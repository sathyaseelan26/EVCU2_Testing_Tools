/*
 * File: THMR_ac.c
 *
 * Code generated for Simulink model 'THMR_ac'.
 *
 * Model version                  : 9.965
 * Simulink Coder version         : 9.4 (R2020b) 29-Jul-2020
 * C/C++ source code generated on : Fri Apr  5 19:40:33 2024
 *
 * Target selection: autosar.tlc
 * Embedded hardware selection: Freescale->MPC55xx
 * Emulation hardware selection:
 *    Differs from embedded hardware (Generic->MATLAB Host Computer)
 * Code generation objectives: Unspecified
 * Validation result: Not run
 */

#include "THMR_ac.h"
#include "look1_iflf_binlcapw.h"
#include "look2_iflf_binlcapw.h"

/* Named constants for Chart: '<S2279>/StateflowChart' */
#define THMR_ac_IN_Extended_Cooling    ((uint8)1U)
#define THMR_ac_IN_NO_ACTIVE_CHILD     ((uint8)0U)
#define THMR_ac_IN_No_Extended_Cooling ((uint8)2U)

/* Named constants for Chart: '<S5430>/Pct_Fan_Req_SF' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd
#define THMR_ac_IN_Fan_Off             ((uint8)1U)
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd
#define THMR_ac_IN_Fan_On              ((uint8)2U)
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd
#define THMR_ac_IN_Fan_On_Timer        ((uint8)3U)
#endif

/* Named constants for Chart: '<S71>/AfterRun' */
#define IN_PlugInCharging_CmndOutOfAftr ((uint8)8U)
#define THMR_ac_IN_AfterRunComplt      ((uint8)1U)
#define THMR_ac_IN_AfterRunInit        ((uint8)2U)
#define THMR_ac_IN_AlternatorMode      ((uint8)3U)
#define THMR_ac_IN_CalNewAfterRunRq    ((uint8)4U)
#define THMR_ac_IN_CommandContactorOpen ((uint8)5U)
#define THMR_ac_IN_DeterminAftrRunRq   ((uint8)6U)
#define THMR_ac_IN_FOTARequested       ((uint8)7U)
#define THMR_ac_IN_RadFanAndPumpCmmnd  ((uint8)9U)
#define THMR_ac_IN_SM_Entry            ((uint8)10U)

/* Named constants for Truth Table: '<S1158>/TruthTable1' */
#define THMR_ac_Eight                  ((uint16)8U)
#define THMR_ac_Five                   ((uint16)5U)
#define THMR_ac_Four                   ((uint16)4U)
#define THMR_ac_Seven                  ((uint16)7U)
#define THMR_ac_Six                    ((uint16)6U)
#define THMR_ac_Three                  ((uint16)3U)
#define THMR_ac_Two                    ((uint16)2U)

/* Named constants for Truth Table: '<S4098>/Batt_Condition' */
#define THMR_ac_Eight_o                ((sint16)8)
#define THMR_ac_Eleven                 ((sint16)11)
#define THMR_ac_Fifteen                ((sint16)15)
#define THMR_ac_Five_f                 ((sint16)5)
#define THMR_ac_Four_m                 ((sint16)4)
#define THMR_ac_Fourteen               ((sint16)14)
#define THMR_ac_Nine                   ((sint16)9)
#define THMR_ac_One                    ((sint16)1)
#define THMR_ac_Seven_c                ((sint16)7)
#define THMR_ac_Six_p                  ((sint16)6)
#define THMR_ac_Ten                    ((sint16)10)
#define THMR_ac_Thirteen               ((sint16)13)
#define THMR_ac_Three_o                ((sint16)3)
#define THMR_ac_Twelve                 ((sint16)12)
#define THMR_ac_Two_h                  ((sint16)2)

/* Named constants for Truth Table: '<S4251>/Cab_Allowed' */
#define THMR_ac_Eighteen               ((sint16)18)
#define THMR_ac_Nineteen               ((sint16)19)
#define THMR_ac_Seventeen              ((sint16)17)
#define THMR_ac_Sixteen                ((sint16)16)
#define THMR_ac_Twenty                 ((sint16)20)
#define THMR_ac_TwentyFour             ((sint16)24)
#define THMR_ac_TwentyOne              ((sint16)21)
#define THMR_ac_TwentyThree            ((sint16)23)
#define THMR_ac_TwentyTwo              ((sint16)22)

/* Named constants for Chart: '<S83>/ThermalMode' */
#define THMR_ac_IN_ActiveCooling       ((uint8)1U)
#define THMR_ac_IN_Balancing           ((uint8)1U)
#define THMR_ac_IN_ChillerNFront       ((uint8)1U)
#define THMR_ac_IN_ChillerOnly         ((uint8)2U)
#define THMR_ac_IN_Cooling             ((uint8)1U)
#define THMR_ac_IN_EvapOnly            ((uint8)3U)
#define THMR_ac_IN_Fault               ((uint8)1U)
#define THMR_ac_IN_Fault_i             ((uint8)2U)
#define THMR_ac_IN_Fault_is            ((uint8)4U)
#define THMR_ac_IN_Heating             ((uint8)3U)
#define THMR_ac_IN_Init                ((uint8)2U)
#define THMR_ac_IN_Off                 ((uint8)4U)
#define THMR_ac_IN_OffPlug             ((uint8)3U)
#define THMR_ac_IN_Off_b               ((uint8)2U)
#define THMR_ac_IN_On                  ((uint8)3U)
#define THMR_ac_IN_OnPlug              ((uint8)4U)
#define THMR_ac_IN_OpenAll             ((uint8)5U)
#define THMR_ac_IN_PassiveCooling      ((uint8)2U)
#define THMR_ac_IN_PumpOff             ((uint8)2U)
#define THMR_ac_IN_Slct                ((uint8)4U)
#define THMR_ac_IN_Sleep               ((uint8)5U)
#define THMR_ac_IN_Standby             ((uint8)6U)
#define THMR_ac_IN_ValveTransition     ((uint8)4U)
#define THMR_ac_IN_VehicleOff          ((uint8)1U)
#define THMR_ac_IN_VehicleOn           ((uint8)2U)

/* Named constants for Chart: '<S950>/ElVlv_3_Way_FuCell_PwrMaxLimTh' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0
#define THMR_IN_STATE6_PWR_LIM_HOLD_DEC ((uint8)7U)
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0
#define THMR__IN_STATE2_PWR_LIM_MONITOR ((uint8)3U)
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0
#define THMR_ac_ConSngNegVal           (1.0F)
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0
#define THMR_ac_ConSngPosVal           (1.0F)
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0
#define THMR_ac_IN_STATE0_PWR_LIM_RESET ((uint8)1U)
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0
#define THMR_ac_IN_STATE1_PWR_LIM_SET  ((uint8)2U)
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0
#define THMR_ac_IN_STATE3_PWR_LIM_DEC  ((uint8)4U)
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0
#define THMR_ac_IN_STATE4_PWR_LIM_INC  ((uint8)5U)
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0
#define THMR_ac_IN_STATE5_PWR_LIM_HOLD ((uint8)6U)
#endif

/* user code (top of source file) */
/*
   PRODUCTION CONFIGURATION
 */

/* Exported data definition */
#define START_SEC_CALIB_UNSPECIFIED_THMR
#include "MemMap.h"

/* Definition for custom storage class: FCALocalParameter */
static volatile CONST(boolean, THMR_VAR_INIT) HeTHMR_b_BattHtrReq_RA = 0;/* Referenced by: '<S3211>/Calib' */
static volatile CONST(TeTMIR_e_ECM_LTP_FanAftRunRq, THMR_VAR_INIT)
    KaTHMR_Cf_AlternatorMode[8] =
{
    CeTMIR_e_No_AftRunRequest, CeTMIR_e_ECM_AftRunRequest_1,
    CeTMIR_e_ECM_AftRunRequest_2, CeTMIR_e_ECM_AftRunRequest_3,
    CeTMIR_e_ECM_AftRunRequest_4, CeTMIR_e_ECM_AftRunRequest_4,
    CeTMIR_e_ECM_AftRunRequest_4, CeTMIR_e_SNA_AftRunRequest
};                                     /* Referenced by: '<S71>/AfterRun' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_Cf_ECM_FanRqAftrRun[8] =
{
    0, 0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S71>/AfterRun' */

static volatile CONST(TeTMIR_e_ECM_LTP_FanAftRunRq, THMR_VAR_INIT)
    KaTHMR_Cf_ECM_LTP_FanAftRunRq[8] =
{
    CeTMIR_e_No_AftRunRequest, CeTMIR_e_ECM_AftRunRequest_1,
    CeTMIR_e_ECM_AftRunRequest_2, CeTMIR_e_ECM_AftRunRequest_3,
    CeTMIR_e_ECM_AftRunRequest_4, CeTMIR_e_ECM_AftRunRequest_5,
    CeTMIR_e_ECM_AftRunRequest_6, CeTMIR_e_SNA_AftRunRequest
};                                     /* Referenced by: '<S71>/AfterRun' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_Cf_HCP_FanRqAftrRun[8] =
{
    0, 1, 1, 1, 1, 1, 1, 0
} ;                                    /* Referenced by: '<S71>/AfterRun' */

static volatile CONST(TeTMIR_e_ECM_LTP_FanAftRunRq, THMR_VAR_INIT)
    KaTHMR_Cf_HCP_LTP_FanAftrRunRq[4] =
{
    CeTMIR_e_No_AftRunRequest, CeTMIR_e_ECM_AftRunRequest_5,
    CeTMIR_e_ECM_AftRunRequest_2, CeTMIR_e_SNA_AftRunRequest
};                                     /* Referenced by: '<S71>/AfterRun' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_Cf_PIM_FanRqAftrRun[8] =
{
    0, 0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S71>/AfterRun' */

static volatile CONST(TeTMIR_e_ECM_LTP_FanAftRunRq, THMR_VAR_INIT)
    KaTHMR_Cf_PIM_LTP_FanAftrRunRq[8] =
{
    CeTMIR_e_No_AftRunRequest, CeTMIR_e_ECM_AftRunRequest_1,
    CeTMIR_e_ECM_AftRunRequest_2, CeTMIR_e_ECM_AftRunRequest_3,
    CeTMIR_e_ECM_AftRunRequest_4, CeTMIR_e_ECM_AftRunRequest_5,
    CeTMIR_e_ECM_AftRunRequest_6, CeTMIR_e_SNA_AftRunRequest
};                                     /* Referenced by: '<S71>/AfterRun' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_Pct_BattRad_Airflow_AGS[5] =
{
    0.0F, 5.0F, 10.0F, 15.0F, 20.0F
} ;                                    /* Referenced by: '<S5451>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT)
    KaTHMR_Pct_BattRad_Airflow_AGSOpen[11] =
{
    20.0F, 28.0F, 36.0F, 44.0F, 52.0F, 60.0F, 68.0F, 76.0F, 84.0F, 92.0F, 100.0F
} ;                                    /* Referenced by: '<S5452>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_Pct_ECM_Airflow_AGS[5] =
{
    0.0F, 5.0F, 10.0F, 15.0F, 20.0F
} ;                                    /* Referenced by: '<S5465>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_Pct_ECM_Airflow_AGSOpen[11]
    =
{
    20.0F, 28.0F, 36.0F, 44.0F, 52.0F, 60.0F, 68.0F, 76.0F, 84.0F, 92.0F, 100.0F
} ;                                    /* Referenced by: '<S5466>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_Pct_FC_HTR_Airflow_AGS[5] =
{
    0.0F, 5.0F, 10.0F, 15.0F, 20.0F
} ;                                    /* Referenced by: '<S5472>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_Pct_FC_HTR_Airflow_AGSOpen
    [11] =
{
    20.0F, 28.0F, 36.0F, 44.0F, 52.0F, 60.0F, 68.0F, 76.0F, 84.0F, 92.0F, 100.0F
} ;                                    /* Referenced by: '<S5473>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_Pct_HeadPres_Airflow_AGS[5]
    =
{
    0.0F, 5.0F, 10.0F, 15.0F, 20.0F
} ;                                    /* Referenced by: '<S5458>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KaTHMR_Pct_HeadPres_Airflow_AGSOpen[11] =
{
    20.0F, 28.0F, 36.0F, 44.0F, 52.0F, 60.0F, 68.0F, 76.0F, 84.0F, 92.0F, 100.0F
} ;                                    /* Referenced by: '<S5459>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_Pct_LTR_Airflow_AGS[5] =
{
    0.0F, 5.0F, 10.0F, 15.0F, 20.0F
} ;                                    /* Referenced by: '<S5479>/Calib' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_Pct_LTR_Airflow_AGSOpen[11]
    =
{
    20.0F, 28.0F, 36.0F, 44.0F, 52.0F, 60.0F, 68.0F, 76.0F, 84.0F, 92.0F, 100.0F
} ;                                    /* Referenced by: '<S5480>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_P1MotorReqDsbl

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_Pct_P1Motor_Airflow_AGS[5] =
{
    0.0F, 5.0F, 10.0F, 15.0F, 20.0F
} ;                                    /* Referenced by: '<S5495>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_P1MotorReqDsbl

static volatile CONST(float32, THMR_VAR_INIT)
    KaTHMR_Pct_P1Motor_Airflow_AGSOpen[11] =
{
    20.0F, 28.0F, 36.0F, 44.0F, 52.0F, 60.0F, 68.0F, 76.0F, 84.0F, 92.0F, 100.0F
} ;                                    /* Referenced by: '<S5496>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_Pct_PPU_Airflow_AGS[5] =
{
    0.0F, 5.0F, 10.0F, 15.0F, 20.0F
} ;                                    /* Referenced by: '<S5502>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_Pct_PPU_Airflow_AGSOpen[11]
    =
{
    20.0F, 28.0F, 36.0F, 44.0F, 52.0F, 60.0F, 68.0F, 76.0F, 84.0F, 92.0F, 100.0F
} ;                                    /* Referenced by: '<S5503>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_T_TmpMinAllwBsdOnPrrty[16] =
{
    -10.0F, 17.0F, 17.0F, 17.0F, -10.0F, -10.0F, -10.0F, -10.0F, -10.0F, -40.0F,
    -10.0F, -10.0F, -10.0F, -10.0F, -10.0F, -10.0F
} ;                                    /* Referenced by: '<S380>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_BattActvCoolDsbl_RA[20] =
{
    0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S4526>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_BattActvHeatDsbl_RA[20] =
{
    0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S4527>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_BattActvPsvHeatDsbl_RA[20]
    =
{
    0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S4528>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_BattConditioning[10] =
{
    1, 1, 1, 0, 1, 1, 1, 1, 0, 0
} ;                                    /* Referenced by: '<S4213>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_BattCoolArray[15] =
{
    0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0
} ;                                    /* Referenced by: '<S4214>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_BattHeatArray[15] =
{
    1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0
} ;                                    /* Referenced by: '<S4215>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_BattPsvCoolDsbl_RA[20] =
{
    0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S4529>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_BattPsvHeatDsbl_RA[20] =
{
    0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S4530>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_BattRad_AGS[7] =
{
    0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S5586>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_BattRad_FanPWM[7] =
{
    0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S5587>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT)
    KaTHMR_b_BattWasteHeatRcvryDsbl_RA[20] =
{
    0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S4531>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_CabActvHeatDsbl_RA[20] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S4532>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_CabActvPsvHeatDsbl_RA[20]
    =
{
    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S4533>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_CabAllowedArray[24] =
{
    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0
} ;                                    /* Referenced by: '<S4315>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_EDUWasteHeatRcvryDsbl_RA
    [20] =
{
    0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S4534>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_FCCondAllwArray[13] =
{
    1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S4394>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_FCCondAllwArray_NewLogic
    [10] =
{
    1, 0, 0, 1, 0, 1, 1, 1, 0, 0
} ;                                    /* Referenced by: '<S4395>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_HTR_AGS[7] =
{
    0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S5588>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_HTR_FanPWM[7] =
{
    0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S5589>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_HeatPumpDsbl_RA[20] =
{
    0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1
} ;                                    /* Referenced by: '<S4535>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_LTR_AGS[7] =
{
    0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S5590>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_LTR_FanPWM[7] =
{
    0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S5591>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_SolitaryOrCndnsr_AGS[7] =
{
    0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S5592>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_SolitaryOrCndnsr_FanPWM[7]
    =
{
    0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S5593>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_b_WCondLTRSuppDsbl_RA[20] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S4536>/Calib' */

static volatile CONST(sint16, THMR_VAR_INIT) KaTHMR_e_CabPrecReqStMap[16] =
{
    0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 15
} ;                                    /* Referenced by: '<S329>/Calib' */

static volatile CONST(TeTHMR_e_HTCL_Heat_Distrib, THMR_VAR_INIT)
    KaTHMR_e_HTCL_Heat_Distrib[8] =
{
    CeTHMR_e_NoHeating, CeTHMR_e_BatteryHeating, CeTHMR_e_CabinHeating,
    CeTHMR_e_BatteryNCabinHeating, CeTHMR_e_Faulted, CeTHMR_e_NoHeating,
    CeTHMR_e_NoHeating, CeTHMR_e_NoHeating
};                                     /* Referenced by: '<S1828>/Calib' */

static volatile CONST(uint8, THMR_VAR_INIT) KaTHMR_i_Branch1Map[19] =
{
    0U, 0U, 1U, 1U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 1U, 0U, 0U, 0U, 0U, 0U, 0U, 1U
} ;                                    /* Referenced by: '<S3004>/Calib' */

static volatile CONST(uint8, THMR_VAR_INIT) KaTHMR_i_Branch2Map[19] =
{
    0U, 0U, 0U, 0U, 1U, 0U, 1U, 0U, 0U, 0U, 1U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 1U
} ;                                    /* Referenced by: '<S3005>/Calib' */

static volatile CONST(uint8, THMR_VAR_INIT) KaTHMR_i_Branch3Map[19] =
{
    0U, 0U, 0U, 0U, 0U, 1U, 0U, 0U, 0U, 1U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U
} ;                                    /* Referenced by: '<S3006>/Calib' */

static volatile CONST(uint8, THMR_VAR_INIT) KaTHMR_i_BrchFlwMap_EDMheatEstm[3] =
{
    0U, 1U, 2U
} ;                                    /* Referenced by: '<S2417>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_i_ERLv1_Branch1Select[13] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S2487>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_i_ERLv1_Branch2Select[13] =
{
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
} ;                                    /* Referenced by: '<S2488>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_i_ERLv1_Branch3Select[13] =
{
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
} ;                                    /* Referenced by: '<S2489>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_i_ERLv2_Branch1Select[45] =
{
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
} ;                                    /* Referenced by: '<S2571>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_i_ERLv2_Branch2Select[45] =
{
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
} ;                                    /* Referenced by: '<S2572>/Calib' */

static volatile CONST(boolean, THMR_VAR_INIT) KaTHMR_i_ERLv2_Branch3Select[45] =
{
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
} ;                                    /* Referenced by: '<S2573>/Calib' */

static volatile CONST(uint16, THMR_VAR_INIT) KaTHMR_i_Initial13Array[16] =
{
    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U
} ;                                    /* Referenced by: '<S383>/Calib' */

static volatile CONST(uint8, THMR_VAR_INIT) KaTHMR_i_RearFrontGEN_HeatFlwTgt[3] =
{
    0U, 1U, 2U
} ;                                    /* Referenced by:
                                        * '<S2418>/Calib'
                                        * '<S2870>/Calib'
                                        */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_AkalmanBTLMBC[9] =
{
    0.949596524F, 0.0915239304F, -0.383158982F, -0.0698366091F, 1.00608313F,
    -0.067382F, 0.335645109F, 0.216503352F, 0.3592287F
} ;                                    /* Referenced by: '<S3129>/Constant' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_AkalmanMBC1[36] =
{
    1.99705756F, 1.0F, 0.0F, 0.0F, 0.0F, 0.0F, -0.997085035F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 1.72064388F, 1.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    -0.721535504F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.37827265F, 0.5F,
    0.0F, 0.0F, 0.0F, 0.0F, -0.769472659F, 0.0F
} ;                                    /* Referenced by: '<S2034>/Constant' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_AkalmanMLTLMBC[9] =
{
    0.735537112F, 0.0300964471F, -0.221127599F, 0.185774922F, 0.87814337F,
    0.240014985F, -0.558029294F, -0.317368388F, 0.366565496F
} ;                                    /* Referenced by: '<S3021>/Constant' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_Akalman_MBCHTLLTL[9] =
{
    0.4827F, 0.1384F, 0.6416F, -0.1225F, 1.281F, 0.5259F, -0.06118F, -0.5888F,
    0.4484F
} ;                                    /* Referenced by: '<S3232>/Constant' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_BkalmanBTLMBC[12] =
{
    115.459846F, 38.7095833F, -81.8479843F, -0.00676831324F, -0.0019991002F,
    0.00375350425F, 0.0719874129F, 0.0221291166F, -0.0432752185F, 2.09468603F,
    0.411890835F, -0.361847937F
} ;                                    /* Referenced by: '<S3129>/Gain1' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_BkalmanMBC1[24] =
{
    0.001953125F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2034>/Gain1' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_BkalmanMLTLMBC[15] =
{
    4.0566385E-5F, 1.89376351E-5F, 4.19924545E-5F, 6.03376691E-7F,
    8.60613284E-7F, 6.53145946E-7F, 0.00154699525F, 0.000932288182F,
    0.00140517415F, -0.311102033F, -0.177846074F, -0.311309904F, -0.022153208F,
    -0.0096561471F, -0.0236004051F
} ;                                    /* Referenced by: '<S3021>/Gain1' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_Bkalman_MBCHTLLTL[30] =
{
    -2.556E-5F, 3.175E-5F, 5.667E-5F, 3.751E-5F, -6.917E-5F, -0.0001059F,
    5.279E-5F, -0.002449F, -0.002374F, 1.113E-5F, 2.088E-5F, 5.699E-6F,
    1.742E-5F, -3.559E-5F, -5.611E-5F, -0.001069F, 0.005113F, 0.005605F,
    0.007467F, -0.04344F, -0.02106F, -0.0002779F, 0.0001605F, 0.0005233F,
    -0.002702F, -0.03239F, -0.02694F, -0.06438F, 0.319F, 0.3748F
} ;                                    /* Referenced by: '<S3232>/Gain1' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_CkalmanBTLMBC[3] =
{
    -9.37879467F, 63.9703369F, 16.8357506F
} ;                                    /* Referenced by: '<S3129>/Gain2' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_CkalmanMBC1[6] =
{
    -0.0013F, 0.0012F, -0.4661F, 0.4731F, -0.5984F, 1.2025F
} ;                                    /* Referenced by: '<S2034>/Gain2' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_CkalmanMLTLMBC[3] =
{
    92.4993515F, 31.2952862F, -77.3780212F
} ;                                    /* Referenced by: '<S3021>/Gain2' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_Ckalman_MBCHTLLTL[6] =
{
    -35.23F, -36.64F, -8.397F, 59.2F, -11.43F, -28.82F
} ;                                    /* Referenced by: '<S3232>/Gain2' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLGGPumpMBC1[7] =
{
    10.0621F, -9.9354F, -0.0031F, -0.0007F, 0.0008F, -0.0079F, 0.0599F
} ;                                    /* Referenced by: '<S2076>/Calib' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLGGPumpMBC2[7] =
{
    -0.0031F, 0.0031F, 0.0464F, -0.0236F, 0.0052F, 0.0196F, -1.954F
} ;                                    /* Referenced by: '<S2077>/Calib' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLQGBTLHtrMBC[4] =
{
    1.76203573F, -11.7489157F, -3.08400726F, 0.0476348773F
} ;                                    /* Referenced by: '<S3150>/Calib' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLQGBTLPumpMBC[4] =
{
    33029.4063F, -221090.156F, -58032.3281F, 902.937317F
} ;                                    /* Referenced by: '<S3151>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLQGECH_MBCHTLLTL[5] =
{
    -0.053791672F, 0.00424158853F, -0.00708087347F, -0.000626021065F,
    -0.000139593045F
} ;                                    /* Referenced by: '<S3315>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLQGFANMBC[4] =
{
    -2.02419162F, -0.122916862F, 1.94408476F, 0.0303301625F
} ;                                    /* Referenced by: '<S3058>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLQGFan_MBCHTLLTL[5] =
{
    15.6051006F, -30.5608425F, 21.1815243F, -0.00710071204F, 0.174121857F
} ;                                    /* Referenced by: '<S3316>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLQGHCP_MBCHTLLTL[5] =
{
    699.524048F, -169.563934F, 148.60379F, 7.67202044F, 2.57594538F
} ;                                    /* Referenced by: '<S3317>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLQGHtrMBCECO[7] =
{
    -0.0031F, 0.0031F, 0.0464F, -0.0236F, 0.0052F, 0.0196F, -1.954F
} ;                                    /* Referenced by: '<S2078>/Calib' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLQGLTLVMBC[4] =
{
    146.992783F, -0.139442578F, -138.980225F, -1.67928457F
} ;                                    /* Referenced by: '<S3059>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLQGLTRVlv_MBCHTLLTL[5] =
{
    -1.00120807F, 2.22858977F, -1.28304911F, -0.0015225336F, -0.015709186F
} ;                                    /* Referenced by: '<S3318>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLQGPCEP1MBC[4] =
{
    -1022.06561F, 328.452F, 878.752563F, -5.08109093F
} ;                                    /* Referenced by: '<S3060>/Calib' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLQGPCEP2MBC[4] =
{
    18272.3926F, 2775.4585F, -17893.7363F, -385.181274F
} ;                                    /* Referenced by: '<S3061>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLQGPECP1_MBCHTLLTL[5] =
{
    351.626556F, 166.574127F, -56.8139267F, 4.99360037F, -0.285263598F
} ;                                    /* Referenced by: '<S3319>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLQGPECP2_MBCHTLLTL[5] =
{
    295.672882F, -80.1902542F, 61.6944771F, 3.28653049F, 1.21594131F
} ;                                    /* Referenced by: '<S3320>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLQGPumpMBCECO[7] =
{
    10.0621F, -9.9354F, -0.0031F, -0.0007F, 0.0008F, -0.0079F, 0.0599F
} ;                                    /* Referenced by: '<S2079>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_KLQGVHTL_MBCHTLLTL[5] =
{
    -0.773258924F, -1.20415735F, 0.545381546F, -0.0145118646F, 0.00611171732F
} ;                                    /* Referenced by: '<S3321>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[7] =
{
    0.28072F, 1.1163F, 1.1355F, 1.0996F, 0.99066F, 0.45721F, 0.64476F
} ;                                    /* Referenced by: '<S2768>/Calib' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_LkalmanBTLMBC[3] =
{
    0.000176884059F, 5.52738893E-5F, -0.000109807719F
} ;                                    /* Referenced by: '<S3128>/Calib' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_LkalmanMBC1[6] =
{
    -8.0E-6F, -8.0E-6F, 0.11433F, 0.12139F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2033>/Calib' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_LkalmanMLTLMBC[3] =
{
    0.000905959401F, 0.000736719056F, 0.000904001F
} ;                                    /* Referenced by: '<S3020>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_Lkalman_MBCHTLLTL[6] =
{
    5.50067598E-5F, -0.000160027892F, -0.0002145865F, -0.000162458804F,
    0.000321989879F, 0.000509586069F
} ;                                    /* Referenced by: '<S3231>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_PLTLC[10] =
{
    0.7389F, 0.125F, 0.1586F, 1.0799F, 1.1922F, 0.1181F, 6.3448F, 20.607F,
    1.0953F, 0.92084F
} ;                                    /* Referenced by: '<S3072>/Calib' */

static volatile CONST(float32, THMR_VAR_INIT) KaTHMR_k_WLTL[2] =
{
    1.0F, 1.0F
} ;                                    /* Referenced by: '<S3073>/Calib' */

static volatile CONST(uint16, THMR_VAR_INIT) KaTHMR_t_AfterRunTimeForRq[7] =
{
    0U, 180U, 360U, 600U, 900U, 0U, 0U
} ;                                    /* Referenced by: '<S71>/AfterRun' */

static volatile CONST(uint8, THMR_VAR_INIT) KaTHMR_y_HTAP_TempSrcPriority[3] =
{
    0U, 2U, 1U
} ;                                    /* Referenced by: '<S1925>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(uint8, THMR_VAR_INIT) KaTHMR_y_RearFrontEDM_MtrClng[3] =
{
    0U, 1U, 2U
} ;                                    /* Referenced by: '<S709>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cf_Bar2KPa = 100.0F;/* Referenced by: '<S2164>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cf_Bar2KPa_OEXVOutPres =
    100.0F;                            /* Referenced by: '<S266>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cf_CtoK = 273.15F;/* Referenced by: '<S2419>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cf_FanAFCnvsn_MBCHTLLTL =
    35.3147F;                          /* Referenced by: '<S3252>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cf_HtrPwrCnvsn_MBCHTLLTL =
    1000.0F;                           /* Referenced by: '<S3233>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cf_HtrPwrMBCCnvsn = 1000.0F;/* Referenced by:
                                                                      * '<S2035>/Calib'
                                                                      * '<S3130>/Calib'
                                                                      */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cf_LTLFanAFConfctr =
    35.3147F;                          /* Referenced by: '<S3029>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Cf_LTRVlv_degCtoKTempConvert = 273.0F;/* Referenced by:
                                                  * '<S2796>/Calib'
                                                  * '<S2797>/Calib'
                                                  * '<S2798>/Calib'
                                                  */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cf_SuctionPressCnvrsFctr =
    0.0F;                              /* Referenced by: '<S2169>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cf_VehSpdCnvsn_MBCHTLLTL =
    0.621371F;                         /* Referenced by: '<S3234>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cf_VehSpdMBCCnvsn =
    0.621371F;                         /* Referenced by: '<S3131>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Cf_VlmtrcFlwAddtn_CrrctnFctr = 1.0F;/* Referenced by: '<S2806>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_Cnt_AmbTempDebnc_Tim = 1U;/* Referenced by: '<S21>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT)
    KeTHMR_Cnt_BattPriority_KeepBattCond = 600U;/* Referenced by: '<S412>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cnt_BattPsvCoolDbnc = 5.0F;/* Referenced by: '<S4803>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cnt_BattPsvHeatDbnc = 30.0F;/* Referenced by:
                                                                      * '<S4644>/Calib'
                                                                      * '<S4691>/Calib'
                                                                      * '<S4704>/Calib'
                                                                      */
static volatile CONST(uint16, THMR_VAR_INIT)
    KeTHMR_Cnt_CabPriorty_DsblBattCondDbnc = 1200U;/* Referenced by: '<S438>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT)
    KeTHMR_Cnt_CabPriorty_EnblBattCondDbnc = 100U;/* Referenced by: '<S432>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cnt_CabPsvHeatDbnc = 30.0F;/* Referenced by: '<S4938>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cnt_CoFuCellHiTInSpPredFf_C
    = 6.0F;                            /* Referenced by: '<S989>/Calib' */

#endif

static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_Cnt_EmergencyRun_DbncTime =
    1U;                                /* Referenced by: '<S2732>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_Cnt_EngOff_LH_Waittime = 5U;/* Referenced by: '<S4564>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_Cnt_FCActvPsvHeatDbnc = 5U;/* Referenced by: '<S5097>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_Cnt_FCAirflwStblzDbnc = 30U;/* Referenced by: '<S872>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_Cnt_FCDeratePreHeatDebounce =
    20U;                               /* Referenced by: '<S4396>/Calib' */

#endif

static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_Cnt_FCHeatStblzDbnc = 30U;/* Referenced by: '<S1333>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cnt_FCSDerateDebounce =
    100.0F;                            /* Referenced by: '<S799>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cnt_InitCount = 20.0F;/* Referenced by: '<S83>/ThermalMode' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Cnt_InitDlyTCoSenElVlv3WayFuCellCtl_C = 10.0F;/* Referenced by: '<S1025>/Calib' */

#endif

static volatile CONST(uint16, THMR_VAR_INIT)
    KeTHMR_Cnt_LTCLCool_InhbtPsvHeatStates = 10U;/* Referenced by:
                                                  * '<S4962>/Calib'
                                                  * '<S4672>/Calib'
                                                  * '<S4724>/Calib'
                                                  */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cnt_LTRVlv_SlvrMaxIter =
    10000.0F;                          /* Referenced by: '<S2769>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_Cnt_PsvCool_Dbnc = 3U;/* Referenced by:
                                                                      * '<S4848>/Calib'
                                                                      * '<S4890>/Calib'
                                                                      */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cnt_RSVCount = 1.0F;/* Referenced by: '<S83>/ThermalMode' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Cnt_SampleFuCellHiTInSpGrd_C = 4.0F;/* Referenced by: '<S990>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cnt_SampleFuCellHiToutGrd_C
    = 20.0F;                           /* Referenced by: '<S966>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cnt_WCondLTRSupp_Dbnc =
    30.0F;                             /* Referenced by: '<S5225>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Cnt_dbncBTCLFlw4TempUpdt =
    50.0F;                             /* Referenced by: '<S4804>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_RacePrepCrrntLim

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_I_ChargeCurrentLim_NF =
    99999.0F;                          /* Referenced by: '<S3735>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_I_ChrgCrntReqDelta_D = 0.0F;/* Referenced by: '<S539>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_RacePrepCrrntLim

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_I_RacePrepMaxCurrentOvrd =
    99999.0F;                          /* Referenced by: '<S3736>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_BTLVlvPICont_Ki = 1.5F;/* Referenced by: '<S2328>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_BTLVlvPICont_Kp = 2.5F;/* Referenced by: '<S2329>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_COPNominalHP = 2.5F;/* Referenced by: '<S4991>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_CritCOPDeltaDeIcing_LSP =
    1.2F;                              /* Referenced by: '<S4992>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_CritCOPDeltaDeIcing_RSP =
    1.2F;                              /* Referenced by: '<S4993>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_FCHEXBrnchFlwRatio = 0.3F;/* Referenced by: '<S843>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_FCSDerateKd = 0.0F;/* Referenced by: '<S827>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_FCSDerateKi = 0.0F;/* Referenced by: '<S828>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_FCSDerateKp = 0.0F;/* Referenced by: '<S829>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_FCWCACBrnchFlwRatio =
    0.3F;                              /* Referenced by: '<S893>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_HTCLTempMitgatn_Kd = 0.0F;/* Referenced by: '<S1429>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_HTCLTempMitgatn_Ki =
    10.0F;                             /* Referenced by: '<S1430>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_HTCLTempMitgatn_Kp =
    1500.0F;                           /* Referenced by: '<S1431>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_HTCVPICont_Ki = 1.5F;/* Referenced by: '<S1358>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_HTCVPICont_Kp = 2.5F;/* Referenced by: '<S1359>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_HTLVlvPICont_Ki = 1.5F;/* Referenced by: '<S2011>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_HTLVlvPICont_Kp = 2.5F;/* Referenced by: '<S2012>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_LTRVlvBalncing_Kd = 0.0F;/* Referenced by: '<S2770>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_LTRVlvBalncing_Ki = 0.0F;/* Referenced by: '<S2771>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_LTRVlvBalncing_Kp = 20.0F;/* Referenced by: '<S2772>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_LTRVlv_LTCLFlowActConvert
    = 1.0F;                            /* Referenced by: '<S2795>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_MtrPwrLossFilt = 0.5F;/* Referenced by: '<S657>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_Reg_HtrPwr_Ki_M10 = 0.0F;/* Referenced by: '<S1291>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_Reg_HtrPwr_Ki_M11 = 0.0F;/* Referenced by: '<S1293>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_Reg_HtrPwr_Ki_M14 = 0.0F;/* Referenced by: '<S1295>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_Reg_HtrPwr_Ki_M15 = 0.0F;/* Referenced by: '<S1297>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_Reg_HtrPwr_Ki_M3 = 0.0F;/* Referenced by: '<S1299>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_Reg_HtrPwr_Ki_M7 = 0.0F;/* Referenced by: '<S1301>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_Reg_HtrPwr_Kp_M10 = 0.0F;/* Referenced by: '<S1292>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_Reg_HtrPwr_Kp_M11 = 0.0F;/* Referenced by: '<S1294>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_Reg_HtrPwr_Kp_M14 = 0.0F;/* Referenced by: '<S1296>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_Reg_HtrPwr_Kp_M15 = 0.0F;/* Referenced by: '<S1298>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_Reg_HtrPwr_Kp_M3 = 0.0F;/* Referenced by: '<S1300>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_K_Reg_HtrPwr_Kp_M7 = 0.0F;/* Referenced by: '<S1302>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_M_MtrA_TorqAchievedDial =
    0.0F;                              /* Referenced by: '<S3756>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_M_MtrA_TorqCmndDial = 0.0F;/* Referenced by: '<S3758>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_M_MtrB_TorqAchievedDial =
    0.0F;                              /* Referenced by: '<S3763>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_M_MtrB_TorqCmndDial = 0.0F;/* Referenced by: '<S3765>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_M_MtrC_TorqAchievedDial =
    0.0F;                              /* Referenced by: '<S3770>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_M_MtrC_TorqCmndDial = 0.0F;/* Referenced by: '<S3772>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ActvPwr_htrReqMin =
    500.0F;                            /* Referenced by:
                                        * '<S1778>/Calib'
                                        * '<S1755>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ActvTotPwr_Max = 10000.0F;/* Referenced by: '<S1695>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ActvTotPwr_Min = 150.0F;/* Referenced by: '<S1696>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_AdjWshd_BattHtrPwr =
    999999.0F;                         /* Referenced by: '<S3195>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_AvalPwrForThmr_Dial =
    0.0F;                              /* Referenced by: '<S546>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_BCHPwr_HtrReqMin = 600.0F;/* Referenced by: '<S3180>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_BCH_ActWhsdPwr_Max = 0.0F;/* Referenced by: '<S3181>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_BCH_ActWhsdPwr_Min = 0.0F;/* Referenced by: '<S3182>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_BattHeatPwrTgt_Max =
    7000.0F;                           /* Referenced by: '<S3187>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_BattHeatPwrTgt_Min = 0.0F;/* Referenced by: '<S3188>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_BattHeatPwrTgt_MinOn =
    0.0F;                              /* Referenced by: '<S3166>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_BattHeatPwr_TgtZero =
    0.0F;                              /* Referenced by: '<S3167>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_BattHtrPwr_PerwUP_D =
    0.0F;                              /* Referenced by: '<S3191>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_BattHtr_PwrMin = 0.0F;/* Referenced by: '<S3168>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_BattHtr_Pwr_RA = 0.0F;/* Referenced by: '<S3212>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_CabHeatPwrNeed_Max =
    10000.0F;                          /* Referenced by: '<S1223>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_CabHeatPwrNeed_Min = 0.0F;/* Referenced by: '<S1224>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_CabHtrPwrNeed_Max =
    7000.0F;                           /* Referenced by: '<S1305>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_CabHtrPwrNeed_Min = 0.0F;/* Referenced by: '<S1306>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_CabPwrNeed_NoFlow = 0.0F;/* Referenced by: '<S1225>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_Cab_N_Bat_HeatPwrTot_Max =
    15000.0F;                          /* Referenced by: '<S1948>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_Cab_N_Bat_HeatPwrTot_Min =
    2000.0F;                           /* Referenced by: '<S1949>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ChrgBudgetMinHeat =
    1500.0F;                           /* Referenced by: '<S5298>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_DGrdLimitBTLHtrMBC =
    -20.0F;                            /* Referenced by: '<S3132>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_DGrdLimitECH_MBCHTLLTL =
    -20.0F;                            /* Referenced by: '<S3253>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_DGrdLimitHTLHtrMBC1 =
    -20.0F;                            /* Referenced by: '<S2036>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_DGrdLimitHTLHtrMBC2 =
    -20.0F;                            /* Referenced by: '<S2037>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_Deflt_PwrLimit = 7000.0F;/* Referenced by: '<S4552>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_DfltAirHtrPwrTgt = 0.0F;/* Referenced by: '<S1314>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ECH_ActWhsdPwr_Min =
    150.0F;                            /* Referenced by:
                                        * '<S1779>/Calib'
                                        * '<S1756>/Calib'
                                        */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ECH_HtrPwrTgt_Dial = 0.0F;/* Referenced by: '<S2203>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ECH_HtrPwrTgt_Max_e =
    10000.0F;                          /* Referenced by: '<S1637>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ECH_HtrPwrTgt_Min_e =
    0.0F;                              /* Referenced by: '<S1638>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ECH_PwrLow = 5000.0F;/* Referenced by: '<S1744>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ECH_PwrMax = 7000.0F;/* Referenced by: '<S1745>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ECH_WishdPwr_Up = 1000.0F;/* Referenced by: '<S1764>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_EDURawWasteHeat_Batt_MaxLim = 600.0F;/* Referenced by: '<S4645>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_EDURawWasteHeat_Batt_MinLim = 200.0F;/* Referenced by: '<S4646>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_EDURawWasteHeat_Cab_MaxLim = 600.0F;/* Referenced by: '<S4939>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_EDURawWasteHeat_Cab_MinLim = 200.0F;/* Referenced by: '<S4940>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_EDUheat_Batt_Assist_Max =
    6000.0F;                           /* Referenced by: '<S2447>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_EDUheat_Batt_Assist_RtLimDown = -500.0F;/* Referenced by: '<S2458>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_EDUheat_Batt_Assist_RtLimUp = 200.0F;/* Referenced by: '<S2459>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_EDUheat_Cabin_Assist_Max =
    6000.0F;                           /* Referenced by: '<S2449>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_EDUheat_Cabin_Assist_RtLimDown = -500.0F;/* Referenced by: '<S2462>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_EDUheat_Cabin_Assist_RtLimUp = 200.0F;/* Referenced by: '<S2463>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_EngHotPwr_Min = 0.0F;/* Referenced by:
                                                                      * '<S1561>/Calib'
                                                                      * '<S4941>/Calib'
                                                                      * '<S4630>/Calib'
                                                                      */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_EngPower_EngHot_Th =
    20.0F;                             /* Referenced by: '<S1876>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_EngPwrWaste_AvailMin =
    0.0F;                              /* Referenced by: '<S1697>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ExtraHVACPwr = 100.0F;/* Referenced by: '<S1698>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_FCMinOnPwr = 1.0F;/* Referenced by: '<S4109>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_FCSDeratePwr_IV = 0.0F;/* Referenced by: '<S830>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_FuCellMaxLimThMaxDft_C =
    25000.0F;                          /* Referenced by: '<S1041>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_FuCellMaxLimThMax_C =
    60000.0F;                          /* Referenced by: '<S1042>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_FuCellMaxLimThMin_C =
    5000.0F;                           /* Referenced by: '<S1043>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_FuCellMin_C = 1000.0F;/* Referenced by: '<S952>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_HCCTISErr_IV = 0.0F;/* Referenced by: '<S1307>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_HCCTIS_MinPwr = 2000.0F;/* Referenced by: '<S1247>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_HTCLTempMitgatn_MaxPwr =
    7000.0F;                           /* Referenced by: '<S1432>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_HVWHFuCellPreHeatMinWaPmp_C = 300.0F;/* Referenced by: '<S907>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_HeatPwrTgt_Min = 0.0F;/* Referenced by: '<S1413>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_HeatPwrTgt_MinOn = -1.0F;/* Referenced by: '<S1414>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_HghRfrgtPres_Dial = 0.0F;/* Referenced by: '<S2165>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_HghSOC_LwTmp_Pwr =
    1500.0F;                           /* Referenced by: '<S1721>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_Htr2Flty_ExpctdPwr = 0.0F;/* Referenced by: '<S1699>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_Htr2PwrTgt_Dial = 0.0F;/* Referenced by: '<S2179>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_Htr3PwrTgt_Dial = 0.0F;/* Referenced by: '<S2187>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_Htr4PwrTgt_Dial = 0.0F;/* Referenced by: '<S2195>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_HtrOff_ActvPwrMax = 0.0F;/* Referenced by: '<S1562>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MaxAntWdBTLHtrMBC = 7.5F;/* Referenced by: '<S3152>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MaxAntWdECH_MBCHTLLTL =
    7.0F;                              /* Referenced by: '<S3322>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MaxAntWdHtrMBC1 = 10.0F;/* Referenced by: '<S2038>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MaxBTLHtrMBC = 7.0F;/* Referenced by: '<S3133>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MaxHTLHtrMBC1 = 7.0F;/* Referenced by: '<S2039>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MaxHTLHtrMBC2 = 7.0F;/* Referenced by: '<S2040>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MaxLimitECH_MBCHTLLTL =
    7.0F;                              /* Referenced by: '<S3254>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MinAllwdFCSDeratePwr =
    10.0F;                             /* Referenced by:
                                        * '<S817>/Calib'
                                        * '<S836>/Calib'
                                        */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MinAntWdBTLHtrMBC = 0.0F;/* Referenced by: '<S3153>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MinAntWdECH_MBCHTLLTL =
    0.0F;                              /* Referenced by: '<S3323>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MinAntWdHtrMBC1 = 0.0F;/* Referenced by: '<S2041>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MinBTLHtrMBC = 0.0F;/* Referenced by: '<S3134>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_MinEDMHeatGen_FrClntHeatAbsrb = 0.0F;/* Referenced by: '<S2420>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MinFlw_CabHtrPwr_Max =
    1000.0F;                           /* Referenced by: '<S1248>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MinFlw_CabHtrPwr_Min =
    0.0F;                              /* Referenced by: '<S1249>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MinFlw_HCCTISErr_IV =
    0.0F;                              /* Referenced by: '<S1250>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MinHTLHtrMBC1 = 0.0F;/* Referenced by: '<S2042>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MinHTLHtrMBC2 = 0.0F;/* Referenced by: '<S2043>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MinLimitECH_MBCHTLLTL =
    0.0F;                              /* Referenced by: '<S3255>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MtrAPowerLimit = 100.0F;/* Referenced by: '<S3447>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MtrA_ElecPwrCalc_TotDial =
    0.0F;                              /* Referenced by: '<S3778>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MtrBPowerLimit = 100.0F;/* Referenced by: '<S3513>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MtrB_ElecPwrCalc_TotDial =
    0.0F;                              /* Referenced by: '<S3787>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MtrCPowerLimit = 100.0F;/* Referenced by: '<S3586>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_MtrC_ElecPwrCalc_TotDial =
    0.0F;                              /* Referenced by: '<S3790>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_NoFCSDerate_Pwr =
    9.999999E+6F;                      /* Referenced by: '<S818>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_OV_CabinHeatPwr_Need =
    50.0F;                             /* Referenced by: '<S1233>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_OvrrdWishedHtrPwr = 6.0F;/* Referenced by: '<S1731>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblRA_BattCoolingFlt_PsvCool

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_PressSnsrThLo_AllwRA4PsvCool = 2800.0F;/* Referenced by: '<S294>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblRA_BattCoolingFlt_PsvCool

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_PressSnsrThLo_RejectRA4PsvCool = 2500.0F;/* Referenced by: '<S295>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_PwrBdgt_BattHtrReqMin =
    600.0F;                            /* Referenced by: '<S3183>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_PwrBdgt_PwrLimitAvail_D =
    0.0F;                              /* Referenced by: '<S201>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_P_PwrBdgt_PwrLimitAvail_SD =
    0;                                 /* Referenced by: '<S202>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_PwrBdgt_htrReqMin =
    500.0F;                            /* Referenced by:
                                        * '<S1780>/Calib'
                                        * '<S1757>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_PwrBudgt_LowThrsh = 0.0F;/* Referenced by: '<S4291>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_PwrHtrOff = 0.0F;/* Referenced by: '<S1546>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_PwrLimitMargin_Dial =
    800.0F;                            /* Referenced by: '<S1700>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_RU_ThermalPwrLim_tst =
    7.0F;                              /* Referenced by: '<S5299>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_RatEAC_PwrBdgt_Avail_D =
    0.0F;                              /* Referenced by: '<S203>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_RearHeatPwrTgt_MinOn =
    200.0F;                            /* Referenced by: '<S1415>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_Reg_HCCTIS_MinPwr =
    1000.0F;                           /* Referenced by: '<S1308>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_Reg_HtrNeed_MaxPwr_AntiWindup = 7000.0F;/* Referenced by: '<S1311>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_Reg_HtrNeed_MinPwr_AntiWindup = 0.0F;/* Referenced by: '<S1312>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ThrmlBattPwrLimit_Min =
    4.0F;                              /* Referenced by: '<S4553>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ThrmlPrwAvail_Low = 50.0F;/* Referenced by:
                                                                      * '<S4353>/Calib'
                                                                      * '<S4375>/Calib'
                                                                      */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ThrmlPrwAvail_LowBattCond
    = 1000.0F;                         /* Referenced by: '<S4354>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_ThrmlPrwAvail_LowNoBattCond = 500.0F;/* Referenced by: '<S4355>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_ThrmlPwrBdgt_Min = 4.0F;/* Referenced by: '<S4554>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_TotBatBdgt_Limit_Min =
    4.0F;                              /* Referenced by: '<S4555>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_UGrdLimitBTLHtrMBC =
    20.0F;                             /* Referenced by: '<S3135>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_UGrdLimitECH_MBCHTLLTL =
    20.0F;                             /* Referenced by: '<S3256>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_UGrdLimitHTLHtrMBC1 =
    20.0F;                             /* Referenced by: '<S2044>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_P_UGrdLimitHTLHtrMBC2 =
    20.0F;                             /* Referenced by: '<S2045>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_WCondHeat_Cabin_Assist_Max = 5000.0F;/* Referenced by: '<S2109>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_WCondHeat_Cabin_Assist_RtLimDown = -500.0F;/* Referenced by: '<S2112>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_P_WCondHeat_Cabin_Assist_RtLimUp = 500.0F;/* Referenced by: '<S2113>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_AGS1_Dsbl = 0.0F;/* Referenced by:
                                                                      * '<S5415>/Calib'
                                                                      * '<S5416>/Calib'
                                                                      */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_AGS2_Dsbl = 0.0F;/* Referenced by:
                                                                      * '<S5417>/Calib'
                                                                      * '<S5418>/Calib'
                                                                      * '<S5419>/Calib'
                                                                      */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_AGS2_PosReq_D = 0.0F;/* Referenced by: '<S1137>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_AGS2_Rng2 = 22.0F;/* Referenced by: '<S5401>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_AGSOpen = 20.0F;/* Referenced by:
                                                                      * '<S5453>/Calib'
                                                                      * '<S5460>/Calib'
                                                                      * '<S5467>/Calib'
                                                                      * '<S5474>/Calib'
                                                                      * '<S5481>/Calib'
                                                                      * '<S5497>/Calib'
                                                                      * '<S5504>/Calib'
                                                                      */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_AGSPsCmdLTRVlvPos_HPMode = 0.0F;/* Referenced by: '<S5373>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_AGS_PosReq_D = 0.0F;/* Referenced by: '<S1138>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_AGS_Rng2 = 22.0F;/* Referenced by: '<S5402>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_AHH_NrlzdFanSpeed_D =
    0.0F;                              /* Referenced by: '<S5428>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_AHH_NrmlzdMaxFan_Speed =
    1.0F;                              /* Referenced by: '<S5426>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_AirFlowReq = 0.0F;/* Referenced by: '<S1141>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_AllWheelBreakTmp = 0.0F;/* Referenced by: '<S5374>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_BSG_LTR_PmpFlwRq_D =
    0.0F;                              /* Referenced by: '<S351>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_BTLVlvCntrl_Max =
    100.0F;                            /* Referenced by: '<S2334>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_BTLVlvCntrl_Min = 10.0F;/* Referenced by: '<S2335>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_BTLVlvITerm_Max =
    100.0F;                            /* Referenced by: '<S2336>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_BTLVlvITerm_Min = 10.0F;/* Referenced by: '<S2337>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_BTLVlvPI_IV = 10.0F;/* Referenced by: '<S2338>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_BattCoolFlwRtTest =
    0.0F;                              /* Referenced by: '<S5295>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_BattSOC_LdShdCool_Lv1 =
    0.0F;                              /* Referenced by: '<S4234>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_CabCondDsbl_Run_NoPlugin = 15.0F;/* Referenced by: '<S4376>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_CabCondEnbl_Run_NoPlugin = 20.0F;/* Referenced by: '<S4377>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_DGrdLimitLTLTRVMBC =
    -20.0F;                            /* Referenced by: '<S3030>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_DGrdLimitLTRVlv_MBCHTLLTL = -20.0F;/* Referenced by: '<S3257>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_DGrdLimitVHTL_MBCHTLLTL
    = -20.0F;                          /* Referenced by: '<S3258>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_DesablingSOC_N_Fuel_Min
    = 25.0F;                           /* Referenced by: '<S4340>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_DisablingSOCMin = 22.0F;/* Referenced by: '<S4356>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_DisablingSOCMin_BattCond = 35.0F;/* Referenced by: '<S4357>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_DsblSOCMin_NoBattCond =
    20.0F;                             /* Referenced by: '<S4358>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_ECM_LTPsvPmpRq_SD =
    0.0F;                              /* Referenced by: '<S113>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_ECM_LT_PsvPmpRq_Max =
    100.0F;                            /* Referenced by: '<S2960>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_ECM_RadFanSpd_Min =
    0.0F;                              /* Referenced by: '<S4496>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_Emrgy_RadFanCmd_On =
    100.0F;                            /* Referenced by: '<S5511>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_Emrgy_RadFanCmd_OnDft =
    0.0F;                              /* Referenced by: '<S5512>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_Emrgy_RadFanCmd_OnLo =
    33.0F;                             /* Referenced by: '<S5513>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FCSVlvReq_FCSDerate =
    10.0F;                             /* Referenced by: '<S800>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FCVlvInit = 0.0F;/* Referenced by: '<S785>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_FCVlvPos_FrzAirflowITerm = 3.0F;/* Referenced by: '<S859>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_FCVlvPos_FrzAirflowPTerm = 100.0F;/* Referenced by: '<S860>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FCVlv_BypassRad =
    100.0F;                            /* Referenced by: '<S766>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FCVlv_CntThruRad = 0.0F;/* Referenced by:
                                                                      * '<S764>/Calib'
                                                                      * '<S765>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FCVlv_MinRampPct =
    10.0F;                             /* Referenced by: '<S771>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FCVlv_PICmdMax = 100.0F;/* Referenced by: '<S772>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FCVlv_PICmdMin = 0.0F;/* Referenced by: '<S773>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FCVlv_PI_IntgrlTerm_Max
    = 100.0F;                          /* Referenced by: '<S774>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FCVlv_PI_IntgrlTerm_Min
    = 0.0F;                            /* Referenced by: '<S775>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FCVlv_RmpRateLim_Dwn =
    -10.0F;                            /* Referenced by: '<S776>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FCVlv_RmpRateLim_Up =
    10.0F;                             /* Referenced by: '<S777>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FCWaPump_MaxSpdPct =
    0.0F;                              /* Referenced by: '<S897>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FCWaPump_MinSpdPct =
    0.0F;                              /* Referenced by: '<S898>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FC_VlvPosReq_NF = 0.0F;/* Referenced by: '<S5680>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FanCmdOff_Hi = 94.0F;/* Referenced by: '<S2490>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FanCmdOff_Lo = 12.0F;/* Referenced by: '<S2491>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FanOnPct_SFvsRaw =
    25.0F;                             /* Referenced by: '<S5441>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_FanSpeed_Default = 0.0F;/* Referenced by:
                                                                      * '<S5594>/Calib'
                                                                      * '<S5454>/Calib'
                                                                      * '<S5461>/Calib'
                                                                      * '<S5468>/Calib'
                                                                      * '<S5475>/Calib'
                                                                      * '<S5482>/Calib'
                                                                      * '<S5498>/Calib'
                                                                      * '<S5505>/Calib'
                                                                      */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_Fan_off_to_on_pct =
    25.0F;                             /* Referenced by: '<S5442>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_Fan_on_to_off_pct =
    16.0F;                             /* Referenced by: '<S5443>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HCP_AGS_Req_Dial = 0.0F;/* Referenced by: '<S1131>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTCLVlv_FCBoostCool =
    100.0F;                            /* Referenced by: '<S1992>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTCL_Byps_Clsd = 0.0F;/* Referenced by:
                                                                      * '<S2003>/Calib'
                                                                      * '<S2029>/Calib'
                                                                      */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTCL_Byps_MinClsd =
    5.0F;                              /* Referenced by: '<S1905>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTCL_Byps_Opn = 100.0F;/* Referenced by: '<S1995>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTCVClose = 0.0F;
                                  /* Referenced by: '<S1852>/THMR_HTCVFlt_RA' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTCVCntrl_Max = 100.0F;/* Referenced by: '<S1367>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTCVCntrl_Min = 10.0F;/* Referenced by: '<S1368>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTCVOpen = 100.0F;
                                  /* Referenced by: '<S1852>/THMR_HTCVFlt_RA' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTCVPI_IV = 10.0F;/* Referenced by: '<S1369>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTCVPI_Max = 100.0F;/* Referenced by: '<S1370>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTCVPI_Min = 10.0F;/* Referenced by: '<S1371>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTCV_HTLFullThrmCpldBTL
    = 0.0F;                            /* Referenced by: '<S1343>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTCV_HTLNotThrmCpldBTL =
    100.0F;                            /* Referenced by: '<S1344>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTLVlvCntrl_Max =
    100.0F;                            /* Referenced by: '<S2018>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTLVlvCntrl_Min = 10.0F;/* Referenced by: '<S2019>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTLVlvFullyOpen = 95.0F;/* Referenced by:
                                                                      * '<S4410>/Calib'
                                                                      * '<S4417>/Calib'
                                                                      * '<S4473>/Calib'
                                                                      */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTLVlvPI_IV = 10.0F;/* Referenced by: '<S2020>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTLVlvPI_Max = 100.0F;/* Referenced by: '<S2021>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HTLVlvPI_Min = 10.0F;/* Referenced by: '<S2022>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HT_CabVlvCmd_Dial =
    0.0F;                              /* Referenced by: '<S5653>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HT_CabVlvCmd_Dum4BSG =
    0.0F;                              /* Referenced by: '<S5654>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HVBatSOC_FCSDerate_LSP =
    30.0F;                             /* Referenced by: '<S801>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HVBatSOC_FCSDerate_RSP =
    40.0F;                             /* Referenced by: '<S802>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HV_BatPckSOC_Dial =
    0.0F;                              /* Referenced by: '<S245>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_HV_ElecClntHtr2_Cmd_Dum4BSG = 0.0F;/* Referenced by: '<S2182>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_HV_ElecClntHtr2_Sts_Dum4BSG = 0.0F;/* Referenced by: '<S2180>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_HV_ElecClntHtr3_Cmd_Dum4BSG = 0.0F;/* Referenced by: '<S2190>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_HV_ElecClntHtr3_Sts_Dum4BSG = 0.0F;/* Referenced by: '<S2188>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_HV_ElecClntHtr4_Cmd_Dum4BSG = 0.0F;/* Referenced by: '<S2198>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_HV_ElecClntHtr4_Sts_Dum4BSG = 0.0F;/* Referenced by: '<S2196>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_HV_ElecClntHtr_Cmd_Dum4BSG = 0.0F;/* Referenced by: '<S2206>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_HV_ElecClntHtr_Sts_Dum4BSG = 0.0F;/* Referenced by: '<S2204>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HtrByPassDflt = 100.0F;/* Referenced by: '<S1962>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_HtrByPassOpen = 100.0F;/* Referenced by: '<S1963>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LINPrplVlv_AllPortsOpen
    = 66.0F;                           /* Referenced by: '<S2327>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LINPrplVlv_Cmd_D = 0.0F;/* Referenced by: '<S5664>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LINPrplVlv_Cmd_Dum4BSG =
    0.0F;                              /* Referenced by: '<S5665>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_LINPrplVlv_LTCLBTLPrtlyComb = 10.0F;/* Referenced by: '<S2366>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LINPrplVlv_PrplMdReq =
    0.0F;                              /* Referenced by: '<S2363>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LINPrplVlv_SingleLoop =
    100.0F;                            /* Referenced by: '<S2360>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LINPrplVlv_TwoLoops =
    0.0F;                              /* Referenced by:
                                        * '<S2362>/Calib'
                                        * '<S2364>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_LINPrplVlv_TwoLoops_BattLTCLComb = 200.0F;/* Referenced by: '<S2361>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_LINPrplVlv_TwoLoops_LTCLCool = 150.0F;/* Referenced by: '<S2367>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTCLPsvCool_AHHNrmlzdAF
    = 20.0F;                           /* Referenced by:
                                        * '<S5195>/Calib'
                                        * '<S4916>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_LTCLPsvCool_AftrRunNrmlzdAF = 20.0F;/* Referenced by: '<S5196>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTCLVlvMax = 100.0F;/* Referenced by: '<S3074>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTCLVlvMin = 0.0F;/* Referenced by: '<S3075>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlvCls_FanOn_Max =
    50.0F;                             /* Referenced by: '<S5489>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlvCls_FanOn_Min =
    33.0F;                             /* Referenced by: '<S5490>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlvCmd_Max = 100.0F;/* Referenced by: '<S2773>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlvCmd_Min = 0.0F;/* Referenced by: '<S2774>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlvFullyClsd_Max =
    50.0F;                             /* Referenced by: '<S4481>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlvFullyClsd_Min =
    33.0F;                             /* Referenced by: '<S4482>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlvInit = 0.0F;/* Referenced by: '<S2775>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlvPI_Max = 100.0F;/* Referenced by: '<S2776>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlvPI_Min = 0.0F;/* Referenced by: '<S2777>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlv_BlockRad =
    -100.0F;                           /* Referenced by: '<S2756>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlv_BypassRad =
    100.0F;                            /* Referenced by: '<S2762>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlv_CntThruRad =
    0.0F;                              /* Referenced by:
                                        * '<S2759>/Calib'
                                        * '<S2760>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlv_FCBoostCool =
    100.0F;                            /* Referenced by: '<S2761>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlv_LinearInv = 0.0F;/* Referenced by: '<S3302>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlv_MinRampPct =
    10.0F;                             /* Referenced by: '<S2778>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlv_Nrmlztn = 100.0F;/* Referenced by: '<S3303>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlv_RmpRateLim_Dwn =
    -10.0F;                            /* Referenced by: '<S2779>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTRVlv_RmpRateLim_Up =
    10.0F;                             /* Referenced by: '<S2780>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_LTR_PmpFlwRq_RU_D =
    0.0F;                              /* Referenced by: '<S352>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_MaskCmprNoiseFanCmdDefault = 0.0F;/* Referenced by: '<S5595>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_MaxAntWdLTLLTRVMBC =
    200.0F;                            /* Referenced by: '<S3062>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_MaxAntWdLTRVlv_MBCHTLLTL = 200.0F;/* Referenced by: '<S3324>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_MaxAntWdVHTL_MBCHTLLTL =
    200.0F;                            /* Referenced by: '<S3325>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_MaxLimitLTLTRVMBC =
    100.0F;                            /* Referenced by: '<S3031>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_MaxLimitLTRVlv_MBCHTLLTL = 100.0F;/* Referenced by: '<S3259>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_MaxLimitVHTL_MBCHTLLTL =
    100.0F;                            /* Referenced by: '<S3260>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_MinAntWdLTLLTRVMBC =
    100.0F;                            /* Referenced by: '<S3063>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_MinAntWdLTRVlv_MBCHTLLTL = 100.0F;/* Referenced by: '<S3326>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_MinAntWdVHTL_MBCHTLLTL =
    100.0F;                            /* Referenced by: '<S3327>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_MinLimitLTLTRVMBC =
    0.0F;                              /* Referenced by: '<S3032>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_MinLimitLTRVlv_MBCHTLLTL = 0.0F;/* Referenced by: '<S3261>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_MinLimitVHTL_MBCHTLLTL =
    0.0F;                              /* Referenced by: '<S3262>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_NoECMReq = 0.0F;/* Referenced by: '<S5435>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_P1MotorReqDsbl

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_NoP1MotorReq = 0.0F;/* Referenced by: '<S5436>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_Ovrrd_AftrRunMaxFanSpeed = 100.0F;/* Referenced by: '<S5375>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_PPU_Airflow_MinDummy =
    0.0F;                              /* Referenced by:
                                        * '<S5376>/Calib'
                                        * '<S5437>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_RadFanOn_DsblFanThrsld =
    12.0F;                             /* Referenced by: '<S2860>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_RadFanSts_Dial = 0.0F;/* Referenced by: '<S4018>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_RenblingSOCMin = 28.0F;/* Referenced by: '<S4359>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_RenblingSOCMin_BattCond
    = 36.0F;                           /* Referenced by: '<S4360>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_RenblingSOCMin_NoBattCond = 21.0F;/* Referenced by: '<S4361>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_RenblingSOC_N_Fuel_Min =
    35.0F;                             /* Referenced by: '<S4341>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_RunFanSpd = 20.0F;/* Referenced by: '<S4497>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_TCU_Load_Index_Max_Alwd
    = 78.0F;                           /* Referenced by: '<S2574>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_UGrdLimitLTLTRVMBC =
    20.0F;                             /* Referenced by: '<S3033>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_Pct_UGrdLimitLTRVlv_MBCHTLLTL = 20.0F;/* Referenced by: '<S3263>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_UGrdLimitVHTL_MBCHTLLTL
    = 20.0F;                           /* Referenced by: '<S3264>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_VHTL_LinearInv = 0.0F;/* Referenced by: '<S3296>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_VHTL_Nrmlztn = 100.0F;/* Referenced by: '<S3297>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_min_Fan_off_pct = 7.0F;/* Referenced by: '<S5444>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_Pct_min_Fan_on_pct = 25.0F;/* Referenced by: '<S5445>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_AAD_ACConClmp_Max = 0.0F;/* Referenced by: '<S91>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_AAD_AmbMaxTemp = 0.0F;/* Referenced by: '<S92>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_AAD_AmbMinTemp = 0.0F;/* Referenced by: '<S93>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_AAD_CellOverTemp = 0.0F;/* Referenced by: '<S94>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_AAD_DCConClmp_Max = 0.0F;/* Referenced by: '<S95>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_AAD_FEDMConClmp_Max =
    0.0F;                              /* Referenced by: '<S96>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_AAD_GenConClmp_Max = 0.0F;/* Referenced by: '<S97>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_AAD_HVBP_FEDMConClmp_Max =
    0.0F;                              /* Referenced by: '<S98>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_AAD_HVBP_REDMConClmp_Max =
    0.0F;                              /* Referenced by: '<S99>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_AAD_PDCSurfTemp_Max =
    0.0F;                              /* Referenced by: '<S100>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_AAD_REDMConClmp_Max =
    0.0F;                              /* Referenced by: '<S101>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_AAD_REEVConClmp_Max =
    0.0F;                              /* Referenced by: '<S102>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_AATRefDeltaDeicing_LSP =
    10.0F;                             /* Referenced by: '<S4994>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_AATRefDeltaDeicing_RSP =
    10.0F;                             /* Referenced by: '<S4995>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_APM2_Temp1_D = 0.0F;/* Referenced by: '<S3849>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_APM2_Temp1_HiMax = 85.0F;/* Referenced by: '<S2575>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_APM2_Temp2_D = 0.0F;/* Referenced by: '<S3855>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_APM2_Temp2_HiMax = 85.0F;/* Referenced by: '<S2576>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_APM3_Temp1_D = 0.0F;/* Referenced by: '<S3861>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_APM3_Temp1_HiMax = 85.0F;/* Referenced by: '<S2577>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_APM3_Temp2_D = 0.0F;/* Referenced by: '<S3867>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_APM3_Temp2_HiMax = 85.0F;/* Referenced by: '<S2578>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_APMTmpTh_EmrgncyCoolLSP =
    200.0F;                            /* Referenced by: '<S4794>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_APMTmpTh_EmrgncyCoolRSP =
    200.0F;                            /* Referenced by: '<S4795>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_APM_Temp1_D = 25.0F;/* Referenced by: '<S3874>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_APM_Temp1_HiMax = 85.0F;/* Referenced by: '<S2579>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_APM_Temp2_D = 25.0F;/* Referenced by: '<S3881>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_APM_Temp2_HiMax = 85.0F;/* Referenced by: '<S2580>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ActvCoolAmbTemp = 30.0F;/* Referenced by: '<S4742>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BSG_ClntInTemp_D = 0.0F;/* Referenced by: '<S136>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BSG_ClntOutTemp_D = 0.0F;/* Referenced by: '<S141>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BSG_CntrlBoardTemp_D =
    0.0F;                              /* Referenced by: '<S127>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BSG_MtrCapctrTemp_D =
    25.0F;                             /* Referenced by: '<S150>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BSG_Rotor_Temp_D = 0.0F;/* Referenced by: '<S122>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BTISTgtOffset_frWCondTgt =
    0.0F;                              /* Referenced by: '<S5250>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BTOSTh_EmrgncyCoolLSP =
    200.0F;                            /* Referenced by: '<S4796>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BTOSTh_EmrgncyCoolRSP =
    200.0F;                            /* Referenced by: '<S4797>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_BatCellTemp_Thrshld_Emgncy_Cooling = 5.0F;/* Referenced by: '<S2710>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_BattCellPriorityThresholdHigh = 0.0F;/* Referenced by: '<S4046>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_BattCellPriorityThresholdLow = 0.0F;/* Referenced by: '<S4047>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BattHot_DsblHVACPriority =
    46.0F;                             /* Referenced by: '<S413>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BattLTLdeltaT_MaxLim =
    6.0F;                              /* Referenced by: '<S4636>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BattLTLdeltaT_MinLim =
    -6.0F;                             /* Referenced by: '<S4637>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BattMaxTmp1_LdShed = 0.0F;/* Referenced by: '<S4235>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BattMaxTmp2_LdShed = 0.0F;/* Referenced by: '<S4236>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BattOverTmp_DiffTh = 3.0F;/* Referenced by: '<S1871>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BattWrm_EnblHVACPriorty =
    45.0F;                             /* Referenced by: '<S414>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BstCnvtrLwrIGBT_Max_Alwd =
    0.0F;                              /* Referenced by: '<S2581>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BstCnvtrLwrIGBT_TmpFltd_D
    = 0.0F;                            /* Referenced by: '<S2267>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_T_BstCnvtrLwrIGBT_TmpFltd_SD = 0;/* Referenced by: '<S2268>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BstCnvtrReactorTmp_D =
    0.0F;                              /* Referenced by: '<S2269>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_BstCnvtrReactorTmp_Max_Alwd = 0.0F;/* Referenced by: '<S2582>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_T_BstCnvtrReactorTmp_SD = 0;/* Referenced by: '<S2270>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_BstCnvtrUpprIGBT_Max_Alwd
    = 0.0F;                            /* Referenced by: '<S2583>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_BstCnvtrUpprIGBT_TmpFltd_D = 0.0F;/* Referenced by: '<S2271>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_T_BstCnvtrUpprIGBT_TmpFltd_SD = 0;/* Referenced by: '<S2272>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_CellTempMaxAllw_PsvRA_BattCoolFltd = 25.0F;/* Referenced by: '<S371>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_CellTempMaxPsv = 65.0F;/* Referenced by: '<S4805>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblRA_BattCoolingFlt_PsvCool

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_CellTempMax_AllowRA4BattCool = 25.0F;/* Referenced by: '<S280>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblRA_BattCoolingFlt_PsvCool

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_CellTempMax_RejectRA4BattCool = 20.0F;/* Referenced by: '<S281>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_CellTempMax_Th = 50.0F;/* Referenced by: '<S1859>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_CellTempMin_BattPsvHeatEnbl = -40.0F;/* Referenced by: '<S4681>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_Celltemp_DsblWasteHeatRcvry = 23.0F;/* Referenced by: '<S4783>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_Celltemp_DsblWasteHeatRcvry_Deice = 10.0F;/* Referenced by: '<S4784>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_Celltemp_EnblWasteHeatRcvry = 25.0F;/* Referenced by: '<S4785>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_Celltemp_EnblWasteHeatRcvry_Deice = 12.0F;/* Referenced by: '<S4786>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ClntTmpDiff = 5.0F;/* Referenced by:
                                                                      * '<S4891>/Calib'
                                                                      * '<S4906>/Calib'
                                                                      */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_Clnt_In_Temp_Max = 85.0F;/* Referenced by: '<S2584>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_Clnt_Out_Temp_Max = 85.0F;/* Referenced by: '<S2585>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_CntrlBoardTmp_Dflt =
    -99.0F;                            /* Referenced by: '<S2842>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_CntrlBoard_Temp_LoMax =
    65.0F;                             /* Referenced by: '<S2492>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_CntrlBrdTmp_Snsr2_LoMax =
    110.0F;                            /* Referenced by: '<S2473>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_CntrlBrdTmp_Snsr2_TempMax
    = 120.0F;                          /* Referenced by: '<S2586>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_CoFuCellHiTOutMax_C =
    85.0F;                             /* Referenced by: '<S1002>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_CoFuCellHiTSigOfs_C =
    5.0F;                              /* Referenced by: '<S1029>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_CoOutDeltaFuCellHiTHEXRstLo_C = 0.5F;/* Referenced by: '<S1109>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_DifCoFuCellHiTOutSpDecHld_C = 2.0F;/* Referenced by: '<S1044>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ECHTISHtPumpDsbl = 80.0F;/* Referenced by: '<S4977>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ECHTIS_HtPumpEnbl = 80.0F;/* Referenced by: '<S4978>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ECH_ClntTempTgt = 99.0F;/* Referenced by: '<S4131>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ECH_ClntTempTgt_Dial =
    25.0F;                             /* Referenced by: '<S2207>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ECH_ClntTmpIn_DratOff =
    80.0F;                             /* Referenced by:
                                        * '<S1781>/Calib'
                                        * '<S1758>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ECH_ClntTmpIn_DratOn =
    83.0F;                             /* Referenced by:
                                        * '<S1782>/Calib'
                                        * '<S1759>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ECH_TempErrDef = -40.0F;/* Referenced by:
                                                                      * '<S1323>/Calib'
                                                                      * '<S1324>/Calib'
                                                                      * '<S1325>/Calib'
                                                                      * '<S2353>/Calib'
                                                                      * '<S2354>/Calib'
                                                                      * '<S2355>/Calib'
                                                                      */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ECT_CavitHi = 80.0F;/* Referenced by: '<S1452>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ECT_CavitLo = 20.0F;/* Referenced by: '<S1453>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ECT_ECHTIS_Hyst = 2.0F;/* Referenced by:
                                                                      * '<S4942>/Calib'
                                                                      * '<S4631>/Calib'
                                                                      */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ECT_EngPwrWaste_MinHi =
    60.0F;                             /* Referenced by: '<S1701>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ECT_EngPwrWaste_MinLo =
    58.0F;                             /* Referenced by: '<S1702>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ECT_hotDisFan_Thrsld =
    -95.0F;                            /* Referenced by: '<S2861>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ElecClntHtr_Th = 10.0F;/* Referenced by: '<S1860>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_EngAllowd_AmbTempMax1 =
    1.7F;                              /* Referenced by: '<S1482>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_EngAllowd_AmbTempMax2 =
    7.2F;                              /* Referenced by: '<S1483>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_EngAllowd_AmbTempMin =
    -30.0F;                            /* Referenced by: '<S1484>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_EngAllowd_EVMode_AmbTempMax = -15.0F;/* Referenced by: '<S1481>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_EngClntTmp_EngCold =
    10.0F;                             /* Referenced by: '<S1703>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_EngClntTmp_LowWshdPwr =
    60.0F;                             /* Referenced by: '<S1746>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_EngClntTmp_Out_Dial =
    25.0F;                             /* Referenced by: '<S3884>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_FCCTOSHot_FCSDerate_LSP =
    82.0F;                             /* Referenced by: '<S803>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_FCCTOSHot_FCSDerate_RSP =
    85.0F;                             /* Referenced by: '<S804>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_FuCellHiTHEXCtlMax_C =
    10.0F;                             /* Referenced by: '<S1101>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_FuCellHiTHEXCtlMin_C =
    -10.0F;                            /* Referenced by: '<S1102>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_FuCellHiTHEXCtlReqErrOvrd_C = 4.0F;/* Referenced by: '<S1110>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_FuCellHiTHEXTInTarPreHeat_C = 70.0F;/* Referenced by: '<S1103>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_HCCTISBTISTgtDef_frWCond =
    -40.0F;                            /* Referenced by: '<S5119>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_HCCTISErr_EnblLTCLActvPsvHeat_LSP = -6.0F;/* Referenced by: '<S4640>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_HCCTISErr_EnblLTCLActvPsvHeat_RSP = 6.0F;/* Referenced by: '<S4641>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_HCCTISTgtOffset_frWCondTgt = 0.0F;/* Referenced by: '<S5251>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_HCCTISTgt_AllwCabActvPsvCond = 65.0F;/* Referenced by: '<S4928>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_HCCTOSNominal4LTCL =
    60.0F;                             /* Referenced by: '<S4951>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_HCCTOStooHot4LTCL = 65.0F;/* Referenced by: '<S4952>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_HV_BatClntTmp_Th = 50.0F;/* Referenced by: '<S1861>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_HeatPumpDsblAAT_CabCool =
    15.0F;                             /* Referenced by: '<S4979>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_HeatPumpEnblAATMax =
    50.0F;                             /* Referenced by: '<S5003>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_HeatPumpEnblAATMin =
    -5.0F;                             /* Referenced by: '<S5004>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_Htr2ClntTempTgt_Dial =
    25.0F;                             /* Referenced by: '<S2183>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_Htr2_ClntTempTgt = 99.0F;/* Referenced by: '<S4151>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_Htr3ClntTempTgt_Dial =
    25.0F;                             /* Referenced by: '<S2191>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_Htr3_ClntTempTgt = 99.0F;/* Referenced by: '<S4171>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_Htr4ClntTempTgt_Dial =
    25.0F;                             /* Referenced by: '<S2199>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_Htr4_ClntTempTgt = 99.0F;/* Referenced by: '<S4191>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_HtrCorClnt_TmpIn_Dum4BSG =
    0.0F;                              /* Referenced by: '<S325>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_HtrCorClnt_Tmp_In_D =
    50.0F;                             /* Referenced by: '<S4022>/Calib' */
static volatile CONST(sint16, THMR_VAR_INIT) KeTHMR_T_HtrCrErr_Htr1Flty_LSP =
    -20;                               /* Referenced by: '<S1492>/Calib' */
static volatile CONST(sint16, THMR_VAR_INIT) KeTHMR_T_HtrCrErr_Htr1Flty_RSP = 0;/* Referenced by: '<S1493>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_ILHEX_DeltaTemp = 7.0F;/* Referenced by: '<S1321>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_InductionAirTemp_D =
    25.0F;                             /* Referenced by: '<S111>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_InvrtTmpConditioning_Dwn =
    1.0F;                              /* Referenced by: '<S2843>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_InvrtTmpConditioning_Up =
    4.0F;                              /* Referenced by: '<S2844>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_LTCLTgt_BattActvPsvHeating_D = 0.0F;/* Referenced by: '<S219>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_LTRClntTmpOutTgt = 70.0F;/* Referenced by: '<S3076>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MaxBattTempAllowed =
    55.0F;                         /* Referenced by: '<S4098>/Batt_Condition' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MaxDefrostAmb = -1.0F;/* Referenced by: '<S406>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MaxHTCLTemp = 99.0F;/* Referenced by: '<S1457>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MaxHTCLTemp_HTLVlvOpenFlt
    = 63.0F;                           /* Referenced by: '<S1458>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MinBattTempAllowed =
    -1.0F;                         /* Referenced by: '<S4098>/Batt_Condition' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MinFBLMBC2 = 3.0F;/* Referenced by: '<S2088>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MotTemp_1_Hyst_Hi = 70.0F;/* Referenced by: '<S679>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MotTemp_1_Hyst_Low =
    66.0F;                             /* Referenced by: '<S680>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MotTemp_1_Hyst_RvrsHi =
    70.0F;                             /* Referenced by: '<S674>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MotTemp_1_Hyst_RvrsLow =
    66.0F;                             /* Referenced by: '<S675>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MotTemp_2_Hyst_Hi = 70.0F;/* Referenced by: '<S702>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MotTemp_2_Hyst_Low =
    66.0F;                             /* Referenced by: '<S703>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MotTemp_2_Hyst_RvrsHi =
    70.0F;                             /* Referenced by: '<S697>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MotTemp_2_Hyst_RvrsLow =
    66.0F;                             /* Referenced by: '<S698>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_Mtr2_EOP_Off_LSP = 60.0F;/* Referenced by: '<S712>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_Mtr2_EOP_On_RSP = 70.0F;/* Referenced by: '<S713>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrAConCmpTempLSP1 =
    10.0F;                             /* Referenced by: '<S3414>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrAConCmpTempLSP2 =
    10.0F;                             /* Referenced by: '<S3415>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrAConCmpTempLSP3 =
    10.0F;                             /* Referenced by: '<S3416>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrAConCmpTempLSP4 =
    10.0F;                             /* Referenced by: '<S3417>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrAConCmpTempRSP1 =
    100.0F;                            /* Referenced by: '<S3418>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrAConCmpTempRSP2 =
    100.0F;                            /* Referenced by: '<S3419>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrAConCmpTempRSP3 =
    100.0F;                            /* Referenced by: '<S3420>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrAConCmpTempRSP4 =
    100.0F;                            /* Referenced by: '<S3421>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrA_CntrlBoard_Temp_Max =
    85.0F;                             /* Referenced by: '<S2587>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrA_InvrtTmp_Dflt =
    -99.0F;                            /* Referenced by: '<S2845>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrA_InvrtrTempDial =
    25.0F;                             /* Referenced by: '<S3899>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrA_InvrtrTemp_LoMax =
    65.0F;                             /* Referenced by: '<S2493>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrA_InvrtrTemp_Max =
    200.0F;                            /* Referenced by: '<S2588>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrA_OilPumpTemp_Max =
    100.0F;                            /* Referenced by: '<S2589>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrA_Rotor_Temp_Max =
    85.0F;                             /* Referenced by: '<S2590>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrA_TempDial = 25.0F;/* Referenced by: '<S3914>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrA_Temp_LoMax = 65.0F;/* Referenced by: '<S2494>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrA_Temp_Max = 200.0F;/* Referenced by: '<S2591>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrBConCmpTempLSP1 =
    10.0F;                             /* Referenced by: '<S3488>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrBConCmpTempLSP2 =
    10.0F;                             /* Referenced by: '<S3489>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrBConCmpTempRSP1 =
    100.0F;                            /* Referenced by: '<S3490>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrBConCmpTempRSP2 =
    100.0F;                            /* Referenced by: '<S3491>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrB_CntrlBoard_Temp_Max =
    85.0F;                             /* Referenced by: '<S2592>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrB_InvrtrTempDial =
    25.0F;                             /* Referenced by: '<S3906>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrB_InvrtrTemp_Max =
    200.0F;                            /* Referenced by: '<S2593>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrB_OilPumpTemp_Max =
    100.0F;                            /* Referenced by: '<S2594>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrB_Rotor_Temp_Max =
    85.0F;                             /* Referenced by: '<S2595>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrB_TempDial = 25.0F;/* Referenced by: '<S3920>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrB_Temp_Max = 200.0F;/* Referenced by: '<S2596>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrCConCmpTempLSP1 =
    10.0F;                             /* Referenced by: '<S3546>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrCConCmpTempLSP2 =
    10.0F;                             /* Referenced by: '<S3547>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrCConCmpTempRSP1 =
    100.0F;                            /* Referenced by: '<S3548>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrCConCmpTempRSP2 =
    100.0F;                            /* Referenced by: '<S3549>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrC_CntrlBoardTemp_D =
    0.0F;                              /* Referenced by: '<S3822>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrC_CntrlBoardTemp_Max =
    0.0F;                              /* Referenced by: '<S2597>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrC_InvrtrTemp_D = 0.0F;/* Referenced by: '<S3809>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrC_InvrtrTemp_Max =
    0.0F;                              /* Referenced by: '<S2598>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrC_Rotor_Temp_D = 0.0F;/* Referenced by: '<S3817>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrC_Rotor_Temp_Max =
    0.0F;                              /* Referenced by: '<S2599>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrC_Temp_D = 0.0F;/* Referenced by: '<S3813>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrC_Temp_Max = 0.0F;/* Referenced by: '<S2600>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrCapctrTemp_LoMax =
    100.0F;                            /* Referenced by: '<S2495>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrCapctrTemp_Max =
    130.0F;                            /* Referenced by: '<S2601>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_MtrHiCoolThresh = 85.0F;/* Referenced by: '<S658>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_OBCMTemp1_HiMax = 85.0F;/* Referenced by: '<S2602>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_OBCMTemp1_LoMax = 65.0F;/* Referenced by: '<S2496>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_OBCMTemp2_HiMax = 85.0F;/* Referenced by: '<S2603>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_OBCMTemp2_LoMax = 65.0F;/* Referenced by: '<S2497>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_OBCMTemp3_Max_Alwd =
    150.0F;                            /* Referenced by: '<S2604>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_OBCMTemp4_Max_Alwd =
    150.0F;                            /* Referenced by: '<S2605>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_OutAirTemp_EstDial =
    25.0F;                             /* Referenced by: '<S22>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_OutAirTemp_EstFlt = 25.0F;/* Referenced by: '<S14>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_OutAirTemp_Est_Max =
    85.0F;                             /* Referenced by: '<S2606>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_OutletTempTooHigh = 70.0F;/* Referenced by: '<S1783>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_P1P2p5_MtrB_ClntInTemp_D =
    0.0F;                              /* Referenced by: '<S173>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_P1P2p5_MtrB_ClntOutTemp_D
    = 0.0F;                            /* Referenced by: '<S178>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp_D = 0.0F;/* Referenced by: '<S164>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_P1P2p5_MtrB_MtrCapctrTemp_D = 0.0F;/* Referenced by: '<S187>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_P1P2p5_MtrB_Rotor_Temp_D =
    0.0F;                              /* Referenced by: '<S159>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_PDCSurfTemp_D = 0.0F;/* Referenced by: '<S259>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_PECTOS_PPCTIS_Delta =
    3.0F;                              /* Referenced by: '<S4483>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_PPCTISCold_EnblWasteHeatRcvryDeice_LSP = 10.0F;/* Referenced by: '<S5151>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_PPCTISCold_EnblWasteHeatRcvryDeice_RSP = 15.0F;/* Referenced by: '<S5152>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_PPCTISCold_EnblWasteHeatRcvry_LSP = 10.0F;/* Referenced by: '<S5153>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_PPCTISCold_EnblWasteHeatRcvry_RSP = 15.0F;/* Referenced by: '<S5154>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_PPCTISHot_EnblWasteHeatRcvry_LSP = 50.0F;/* Referenced by: '<S5155>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_PPCTISHot_EnblWasteHeatRcvry_RSP = 55.0F;/* Referenced by: '<S5156>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_PPCTISNominal4LTCL =
    60.0F;                             /* Referenced by: '<S4953>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_PPCTIS_LSPTh_PsvCool =
    17.0F;                             /* Referenced by: '<S4912>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_PPCTIS_RSPTh_PsvCool =
    15.0F;                             /* Referenced by: '<S4913>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_PPCTIS_Tgt_BattPsvCool =
    20.0F;                             /* Referenced by: '<S5206>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_PPCTIS_Tgt_BattPsvHeat =
    50.0F;                             /* Referenced by:
                                        * '<S5208>/Calib'
                                        * '<S5209>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_PPCTIS_Tgt_CabPsvHeat =
    63.0F;                             /* Referenced by:
                                        * '<S5210>/Calib'
                                        * '<S5212>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_PPCTIStooCold_BattActvPsvHeat_LSP = -40.0F;/* Referenced by: '<S4655>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_PPCTIStooCold_BattActvPsvHeat_RSP = -30.0F;/* Referenced by: '<S4656>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_PPCTIStooHot4LTCL = 65.0F;/* Referenced by: '<S4954>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_PPCTIStooHot_BattActvPsvHeat_LSP = 63.0F;/* Referenced by: '<S4657>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_PPCTIStooHot_BattActvPsvHeat_RSP = 67.0F;/* Referenced by: '<S4658>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_PmpClnt_In_TempTgt =
    70.0F;                             /* Referenced by: '<S5160>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_PmpClnt_In_TempTgt_BattCPVFault = 50.0F;/* Referenced by: '<S5161>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_PsvPmpClnt_FltSet = 85.0F;/* Referenced by: '<S2867>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_PsvPmpClnt_TempTgt_PlgdIn_or_Chrg = 70.0F;/* Referenced by: '<S5162>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_PsvPmpClnt_TempTgt_PsvCool = 30.0F;/* Referenced by: '<S5163>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_PsvPmpClnt_TempTgt_PsvCool_RA = 20.0F;/* Referenced by: '<S5164>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_Pump2OilTemp_D = 0.0F;/* Referenced by: '<S3934>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_PumpOilTemp_D = 0.0F;/* Referenced by: '<S3928>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_RecircAmbLow = 10.0F;/* Referenced by: '<S83>/ThermalMode' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_RefTDeIcingEnable = 0.0F;/* Referenced by: '<S4996>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_Rotor_Temp_LoMax = 65.0F;/* Referenced by: '<S2498>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_SumpOilTmp_Dial = 25.0F;/* Referenced by: '<S3938>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_TransOilTmp_HiMax =
    185.0F;                            /* Referenced by: '<S2607>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_VehSpdHigh_LTCLtooHot_LSP
    = 70.0F;                           /* Referenced by: '<S5172>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_VehSpdHigh_LTCLtooHot_RSP
    = 75.0F;                           /* Referenced by: '<S5173>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_VehSpdLow_LTCLtooHot_LSP =
    75.0F;                             /* Referenced by: '<S5174>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_VehSpdLow_LTCLtooHot_RSP =
    80.0F;                             /* Referenced by: '<S5175>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_VehSpd_LSP_frLTCLtooHotThrsh = 55.0F;/* Referenced by: '<S5176>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_VehSpd_RSP_frLTCLtooHotThrsh = 90.0F;/* Referenced by: '<S5177>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_WCondErrorDelta_LSP =
    -3.0F;                             /* Referenced by: '<S5226>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_WCondErrorDelta_RSP =
    3.0F;                              /* Referenced by: '<S5227>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_WCondLTRSupp_BattDelta_LSP = 3.0F;/* Referenced by: '<S5228>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_WCondLTRSupp_BattDelta_RSP = 3.0F;/* Referenced by: '<S5229>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_WCondLTRSupp_CabDelta_LSP
    = 3.0F;                            /* Referenced by: '<S5230>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_WCondLTRSupp_CabDelta_RSP
    = 3.0F;                            /* Referenced by: '<S5231>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_WCondLTRSupp_HTLHghrLTL_LSP = 3.0F;/* Referenced by: '<S5232>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_WCondLTRSupp_HTLHghrLTL_RSP = 3.0F;/* Referenced by: '<S5233>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_WCondLTRSupp_MinAmbTemp =
    -30.0F;                            /* Referenced by: '<S5234>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_WaPmpFuCellHiTOutDeltaMinHys_C = 8.0F;/* Referenced by: '<S940>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_WaPmpFuCellHiTOutDeltaMin_C = -2.0F;/* Referenced by: '<S941>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_WaPmpFuCellPIDMax_C =
    5.0F;                              /* Referenced by: '<S908>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_WaPmpFuCellPIDMin_C =
    -5.0F;                             /* Referenced by: '<S909>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_WasteHeatRcvryEnblAATMax =
    15.0F;                             /* Referenced by:
                                        * '<S5141>/Calib'
                                        * '<S4771>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_T_WasteHeatRcvryEnblAATMax_CabCool = -40.0F;/* Referenced by:
                                                        * '<S5142>/Calib'
                                                        * '<S4772>/Calib'
                                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_T_WcondTgtCnst = 30.0F;/* Referenced by: '<S5252>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_U_HV_BatVolt_D = 0.0F;/* Referenced by: '<S247>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AAD_RetrctReq_D = 0;/* Referenced by: '<S87>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AAD_RetrctReq_SD = 0;/* Referenced by: '<S88>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ACCompFaultTest = 0;/* Referenced by: '<S5288>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AC_CompReq_Dial = 0;/* Referenced by: '<S3970>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AC_CompReq_SelDial = 0;/* Referenced by: '<S3971>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AGS2_PosReq_SD = 0;/* Referenced by: '<S1139>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AGSOpen = 1;/* Referenced by: '<S5403>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AGS_ChkOvrd = 0;/* Referenced by: '<S5408>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AGS_PosReq_SD = 0;/* Referenced by: '<S1140>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AGS_State_Dial = 0;/* Referenced by: '<S1132>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AHH_NrlzdFanSpeed_SD = 0;/* Referenced by: '<S5429>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AHH_ReadyStatus_SD = 0;/* Referenced by: '<S3783>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AHH_StresFact_ThrsldEnbld
    = 0;                               /* Referenced by: '<S2608>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AHH_StressFactor_SD = 0;/* Referenced by: '<S3785>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AHPEnbl_mHEV = 0;/* Referenced by:
                                                                      * '<S1885>/Calib'
                                                                      * '<S1926>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM2_Temp1_FA_D = 0;/* Referenced by: '<S3847>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM2_Temp1_FA_Enbld = 1;/* Referenced by: '<S2609>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM2_Temp1_FA_SD = 0;/* Referenced by: '<S3848>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM2_Temp1_OT_ThrsldEnbld
    = 1;                               /* Referenced by: '<S2610>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM2_Temp1_SD = 0;/* Referenced by: '<S3850>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM2_Temp2_FA_D = 0;/* Referenced by: '<S3853>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM2_Temp2_FA_Enbld = 1;/* Referenced by: '<S2611>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM2_Temp2_FA_SD = 0;/* Referenced by: '<S3854>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM2_Temp2_OT_ThrsldEnbld
    = 1;                               /* Referenced by: '<S2612>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM2_Temp2_SD = 0;/* Referenced by: '<S3856>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM3_Temp1_FA_D = 0;/* Referenced by: '<S3859>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM3_Temp1_FA_Enbld = 1;/* Referenced by: '<S2613>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM3_Temp1_FA_SD = 0;/* Referenced by: '<S3860>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM3_Temp1_OT_ThrsldEnbld
    = 1;                               /* Referenced by: '<S2614>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM3_Temp1_SD = 0;/* Referenced by: '<S3862>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM3_Temp2_FA_D = 0;/* Referenced by: '<S3865>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM3_Temp2_FA_Enbld = 1;/* Referenced by: '<S2615>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM3_Temp2_FA_SD = 0;/* Referenced by: '<S3866>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM3_Temp2_OT_ThrsldEnbld
    = 1;                               /* Referenced by: '<S2616>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM3_Temp2_SD = 0;/* Referenced by: '<S3868>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM_Temp1_FA_D = 0;/* Referenced by: '<S3872>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM_Temp1_FA_Enbld = 1;/* Referenced by: '<S2617>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM_Temp1_FA_SD = 0;/* Referenced by: '<S3873>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM_Temp1_OT_ThrsldEnbld =
    1;                                 /* Referenced by: '<S2618>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM_Temp1_SD = 0;/* Referenced by: '<S3875>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM_Temp2_FA_D = 0;/* Referenced by: '<S3879>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM_Temp2_FA_Enbld = 1;/* Referenced by: '<S2619>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM_Temp2_FA_SD = 0;/* Referenced by: '<S3880>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM_Temp2_OT_ThrsldEnbld =
    1;                                 /* Referenced by: '<S2620>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_APM_Temp2_SD = 0;/* Referenced by: '<S3882>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ActRemCompDecision_Dial =
    0;                                 /* Referenced by: '<S307>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_AcvPropTCoOutDeltaFuCellHiTHEX_C = 1;/* Referenced by: '<S1104>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_AcvRmpTCoFuCellHiTSigOfs_C = 0;/* Referenced by: '<S1030>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AcvTCoFuCellHiTSigOfs_C =
    0;                                 /* Referenced by: '<S1003>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_AcvTWaVeryLoTFuCellHiTHEX_C = 1;/* Referenced by: '<S1111>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AftrRunFanRqOvrdEnbl = 1;/* Referenced by: '<S5377>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AftrRunFanRqst_Dial = 0;/* Referenced by: '<S3362>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AftrRunFanRqst_SD = 0;/* Referenced by: '<S3363>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AftrRunPmpFlowOvrdEnbl =
    0;                                 /* Referenced by:
                                        * '<S2984>/Calib'
                                        * '<S2920>/Calib'
                                        */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AftrRunStateOvrdEnbl = 1;/* Referenced by: '<S636>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AirFlowReq_SelDial = 0;/* Referenced by: '<S1142>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AirTempSourceSel = 0;/* Referenced by: '<S2846>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AllWheelBreakTmpEnbl = 0;/* Referenced by: '<S5378>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_AllwHeatPumpActvPsvHeatCab = 0;/* Referenced by:
                                             * '<S5030>/Calib'
                                             * '<S5040>/Calib'
                                             */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AlternatorMode_Enbl = 0;/* Referenced by: '<S4237>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_AlwaysPriotzBattActvPsvHeat = 0;/* Referenced by: '<S4617>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AmbTmp_BTIS_Ovrrd = 0;/* Referenced by: '<S4849>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AmbTmp_CellMax_Ovrrd = 1;/* Referenced by: '<S4850>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AmbTmp_PPCTIS_Ovrrd = 0;/* Referenced by: '<S4851>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AmznDrvDprt_D = 0;/* Referenced by: '<S104>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AmznDrvDprt_Enbl = 0;/* Referenced by: '<S4316>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AmznDrvDprt_SD = 0;/* Referenced by: '<S105>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AntiWindupLTCLFBL = 0;/* Referenced by: '<S3077>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ArbPECTOS4FanCntrl = 1;/* Referenced by: '<S2807>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_AvalPwrForThmr_SelDial =
    0;                                 /* Referenced by: '<S547>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BCHStsHtrFaulty = 0;/* Referenced by: '<S3205>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BCHWishedPower_Enb = 0;/* Referenced by: '<S3169>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BCH_CntrlPerfIssue_HtrFlty_RA = 0;/* Referenced by: '<S3206>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BCH_LIN1BusOff_HtrFlty_RA
    = 0;                               /* Referenced by: '<S3207>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BCH_LIN2BusOff_HtrFlty_RA
    = 0;                               /* Referenced by: '<S3208>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BCH_LOC_HtrFlty_RA = 0;/* Referenced by: '<S3209>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BCH_TempSensPerfIssue_HtrFlty_RA = 0;/* Referenced by: '<S3210>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BPCM_LIN_BusOff_FA_D = 0;/* Referenced by: '<S231>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BPCM_LIN_BusOff_FA_SD = 0;/* Referenced by: '<S232>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BPCM_LIN_BusOff_SD = 0;/* Referenced by: '<S229>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BPCM_LIN_BusOff_SgnlRcvd_D = 0;/* Referenced by: '<S233>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BPCM_LIN_BusOff_SgnlRcvd_SD = 0;/* Referenced by: '<S234>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BPCM_LOC_BCP_FA_D = 0;/* Referenced by: '<S240>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BPCM_LOC_BCP_FA_SD = 0;/* Referenced by: '<S241>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BPCM_LOC_BCP_SD = 0;/* Referenced by: '<S238>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BPCM_LOC_BCP_SgnlRcvd_D =
    0;                                 /* Referenced by: '<S242>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BPCM_LOC_BCP_SgnlRcvd_SD =
    0;                                 /* Referenced by: '<S243>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_ClntInTemp_FA_D = 0;/* Referenced by: '<S137>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_ClntInTemp_FA_SD = 0;/* Referenced by: '<S138>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_ClntInTemp_SD = 0;/* Referenced by: '<S139>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_ClntOutTemp_FA_D = 0;/* Referenced by: '<S142>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_ClntOutTemp_FA_SD = 0;/* Referenced by: '<S143>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_ClntOutTemp_Fltr_Sel =
    1;                                 /* Referenced by:
                                        * '<S149>/Calib'
                                        * '<S186>/Calib'
                                        */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_ClntOutTemp_SD = 0;/* Referenced by: '<S144>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_CntrlBoardTemp_FA_D =
    0;                                 /* Referenced by: '<S128>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_CntrlBoardTemp_FA_SD =
    0;                                 /* Referenced by: '<S129>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BSG_CntrlBoardTemp_Fltr_Sel = 0;/* Referenced by: '<S135>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_CntrlBoardTemp_SD = 0;/* Referenced by: '<S130>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_LTR_PmpFlwRq_SD = 0;/* Referenced by: '<S353>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_MtrCapctrTemp_FA_D =
    0;                                 /* Referenced by: '<S151>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_MtrCapctrTemp_FA_SD =
    0;                                 /* Referenced by: '<S152>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_MtrCapctrTemp_SD = 0;/* Referenced by: '<S153>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_Rotor_Temp_FA_D = 0;/* Referenced by: '<S123>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_Rotor_Temp_FA_SD = 0;/* Referenced by: '<S124>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BSG_Rotor_Temp_SD = 0;/* Referenced by: '<S125>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblRA_BattCoolingFlt_PsvCool

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BTISFlty_Disbl_RA4PsvCool
    = 1;                               /* Referenced by: '<S287>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BTIS_CellMax_Ovrrd = 0;/* Referenced by: '<S4852>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BTLHTLDrctConnct = 1;/* Referenced by:
                                                                      * '<S1983>/Calib'
                                                                      * '<S2312>/Calib'
                                                                      * '<S2400>/Calib'
                                                                      * '<S5189>/Calib'
                                                                      * '<S4632>/Calib'
                                                                      * '<S4673>/Calib'
                                                                      * '<S4705>/Calib'
                                                                      * '<S4725>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BTLHTL_ILHEX = 1;/* Referenced by: '<S1984>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BTLMBCLegcySel = 0;/* Referenced by: '<S3104>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblRA_BattCoolingFlt_PsvCool

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BTOSFlty_Disbl_RA4PsvCool
    = 1;                               /* Referenced by: '<S288>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BatClntVlv2CtrlCktLo_En =
    1;                                 /* Referenced by: '<S2711>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BatClntVlvBStkOn_En = 1;/* Referenced by: '<S2712>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BatCndRq_ChkdCaseSix = 0;/* Referenced by: '<S1685>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BatCntctrStat_SelDial = 0;/* Referenced by: '<S3988>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BatPerWU_ThrmlCond_Timer_SD = 1;/* Referenced by: '<S3390>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BatThrmlSt_SelDial = 0;/* Referenced by: '<S318>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BattActvPsvOvrride_BattLTCL = 1;/* Referenced by: '<S4659>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BattActvPsvOvrride_CellLTCL = 1;/* Referenced by: '<S4660>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BattActvPsvOvrride_LTCLtooCold = 1;/* Referenced by: '<S4661>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattAllowed_D = 0;/* Referenced by: '<S4216>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattAllowed_SD = 0;/* Referenced by: '<S4217>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattAllowedtableNewLogic =
    1;                                 /* Referenced by: '<S4218>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattCabPriority_SD = 0;/* Referenced by: '<S217>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BattClntMaxTgt_UseTempAllowMode = 0;/* Referenced by: '<S366>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattCntctrOpenPndg_D = 0;/* Referenced by: '<S32>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattCntctrOpenPndg_Sel =
    0;                                 /* Referenced by: '<S33>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattCondPlugin_RqDial = 0;/* Referenced by: '<S205>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattCondPlugin_Rq_Dum4BSG
    = 0;                               /* Referenced by: '<S206>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattCondPlugin_Rq_Enb = 0;/* Referenced by: '<S209>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattCondPlugin_Rq_SD = 0;/* Referenced by: '<S207>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BattCritAllowBattActvPsvHeat = 1;/* Referenced by: '<S4618>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BattCritical_EnblEngOnReqmHEV = 0;/* Referenced by: '<S1416>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattHtr_PwrWup_Ovrd = 0;/* Referenced by: '<S3192>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattHtr_State_SelDial = 0;/* Referenced by: '<S2246>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BattLoopEmrgncyCool_EnblEngOnReqmHEV = 0;/* Referenced by: '<S1417>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BattPsvCool_BTISMaxAllwd_Ovrrd = 1;/* Referenced by: '<S4853>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattPsvCool_Dbnc_Ovrrd =
    0;                                 /* Referenced by: '<S4854>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattPsvCool_EmrgcyEnbl =
    1;                                 /* Referenced by: '<S4917>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattPwrDstrbt_Slct = 1;/* Referenced by: '<S3196>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BattRad_Airflow_Ovrrd = 1;/* Referenced by: '<S3109>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Branch_1_Flw_SD = 0;/* Referenced by: '<S251>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Branch_2_Flw_SD = 0;/* Referenced by: '<S252>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Branch_3_Flw_SD = 0;/* Referenced by: '<S253>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BstCnvtrLwrIGBT_Chk_Enbl =
    0;                                 /* Referenced by: '<S2621>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BstCnvtrLwrIGBT_FA_Chk_Enbl = 0;/* Referenced by: '<S2622>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BstCnvtrLwrIGBT_TmpFltdFA_D = 0;/* Referenced by: '<S2273>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BstCnvtrLwrIGBT_TmpFltdFA_SD = 0;/* Referenced by: '<S2274>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BstCnvtrReactorTmpFA_Chk_Enbl = 0;/* Referenced by: '<S2623>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BstCnvtrReactorTmpFA_D =
    0;                                 /* Referenced by: '<S2275>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BstCnvtrReactorTmpFA_SD =
    0;                                 /* Referenced by: '<S2276>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BstCnvtrReactorTmp_Chk_Enbl = 0;/* Referenced by: '<S2624>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BstCnvtrUpprIGBT_Chk_Enbl
    = 0;                               /* Referenced by: '<S2625>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BstCnvtrUpprIGBT_FA_Chk_Enbl = 0;/* Referenced by: '<S2626>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BstCnvtrUpprIGBT_TmpFltdFA_D = 0;/* Referenced by: '<S2277>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BstCnvtrUpprIGBT_TmpFltdFA_SD = 0;/* Referenced by: '<S2278>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BypassHTAPDryRun = 1;/* Referenced by: '<S4429>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_BypassHTAPDryRun_CabinActvPsvHeat = 0;/* Referenced by: '<S4929>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BypassHTAP_FltDtct = 0;/* Referenced by: '<S4430>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_BypassHTAP_LOC = 0;/* Referenced by: '<S4431>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CAC_Enbl_Branch1 = 0;/* Referenced by: '<S2892>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CAC_Enbl_Branch2 = 0;/* Referenced by: '<S2893>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabAllowCond_Dsbl = 0;/* Referenced by: '<S5297>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabAllowed_D = 0;/* Referenced by: '<S4317>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabAllowed_SD = 0;/* Referenced by: '<S4318>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabAllw_Defrost = 1;/* Referenced by: '<S4319>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabAllw_RS = 1;/* Referenced by: '<S4320>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabAlwd_OVst1_Enbl = 1;/* Referenced by: '<S4328>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabAlwd_OVst1_Enbl1 = 1;/* Referenced by: '<S4329>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabAlwd_OVst1_Enbl2 = 1;/* Referenced by: '<S4330>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabAlwd_OVst2_Enbl = 1;/* Referenced by: '<S4331>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabCondKeyRun_NoPlugIn =
    0;                                 /* Referenced by: '<S4378>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabDsblRemEnbl = 1;/* Referenced by: '<S4292>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabDsblShippingEnbl = 1;/* Referenced by: '<S4293>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabHeatPumpAllowEnbl = 0;/* Referenced by: '<S5596>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_CabHeatReq_NotAllow_CabActv = 0;/* Referenced by: '<S4260>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabHeat_OldApp = 0;/* Referenced by: '<S1418>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_CabNotAlw_KeyRun_TurnOff_SD = 0;/* Referenced by: '<S4255>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabPrecDny_BattCond_Dial =
    0;                                 /* Referenced by: '<S323>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabPrecDny_BattCond_SD =
    0;                                 /* Referenced by: '<S324>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabReq_NotAllow_Dial = 0;/* Referenced by: '<S4261>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabReq_NotAllow_SelDial =
    0;                                 /* Referenced by: '<S4262>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabinPreCondActive_Dial =
    0;                                 /* Referenced by: '<S267>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabinPreCondActive_SD = 0;/* Referenced by: '<S268>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabinPreCondReqStCAN_SD =
    0;                                 /* Referenced by: '<S330>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabinPreCondReqStMsg_SD =
    0;                                 /* Referenced by: '<S331>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabinPreCondReqStat_SD =
    0;                                 /* Referenced by: '<S332>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CabinPwrNeed_PIEnbl = 0;/* Referenced by:
                                                                      * '<S1251>/Calib'
                                                                      * '<S1264>/Calib'
                                                                      */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CellOverTemp_SelDial = 0;/* Referenced by: '<S211>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Charg_PlgdIn_Sel = 0;/* Referenced by: '<S4491>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ChargingLevel_SelDial = 0;/* Referenced by: '<S540>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CheckExpectdPwr_Enb = 0;/* Referenced by: '<S1765>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ChrgCrntReqDelta_SD = 0;/* Referenced by: '<S541>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_ClntNProp3WyVlv_State_SelDial = 0;/* Referenced by: '<S5650>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_ClntProp3WyVlv_State_SelDial = 0;/* Referenced by: '<S5659>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ClntTemp4Pmp_SD = 1;/* Referenced by: '<S1927>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Clnt_In_Temp_FA_Enbld = 1;/* Referenced by: '<S2627>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Clnt_In_Temp_OT_ThrsldEnbld = 0;/* Referenced by: '<S2628>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Clnt_Out_Temp_FA_Enbld =
    1;                                 /* Referenced by: '<S2629>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Clnt_Out_Temp_OT_ThrsldEnbld = 0;/* Referenced by: '<S2630>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_CntrlBoard_TempLo_OT_ThrsldEnbld = 1;/* Referenced by: '<S2499>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_CntrlBrdTmp_Snsr2OT_ThrsldEnbld = 1;/* Referenced by: '<S2631>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_CntrlBrdTmp_Snsr2_FA_Enbld = 1;/* Referenced by: '<S2632>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_CntrlBrdTmp_Snsr2_OTLo_Enbld = 1;/* Referenced by: '<S2500>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CntrlBrdTmp_Src = 0;/* Referenced by: '<S2742>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CommBus_B_Off_Ovrd = 1;/* Referenced by:
                                                                      * '<S5330>/Calib'
                                                                      * '<S4308>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_CompFlts_SD = 0;/* Referenced by: '<S2162>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DbgDsblEmrgcyRunApp_Enbl =
    0;                                 /* Referenced by: '<S2733>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DeIcingStartOverrid = 0;/* Referenced by: '<S4997>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DeIcngANDORStrtgySelect =
    1;                                 /* Referenced by: '<S4998>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DefrostVhcleMode_Dial = 0;/* Referenced by: '<S407>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DefrostVhcleMode_DialSlct
    = 0;                               /* Referenced by: '<S408>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Defrost_D = 0;/* Referenced by: '<S2167>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Defrost_SD = 0;/* Referenced by: '<S2168>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DisableLearningFrAftrrun =
    1;                                 /* Referenced by: '<S3631>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DisblChkFanOffEmrLvl1 = 0;/* Referenced by: '<S2501>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DisblFunc_Msg_10_D = 0;/* Referenced by: '<S3388>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DisblFunc_Msg_10_SD = 1;/* Referenced by: '<S3389>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DrvDrAjar_Dial = 0;/* Referenced by: '<S3962>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DrvDrAjar_SelDial = 0;/* Referenced by: '<S3963>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblActvCool = 0;/* Referenced by: '<S4743>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblActvCoolChk = 0;/* Referenced by: '<S4806>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblActvHeat = 0;/* Referenced by: '<S4730>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblAmbChk_ActvCool = 1;/* Referenced by: '<S4744>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblAmbChk_PsvCool = 1;/* Referenced by: '<S4892>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblBattActvPassiveHeat =
    0;                                 /* Referenced by: '<S4619>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_DsblBattAllwChk_OptPriority = 1;/* Referenced by: '<S1193>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblBattAllwd_D = 0;/* Referenced by: '<S4611>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblBattAllwd_SD = 0;/* Referenced by: '<S4612>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblBattWasteHeatRcvry =
    0;                                 /* Referenced by: '<S4764>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblCabActvPsvHeat = 0;/* Referenced by: '<S4930>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblCellBalChk = 0;/* Referenced by:
                                                                      * '<S4620>/Calib'
                                                                      * '<S4682>/Calib'
                                                                      * '<S4807>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblClntLoChk = 0;/* Referenced by:
                                                                      * '<S4621>/Calib'
                                                                      * '<S4683>/Calib'
                                                                      * '<S4808>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_DsblDfrst_HybAltMdShedRejCab = 0;/* Referenced by: '<S4294>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblDfrst_LoadShedRejCab =
    0;                                 /* Referenced by: '<S4295>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblDryRunChk = 0;/* Referenced by:
                                                                      * '<S4666>/Calib'
                                                                      * '<S4718>/Calib'
                                                                      * '<S4908>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblDryRunFAChk = 0;/* Referenced by:
                                                                      * '<S4667>/Calib'
                                                                      * '<S4719>/Calib'
                                                                      * '<S4909>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblEDUWasteHeatRcvry = 0;/* Referenced by: '<S5120>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblEngBlwr_RS = 0;/* Referenced by: '<S1467>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblEngReq_RS = 0;/* Referenced by: '<S1704>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblFCActvPsvHeat = 0;/* Referenced by: '<S5093>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblFCBoostCool = 0;/* Referenced by: '<S5077>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblFCPsvCool = 0;/* Referenced by: '<S5087>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblImpctChk = 1;/* Referenced by:
                                                                      * '<S4622>/Calib'
                                                                      * '<S4684>/Calib'
                                                                      * '<S4809>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblImpct_EmrgncyCool = 1;/* Referenced by: '<S4798>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_DsblLTCLTooHotCheck_frWcondLTRSup = 1;/* Referenced by: '<S5145>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblLTRVlv_PropCntrl = 1;/* Referenced by: '<S2748>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_DsblMinEDMHeatGen_FrClntHeatAbsrb = 1;/* Referenced by: '<S2421>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblNoCabChk_OptPriority =
    1;                                 /* Referenced by: '<S1194>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblPSA_HghSOC_LwTmp = 1;/* Referenced by: '<S1722>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblPWup_HghSOC_LwTmp = 1;/* Referenced by: '<S1723>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblPassiveCool = 0;/* Referenced by: '<S4810>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblPassiveHeat = 0;/* Referenced by: '<S4685>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Dsbl_ActvCoolFltsChk = 1;/* Referenced by: '<S4754>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Dsbl_CabPrecChk_CabNotAllw = 0;/* Referenced by: '<S4370>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Dsbl_CabPrecChk_CabNotAllwSOC = 0;/* Referenced by: '<S4345>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Dsbl_CabPrecChk_NoCabPwrBdgtPstStart = 1;/* Referenced by: '<S4556>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Dsbl_CabPrecChk_NoCabPwrBdgt_PreStart = 1;/* Referenced by: '<S4557>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Dsbl_Dfrst_CabNotAllwKeyRun = 1;/* Referenced by: '<S4371>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Dsbl_Dfrst_CabNotAllwSOC =
    0;                                 /* Referenced by: '<S4346>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Dsbl_Dfrst_HAM = 0;/* Referenced by: '<S4265>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Dsbl_Dfrst_LoadShed = 0;/* Referenced by: '<S4267>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Dsbl_Dfrst_NoCabPwrBdgtKeyCrnkStart = 1;/* Referenced by: '<S4558>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Dsbl_Dfrst_NoCabPwrBdgtKeyPreStart = 1;/* Referenced by: '<S4559>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Dsbl_Dfrst_TurtlMd = 0;/* Referenced by: '<S4271>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Dsbl_HAM_NoCab = 0;/* Referenced by: '<S4266>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Dsbl_OV_LoadShed_BatteryCond = 0;/* Referenced by: '<S4238>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Dsbl_OV_LoadShed_CabinCond = 0;/* Referenced by: '<S4268>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblRA_BattCoolingFlt_PsvCool

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Dsbl_PressSnsrThChk4RA =
    0;                                 /* Referenced by: '<S296>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblcoolreqChk_ActvCool =
    0;                                 /* Referenced by: '<S4745>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DsblcoolreqChk_PsvCool =
    0;                                 /* Referenced by: '<S4811>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DschrgActvEnbl_VehThrmlSt
    = 0;                               /* Referenced by: '<S481>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_DualPmpsIn_LTCL = 0;/* Referenced by: '<S2808>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EAHInvData_HtrFlty_RA = 0;/* Referenced by: '<S1511>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECHInvData_HtrFlty_RA = 0;/* Referenced by: '<S1512>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECHOutTemp_HCCTIS_Dial =
    0;                                 /* Referenced by: '<S1419>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECHTmpIn_HtrFlty_RA = 1;/* Referenced by: '<S1513>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECHTmpOut_HtrFlty_RA = 1;/* Referenced by: '<S1514>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECHWishedPwr_OldApp = 0;/* Referenced by: '<S1732>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECH_ClntTempTgt_SelDial =
    0;                                 /* Referenced by: '<S2208>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_ECH_HtrPwrTgt_FuelEcnmy_KeyEnb = 1;/* Referenced by: '<S1639>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_ECH_HtrPwrTgt_FuelEcnmy_e_SD = 1;/* Referenced by: '<S1640>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECH_HtrPwrTgt_SelDial = 0;/* Referenced by: '<S2205>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECH_WshdPwr_SkipHtrState =
    1;                                 /* Referenced by: '<S1760>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECH_WshdPwr_SkipLatch = 1;/* Referenced by: '<S1766>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECH_WshdPwr_SkipTimer = 1;/* Referenced by: '<S1737>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECH_WshdPwr_UseClntTmp =
    0;                                 /* Referenced by:
                                        * '<S1784>/Calib'
                                        * '<S1761>/Calib'
                                        */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECH_WshdPwr_UsePwrBdgt =
    1;                                 /* Referenced by: '<S1747>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECM_LTPsvPmpRq_D = 0;/* Referenced by: '<S114>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECM_LTPsvPmpRq_Enbl = 1;/* Referenced by: '<S2900>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECM_LTPsvPmpRq_FA_D = 0;/* Referenced by: '<S115>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECM_LTPsvPmpRq_FA_SD = 0;/* Referenced by: '<S116>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECT_HotDisFan_IgnorFanSts
    = 1;                               /* Referenced by: '<S2862>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECT_Sgnl_Rcvd_D = 0;/* Referenced by: '<S3885>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ECT_Sgnl_Rcvd_SD = 0;/* Referenced by: '<S3886>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EOPEmrgCool_AHH_Enbld = 0;/* Referenced by: '<S2633>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EOPEmrgCool_MtrA_Enbld =
    0;                                 /* Referenced by: '<S2634>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EOPEmrgCool_MtrB_Enbld =
    0;                                 /* Referenced by: '<S2635>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EOP_A_EmrgCool_SD = 0;/* Referenced by: '<S718>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EOP_B_EmrgCool_SD = 0;/* Referenced by: '<S720>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_ElVlv3WayFuCellCtlDftSel_C = 0;/* Referenced by: '<S953>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ElVlv3WayFuCellMixPtSel_C
    = 0;                               /* Referenced by: '<S982>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_EmergencyRun_DisableDebounceRST = 0;/* Referenced by: '<S2734>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EmrgcyFanRq_Lvl_SD = 0;/* Referenced by: '<S1146>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_EmrgncyFanFlashing_App_Sel = 0;/* Referenced by: '<S2735>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_EmrgyRunSwitchLv1or2_P0C73 = 0;/* Referenced by:
                                             * '<S2524>/Calib'
                                             * '<S2705>/Calib'
                                             */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnbAHPInletTempArb = 1;/* Referenced by: '<S1906>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblAHPforActvCoolReq = 1;/* Referenced by: '<S1886>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblAHPforDeicing = 0;/* Referenced by: '<S1898>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_EnblBatActvPsvHeatChck4HTCLVlv = 0;/* Referenced by: '<S1985>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_EnblBattActvCoolCond_frWcondLTRSup = 1;/* Referenced by: '<S5146>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_EnblBattHeatChck4LTRbypassInER = 1;/* Referenced by: '<S5197>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblBattPsvClngChck2 = 0;/* Referenced by: '<S4893>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_EnblCabActvCoolCond_frWcondLTRSup = 1;/* Referenced by: '<S5147>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblCabPrecSPR_HTCVLrn =
    1;                                 /* Referenced by: '<S2154>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblCabPrecSPR_PrecStat2 =
    1;                                 /* Referenced by: '<S269>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblFEDMheatEstmCalc = 0;/* Referenced by: '<S2422>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblHTCV_CktHiFlt = 1;/* Referenced by: '<S1853>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblHTCV_CktLoFlt = 1;/* Referenced by: '<S1854>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblHTCV_CktOpenFlt = 1;/* Referenced by: '<S1855>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblHTCV_Leak_Flt = 1;/* Referenced by: '<S1856>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblHTCV_Stck_Flt = 1;/* Referenced by: '<S1857>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_EnblHTLVlvStckSNAAndBattNotCrit_RA = 1;/* Referenced by: '<S4537>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblHT_CabVlvSts_FA = 1;/* Referenced by: '<S1858>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblHtr1_HtrFlty_RA = 1;/* Referenced by: '<S1515>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblHtr2_HtrFlty_RA = 0;/* Referenced by: '<S1516>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblHybAltMd_RejCab = 1;/* Referenced by: '<S4296>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblKeyCrnkCabNotAllw = 1;/* Referenced by: '<S4372>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblKeyPostCrnkCabNotAllw
    = 1;                               /* Referenced by: '<S4373>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblLTRInTempArb = 1;/* Referenced by: '<S4474>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_EnblLTRVlvStckClsdAndBattNotCrit_RA = 1;/* Referenced by: '<S4538>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblLoadShed_RejCab = 1;/* Referenced by: '<S4297>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblNewPwrDsrbtn = 1;/* Referenced by: '<S1420>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblPPCTISArb = 1;/* Referenced by: '<S4484>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblREDMheatEstmCalc = 0;/* Referenced by: '<S2423>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_RacePrepCrrntLim

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblRacePrepChargeCntrl =
    1;                                 /* Referenced by: '<S3737>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_EnblRacePrepDrag_VehThrmlSt = 1;/* Referenced by: '<S482>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_EnblRacePrepTrack_VehThrmlSt = 1;/* Referenced by: '<S483>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblSOCTh_BattCond_NoCab =
    0;                                 /* Referenced by: '<S4362>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblTmpDiff_PPCTIS_BTIS =
    1;                                 /* Referenced by: '<S4894>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblWCondHeat_CabAssist =
    0;                                 /* Referenced by: '<S2106>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EnblWasteCalc_WithAHPEnbl
    = 1;                               /* Referenced by: '<S1705>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_BTISHiChk_PsvCool =
    1;                                 /* Referenced by: '<S4855>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_BattAllwd_ActvCool =
    0;                                 /* Referenced by: '<S4762>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Enbl_BattAllwd_ActvPsvHeat = 0;/* Referenced by: '<S4668>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Enbl_BattAllwd_ActvWsteHeatRecovry = 0;/* Referenced by: '<S4787>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Enbl_BattAllwd_EmrgncyCool = 0;/* Referenced by: '<S4799>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_BattAllwd_PsvCool =
    0;                                 /* Referenced by: '<S4910>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_BattAllwd_PsvHeat =
    0;                                 /* Referenced by: '<S4720>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_BattAllwd_balancing =
    0;                                 /* Referenced by: '<S4732>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_BattCPV_Vlv_Open_SNA
    = 0;                               /* Referenced by: '<S5168>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_BattTmpChk = 1;/* Referenced by: '<S1862>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_ChilVlvCktHi = 0;/* Referenced by: '<S4755>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_CoolPerfFlt = 0;/* Referenced by: '<S4756>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_EACPerfFlt = 0;/* Referenced by: '<S4757>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_ElecClntHtr_ThChk =
    1;                                 /* Referenced by: '<S1863>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Enbl_EmrgyRun1_ForFanFault = 0;/* Referenced by: '<S2512>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_EmrgyRun1_SnsrBCktHi
    = 0;                               /* Referenced by: '<S2516>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_EmrgyRun1_SnsrBCktLo
    = 0;                               /* Referenced by: '<S2517>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_EmrgyRun1_SnsrBPerf =
    0;                                 /* Referenced by: '<S2518>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Enbl_EmrgyRun2_ForFanFault = 1;/* Referenced by: '<S2694>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_EmrgyRun_P0A01 = 1;/* Referenced by: '<S2717>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_EmrgyRun_P0C73 = 1;/* Referenced by:
                                                                      * '<S2525>/Calib'
                                                                      * '<S2706>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_EmrgyRun_P0C74 = 1;/* Referenced by: '<S2707>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_EmrgyRun_P0CEA = 1;/* Referenced by: '<S2718>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Enbl_EmrgyRun_P0CEA_SngPmp = 1;/* Referenced by: '<S2719>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_EmrgyRun_P0CEF = 1;/* Referenced by: '<S2720>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_EmrgyRun_P1EA3 = 1;/* Referenced by: '<S2721>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_EngHot_On = 0;/* Referenced by: '<S1877>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Enbl_FltRct_BattCoolPmpPerf = 0;/* Referenced by: '<S4603>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_FltRct_CoolHtrALOC =
    0;                                 /* Referenced by: '<S4969>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_FltRct_CoolHtrAPerf =
    0;                                 /* Referenced by: '<S4970>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_FltRct_CoolPmpALOC =
    0;                                 /* Referenced by: '<S4971>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_FltRct_CoolPmpAPerf =
    0;                                 /* Referenced by: '<S4972>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Enbl_FltRct_CoolantHeaterBPerf = 0;/* Referenced by: '<S4604>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Enbl_FltRct_LostCommHB_CoolPmp = 0;/* Referenced by: '<S4605>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Enbl_FltRct_LostCommHB_CooltHtr4 = 0;/* Referenced by: '<S4606>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_HCCTIS_CrctHigh_flt =
    1;                                 /* Referenced by: '<S1801>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_HCCTIS_CrctLow_flt =
    1;                                 /* Referenced by: '<S1802>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_HCCTIS_Rtnlty_flt =
    1;                                 /* Referenced by: '<S1803>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_HCCTOS_CrctHigh_flt =
    1;                                 /* Referenced by:
                                        * '<S1810>/Calib'
                                        * '<S4411>/Calib'
                                        */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_HCCTOS_CrctLow_flt =
    1;                                 /* Referenced by:
                                        * '<S1811>/Calib'
                                        * '<S4412>/Calib'
                                        */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_HCCTOS_Rtnlty_flt =
    1;                                 /* Referenced by:
                                        * '<S1812>/Calib'
                                        * '<S4413>/Calib'
                                        */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_HVACECOModeGainSel =
    0;                                 /* Referenced by: '<S1280>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_HeatPmpModeGainSel =
    0;                                 /* Referenced by: '<S1281>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Enbl_HghRfrgtPres_CrctHigh_flt = 1;/* Referenced by: '<S303>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Enbl_HghRfrgtPres_CrctLow_flt = 1;/* Referenced by: '<S304>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Enbl_HghRfrgtPres_Rtnlty_flt = 1;/* Referenced by: '<S305>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_Htr2Flty_ExpctdPwr =
    1;                                 /* Referenced by: '<S1706>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_LOCEACFlt = 0;/* Referenced by: '<S4758>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_LRCTOS_FA = 0;/* Referenced by: '<S2700>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Enbl_LTAPLOC_EnblRA_LTCLflow = 1;/* Referenced by: '<S2957>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_LTLAmb_PsvCool = 0;/* Referenced by: '<S4914>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_PECP2_DryRun_Flag =
    1;                                 /* Referenced by: '<S2521>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_PECP2_LOC_Flag = 1;/* Referenced by: '<S2522>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_PECP_DryRun_Flag = 1;/* Referenced by: '<S2519>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_PECP_LOC_Flag = 1;/* Referenced by: '<S2520>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_PresSnsrCktHi = 0;/* Referenced by: '<S4759>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_PresSnsrCktLo = 0;/* Referenced by: '<S4760>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_PresSnsrCktPerf = 0;/* Referenced by: '<S4761>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_RadFanFor_PowerDisp =
    1;                                 /* Referenced by: '<S2697>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Enbl_StateE_HtrFlty = 1;/* Referenced by: '<S1563>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EngAllowd_AmbTemp_Slct =
    1;                                 /* Referenced by: '<S1475>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EngAllowd_AmbTemp_dial =
    0;                                 /* Referenced by: '<S1476>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EngClntTmp_Out_SelDial =
    0;                                 /* Referenced by: '<S3887>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EngCoolantTemp_FA_D = 0;/* Referenced by: '<S3888>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EngCoolantTemp_FA_SD = 0;/* Referenced by: '<S3889>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EngOff_LH_Sel = 1;/* Referenced by: '<S4565>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EngReq_HtrFlty_RA_D = 0;/* Referenced by: '<S1533>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EngReq_HtrFlty_RA_SD = 0;/* Referenced by: '<S1534>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EngSpdInc_AppSel = 0;/* Referenced by: '<S2847>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EngSpdInc_TempSel = 1;/* Referenced by: '<S2848>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EngSpd_SelDial = 0;/* Referenced by: '<S3978>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EngStartStopSt_SelDial =
    0;                                 /* Referenced by: '<S3972>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EngSysLowFuel_Dial = 0;/* Referenced by: '<S3974>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EngSysLowFuel_Sel = 1;/* Referenced by: '<S3975>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_EngTurnOff_AmbTmpSel = 0;/* Referenced by: '<S1588>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Eng_Htr_HTSOV_Stat_SD = 0;/* Referenced by: '<S338>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_FCAirdT4Airflw = 0;/* Referenced by:
                                                                      * '<S906>/Calib'
                                                                      * '<S879>/Calib'
                                                                      */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_FCAllowedtableNewLogic =
    1;                                 /* Referenced by: '<S4397>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_FCBoostCoolReq_ExcsvTemp =
    0;                                 /* Referenced by: '<S5082>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_FCCritCold_FCAllwdEnbl =
    0;                                 /* Referenced by: '<S4398>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_FCSDerate_AppSel = 1;/* Referenced by: '<S819>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_FCSDerationPwrSel = 0;/* Referenced by: '<S820>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_FCStblz_HtrAllwd = 1;/* Referenced by: '<S1334>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_FOTA_Install_Type_SD = 0;/* Referenced by: '<S257>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblRA_BattCoolingFlt_PsvCool

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_FanFlty_Disbl_RA4PsvCool =
    1;                                 /* Referenced by: '<S297>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_FlagDsblEmrgcyRunApp_Enbl
    = 0;                               /* Referenced by: '<S2736>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Flashing_Flag_D = 0;/* Referenced by: '<S4020>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Flashing_Flag_SD = 0;/* Referenced by: '<S4021>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_FrontEDM_UseTorqCmnd = 1;/* Referenced by: '<S2871>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_FrontRearWhlSpds_Mtr1_Mtr2_Slctr = 0;/* Referenced by: '<S710>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_GEN_PIM_EngOff_Ovrd = 1;/* Referenced by: '<S2931>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_GEN_UseTorqCmnd = 1;/* Referenced by: '<S2872>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HCBVStuckOpen_SwtchHCCTISwECHoutTemp = 1;/* Referenced by: '<S1804>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HCBVStuckSNA_SwtchHCCTISwECHoutTemp = 1;/* Referenced by: '<S1805>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HCP_LTP_FanAftRunRq_SD =
    0;                                 /* Referenced by: '<S3364>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HCP_LTP_FanAftRun_Rq_D =
    0;                                 /* Referenced by: '<S3368>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HCP_LTP_FanAftRun_Rq_SD =
    0;                                 /* Referenced by: '<S3369>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTAPFunPer_FltDtct_D = 0;/* Referenced by: '<S4008>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTAPFunPer_FltDtct_SD = 0;/* Referenced by: '<S4009>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTAuxPmpDryRunFA_D = 0;/* Referenced by: '<S3795>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTAuxPmpDryRunFA_SD = 0;/* Referenced by: '<S3796>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTAuxPmp_ClntWarmUp = 0;/* Referenced by: '<S3658>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTAuxPumpDryRun_SD = 0;/* Referenced by: '<S3797>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTAuxPump_FltDtctd_D = 0;/* Referenced by: '<S4006>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTAuxPump_FltDtctd_SD = 0;/* Referenced by: '<S4007>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTAuxPump_On_D = 0;/* Referenced by: '<S5315>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTAuxPump_On_SD = 0;/* Referenced by: '<S5316>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTAuxPump_OprtngSt_SD = 0;/* Referenced by: '<S3727>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTAuxPump_Slct = 1;/* Referenced by: '<S651>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTCL_HeatDistr_NoFault =
    0;                                 /* Referenced by: '<S1167>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTCL_Heat_Distrib_SelD =
    0;                                 /* Referenced by: '<S1843>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HTCL_Heat_Distrib_SelectDial = 1;/* Referenced by: '<S1829>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTCV_LearnEnbl_D = 0;/* Referenced by: '<S5662>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTCV_LearnEnbl_SD = 0;/* Referenced by: '<S5663>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTCV_LearnOkBat_OV_Dsbl =
    0;                                 /* Referenced by: '<S2150>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HTCV_LearnOkCab_CoolReqDsbl = 0;/* Referenced by: '<S2148>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HTCV_LearnOkCab_HeatReqDsbl = 0;/* Referenced by: '<S2137>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HTCV_LearnOkDsb_BatBalancin = 0;/* Referenced by: '<S2135>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HTCV_LearnOkPeriod_LeakFltDsbl = 0;/* Referenced by: '<S2146>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HTCV_LearnOkPeriod_Sts_FA_Dsbl = 0;/* Referenced by: '<S2144>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HTCV_LearnOkPeriod_StuckFltDsbl = 0;/* Referenced by: '<S2147>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTCV_LearnOkPeriod_WpDsbl
    = 0;                               /* Referenced by:
                                        * '<S2157>/Calib'
                                        * '<S2145>/Calib'
                                        */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTCV_LearnOk_BatCondDsb =
    0;                                 /* Referenced by: '<S2136>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTCV_LearnOk_RS_Dsbl = 0;/* Referenced by: '<S2155>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTCV_LearnOnWait_Dsbl = 1;/* Referenced by: '<S2123>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTCoolReq_Enbl = 1;/* Referenced by: '<S4399>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTLLTCLMBCEnbl = 0;/* Referenced by: '<S3235>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTLMBCLegcySel = 0;/* Referenced by:
                                                                      * '<S1168>/Calib'
                                                                      * '<S1398>/Calib'
                                                                      * '<S1937>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTLMBCSelect = 0;/* Referenced by:
                                                                      * '<S1169>/Calib'
                                                                      * '<S2046>/Calib'
                                                                      * '<S1938>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTSOV_Closed = 1;/* Referenced by: '<S2004>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTSOV_Cls_KeyRun_Charging
    = 1;                               /* Referenced by: '<S1456>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTSOV_Cmd_KeyRun = 1;/* Referenced by: '<S1444>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTSOV_DlydOpn_AbsVal_S =
    1;                                 /* Referenced by: '<S1643>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTSOV_DlydOpn_S = 0;/* Referenced by: '<S1623>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTSOV_FCBoostCooling = 0;/* Referenced by: '<S1993>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTSOV_Hyst_Enbl = 1;/* Referenced by: '<S1494>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTSOV_LTCLActvPsvHeating =
    0;                                 /* Referenced by: '<S2013>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTSOV_NoHeating = 1;/* Referenced by: '<S2030>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTSOV_Open = 0;/* Referenced by: '<S1996>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTSOV_VlvCmdCls_MaxAC = 1;/* Referenced by: '<S1445>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HTSO_VlvCmdCls_PmpCav = 1;/* Referenced by: '<S1446>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HT_AuxPmpCmd_SelDial = 0;/* Referenced by: '<S3676>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HT_CabVlvCmd_SelDial = 0;/* Referenced by: '<S5655>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HT_CabVlvSts_FA_Dial = 0;/* Referenced by: '<S4014>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HT_CabVlvSts_FA_SD = 0;/* Referenced by: '<S4015>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HT_Shtoff_VlvCmd_Dial = 0;/* Referenced by: '<S5656>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HT_Shtoff_VlvCmd_Dum4BSG =
    0;                                 /* Referenced by: '<S5657>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HT_Shtoff_VlvCmd_SelDial =
    0;                                 /* Referenced by: '<S5658>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HT_Shtoff_VlvCmd_TemporDial = 1;/* Referenced by: '<S1447>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HVACECOModeSts_SD = 0;/* Referenced by: '<S3960>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HVACEcoModHTSOVOpnEngRunVsHot = 0;/* Referenced by: '<S1707>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HVACPrrtyVhcleMode_Dial =
    0;                                 /* Referenced by: '<S415>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HVACPrrtyVhcleMode_DialSlct = 0;/* Referenced by: '<S416>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HVAC_HeatReq_Dial = 0;/* Referenced by: '<S3402>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HVAC_HeatReq_SelDial = 0;/* Referenced by: '<S3403>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HVAC_RdPerfModeFlg_SD = 0;/* Referenced by: '<S3396>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HVAC_turnedOff_Dial = 0;/* Referenced by: '<S3406>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HVAC_turnedOff_SelDial =
    0;                                 /* Referenced by: '<S3407>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HVBR_OvrdReq_Dial = 0;/* Referenced by: '<S7>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HVBR_OvrdReq_Dum4BSG = 0;/* Referenced by: '<S8>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HVBR_OvrdReq_SD = 0;/* Referenced by: '<S9>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HVDspt_Enbl_D = 0;/* Referenced by: '<S3803>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HVDspt_Enbl_SD = 0;/* Referenced by: '<S3804>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HV_BatPckSOC_SelDial = 0;/* Referenced by: '<S246>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HV_BatRdy_Dial = 0;/* Referenced by: '<S249>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HV_BatRdy_SelDial = 0;/* Referenced by: '<S250>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HV_BatRdy_True = 1;/* Referenced by: '<S4421>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HV_BatRdy_True_Sel = 1;/* Referenced by: '<S4422>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HV_BatTempCrit_Cond_Dial =
    0;                                 /* Referenced by: '<S3400>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HV_BatTempCrit_Cond_SelDial = 0;/* Referenced by: '<S3401>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HV_BatVolt_SD = 0;/* Referenced by: '<S248>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HV_Bat_CltLvlLo_SD = 0;/* Referenced by: '<S3386>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HV_PropSysActv_Dial = 0;/* Referenced by: '<S34>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HV_PropSysActv_SelDial =
    0;                                 /* Referenced by: '<S35>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HardCabHeatEng_AllwdEnb =
    1;                                 /* Referenced by: '<S1485>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HeadPress_Enbl_Branch1 =
    0;                                 /* Referenced by: '<S2894>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HeadPress_Enbl_Branch2 =
    0;                                 /* Referenced by: '<S2895>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HeatPumpEquipped = 1;/* Referenced by:
                                                                      * '<S5379>/Calib'
                                                                      * '<S4980>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HeatState_EngReq_Enbl = 0;/* Referenced by: '<S1421>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HeatState_HTSOV_Enbl = 0;/* Referenced by: '<S1422>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HghRfrgtPres_FA_Enb = 1;/* Referenced by: '<S2636>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HghRfrgtPres_SelDial = 0;/* Referenced by: '<S2166>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HighVoltageRapidShtdwnCmnd_Dial = 0;/* Referenced by: '<S3958>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HighVoltageRapidShtdwnCmnd_Sel = 1;/* Referenced by: '<S3959>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Hld_I_Term_ClntErr = 1;/* Referenced by: '<S5543>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Hld_I_Term_HtrAirFlw = 1;/* Referenced by: '<S5531>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Hld_I_Term_PresErr = 1;/* Referenced by: '<S5568>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Hld_I_Term_PsucErr = 1;/* Referenced by: '<S5555>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HoldContactrsOnKeyOFF = 0;/* Referenced by: '<S3632>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr1_Cntrl_Mchnztn_1 = 0;/* Referenced by: '<S4132>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr1_Cntrl_Mchnztn_2 = 0;/* Referenced by: '<S4133>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr1_Cntrl_Mchnztn_3 = 0;/* Referenced by: '<S4134>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr1_Cntrl_Mchnztn_4 = 0;/* Referenced by: '<S4135>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr1_Slctn_State = 0;/* Referenced by:
                                                                      * '<S2209>/Calib'
                                                                      * '<S4123>/Calib'
                                                                      */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr2ClntTempTgt_SelDial =
    0;                                 /* Referenced by: '<S2184>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr2PwrTgt_SelDial = 0;/* Referenced by: '<S2181>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr2_Cntrl_Mchnztn_1 = 0;/* Referenced by: '<S4152>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr2_Cntrl_Mchnztn_2 = 0;/* Referenced by: '<S4153>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr2_Cntrl_Mchnztn_3 = 0;/* Referenced by: '<S4154>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr2_Cntrl_Mchnztn_4 = 0;/* Referenced by: '<S4155>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr2_Slctn_State = 0;/* Referenced by:
                                                                      * '<S2210>/Calib'
                                                                      * '<S4124>/Calib'
                                                                      */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr2_State_SelDial = 0;/* Referenced by: '<S2243>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr3ClntTempTgt_SelDial =
    0;                                 /* Referenced by: '<S2192>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr3PwrTgt_SelDial = 0;/* Referenced by: '<S2189>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr3_Cntrl_Mchnztn_1 = 0;/* Referenced by: '<S4172>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr3_Cntrl_Mchnztn_2 = 0;/* Referenced by: '<S4173>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr3_Cntrl_Mchnztn_3 = 0;/* Referenced by: '<S4174>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr3_Cntrl_Mchnztn_4 = 0;/* Referenced by: '<S4175>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr3_Slctn_State = 0;/* Referenced by:
                                                                      * '<S2211>/Calib'
                                                                      * '<S4125>/Calib'
                                                                      */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr3_State_SelDial = 0;/* Referenced by: '<S2249>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr4ClntTempTgt_SelDial =
    0;                                 /* Referenced by: '<S2200>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr4PwrTgt_SelDial = 0;/* Referenced by: '<S2197>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr4_Cntrl_Mchnztn_1 = 0;/* Referenced by: '<S4192>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr4_Cntrl_Mchnztn_2 = 0;/* Referenced by: '<S4193>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr4_Cntrl_Mchnztn_3 = 0;/* Referenced by: '<S4194>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr4_Cntrl_Mchnztn_4 = 0;/* Referenced by: '<S4195>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr4_Slctn_State = 0;/* Referenced by:
                                                                      * '<S2212>/Calib'
                                                                      * '<S4126>/Calib'
                                                                      */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Htr4_State_SelDial = 0;/* Referenced by: '<S2252>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HtrCorClnt_Tmp_InFA_Dial =
    0;                                 /* Referenced by: '<S3392>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HtrCorClnt_Tmp_InFA_SelDial = 0;/* Referenced by: '<S3393>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HtrCorClnt_Tmp_In_FA_D =
    0;                                 /* Referenced by: '<S4023>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HtrCorClnt_Tmp_In_FA_SD =
    0;                                 /* Referenced by: '<S4024>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HtrCorClnt_Tmp_In_SD = 0;/* Referenced by: '<S4025>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_HtrCorTmp_ErrCmfrtAchvd_Dsbl = 1;/* Referenced by: '<S1583>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HtrCorTmp_ErrLargNegativ =
    0;                                 /* Referenced by: '<S1584>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HtrCorTmp_NegErr_Dsbl = 1;/* Referenced by: '<S1585>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HtrFltyEngAllw_D = 0;/* Referenced by: '<S1535>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HtrFltyEngAllw_SD = 0;/* Referenced by: '<S1536>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HtrLOC_HtrFlty_RA = 1;/* Referenced by: '<S1517>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_HybSysSt_SelDial = 0;/* Referenced by: '<S3984>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Hybrid_Altrntr_ModeRq_D =
    0;                                 /* Referenced by: '<S3394>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Hybrid_Altrntr_ModeRq_SD =
    0;                                 /* Referenced by: '<S3395>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_IDCM_BsdFlwTgt_Dsbl = 1;/* Referenced by: '<S3018>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Ignore_LoadShd = 0;/* Referenced by: '<S4239>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_IgnrBattCritFCActvPsvHeat
    = 0;                               /* Referenced by: '<S5094>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_IgnrCabHeat4BattPsvHeat =
    0;                                 /* Referenced by: '<S4706>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_IgnrClntCrtrea4BattPsvHeat = 0;/* Referenced by: '<S4692>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_IgnrDefrost4FCBoostCool =
    0;                                 /* Referenced by: '<S5078>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_IncldAPMflw_LTAPFlow = 0;/* Referenced by: '<S270>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_InductionAirTemp_SD = 0;/* Referenced by: '<S112>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_InhibitMsg4_CanCBusoff =
    1;                                 /* Referenced by: '<S4309>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_InhibitMsg4_CanEptBusoff =
    0;                                 /* Referenced by: '<S4310>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_InhibitMsg4_LIN2Busoff =
    1;                                 /* Referenced by: '<S4311>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_InhibitMsg4_ThrmlRlyFlt =
    1;                                 /* Referenced by: '<S4312>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_InitDfltCabPriorty = 1;/* Referenced by: '<S426>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_KeyAcc_HghSOC_LwTmp = 0;/* Referenced by: '<S1724>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_KeyInOFF_Pstn_D = 0;/* Referenced by: '<S3398>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_KeyInOFF_Pstn_SD = 0;/* Referenced by: '<S3399>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_KeyOff_HghSOC_LwTmp = 1;/* Referenced by: '<S1725>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_KeyRunOVBattCrit_frm_PDTR
    = 0;                               /* Referenced by: '<S3383>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_KeyRun_HghSOC_LwTmp = 0;/* Referenced by: '<S1726>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LIN1BusOff_HtrFlty_RA = 1;/* Referenced by: '<S1518>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LIN2BusOff_HtrFlty_RA = 1;/* Referenced by: '<S1519>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LINPrpVlv_SvCmndChk_Ovrd =
    0;                                 /* Referenced by: '<S2389>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LINPrplVlv_BatOV_Ovrd = 1;/* Referenced by: '<S2387>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LINPrplVlv_CalibReqOvrd =
    0;                                 /* Referenced by: '<S2313>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LINPrplVlv_CalibReq_D = 0;/* Referenced by: '<S5667>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LINPrplVlv_CalibReq_Dum4BSG = 0;/* Referenced by: '<S5668>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LINPrplVlv_CalibReq_SD =
    0;                                 /* Referenced by: '<S5669>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LINPrplVlv_Cmd_SD = 0;/* Referenced by: '<S5666>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LINPrplVlv_PrplMd = 0;/* Referenced by: '<S2365>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LINPrplVlv_SvReq_D = 0;/* Referenced by: '<S5670>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LINPrplVlv_SvReq_Dum4BSG =
    0;                                 /* Referenced by: '<S5671>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LINPrplVlv_SvReq_SD = 0;/* Referenced by: '<S5672>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblRA_BattCoolingFlt_PsvCool

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LTAPPerfFlt_Disbl_RA4PsvCool = 0;/* Referenced by: '<S291>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LTAPPerfFlt_EnblRA_LTCLflow = 1;/* Referenced by: '<S2958>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblRA_BattCoolingFlt_PsvCool

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LTAPTempFlt_Disbl_RA4PsvCool = 0;/* Referenced by: '<S292>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTAP_DryRun_DFIR_Ovrd = 0;/* Referenced by: '<S4244>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTAP_ExpOff_ActCoolChk_OV
    = 0;                               /* Referenced by: '<S5331>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTAP_ExpOff_ActSpdChk_OV =
    0;                                 /* Referenced by: '<S5332>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LTAP_ExpOff_BPCM_LINBusChk_OV = 0;/* Referenced by: '<S5333>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LTAP_ExpOff_BPCM_LOCChk_OV = 0;/* Referenced by: '<S5334>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTAP_ExpOff_BatBlncChk_OV
    = 0;                               /* Referenced by: '<S5335>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTAP_ExpOff_BatHeatChk_OV
    = 0;                               /* Referenced by: '<S5336>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LTAP_ExpOff_BatPsvCoolChk_OV = 0;/* Referenced by: '<S5337>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LTAP_ExpOff_BatPsvHeatChk_OV = 0;/* Referenced by: '<S5338>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTAP_ExpOff_CmndSpdChk_OV
    = 0;                               /* Referenced by: '<S5339>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTAP_ExpOff_Dial = 0;/* Referenced by: '<S5340>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTAP_ExpOff_FlwChk_OV = 0;/* Referenced by: '<S5341>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LTAP_ExpOff_FrcdBattCool_OV = 0;/* Referenced by: '<S5342>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LTAP_ExpOff_FrcdBattHeat_OV = 0;/* Referenced by: '<S5343>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTAP_ExpOff_LOCwBPCM_OV =
    0;                                 /* Referenced by: '<S5344>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTAP_ExpOff_RsErrChk_OV =
    0;                                 /* Referenced by: '<S5345>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTAP_ExpOff_SelDial = 0;/* Referenced by: '<S5346>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTAP_ExpOff_ePTBusOff_OV =
    0;                                 /* Referenced by: '<S5347>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTActPump_ExpOff_OV = 0;/* Referenced by: '<S4050>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTActPump_FltDtctd_D = 0;/* Referenced by: '<S4004>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTActPump_FltDtctd_SD = 0;/* Referenced by: '<S4005>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTActPump_On_D = 0;/* Referenced by: '<S5313>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTActPump_On_SD = 0;/* Referenced by: '<S5314>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTActPump_OprtngSt_SD = 0;/* Referenced by: '<S3724>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTActPump_Slct = 1;/* Referenced by: '<S652>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTActvPmp_ClntWarmUp = 0;/* Referenced by: '<S3659>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LTCLEmrgncyRun_FCBoostCool = 0;/* Referenced by: '<S2699>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTCLFBLEnbl = 0;/* Referenced by: '<S3022>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LTCLTgt_BattActvPsvHeating_SD = 0;/* Referenced by: '<S220>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTCL_HeatRejctFcn_OfFlw =
    0;                                 /* Referenced by: '<S2809>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTLFBL_LegFlow = 0;/* Referenced by: '<S2291>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTLFBL_MBCFlow = 0;/* Referenced by: '<S2292>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTLMBCEnbl = 0;/* Referenced by: '<S3100>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPP2_Enbl_Branch1 = 0;/* Referenced by: '<S2985>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPP2_Enbl_Branch2 = 0;/* Referenced by: '<S2986>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPP_Enbl_Branch1 = 0;/* Referenced by: '<S2987>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPP_Enbl_Branch2 = 0;/* Referenced by: '<S2988>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPmp2_ClntWarmUp = 0;/* Referenced by: '<S3660>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPmp_ClntWarmUp = 0;/* Referenced by: '<S3661>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPump2Temp_FA_D = 0;/* Referenced by: '<S4012>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPump2Temp_FA_SD = 0;/* Referenced by: '<S4013>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPump2_FltDtctd_D = 0;/* Referenced by: '<S4002>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPump2_FltDtctd_SD =
    0;                                 /* Referenced by: '<S4003>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPump2_On_D = 0;/* Referenced by: '<S5311>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPump2_On_SD = 0;/* Referenced by: '<S5312>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPump2_OprtngSt_SD =
    0;                                 /* Referenced by: '<S3721>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPump2_Slct = 1;/* Referenced by: '<S653>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPumpTemp_FA_D = 0;/* Referenced by: '<S4010>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPumpTemp_FA_SD = 0;/* Referenced by: '<S4011>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPump_FltDtctd_D = 0;/* Referenced by: '<S4000>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPump_FltDtctd_SD = 0;/* Referenced by: '<S4001>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPump_On_D = 0;/* Referenced by: '<S5309>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPump_On_SD = 0;/* Referenced by: '<S5310>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPump_OprtngSt_SD = 0;/* Referenced by: '<S3718>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTPsvPump_Slct = 1;/* Referenced by: '<S654>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LTRVlvStuckOpenBypass_DisblFan4LTR = 0;/* Referenced by: '<S5491>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LTRVlvStuckOpen_DisblFan4LTR = 0;/* Referenced by: '<S5492>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LTRVlvStuckSNA_DisblFan4LTR = 0;/* Referenced by: '<S5493>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTRVlv_SlctPIvPhysics = 1;/* Referenced by: '<S2781>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LTRVlv_SlvForPositionVlvOpn = 0;/* Referenced by: '<S2782>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTR_AirFlw_UseAmb = 0;/* Referenced by: '<S2810>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LTR_Flw_SD = 0;/* Referenced by: '<S3732>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_LT_ActPmpRPM_MinHtrEnb_Ovrd = 0;/* Referenced by: '<S4245>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LT_ActPmp_DryRunFA_Ovrd =
    0;                                 /* Referenced by: '<S4246>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LT_ActPmp_DryRun_Ovrd = 0;/* Referenced by: '<S4247>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LT_ActPmp_FltDtct_Ovrd =
    0;                                 /* Referenced by: '<S4248>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LT_ActvPmpCmd_SelDial = 0;/* Referenced by: '<S3672>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LT_PrssFlwRunning_Slct =
    1;                                 /* Referenced by: '<S2989>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LT_PsvPmp2Cmd_SelDial = 0;/* Referenced by: '<S3684>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LT_PsvPmp2Sts_SelDial = 0;/* Referenced by: '<S3801>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LT_PsvPmpCmd_SelDial = 0;/* Referenced by: '<S3681>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LT_PsvPmpRunning_Slct = 1;/* Referenced by: '<S2990>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LT_PsvPmpSts_SelDial = 0;/* Referenced by: '<S3799>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LdshedBattCondtn_Slct = 0;/* Referenced by: '<S4240>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LeaveKeyIn_RUN_Dial = 1;/* Referenced by: '<S3384>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LeaveKeyIn_RUN_SelDial =
    1;                                 /* Referenced by: '<S3385>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Loadshed_Slct_New = 0;/* Referenced by: '<S484>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_LosCommBECM_A_CANC11_Ovrd
    = 1;                               /* Referenced by: '<S5348>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MGU_AirInletTmp_UseIntakeTmp = 1;/* Referenced by: '<S2849>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MGU_ClntPumpFlw_SD = 0;/* Referenced by: '<S356>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MGU_ClntTmpOut_Enb = 0;/* Referenced by: '<S2811>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MGU_EngSpdInc_Req_SD = 0;/* Referenced by: '<S359>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MaskCmprNoiseEnbl = 0;/* Referenced by: '<S5597>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MaxAC_DefrostEnbl = 1;/* Referenced by: '<S1830>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MaxAC_Dsbl_BattAndCab = 0;/* Referenced by: '<S1831>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MaxAC_Dsbl_CabOnly = 0;/* Referenced by: '<S1832>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MaxAC_EnblDcrs_EngPwrWaste = 1;/* Referenced by: '<S1708>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MaxAC_Enbl_HTSOV_VlvCmdCls = 0;/* Referenced by: '<S1448>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MotorOutltTempCtrlEnbl =
    0;                                 /* Referenced by: '<S3078>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Mtr1_CoolFlwCmd_SelDial =
    0;                                 /* Referenced by: '<S3603>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Mtr1_TorqAchievedEnbl = 0;/* Referenced by: '<S667>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Mtr2_CoolFlwCmd_SelDial =
    0;                                 /* Referenced by: '<S3606>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Mtr2_TorqAchievedEnbl = 0;/* Referenced by: '<S689>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrAClassicDerate = 0;/* Referenced by: '<S3428>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrALubOilFlw_SD = 0;/* Referenced by: '<S5616>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrAOilFlwMaxLimit_SD = 0;/* Referenced by: '<S5617>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrAPwrDerate = 0;/* Referenced by: '<S3429>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrATorqueDerate = 1;/* Referenced by: '<S3430>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrA_CntrlBoard_Temp_FA_Enbld = 1;/* Referenced by: '<S2637>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrA_CntrlBoard_Temp_OT_ThrsldEnbld = 1;/* Referenced by: '<S2638>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrA_ElecPwrCalc_Tot_SelDial = 0;/* Referenced by: '<S3779>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrA_InvrtrTempDial_FA =
    0;                                 /* Referenced by: '<S3897>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrA_InvrtrTempFA_SelDial
    = 0;                               /* Referenced by: '<S3898>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrA_InvrtrTempLo_OT_ThrsldEnbld = 1;/* Referenced by: '<S2502>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrA_InvrtrTemp_FA_Enbld =
    1;                                 /* Referenced by: '<S2639>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrA_InvrtrTemp_OT_ThrsldEnbld = 1;/* Referenced by: '<S2640>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrA_InvrtrTemp_SelDial =
    0;                                 /* Referenced by: '<S3900>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrA_OilPumpTemp_FA_Enbld
    = 0;                               /* Referenced by: '<S2641>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrA_OilPumpTemp_ThrsldEnbld = 0;/* Referenced by: '<S2642>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrA_Rotor_Temp_FA_Enbld =
    1;                                 /* Referenced by: '<S2643>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrA_Rotor_Temp_OT_ThrsldEnbld = 1;/* Referenced by: '<S2644>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrA_Spd_SelDial = 0;/* Referenced by: '<S3746>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrA_TempDial_FA = 0;/* Referenced by: '<S3912>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrA_TempFA_SelDial = 0;/* Referenced by: '<S3913>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrA_TempLo_OT_ThrsldEnbld = 1;/* Referenced by: '<S2503>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrA_TempUse = 1;/* Referenced by: '<S2873>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrA_Temp_FA_Enbld = 1;/* Referenced by: '<S2645>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrA_Temp_OT_ThrsldEnbld =
    1;                                 /* Referenced by: '<S2646>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrA_Temp_SelDial = 0;/* Referenced by: '<S3915>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrA_TorqAchieved_SelDial
    = 0;                               /* Referenced by: '<S3757>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrA_TorqCmnd_SelDial = 0;/* Referenced by: '<S3759>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrBClassicDerate = 0;/* Referenced by: '<S3495>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrBLubOilFlw_SD = 0;/* Referenced by: '<S5618>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrBOilFlwMaxLimit_SD = 0;/* Referenced by: '<S5619>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrBPwrDerate = 0;/* Referenced by: '<S3496>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrBTorqueDerate = 1;/* Referenced by: '<S3497>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrB_CntrlBoard_Temp_FA_Enbld = 1;/* Referenced by: '<S2647>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrB_CntrlBoard_Temp_OT_ThrsldEnbld = 1;/* Referenced by: '<S2648>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrB_ElecPwrCalc_Tot_SelDial = 0;/* Referenced by: '<S3788>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrB_InvrtrTempDial_FA =
    0;                                 /* Referenced by: '<S3904>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrB_InvrtrTempFA_SelDial
    = 0;                               /* Referenced by: '<S3905>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrB_InvrtrTemp_FA_Enbld =
    1;                                 /* Referenced by: '<S2649>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrB_InvrtrTemp_OT_ThrsldEnbld = 1;/* Referenced by: '<S2650>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrB_InvrtrTemp_SelDial =
    0;                                 /* Referenced by: '<S3907>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrB_OilPumpTemp_FA_Enbld
    = 0;                               /* Referenced by: '<S2651>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrB_OilPumpTemp_ThrsldEnbld = 0;/* Referenced by: '<S2652>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrB_Rotor_Temp_FA_Enbld =
    1;                                 /* Referenced by: '<S2653>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrB_Rotor_Temp_OT_ThrsldEnbld = 1;/* Referenced by: '<S2654>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrB_Spd_SelDial = 0;/* Referenced by: '<S3748>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrB_TempDial_FA = 0;/* Referenced by: '<S3918>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrB_TempFA_SelDial = 0;/* Referenced by: '<S3919>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrB_Temp_FA_Enbld = 1;/* Referenced by: '<S2655>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrB_Temp_OT_ThrsldEnbld =
    1;                                 /* Referenced by: '<S2656>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrB_Temp_SelDial = 0;/* Referenced by: '<S3921>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrB_TorqAchieved_SelDial
    = 0;                               /* Referenced by: '<S3764>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrB_TorqCmnd_SelDial = 0;/* Referenced by: '<S3766>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrBorC_TempUse = 1;/* Referenced by: '<S2874>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrCClassicDerate = 0;/* Referenced by: '<S3553>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrCPwrDerate = 0;/* Referenced by: '<S3554>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrCTorqueDerate = 1;/* Referenced by: '<S3555>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_CntrlBoardTemp_FA_D =
    0;                                 /* Referenced by: '<S3823>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrC_CntrlBoardTemp_FA_Enbld = 0;/* Referenced by: '<S2657>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_CntrlBoardTemp_FA_SD
    = 0;                               /* Referenced by: '<S3824>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrC_CntrlBoardTemp_Fltr_Sel = 0;/* Referenced by: '<S3830>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrC_CntrlBoardTemp_OT_ThrsldEnbld = 0;/* Referenced by: '<S2658>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_CntrlBoardTemp_SD =
    0;                                 /* Referenced by: '<S3825>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrC_ElecPwrCalc_Tot_SelDial = 0;/* Referenced by: '<S3791>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_InvrtrTemp_FA_D = 0;/* Referenced by: '<S3810>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_InvrtrTemp_FA_Enbld =
    0;                                 /* Referenced by: '<S2659>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_InvrtrTemp_FA_SD = 0;/* Referenced by: '<S3811>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrC_InvrtrTemp_OT_ThrsldEnbld = 0;/* Referenced by: '<S2660>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_InvrtrTemp_SD = 0;/* Referenced by: '<S3812>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_Rotor_FA_Enbld = 0;/* Referenced by: '<S2661>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_Rotor_Temp_FA_D = 0;/* Referenced by: '<S3818>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_Rotor_Temp_FA_SD = 0;/* Referenced by: '<S3819>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrC_Rotor_Temp_OT_ThrsldEnbld = 0;/* Referenced by: '<S2662>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_Rotor_Temp_SD = 0;/* Referenced by: '<S3820>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_Spd_SelDial = 0;/* Referenced by: '<S3744>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_Temp_FA_D = 0;/* Referenced by: '<S3814>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_Temp_FA_Enbld = 0;/* Referenced by: '<S2663>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_Temp_FA_SD = 0;/* Referenced by: '<S3815>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_Temp_OT_ThrsldEnbld =
    0;                                 /* Referenced by: '<S2664>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_Temp_SD = 0;/* Referenced by: '<S3816>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_TorqAchieved_SelDial
    = 0;                               /* Referenced by: '<S3771>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrC_TorqCmnd_SelDial = 0;/* Referenced by: '<S3773>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrCapctrTempLo_OT_ThrsldEnbld = 1;/* Referenced by: '<S2504>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_MtrCapctrTemp_FA_Enbld =
    1;                                 /* Referenced by: '<S2665>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_MtrCapctrTemp_OT_ThrsldEnbld = 1;/* Referenced by: '<S2666>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_NoEngReqBlwr_InRS = 0;/* Referenced by: '<S1468>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_NoEngReq_InRS = 1;/* Referenced by: '<S1709>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_NoHysCellMaxOldLogic_BattAlw = 1;/* Referenced by: '<S4219>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_No_HVAC_Rq_Message4 = 0;/* Referenced by: '<S4256>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_NormalDrvVhclMode_Dial =
    0;                                 /* Referenced by: '<S445>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_NormalDrvVhclMode_DialSlct = 0;/* Referenced by: '<S446>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_NrmlPerWp_StateEnb = 1;/* Referenced by: '<S4301>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_NucleusOrFCA_SD = 0;/* Referenced by: '<S5598>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OAT_DisabDebnc_RST = 1;/* Referenced by: '<S23>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OBCMTemp1_FA_Enbld = 1;/* Referenced by: '<S2667>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_OBCMTemp1_Lo_OT_ThrsldEnbl = 1;/* Referenced by: '<S2505>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OBCMTemp1_OT_ThrsldEnbld =
    1;                                 /* Referenced by: '<S2668>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OBCMTemp2_FA_Enbld = 1;/* Referenced by: '<S2669>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_OBCMTemp2_Lo_OT_ThrsldEnbl = 1;/* Referenced by: '<S2506>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OBCMTemp2_OT_ThrsldEnbld =
    1;                                 /* Referenced by: '<S2670>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OBCMTemp3_Chk_Enbl = 0;/* Referenced by: '<S2671>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OBCMTemp3_FA_Chk_Enbl = 0;/* Referenced by: '<S2672>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OBCMTemp4_Chk_Enbl = 0;/* Referenced by: '<S2673>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OBCMTemp4_FA_Chk_Enbl = 0;/* Referenced by: '<S2674>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OVStateHeatPumpDsbl_Ovrd =
    1;                                 /* Referenced by: '<S4981>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OV_AmbChill_CabPwrSlct =
    1;                                 /* Referenced by: '<S1234>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_OV_AmbChill_CabPwrSlct_OldApp = 0;/* Referenced by: '<S1235>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OV_CabHeat_HTAP_Enb = 1;/* Referenced by: '<S1899>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OV_EPD_CondAmbTemp = 0;/* Referenced by: '<S1236>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OV_HTCV_FulOpn_StatFivEnb
    = 1;                               /* Referenced by: '<S1390>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_OV_HTCV_FulOpn_StatFourEnb = 1;/* Referenced by: '<S1391>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_OV_HTCV_FulOpn_StatThreeEnb = 1;/* Referenced by: '<S1392>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OV_SelClntTmpECHPwr = 1;/* Referenced by: '<S1237>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OffBoardPwrPnlPrsnt = 1;/* Referenced by: '<S485>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_OnBrdChrg_ClntTmpIn_FA_Enb = 1;/* Referenced by: '<S2675>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OutAirTemp_AdjstEnb = 1;/* Referenced by: '<S15>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OutAirTemp_EstV_Dial = 0;/* Referenced by: '<S18>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OutAirTemp_EstV_SelDial =
    0;                                 /* Referenced by: '<S19>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OutAirTemp_Est_FA_Enbld =
    1;                                 /* Referenced by: '<S2676>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OutAirTemp_Est_NoDebounce
    = 1;                               /* Referenced by: '<S24>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_OutAirTemp_Est_OT_ThrsldEnbld = 0;/* Referenced by: '<S2677>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OutAirTemp_Est_SelDial =
    0;                                 /* Referenced by: '<S25>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OverTempImminent_Dial = 0;/* Referenced by: '<S3968>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OverTempImminent_SelDial =
    0;                                 /* Referenced by: '<S3969>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OvrrdBattHeatReq4Pwr = 0;/* Referenced by: '<S1950>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OvrrdCabAllw4FtEvpMngmnt =
    0;                                 /* Referenced by: '<S4051>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_OvrrdDischrgChk_AvailEngPwr = 1;/* Referenced by: '<S1710>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OvrrdPmpStsCheck = 0;/* Referenced by: '<S3633>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_OvrrdWishedHtrPwr = 0;/* Referenced by: '<S1733>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_P1P2p5_MtrB_ClntInTemp_FA_D = 0;/* Referenced by: '<S174>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_P1P2p5_MtrB_ClntInTemp_FA_SD = 0;/* Referenced by: '<S175>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_P1P2p5_MtrB_ClntInTemp_SD
    = 0;                               /* Referenced by: '<S176>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_P1P2p5_MtrB_ClntOutTemp_FA_D = 0;/* Referenced by: '<S179>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_P1P2p5_MtrB_ClntOutTemp_FA_SD = 0;/* Referenced by: '<S180>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_P1P2p5_MtrB_ClntOutTemp_SD = 0;/* Referenced by: '<S181>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_P1P2p5_MtrB_CntrlBoardTemp_FA_D = 0;/* Referenced by: '<S165>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_P1P2p5_MtrB_CntrlBoardTemp_FA_SD = 0;/* Referenced by: '<S166>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_P1P2p5_MtrB_CntrlBoardTemp_Fltr_Sel = 0;/* Referenced by: '<S172>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_P1P2p5_MtrB_CntrlBoardTemp_SD = 0;/* Referenced by: '<S167>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_P1P2p5_MtrB_MtrCapctrTemp_FA_D = 0;/* Referenced by: '<S188>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_P1P2p5_MtrB_MtrCapctrTemp_FA_SD = 0;/* Referenced by: '<S189>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_P1P2p5_MtrB_MtrCapctrTemp_SD = 0;/* Referenced by: '<S190>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_P1P2p5_MtrB_Rotor_Temp_FA_D = 0;/* Referenced by: '<S160>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_P1P2p5_MtrB_Rotor_Temp_FA_SD = 0;/* Referenced by: '<S161>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_P1P2p5_MtrB_Rotor_Temp_SD
    = 0;                               /* Referenced by: '<S162>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PCCreq_battallowedEnbl =
    1;                                 /* Referenced by: '<S4220>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PDCSurfTemp_SD = 0;/* Referenced by: '<S260>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PDTRBattDschrgEnbl = 0;/* Referenced by: '<S4400>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PECP2_Enbl = 0;/* Referenced by:
                                                                      * '<S3634>/Calib'
                                                                      * '<S2812>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PECP2_RPM_Flw_OpSt = 1;/* Referenced by: '<S5318>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PECP_DR_FrcCPV_RA_Enbl =
    1;                                 /* Referenced by: '<S2371>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PECP_LOC_FrcCPV_RA_Enbl =
    1;                                 /* Referenced by: '<S2372>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PECP_Perf_FrcCPV_RA_Enbl =
    1;                                 /* Referenced by: '<S2373>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PECP_RPM_Flw_OpSt = 1;/* Referenced by: '<S5317>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PIM_Enbl_Branch1 = 0;/* Referenced by: '<S2896>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PIM_Enbl_Branch2 = 0;/* Referenced by: '<S2897>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PPCTIS_BTIS_Ovrrd = 0;/* Referenced by: '<S4856>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PPCTIS_CellMax_Enbl = 1;/* Referenced by: '<S4857>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PPCTIS_Fault_chk_Enbl = 1;/* Referenced by: '<S4485>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PPCTIS_OT_RemActEnb = 0;/* Referenced by: '<S2678>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PPCTIS_OT_SD = 0;/* Referenced by: '<S341>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PPCTIS_OT_SNA_RemActEnb =
    0;                                 /* Referenced by: '<S2679>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PPU_AirFlw_Enbl = 0;/* Referenced by: '<S5380>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PPU_Airflow_TypeSlct = 0;/* Referenced by: '<S5381>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PctPwrBasdCntrl = 0;/* Referenced by: '<S1341>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PerWpEng_AllowCaseSix_Enb
    = 1;                               /* Referenced by: '<S1686>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PerWpSts_CaseFivEnb = 1;/* Referenced by: '<S1684>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PerWp_TmpErr_SelApp = 1;/* Referenced by: '<S1910>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PerWupClntBsdAHPCntrl = 0;/* Referenced by: '<S1900>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PerWupOvrrd4CPV = 0;/* Referenced by: '<S2378>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PeriodWup_Msg2_Enb = 1;/* Referenced by: '<S210>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PeriodicWup_Dial = 0;/* Referenced by: '<S271>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PeriodicWup_SD = 0;/* Referenced by: '<S272>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PowerFault = 0;/* Referenced by: '<S5274>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ProactiveCondSPREnbl = 0;/* Referenced by: '<S486>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PropSysActv_100msSD = 0;/* Referenced by: '<S3936>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PropSysActv_100ms_D = 0;/* Referenced by: '<S3937>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_PsvCool_ChrgLvlAmbTemp_Enb = 0;/* Referenced by: '<S4858>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_PsvCool_ChrgPwrReqAmbTemp_Enb = 0;/* Referenced by: '<S4859>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PsvPump_DualChk_Enbl = 0;/* Referenced by: '<S2680>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PsvPump_SingleChk_Enbl =
    0;                                 /* Referenced by: '<S2681>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Pump2OilTemp_FA_D = 0;/* Referenced by: '<S3932>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Pump2OilTemp_FA_SD = 0;/* Referenced by: '<S3933>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Pump2OilTemp_SD = 0;/* Referenced by: '<S3935>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PumpOilFlwMap_EDMheatEstm
    = 0;                               /* Referenced by: '<S2424>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PumpOilTemp_FA_D = 0;/* Referenced by: '<S3926>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PumpOilTemp_FA_SD = 0;/* Referenced by: '<S3927>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PumpOilTemp_SD = 0;/* Referenced by: '<S3929>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PwrAvailConst_Select = 1;/* Referenced by: '<S1711>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PwrDstrbt_Slct = 1;/* Referenced by: '<S1712>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_PwrLevSet_SD = 0;/* Referenced by: '<S542>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_REMDisabled_D = 0;/* Referenced by: '<S3976>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_REMDisabled_SD = 0;/* Referenced by: '<S3977>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_RSA_StrtVhclRq_Dum4BSG =
    0;                                 /* Referenced by: '<S214>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_RSA_StrtVhclRq_SD = 0;/* Referenced by: '<S215>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_RSVFault = 0;/* Referenced by: '<S5289>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_RS_PerWp_StateEnb = 1;/* Referenced by: '<S4302>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_RU_CompStat_Dial = 0;/* Referenced by: '<S5296>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_RU_TstSwitch1 = 0;/* Referenced by: '<S5291>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_RadFanSts_SelDial = 0;/* Referenced by: '<S4019>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_RadFan_AGS_Enbl = 0;/* Referenced by: '<S5382>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_RadFan_State_SelDial = 0;/* Referenced by: '<S1143>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_RatEAC_PwrBdgt_Avail_SD =
    0;                                 /* Referenced by: '<S204>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_RdyForShtDwn_D = 0;/* Referenced by: '<S3370>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_RdyForShtDwn_Dum4BSG = 0;/* Referenced by: '<S3365>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_RdyForShtDwn_SD = 0;/* Referenced by: '<S3371>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_RearEDM_FrontEDM_UseOilTemp = 1;/* Referenced by: '<S2875>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_RearEDM_UseTorqCmnd = 1;/* Referenced by: '<S2876>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_RefPressFabPct_SF_dsbl =
    1;                                 /* Referenced by: '<S5446>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ResetCabPriortyDbnc = 1;/* Referenced by: '<S427>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ResetOnNewHeatReq = 1;/* Referenced by: '<S1537>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_RmtStrtAbort_StrtVhclRq_Dial = 0;/* Referenced by: '<S216>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_Rotor_TempLo_OT_ThrsldEnbld = 1;/* Referenced by: '<S2507>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SCCNRSreq_FCAllwdEnbl = 0;/* Referenced by: '<S4401>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SCCNRSreq_battallowedEnbl
    = 1;                               /* Referenced by: '<S4221>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SC_PrecTimer_SD = 0;/* Referenced by: '<S321>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SC_WkUpFlg_Dial = 0;/* Referenced by: '<S344>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SC_WkUpFlg_SD = 0;/* Referenced by: '<S345>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SC_WkUp_SD = 0;/* Referenced by: '<S346>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SOC_FuelDisbld = 0;/* Referenced by: '<S4342>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SOC_FuelUs_VehMod = 0;/* Referenced by: '<S4343>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SOC_Fuel_Nodefrst = 1;/* Referenced by: '<S4344>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SO_VlvCmdOpn_OV_Dial = 0;/* Referenced by: '<S1449>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SSDR_KeySts_SD = 0;/* Referenced by: '<S3966>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SelBattCrit_HVACFlag = 0;/* Referenced by: '<S4298>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SelCBCDoorAjar = 0;/* Referenced by: '<S3940>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_SelFacHeatTranCoefOutRadHiT_C = 1;/* Referenced by: '<S983>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SelFuCellHiTHEXTInTar_C =
    0;                                 /* Referenced by: '<S1105>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SelKMGen2EDMOilFlwStratgy
    = 0;                               /* Referenced by: '<S659>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SelOldCabPrecSt = 0;/* Referenced by: '<S333>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SelSOCCal_MoreToBatt = 0;/* Referenced by: '<S1199>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SelSOCCal_MoreToCab = 0;/* Referenced by: '<S1202>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SelSOCCal_MoreToCab_Opt =
    0;                                 /* Referenced by: '<S1190>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_SelTarTCoFuCellHiTSigOfs_C = 0;/* Referenced by: '<S1004>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SelWaPmpFuCellCtlOfs_C =
    0;                                 /* Referenced by: '<S910>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_SelectCellMinTempAllow_newApp = 0;/* Referenced by: '<S375>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SelectNewTempTgt_PsvRA =
    1;                                 /* Referenced by:
                                        * '<S374>/Calib'
                                        * '<S5165>/Calib'
                                        */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ShippingMode_SD = 0;/* Referenced by: '<S3982>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ShrdHtrHEXEnbl = 0;/* Referenced by:
                                                                      * '<S1322>/Calib'
                                                                      * '<S1360>/Calib'
                                                                      * '<S1379>/Calib'
                                                                      * '<S1382>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ShrdHtr_CombAllLoops = 1;/* Referenced by:
                                                                      * '<S5188>/Calib'
                                                                      * '<S5190>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ShutdownPending = 0;/* Referenced by: '<S5275>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_Slct_BSGMtrA_P1P2p5MtrB =
    0;                                 /* Referenced by: '<S108>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_StartAgain = 0;/* Referenced by: '<S5276>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SuctnPress_SD = 0;/* Referenced by: '<S2170>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SumpOilTmp_SelDial = 0;/* Referenced by: '<S3939>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_SupressThrmlEngOn_EVMode =
    1;                                 /* Referenced by:
                                        * '<S1487>/Calib'
                                        * '<S1480>/Calib'
                                        */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_TCU_Load_Index_Chk_Enbl =
    1;                                 /* Referenced by: '<S2682>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_TCU_Load_Index_FA_Chk_Enbl = 0;/* Referenced by: '<S2683>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_TWaOutRadHiTSpdAirSel_C =
    0;                                 /* Referenced by: '<S1005>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ThermSystEng_Req_Dial = 0;/* Referenced by: '<S3404>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ThermSystEng_Req_SelDial =
    0;                                 /* Referenced by: '<S3405>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ThreeW_N_Prop_Valve2_Dial
    = 0;                               /* Referenced by: '<S273>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ThreeW_N_Prop_Valve3_Dial
    = 0;                               /* Referenced by: '<S274>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ThreeW_Prop_Valve1_Dial =
    1;                                 /* Referenced by: '<S1345>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ThreeW_Prop_Valve2_Dial =
    0;                                 /* Referenced by: '<S275>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ThreeW_Prop_Valve3_Dial =
    0;                                 /* Referenced by: '<S276>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ThrmLoad_Shed_Dial = 0;/* Referenced by: '<S3986>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ThrmLoad_Shed_SelDial = 0;/* Referenced by: '<S3987>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_ThrmlRdyShtDwn_AftRun = 0;/* Referenced by: '<S71>/AfterRun' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_TransDirctnSt_SelDial = 0;/* Referenced by: '<S3990>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT)
    KeTHMR_b_TransOilTmp_OT_ThrsldEnbld = 1;/* Referenced by: '<S2684>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_TrueCabHeatOvrd = 0;/* Referenced by: '<S4924>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_UseActFlw4FanCntrol = 1;/* Referenced by: '<S2813>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_UseBTLMBCforOV = 0;/* Referenced by: '<S3219>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_UseCellUT4PerWupBattHeat =
    1;                                 /* Referenced by: '<S1238>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_UseFCVlvFdb4FlwEst = 0;/* Referenced by: '<S737>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_UseFdbFCVlvPos = 0;/* Referenced by: '<S738>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_UseFdbFCWaPmp = 0;/* Referenced by: '<S739>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_UseHLTMBCforOV = 0;/* Referenced by:
                                                                      * '<S2103>/Calib'
                                                                      * '<S1406>/Calib'
                                                                      */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_UseHTLLTCLMBCforOV = 0;/* Referenced by: '<S3236>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_UseLTRInTemp4VlvCntrl = 1;/* Referenced by: '<S5249>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_UseModeECHGains = 0;/* Referenced by: '<S1273>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_UseNucleusFCCntrls = 0;/* Referenced by: '<S740>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_UseSepPwr_P1P4 = 1;/* Referenced by: '<S1469>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_UseShrdHtrPI4Battheat = 0;/* Referenced by: '<S1951>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_VehicleSpd_SelDial = 0;/* Referenced by: '<S3964>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_VhclStatus = 0;/* Referenced by: '<S3344>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_WhlSpdLHF_FA_D = 0;/* Referenced by: '<S5620>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_WhlSpdLHF_FA_SD = 0;/* Referenced by: '<S5621>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_WhlSpdLHF_SD = 0;/* Referenced by: '<S5622>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_WhlSpdLHR_FA_D = 0;/* Referenced by: '<S5623>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_WhlSpdLHR_FA_SD = 0;/* Referenced by: '<S5624>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_WhlSpdLHR_SD = 0;/* Referenced by: '<S5625>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_WhlSpdRHF_FA_D = 0;/* Referenced by: '<S5626>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_WhlSpdRHF_FA_SD = 0;/* Referenced by: '<S5627>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_WhlSpdRHF_SD = 0;/* Referenced by: '<S5628>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_WhlSpdRHR_FA_D = 0;/* Referenced by: '<S5629>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_WhlSpdRHR_FA_SD = 0;/* Referenced by: '<S5630>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_WhlSpdRHR_SD = 0;/* Referenced by: '<S5631>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_isCharging_Dial = 0;/* Referenced by: '<S326>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_isCharging_Dial_Dum4BSG =
    0;                                 /* Referenced by: '<S327>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_isCharging_SelDial = 0;/* Referenced by: '<S328>/Calib' */

#endif

static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_thermalActivityCmplt_D =
    0;                                 /* Referenced by: '<S3372>/Calib' */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_b_thermalActivityCmplt_SD =
    0;                                 /* Referenced by: '<S3373>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dP_ChrgThermBdgtHyst =
    50.0F;                             /* Referenced by: '<S5300>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dP_FuCellMaxLimThDec_C =
    -5000.0F;                          /* Referenced by: '<S1045>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dP_FuCellMaxLimThInc_C =
    5000.0F;                           /* Referenced by: '<S1046>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dPct_BTLVlvCntrl_LD = -5.0F;/* Referenced by: '<S2339>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dPct_BTLVlvCntrl_LU = 5.0F;/* Referenced by: '<S2340>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dPct_DecHiTFuCellWaPmpPIDReq_C = -2.0F;/* Referenced by: '<S911>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dPct_HTCVCntrl_LD = -1.0F;/* Referenced by: '<S1372>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dPct_HTCVCntrl_LU = 1.0F;/* Referenced by: '<S1373>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dPct_HTLVlvCntrl_LD = -1.0F;/* Referenced by: '<S2023>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dPct_HTLVlvCntrl_LU = 1.0F;/* Referenced by: '<S2024>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dPct_HiTSpdAirReqDec_C =
    -20.0F;                            /* Referenced by: '<S1066>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dPct_HiTSpdAirReqInc_C =
    100.0F;                            /* Referenced by: '<S1067>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dPct_IncHiTFuCellWaPmpPIDReq_C = 4.0F;/* Referenced by: '<S912>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dT_AATClnt_EnblHPWasteHeatRcvry_LSP = -2.0F;/* Referenced by:
                                                        * '<S5254>/Calib'
                                                        * '<S4789>/Calib'
                                                        */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dT_AATClnt_EnblHPWasteHeatRcvry_RSP = 10.0F;/* Referenced by:
                                                        * '<S5255>/Calib'
                                                        * '<S4790>/Calib'
                                                        */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dT_AATClnt_EnblOhxHPWasteHeatRcvry_LSP = -2.0F;/* Referenced by:
                                                           * '<S5008>/Calib'
                                                           * '<S5011>/Calib'
                                                           */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dT_AATClnt_EnblOhxHPWasteHeatRcvry_RSP = 3.0F;/* Referenced by:
                                                          * '<S5009>/Calib'
                                                          * '<S5012>/Calib'
                                                          */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_AmbTmpHys_BTIS = 3.0F;/* Referenced by:
                                                                      * '<S4860>/Calib'
                                                                      * '<S4895>/Calib'
                                                                      */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_AmbTmpHys_BTIS_RSP =
    3.0F;                              /* Referenced by:
                                        * '<S4861>/Calib'
                                        * '<S4896>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_AmbTmpHys_CellMaxLSP =
    1.0F;                              /* Referenced by: '<S4862>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_AmbTmpHys_CellMaxRSP =
    1.0F;                              /* Referenced by: '<S4863>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_AmbTmpHys_PPCTIS = 3.0F;/* Referenced by:
                                                                      * '<S4864>/Calib'
                                                                      * '<S4897>/Calib'
                                                                      */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_AmbTmpHys_PPCTIS_RSP =
    3.0F;                              /* Referenced by:
                                        * '<S4865>/Calib'
                                        * '<S4898>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_BTISHys_CellMaxLSP =
    3.0F;                              /* Referenced by:
                                        * '<S4866>/Calib'
                                        * '<S4899>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_BTISTmpHys_PsvClnt_LSP =
    3.0F;                              /* Referenced by: '<S4900>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_BTISTmpHys_PsvClnt_RSP =
    5.0F;                              /* Referenced by: '<S4901>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_BTIStHys_CellMaxRSP =
    3.0F;                              /* Referenced by:
                                        * '<S4867>/Calib'
                                        * '<S4902>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_BattClntChillerOff =
    25.0F;                             /* Referenced by: '<S5278>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_BattClntChillerOn =
    25.0F;                             /* Referenced by: '<S5279>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_BattClntCoolOff = 25.0F;/* Referenced by: '<S5280>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_BattClntCoolOn = 25.0F;/* Referenced by: '<S5281>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_BattClntHeatOff = 25.0F;/* Referenced by: '<S5282>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_BattClntHeatOn = 25.0F;/* Referenced by: '<S5283>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_CellOverTemp_Dial = 0.0F;/* Referenced by: '<S212>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_CellOverTemp_Dum4BSG =
    0.0F;                              /* Referenced by: '<S213>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_CellTempDltOff = 4.0F;/* Referenced by: '<S83>/ThermalMode' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_CellTempDltOn = 5.0F;/* Referenced by: '<S83>/ThermalMode' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_CellTempHystHeat = 4.0F;/* Referenced by: '<S83>/ThermalMode' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_CellTempHysteresis =
    2.0F;                              /* Referenced by: '<S5284>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_CellTempPassCoolOfst =
    15.0F;                             /* Referenced by: '<S83>/ThermalMode' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_ChillerDeficitTest =
    1.0F;                              /* Referenced by: '<S5292>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_ChillerFrntOnlyOff =
    3.0F;                              /* Referenced by: '<S83>/ThermalMode' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_ChillerFrntOnlyOn = 4.0F;/* Referenced by: '<S83>/ThermalMode' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_ChillerOnlyOff = 9.0F;/* Referenced by: '<S83>/ThermalMode' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_ChillerOnlyOn = 10.0F;/* Referenced by: '<S83>/ThermalMode' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_Clnt2Hot4Batt_ActvPsv =
    55.0F;                             /* Referenced by: '<S4662>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_CoFuCellHiTOutSpOfsDec_C
    = -1.0F;                           /* Referenced by: '<S1006>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_CoFuCellHiTOutSpOfsInc_C
    = 0.2F;                            /* Referenced by: '<S1007>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_CoFuCellHiTSigOfsDec_C =
    -0.5F;                             /* Referenced by: '<S1031>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_CoFuCellHiTSigOfsInc_C =
    0.2F;                              /* Referenced by: '<S1032>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dT_FCAirflwTgtOffset_VlvCntrlActv = 1.0F;/* Referenced by: '<S861>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_FCCTOSTgtHTCLTgt_Max =
    99.0F;                             /* Referenced by: '<S839>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_FCCTOSTgtHTCLTgt_Min =
    99.0F;                             /* Referenced by: '<S840>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_FCClntErrTgt_FCSDerate =
    0.0F;                              /* Referenced by: '<S821>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_FCClntdT_FCSDerate_LSP =
    0.0F;                              /* Referenced by: '<S805>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_FCClntdT_FCSDerate_RSP =
    5.0F;                              /* Referenced by: '<S806>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_FCPsvCool_RadOpen_LSP =
    0.0F;                              /* Referenced by:
                                        * '<S5084>/Calib'
                                        * '<S5089>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_FCPsvCool_RadOpen_RSP =
    0.0F;                              /* Referenced by:
                                        * '<S5085>/Calib'
                                        * '<S5090>/Calib'
                                        */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_FCStblz_FanAllwdDsbl =
    -0.5F;                             /* Referenced by: '<S873>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_FCStblz_FanAllwdEnbl =
    3.0F;                              /* Referenced by: '<S874>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_FCStblz_HtrAllwdDsbl =
    0.5F;                              /* Referenced by: '<S1330>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_FCStblz_HtrAllwdEnbl =
    3.0F;                              /* Referenced by: '<S1331>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_FCVlvCls_Stblz_LSP =
    -3.0F;                             /* Referenced by: '<S5098>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_FCVlvCls_Stblz_RSP =
    0.0F;                              /* Referenced by: '<S5099>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_HXCTOS_BTISBattPsvLSP =
    1.0F;                              /* Referenced by: '<S4707>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_HXCTOS_BTISBattPsvRSP =
    3.0F;                              /* Referenced by: '<S4708>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_HexTempGrdOffset_Stblz =
    -0.5F;                             /* Referenced by: '<S851>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_HexTempGrdOffset_Wrmup =
    0.5F;                              /* Referenced by: '<S852>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_HtrCorTmp_ErrCmfrtAchvd =
    4.0F;                              /* Referenced by: '<S1586>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_InvrtTmpCond_Incrs =
    2.0F;                              /* Referenced by: '<S2850>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_LTRVlvClosedHys = -2.0F;/* Referenced by:
                                                                      * '<S5180>/Calib'
                                                                      * '<S5182>/Calib'
                                                                      * '<S5184>/Calib'
                                                                      * '<S5200>/Calib'
                                                                      */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_LTRVlvOpenHys = 0.0F;/* Referenced by: '<S5198>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_MaxBatAlwLSPTh_BattAlw =
    1.0F;                              /* Referenced by: '<S4222>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_MinDeltTmp_HTSOV_LSP =
    2.0F;                              /* Referenced by: '<S1624>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_MinDeltTmp_HTSOV_RSP =
    4.0F;                              /* Referenced by: '<S1625>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dT_PECTOS_HCCTOS_LSP_CabActvPsvHeat = 1.0F;/* Referenced by: '<S4945>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dT_PECTOS_HCCTOS_RSP_CabActvPsvHeat = 1.0F;/* Referenced by: '<S4946>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dT_PPCTISBTOS_CombWasteRcvry_LSP = 5.0F;/* Referenced by: '<S5068>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dT_PPCTISBTOS_CombWasteRcvry_RSP = 2.0F;/* Referenced by: '<S5069>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dT_PPCTIS_BTIS_LSP_BattActvPsvHeat = 1.0F;/* Referenced by: '<S4663>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dT_PPCTIS_BTIS_RSP_BattActvPsvHeat = 1.0F;/* Referenced by: '<S4664>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dT_PPCTIS_ECHTIS_LSP_CabActvPsvHeat = 1.0F;/* Referenced by: '<S4947>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dT_PPCTIS_ECHTIS_RSP_CabActvPsvHeat = 1.0F;/* Referenced by: '<S4948>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_PPCTIS_Tgt_BattPsvCool =
    10.0F;                             /* Referenced by: '<S5207>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_PPCTIS_Tgt_CabPsvHeat =
    3.0F;                              /* Referenced by:
                                        * '<S5211>/Calib'
                                        * '<S5213>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_PsvPmpClntHys = 3.0F;/* Referenced by: '<S4868>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_PsvPmpClntHys_CellMaxLSP
    = 3.0F;                            /* Referenced by:
                                        * '<S4869>/Calib'
                                        * '<S4903>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_PsvPmpClntHys_CellMaxRSP
    = 3.0F;                            /* Referenced by:
                                        * '<S4870>/Calib'
                                        * '<S4904>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_PsvPmpClntHys_CellMinLSP
    = 3.0F;                            /* Referenced by: '<S4693>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_PsvPmpClntHys_CellMinRSP
    = 1.0F;                            /* Referenced by: '<S4694>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_PsvPmpClntHys_RSP = 3.0F;/* Referenced by: '<S4871>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_RecircAmbCellDelta =
    5.0F;                              /* Referenced by: '<S83>/ThermalMode' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_RecircAmbCellDeltaHyst =
    2.0F;                              /* Referenced by: '<S83>/ThermalMode' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dT_RecircAmbLowHyst = 2.0F;/* Referenced by: '<S83>/ThermalMode' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_BattRadAirflow_PID_Init =
    0.0F;                              /* Referenced by: '<S3117>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_Branch1_Emrgcy_LV1 =
    0.0F;                              /* Referenced by: '<S2994>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_Branch1_Emrgcy_LV2 =
    0.0F;                              /* Referenced by: '<S2999>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_Branch2_Emrgcy_LV1 =
    0.0F;                              /* Referenced by: '<S3001>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_Branch2_Emrgcy_LV2 =
    0.0F;                              /* Referenced by: '<S3002>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_Branch3_Emrgcy_LV1 =
    0.0F;                              /* Referenced by: '<S2996>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_Branch3_Emrgcy_LV2 =
    0.0F;                              /* Referenced by: '<S2997>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_Branch_1_Flw_D = 0.0F;/* Referenced by: '<S254>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_Branch_2_Flw_D = 0.0F;/* Referenced by: '<S255>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_Branch_3_Flw_D = 0.0F;/* Referenced by: '<S256>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_DGrdLimitFan_MBCHTLLTL =
    -20.0F;                            /* Referenced by: '<S3265>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_DGrdLimitHTLFlowMBC2 =
    -0.5F;                             /* Referenced by: '<S2047>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_DGrdLimitLTLFanAFBC =
    -20.0F;                            /* Referenced by: '<S3034>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_DeIce_CondAirFlow =
    2200.0F;                           /* Referenced by:
                                        * '<S5523>/Calib'
                                        * '<S2833>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_ECM_LTPsvPmpRq_Max =
    8000.0F;                           /* Referenced by: '<S2961>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_EOP_Dsrd_Flw = 0.05F;/* Referenced by: '<S714>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_FCSAirflwReq_FCSDerate =
    100.0F;                            /* Referenced by: '<S807>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_FCSClntflwReq_FCSDerate =
    100.0F;                            /* Referenced by: '<S808>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_FC_ClntFlwtgt_NF = 0.0F;/* Referenced by: '<S5683>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_FanAftrRun_Branch1Flow =
    0.0F;                              /* Referenced by: '<S3000>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_FanAftrRun_Branch2Flow =
    0.0F;                              /* Referenced by: '<S2995>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_FanAftrRun_Branch3Flow =
    0.0F;                              /* Referenced by: '<S2998>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_FanPID_ClntErr_Max =
    4000.0F;                           /* Referenced by: '<S5544>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_FanPID_ClntErr_Min =
    0.0F;                              /* Referenced by: '<S5545>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_FanPID_HtrAirFlw_Max =
    4000.0F;                           /* Referenced by: '<S5532>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_FanPID_HtrAirFlw_Min =
    0.0F;                              /* Referenced by: '<S5533>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_FanPID_PresErr_Max =
    4000.0F;                           /* Referenced by: '<S5569>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_FanPID_PresErr_Min =
    0.0F;                              /* Referenced by: '<S5570>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_FanPID_PsucErr_Max =
    4000.0F;                           /* Referenced by: '<S5556>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_FanPID_PsucErr_Min =
    0.0F;                              /* Referenced by: '<S5557>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_HTRAirflow_PID_Init =
    0.0F;                              /* Referenced by: '<S881>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_HT_AuxPmpCmd_Dial = 0.0F;/* Referenced by: '<S3677>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dV_HT_AuxPmpFlw_CabHtg_OV_Dial = 70.0F;/* Referenced by: '<S1908>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_HT_AuxPmpFlw_EngOff =
    0.3F;                              /* Referenced by: '<S1935>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_HT_AuxPmpFlw_EngOn =
    0.0F;                              /* Referenced by:
                                        * '<S1901>/Calib'
                                        * '<S1934>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_HT_AuxPmpFlw_HtrOnDflt =
    70.0F;                             /* Referenced by:
                                        * '<S1909>/Calib'
                                        * '<S1933>/Calib'
                                        */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_HeadPresDsblECTHotVal =
    0.0F;                              /* Referenced by: '<S2814>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LTAP_ExpOff_MinLTAPFlow =
    0.0F;                              /* Referenced by: '<S5356>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dV_LTCL_DT_BSG_HeatRejectNo_Fan = 0.0F;/* Referenced by: '<S2815>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LTCLflow4LTAPFaults =
    0.333333343F;                      /* Referenced by: '<S2959>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LTP_AftrRunPmp2FlowOvrrd
    = 0.0F;                            /* Referenced by: '<S2921>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dV_LTP_AftrRunPmpFlowFrPmpState = 10.0F;/* Referenced by: '<S637>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LTP_AftrRunPmpFlowOvrrd =
    0.0F;                              /* Referenced by: '<S2922>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LTRVlv_McLTRIni =
    0.0107F;                           /* Referenced by: '<S2783>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LTR_Flw_D = 0.0F;/* Referenced by: '<S3733>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LTR_Flw_Dum4BSG = 0.0F;/* Referenced by: '<S3734>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LT_ActvPmpCmd_Dial =
    0.0F;                              /* Referenced by: '<S3673>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LT_ClntPmpFlw_Max =
    8000.0F;                           /* Referenced by: '<S354>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LT_FrontEDM_AHH_Actv =
    0.384F;                            /* Referenced by: '<S2950>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LT_PsvPmp2Cmd_Dial =
    0.0F;                              /* Referenced by: '<S3685>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LT_PsvPmpCmd_Dial = 0.0F;/* Referenced by: '<S3682>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LT_PsvPmpFlw_Max =
    8000.0F;                           /* Referenced by: '<S2901>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LT_PsvPmpFlw_Min = 0.0F;/* Referenced by: '<S2902>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LT_RearEDM_AHH_Actv =
    0.0F;                              /* Referenced by: '<S2951>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_LtrAfAwuMin = 0.0F;/* Referenced by: '<S3079>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MGU_ClntPumpFlw_D = 0.0F;/* Referenced by: '<S357>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MGU_ClntPumpFlw_RU_D =
    0.0F;                              /* Referenced by: '<S358>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MaxAirflowECM = 1.0F;/* Referenced by: '<S5383>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MaxAllwdFlw_ThruLTR =
    5.0F;                              /* Referenced by: '<S2816>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MaxAntWdFan_MBCHTLLTL =
    2.0F;                              /* Referenced by: '<S3328>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MaxAntWdLTLFANMBC = 2.0F;/* Referenced by: '<S3064>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MaxBattRadAirflow =
    17300.0F;                          /* Referenced by:
                                        * '<S3110>/Calib'
                                        * '<S3118>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MaxFCHEXBrnchFlw = 1.0F;/* Referenced by: '<S844>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MaxFCWCACBrnchFlw = 1.0F;/* Referenced by: '<S894>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MaxFlowLTL = 0.5F;/* Referenced by: '<S3080>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MaxFlowLTR = 2.0F;/* Referenced by: '<S3081>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MaxHTLFlowMBC2 = 0.19F;/* Referenced by: '<S2048>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MaxHTLPumpMBC2 = 0.3F;/* Referenced by: '<S2089>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MaxHTRAirflow = 17300.0F;/* Referenced by: '<S882>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MaxLimitFan_MBCHTLLTL =
    2.0F;                              /* Referenced by: '<S3266>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MaxLimitLTLFanAFBC =
    2.0F;                              /* Referenced by: '<S3035>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dV_MinAirflw_EnblHPWasteHeatRcvry = 100.0F;/* Referenced by:
                                                       * '<S5246>/Calib'
                                                       * '<S4779>/Calib'
                                                       */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MinAllwdFlw_ThruLTR =
    0.0F;                              /* Referenced by: '<S2817>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MinAntWdFan_MBCHTLLTL =
    0.05F;                             /* Referenced by: '<S3329>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MinAntWdLTLFANMBC =
    0.05F;                             /* Referenced by: '<S3065>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MinBTCLFlw4TempUpdt =
    0.001F;                            /* Referenced by: '<S4812>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MinBattRadAirflow_PID =
    0.0F;                              /* Referenced by: '<S3119>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MinFlowLTL = 0.2F;/* Referenced by: '<S3082>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MinFlowLTR = 0.05F;/* Referenced by: '<S3083>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MinHTLFlowMBC2 = 0.07F;/* Referenced by: '<S2049>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MinHTLPumpMBC2 = 0.19F;/* Referenced by: '<S2090>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MinHTRAirflow_PID = 0.0F;/* Referenced by: '<S883>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MinLimitFan_MBCHTLLTL =
    0.05F;                             /* Referenced by: '<S3267>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MinLimitLTLFanAFBC =
    0.05F;                             /* Referenced by: '<S3036>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MotTemp_1_FlwMin = 0.0F;/* Referenced by: '<S681>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MotTemp_1_RvrsFlwMin =
    0.0F;                              /* Referenced by: '<S676>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MotTemp_2_FlwMin = 0.0F;/* Referenced by: '<S704>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MotTemp_2_RvrsFlwMin =
    0.0F;                              /* Referenced by: '<S699>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_Mtr1_CoolFlwCmd_Dial =
    0.0F;                              /* Referenced by: '<S3604>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_Mtr1_CoolFlwCmd_Dum4BSG =
    0.0F;                              /* Referenced by: '<S3605>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_Mtr2_CoolFlwCmd_Dial =
    0.0F;                              /* Referenced by: '<S3607>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_Mtr2_CoolFlwCmd_Dum4BSG =
    0.0F;                              /* Referenced by: '<S3608>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MtrALubOilFlw_D = 1.0F;/* Referenced by: '<S5632>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MtrAOilFlwMaxLimit_D =
    1.0F;                              /* Referenced by: '<S5633>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MtrBLubOilFlw_D = 1.0F;/* Referenced by: '<S5634>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MtrBOilFlwMaxLimit_D =
    1.0F;                              /* Referenced by: '<S5635>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_MtrMinCool = 0.175F;/* Referenced by: '<S660>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_NoPmpFlw_AirCooled =
    0.0F;                              /* Referenced by: '<S2818>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_P1MotorDsblECTHotVal =
    0.0F;                              /* Referenced by: '<S2819>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_PPU_AirFlw_Max = 1000.0F;/* Referenced by: '<S5384>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_UGrdLimitFan_MBCHTLLTL =
    20.0F;                             /* Referenced by: '<S3268>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_UGrdLimitHTLFlowMBC2 =
    0.5F;                              /* Referenced by: '<S2050>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dV_UGrdLimitLTLFanAFBC =
    20.0F;                             /* Referenced by: '<S3037>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dV_WhlSpdFA_OilFlwRtDiffTgt1 = 1.5F;/* Referenced by: '<S684>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_dV_WhlSpdFA_OilFlwRtDiffTgt2 = 1.5F;/* Referenced by: '<S706>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dv_HTAP_PumpOff = 0.0F;
                                  /* Referenced by: '<S1852>/THMR_HTCVFlt_RA' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_dv_LTAP_PumpOff = 0.0F;
                                  /* Referenced by: '<S1852>/THMR_HTCVFlt_RA' */
static volatile CONST(TeBRKR_e_AHH_ReadyStatus, THMR_VAR_INIT)
    KeTHMR_e_AHH_Ready_Status_D = CeBRKR_e_AHH_NotReady;/* Referenced by: '<S3784>/Calib' */
static volatile CONST(TeTMIR_e_ECM_LTP_FanAftRunRq, THMR_VAR_INIT)
    KeTHMR_e_AfterRunDefault = CeTMIR_e_SNA_AftRunRequest;/* Referenced by: '<S71>/AfterRun' */
static volatile CONST(TeBPCR_e_LIN_BusOff, THMR_VAR_INIT)
    KeTHMR_e_BPCM_LIN_BusOff_D = CeBPCR_e_LIN_BusOff_Disabled;/* Referenced by: '<S230>/Calib' */
static volatile CONST(TeBPCR_e_LOC_BCP, THMR_VAR_INIT) KeTHMR_e_BPCM_LOC_BCP_D =
    CeBPCR_e_LOC_BCP_False;            /* Referenced by: '<S239>/Calib' */
static volatile CONST(TeHVTR_e_HV_BatCntctrStat, THMR_VAR_INIT)
    KeTHMR_e_BatCntctrStat_Dial = CeHVTR_e_Open;/* Referenced by: '<S3989>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_BatThrmlSt, THMR_VAR_INIT) KeTHMR_e_BatThrmlSt =
    CeTHMR_e_NoConditioning;           /* Referenced by: '<S319>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_BatThrmlSt, THMR_VAR_INIT)
    KeTHMR_e_BatThrmlSt_Dum4BSG = CeTHMR_e_NoConditioning;/* Referenced by: '<S320>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_HtrState, THMR_VAR_INIT)
    KeTHMR_e_BattHtrState_Dum4BSG = CeTHMR_e_HtrOff;/* Referenced by: '<S2247>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_HtrState, THMR_VAR_INIT)
    KeTHMR_e_BattHtr_StateDial = CeTHMR_e_HtrOff;/* Referenced by: '<S2248>/Calib' */

#endif

static volatile CONST(sint16, THMR_VAR_INIT) KeTHMR_e_CabinPreCondReqStCAN_D = 0;/* Referenced by: '<S334>/Calib' */
static volatile CONST(TeTPCR_e_CabinPreCondReqStat, THMR_VAR_INIT)
    KeTHMR_e_CabinPreCondReqStMsg_D = CeTPCR_e_CabinPrec_Dflt;/* Referenced by: '<S335>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTPCR_e_CabinPreCondReqStat, THMR_VAR_INIT)
    KeTHMR_e_CabinPreCondReqStat_Dial = CeTPCR_e_CabinPrec_Dflt;/* Referenced by: '<S336>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTPCR_e_CabinPreCondReqStat, THMR_VAR_INIT)
    KeTHMR_e_CabinPrecondSts_Dial_Dum4BSG = CeTPCR_e_CabinPrec_Dflt;/* Referenced by: '<S337>/Calib' */

#endif

static volatile CONST(TeOBCR_e_ChargingLevel, THMR_VAR_INIT)
    KeTHMR_e_ChargingLevel_Dial = CeOBCR_e_ChargingLvlDefault;/* Referenced by: '<S543>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_VlvState, THMR_VAR_INIT)
    KeTHMR_e_ClntNProp3WyVlv_State_Dial = CeTHMR_e_NoVlvPwrd;/* Referenced by: '<S5651>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_VlvState, THMR_VAR_INIT)
    KeTHMR_e_ClntNProp3WyVlv_State_Dum4BSG = CeTHMR_e_NoVlvPwrd;/* Referenced by: '<S5652>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_VlvState, THMR_VAR_INIT)
    KeTHMR_e_ClntProp3WyVlv_State_Dial = CeTHMR_e_NoVlvPwrd;/* Referenced by: '<S5660>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_VlvState, THMR_VAR_INIT)
    KeTHMR_e_ClntProp3WyVlv_State_Dum4BSG = CeTHMR_e_NoVlvPwrd;/* Referenced by: '<S5661>/Calib' */

#endif

static volatile CONST(TeHCDR_e_BatteryThermalFault, THMR_VAR_INIT)
    KeTHMR_e_CompFlts_D = CeHCDR_e_BattThermalNoFault;/* Referenced by: '<S2163>/Calib' */
static volatile CONST(TeTMIR_e_ECM_LTP_FanAftRunRq, THMR_VAR_INIT)
    KeTHMR_e_ECM_LTP_FanAftRunRqDflt = CeTMIR_e_SNA_AftRunRequest;/* Referenced by: '<S3635>/Calib' */
static volatile CONST(TeTHMR_e_OilPumpEmrgCoolState, THMR_VAR_INIT)
    KeTHMR_e_EOP_A_EmrgCool_D = CeTHMR_e_OilPumpEmrgCool_OFF;/* Referenced by: '<S719>/Calib' */
static volatile CONST(TeTHMR_e_OilPumpEmrgCoolState, THMR_VAR_INIT)
    KeTHMR_e_EOP_B_EmrgCool_D = CeTHMR_e_OilPumpEmrgCool_OFF;/* Referenced by: '<S721>/Calib' */
static volatile CONST(TeTHMR_e_EmrgcyFanRq_Lvl, THMR_VAR_INIT)
    KeTHMR_e_EmrgcyFanRq_Lvl_D = CeTHMR_e_No_EmrgcyFanRq;/* Referenced by: '<S1147>/Calib' */
static volatile CONST(TeESSR_e_EngStartStopSt, THMR_VAR_INIT)
    KeTHMR_e_EngStartStopSt_Dial = CeESSR_e_EngOff;/* Referenced by: '<S3973>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_Eng_Htr_HTSOV_St, THMR_VAR_INIT)
    KeTHMR_e_Eng_Htr_HTSOV_Stat_D = CeTHMR_e_NoStateSlctd;/* Referenced by: '<S339>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_Eng_Htr_HTSOV_St, THMR_VAR_INIT)
    KeTHMR_e_Eng_Htr_HTSOV_Stat_D_Dum4BSG = CeTHMR_e_NoStateSlctd;/* Referenced by: '<S340>/Calib' */

#endif

static volatile CONST(TeCITR_e_FOTA_Install_Type, THMR_VAR_INIT)
    KeTHMR_e_FOTA_Install_Type_D = CeCITR_e_NoFOTA;/* Referenced by: '<S258>/Calib' */
static volatile CONST(TeTHMR_e_EmrgcyFanRq_Lvl, THMR_VAR_INIT)
    KeTHMR_e_HCP_LTP_FanAftRunRqDflt = CeTHMR_e_SNA_EmrgcyFanRq;/* Referenced by: '<S3636>/Calib' */
static volatile CONST(TeTMIR_e_ECM_LTP_FanAftRunRq, THMR_VAR_INIT)
    KeTHMR_e_HCP_LTP_FanAftRunRq_D = CeTMIR_e_No_AftRunRequest;/* Referenced by: '<S3366>/Calib' */
static volatile CONST(TePMPR_e_FTSNA, THMR_VAR_INIT) KeTHMR_e_HTAuxPumpDryRun_D =
    CePMPR_e_FTSNA_False;              /* Referenced by: '<S3798>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_PumpOpState, THMR_VAR_INIT)
    KeTHMR_e_HTAuxPump_OprtngSt_D = CeTHMR_e_PumpOff;/* Referenced by: '<S3728>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_PumpOpState, THMR_VAR_INIT)
    KeTHMR_e_HTAuxPump_OprtngSt_Dum4BSG = CeTHMR_e_PumpOff;/* Referenced by: '<S3729>/Calib' */

#endif

static volatile CONST(TeTHMR_e_HTCL_Heat_Distrib, THMR_VAR_INIT)
    KeTHMR_e_HTCL_Heat_Distrib_Dial = CeTHMR_e_NoHeating;/* Referenced by: '<S1844>/Calib' */
static volatile CONST(TeTRIR_e_HVAC_ECO_State, THMR_VAR_INIT)
    KeTHMR_e_HVACECOModeSts_D = CeTRIR_e_HVAC_ECO_SNA;/* Referenced by: '<S3961>/Calib' */
static volatile CONST(TeTHMR_e_HVACPerf_Mode, THMR_VAR_INIT)
    KeTHMR_e_HVAC_RdPerfModeFlg_D = CeTHMR_e_NormalMode;/* Referenced by: '<S3397>/Calib' */
static volatile CONST(TeBRDR_e_BatCltLvlLo, THMR_VAR_INIT)
    KeTHMR_e_HV_Bat_CltLvlLo_Dial = CeBRDR_e_BatCltLvlNotLo;/* Referenced by: '<S3387>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_HtrState, THMR_VAR_INIT)
    KeTHMR_e_Htr2State_Dum4BSG = CeTHMR_e_HtrOff;/* Referenced by: '<S2244>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_HtrState, THMR_VAR_INIT) KeTHMR_e_Htr2_StateDial =
    CeTHMR_e_HtrOff;                   /* Referenced by: '<S2245>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_HtrState, THMR_VAR_INIT)
    KeTHMR_e_Htr3State_Dum4BSG = CeTHMR_e_HtrOff;/* Referenced by: '<S2250>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_HtrState, THMR_VAR_INIT) KeTHMR_e_Htr3_StateDial =
    CeTHMR_e_HtrOff;                   /* Referenced by: '<S2251>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_HtrState, THMR_VAR_INIT)
    KeTHMR_e_Htr4State_Dum4BSG = CeTHMR_e_HtrOff;/* Referenced by: '<S2253>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_HtrState, THMR_VAR_INIT) KeTHMR_e_Htr4_StateDial =
    CeTHMR_e_HtrOff;                   /* Referenced by: '<S2254>/Calib' */

#endif

static volatile CONST(TeHPMR_e_HybSysState, THMR_VAR_INIT)
    KeTHMR_e_HybSysSt_Dial = CeHPMR_e_POWERUP;/* Referenced by: '<S3985>/Calib' */
static volatile CONST(TePMDR_e_PowerMode, THMR_VAR_INIT)
    KeTHMR_e_IgnStatusIn_RU_Test = CePMDR_e_PowerMode_Off;/* Referenced by: '<S4052>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_PumpOpState, THMR_VAR_INIT)
    KeTHMR_e_LTActPump_OprtngSt_Dum4BSG = CeTHMR_e_PumpOff;/* Referenced by: '<S3725>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_PumpOpState, THMR_VAR_INIT)
    KeTHMR_e_LTActPump_OprtrngSt_D = CeTHMR_e_PumpOff;/* Referenced by: '<S3726>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_PumpOpState, THMR_VAR_INIT)
    KeTHMR_e_LTPsvPump2_OprtngSt_D = CeTHMR_e_PumpOff;/* Referenced by: '<S3722>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_PumpOpState, THMR_VAR_INIT)
    KeTHMR_e_LTPsvPump2_OprtngSt_Dum4BSG = CeTHMR_e_PumpOff;/* Referenced by: '<S3723>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_PumpOpState, THMR_VAR_INIT)
    KeTHMR_e_LTPsvPump_OprtngSt_D = CeTHMR_e_PumpOff;/* Referenced by: '<S3719>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeTHMR_e_PumpOpState, THMR_VAR_INIT)
    KeTHMR_e_LTPsvPump_OprtngSt_Dum4BSG = CeTHMR_e_PumpOff;/* Referenced by: '<S3720>/Calib' */

#endif

static volatile CONST(TeTMIR_e_ECM_LTP_FanAftRunRq, THMR_VAR_INIT)
    KeTHMR_e_No_AfterRun = CeTMIR_e_No_AftRunRequest;/* Referenced by: '<S71>/AfterRun' */
static volatile CONST(TeTHMR_e_PPCTIS_OT, THMR_VAR_INIT) KeTHMR_e_PPCTIS_OT_D =
    CeTHMR_e_EmergencyLevel4;          /* Referenced by: '<S342>/Calib' */
static volatile CONST(TeOBCR_e_PlugInStat_HCP, THMR_VAR_INIT)
    KeTHMR_e_PlugSts_RU_Test = CeOBCR_e_NotPlugedIn_HCP;/* Referenced by: '<S5277>/Calib' */
static volatile CONST(TeOBCR_e_PwrLimReq, THMR_VAR_INIT) KeTHMR_e_PwrLevSet_D =
    CeOBCR_e_PwrLimReq_NoChange;       /* Referenced by: '<S544>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeFSCR_e_RadFanState_Adjtd, THMR_VAR_INIT)
    KeTHMR_e_RadFan_State_Dial = CeFSCR_e_RadFan_OFF;/* Referenced by: '<S1144>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(TeFSCR_e_RadFanState_Adjtd, THMR_VAR_INIT)
    KeTHMR_e_RadFan_State_Dum4BSG = CeFSCR_e_RadFan_OFF;/* Referenced by: '<S1145>/Calib' */

#endif

static volatile CONST(TeTPCR_e_SC_WakeUpSt, THMR_VAR_INIT) KeTHMR_e_SC_WkUp_Dial
    = CeTPCR_e_SC_NotAwake;            /* Referenced by: '<S347>/Calib' */
static volatile CONST(TeSSDR_e_KeySts, THMR_VAR_INIT) KeTHMR_e_SSDR_KeySts_Dial =
    CeSSDR_e_KeyOff;                   /* Referenced by: '<S3967>/Calib' */
static volatile CONST(TePLTR_e_ShipingMode, THMR_VAR_INIT)
    KeTHMR_e_ShippingMode_D = CePLTR_e_ShipingMode_CUST_MD;/* Referenced by: '<S3983>/Calib' */
static volatile CONST(TeTRGR_e_TransRangeState, THMR_VAR_INIT)
    KeTHMR_e_TransDirctnSt_Dial = CeTRGR_e_NoSelectionAvailable;/* Referenced by: '<S3991>/Calib' */
static volatile CONST(sint16, THMR_VAR_INIT) KeTHMR_i_AftrRunArryLim = 6;/* Referenced by: '<S71>/AfterRun' */
static volatile CONST(uint16, THMR_VAR_INIT)
    KeTHMR_i_ProactiveChgActiveMinTempAllow = 8U;/* Referenced by: '<S386>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT)
    KeTHMR_i_ProactiveChgPassiveMinTempAllow = 7U;/* Referenced by: '<S387>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT)
    KeTHMR_i_Wght4BattCoolNHeatOVReqTempAllow = 16U;/* Referenced by: '<S388>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT)
    KeTHMR_i_Wght4BattCoolOVReqTempAllow = 14U;/* Referenced by: '<S389>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT)
    KeTHMR_i_Wght4BattHeatOVReqTempAllow = 15U;/* Referenced by: '<S390>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_i_Wght4CabPrecMinTempAllow =
    13U;                               /* Referenced by: '<S391>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_i_Wght4ChrgLvl1MinTempAllow =
    12U;                               /* Referenced by: '<S392>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_i_Wght4ChrgLvl2MinTempAllow =
    11U;                               /* Referenced by: '<S393>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_i_Wght4ChrgLvl3MinTempAllow =
    10U;                               /* Referenced by: '<S394>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_i_Wght4ChrgPreMinTempAllow =
    2U;                                /* Referenced by: '<S395>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_i_Wght4DefrostMinTempAllow =
    5U;                                /* Referenced by: '<S396>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT)
    KeTHMR_i_Wght4DschrgSysStsMinTempAllow = 4U;/* Referenced by: '<S397>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT)
    KeTHMR_i_Wght4HVACPriorityMinTempAllow = 6U;/* Referenced by: '<S398>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_i_Wght4LoadShed1MinTempAllow
    = 9U;                              /* Referenced by: '<S399>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_i_Wght4NormalDrvMinTempAllow
    = 1U;                              /* Referenced by: '<S400>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_i_Wght4PeriodWupMinTempAllow
    = 3U;                              /* Referenced by: '<S401>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_BattRadAirflw_Kd = 0.0F;/* Referenced by: '<S3120>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_ChrgCrntReq_Coeff = 0.25F;/* Referenced by: '<S4872>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_ElVlv3WayDirDetMinHys_C =
    0.8F;                              /* Referenced by: '<S959>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_ElVlv3WayFanLpfInit_C =
    100.0F;                            /* Referenced by: '<S1082>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_ElVlv3WayFanLpf_C = 0.1F;/* Referenced by: '<S1083>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_ElVlv3WayFanMinPosn_C =
    90.0F;                             /* Referenced by: '<S1084>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_ElVlv3WayFuCellOffReq_C =
    100.0F;                            /* Referenced by: '<S954>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_ElVlv3WayFuCellPIDByp_C =
    60.0F;                             /* Referenced by: '<S1128>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_ElVlv3WayFuCellPIDCls_C =
    98.0F;                             /* Referenced by: '<S1008>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_ElVlv3WayFuCellPIDMax_C =
    101.0F;                            /* Referenced by: '<S955>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_ElVlv3WayFuCellPIDMin_C =
    -1.0F;                             /* Referenced by: '<S956>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_ElVlv3WayFuCellPwrLimThDec_C = -10.0F;/* Referenced by: '<S1047>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_ElVlv3WayFuCellPwrLimThHld_C = 18.0F;/* Referenced by: '<S1048>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_ElVlv3WayFuCellPwrLimThInc_C = 10.0F;/* Referenced by: '<S1049>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_ElVlv3WayFuCellPwrLimThRst_C = 100.0F;/* Referenced by: '<S1050>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_ElVlv3WayFuCellReqDif_C =
    1.0F;                              /* Referenced by: '<S978>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_ElVlv3WayTranCmpHys_C =
    0.0F;                              /* Referenced by: '<S960>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_EngPwrWasteAvail_FltrCoeff = 0.01F;/* Referenced by: '<S1713>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_EstHTRGrillArea = 0.46F;/* Referenced by: '<S741>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_EstOhxArflw_LPFCoeff =
    0.25F;                             /* Referenced by:
                                        * '<S5247>/Calib'
                                        * '<S4780>/Calib'
                                        */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_FCAirflw_Kd = 0.0F;/* Referenced by: '<S884>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_FCPropVlv_Kd = 0.0F;/* Referenced by: '<S778>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_FuCellHiTHEXElVlv3WayByp_C = 0.2F;/* Referenced by: '<S1129>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_HTRAirflw_MFltrCoeff =
    0.25F;                             /* Referenced by: '<S862>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_HiTFuCellSpdAirMaxExtOptCtl_C = 50.0F;/* Referenced by: '<S1068>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_HiTFuCellWaPmpExtOptCtl_C
    = 40.0F;                           /* Referenced by: '<S913>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_HiTFuCellWaPmpPreHeat_C =
    100.0F;                            /* Referenced by: '<S914>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_HiTSpdAirReqHysMinOfs_C =
    5.0F;                              /* Referenced by: '<S1069>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_HiTSpdAirReqHysMin_C =
    -20.0F;                            /* Referenced by: '<S1070>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_HiTSpdAirReqMax_C = 90.0F;/* Referenced by: '<S1071>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_HiTSpdAirReqMin_C = 20.0F;/* Referenced by: '<S1072>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_HtrDterm_HtrAirFlw = 0.0F;/* Referenced by: '<S5534>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_HtrIterm_HtrAirFlw =
    10.0F;                             /* Referenced by: '<S5535>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_HtrPterm_HtrAirFlw =
    1000.0F;                           /* Referenced by: '<S5536>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_KiFBLMBC2 = 0.1F;/* Referenced by: '<S2091>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_KiFBLMBCECO = 0.1F;/* Referenced by: '<S2092>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_KiLTCLFBL = 0.01F;/* Referenced by: '<S3084>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_KpFBLMBC2 = 10.0F;/* Referenced by: '<S2093>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_KpFBLMBCECO = 10.0F;/* Referenced by: '<S2094>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_KpLTCLFBL = 0.1F;/* Referenced by: '<S3085>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_KpMotorOutltTemp = 2.0F;/* Referenced by: '<S3086>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_LTRVlv_DetJcbTooSmallThrshld = 0.001F;/* Referenced by: '<S2784>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_LTRVlv_FcnRsdTooSmallThrshld = 0.001F;/* Referenced by: '<S2785>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_LTRVlv_LinearInv = 1.0F;/* Referenced by: '<S3304>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_LTRVlv_McStepSizeThrshld =
    0.001F;                            /* Referenced by: '<S2786>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_LTRVlv_Nrmlztn = 1.0F;/* Referenced by: '<S3305>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_LTRVlv_SrchDirThrshld =
    0.001F;                            /* Referenced by: '<S2787>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_LTRVlv_StepSzTooSmallThrshld = 0.001F;/* Referenced by: '<S2788>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_LoopPriorty_BattActvPsvHeat_Ovrrd = 120.0F;/* Referenced by: '<S5045>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_LoopPriorty_BattPsvCool =
    60.0F;                             /* Referenced by: '<S5046>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_LoopPriorty_BattPsvHeat =
    50.0F;                             /* Referenced by: '<S5047>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_LoopPriorty_CabActvPsvHeat_Ovrrd = 110.0F;/* Referenced by: '<S5048>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_LoopPriorty_CombWasteRcvryHP = 90.0F;/* Referenced by: '<S5063>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_LoopPriorty_LTCLActvPsvHeat = 100.0F;/* Referenced by: '<S5049>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_LoopPriorty_LTCLWasteRcvryHP = 85.0F;/* Referenced by: '<S5064>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_MaxITerm_ClntErr =
    4000.0F;                           /* Referenced by: '<S5546>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_MaxITerm_HtrAirFlw =
    4000.0F;                           /* Referenced by: '<S5537>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_MaxITerm_PresErr =
    4000.0F;                           /* Referenced by: '<S5571>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_MaxITerm_PsucErr =
    4000.0F;                           /* Referenced by: '<S5558>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_MinITerm_ClntErr = 0.0F;/* Referenced by: '<S5547>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_MinITerm_HtrAirFlw = 0.0F;/* Referenced by: '<S5538>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_MinITerm_PresErr = 0.0F;/* Referenced by: '<S5572>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_MinITerm_PsucErr = 0.0F;/* Referenced by: '<S5559>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_MtrC_CntrlBoardTemp_FltrCoeff = 0.05F;/* Referenced by: '<S3831>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_NTUcte1 = 0.78F;/* Referenced by:
                                                                      * '<S2455>/Calib'
                                                                      * '<S2467>/Calib'
                                                                      */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_NTUcte2 = 0.22F;/* Referenced by:
                                                                      * '<S2456>/Calib'
                                                                      * '<S2468>/Calib'
                                                                      */
static volatile CONST(boolean, THMR_VAR_INIT) KeTHMR_k_OVOverideCabHtrPIGain = 0;/* Referenced by: '<S1282>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_PsucDterm_PsucErr = 0.0F;/* Referenced by: '<S5560>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_PsucIterm_PsucErr = 10.0F;/* Referenced by: '<S5561>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_PsucPterm_PsucErr =
    1000.0F;                           /* Referenced by: '<S5562>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_RadBypFuCellHiTHEXHysHiRst_C = 0.99F;/* Referenced by: '<S1112>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_RadBypFuCellHiTHEXHysLoRst_C = 0.5F;/* Referenced by: '<S1113>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_k_TCoFuCellHiTHEXMesDlyFil_C = 10.0F;/* Referenced by: '<S1106>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_TCoFuCellHiTInOutSpFil_C =
    0.05F;                             /* Referenced by: '<S1009>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_VHTL_LinearInv = 1.0F;/* Referenced by: '<S3298>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_VHTL_Nrmlztn = 1.0F;/* Referenced by: '<S3299>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_WaPmpFuCellDft_C = 0.0F;/* Referenced by: '<S915>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_WaPmpFuCellGrdAcvDif_C =
    1.0F;                              /* Referenced by: '<S916>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_WaPmpFuCellReqDif_C =
    1.0F;                              /* Referenced by: '<S942>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_WaPmpFuCellReqOvrd_C =
    1.0F;                              /* Referenced by: '<S943>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_alpha = 0.0F;/* Referenced by:
                                                                     * '<S2991>/Calib'
                                                                     * '<S2908>/Calib'
                                                                     */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_k_alpha_prime = 0.0F;/* Referenced by: '<S2912>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_BSG_LTR_PmpSpdAct_Max =
    1000.0F;                           /* Referenced by: '<S2820>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_n_CabPriorty_MinEACrpmEnblBattCond = 5000.0F;/* Referenced by: '<S428>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_DGrdLimitBTLPumpMBC =
    -20.0F;                            /* Referenced by: '<S3136>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_DGrdLimitHCP_MBCHTLLTL =
    -20.0F;                            /* Referenced by: '<S3269>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_DGrdLimitHTLPumpMBC1 =
    -20.0F;                            /* Referenced by: '<S2051>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_DGrdLimitLTLPECP1MBC =
    -20.0F;                            /* Referenced by: '<S3038>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_DGrdLimitLTLPECP2MBC =
    -20.0F;                            /* Referenced by: '<S3039>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_DGrdLimitPECP1_MBCHTLLTL =
    -20.0F;                            /* Referenced by: '<S3270>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_DGrdLimitPECP2_MBCHTLLTL =
    -20.0F;                            /* Referenced by: '<S3271>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_EngIncrsHys_RPM = 200.0F;/* Referenced by: '<S2851>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_EngSpdInc_Req_Dum = 0.0F;/* Referenced by: '<S360>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_EngSpdInc_Req_Dwn = 2.0F;/* Referenced by: '<S2852>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_EngSpdInc_Req_Up = 2.0F;/* Referenced by: '<S2853>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_EngSpd_Dial = 0.0F;/* Referenced by: '<S3979>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_Eng_RPM_EngOn = 1.0F;/* Referenced by: '<S1878>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_FCWaPump_MaxSpdRPM = 0.0F;/* Referenced by: '<S899>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_FCWaPump_MinSpdRPM = 0.0F;/* Referenced by: '<S900>/Calib' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_HT_AuxPmpCmd_Dum4BSG =
    0.0F;                              /* Referenced by: '<S3678>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_HT_AuxPmpFlw_MinHtrEnb =
    200.0F;                            /* Referenced by: '<S4432>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_LTAP_ExpOff_MinLTAPCmnd =
    1000.0F;                           /* Referenced by: '<S5358>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_LTAP_ExpOff_MinLTAPSpd =
    1000.0F;                           /* Referenced by: '<S5357>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_LT_ActPmpRPM_MinHtrEnb =
    1000.0F;                           /* Referenced by: '<S4249>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_LT_ActvPmpCmd_Dum4BSG =
    0.0F;                              /* Referenced by: '<S3674>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_LT_PrssFlwRPM_Min = 50.0F;/* Referenced by: '<S2992>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_LT_PsvPmp2Cmd_Dum4BSG =
    0.0F;                              /* Referenced by: '<S3686>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_LT_PsvPmp2Sts_Dial = 0.0F;/* Referenced by: '<S3802>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_LT_PsvPmpCmd_Dum4BSG =
    0.0F;                              /* Referenced by: '<S3683>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_LT_PsvPmpRPM_Min = 50.0F;/* Referenced by: '<S2993>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_LT_PsvPmpSts_Dial = 0.0F;/* Referenced by: '<S3800>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MGU_EngSpdInc_Req_D =
    0.0F;                              /* Referenced by: '<S361>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MaskCmprNoiseLim_Hi =
    0.0F;                              /* Referenced by: '<S5599>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MaskCmprNoiseLim_Lo =
    0.0F;                              /* Referenced by: '<S5600>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MaxAntWdBTLPumpMBC =
    6000.0F;                           /* Referenced by: '<S3154>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MaxAntWdHCP_MBCHTLLTL =
    7000.0F;                           /* Referenced by: '<S3330>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MaxAntWdLTLPECPMBC =
    7000.0F;                           /* Referenced by: '<S3066>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MaxAntWdPECP1_MBCHTLLTL =
    7000.0F;                           /* Referenced by: '<S3331>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MaxAntWdPECP2_MBCHTLLTL =
    7000.0F;                           /* Referenced by: '<S3332>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MaxAntWdPumpMBC1 =
    5000.0F;                           /* Referenced by: '<S2080>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MaxBTLPumpMBC = 6000.0F;/* Referenced by: '<S3137>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MaxHTLPumpMBC1 = 5000.0F;/* Referenced by: '<S2052>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MaxLimitHCP_MBCHTLLTL =
    7000.0F;                           /* Referenced by: '<S3272>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MaxLimitLTLPECP1MBC =
    7000.0F;                           /* Referenced by: '<S3040>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MaxLimitLTLPECP2MBC =
    7000.0F;                           /* Referenced by: '<S3041>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MaxLimitPECP1_MBCHTLLTL =
    7000.0F;                           /* Referenced by: '<S3273>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MaxLimitPECP2_MBCHTLLTL =
    7000.0F;                           /* Referenced by: '<S3274>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MinAntWdBTLPumpMBC =
    2000.0F;                           /* Referenced by: '<S3155>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MinAntWdHCP_MBCHTLLTL =
    3000.0F;                           /* Referenced by: '<S3333>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MinAntWdLTLPECPMBC =
    500.0F;                            /* Referenced by: '<S3067>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MinAntWdPECP1_MBCHTLLTL =
    3000.0F;                           /* Referenced by: '<S3334>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MinAntWdPECP2_MBCHTLLTL =
    3000.0F;                           /* Referenced by: '<S3335>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MinAntWdPumpMBC1 = 0.0F;/* Referenced by: '<S2081>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MinBTLPumpMBC = 2000.0F;/* Referenced by: '<S3138>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MinHTLPumpMBC1 = 3000.0F;/* Referenced by: '<S2053>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MinLimitHCP_MBCHTLLTL =
    3000.0F;                           /* Referenced by: '<S3275>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MinLimitLTLPECP1MBC =
    2000.0F;                           /* Referenced by: '<S3042>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MinLimitLTLPECP2MBC =
    2000.0F;                           /* Referenced by: '<S3043>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MinLimitPECP1_MBCHTLLTL =
    3000.0F;                           /* Referenced by: '<S3276>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MinLimitPECP2_MBCHTLLTL =
    3000.0F;                           /* Referenced by: '<S3277>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MtrA_SpdDial = 0.0F;/* Referenced by: '<S3747>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MtrB_SpdDial = 0.0F;/* Referenced by: '<S3749>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_MtrC_SpdDial = 0.0F;/* Referenced by: '<S3745>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_PumpCavEng_RPM = 4100.0F;/* Referenced by: '<S1454>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_UGrdLimitBTLPumpMBC =
    20.0F;                             /* Referenced by: '<S3139>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_UGrdLimitHCP_MBCHTLLTL =
    20.0F;                             /* Referenced by: '<S3278>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_UGrdLimitHTLPumpMBC1 =
    20.0F;                             /* Referenced by: '<S2054>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_UGrdLimitLTLPECP1MBC =
    20.0F;                             /* Referenced by: '<S3044>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_UGrdLimitLTLPECP2MBC =
    20.0F;                             /* Referenced by: '<S3045>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_UGrdLimitPECP1_MBCHTLLTL =
    20.0F;                             /* Referenced by: '<S3279>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_UGrdLimitPECP2_MBCHTLLTL =
    20.0F;                             /* Referenced by: '<S3280>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_VhclSpdLo_DisFanThrsld =
    10.0F;                             /* Referenced by: '<S2863>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_WhlSpdLHF_D = 0.0F;/* Referenced by: '<S5636>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_WhlSpdLHR_D = 0.0F;/* Referenced by: '<S5637>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_WhlSpdRHF_D = 0.0F;/* Referenced by: '<S5638>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_n_WhlSpdRHR_D = 0.0F;/* Referenced by: '<S5639>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_p_HtPmpDsrgrdHeadPress =
    800.0F;                            /* Referenced by: '<S2835>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_p_HtPmpIncldHeadPress =
    2000.0F;                           /* Referenced by: '<S2836>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_p_SuctnPress_D = 0.0F;/* Referenced by: '<S2171>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_AHH_StresFact_Max = 1.0F;/* Referenced by: '<S2298>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_AHH_StresFact_Min = 1.0F;/* Referenced by: '<S2952>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_AHH_StressFactor_D = 0.0F;/* Referenced by: '<S3786>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_BattCabPriority_D = 0.0F;/* Referenced by: '<S218>/Calib' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_Dflt_NoPrioritySelected =
    0.5F;                              /* Referenced by: '<S1206>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_Dflt_Priority = 0.5F;/* Referenced by: '<S1195>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_EDMHeatEstm_SpcfcHeatChng
    = 0.85F;                           /* Referenced by: '<S2425>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_r_EDMHeatEstm_ThrmlEnrgyBalnce = 0.15F;/* Referenced by: '<S2426>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_r_EOPEmrgCool_AHH_StresFact_Max = 1.0F;/* Referenced by: '<S2685>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_FCClntdTTgtfctr_FCSDerate
    = 0.0F;                            /* Referenced by: '<S813>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_FullBatt = 1.0F;/* Referenced by: '<S1196>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_FullToCab = 0.0F;/* Referenced by: '<S1197>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_HvHrnMtrAPowerLimit_NF =
    1.0F;                              /* Referenced by: '<S5702>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_HvHrnMtrBPowerLimit_NF =
    1.0F;                              /* Referenced by: '<S5703>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_HvHrnMtrCPowerLimit_NF =
    1.0F;                              /* Referenced by: '<S5704>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_LTLTgt_HCCTISBTLPri =
    0.2F;                              /* Referenced by: '<S4638>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_r_LTRVlv_DfltPos4SlvrCnvrgdButOutRng = 1.0F;/* Referenced by: '<S2789>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_MoreToBatt = 0.8F;/* Referenced by: '<S1200>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_MoreToCab = 0.3F;/* Referenced by: '<S1203>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_MoreToCab_Opt = 0.3F;/* Referenced by: '<S1191>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_NoPriority = 0.5F;/* Referenced by: '<S1205>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_PerWp_BatTmpErr_Wght =
    0.5F;                              /* Referenced by: '<S1911>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_PerWp_EngTmpErr_Wght =
    0.5F;                              /* Referenced by: '<S1912>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_PerWp_TmpErr_WghtCorrct =
    2.0F;                              /* Referenced by: '<S1913>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_r_VehSpdLwPassFltrCf_frLTCLtooHotThrsh = 0.7F;/* Referenced by: '<S5178>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_r_WCondPrioRatioFrHTLVlv =
    0.8F;                              /* Referenced by: '<S1986>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_t_AAD_RetrctDbncTime = 0U;/* Referenced by: '<S103>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_BCH_WshdPwrNot_AvalTim =
    0.0F;                              /* Referenced by: '<S3184>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_BatHtTm_HtrFlty = 180.0F;/* Referenced by: '<S1538>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_t_BatPerWU_ThrmlCond_Timer_Dial = 10.0F;/* Referenced by: '<S3391>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_BattCool_TmOut = 0.5F;/* Referenced by: '<S1872>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_BothHtTm_HtrFlty = 420.0F;/* Referenced by: '<S1539>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_CabHtTm_HtrFlty = 300.0F;/* Referenced by: '<S1540>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_DelayEngTurn_Off = 5.0F;/* Referenced by: '<S1590>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_DerationTime = 5.0F;/* Referenced by: '<S1785>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_ECH_WshdPwrDelay = 5.0F;/* Referenced by: '<S1767>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_ECH_WshdPwrNot_AvalTim =
    5.0F;                              /* Referenced by:
                                        * '<S1738>/Calib'
                                        * '<S1786>/Calib'
                                        */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_ElVlv3WayFanMinOffDly_C =
    8.0F;                              /* Referenced by: '<S1085>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_t_Extnd_Max_Cooling_for_Max_AHH_SF = 10.0F;/* Referenced by: '<S2299>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_FanAftrRunOnTmr = 120.0F;/* Referenced by: '<S71>/AfterRun' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_Fan_Off_to_On_Timer =
    0.5F;                              /* Referenced by: '<S5447>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_Fan_min_FanRunTime =
    10.0F;                             /* Referenced by: '<S5448>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_HTCV_LearnOnWait_Tim =
    250.0F;                            /* Referenced by: '<S2124>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_HTSOV_OpnDelayTim = 5.0F;/* Referenced by: '<S1631>/Calib' */
static volatile CONST(uint16, THMR_VAR_INIT) KeTHMR_t_HVBR_LocalUsgEnb = 1U;/* Referenced by: '<S4424>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_INITValuesWaittime_CabVlv
    = 5.0F;                            /* Referenced by: '<S1346>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_InitWshdPwr_StartUpTim =
    30.0F;                             /* Referenced by: '<S1749>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_LimFuCellPwrLimThDec_C =
    8.0F;                              /* Referenced by: '<S1051>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_MaxWaitTimeFrAftrRnRq =
    1.0F;                              /* Referenced by: '<S71>/AfterRun' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_MinAftrRunTime = 180.0F;/* Referenced by: '<S71>/AfterRun' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_RTC_CalDelay = 2.0F;/* Referenced by: '<S71>/AfterRun' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_t_RadBypFuCellHiTHEXHysNotRstDly_C = 30.0F;/* Referenced by: '<S1114>/Calib' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_t_RadBypFuCellHiTHEXHysRstDly_C = 30.0F;/* Referenced by: '<S1115>/Calib' */

#endif

static volatile CONST(sint16, THMR_VAR_INIT) KeTHMR_t_SC_PrecTimer_Dial = 0;/* Referenced by: '<S322>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KeTHMR_t_TCoOutDeltaFuCellHiTHEXRstDly_C = 1.0F;/* Referenced by: '<S1116>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_THMRTaskRt = 0.1F;/* Referenced by: '<S71>/AfterRun' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_t_oHXDeIceDuration = 300.0F;/* Referenced by: '<S4999>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_v_VehSpd_DeemStop = 1.0F;/* Referenced by: '<S4873>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_v_VehSpd_DeemStopHyst =
    3.0F;                              /* Referenced by: '<S4874>/Calib' */
static volatile CONST(float32, THMR_VAR_INIT) KeTHMR_v_VehicleSpd_Dial = 0.0F;/* Referenced by: '<S3965>/Calib' */
static volatile CONST(sint8, THMR_VAR_INIT) KeTHMR_y_DelayEngTurn_OffSelAp = 2;/* Referenced by: '<S1547>/Calib' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(sint8, THMR_VAR_INIT) KeTHMR_y_ThrmSysShtDwnFlt_Dial = 0;/* Referenced by: '<S3345>/Calib' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_Cf_ClntFlwsConv_EDMheatEstm[8] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S2427>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_Cf_FEDM_OilFlwConv_EDMheatEstm[8] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S2428>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_Cf_REDM_OilFlwConv_EDMheatEstm[8] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S2429>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_CoolantHeatCap[6] =
{
    3384.0F, 3502.0F, 3594.0F, 3661.0F, 3707.0F, 3720.0F
} ;                                    /* Referenced by:
                                        * '<S742>/Vector'
                                        * '<S2107>/Vector'
                                        * '<S2430>/Vector'
                                        * '<S3111>/Vector'
                                        */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_KiMtrACon[7] =
{
    0.1F, 0.1F, 0.1F, 0.1F, 0.1F, 0.1F, 0.1F
} ;                                    /* Referenced by:
                                        * '<S3443>/Vector'
                                        * '<S3462>/Vector'
                                        * '<S3481>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_KiMtrBCon[7] =
{
    0.1F, 0.1F, 0.1F, 0.1F, 0.1F, 0.1F, 0.1F
} ;                                    /* Referenced by:
                                        * '<S3509>/Vector'
                                        * '<S3524>/Vector'
                                        * '<S3539>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_KiMtrCCon[7] =
{
    0.1F, 0.1F, 0.1F, 0.1F, 0.1F, 0.1F, 0.1F
} ;                                    /* Referenced by:
                                        * '<S3571>/Vector'
                                        * '<S3582>/Vector'
                                        * '<S3597>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_KpMtrACon[7] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by:
                                        * '<S3444>/Vector'
                                        * '<S3463>/Vector'
                                        * '<S3482>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_KpMtrBCon[7] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by:
                                        * '<S3510>/Vector'
                                        * '<S3525>/Vector'
                                        * '<S3540>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_KpMtrCCon[7] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by:
                                        * '<S3572>/Vector'
                                        * '<S3583>/Vector'
                                        * '<S3598>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MaxFCSDerateFctr[7] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S822>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MaxMtrAConTemp1[7] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by:
                                        * '<S3431>/Vector'
                                        * '<S3448>/Vector'
                                        * '<S3467>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MaxMtrAConTemp2[7] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by:
                                        * '<S3432>/Vector'
                                        * '<S3449>/Vector'
                                        * '<S3468>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MaxMtrAConTemp3[7] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by:
                                        * '<S3433>/Vector'
                                        * '<S3450>/Vector'
                                        * '<S3469>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MaxMtrAConTemp4[7] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by:
                                        * '<S3434>/Vector'
                                        * '<S3451>/Vector'
                                        * '<S3470>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MaxMtrBConTemp1[7] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by:
                                        * '<S3501>/Vector'
                                        * '<S3514>/Vector'
                                        * '<S3529>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MaxMtrBConTemp2[7] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by:
                                        * '<S3502>/Vector'
                                        * '<S3515>/Vector'
                                        * '<S3530>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MaxMtrCConTemp1[7] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3561>/Vector'
                                        * '<S3574>/Vector'
                                        * '<S3587>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MaxMtrCConTemp2[7] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3562>/Vector'
                                        * '<S3575>/Vector'
                                        * '<S3588>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MinFCSDerateFctr[7] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S823>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MinMtrAConTemp1[7] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3435>/Vector'
                                        * '<S3452>/Vector'
                                        * '<S3471>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MinMtrAConTemp2[7] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3436>/Vector'
                                        * '<S3453>/Vector'
                                        * '<S3472>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MinMtrAConTemp3[7] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3437>/Vector'
                                        * '<S3454>/Vector'
                                        * '<S3473>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MinMtrAConTemp4[7] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3438>/Vector'
                                        * '<S3455>/Vector'
                                        * '<S3474>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MinMtrBConTemp1[7] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3503>/Vector'
                                        * '<S3516>/Vector'
                                        * '<S3531>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MinMtrBConTemp2[7] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3504>/Vector'
                                        * '<S3517>/Vector'
                                        * '<S3532>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MinMtrCConTemp1[7] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3563>/Vector'
                                        * '<S3576>/Vector'
                                        * '<S3589>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_MinMtrCConTemp2[7] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3564>/Vector'
                                        * '<S3577>/Vector'
                                        * '<S3590>/Vector'
                                        */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_Min_HtrPwr_Ki[36] =
{
    10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 10.0F
} ;                                    /* Referenced by: '<S1252>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_Min_HtrPwr_Kp[36] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S1253>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_Reg_HtrPwr_Ki_ECO[36] =
{
    132.0F, 132.0F, 2.3F, 2.3F, 2.3F, 2.3F, 132.0F, 132.0F, 2.3F, 2.3F, 2.3F,
    2.3F, 132.0F, 132.0F, 2.3F, 2.3F, 2.3F, 2.3F, 132.0F, 132.0F, 2.3F, 2.3F,
    2.3F, 2.3F, 132.0F, 132.0F, 2.3F, 2.3F, 2.3F, 2.3F, 132.0F, 132.0F, 2.3F,
    2.3F, 2.3F, 2.3F
} ;                                    /* Referenced by: '<S1283>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_Reg_HtrPwr_Ki_HPM[36] =
{
    10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 10.0F
} ;                                    /* Referenced by: '<S1284>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_Reg_HtrPwr_Ki_HPM_ECO[36]
    =
{
    216.0F, 216.0F, 40.0F, 40.0F, 40.0F, 40.0F, 216.0F, 216.0F, 40.0F, 40.0F,
    40.0F, 40.0F, 216.0F, 216.0F, 40.0F, 40.0F, 40.0F, 40.0F, 216.0F, 216.0F,
    40.0F, 40.0F, 40.0F, 40.0F, 216.0F, 216.0F, 40.0F, 40.0F, 40.0F, 40.0F,
    216.0F, 216.0F, 40.0F, 40.0F, 40.0F, 40.0F
} ;                                    /* Referenced by: '<S1285>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_Reg_HtrPwr_Ki_NM[36] =
{
    132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F,
    132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F,
    132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F,
    132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F, 132.0F
} ;                                    /* Referenced by: '<S1286>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_Reg_HtrPwr_Kp_ECO[36] =
{
    216.0F, 216.0F, 40.0F, 40.0F, 40.0F, 40.0F, 216.0F, 216.0F, 40.0F, 40.0F,
    40.0F, 40.0F, 216.0F, 216.0F, 40.0F, 40.0F, 40.0F, 40.0F, 216.0F, 216.0F,
    40.0F, 40.0F, 40.0F, 40.0F, 216.0F, 216.0F, 40.0F, 40.0F, 40.0F, 40.0F,
    216.0F, 216.0F, 40.0F, 40.0F, 40.0F, 40.0F
} ;                                    /* Referenced by: '<S1287>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_Reg_HtrPwr_Kp_HPM[36] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S1288>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_Reg_HtrPwr_Kp_HPM_ECO[36]
    =
{
    216.0F, 216.0F, 40.0F, 40.0F, 40.0F, 40.0F, 216.0F, 216.0F, 40.0F, 40.0F,
    40.0F, 40.0F, 216.0F, 216.0F, 40.0F, 40.0F, 40.0F, 40.0F, 216.0F, 216.0F,
    40.0F, 40.0F, 40.0F, 40.0F, 216.0F, 216.0F, 40.0F, 40.0F, 40.0F, 40.0F,
    216.0F, 216.0F, 40.0F, 40.0F, 40.0F, 40.0F
} ;                                    /* Referenced by: '<S1289>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_K_Reg_HtrPwr_Kp_NM[36] =
{
    216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F,
    216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F,
    216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F,
    216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F, 216.0F
} ;                                    /* Referenced by: '<S1290>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_P_BattHeatPwrNeed_PerWup[8]
    =
{
    0.0F, 1500.0F, 3000.0F, 3500.0F, 4500.0F, 6000.0F, 7500.0F, 9000.0F
} ;                                    /* Referenced by: '<S1239>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_P_CabAirHtrPwrTgt[9] =
{
    10.0F, 510.0F, 1030.0F, 1560.0F, 2590.0F, 3630.0F, 4670.0F, 5740.0F, 6600.0F
} ;                                    /* Referenced by: '<S1261>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_P_CabinPwrNeed_BlwrFlowMin
    [9] =
{
    7000.0F, 7000.0F, 7000.0F, 7000.0F, 6000.0F, 4000.0F, 1000.0F, 0.001F,
    0.001F
} ;                                    /* Referenced by: '<S1254>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_P_CabinPwrNeed_LookUp[8] =
{
    0.0F, 1500.0F, 3000.0F, 3500.0F, 4500.0F, 6000.0F, 7500.0F, 9000.0F
} ;                                    /* Referenced by: '<S1265>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_P_ECHWishdPowerLimInit_ECT
    [6] =
{
    7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F
} ;                                    /* Referenced by: '<S1787>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_P_ECH_HtrPwrTgt_FuelEcnmy
    [10] =
{
    7000.0F, 7000.0F, 7000.0F, 5000.0F, 5000.0F, 7000.0F, 7000.0F, 7000.0F,
    7000.0F, 7000.0F
} ;                                    /* Referenced by: '<S1641>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_P_EDU_Heat_Loss[4] =
{
    2.0F, 5.0F, 10.0F, 20.0F
} ;                                    /* Referenced by: '<S2446>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_P_EngPwrWasteHVACEcoModeHTSOV[8] =
{
    0.0F, 1500.0F, 3000.0F, 3500.0F, 4500.0F, 6000.0F, 7500.0F, 9000.0F
} ;                                    /* Referenced by: '<S1714>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_P_EngPwrWaste_Availb[8] =
{
    0.0F, 1500.0F, 3000.0F, 3500.0F, 4500.0F, 6000.0F, 7500.0F, 9000.0F
} ;                                    /* Referenced by: '<S1715>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_P_FuCellHiTHEXCtlReqRst_T[8]
    =
{
    32500.0F, 28750.0F, 21250.0F, 17500.0F, 13750.0F, 10000.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S1117>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_P_LTCL_Heat_Reject[56] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 30.0F, 30.0F,
    30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F,
    40.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 60.0F, 60.0F, 60.0F,
    60.0F, 60.0F, 60.0F, 60.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F
} ;                                    /* Referenced by: '<S2821>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_P_MaxBCHPwrHtrClntFlow[8] =
{
    10000.0F, 10000.0F, 10000.0F, 10000.0F, 10000.0F, 10000.0F, 10000.0F,
    10000.0F
} ;                                    /* Referenced by: '<S3170>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_P_MaxCabHtrPwrVsClntFlow[8]
    =
{
    7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F
} ;                                    /* Referenced by: '<S1423>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_P_Min_HCCTIS_MaxPwr[36] =
{
    10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 10.0F
} ;                                    /* Referenced by: '<S1255>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_P_OV_AmbChill_CabPwr[9] =
{
    3800.0F, 3800.0F, 3700.0F, 3500.0F, 3000.0F, 2500.0F, 300.0F, 100.0F, 0.0F
} ;                                    /* Referenced by: '<S1240>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_P_PerWpCond_EngHeatPwr_Need[8] =
{
    0.0F, 1500.0F, 3000.0F, 3500.0F, 4500.0F, 6000.0F, 7500.0F, 9000.0F
} ;                                    /* Referenced by: '<S1952>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_P_Reg_HCCTIS_MaxPwr[36] =
{
    7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F,
    7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F,
    7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F,
    7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F, 7000.0F,
    7000.0F, 7000.0F, 7000.0F, 7000.0F
} ;                                    /* Referenced by: '<S1270>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_AGS1_PosReqLUT[10] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5420>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_AGS1_PosReqLUT1[10] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5421>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_AGS2_PosReqLUT[10] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5422>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_AGS_PosReqLUT[10] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5385>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_AHH_Fan_Speed[9] =
{
    0.001F, 0.0F, 0.33F, 0.33F, 0.66F, 0.66F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S5427>/Vector' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_BTCLPstnFlwpct[9] =
{
    0.0F, 0.05F, 0.3F, 0.4F, 0.5F, 0.6F, 0.7F, 0.95F, 1.0F
} ;                                    /* Referenced by: '<S277>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_BattRad_AGSPos_Req[143]
    =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5601>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_Pct_BattRad_Airflow_Idx_AGS[132] =
{
    4.0F, 2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 4.0F, 3.0F,
    3.0F, 2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 4.0F, 4.0F, 2.0F,
    2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 1.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 4.0F, 3.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 4.0F
} ;                                    /* Referenced by: '<S5455>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_Pct_BattRad_Airflow_Idx_AGSOpen[143] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 6.0F, 6.0F,
    5.0F, 3.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 6.0F, 6.0F, 5.0F, 3.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 7.0F, 7.0F, 6.0F, 4.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 9.0F, 9.0F, 8.0F, 6.0F, 3.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 11.0F, 10.0F, 10.0F, 8.0F, 6.0F, 3.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 1.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 6.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 6.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 5.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F
} ;                                    /* Referenced by: '<S5456>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_BattRad_FanPWM_Req[143]
    =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5602>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_CabVlvOpeng_CmdLookUp[6]
    =
{
    0.001F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S1361>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_Pct_DirectAirFlw_AGSPos_Req[143] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5603>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_Pct_DirectAirFlw_FanPWM_Req[143] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5604>/Vector' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_ECM_Airflow_Idx_AGS[132]
    =
{
    4.0F, 2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 4.0F, 3.0F,
    3.0F, 2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 4.0F, 4.0F, 2.0F,
    2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 1.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 4.0F, 3.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 4.0F
} ;                                    /* Referenced by: '<S5469>/Vector' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_Pct_ECM_Airflow_Idx_AGSOpen[143] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 6.0F, 6.0F,
    5.0F, 3.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 6.0F, 6.0F, 5.0F, 3.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 7.0F, 7.0F, 6.0F, 4.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 9.0F, 9.0F, 8.0F, 6.0F, 3.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 11.0F, 10.0F, 10.0F, 8.0F, 6.0F, 3.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 1.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 6.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 6.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 5.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F
} ;                                    /* Referenced by: '<S5470>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_EffctvAGSCombPos[49] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 20.0F, 20.0F, 20.0F,
    20.0F, 20.0F, 20.0F, 20.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F,
    50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 100.0F, 100.0F, 100.0F,
    100.0F, 100.0F, 100.0F, 100.0F
} ;                                    /* Referenced by: '<S5514>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_EngRad_AGSPos_Req[143] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5605>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_EngRad_FanPWM_Req[143] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5606>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_FCLPstnFlwpct[9] =
{
    0.0F, 0.05F, 0.3F, 0.4F, 0.5F, 0.6F, 0.7F, 0.95F, 1.0F
} ;                                    /* Referenced by: '<S890>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_FCNucleus_AGSPos[6] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5614>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_FCNucleus_FanPWM[6] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5615>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_FC_AGSPos_ReqFCA[143] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5607>/Vector' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_FC_HTR_Airflow_Idx_AGS
    [132] =
{
    4.0F, 2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 4.0F, 3.0F,
    3.0F, 2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 4.0F, 4.0F, 2.0F,
    2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 1.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 4.0F, 3.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 4.0F
} ;                                    /* Referenced by: '<S5476>/Vector' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_Pct_FC_HTR_Airflow_Idx_AGSOpen[143] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 6.0F, 6.0F,
    5.0F, 3.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 6.0F, 6.0F, 5.0F, 3.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 7.0F, 7.0F, 6.0F, 4.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 9.0F, 9.0F, 8.0F, 6.0F, 3.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 11.0F, 10.0F, 10.0F, 8.0F, 6.0F, 3.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 1.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 6.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 6.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 5.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F
} ;                                    /* Referenced by: '<S5477>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_FC_VlvFdpPosPct[9] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 50.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by:
                                        * '<S743>/Vector'
                                        * '<S837>/Vector'
                                        */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_FanPWM_ReqFCA[143] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5608>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_HTCLPstnFlwpct[9] =
{
    0.0F, 0.05F, 0.3F, 0.4F, 0.5F, 0.6F, 0.7F, 0.95F, 1.0F
} ;                                    /* Referenced by:
                                        * '<S1907>/Vector'
                                        * '<S4414>/Vector'
                                        * '<S4418>/Vector'
                                        * '<S4475>/Vector'
                                        */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_HTRConversionRCVR[6] =
{
    7.5F, 9.0F, 10.5F, 12.0F, 13.5F, 15.0F
} ;                                    /* Referenced by: '<S779>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_Pct_HeadPres_Airflow_Idx_AGS[143] =
{
    5.0F, 2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 3.0F,
    2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 4.0F, 4.0F, 2.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 3.0F, 2.0F, 1.0F, 1.0F, 1.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 3.0F, 2.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 3.0F, 3.0F, 1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 4.0F, 1.0F, 3.0F, 2.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 3.0F, 1.0F, 2.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F,
    3.0F, 3.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 3.0F, 5.0F
} ;                                    /* Referenced by: '<S5462>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_Pct_HeadPres_Airflow_Idx_AGSOpen[143] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 3.0F, 2.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 6.0F, 6.0F, 5.0F, 3.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 7.0F, 7.0F, 6.0F, 4.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 9.0F, 9.0F, 8.0F, 6.0F, 4.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 11.0F, 11.0F, 10.0F, 8.0F, 6.0F, 3.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 6.0F, 2.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 6.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 5.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F
} ;                                    /* Referenced by: '<S5463>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_LTCLPstnFlwpct[13] =
{
    0.0F, 0.08333F, 0.166667F, 0.25F, 0.33333F, 0.416663F, 0.5F, 0.58333F,
    0.66663F, 0.75F, 0.833333F, 0.916666F, 1.0F
} ;                                    /* Referenced by: '<S4487>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_LTRVlvCmd_Airflow[5] =
{
    20.0F, 20.0F, 20.0F, 10.0F, 0.0F
} ;                                    /* Referenced by: '<S5386>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_LTR_AGSPos_Req[143] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5609>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_LTR_Airflow_Idx_AGS[132]
    =
{
    5.0F, 2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 3.0F,
    3.0F, 2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 4.0F, 4.0F, 2.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 1.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 4.0F, 3.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F
} ;                                    /* Referenced by: '<S5483>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_Pct_LTR_Airflow_Idx_AGSOpen[143] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 6.0F, 6.0F,
    5.0F, 3.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 6.0F, 6.0F, 5.0F, 3.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 7.0F, 7.0F, 6.0F, 4.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 9.0F, 9.0F, 8.0F, 6.0F, 3.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 11.0F, 10.0F, 10.0F, 8.0F, 6.0F, 3.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 1.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 6.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 6.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 5.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F
} ;                                    /* Referenced by: '<S5484>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_LTR_FanPWM_Req[143] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5610>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_MaskCmprNoiseFanCmd[5] =
{
    0.0F, 0.001F, 0.01F, 0.1F, 0.2F
} ;                                    /* Referenced by: '<S5611>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_OHX_AGSPos_Req[143] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5612>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_OHX_FanPWM_Req[143] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S5613>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_P1MotorReqDsbl

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_Pct_P1Motor_Airflow_Idx_AGS[132] =
{
    4.0F, 2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 4.0F, 3.0F,
    3.0F, 2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 4.0F, 4.0F, 2.0F,
    2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 1.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 2.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 4.0F, 3.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 4.0F
} ;                                    /* Referenced by: '<S5499>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_P1MotorReqDsbl

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_Pct_P1Motor_Airflow_Idx_AGSOpen[143] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 6.0F, 6.0F,
    5.0F, 3.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 6.0F, 6.0F, 5.0F, 3.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 7.0F, 7.0F, 6.0F, 4.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 9.0F, 9.0F, 8.0F, 6.0F, 3.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 11.0F, 10.0F, 10.0F, 8.0F, 6.0F, 3.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 1.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 6.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 6.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 5.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F
} ;                                    /* Referenced by: '<S5500>/Vector' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_Pct_PPU_Airflow_Idx_AGS[143]
    =
{
    4.0F, 2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 4.0F, 3.0F,
    2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 4.0F, 1.0F, 1.0F,
    2.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 4.0F, 1.0F, 1.0F, 2.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F, 4.0F, 1.0F, 1.0F, 2.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 1.0F, 1.0F, 2.0F, 1.0F, 1.0F,
    1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 3.0F, 4.0F, 1.0F, 2.0F, 1.0F, 1.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 3.0F, 4.0F, 1.0F, 2.0F, 1.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 5.0F, 4.0F, 3.0F, 3.0F, 1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 1.0F, 3.0F, 1.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 3.0F, 1.0F, 2.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    3.0F, 3.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 3.0F, 5.0F
} ;                                    /* Referenced by: '<S5506>/Vector' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_Pct_PPU_Airflow_Idx_AGSOpen[143] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 3.0F, 2.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 6.0F, 6.0F, 5.0F, 3.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 7.0F, 7.0F, 6.0F, 4.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 9.0F, 9.0F, 8.0F, 6.0F, 4.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 11.0F, 11.0F, 10.0F, 8.0F, 6.0F, 3.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 6.0F, 2.0F, 1.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 6.0F, 2.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 10.0F, 6.0F, 1.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 9.0F, 5.0F,
    11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F, 11.0F
} ;                                    /* Referenced by: '<S5507>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_T_BattClntMaxTgt[126] =
{
    -45.0F, -45.0F, -45.0F, -45.0F, -45.0F, -45.0F, -45.0F, -45.0F, -45.0F,
    -45.0F, -45.0F, -45.0F, -45.0F, -45.0F, -45.0F, -45.0F, -45.0F, -45.0F,
    -35.0F, -35.0F, -35.0F, -35.0F, -35.0F, -35.0F, -35.0F, -35.0F, -35.0F,
    -35.0F, -35.0F, -35.0F, -35.0F, -35.0F, -35.0F, -35.0F, -35.0F, -35.0F,
    -25.0F, -25.0F, -25.0F, -25.0F, -25.0F, -25.0F, -25.0F, -25.0F, -25.0F,
    -25.0F, -25.0F, -25.0F, -25.0F, -25.0F, -25.0F, -25.0F, -25.0F, -25.0F,
    -15.0F, -15.0F, -15.0F, -15.0F, -15.0F, -15.0F, -15.0F, -15.0F, -15.0F,
    -15.0F, -15.0F, -15.0F, -15.0F, -15.0F, -15.0F, -15.0F, -15.0F, -15.0F,
    -5.0F, -5.0F, -5.0F, -5.0F, -5.0F, -5.0F, -5.0F, -5.0F, -5.0F, -5.0F, -5.0F,
    -5.0F, -5.0F, -5.0F, -5.0F, -5.0F, -5.0F, -5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F,
    5.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F,
    20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F
} ;                                    /* Referenced by: '<S367>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_T_BattClntMinTgt[126] =
{
    -10.0F, -10.0F, -10.0F, -10.0F, -10.0F, -10.0F, -10.0F, -10.0F, -10.0F,
    -10.0F, -10.0F, -10.0F, -10.0F, -10.0F, -10.0F, -10.0F, -10.0F, -10.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F,
    20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 30.0F, 30.0F, 30.0F, 30.0F,
    30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F,
    30.0F, 30.0F, 30.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F,
    40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 55.0F,
    55.0F, 55.0F, 55.0F, 55.0F, 55.0F, 55.0F, 55.0F, 55.0F, 55.0F, 55.0F, 55.0F,
    55.0F, 55.0F, 55.0F, 55.0F, 55.0F, 55.0F
} ;                                    /* Referenced by: '<S368>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_T_CellTempMaxAllow[108] =
{
    40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 35.0F, 40.0F, 40.0F,
    40.0F, 40.0F, 25.0F, 25.0F, 25.0F, 10.0F, 18.0F, 40.0F, 40.0F, 40.0F, 40.0F,
    40.0F, 40.0F, 40.0F, 40.0F, 35.0F, 40.0F, 40.0F, 40.0F, 40.0F, 25.0F, 25.0F,
    25.0F, 10.0F, 18.0F, 37.0F, 37.0F, 37.0F, 37.5F, 37.0F, 37.0F, 40.0F, 40.0F,
    35.0F, 37.0F, 37.0F, 37.0F, 37.0F, 25.0F, 25.0F, 25.0F, 10.0F, 18.0F, 37.0F,
    37.0F, 37.0F, 37.0F, 37.0F, 37.0F, 40.0F, 40.0F, 35.0F, 37.0F, 37.5F, 37.6F,
    37.0F, 25.0F, 25.0F, 25.0F, 10.0F, 18.0F, 37.0F, 37.0F, 37.0F, 37.0F, 37.0F,
    37.0F, 40.0F, 40.0F, 35.0F, 37.0F, 37.0F, 37.0F, 37.0F, 25.0F, 25.0F, 25.0F,
    10.0F, 18.0F, 37.0F, 37.0F, 37.0F, 37.0F, 37.0F, 37.0F, 40.0F, 40.0F, 35.0F,
    37.0F, 37.0F, 37.0F, 37.3F, 25.0F, 25.0F, 25.0F, 10.0F, 18.0F
} ;                                    /* Referenced by: '<S372>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_T_CellTempMaxAllowPsv[18] =
{
    30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F,
    30.0F, 30.0F, 25.0F, 25.0F, 25.0F, 10.0F, 18.0F
} ;                                    /* Referenced by: '<S373>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_T_CellTempMinAllowPsv[18] =
{
    10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 25.0F, 25.0F, 25.0F, 10.0F, 18.0F
} ;                                    /* Referenced by: '<S376>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_T_ChrgLvlBasedAmbTemp[15] =
{
    15.0F, 15.0F, 45.0F, 15.0F, 15.0F, 45.0F, 15.0F, 20.0F, 45.0F, 15.0F, 35.0F,
    45.0F, 15.0F, 45.0F, 45.0F
} ;                                    /* Referenced by: '<S4875>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_T_ChrgPwrReqBasedAmbTemp[10]
    =
{
    15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F
} ;                                    /* Referenced by: '<S4876>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_T_CoFuCellHiTOutSpOfs_T[10]
    =
{
    20.0F, 12.0F, 9.0F, 7.0F, 5.0F, 3.0F, 2.0F, 1.0F, 0.5F, 0.0F
} ;                                    /* Referenced by: '<S1010>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_T_LTCLVlvAllowTempDflt_Ambient[5] =
{
    45.0F, 45.0F, 30.0F, 30.0F, 30.0F
} ;                                    /* Referenced by: '<S5214>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_T_MGU_AirInletTmp_Offset[12]
    =
{
    10.0F, 10.0F, 10.0F, 15.0F, 18.0F, 20.0F, 30.0F, 37.0F, 40.0F, 44.0F, 40.0F,
    37.0F
} ;                                    /* Referenced by: '<S2854>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_T_PsvCool_BTISMaxAllwd[15] =
{
    0.0F, 15.0F, 30.0F, 0.0F, 15.0F, 30.0F, 0.0F, 15.0F, 30.0F, 0.0F, 15.0F,
    30.0F, 0.0F, 15.0F, 30.0F
} ;                                    /* Referenced by: '<S4877>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_T_TempMinAllow[18] =
{
    -12.0F, -8.0F, -8.0F, -8.0F, -8.0F, -8.0F, -10.0F, -5.0F, 25.0F, -10.0F,
    -8.0F, -8.0F, -8.0F, 25.0F, 25.0F, 25.0F, 10.0F, 18.0F
} ;                                    /* Referenced by: '<S377>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_T_VehSpdBasedAmbTemp[8] =
{
    10.0F, 10.0F, 15.0F, 20.0F, 25.0F, 25.0F, 25.0F, 30.0F
} ;                                    /* Referenced by: '<S4813>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_T_WaOutRadHiTEstimFil_T[6] =
{
    0.01F, 0.008F, 0.006F, 0.005F, 0.004F, 0.003F
} ;                                    /* Referenced by: '<S1011>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_T_WaPmpFuCellOfs_T[8] =
{
    1.0F, 1.7F, 2.7F, 4.0F, 5.0F, 6.2F, 8.3F, 10.0F
} ;                                    /* Referenced by: '<S917>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dQ_FrontEDM_ActHeat[121] =
{
    0.0F, 17.0F, 34.0F, 51.0F, 68.0F, 85.0F, 102.0F, 119.0F, 136.0F, 153.0F,
    170.0F, 1500.0F, 375.0F, 591.0F, 821.0F, 1089.0F, 1085.0F, 2050.0F, 2413.0F,
    2600.0F, 3207.0F, 3638.0F, 3000.0F, 675.0F, 954.0F, 1253.0F, 1596.0F,
    1565.0F, 2707.0F, 3241.0F, 3712.0F, 4207.0F, 4724.0F, 4500.0F, 1000.0F,
    1351.0F, 1711.0F, 2125.0F, 2567.0F, 3536.0F, 4053.0F, 4538.0F, 5153.0F,
    5750.0F, 6000.0F, 1400.0F, 1785.0F, 2133.0F, 2664.0F, 3156.0F, 4284.0F,
    5663.0F, 5466.0F, 6114.0F, 6770.0F, 7500.0F, 1825.0F, 2267.0F, 2737.0F,
    3283.0F, 3843.0F, 5007.0F, 5747.0F, 6428.0F, 6915.0F, 7492.0F, 9000.0F,
    2070.0F, 2821.0F, 3341.0F, 3348.0F, 4556.0F, 5618.0F, 6138.0F, 7044.0F,
    7959.0F, 8996.0F, 10500.0F, 2300.0F, 3356.0F, 3846.0F, 4374.0F, 4999.0F,
    6757.0F, 7723.0F, 8864.0F, 10046.0F, 11202.0F, 12000.0F, 3360.0F, 3853.0F,
    4483.0F, 5318.0F, 6100.0F, 6411.0F, 9532.0F, 11055.0F, 12594.0F, 14328.0F,
    13500.0F, 4100.0F, 4861.0F, 5635.0F, 6655.0F, 7768.0F, 10411.0F, 12013.0F,
    13802.0F, 15320.0F, 18613.0F, 15000.0F, 5000.0F, 6000.0F, 7000.0F, 8000.0F,
    9000.0F, 12000.0F, 14000.0F, 17000.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2877>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dQ_FrontEDM_HeatLoss[121] =
{
    0.0F, 17.0F, 34.0F, 51.0F, 68.0F, 85.0F, 102.0F, 119.0F, 136.0F, 153.0F,
    170.0F, 1500.0F, 375.0F, 591.0F, 821.0F, 1089.0F, 1085.0F, 2050.0F, 2413.0F,
    2600.0F, 3207.0F, 3638.0F, 3000.0F, 675.0F, 954.0F, 1253.0F, 1596.0F,
    1565.0F, 2707.0F, 3241.0F, 3712.0F, 4207.0F, 4724.0F, 4500.0F, 1000.0F,
    1351.0F, 1711.0F, 2125.0F, 2567.0F, 3536.0F, 4053.0F, 4538.0F, 5153.0F,
    5750.0F, 6000.0F, 1400.0F, 1785.0F, 2133.0F, 2664.0F, 3156.0F, 4284.0F,
    5663.0F, 5466.0F, 6114.0F, 6770.0F, 7500.0F, 1825.0F, 2267.0F, 2737.0F,
    3283.0F, 3843.0F, 5007.0F, 5747.0F, 6428.0F, 6915.0F, 7492.0F, 9000.0F,
    2070.0F, 2821.0F, 3341.0F, 3348.0F, 4556.0F, 5618.0F, 6138.0F, 7044.0F,
    7959.0F, 8996.0F, 10500.0F, 2300.0F, 3356.0F, 3846.0F, 4374.0F, 4999.0F,
    6757.0F, 7723.0F, 8864.0F, 10046.0F, 11202.0F, 12000.0F, 3360.0F, 3853.0F,
    4483.0F, 5318.0F, 6100.0F, 6411.0F, 9532.0F, 11055.0F, 12594.0F, 14328.0F,
    13500.0F, 4100.0F, 4861.0F, 5635.0F, 6655.0F, 7768.0F, 10411.0F, 12013.0F,
    13802.0F, 15320.0F, 18613.0F, 15000.0F, 5000.0F, 6000.0F, 7000.0F, 8000.0F,
    9000.0F, 12000.0F, 14000.0F, 17000.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2431>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dQ_FrontEDM_MaxHeat[11] =
{
    170.0F, 3638.0F, 4724.0F, 5750.0F, 6770.0F, 7492.0F, 7969.0F, 7723.0F,
    8411.0F, 9049.0F, 11000.0F
} ;                                    /* Referenced by: '<S2878>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dQ_GEN_ActHeat[121] =
{
    0.0F, 17.0F, 34.0F, 51.0F, 68.0F, 85.0F, 102.0F, 119.0F, 136.0F, 153.0F,
    170.0F, 1500.0F, 375.0F, 591.0F, 821.0F, 1089.0F, 1085.0F, 2050.0F, 2413.0F,
    2600.0F, 3207.0F, 3638.0F, 3000.0F, 675.0F, 954.0F, 1253.0F, 1596.0F,
    1565.0F, 2707.0F, 3241.0F, 3712.0F, 4207.0F, 4724.0F, 4500.0F, 1000.0F,
    1351.0F, 1711.0F, 2125.0F, 2567.0F, 3536.0F, 4053.0F, 4538.0F, 5153.0F,
    5750.0F, 6000.0F, 1400.0F, 1785.0F, 2133.0F, 2664.0F, 3156.0F, 4284.0F,
    5663.0F, 5466.0F, 6114.0F, 6770.0F, 7500.0F, 1825.0F, 2267.0F, 2737.0F,
    3283.0F, 3843.0F, 5007.0F, 5747.0F, 6428.0F, 6915.0F, 7492.0F, 9000.0F,
    2070.0F, 2821.0F, 3341.0F, 3348.0F, 4556.0F, 5618.0F, 6138.0F, 7044.0F,
    7959.0F, 8996.0F, 10500.0F, 2300.0F, 3356.0F, 3846.0F, 4374.0F, 4999.0F,
    6757.0F, 7723.0F, 8864.0F, 10046.0F, 11202.0F, 12000.0F, 3360.0F, 3853.0F,
    4483.0F, 5318.0F, 6100.0F, 6411.0F, 9532.0F, 11055.0F, 12594.0F, 14328.0F,
    13500.0F, 4100.0F, 4861.0F, 5635.0F, 6655.0F, 7768.0F, 10411.0F, 12013.0F,
    13802.0F, 15320.0F, 18613.0F, 15000.0F, 5000.0F, 6000.0F, 7000.0F, 8000.0F,
    9000.0F, 12000.0F, 14000.0F, 17000.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2879>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dQ_GEN_MaxHeat[11] =
{
    170.0F, 3638.0F, 4724.0F, 5750.0F, 6770.0F, 7492.0F, 7969.0F, 7723.0F,
    8411.0F, 9049.0F, 11000.0F
} ;                                    /* Referenced by: '<S2880>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dQ_RearEDM_ActHeat[121] =
{
    0.0F, 17.0F, 34.0F, 51.0F, 68.0F, 85.0F, 102.0F, 119.0F, 136.0F, 153.0F,
    170.0F, 1500.0F, 375.0F, 591.0F, 821.0F, 1089.0F, 1085.0F, 2050.0F, 2413.0F,
    2600.0F, 3207.0F, 3638.0F, 3000.0F, 675.0F, 954.0F, 1253.0F, 1596.0F,
    1565.0F, 2707.0F, 3241.0F, 3712.0F, 4207.0F, 4724.0F, 4500.0F, 1000.0F,
    1351.0F, 1711.0F, 2125.0F, 2567.0F, 3536.0F, 4053.0F, 4538.0F, 5153.0F,
    5750.0F, 6000.0F, 1400.0F, 1785.0F, 2133.0F, 2664.0F, 3156.0F, 4284.0F,
    5663.0F, 5466.0F, 6114.0F, 6770.0F, 7500.0F, 1825.0F, 2267.0F, 2737.0F,
    3283.0F, 3843.0F, 5007.0F, 5747.0F, 6428.0F, 6915.0F, 7492.0F, 9000.0F,
    2070.0F, 2821.0F, 3341.0F, 3348.0F, 4556.0F, 5618.0F, 6138.0F, 7044.0F,
    7959.0F, 8996.0F, 10500.0F, 2300.0F, 3356.0F, 3846.0F, 4374.0F, 4999.0F,
    6757.0F, 7723.0F, 8864.0F, 10046.0F, 11202.0F, 12000.0F, 3360.0F, 3853.0F,
    4483.0F, 5318.0F, 6100.0F, 6411.0F, 9532.0F, 11055.0F, 12594.0F, 14328.0F,
    13500.0F, 4100.0F, 4861.0F, 5635.0F, 6655.0F, 7768.0F, 10411.0F, 12013.0F,
    13802.0F, 15320.0F, 18613.0F, 15000.0F, 5000.0F, 6000.0F, 7000.0F, 8000.0F,
    9000.0F, 12000.0F, 14000.0F, 17000.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2881>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dQ_RearEDM_HeatLoss[121] =
{
    0.0F, 17.0F, 34.0F, 51.0F, 68.0F, 85.0F, 102.0F, 119.0F, 136.0F, 153.0F,
    170.0F, 1500.0F, 375.0F, 591.0F, 821.0F, 1089.0F, 1085.0F, 2050.0F, 2413.0F,
    2600.0F, 3207.0F, 3638.0F, 3000.0F, 675.0F, 954.0F, 1253.0F, 1596.0F,
    1565.0F, 2707.0F, 3241.0F, 3712.0F, 4207.0F, 4724.0F, 4500.0F, 1000.0F,
    1351.0F, 1711.0F, 2125.0F, 2567.0F, 3536.0F, 4053.0F, 4538.0F, 5153.0F,
    5750.0F, 6000.0F, 1400.0F, 1785.0F, 2133.0F, 2664.0F, 3156.0F, 4284.0F,
    5663.0F, 5466.0F, 6114.0F, 6770.0F, 7500.0F, 1825.0F, 2267.0F, 2737.0F,
    3283.0F, 3843.0F, 5007.0F, 5747.0F, 6428.0F, 6915.0F, 7492.0F, 9000.0F,
    2070.0F, 2821.0F, 3341.0F, 3348.0F, 4556.0F, 5618.0F, 6138.0F, 7044.0F,
    7959.0F, 8996.0F, 10500.0F, 2300.0F, 3356.0F, 3846.0F, 4374.0F, 4999.0F,
    6757.0F, 7723.0F, 8864.0F, 10046.0F, 11202.0F, 12000.0F, 3360.0F, 3853.0F,
    4483.0F, 5318.0F, 6100.0F, 6411.0F, 9532.0F, 11055.0F, 12594.0F, 14328.0F,
    13500.0F, 4100.0F, 4861.0F, 5635.0F, 6655.0F, 7768.0F, 10411.0F, 12013.0F,
    13802.0F, 15320.0F, 18613.0F, 15000.0F, 5000.0F, 6000.0F, 7000.0F, 8000.0F,
    9000.0F, 12000.0F, 14000.0F, 17000.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2432>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dQ_RearEDM_MaxHeat[11] =
{
    170.0F, 3638.0F, 4724.0F, 5750.0F, 6770.0F, 7492.0F, 7969.0F, 7723.0F,
    8411.0F, 9049.0F, 11000.0F
} ;                                    /* Referenced by: '<S2882>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_dT_CabPriorty_Blwr_EvapErrHigh[6] =
{
    5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F
} ;                                    /* Referenced by: '<S429>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_dT_CabPriorty_Blwr_EvapErrLow[6] =
{
    3.0F, 3.0F, 3.0F, 3.0F, 3.0F, 3.0F
} ;                                    /* Referenced by: '<S430>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dT_CondAirWarmupEst[36] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 2.0F,
    2.0F, 2.0F, 2.0F, 2.0F, 2.0F, 3.0F, 3.0F, 3.0F, 3.0F, 3.0F, 3.0F, 4.0F, 4.0F,
    4.0F, 4.0F, 4.0F, 4.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F
} ;                                    /* Referenced by: '<S749>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dT_LTRAirWarmupEst[36] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 2.0F,
    2.0F, 2.0F, 2.0F, 2.0F, 2.0F, 3.0F, 3.0F, 3.0F, 3.0F, 3.0F, 3.0F, 4.0F, 4.0F,
    4.0F, 4.0F, 4.0F, 4.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F
} ;                                    /* Referenced by: '<S750>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_AHH_LT_FrontEDM_FlwTgt[7]
    =
{
    0.0F, 1025.0F, 1400.0F, 2050.0F, 4200.0F, 6500.0F, 8000.0F
} ;                                    /* Referenced by: '<S2953>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_AHH_LT_RearEDM_FlwTgt[11]
    =
{
    0.5F, 0.55F, 0.6F, 0.65F, 0.7F, 0.75F, 0.8F, 0.85F, 0.9F, 0.95F, 1.0F
} ;                                    /* Referenced by: '<S2954>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_APM_ClntFlw[7] =
{
    0.31F, 0.4F, 0.65F, 0.8F, 1.3F, 1.77F, 3.0F
} ;                                    /* Referenced by: '<S2932>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_BattRad_AirFlowRaw[56] =
{
    0.0F, 65.0F, 119.2F, 173.4F, 227.5F, 281.7F, 335.9F, 0.0F, 73.5F, 134.7F,
    196.0F, 257.2F, 318.4F, 379.7F, 0.0F, 84.1F, 154.2F, 224.2F, 294.3F, 364.3F,
    434.4F, 0.0F, 117.3F, 215.0F, 312.7F, 410.4F, 508.1F, 605.7F, 0.0F, 160.0F,
    293.2F, 426.4F, 559.7F, 692.9F, 826.1F, 0.0F, 195.1F, 357.5F, 520.0F, 682.5F,
    845.0F, 1007.4F, 0.0F, 247.7F, 454.1F, 660.4F, 886.7F, 1073.1F, 1279.4F,
    0.0F, 335.5F, 614.9F, 894.4F, 1173.8F, 1453.2F, 1732.7F
} ;                                    /* Referenced by: '<S3112>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_ClngFlowRqrdMtr1[56] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 30.0F, 30.0F,
    30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F,
    40.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 60.0F, 60.0F, 60.0F,
    60.0F, 60.0F, 60.0F, 60.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F
} ;                                    /* Referenced by: '<S682>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_dV_ClngFlowRqrdMtr1_Reverse[56] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 30.0F, 30.0F,
    30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F,
    40.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 60.0F, 60.0F, 60.0F,
    60.0F, 60.0F, 60.0F, 60.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F
} ;                                    /* Referenced by: '<S677>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_ClngFlowRqrdMtr2[56] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 30.0F, 30.0F,
    30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F,
    40.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 60.0F, 60.0F, 60.0F,
    60.0F, 60.0F, 60.0F, 60.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F
} ;                                    /* Referenced by: '<S705>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_dV_ClngFlowRqrdMtr2_Reverse[56] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 30.0F, 30.0F,
    30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F,
    40.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 60.0F, 60.0F, 60.0F,
    60.0F, 60.0F, 60.0F, 60.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F
} ;                                    /* Referenced by: '<S700>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_DCBC_ClntFlw[9] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2933>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_DCDC_ClntFlw[9] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2934>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_EstAirflow_Max[20] =
{
    0.0F, 0.22F, 0.395F, 0.815F, 1.16F, 0.232F, 0.383F, 0.528F, 0.8605F, 1.16F,
    0.6133F, 0.699F, 0.789F, 1.052F, 1.329F, 1.0988F, 1.125F, 1.155F, 1.3255F,
    1.575F
} ;                                    /* Referenced by: '<S5515>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_FC_HTR_AirFlowRaw[56] =
{
    0.0F, 65.0F, 119.2F, 173.4F, 227.5F, 281.7F, 335.9F, 0.0F, 73.5F, 134.7F,
    196.0F, 257.2F, 318.4F, 379.7F, 0.0F, 84.1F, 154.2F, 224.2F, 294.3F, 364.3F,
    434.4F, 0.0F, 117.3F, 215.0F, 312.7F, 410.4F, 508.1F, 605.7F, 0.0F, 160.0F,
    293.2F, 426.4F, 559.7F, 692.9F, 826.1F, 0.0F, 195.1F, 357.5F, 520.0F, 682.5F,
    845.0F, 1007.4F, 0.0F, 247.7F, 454.1F, 660.4F, 866.7F, 1073.1F, 1279.4F,
    0.0F, 335.5F, 614.9F, 894.4F, 1173.8F, 1453.2F, 1732.7F
} ;                                    /* Referenced by: '<S863>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_FrontEDM_FlwTgt[7] =
{
    0.0F, 1025.0F, 1400.0F, 2050.0F, 4200.0F, 6500.0F, 8000.0F
} ;                                    /* Referenced by: '<S2883>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_FrontEDM_MinFlw[7] =
{
    0.0F, 1025.0F, 1400.0F, 2050.0F, 4200.0F, 6500.0F, 8000.0F
} ;                                    /* Referenced by: '<S2884>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_GEN_FlwTgt[7] =
{
    0.0F, 1025.0F, 1400.0F, 2050.0F, 4200.0F, 6500.0F, 8000.0F
} ;                                    /* Referenced by: '<S2885>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_GEN_MinFlw[7] =
{
    0.0F, 1025.0F, 1400.0F, 2050.0F, 4200.0F, 6500.0F, 8000.0F
} ;                                    /* Referenced by: '<S2886>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_GEN_PIM_FlwTgt[11] =
{
    0.0F, 0.05F, 0.1F, 0.15F, 0.2F, 0.25F, 0.3F, 0.35F, 0.4F, 0.45F, 0.5F
} ;                                    /* Referenced by: '<S2935>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_HT_AuxPmpFlw[7] =
{
    0.0F, 1025.0F, 1400.0F, 2050.0F, 4200.0F, 6500.0F, 8000.0F
} ;                                    /* Referenced by: '<S1928>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_HT_AuxPmpFlwForActvCool
    [35] =
{
    0.2175F, 0.2175F, 0.1864F, 0.1864F, 0.1553F, 0.1243F, 0.1243F, 0.2175F,
    0.2175F, 0.1864F, 0.1864F, 0.1553F, 0.1243F, 0.1243F, 0.2175F, 0.2175F,
    0.1864F, 0.1864F, 0.1553F, 0.1243F, 0.1243F, 0.2175F, 0.2175F, 0.2175F,
    0.2175F, 0.2175F, 0.2175F, 0.2175F, 0.2175F, 0.2175F, 0.2175F, 0.2175F,
    0.2175F, 0.2175F, 0.2175F
} ;                                    /* Referenced by: '<S1929>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_HeadPresAir_Flow[56] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 30.0F, 30.0F,
    30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F,
    40.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 60.0F, 60.0F, 60.0F,
    60.0F, 60.0F, 60.0F, 60.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F
} ;                                    /* Referenced by: '<S2822>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_HeadPres_LTPsvPmpFlw[7] =
{
    0.0F, 1025.0F, 1400.0F, 2050.0F, 4200.0F, 6500.0F, 8000.0F
} ;                                    /* Referenced by: '<S2936>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_HeatPumpAir_Flow[56] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 30.0F, 30.0F,
    30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F,
    40.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 60.0F, 60.0F, 60.0F,
    60.0F, 60.0F, 60.0F, 60.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F
} ;                                    /* Referenced by: '<S2823>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_IDCM_FlwTgt[9] =
{
    0.02F, 0.02F, 0.02F, 0.03F, 0.03F, 0.04F, 0.05F, 0.08F, 0.13F
} ;                                    /* Referenced by: '<S2937>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_dV_LTRVlv_RadAirFlowRate_LookUp[13] =
{
    0.0F, 25.0F, 50.0F, 75.0F, 100.0F, 125.0F, 150.0F, 175.0F, 200.0F, 225.0F,
    250.0F, 275.0F, 300.0F
} ;                                    /* Referenced by: '<S2790>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_LTR_AirFlowRaw[56] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 30.0F, 30.0F,
    30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F,
    40.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 60.0F, 60.0F, 60.0F,
    60.0F, 60.0F, 60.0F, 60.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F
} ;                                    /* Referenced by: '<S2824>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_MGU_ClntPumpFlw[56] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 30.0F, 30.0F,
    30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F,
    40.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 60.0F, 60.0F, 60.0F,
    60.0F, 60.0F, 60.0F, 60.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F
} ;                                    /* Referenced by: '<S2825>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_MaxAirFlw_HiTempRad[5] =
{
    1700.0F, 1900.0F, 2300.0F, 2800.0F, 3400.0F
} ;                                    /* Referenced by: '<S5524>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_MaxAirFlw_LoTempRad[5] =
{
    1700.0F, 1900.0F, 2300.0F, 2800.0F, 3400.0F
} ;                                    /* Referenced by: '<S5525>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_MaxAirFlw_OHX[5] =
{
    1700.0F, 1900.0F, 2300.0F, 2800.0F, 3400.0F
} ;                                    /* Referenced by: '<S5526>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_MaxHTRAirflow[5] =
{
    1700.0F, 1900.0F, 2300.0F, 2800.0F, 3400.0F
} ;                                    /* Referenced by: '<S864>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_MinAchvblArflwEst_Ohx[42]
    =
{
    0.0F, 0.94F, 3.29F, 7.05F, 10.81F, 15.51F, 0.0F, 14.1F, 39.48F, 83.66F,
    127.37F, 170.61F, 0.0F, 22.56F, 63.92F, 133.95F, 205.39F, 275.89F, 0.0F,
    52.17F, 156.04F, 334.17F, 515.59F, 691.37F, 0.0F, 65.8F, 205.39F, 452.61F,
    692.31F, 936.71F, 0.0F, 80.84F, 271.19F, 610.53F, 949.4F, 1297.2F, 0.0F,
    85.54F, 295.63F, 672.57F, 1055.62F, 1433.5F
} ;                                    /* Referenced by: '<S5516>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_OBCM_ClntFlw[9] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2938>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_P1Motor_AirFlowRaw[56] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 20.0F, 30.0F, 30.0F,
    30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F, 40.0F,
    40.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 50.0F, 60.0F, 60.0F, 60.0F,
    60.0F, 60.0F, 60.0F, 60.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F
} ;                                    /* Referenced by: '<S2826>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_PCU_ClntFlw[9] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2939>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_PIM_Front_ClntFlw[9] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2940>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_PIM_Rear_ClntFlw[9] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2941>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_PerWp_HT_AuxPmpFlow[7] =
{
    0.0F, 1025.0F, 1400.0F, 2050.0F, 4200.0F, 6500.0F, 8000.0F
} ;                                    /* Referenced by: '<S1914>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_RearEDM_FlwTgt[7] =
{
    0.0F, 1025.0F, 1400.0F, 2050.0F, 4200.0F, 6500.0F, 8000.0F
} ;                                    /* Referenced by: '<S2887>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_dV_RearEDM_MinFlw[7] =
{
    0.0F, 1025.0F, 1400.0F, 2050.0F, 4200.0F, 6500.0F, 8000.0F
} ;                                    /* Referenced by: '<S2888>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_dV_TransOilCooler_ClntFlw_Front_EDM[64] =
{
    1.0F, 2.0F, 3.0F, 4.0F, 5.0F, 6.0F, 7.0F, 8.0F, 9.0F, 10.0F, 11.0F, 12.0F,
    13.0F, 14.0F, 15.0F, 16.0F, 17.0F, 18.0F, 19.0F, 20.0F, 21.0F, 22.0F, 23.0F,
    24.0F, 25.0F, 26.0F, 27.0F, 28.0F, 29.0F, 30.0F, 31.0F, 32.0F, 33.0F, 34.0F,
    35.0F, 36.0F, 37.0F, 38.0F, 39.0F, 40.0F, 41.0F, 42.0F, 43.0F, 44.0F, 45.0F,
    46.0F, 47.0F, 48.0F, 49.0F, 50.0F, 51.0F, 52.0F, 53.0F, 54.0F, 55.0F, 56.0F,
    57.0F, 58.0F, 59.0F, 60.0F, 61.0F, 62.0F, 63.0F, 64.0F
} ;                                    /* Referenced by: '<S2942>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_dV_TransOilCooler_ClntFlw_GEN[64] =
{
    1.0F, 2.0F, 3.0F, 4.0F, 5.0F, 6.0F, 7.0F, 8.0F, 9.0F, 10.0F, 11.0F, 12.0F,
    13.0F, 14.0F, 15.0F, 16.0F, 17.0F, 18.0F, 19.0F, 20.0F, 21.0F, 22.0F, 23.0F,
    24.0F, 25.0F, 26.0F, 27.0F, 28.0F, 29.0F, 30.0F, 31.0F, 32.0F, 33.0F, 34.0F,
    35.0F, 36.0F, 37.0F, 38.0F, 39.0F, 40.0F, 41.0F, 42.0F, 43.0F, 44.0F, 45.0F,
    46.0F, 47.0F, 48.0F, 49.0F, 50.0F, 51.0F, 52.0F, 53.0F, 54.0F, 55.0F, 56.0F,
    57.0F, 58.0F, 59.0F, 60.0F, 61.0F, 62.0F, 63.0F, 64.0F
} ;                                    /* Referenced by: '<S2943>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_dV_TransOilCooler_ClntFlw_Rear_EDM[64] =
{
    1.0F, 2.0F, 3.0F, 4.0F, 5.0F, 6.0F, 7.0F, 8.0F, 9.0F, 10.0F, 11.0F, 12.0F,
    13.0F, 14.0F, 15.0F, 16.0F, 17.0F, 18.0F, 19.0F, 20.0F, 21.0F, 22.0F, 23.0F,
    24.0F, 25.0F, 26.0F, 27.0F, 28.0F, 29.0F, 30.0F, 31.0F, 32.0F, 33.0F, 34.0F,
    35.0F, 36.0F, 37.0F, 38.0F, 39.0F, 40.0F, 41.0F, 42.0F, 43.0F, 44.0F, 45.0F,
    46.0F, 47.0F, 48.0F, 49.0F, 50.0F, 51.0F, 52.0F, 53.0F, 54.0F, 55.0F, 56.0F,
    57.0F, 58.0F, 59.0F, 60.0F, 61.0F, 62.0F, 63.0F, 64.0F
} ;                                    /* Referenced by: '<S2944>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_dV_WhlSpdDiff_OilFlwRtDiffTgt1[5] =
{
    0.0F, 3.0F, 6.0F, 9.0F, 12.0F
} ;                                    /* Referenced by: '<S685>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_dV_WhlSpdDiff_OilFlwRtDiffTgt2[5] =
{
    0.0F, 3.0F, 6.0F, 9.0F, 12.0F
} ;                                    /* Referenced by: '<S707>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_BattRadAirflw_Ki[6] =
{
    10.0000095F, 10.00002F, 10.0000296F, 10.0000401F, 10.0000496F, 10.0000601F
} ;                                    /* Referenced by: '<S3121>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_BattRadAirflw_Kp[6] =
{
    10.0000095F, 10.00002F, 10.0000296F, 10.0000401F, 10.0000496F, 10.0000601F
} ;                                    /* Referenced by: '<S3122>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_DFuCellWaPmpDelta_T[9] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S918>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_DHiTRegFuCellDft_M[63] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S975>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_DHiTRegFuCell_M[63] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S972>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_ElVlv3WayFuCellPosnLnr_T
    [18] =
{
    -10.0F, 3.0F, 7.8F, 20.7F, 37.2F, 48.8F, 58.8F, 68.0F, 75.6F, 82.3F, 88.0F,
    92.0F, 95.1F, 97.4F, 98.7F, 99.7F, 100.7F, 112.0F
} ;                                    /* Referenced by: '<S961>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FCAirflw_Ki[24] =
{
    10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F
} ;                                    /* Referenced by: '<S885>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FCAirflw_Kp[24] =
{
    10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F, 10.0F,
    10.0F, 10.0F
} ;                                    /* Referenced by: '<S886>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FCPropVlv_Ki[24] =
{
    -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F,
    -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F,
    -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F
} ;                                    /* Referenced by: '<S780>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FCPropVlv_Kp[24] =
{
    -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F,
    -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F,
    -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F, -100.0F
} ;                                    /* Referenced by: '<S781>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FEDMheatEstm_Alpha1[2] =
{
    0.000861379376F, 0.0012150344F
} ;                                    /* Referenced by: '<S2433>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FEDMheatEstm_Alpha2[2] =
{
    4.43458557E-5F, 6.15716E-5F
} ;                                    /* Referenced by: '<S2434>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FEDMheatEstm_Alpha3[2] =
{
    22.1588135F, 26.9984512F
} ;                                    /* Referenced by: '<S2435>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FEDMheatEstm_Alpha4[2] =
{
    18.5908756F, 53.9812393F
} ;                                    /* Referenced by: '<S2436>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FEDMheatEstm_Alpha5[2] =
{
    4.93969107F, 4.60833263F
} ;                                    /* Referenced by: '<S2437>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FacPHiTRegFuCell_T[5] =
{
    2.0F, 1.35F, 1.0F, 0.75F, 0.5F
} ;                                    /* Referenced by: '<S971>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FanDTerm_ClntErr[3] =
{
    25.0F, 25.0F, 25.0F
} ;                                    /* Referenced by: '<S5548>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FanDTerm_PressErr[3] =
{
    25.0F, 25.0F, 25.0F
} ;                                    /* Referenced by: '<S5573>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FanITerm_ClntErr[3] =
{
    50.0F, 50.0F, 50.0F
} ;                                    /* Referenced by: '<S5549>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FanITerm_PressErr[3] =
{
    50.0F, 50.0F, 50.0F
} ;                                    /* Referenced by: '<S5574>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FanPTerm_ClntErr[3] =
{
    500.0F, 500.0F, 500.0F
} ;                                    /* Referenced by: '<S5550>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FanPTerm_PressErr[3] =
{
    500.0F, 500.0F, 500.0F
} ;                                    /* Referenced by: '<S5575>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FlowCorHiTFuCellMixPt_T
    [11] =
{
    1.0F, 0.9F, 0.85F, 0.8F, 75.0F, 0.72F, 0.7F, 0.685F, 0.675F, 0.665F, 0.66F
} ;                                    /* Referenced by: '<S984>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_FuCellEfcMaxLimThStep_T[8]
    =
{
    0.7F, 0.85F, 0.95F, 1.0F, 1.0F, 0.95F, 0.85F, 0.65F
} ;                                    /* Referenced by: '<S1052>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_HeatTranCoefOutRadHiT1_M
    [56] =
{
    0.0F, 0.008F, 0.016F, 0.024F, 0.032F, 0.04F, 0.048F, 0.064F, 0.072F, 0.088F,
    0.096F, 0.112F, 0.12F, 0.136F, 0.144F, 0.16F, 0.152F, 0.168F, 0.184F, 0.2F,
    0.216F, 0.232F, 0.248F, 0.264F, 0.256F, 0.272F, 0.296F, 0.312F, 0.336F,
    0.352F, 0.368F, 0.392F, 0.496F, 0.52F, 0.544F, 0.576F, 0.6F, 0.624F, 0.656F,
    0.68F, 0.672F, 0.704F, 0.728F, 0.76F, 0.792F, 0.824F, 0.848F, 0.88F, 0.808F,
    0.84F, 0.872F, 0.904F, 0.944F, 0.976F, 1.008F, 1.04F
} ;                                    /* Referenced by: '<S1012>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_HeatTranCoefOutRadHiT2_M
    [56] =
{
    0.514F, 1.285F, 1.9275F, 2.056F, 2.1845F, 2.313F, 2.4415F, 2.57F, 0.386F,
    0.956F, 1.4475F, 1.544F, 1.6405F, 1.737F, 1.8335F, 1.93F, 0.332F, 0.83F,
    1.245F, 1.328F, 1.411F, 1.494F, 1.577F, 1.66F, 0.274F, 0.685F, 1.0275F,
    1.096F, 1.1645F, 1.233F, 1.3015F, 1.37F, 0.24F, 0.6F, 0.9F, 0.96F, 1.02F,
    1.08F, 1.14F, 1.2F, 0.216F, 0.54F, 0.81F, 0.864F, 0.918F, 0.972F, 1.026F,
    1.08F, 0.192F, 0.48F, 0.72F, 0.768F, 0.816F, 0.864F, 0.912F, 0.96F
} ;                                    /* Referenced by: '<S1013>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_HeatTranCoefOutRadHiT3_M
    [56] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.14F, 0.16F, 0.18F, 0.19F,
    0.2F, 0.21F, 0.23F, 0.26F, 0.28F, 0.32F, 0.36F, 0.38F, 0.4F, 0.43F, 0.46F,
    0.52F, 0.56F, 0.64F, 0.72F, 0.76F, 1.1F, 0.86F, 0.92F, 1.04F, 0.77F, 0.88F,
    0.99F, 1.05F, 1.35F, 1.18F, 1.27F, 1.43F, 0.95F, 1.08F, 1.22F, 1.28F, 1.35F,
    1.44F, 1.55F, 1.76F, 1.12F, 1.28F, 1.44F, 1.52F, 1.6F, 1.71F, 1.84F, 2.08F
} ;                                    /* Referenced by: '<S1014>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_HiTSpdFanReq_M[63] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 55.0F, 30.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 88.0F, 55.0F, 20.0F, 0.0F, 0.0F, 0.0F, 0.0F, 100.0F, 80.0F,
    42.0F, 0.0F, 0.0F, 0.0F, 0.0F, 100.0F, 100.0F, 100.0F, 44.0F, 0.0F, 0.0F,
    0.0F, 100.0F, 100.0F, 100.0F, 100.0F, 47.0F, 0.0F, 0.0F, 100.0F, 100.0F,
    100.0F, 100.0F, 100.0F, 25.0F, 0.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F, 0.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F
} ;                                    /* Referenced by: '<S1076>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_HiTSpdFanSysReqTrimMin_M
    [49] =
{
    100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F, 100.0F, 100.0F, 100.0F
} ;                                    /* Referenced by: '<S1086>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_HiTSpdFanTRadOutMax_T[5] =
{
    30.0F, 40.0F, 60.0F, 100.0F, 100.0F
} ;                                    /* Referenced by: '<S1073>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_HiTSpdFanTRadOutMin_T[5] =
{
    100.0F, 80.0F, 50.0F, 20.0F, 0.0F
} ;                                    /* Referenced by: '<S1074>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_IFuCellHiTHEXTInTar_T[9] =
{
    0.01F, 0.04F, 0.03F, 0.02F, 0.02F, 0.02F, 0.02F, 0.04F, 0.01F
} ;                                    /* Referenced by: '<S1127>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_IFuCellWaPmpDelta_T[9] =
{
    0.3F, 0.3F, 0.3F, 0.3F, 0.3F, 0.3F, 0.3F, 0.3F, 0.3F
} ;                                    /* Referenced by: '<S919>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_IHiTRegFuCellDft_M[63] =
{
    0.0F, 0.08F, 0.1F, 0.125F, 0.0F, 0.125F, 0.1F, 0.08F, 0.0F, 0.0F, 0.08F,
    0.1F, 0.125F, 0.0F, 0.125F, 0.1F, 0.08F, 0.0F, 0.0F, 0.08F, 0.1F, 0.125F,
    0.0F, 0.125F, 0.1F, 0.08F, 0.0F, 0.0F, 0.08F, 0.1F, 0.125F, 0.0F, 0.125F,
    0.1F, 0.08F, 0.0F, 0.0F, 0.08F, 0.1F, 0.125F, 0.0F, 0.125F, 0.1F, 0.08F,
    0.0F, 0.0F, 0.08F, 0.1F, 0.125F, 0.0F, 0.125F, 0.1F, 0.08F, 0.0F, 0.0F,
    0.08F, 0.1F, 0.125F, 0.0F, 0.125F, 0.1F, 0.08F, 0.0F
} ;                                    /* Referenced by: '<S976>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_IHiTRegFuCell_M[63] =
{
    0.0F, 0.08F, 0.1F, 0.125F, 0.0F, 0.125F, 0.1F, 0.08F, 0.0F, 0.0F, 0.08F,
    0.1F, 0.125F, 0.0F, 0.125F, 0.1F, 0.08F, 0.0F, 0.0F, 0.08F, 0.1F, 0.125F,
    0.0F, 0.125F, 0.1F, 0.08F, 0.0F, 0.0F, 0.08F, 0.1F, 0.125F, 0.0F, 0.125F,
    0.1F, 0.08F, 0.0F, 0.0F, 0.08F, 0.1F, 0.125F, 0.0F, 0.125F, 0.1F, 0.08F,
    0.0F, 0.0F, 0.08F, 0.1F, 0.125F, 0.0F, 0.125F, 0.1F, 0.08F, 0.0F, 0.0F,
    0.08F, 0.1F, 0.125F, 0.0F, 0.125F, 0.1F, 0.08F, 0.0F
} ;                                    /* Referenced by: '<S973>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_k_LoopPriorty_BTCLWsteHeatRcvryHP[36] =
{
    82.0F, 82.0F, 82.0F, 82.0F, 82.0F, 80.0F, 82.0F, 82.0F, 82.0F, 82.0F, 82.0F,
    80.0F, 82.0F, 82.0F, 82.0F, 82.0F, 82.0F, 80.0F, 82.0F, 82.0F, 82.0F, 82.0F,
    82.0F, 80.0F, 90.0F, 90.0F, 90.0F, 90.0F, 90.0F, 90.0F, 90.0F, 90.0F, 90.0F,
    90.0F, 90.0F, 90.0F
} ;                                    /* Referenced by: '<S5065>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_k_LoopPriorty_BattActvPsvHeat[24] =
{
    100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F
} ;                                    /* Referenced by: '<S5050>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_k_LoopPriorty_CabActvPsvHeat[24] =
{
    100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F
} ;                                    /* Referenced by: '<S5060>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_k_LoopPriorty_CabActvPsvHeat_HP[36] =
{
    100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F,
    100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F, 100.0F
} ;                                    /* Referenced by: '<S5061>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_LpfSpdAirHiTSysReqDec_T[7]
    =
{
    360.0F, 347.1F, 339.0F, 288.0F, 210.0F, 68.0F, 66.0F
} ;                                    /* Referenced by: '<S1087>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_LpfSpdAirHiTSysReqInc_T[7]
    =
{
    5.0F, 7.0F, 9.0F, 11.0F, 13.0F, 14.0F, 15.0F
} ;                                    /* Referenced by: '<S1088>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_PFuCellWaPmpDelta_T[8] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S920>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_PHiTRegFuCellDft_M[63] =
{
    20.0F, 10.0F, 7.5F, 2.5F, 0.0F, 2.5F, 7.5F, 10.0F, 20.0F, 20.0F, 10.0F, 7.5F,
    2.5F, 0.0F, 2.5F, 7.5F, 10.0F, 20.0F, 20.0F, 10.0F, 7.5F, 2.5F, 0.0F, 2.5F,
    7.5F, 10.0F, 20.0F, 20.0F, 10.0F, 7.5F, 2.5F, 0.0F, 2.5F, 7.5F, 10.0F, 20.0F,
    20.0F, 10.0F, 7.5F, 2.5F, 0.0F, 2.5F, 7.5F, 10.0F, 20.0F, 20.0F, 10.0F, 7.5F,
    2.5F, 0.0F, 2.5F, 7.5F, 10.0F, 20.0F, 20.0F, 10.0F, 7.5F, 2.5F, 0.35F, 2.5F,
    7.5F, 10.0F, 20.0F
} ;                                    /* Referenced by: '<S977>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_PHiTRegFuCell_M[63] =
{
    20.0F, 10.0F, 7.5F, 2.5F, 0.0F, 2.5F, 7.5F, 10.0F, 20.0F, 20.0F, 10.0F, 7.5F,
    2.5F, 0.0F, 2.5F, 7.5F, 10.0F, 20.0F, 20.0F, 10.0F, 7.5F, 2.5F, 0.0F, 2.5F,
    7.5F, 10.0F, 20.0F, 20.0F, 10.0F, 7.5F, 2.5F, 0.0F, 2.5F, 7.5F, 10.0F, 20.0F,
    20.0F, 10.0F, 7.5F, 2.5F, 0.0F, 2.5F, 7.5F, 10.0F, 20.0F, 20.0F, 10.0F, 7.5F,
    2.5F, 0.0F, 2.5F, 7.5F, 10.0F, 20.0F, 20.0F, 10.0F, 7.5F, 2.5F, 0.35F, 2.5F,
    7.5F, 10.0F, 20.0F
} ;                                    /* Referenced by: '<S974>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_PwrFuCellMaxLimThStep_M
    [16] =
{
    -0.01F, -0.01F, -0.01F, -0.01F, -0.01F, -0.01F, -0.01F, -0.01F, 0.01F, 0.01F,
    0.01F, 0.01F, 0.01F, 0.01F, 0.015F, 0.02F
} ;                                    /* Referenced by: '<S1053>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_REDMheatEstm_Alpha1[2] =
{
    0.000861379376F, 0.0012150344F
} ;                                    /* Referenced by: '<S2438>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_REDMheatEstm_Alpha2[2] =
{
    4.43458557E-5F, 6.15716E-5F
} ;                                    /* Referenced by: '<S2439>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_REDMheatEstm_Alpha3[2] =
{
    22.1588135F, 26.9984512F
} ;                                    /* Referenced by: '<S2440>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_REDMheatEstm_Alpha4[2] =
{
    18.5908756F, 53.9812393F
} ;                                    /* Referenced by: '<S2441>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_REDMheatEstm_Alpha5[2] =
{
    4.93969107F, 4.60833263F
} ;                                    /* Referenced by: '<S2442>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_SpdAirHiTDown_T[9] =
{
    0.0F, 0.0F, 0.2F, 0.4F, 0.45F, 0.5F, 0.55F, 0.6F, 0.65F
} ;                                    /* Referenced by: '<S1077>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_SpdAirHiTSysReq_M[63] =
{
    0.125F, 0.085F, 0.04F, 0.01F, 0.0F, 0.0F, 0.0F, 0.155F, 0.115F, 0.065F,
    0.015F, 0.0F, 0.0F, 0.0F, 0.25F, 0.22F, 0.15F, 0.07F, 0.03F, 0.005F, 0.0F,
    0.45F, 0.45F, 0.35F, 0.185F, 0.095F, 0.02F, 0.0F, 1.0F, 1.0F, 0.7F, 0.285F,
    0.12F, 0.04F, 0.0F, 1.0F, 1.0F, 0.77F, 0.375F, 0.18F, 0.06F, 0.0F, 1.0F,
    1.0F, 1.0F, 0.585F, 0.35F, 0.25F, 0.25F, 1.0F, 1.0F, 1.0F, 1.0F, 0.75F, 0.6F,
    0.6F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S1089>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_SpdAirHiTUp_T[9] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.3F, 0.3F, 0.4F, 0.4F, 0.5F
} ;                                    /* Referenced by: '<S1078>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_TDifCoFuCellHiTOutFil_T[7]
    =
{
    1.0F, 1.0F, 0.32F, 0.16F, 0.08F, 0.04F, 0.001F
} ;                                    /* Referenced by: '<S1015>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_TDifWaOutRadHiTFil_T[7] =
{
    0.1F, 0.1F, 0.16F, 0.16F, 0.08F, 0.04F, 0.001F
} ;                                    /* Referenced by: '<S1016>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_WaPmpFuCellMin_T[5] =
{
    30.0F, 65.0F, 65.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S921>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KtTHMR_k_WaPmpFuCellPwrMaxLimThReq_M[30] =
{
    0.0F, 27.0F, 100.0F, 100.0F, 100.0F, 100.0F, 0.0F, 27.0F, 100.0F, 100.0F,
    100.0F, 100.0F, 0.0F, 27.0F, 100.0F, 100.0F, 100.0F, 100.0F, 0.0F, 27.0F,
    93.0F, 100.0F, 100.0F, 100.0F, 0.0F, 27.0F, 53.0F, 80.0F, 100.0F, 100.0F
} ;                                    /* Referenced by: '<S922>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_WaPmpFuCellReg_M[56] =
{
    64.0F, 70.0F, 78.0F, 85.0F, 93.0F, 94.0F, 94.0F, 94.0F, 53.0F, 59.0F, 66.0F,
    74.0F, 81.0F, 90.0F, 94.0F, 94.0F, 44.0F, 49.0F, 56.0F, 64.0F, 71.0F, 81.0F,
    90.0F, 94.0F, 36.0F, 41.0F, 49.0F, 56.0F, 64.0F, 74.0F, 83.0F, 93.0F, 29.0F,
    35.0F, 43.0F, 50.0F, 58.0F, 66.0F, 76.0F, 85.0F, 25.0F, 30.0F, 38.0F, 45.0F,
    53.0F, 63.0F, 71.0F, 81.0F, 21.0F, 28.0F, 35.0F, 43.0F, 50.0F, 59.0F, 69.0F,
    78.0F
} ;                                    /* Referenced by: '<S923>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_WaPmpFuCellReq_M[56] =
{
    0.0F, 10.0F, 15.0F, 30.0F, 45.0F, 100.0F, 100.0F, 100.0F, 0.0F, 10.0F, 15.0F,
    30.0F, 45.0F, 85.0F, 95.0F, 100.0F, 0.0F, 10.0F, 15.0F, 30.0F, 45.0F, 60.0F,
    85.0F, 100.0F, 0.0F, 10.0F, 15.0F, 30.0F, 45.0F, 60.0F, 85.0F, 100.0F, 0.0F,
    10.0F, 15.0F, 30.0F, 45.0F, 60.0F, 85.0F, 100.0F, 0.0F, 10.0F, 15.0F, 30.0F,
    45.0F, 60.0F, 85.0F, 100.0F, 0.0F, 10.0F, 15.0F, 30.0F, 45.0F, 60.0F, 85.0F,
    100.0F
} ;                                    /* Referenced by: '<S924>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_k_WaPmpFuCellTDeltaReq_M[30]
    =
{
    0.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F, 0.0F, 20.0F, 40.0F, 60.0F, 80.0F,
    100.0F, 0.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F, 0.0F, 20.0F, 40.0F, 60.0F,
    80.0F, 100.0F, 0.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S925>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_n_AirHiTNomReq_M[56] =
{
    0.45F, 0.45F, 0.45F, 0.45F, 0.45F, 0.45F, 0.91F, 0.91F, 0.45F, 0.45F, 0.45F,
    0.45F, 0.45F, 0.91F, 0.91F, 1.09F, 0.45F, 0.45F, 0.45F, 0.45F, 0.91F, 0.91F,
    1.1F, 1.1F, 0.45F, 0.45F, 0.45F, 0.91F, 0.91F, 0.91F, 1.1F, 2.55F, 0.45F,
    0.45F, 0.45F, 0.91F, 0.91F, 1.1F, 2.55F, 3.35F, 0.45F, 0.45F, 0.45F, 0.91F,
    1.09F, 1.1F, 2.55F, 4.1F, 0.45F, 0.45F, 0.45F, 0.91F, 1.09F, 1.1F, 3.28F,
    4.11F
} ;                                    /* Referenced by: '<S1079>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_n_EngSpdInc_ReqHysUp[8] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 700.0F, 900.0F, 1600.0F, 2000.0F
} ;                                    /* Referenced by: '<S2855>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_n_HghSOC_LwTmp_BattRng[36] =
{
    0.0F, 0.0F, 0.0F, 10.0F, 10.0F, 10.0F, 0.0F, 0.0F, 0.0F, 10.0F, 10.0F, 10.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S1727>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_n_P1Motor_EngSpdInc[49] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 100.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 200.0F, 100.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 200.0F, 100.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 200.0F, 200.0F, 100.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    400.0F, 300.0F, 200.0F, 100.0F, 0.0F, 0.0F, 0.0F, 500.0F, 400.0F, 300.0F,
    200.0F, 100.0F, 100.0F, 0.0F
} ;                                    /* Referenced by: '<S2856>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_p_TgtPSuc[14] =
{
    640.5F, 770.5F, 916.9F, 1080.9F, 1139.7F, 1200.7F, 1263.9F, 1329.4F, 1397.2F,
    1467.5F, 1540.2F, 1615.4F, 1693.1F, 1773.6F
} ;                                    /* Referenced by: '<S5563>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_p_TgtPres[14] =
{
    640.5F, 770.5F, 916.9F, 1080.9F, 1139.7F, 1200.7F, 1263.9F, 1329.4F, 1397.2F,
    1467.5F, 1540.2F, 1615.4F, 1693.1F, 1773.6F
} ;                                    /* Referenced by: '<S5576>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_r_BattCabPrioRatioFrHTCV[5]
    =
{
    0.5F, 0.5F, 0.5F, 0.5F, 0.5F
} ;                                    /* Referenced by: '<S1395>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_r_BattCabPrioRatioFrHTLVlv
    [5] =
{
    0.1F, 0.3F, 0.5F, 0.7F, 0.9F
} ;                                    /* Referenced by:
                                        * '<S1987>/Vector'
                                        * '<S2314>/Vector'
                                        */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_r_EnblBattCabPrty_BlwrAmb
    [48] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S419>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_r_MoreToBatt_SOC[8] =
{
    0.6F, 0.7F, 0.7F, 0.8F, 0.8F, 0.8F, 0.9F, 0.9F
} ;                                    /* Referenced by: '<S1201>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_r_MoreToCab_SOC[8] =
{
    0.1F, 0.2F, 0.2F, 0.3F, 0.3F, 0.4F, 0.4F, 0.4F
} ;                                    /* Referenced by: '<S1204>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_r_MoreToCab_SOC_Opt[8] =
{
    0.1F, 0.2F, 0.2F, 0.3F, 0.3F, 0.4F, 0.4F, 0.4F
} ;                                    /* Referenced by: '<S1192>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_t_AmbTempBasedPsvDuration[7]
    =
{
    0.5F, 0.5F, 0.5F, 10.0F, 15.0F, 20.0F, 30.0F
} ;                                    /* Referenced by: '<S4878>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_t_EngTurnOff_TimDely[8] =
{
    0.0F, 150.0F, 300.0F, 350.0F, 450.0F, 600.0F, 750.0F, 900.0F
} ;                                    /* Referenced by: '<S1589>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KtTHMR_t_FuCellPwrLimTh_M[14] =
{
    0.4F, 0.5F, 0.5F, 0.6F, 0.8F, 1.6F, 2.0F, 1.6F, 1.4F, 1.2F, 1.0F, 0.8F, 0.8F,
    0.8F
} ;                                    /* Referenced by: '<S1054>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_Cf_ClntFlwsConv_EDMheatEstm[8] =
{
    -40.0F, -20.0F, 0.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S2427>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_Cf_FEDM_OilFlwConv_EDMheatEstm[8] =
{
    -40.0F, -20.0F, 0.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S2428>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_Cf_REDM_OilFlwConv_EDMheatEstm[8] =
{
    -40.0F, -20.0F, 0.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S2429>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_CoolantHeatCap[6] =
{
    -10.0F, 10.0F, 30.0F, 50.0F, 70.0F, 90.0F
} ;                                    /* Referenced by:
                                        * '<S742>/Vector'
                                        * '<S2107>/Vector'
                                        * '<S2430>/Vector'
                                        * '<S3111>/Vector'
                                        */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_KiMtrACon[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3443>/Vector'
                                        * '<S3462>/Vector'
                                        * '<S3481>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_KiMtrBCon[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3509>/Vector'
                                        * '<S3524>/Vector'
                                        * '<S3539>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_KiMtrCCon[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3571>/Vector'
                                        * '<S3582>/Vector'
                                        * '<S3597>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_KpMtrACon[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3444>/Vector'
                                        * '<S3463>/Vector'
                                        * '<S3482>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_KpMtrBCon[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3510>/Vector'
                                        * '<S3525>/Vector'
                                        * '<S3540>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_KpMtrCCon[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3572>/Vector'
                                        * '<S3583>/Vector'
                                        * '<S3598>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MaxFCSDerateFctr[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by: '<S822>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MaxMtrAConTemp1[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3431>/Vector'
                                        * '<S3448>/Vector'
                                        * '<S3467>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MaxMtrAConTemp2[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3432>/Vector'
                                        * '<S3449>/Vector'
                                        * '<S3468>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MaxMtrAConTemp3[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3433>/Vector'
                                        * '<S3450>/Vector'
                                        * '<S3469>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MaxMtrAConTemp4[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3434>/Vector'
                                        * '<S3451>/Vector'
                                        * '<S3470>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MaxMtrBConTemp1[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3501>/Vector'
                                        * '<S3514>/Vector'
                                        * '<S3529>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MaxMtrBConTemp2[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3502>/Vector'
                                        * '<S3515>/Vector'
                                        * '<S3530>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MaxMtrCConTemp1[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3561>/Vector'
                                        * '<S3574>/Vector'
                                        * '<S3587>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MaxMtrCConTemp2[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3562>/Vector'
                                        * '<S3575>/Vector'
                                        * '<S3588>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MinFCSDerateFctr[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by: '<S823>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MinMtrAConTemp1[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3435>/Vector'
                                        * '<S3452>/Vector'
                                        * '<S3471>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MinMtrAConTemp2[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3436>/Vector'
                                        * '<S3453>/Vector'
                                        * '<S3472>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MinMtrAConTemp3[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3437>/Vector'
                                        * '<S3454>/Vector'
                                        * '<S3473>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MinMtrAConTemp4[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3438>/Vector'
                                        * '<S3455>/Vector'
                                        * '<S3474>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MinMtrBConTemp1[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3503>/Vector'
                                        * '<S3516>/Vector'
                                        * '<S3531>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MinMtrBConTemp2[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3504>/Vector'
                                        * '<S3517>/Vector'
                                        * '<S3532>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MinMtrCConTemp1[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3563>/Vector'
                                        * '<S3576>/Vector'
                                        * '<S3589>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_MinMtrCConTemp2[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by:
                                        * '<S3564>/Vector'
                                        * '<S3577>/Vector'
                                        * '<S3590>/Vector'
                                        */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_Min_HtrPwr_Ki[6] =
{
    -40.0F, -20.0F, 0.0F, 20.0F, 40.0F, 60.0F
} ;                                    /* Referenced by: '<S1252>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_Min_HtrPwr_Kp[6] =
{
    -40.0F, -20.0F, 0.0F, 20.0F, 40.0F, 60.0F
} ;                                    /* Referenced by: '<S1253>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_Reg_HtrPwr_Ki_ECO[6] =
{
    -10.0F, -5.0F, 0.0F, 20.0F, 40.0F, 60.0F
} ;                                    /* Referenced by: '<S1283>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_Reg_HtrPwr_Ki_HPM[6] =
{
    -40.0F, -20.0F, 0.0F, 20.0F, 40.0F, 60.0F
} ;                                    /* Referenced by: '<S1284>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_Reg_HtrPwr_Ki_HPM_ECO[6] =
{
    -10.0F, -5.0F, 0.0F, 20.0F, 40.0F, 60.0F
} ;                                    /* Referenced by: '<S1285>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_Reg_HtrPwr_Ki_NM[6] =
{
    -10.0F, -5.0F, 0.0F, 20.0F, 40.0F, 60.0F
} ;                                    /* Referenced by: '<S1286>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_Reg_HtrPwr_Kp_ECO[6] =
{
    -10.0F, -5.0F, 0.0F, 20.0F, 40.0F, 60.0F
} ;                                    /* Referenced by: '<S1287>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_Reg_HtrPwr_Kp_HPM[6] =
{
    -40.0F, -20.0F, 0.0F, 20.0F, 40.0F, 60.0F
} ;                                    /* Referenced by: '<S1288>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_Reg_HtrPwr_Kp_HPM_ECO[6] =
{
    -10.0F, -5.0F, 0.0F, 20.0F, 40.0F, 60.0F
} ;                                    /* Referenced by: '<S1289>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_K_Reg_HtrPwr_Kp_NM[6] =
{
    -10.0F, -5.0F, 0.0F, 20.0F, 40.0F, 60.0F
} ;                                    /* Referenced by: '<S1290>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_P_BattHeatPwrNeed_PerWup[8]
    =
{
    0.001F, 5.0F, 10.0F, 15.0F, 20.0F, 25.0F, 30.0F, 35.0F
} ;                                    /* Referenced by: '<S1239>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_P_CabAirHtrPwrTgt[9] =
{
    0.01F, 10.0F, 20.0F, 30.0F, 50.0F, 70.0F, 90.0F, 110.0F, 127.0F
} ;                                    /* Referenced by: '<S1261>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_P_CabinPwrNeed_BlwrFlowMin
    [9] =
{
    -40.0F, -20.0F, 0.001F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F, 120.0F
} ;                                    /* Referenced by: '<S1254>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_P_CabinPwrNeed_LookUp[8] =
{
    0.001F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F, 120.0F, 140.0F
} ;                                    /* Referenced by: '<S1265>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_P_ECHWishdPowerLimInit_ECT
    [6] =
{
    0.001F, 20.0F, 40.0F, 60.0F, 80.0F, 90.0F
} ;                                    /* Referenced by: '<S1787>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_P_ECH_HtrPwrTgt_FuelEcnmy
    [10] =
{
    -40.0F, -20.0F, 0.001F, 10.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F, 120.0F
} ;                                    /* Referenced by: '<S1641>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_P_EDU_Heat_Loss[4] =
{
    0.0F, 30.0F, 60.0F, 100.0F
} ;                                    /* Referenced by: '<S2446>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_P_EngPwrWasteHVACEcoModeHTSOV[8] =
{
    0.001F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F, 120.0F, 140.0F
} ;                                    /* Referenced by: '<S1714>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_P_EngPwrWaste_Availb[8] =
{
    0.001F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F, 120.0F, 140.0F
} ;                                    /* Referenced by: '<S1715>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_P_FuCellHiTHEXCtlReqRst_T[8]
    =
{
    -30.0F, -25.0F, -15.0F, -10.0F, -5.0F, 0.0F, 15.0F, 20.0F
} ;                                    /* Referenced by: '<S1117>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_P_LTCL_Heat_Reject[7] =
{
    -40.0F, 0.0F, 40.0F, 60.0F, 80.0F, 100.0F, 150.0F
} ;                                    /* Referenced by: '<S2821>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_P_MaxBCHPwrHtrClntFlow[8] =
{
    0.001F, 2.0F, 4.0F, 8.0F, 10.0F, 12.0F, 14.0F, 16.0F
} ;                                    /* Referenced by: '<S3170>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_P_MaxCabHtrPwrVsClntFlow[8]
    =
{
    0.001F, 2.0F, 4.0F, 8.0F, 10.0F, 12.0F, 14.0F, 16.0F
} ;                                    /* Referenced by: '<S1423>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_P_Min_HCCTIS_MaxPwr[6] =
{
    -40.0F, -20.0F, 0.0F, 20.0F, 40.0F, 60.0F
} ;                                    /* Referenced by: '<S1255>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_P_OV_AmbChill_CabPwr[9] =
{
    10.0F, 20.0F, 30.0F, 40.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S1240>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_P_PerWpCond_EngHeatPwr_Need[8] =
{
    0.001F, 5.0F, 10.0F, 15.0F, 20.0F, 25.0F, 30.0F, 35.0F
} ;                                    /* Referenced by: '<S1952>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_P_Reg_HCCTIS_MaxPwr[6] =
{
    -40.0F, -20.0F, 0.0F, 20.0F, 40.0F, 60.0F
} ;                                    /* Referenced by: '<S1270>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_AGS1_PosReqLUT[10] =
{
    0.0F, 5.0F, 10.0F, 15.0F, 20.0F, 25.0F, 30.0F, 35.0F, 50.0F, 100.0F
} ;                                    /* Referenced by: '<S5420>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_AGS1_PosReqLUT1[10] =
{
    0.0F, 5.0F, 10.0F, 15.0F, 20.0F, 25.0F, 30.0F, 35.0F, 50.0F, 100.0F
} ;                                    /* Referenced by: '<S5421>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_AGS2_PosReqLUT[10] =
{
    0.0F, 5.0F, 10.0F, 15.0F, 20.0F, 25.0F, 30.0F, 35.0F, 50.0F, 100.0F
} ;                                    /* Referenced by: '<S5422>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_AGS_PosReqLUT[10] =
{
    0.0F, 5.0F, 10.0F, 15.0F, 20.0F, 25.0F, 30.0F, 35.0F, 50.0F, 100.0F
} ;                                    /* Referenced by: '<S5385>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_AHH_Fan_Speed[9] =
{
    0.0F, 0.1875F, 0.375F, 0.5625F, 0.75F, 0.9375F, 1.125F, 1.3125F, 1.5F
} ;                                    /* Referenced by: '<S5427>/Vector' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_BTCLPstnFlwpct[9] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 50.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S277>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_BattRad_AGSPos_Req[11] =
{
    0.1F, 16.0F, 32.0F, 48.0F, 64.0F, 80.0F, 96.0F, 112.0F, 128.0F, 144.0F,
    160.0F
} ;                                    /* Referenced by: '<S5601>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_Pct_BattRad_Airflow_Idx_AGS[11] =
{
    0.1F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S5455>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_Pct_BattRad_Airflow_Idx_AGSOpen[11] =
{
    0.1F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S5456>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_BattRad_FanPWM_Req[11] =
{
    0.1F, 16.0F, 32.0F, 48.0F, 64.0F, 80.0F, 96.0F, 112.0F, 128.0F, 144.0F,
    160.0F
} ;                                    /* Referenced by: '<S5602>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_CabVlvOpeng_CmdLookUp[6]
    =
{
    0.001F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S1361>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_Pct_DirectAirFlw_AGSPos_Req[11] =
{
    0.1F, 16.0F, 32.0F, 48.0F, 64.0F, 80.0F, 96.0F, 112.0F, 128.0F, 144.0F,
    160.0F
} ;                                    /* Referenced by: '<S5603>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_Pct_DirectAirFlw_FanPWM_Req[11] =
{
    0.1F, 16.0F, 32.0F, 48.0F, 64.0F, 80.0F, 96.0F, 112.0F, 128.0F, 144.0F,
    160.0F
} ;                                    /* Referenced by: '<S5604>/Vector' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_ECM_Airflow_Idx_AGS[11]
    =
{
    0.1F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S5469>/Vector' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_Pct_ECM_Airflow_Idx_AGSOpen[11] =
{
    0.1F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S5470>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_EffctvAGSCombPos[7] =
{
    0.0F, 5.0F, 10.0F, 20.0F, 30.0F, 50.0F, 100.0F
} ;                                    /* Referenced by: '<S5514>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_EngRad_AGSPos_Req[11] =
{
    0.1F, 16.0F, 32.0F, 48.0F, 64.0F, 80.0F, 96.0F, 112.0F, 128.0F, 144.0F,
    160.0F
} ;                                    /* Referenced by: '<S5605>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_EngRad_FanPWM_Req[11] =
{
    0.1F, 16.0F, 32.0F, 48.0F, 64.0F, 80.0F, 96.0F, 112.0F, 128.0F, 144.0F,
    160.0F
} ;                                    /* Referenced by: '<S5606>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_FCLPstnFlwpct[9] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 50.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S890>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_FCNucleus_AGSPos[6] =
{
    0.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S5614>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_FCNucleus_FanPWM[6] =
{
    0.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S5615>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_FC_AGSPos_ReqFCA[11] =
{
    0.1F, 16.0F, 32.0F, 48.0F, 64.0F, 80.0F, 96.0F, 112.0F, 128.0F, 144.0F,
    160.0F
} ;                                    /* Referenced by: '<S5607>/Vector' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_FC_HTR_Airflow_Idx_AGS
    [11] =
{
    0.1F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S5476>/Vector' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_Pct_FC_HTR_Airflow_Idx_AGSOpen[11] =
{
    0.1F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S5477>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_FC_VlvFdpPosPct[9] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 50.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by:
                                        * '<S743>/Vector'
                                        * '<S837>/Vector'
                                        */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_FanPWM_ReqFCA[11] =
{
    0.1F, 16.0F, 32.0F, 48.0F, 64.0F, 80.0F, 96.0F, 112.0F, 128.0F, 144.0F,
    160.0F
} ;                                    /* Referenced by: '<S5608>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_HTCLPstnFlwpct[9] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 50.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by:
                                        * '<S1907>/Vector'
                                        * '<S4414>/Vector'
                                        * '<S4418>/Vector'
                                        * '<S4475>/Vector'
                                        */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_HTRConversionRCVR[6] =
{
    0.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S779>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_Pct_HeadPres_Airflow_Idx_AGS[11] =
{
    0.1F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S5462>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_Pct_HeadPres_Airflow_Idx_AGSOpen[11] =
{
    0.1F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S5463>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_LTCLPstnFlwpct[13] =
{
    0.0F, 10.0F, 20.0F, 25.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 75.0F, 80.0F,
    90.0F, 100.0F
} ;                                    /* Referenced by: '<S4487>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_LTRVlvCmd_Airflow[5] =
{
    0.0F, 10.0F, 50.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S5386>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_LTR_AGSPos_Req[11] =
{
    0.1F, 16.0F, 32.0F, 48.0F, 64.0F, 80.0F, 96.0F, 112.0F, 128.0F, 144.0F,
    160.0F
} ;                                    /* Referenced by: '<S5609>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_LTR_Airflow_Idx_AGS[11]
    =
{
    0.1F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S5483>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_Pct_LTR_Airflow_Idx_AGSOpen[11] =
{
    0.1F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S5484>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_LTR_FanPWM_Req[11] =
{
    0.1F, 16.0F, 32.0F, 48.0F, 64.0F, 80.0F, 96.0F, 112.0F, 128.0F, 144.0F,
    160.0F
} ;                                    /* Referenced by: '<S5610>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_MaskCmprNoiseFanCmd[5] =
{
    0.0F, 0.001F, 0.01F, 0.1F, 0.2F
} ;                                    /* Referenced by: '<S5611>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_OHX_AGSPos_Req[11] =
{
    0.1F, 16.0F, 32.0F, 48.0F, 64.0F, 80.0F, 96.0F, 112.0F, 128.0F, 144.0F,
    160.0F
} ;                                    /* Referenced by: '<S5612>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_OHX_FanPWM_Req[11] =
{
    0.1F, 16.0F, 32.0F, 48.0F, 64.0F, 80.0F, 96.0F, 112.0F, 128.0F, 144.0F,
    160.0F
} ;                                    /* Referenced by: '<S5613>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_P1MotorReqDsbl

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_Pct_P1Motor_Airflow_Idx_AGS[11] =
{
    0.1F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S5499>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_P1MotorReqDsbl

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_Pct_P1Motor_Airflow_Idx_AGSOpen[11] =
{
    0.1F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S5500>/Vector' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_Pct_PPU_Airflow_Idx_AGS[11]
    =
{
    0.1F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S5506>/Vector' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_Pct_PPU_Airflow_Idx_AGSOpen[11] =
{
    0.1F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S5507>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_T_BattClntMaxTgt[18] =
{
    0.0F, 1.0F, 2.0F, 3.0F, 4.0F, 5.0F, 6.0F, 7.0F, 8.0F, 9.0F, 10.0F, 11.0F,
    12.0F, 13.0F, 14.0F, 15.0F, 16.0F, 17.0F
} ;                                    /* Referenced by: '<S367>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_T_BattClntMinTgt[18] =
{
    0.0F, 1.0F, 2.0F, 3.0F, 4.0F, 5.0F, 6.0F, 7.0F, 8.0F, 9.0F, 10.0F, 11.0F,
    12.0F, 13.0F, 14.0F, 15.0F, 16.0F, 17.0F
} ;                                    /* Referenced by: '<S368>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_T_CellTempMaxAllow[18] =
{
    0.0001F, 1.0F, 2.0F, 3.0F, 4.0F, 5.0F, 6.0F, 7.0F, 8.0F, 9.0F, 10.0F, 11.0F,
    12.0F, 13.0F, 14.0F, 15.0F, 16.0F, 17.0F
} ;                                    /* Referenced by: '<S372>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_T_CellTempMaxAllowPsv[18] =
{
    0.001F, 1.0F, 2.0F, 3.0F, 4.0F, 5.0F, 6.0F, 7.0F, 8.0F, 9.0F, 10.0F, 11.0F,
    12.0F, 13.0F, 14.0F, 15.0F, 16.0F, 17.0F
} ;                                    /* Referenced by: '<S373>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_T_CellTempMinAllowPsv[18] =
{
    0.001F, 1.0F, 2.0F, 3.0F, 4.0F, 5.0F, 6.0F, 7.0F, 8.0F, 9.0F, 10.0F, 11.0F,
    12.0F, 13.0F, 14.0F, 15.0F, 16.0F, 17.0F
} ;                                    /* Referenced by: '<S376>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_T_ChrgLvlBasedAmbTemp[3] =
{
    1.0F, 2.0F, 3.0F
} ;                                    /* Referenced by: '<S4875>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_T_ChrgPwrReqBasedAmbTemp[10]
    =
{
    1000.0F, 3000.0F, 5000.0F, 7000.0F, 9000.0F, 11000.0F, 13000.0F, 15000.0F,
    17000.0F, 19000.0F
} ;                                    /* Referenced by: '<S4876>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_T_CoFuCellHiTOutSpOfs_T[10]
    =
{
    -0.8F, -0.6F, -0.5F, -0.4F, -0.3F, -0.2F, -0.15F, -0.1F, -0.05F, 0.0F
} ;                                    /* Referenced by: '<S1010>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_T_LTCLVlvAllowTempDflt_Ambient[5] =
{
    -40.0F, 0.0F, 10.0F, 25.0F, 40.0F
} ;                                    /* Referenced by: '<S5214>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_T_MGU_AirInletTmp_Offset[12]
    =
{
    0.0F, 5.0F, 10.0F, 15.0F, 25.0F, 30.0F, 35.0F, 40.0F, 50.0F, 70.0F, 75.0F,
    80.0F
} ;                                    /* Referenced by: '<S2854>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_T_PsvCool_BTISMaxAllwd[3] =
{
    5.0F, 20.0F, 35.0F
} ;                                    /* Referenced by: '<S4877>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_T_TempMinAllow[18] =
{
    0.001F, 1.0F, 2.0F, 3.0F, 4.0F, 5.0F, 6.0F, 7.0F, 8.0F, 9.0F, 10.0F, 11.0F,
    12.0F, 13.0F, 14.0F, 15.0F, 16.0F, 17.0F
} ;                                    /* Referenced by: '<S377>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_T_VehSpdBasedAmbTemp[8] =
{
    0.0F, 15.0F, 30.0F, 45.0F, 60.0F, 75.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S4813>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_T_WaOutRadHiTEstimFil_T[6] =
{
    0.0F, 40.0F, 80.0F, 90.0F, 95.0F, 100.0F
} ;                                    /* Referenced by: '<S1011>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_T_WaPmpFuCellOfs_T[8] =
{
    0.0F, 450.0F, 2250.0F, 6750.0F, 11250.0F, 22500.0F, 33750.0F, 45000.0F
} ;                                    /* Referenced by: '<S917>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dQ_FrontEDM_ActHeat[11] =
{
    0.0F, 17.0F, 34.0F, 51.0F, 68.0F, 85.0F, 102.0F, 119.0F, 136.0F, 153.0F,
    170.0F
} ;                                    /* Referenced by: '<S2877>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dQ_FrontEDM_HeatLoss[11] =
{
    0.0F, 17.0F, 34.0F, 51.0F, 68.0F, 85.0F, 102.0F, 119.0F, 136.0F, 153.0F,
    170.0F
} ;                                    /* Referenced by: '<S2431>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dQ_FrontEDM_MaxHeat[11] =
{
    0.0F, 1500.0F, 3000.0F, 4500.0F, 6000.0F, 7500.0F, 9000.0F, 10500.0F,
    12000.0F, 13500.0F, 15000.0F
} ;                                    /* Referenced by: '<S2878>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dQ_GEN_ActHeat[11] =
{
    0.0F, 17.0F, 34.0F, 51.0F, 68.0F, 85.0F, 102.0F, 119.0F, 136.0F, 153.0F,
    170.0F
} ;                                    /* Referenced by: '<S2879>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dQ_GEN_MaxHeat[11] =
{
    0.0F, 1500.0F, 3000.0F, 4500.0F, 6000.0F, 7500.0F, 9000.0F, 10500.0F,
    12000.0F, 13500.0F, 15000.0F
} ;                                    /* Referenced by: '<S2880>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dQ_RearEDM_ActHeat[11] =
{
    0.0F, 17.0F, 34.0F, 51.0F, 68.0F, 85.0F, 102.0F, 119.0F, 136.0F, 153.0F,
    170.0F
} ;                                    /* Referenced by: '<S2881>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dQ_RearEDM_HeatLoss[11] =
{
    0.0F, 17.0F, 34.0F, 51.0F, 68.0F, 85.0F, 102.0F, 119.0F, 136.0F, 153.0F,
    170.0F
} ;                                    /* Referenced by: '<S2432>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dQ_RearEDM_MaxHeat[11] =
{
    0.0F, 1500.0F, 3000.0F, 4500.0F, 6000.0F, 7500.0F, 9000.0F, 10500.0F,
    12000.0F, 13500.0F, 15000.0F
} ;                                    /* Referenced by: '<S2882>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_dT_CabPriorty_Blwr_EvapErrHigh[6] =
{
    10.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S429>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_dT_CabPriorty_Blwr_EvapErrLow[6] =
{
    10.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S430>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dT_CondAirWarmupEst[6] =
{
    -10.0F, 0.0F, 10.0F, 20.0F, 30.0F, 40.0F
} ;                                    /* Referenced by: '<S749>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dT_LTRAirWarmupEst[6] =
{
    -10.0F, 0.0F, 10.0F, 20.0F, 30.0F, 40.0F
} ;                                    /* Referenced by: '<S750>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_AHH_LT_FrontEDM_FlwTgt[7]
    =
{
    0.001F, 0.2F, 0.4F, 0.6F, 0.8F, 0.9F, 1.0F
} ;                                    /* Referenced by: '<S2953>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_AHH_LT_RearEDM_FlwTgt[11]
    =
{
    0.0F, 0.1F, 0.2F, 0.3F, 0.4F, 0.5F, 0.6F, 0.7F, 0.8F, 0.9F, 1.0F
} ;                                    /* Referenced by: '<S2954>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_APM_ClntFlw[7] =
{
    -40.0F, -20.0F, 0.0F, 10.0F, 20.0F, 30.0F, 60.0F
} ;                                    /* Referenced by: '<S2932>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_BattRad_AirFlowRaw[7] =
{
    0.0F, 133.3F, 266.7F, 400.0F, 533.3F, 666.7F, 800.0F
} ;                                    /* Referenced by: '<S3112>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_ClngFlowRqrdMtr1[7] =
{
    -40.0F, 0.0F, 40.0F, 60.0F, 80.0F, 100.0F, 150.0F
} ;                                    /* Referenced by: '<S682>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_dV_ClngFlowRqrdMtr1_Reverse[7] =
{
    -40.0F, 0.0F, 40.0F, 60.0F, 80.0F, 100.0F, 150.0F
} ;                                    /* Referenced by: '<S677>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_ClngFlowRqrdMtr2[7] =
{
    -40.0F, 0.0F, 40.0F, 60.0F, 80.0F, 100.0F, 150.0F
} ;                                    /* Referenced by: '<S705>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_dV_ClngFlowRqrdMtr2_Reverse[7] =
{
    -40.0F, 0.0F, 40.0F, 60.0F, 80.0F, 100.0F, 150.0F
} ;                                    /* Referenced by: '<S700>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_DCBC_ClntFlw[9] =
{
    1.0F, 2.0F, 3.0F, 4.0F, 5.0F, 6.0F, 7.0F, 8.0F, 9.0F
} ;                                    /* Referenced by: '<S2933>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_DCDC_ClntFlw[9] =
{
    10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F
} ;                                    /* Referenced by: '<S2934>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_EstAirflow_Max[5] =
{
    0.0F, 25.0F, 39.0F, 75.0F, 100.0F
} ;                                    /* Referenced by: '<S5515>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_FC_HTR_AirFlowRaw[7] =
{
    0.0F, 1333.0F, 2667.0F, 4000.0F, 5333.0F, 6667.0F, 8000.0F
} ;                                    /* Referenced by: '<S863>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_FrontEDM_FlwTgt[7] =
{
    0.001F, 0.8F, 1.5F, 2.2F, 4.0F, 5.5F, 7.0F
} ;                                    /* Referenced by: '<S2883>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_FrontEDM_MinFlw[7] =
{
    0.001F, 0.8F, 1.5F, 2.2F, 4.0F, 5.5F, 7.0F
} ;                                    /* Referenced by: '<S2884>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_GEN_FlwTgt[7] =
{
    0.001F, 0.8F, 1.5F, 2.2F, 4.0F, 5.5F, 7.0F
} ;                                    /* Referenced by: '<S2885>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_GEN_MinFlw[7] =
{
    0.001F, 0.8F, 1.5F, 2.2F, 4.0F, 5.5F, 7.0F
} ;                                    /* Referenced by: '<S2886>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_GEN_PIM_FlwTgt[11] =
{
    0.0F, 1.0F, 2.0F, 3.0F, 4.0F, 5.0F, 6.0F, 7.0F, 8.0F, 9.0F, 10.0F
} ;                                    /* Referenced by: '<S2935>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_HT_AuxPmpFlw[7] =
{
    0.001F, 0.8F, 1.5F, 2.2F, 4.0F, 5.5F, 7.0F
} ;                                    /* Referenced by: '<S1928>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_HT_AuxPmpFlwForActvCool
    [7] =
{
    -40.0F, -20.0F, 0.0F, 20.0F, 40.0F, 60.0F, 75.0F
} ;                                    /* Referenced by: '<S1929>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_HeadPresAir_Flow[7] =
{
    -40.0F, 0.0F, 40.0F, 60.0F, 80.0F, 100.0F, 150.0F
} ;                                    /* Referenced by: '<S2822>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_HeadPres_LTPsvPmpFlw[7] =
{
    0.001F, 0.8F, 1.5F, 2.2F, 4.0F, 5.5F, 7.0F
} ;                                    /* Referenced by: '<S2936>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_HeatPumpAir_Flow[7] =
{
    -40.0F, 0.0F, 40.0F, 60.0F, 80.0F, 100.0F, 150.0F
} ;                                    /* Referenced by: '<S2823>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_IDCM_FlwTgt[9] =
{
    -40.0F, 35.0F, 40.0F, 45.0F, 50.0F, 55.0F, 60.0F, 65.0F, 70.0F
} ;                                    /* Referenced by: '<S2937>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_dV_LTRVlv_RadAirFlowRate_LookUp[13] =
{
    0.0F, 1.0F, 2.0F, 3.0F, 4.0F, 5.0F, 6.0F, 7.0F, 8.0F, 9.0F, 10.0F, 11.0F,
    12.0F
} ;                                    /* Referenced by: '<S2790>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_LTR_AirFlowRaw[7] =
{
    -40.0F, 0.0F, 40.0F, 60.0F, 80.0F, 100.0F, 150.0F
} ;                                    /* Referenced by: '<S2824>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_MGU_ClntPumpFlw[7] =
{
    -40.0F, 0.0F, 40.0F, 60.0F, 80.0F, 100.0F, 150.0F
} ;                                    /* Referenced by: '<S2825>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_MaxAirFlw_HiTempRad[5] =
{
    0.1F, 20.0F, 50.0F, 100.0F, 180.0F
} ;                                    /* Referenced by: '<S5524>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_MaxAirFlw_LoTempRad[5] =
{
    0.1F, 20.0F, 50.0F, 100.0F, 180.0F
} ;                                    /* Referenced by: '<S5525>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_MaxAirFlw_OHX[5] =
{
    0.1F, 20.0F, 50.0F, 100.0F, 180.0F
} ;                                    /* Referenced by: '<S5526>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_MaxHTRAirflow[5] =
{
    0.1F, 20.0F, 50.0F, 100.0F, 180.0F
} ;                                    /* Referenced by: '<S864>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_MinAchvblArflwEst_Ohx[6]
    =
{
    0.0F, 16.0F, 40.0F, 80.0F, 120.0F, 160.0F
} ;                                    /* Referenced by: '<S5516>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_OBCM_ClntFlw[9] =
{
    10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F
} ;                                    /* Referenced by: '<S2938>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_P1Motor_AirFlowRaw[7] =
{
    -40.0F, 0.0F, 40.0F, 60.0F, 80.0F, 100.0F, 150.0F
} ;                                    /* Referenced by: '<S2826>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_PCU_ClntFlw[9] =
{
    10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F
} ;                                    /* Referenced by: '<S2939>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_PIM_Front_ClntFlw[9] =
{
    10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F
} ;                                    /* Referenced by: '<S2940>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_PIM_Rear_ClntFlw[9] =
{
    10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F
} ;                                    /* Referenced by: '<S2941>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_PerWp_HT_AuxPmpFlow[7] =
{
    0.001F, 0.8F, 1.5F, 2.2F, 4.0F, 5.5F, 7.0F
} ;                                    /* Referenced by: '<S1914>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_RearEDM_FlwTgt[7] =
{
    0.001F, 0.8F, 1.5F, 2.2F, 4.0F, 5.5F, 7.0F
} ;                                    /* Referenced by: '<S2887>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_dV_RearEDM_MinFlw[7] =
{
    0.001F, 0.8F, 1.5F, 2.2F, 4.0F, 5.5F, 7.0F
} ;                                    /* Referenced by: '<S2888>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_dV_TransOilCooler_ClntFlw_Front_EDM[8] =
{
    -40.0F, -20.0F, -10.0F, 0.0F, 25.0F, 50.0F, 75.0F, 90.0F
} ;                                    /* Referenced by: '<S2942>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_dV_TransOilCooler_ClntFlw_GEN[8] =
{
    -40.0F, -20.0F, -10.0F, 0.0F, 25.0F, 50.0F, 75.0F, 90.0F
} ;                                    /* Referenced by: '<S2943>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_dV_TransOilCooler_ClntFlw_Rear_EDM[8] =
{
    -40.0F, -20.0F, -10.0F, 0.0F, 25.0F, 50.0F, 75.0F, 90.0F
} ;                                    /* Referenced by: '<S2944>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_dV_WhlSpdDiff_OilFlwRtDiffTgt1[5] =
{
    0.0F, 75.0F, 150.0F, 225.0F, 300.0F
} ;                                    /* Referenced by: '<S685>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_dV_WhlSpdDiff_OilFlwRtDiffTgt2[5] =
{
    0.0F, 75.0F, 150.0F, 225.0F, 300.0F
} ;                                    /* Referenced by: '<S707>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_BattRadAirflw_Ki[6] =
{
    -10.0F, -5.0F, 0.0F, 1.0F, 20.0F, 50.0F
} ;                                    /* Referenced by: '<S3121>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_BattRadAirflw_Kp[6] =
{
    -10.0F, -5.0F, 0.0F, 1.0F, 20.0F, 50.0F
} ;                                    /* Referenced by: '<S3122>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_DFuCellWaPmpDelta_T[9] =
{
    -10.0F, -7.0F, -5.0F, -3.0F, 0.0F, 3.0F, 5.0F, 7.0F, 10.0F
} ;                                    /* Referenced by: '<S918>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_DHiTRegFuCellDft_M[9] =
{
    -10.0F, -2.0F, -1.0F, -0.5F, 0.0F, 0.5F, 1.0F, 2.0F, 10.0F
} ;                                    /* Referenced by: '<S975>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_DHiTRegFuCell_M[9] =
{
    -10.0F, -2.0F, -1.0F, -0.5F, 0.0F, 0.5F, 1.0F, 2.0F, 10.0F
} ;                                    /* Referenced by: '<S972>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_ElVlv3WayFuCellPosnLnr_T
    [18] =
{
    -1.0F, 0.0F, 1.1F, 5.9F, 16.0F, 24.9F, 34.5F, 44.4F, 54.0F, 63.1F, 71.4F,
    78.7F, 84.9F, 90.0F, 94.0F, 97.0F, 100.0F, 101.0F
} ;                                    /* Referenced by: '<S961>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FCAirflw_Ki[4] =
{
    0.0F, 0.6F, 1.0F, 10.0F
} ;                                    /* Referenced by: '<S885>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FCAirflw_Kp[4] =
{
    0.0F, 0.6F, 1.0F, 10.0F
} ;                                    /* Referenced by: '<S886>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FCPropVlv_Ki[4] =
{
    -10.0F, -1.0F, -0.6F, 0.0F
} ;                                    /* Referenced by: '<S780>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FCPropVlv_Kp[4] =
{
    -10.0F, -1.0F, -0.6F, 0.0F
} ;                                    /* Referenced by: '<S781>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FEDMheatEstm_Alpha1[2] =
{
    35.0F, 190.0F
} ;                                    /* Referenced by: '<S2433>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FEDMheatEstm_Alpha2[2] =
{
    35.0F, 190.0F
} ;                                    /* Referenced by: '<S2434>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FEDMheatEstm_Alpha3[2] =
{
    35.0F, 190.0F
} ;                                    /* Referenced by: '<S2435>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FEDMheatEstm_Alpha4[2] =
{
    35.0F, 190.0F
} ;                                    /* Referenced by: '<S2436>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FEDMheatEstm_Alpha5[2] =
{
    35.0F, 190.0F
} ;                                    /* Referenced by: '<S2437>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FacPHiTRegFuCell_T[5] =
{
    0.0F, 15.0F, 25.0F, 40.0F, 80.0F
} ;                                    /* Referenced by: '<S971>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FanDTerm_ClntErr[3] =
{
    25.0F, 25.0001F, 25.001F
} ;                                    /* Referenced by: '<S5548>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FanDTerm_PressErr[3] =
{
    25.0F, 25.0001F, 25.001F
} ;                                    /* Referenced by: '<S5573>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FanITerm_ClntErr[3] =
{
    50.0F, 50.0001F, 50.001F
} ;                                    /* Referenced by: '<S5549>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FanITerm_PressErr[3] =
{
    50.0F, 50.0001F, 50.001F
} ;                                    /* Referenced by: '<S5574>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FanPTerm_ClntErr[3] =
{
    500.0F, 500.000092F, 500.001F
} ;                                    /* Referenced by: '<S5550>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FanPTerm_PressErr[3] =
{
    500.0F, 500.000092F, 500.001F
} ;                                    /* Referenced by: '<S5575>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FlowCorHiTFuCellMixPt_T
    [11] =
{
    0.0F, 0.1F, 0.2F, 0.3F, 0.4F, 0.5F, 0.6F, 0.7F, 0.8F, 0.9F, 1.0F
} ;                                    /* Referenced by: '<S984>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_FuCellEfcMaxLimThStep_T[8]
    =
{
    5000.0F, 10000.0F, 15000.0F, 20000.0F, 35000.0F, 40000.0F, 45000.0F,
    50000.0F
} ;                                    /* Referenced by: '<S1052>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_HeatTranCoefOutRadHiT1_M
    [8] =
{
    -15.0F, 0.0F, 15.0F, 20.0F, 25.0F, 30.0F, 35.0F, 40.0F
} ;                                    /* Referenced by: '<S1012>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_HeatTranCoefOutRadHiT2_M
    [8] =
{
    -15.0F, 0.0F, 15.0F, 20.0F, 25.0F, 30.0F, 35.0F, 45.0F
} ;                                    /* Referenced by: '<S1013>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_HeatTranCoefOutRadHiT3_M
    [8] =
{
    -15.0F, 0.0F, 15.0F, 20.0F, 25.0F, 30.0F, 35.0F, 45.0F
} ;                                    /* Referenced by: '<S1014>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_HiTSpdFanReq_M[7] =
{
    5.0F, 10.0F, 20.0F, 40.0F, 60.0F, 90.0F, 120.0F
} ;                                    /* Referenced by: '<S1076>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_HiTSpdFanSysReqTrimMin_M
    [7] =
{
    5.0F, 10.0F, 20.0F, 40.0F, 60.0F, 90.0F, 120.0F
} ;                                    /* Referenced by: '<S1086>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_HiTSpdFanTRadOutMax_T[5] =
{
    -80.0F, -40.0F, -25.0F, -15.0F, 0.0F
} ;                                    /* Referenced by: '<S1073>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_HiTSpdFanTRadOutMin_T[5] =
{
    5.0F, 10.0F, 20.0F, 40.0F, 45.0F
} ;                                    /* Referenced by: '<S1074>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_IFuCellHiTHEXTInTar_T[9] =
{
    -4.0F, -2.0F, -1.0F, -0.5F, 0.0F, 0.5F, 1.0F, 2.0F, 4.0F
} ;                                    /* Referenced by: '<S1127>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_IFuCellWaPmpDelta_T[9] =
{
    -10.0F, -7.0F, -5.0F, -3.0F, 0.0F, 3.0F, 5.0F, 7.0F, 10.0F
} ;                                    /* Referenced by: '<S919>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_IHiTRegFuCellDft_M[9] =
{
    -10.0F, -2.0F, -1.0F, -0.5F, 0.0F, 0.5F, 1.0F, 2.0F, 10.0F
} ;                                    /* Referenced by: '<S976>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_IHiTRegFuCell_M[9] =
{
    -10.0F, -2.0F, -1.0F, -0.5F, 0.0F, 0.5F, 1.0F, 2.0F, 10.0F
} ;                                    /* Referenced by: '<S973>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_k_LoopPriorty_BTCLWsteHeatRcvryHP[6] =
{
    10.0F, 12.0F, 22.0F, 42.0F, 52.0F, 60.0F
} ;                                    /* Referenced by: '<S5065>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_k_LoopPriorty_BattActvPsvHeat[4] =
{
    0.0F, 0.6F, 1.0F, 10.0F
} ;                                    /* Referenced by: '<S5050>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_k_LoopPriorty_CabActvPsvHeat[4] =
{
    0.0F, 0.6F, 1.0F, 10.0F
} ;                                    /* Referenced by: '<S5060>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_k_LoopPriorty_CabActvPsvHeat_HP[6] =
{
    10.0F, 12.0F, 22.0F, 42.0F, 52.0F, 62.0F
} ;                                    /* Referenced by: '<S5061>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_LpfSpdAirHiTSysReqDec_T[7]
    =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by: '<S1087>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_LpfSpdAirHiTSysReqInc_T[7]
    =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by: '<S1088>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_PFuCellWaPmpDelta_T[8] =
{
    -10.0F, -7.0F, -5.0F, -3.0F, 3.0F, 5.0F, 7.0F, 10.0F
} ;                                    /* Referenced by: '<S920>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_PHiTRegFuCellDft_M[9] =
{
    -30.0F, -5.0F, -1.0F, -0.5F, 0.0F, 0.5F, 1.0F, 5.0F, 30.0F
} ;                                    /* Referenced by: '<S977>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_PHiTRegFuCell_M[9] =
{
    -30.0F, -5.0F, -1.0F, -0.5F, 0.0F, 0.5F, 1.0F, 5.0F, 30.0F
} ;                                    /* Referenced by: '<S974>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_PwrFuCellMaxLimThStep_M[8]
    =
{
    5000.0F, 10000.0F, 15000.0F, 20000.0F, 35000.0F, 40000.0F, 45000.0F,
    50000.0F
} ;                                    /* Referenced by: '<S1053>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_REDMheatEstm_Alpha1[2] =
{
    35.0F, 190.0F
} ;                                    /* Referenced by: '<S2438>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_REDMheatEstm_Alpha2[2] =
{
    35.0F, 190.0F
} ;                                    /* Referenced by: '<S2439>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_REDMheatEstm_Alpha3[2] =
{
    35.0F, 190.0F
} ;                                    /* Referenced by: '<S2440>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_REDMheatEstm_Alpha4[2] =
{
    35.0F, 190.0F
} ;                                    /* Referenced by: '<S2441>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_REDMheatEstm_Alpha5[2] =
{
    35.0F, 190.0F
} ;                                    /* Referenced by: '<S2442>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_SpdAirHiTDown_T[9] =
{
    -4.0F, -3.0F, -2.0F, -1.0F, 0.0F, 1.0F, 2.0F, 3.0F, 4.0F
} ;                                    /* Referenced by: '<S1077>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_SpdAirHiTSysReq_M[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F
} ;                                    /* Referenced by: '<S1089>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_SpdAirHiTUp_T[9] =
{
    -4.0F, -3.0F, -2.0F, -1.0F, 0.0F, 1.0F, 2.0F, 3.0F, 4.0F
} ;                                    /* Referenced by: '<S1078>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_TDifCoFuCellHiTOutFil_T[7]
    =
{
    0.2F, 0.4F, 0.8F, 1.6F, 3.2F, 6.4F, 10.0F
} ;                                    /* Referenced by: '<S1015>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_TDifWaOutRadHiTFil_T[7] =
{
    0.2F, 0.4F, 0.8F, 1.6F, 3.2F, 6.4F, 10.0F
} ;                                    /* Referenced by: '<S1016>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_WaPmpFuCellMin_T[5] =
{
    -20.0F, 0.0F, 80.0F, 82.0F, 83.0F
} ;                                    /* Referenced by: '<S921>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KxTHMR_k_WaPmpFuCellPwrMaxLimThReq_M[6] =
{
    0.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S922>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_WaPmpFuCellReg_M[8] =
{
    0.0F, 450.0F, 2250.0F, 6750.0F, 11250.0F, 22500.0F, 33750.0F, 45000.0F
} ;                                    /* Referenced by: '<S923>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_WaPmpFuCellReq_M[8] =
{
    0.0F, 10.0F, 25.0F, 50.0F, 75.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S924>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_k_WaPmpFuCellTDeltaReq_M[6]
    =
{
    0.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S925>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_n_AirHiTNomReq_M[8] =
{
    -20.0F, -10.0F, 0.0F, 5.0F, 10.0F, 20.0F, 30.0F, 45.0F
} ;                                    /* Referenced by: '<S1079>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_n_EngSpdInc_ReqHysUp[8] =
{
    -40.0F, 0.0F, 100.0F, 120.0F, 145.0F, 155.0F, 165.0F, 175.0F
} ;                                    /* Referenced by: '<S2855>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_n_HghSOC_LwTmp_BattRng[6] =
{
    -40.0F, -35.0F, -30.0F, -25.0F, 0.001F, 10.0F
} ;                                    /* Referenced by: '<S1727>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_n_P1Motor_EngSpdInc[7] =
{
    -40.0F, 0.0F, 40.0F, 60.0F, 80.0F, 100.0F, 150.0F
} ;                                    /* Referenced by: '<S2856>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_p_TgtPSuc[14] =
{
    10.0F, 16.0F, 22.0F, 28.0F, 30.0F, 32.0F, 34.0F, 36.0F, 38.0F, 40.0F, 42.0F,
    44.0F, 46.0F, 48.0F
} ;                                    /* Referenced by: '<S5563>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_p_TgtPres[14] =
{
    10.0F, 16.0F, 22.0F, 28.0F, 30.0F, 32.0F, 34.0F, 36.0F, 38.0F, 40.0F, 42.0F,
    44.0F, 46.0F, 48.0F
} ;                                    /* Referenced by: '<S5576>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_r_BattCabPrioRatioFrHTCV[5]
    =
{
    0.0F, 0.3F, 0.5F, 0.7F, 1.0F
} ;                                    /* Referenced by: '<S1395>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_r_BattCabPrioRatioFrHTLVlv
    [5] =
{
    0.0F, 0.3F, 0.5F, 0.7F, 1.0F
} ;                                    /* Referenced by:
                                        * '<S1987>/Vector'
                                        * '<S2314>/Vector'
                                        */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_r_EnblBattCabPrty_BlwrAmb[8]
    =
{
    10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 90.0F
} ;                                    /* Referenced by: '<S419>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_r_MoreToBatt_SOC[8] =
{
    0.001F, 20.0F, 40.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S1201>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_r_MoreToCab_SOC[8] =
{
    0.001F, 20.0F, 40.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S1204>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_r_MoreToCab_SOC_Opt[8] =
{
    0.001F, 20.0F, 40.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S1192>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_t_AmbTempBasedPsvDuration[7]
    =
{
    -40.0F, -25.0F, -10.0F, 5.0F, 20.0F, 40.0F, 60.0F
} ;                                    /* Referenced by: '<S4878>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_t_EngTurnOff_TimDely[8] =
{
    0.001F, 3.0F, 6.0F, 9.0F, 12.0F, 15.0F, 18.0F, 21.0F
} ;                                    /* Referenced by: '<S1589>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KxTHMR_t_FuCellPwrLimTh_M[7] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 55.0F, 70.0F
} ;                                    /* Referenced by: '<S1054>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_K_Min_HtrPwr_Ki[6] =
{
    5.0F, 10.0F, 15.0F, 25.0F, 29.0F, 30.0F
} ;                                    /* Referenced by: '<S1252>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_K_Min_HtrPwr_Kp[6] =
{
    5.0F, 10.0F, 15.0F, 25.0F, 29.0F, 30.0F
} ;                                    /* Referenced by: '<S1253>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_K_Reg_HtrPwr_Ki_ECO[6] =
{
    5.0F, 10.0F, 15.0F, 25.0F, 29.0F, 30.0F
} ;                                    /* Referenced by: '<S1283>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_K_Reg_HtrPwr_Ki_HPM[6] =
{
    5.0F, 10.0F, 15.0F, 25.0F, 29.0F, 30.0F
} ;                                    /* Referenced by: '<S1284>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_K_Reg_HtrPwr_Ki_HPM_ECO[6] =
{
    5.0F, 10.0F, 15.0F, 25.0F, 29.0F, 30.0F
} ;                                    /* Referenced by: '<S1285>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_K_Reg_HtrPwr_Ki_NM[6] =
{
    5.0F, 10.0F, 15.0F, 25.0F, 29.0F, 30.0F
} ;                                    /* Referenced by: '<S1286>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_K_Reg_HtrPwr_Kp_ECO[6] =
{
    5.0F, 10.0F, 15.0F, 25.0F, 29.0F, 30.0F
} ;                                    /* Referenced by: '<S1287>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_K_Reg_HtrPwr_Kp_HPM[6] =
{
    5.0F, 10.0F, 15.0F, 25.0F, 29.0F, 30.0F
} ;                                    /* Referenced by: '<S1288>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_K_Reg_HtrPwr_Kp_HPM_ECO[6] =
{
    5.0F, 10.0F, 15.0F, 25.0F, 29.0F, 30.0F
} ;                                    /* Referenced by: '<S1289>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_K_Reg_HtrPwr_Kp_NM[6] =
{
    5.0F, 10.0F, 15.0F, 25.0F, 29.0F, 30.0F
} ;                                    /* Referenced by: '<S1290>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_P_LTCL_Heat_Reject[8] =
{
    0.001F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 100.0F
} ;                                    /* Referenced by: '<S2821>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_P_Min_HCCTIS_MaxPwr[6] =
{
    2.0F, 5.0F, 10.0F, 15.0F, 20.0F, 30.0F
} ;                                    /* Referenced by: '<S1255>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_P_Reg_HCCTIS_MaxPwr[6] =
{
    2.0F, 5.0F, 10.0F, 15.0F, 20.0F, 30.0F
} ;                                    /* Referenced by: '<S1270>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_Pct_BattRad_AGSPos_Req[13] =
{
    0.1F, 450.0F, 1078.0F, 1079.0F, 1438.0F, 1798.0F, 2157.0F, 2517.0F, 2876.0F,
    3236.0F, 3416.0F, 3596.0F, 3955.0F
} ;                                    /* Referenced by: '<S5601>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_Pct_BattRad_Airflow_Idx_AGS[12] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 95.0F,
    100.0F
} ;                                    /* Referenced by: '<S5455>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_Pct_BattRad_Airflow_Idx_AGSOpen[13] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 92.0F,
    95.0F, 100.0F
} ;                                    /* Referenced by: '<S5456>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_Pct_BattRad_FanPWM_Req[13] =
{
    0.1F, 450.0F, 1078.0F, 1079.0F, 1438.0F, 1798.0F, 2157.0F, 2517.0F, 2876.0F,
    3236.0F, 3416.0F, 3596.0F, 3955.0F
} ;                                    /* Referenced by: '<S5602>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_Pct_DirectAirFlw_AGSPos_Req[13] =
{
    0.1F, 450.0F, 1078.0F, 1079.0F, 1438.0F, 1798.0F, 2157.0F, 2517.0F, 2876.0F,
    3236.0F, 3416.0F, 3596.0F, 3955.0F
} ;                                    /* Referenced by: '<S5603>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_Pct_DirectAirFlw_FanPWM_Req[13] =
{
    0.1F, 450.0F, 1078.0F, 1079.0F, 1438.0F, 1798.0F, 2157.0F, 2517.0F, 2876.0F,
    3236.0F, 3416.0F, 3596.0F, 3955.0F
} ;                                    /* Referenced by: '<S5604>/Vector' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_Pct_ECM_Airflow_Idx_AGS[12]
    =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 95.0F,
    100.0F
} ;                                    /* Referenced by: '<S5469>/Vector' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_Pct_ECM_Airflow_Idx_AGSOpen[13] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 92.0F,
    95.0F, 100.0F
} ;                                    /* Referenced by: '<S5470>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_Pct_EffctvAGSCombPos[7] =
{
    0.0F, 5.0F, 10.0F, 20.0F, 30.0F, 50.0F, 100.0F
} ;                                    /* Referenced by: '<S5514>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_Pct_EngRad_AGSPos_Req[13] =
{
    0.1F, 450.0F, 1078.0F, 1079.0F, 1438.0F, 1798.0F, 2157.0F, 2517.0F, 2876.0F,
    3236.0F, 3416.0F, 3596.0F, 3955.0F
} ;                                    /* Referenced by: '<S5605>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_Pct_EngRad_FanPWM_Req[13] =
{
    0.1F, 450.0F, 1078.0F, 1079.0F, 1438.0F, 1798.0F, 2157.0F, 2517.0F, 2876.0F,
    3236.0F, 3416.0F, 3596.0F, 3955.0F
} ;                                    /* Referenced by: '<S5606>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_Pct_FC_AGSPos_ReqFCA[13] =
{
    0.1F, 450.0F, 1078.0F, 1079.0F, 1438.0F, 1798.0F, 2157.0F, 2517.0F, 2876.0F,
    3236.0F, 3416.0F, 3596.0F, 3955.0F
} ;                                    /* Referenced by: '<S5607>/Vector' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_Pct_FC_HTR_Airflow_Idx_AGS
    [12] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 95.0F,
    100.0F
} ;                                    /* Referenced by: '<S5476>/Vector' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_Pct_FC_HTR_Airflow_Idx_AGSOpen[13] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 92.0F,
    95.0F, 100.0F
} ;                                    /* Referenced by: '<S5477>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_Pct_FanPWM_ReqFCA[13] =
{
    0.1F, 450.0F, 1078.0F, 1079.0F, 1438.0F, 1798.0F, 2157.0F, 2517.0F, 2876.0F,
    3236.0F, 3416.0F, 3596.0F, 3955.0F
} ;                                    /* Referenced by: '<S5608>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_Pct_HeadPres_Airflow_Idx_AGS[13] =
{
    0.0F, 143.0F, 228.0F, 372.0F, 668.0F, 1013.0F, 1389.0F, 1768.0F, 2140.0F,
    2483.0F, 2777.0F, 3003.0F, 3492.0F
} ;                                    /* Referenced by: '<S5462>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_Pct_HeadPres_Airflow_Idx_AGSOpen[13] =
{
    0.0F, 429.0F, 1088.0F, 1254.0F, 1493.0F, 1787.0F, 2119.0F, 2469.0F, 2819.0F,
    3152.0F, 3449.0F, 3692.0F, 4097.0F
} ;                                    /* Referenced by: '<S5463>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_Pct_LTR_AGSPos_Req[13] =
{
    0.1F, 450.0F, 1078.0F, 1079.0F, 1438.0F, 1798.0F, 2157.0F, 2517.0F, 2876.0F,
    3236.0F, 3416.0F, 3596.0F, 3955.0F
} ;                                    /* Referenced by: '<S5609>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_Pct_LTR_Airflow_Idx_AGS[12]
    =
{
    0.0F, 20.0F, 60.0F, 100.0F, 180.0F, 269.0F, 357.0F, 446.0F, 529.0F, 601.0F,
    658.0F, 720.0F
} ;                                    /* Referenced by: '<S5483>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_Pct_LTR_Airflow_Idx_AGSOpen[13] =
{
    0.0F, 170.0F, 182.0F, 215.0F, 265.0F, 329.0F, 403.0F, 481.0F, 561.0F, 637.0F,
    706.0F, 764.0F, 844.0F
} ;                                    /* Referenced by: '<S5484>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_Pct_LTR_FanPWM_Req[13] =
{
    0.1F, 450.0F, 1078.0F, 1079.0F, 1438.0F, 1798.0F, 2157.0F, 2517.0F, 2876.0F,
    3236.0F, 3416.0F, 3596.0F, 3955.0F
} ;                                    /* Referenced by: '<S5610>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_Pct_OHX_AGSPos_Req[13] =
{
    0.1F, 450.0F, 1078.0F, 1079.0F, 1438.0F, 1798.0F, 2157.0F, 2517.0F, 2876.0F,
    3236.0F, 3416.0F, 3596.0F, 3955.0F
} ;                                    /* Referenced by: '<S5612>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_Pct_OHX_FanPWM_Req[13] =
{
    0.1F, 450.0F, 1078.0F, 1079.0F, 1438.0F, 1798.0F, 2157.0F, 2517.0F, 2876.0F,
    3236.0F, 3416.0F, 3596.0F, 3955.0F
} ;                                    /* Referenced by: '<S5613>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_P1MotorReqDsbl

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_Pct_P1Motor_Airflow_Idx_AGS[12] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 95.0F,
    100.0F
} ;                                    /* Referenced by: '<S5499>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_P1MotorReqDsbl

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_Pct_P1Motor_Airflow_Idx_AGSOpen[13] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 92.0F,
    95.0F, 100.0F
} ;                                    /* Referenced by: '<S5500>/Vector' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_Pct_PPU_Airflow_Idx_AGS[13]
    =
{
    0.0F, 143.0F, 228.0F, 372.0F, 668.0F, 1013.0F, 1389.0F, 1768.0F, 2140.0F,
    2483.0F, 2777.0F, 3003.0F, 3492.0F
} ;                                    /* Referenced by: '<S5506>/Vector' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_Pct_PPU_Airflow_Idx_AGSOpen[13] =
{
    0.0F, 429.0F, 1088.0F, 1254.0F, 1493.0F, 1787.0F, 2119.0F, 2469.0F, 2819.0F,
    3152.0F, 3449.0F, 3692.0F, 4097.0F
} ;                                    /* Referenced by: '<S5507>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_T_BattClntMaxTgt[7] =
{
    -40.0F, -30.0F, -20.0F, -10.0F, 0.0F, 10.0F, 25.0F
} ;                                    /* Referenced by: '<S367>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_T_BattClntMinTgt[7] =
{
    -40.0F, -30.0F, -20.0F, -10.0F, 0.0F, 10.0F, 25.0F
} ;                                    /* Referenced by: '<S368>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_T_CellTempMaxAllow[6] =
{
    0.0001F, 20.0F, 30.0F, 35.0F, 40.0F, 45.0F
} ;                                    /* Referenced by: '<S372>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_T_ChrgLvlBasedAmbTemp[5] =
{
    20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S4875>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_T_PsvCool_BTISMaxAllwd[5] =
{
    -10.0F, 0.0F, 10.0F, 20.0F, 30.0F
} ;                                    /* Referenced by: '<S4877>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dQ_FrontEDM_ActHeat[11] =
{
    0.0F, 1500.0F, 3000.0F, 4500.0F, 6000.0F, 7500.0F, 9000.0F, 10500.0F,
    12000.0F, 13500.0F, 15000.0F
} ;                                    /* Referenced by: '<S2877>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dQ_FrontEDM_HeatLoss[11] =
{
    0.0F, 1500.0F, 3000.0F, 4500.0F, 6000.0F, 7500.0F, 9000.0F, 10500.0F,
    12000.0F, 13500.0F, 15000.0F
} ;                                    /* Referenced by: '<S2431>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dQ_GEN_ActHeat[11] =
{
    0.0F, 1500.0F, 3000.0F, 4500.0F, 6000.0F, 7500.0F, 9000.0F, 10500.0F,
    12000.0F, 13500.0F, 15000.0F
} ;                                    /* Referenced by: '<S2879>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dQ_RearEDM_ActHeat[11] =
{
    0.0F, 1500.0F, 3000.0F, 4500.0F, 6000.0F, 7500.0F, 9000.0F, 10500.0F,
    12000.0F, 13500.0F, 15000.0F
} ;                                    /* Referenced by: '<S2881>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dQ_RearEDM_HeatLoss[11] =
{
    0.0F, 1500.0F, 3000.0F, 4500.0F, 6000.0F, 7500.0F, 9000.0F, 10500.0F,
    12000.0F, 13500.0F, 15000.0F
} ;                                    /* Referenced by: '<S2432>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dT_CondAirWarmupEst[6] =
{
    0.0F, 5.5F, 10.5F, 20.0F, 24.0F, 29.0F
} ;                                    /* Referenced by: '<S749>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dT_LTRAirWarmupEst[6] =
{
    -10.0F, 10.0F, 30.0F, 45.0F, 60.0F, 70.0F
} ;                                    /* Referenced by: '<S750>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dV_BattRad_AirFlowRaw[8] =
{
    150.0F, 200.0F, 250.0F, 300.0F, 350.0F, 400.0F, 450.0F, 500.0F
} ;                                    /* Referenced by: '<S3112>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dV_ClngFlowRqrdMtr1[8] =
{
    0.001F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 100.0F
} ;                                    /* Referenced by: '<S682>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_dV_ClngFlowRqrdMtr1_Reverse[8] =
{
    0.001F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 100.0F
} ;                                    /* Referenced by: '<S677>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dV_ClngFlowRqrdMtr2[8] =
{
    0.001F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 100.0F
} ;                                    /* Referenced by: '<S705>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_dV_ClngFlowRqrdMtr2_Reverse[8] =
{
    0.001F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 100.0F
} ;                                    /* Referenced by: '<S700>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dV_EstAirflow_Max[4] =
{
    7.0F, 11.0F, 50.0F, 80.0F
} ;                                    /* Referenced by: '<S5515>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dV_FC_HTR_AirFlowRaw[8] =
{
    15.0F, 20.0F, 25.0F, 30.0F, 35.0F, 40.0F, 45.0F, 50.0F
} ;                                    /* Referenced by: '<S863>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dV_HT_AuxPmpFlwForActvCool
    [5] =
{
    5.0F, 10.0F, 15.0F, 20.0F, 25.0F
} ;                                    /* Referenced by: '<S1929>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dV_HeadPresAir_Flow[8] =
{
    0.001F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 100.0F
} ;                                    /* Referenced by: '<S2822>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dV_HeatPumpAir_Flow[8] =
{
    0.001F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 100.0F
} ;                                    /* Referenced by: '<S2823>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dV_LTR_AirFlowRaw[8] =
{
    0.001F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 100.0F
} ;                                    /* Referenced by: '<S2824>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dV_MGU_ClntPumpFlw[8] =
{
    0.001F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 100.0F
} ;                                    /* Referenced by: '<S2825>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dV_MinAchvblArflwEst_Ohx[7]
    =
{
    0.0F, 5.0F, 10.0F, 20.0F, 30.0F, 50.0F, 100.0F
} ;                                    /* Referenced by: '<S5516>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_dV_P1Motor_AirFlowRaw[8] =
{
    0.001F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 100.0F
} ;                                    /* Referenced by: '<S2826>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_dV_TransOilCooler_ClntFlw_Front_EDM[8] =
{
    -40.0F, -20.0F, -10.0F, 0.0F, 25.0F, 50.0F, 75.0F, 90.0F
} ;                                    /* Referenced by: '<S2942>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_dV_TransOilCooler_ClntFlw_GEN[8] =
{
    -40.0F, -20.0F, -10.0F, 0.0F, 25.0F, 50.0F, 75.0F, 90.0F
} ;                                    /* Referenced by: '<S2943>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_dV_TransOilCooler_ClntFlw_Rear_EDM[8] =
{
    -40.0F, -20.0F, -10.0F, 0.0F, 25.0F, 50.0F, 75.0F, 90.0F
} ;                                    /* Referenced by: '<S2944>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_DHiTRegFuCellDft_M[7] =
{
    -30.0F, -15.0F, -5.0F, 0.0F, 15.0F, 25.0F, 45.0F
} ;                                    /* Referenced by: '<S975>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_DHiTRegFuCell_M[7] =
{
    -30.0F, -15.0F, -5.0F, 0.0F, 15.0F, 25.0F, 45.0F
} ;                                    /* Referenced by: '<S972>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_FCAirflw_Ki[6] =
{
    -10.0F, -5.0F, 0.0F, 1.0F, 20.0F, 50.0F
} ;                                    /* Referenced by: '<S885>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_FCAirflw_Kp[6] =
{
    -10.0F, -5.0F, 0.0F, 1.0F, 20.0F, 50.0F
} ;                                    /* Referenced by: '<S886>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_FCPropVlv_Ki[6] =
{
    -50.0F, -20.0F, -1.0F, 0.0F, 5.0F, 10.0F
} ;                                    /* Referenced by: '<S780>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_FCPropVlv_Kp[6] =
{
    -50.0F, -20.0F, -1.0F, 0.0F, 5.0F, 10.0F
} ;                                    /* Referenced by: '<S781>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_HeatTranCoefOutRadHiT1_M
    [7] =
{
    5000.0F, 10000.0F, 15000.0F, 20000.0F, 30000.0F, 40000.0F, 50000.0F
} ;                                    /* Referenced by: '<S1012>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_HeatTranCoefOutRadHiT2_M
    [7] =
{
    0.0F, 0.5F, 1.0F, 2.0F, 3.0F, 4.0F, 6.0F
} ;                                    /* Referenced by: '<S1013>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_HeatTranCoefOutRadHiT3_M
    [7] =
{
    0.0F, 10.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S1014>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_HiTSpdFanReq_M[9] =
{
    0.0F, 0.5F, 1.0F, 1.5F, 2.0F, 2.5F, 3.0F, 3.5F, 4.0F
} ;                                    /* Referenced by: '<S1076>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_HiTSpdFanSysReqTrimMin_M
    [7] =
{
    5000.0F, 10000.0F, 15000.0F, 20000.0F, 25000.0F, 30000.0F, 35000.0F
} ;                                    /* Referenced by: '<S1086>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_IHiTRegFuCellDft_M[7] =
{
    -30.0F, -15.0F, -5.0F, 0.0F, 15.0F, 25.0F, 45.0F
} ;                                    /* Referenced by: '<S976>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_IHiTRegFuCell_M[7] =
{
    -30.0F, -15.0F, -5.0F, 0.0F, 15.0F, 25.0F, 45.0F
} ;                                    /* Referenced by: '<S973>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_k_LoopPriorty_BTCLWsteHeatRcvryHP[6] =
{
    10.0F, 20.0F, 25.0F, 30.0F, 36.0F, 39.0F
} ;                                    /* Referenced by: '<S5065>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_k_LoopPriorty_BattActvPsvHeat[6] =
{
    -10.0F, -5.0F, 0.0F, 1.0F, 20.0F, 50.0F
} ;                                    /* Referenced by: '<S5050>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_k_LoopPriorty_CabActvPsvHeat[6] =
{
    -10.0F, -5.0F, 0.0F, 1.0F, 20.0F, 50.0F
} ;                                    /* Referenced by: '<S5060>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_k_LoopPriorty_CabActvPsvHeat_HP[6] =
{
    10.0F, 20.0F, 50.0F, 60.0F, 66.0F, 70.0F
} ;                                    /* Referenced by: '<S5061>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_PHiTRegFuCellDft_M[7] =
{
    -30.0F, -15.0F, -5.0F, 0.0F, 15.0F, 25.0F, 45.0F
} ;                                    /* Referenced by: '<S977>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_PHiTRegFuCell_M[7] =
{
    -30.0F, -15.0F, -5.0F, 0.0F, 15.0F, 25.0F, 45.0F
} ;                                    /* Referenced by: '<S974>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_PwrFuCellMaxLimThStep_M[2]
    =
{
    0.0F, 1.0F
} ;                                    /* Referenced by: '<S1053>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_SpdAirHiTSysReq_M[9] =
{
    -4.0F, -3.0F, -2.0F, -1.0F, 0.0F, 1.0F, 2.0F, 3.0F, 4.0F
} ;                                    /* Referenced by: '<S1089>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT)
    KyTHMR_k_WaPmpFuCellPwrMaxLimThReq_M[5] =
{
    -0.8F, -0.6F, -0.4F, -0.2F, -0.1F
} ;                                    /* Referenced by: '<S922>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_WaPmpFuCellReg_M[7] =
{
    -3.0F, -2.0F, -1.0F, 0.0F, 1.0F, 2.0F, 3.0F
} ;                                    /* Referenced by: '<S923>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_WaPmpFuCellReq_M[7] =
{
    0.0F, 10.0F, 25.0F, 50.0F, 75.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S924>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_k_WaPmpFuCellTDeltaReq_M[5]
    =
{
    -4.0F, -3.0F, -2.0F, -1.0F, 6.0F
} ;                                    /* Referenced by: '<S925>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_n_AirHiTNomReq_M[7] =
{
    5000.0F, 10000.0F, 15000.0F, 20000.0F, 25000.0F, 30000.0F, 35000.0F
} ;                                    /* Referenced by: '<S1079>/Vector' */

#endif

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_n_HghSOC_LwTmp_BattRng[6] =
{
    65.0F, 70.0F, 75.0F, 80.0F, 81.0F, 90.0F
} ;                                    /* Referenced by: '<S1727>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_n_P1Motor_EngSpdInc[7] =
{
    -40.001F, 0.0F, 40.0F, 60.0F, 80.0F, 100.0F, 150.0F
} ;                                    /* Referenced by: '<S2856>/Vector' */

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_r_EnblBattCabPrty_BlwrAmb[6]
    =
{
    20.0F, 30.0F, 40.9F, 41.0F, 42.0F, 45.0F
} ;                                    /* Referenced by: '<S419>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static volatile CONST(float32, THMR_VAR_INIT) KyTHMR_t_FuCellPwrLimTh_M[2] =
{
    0.0F, 1.0F
} ;                                    /* Referenced by: '<S1054>/Vector' */

#endif

#define STOP_SEC_CALIB_UNSPECIFIED_THMR
#include "MemMap.h"
#define START_SEC_CONST_UNSPECIFIED_THMR
#include "MemMap.h"

/* Definition for custom storage class: FCALocalConstant */
static volatile CONST(uint8, THMR_VAR_INIT) CeTHMR_i_FlowReqBrnchSel[19] =
{
    1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U, 12U, 13U, 14U, 15U, 16U, 17U,
    18U, 19U
} ;                                    /* Referenced by: '<S3003>/Calib' */

#define STOP_SEC_CONST_UNSPECIFIED_THMR
#include "MemMap.h"
#define START_SEC_VAR_CLEARED_UNSPECIFIED_THMR
#include "MemMap.h"

/* Definition for custom storage class: FCALocalSignal */
static VAR(boolean, THMR_VAR_INIT) VaTHMR_b_HTAP_TempSrc_FAMatrix[3];/* '<S1889>/SignalConversion' */
static VAR(float32, THMR_VAR_INIT) VaTHMR_k_LQGHTLStates[6];/* '<S2034>/UnitDelay' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Cnt_VehThermSt;/* '<S506>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_I_ChrgCrntReqDelta_AD;/* '<S49>/Switch1' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_RacePrepCrrntLim

static VAR(float32, THMR_VAR_INIT) VeTHMR_I_RacePrepCurrentLim;/* '<S73>/Switch2' */

#endif

static VAR(sint16, THMR_VAR_INIT) VeTHMR_K_BattAllowedIndex;/* '<S4225>/Gain' */
static VAR(sint16, THMR_VAR_INIT) VeTHMR_K_BattCoolIndex;/* '<S4223>/Gain' */
static VAR(sint16, THMR_VAR_INIT) VeTHMR_K_BattHeatIndex;/* '<S4224>/Gain' */
static VAR(sint16, THMR_VAR_INIT) VeTHMR_K_CabAllowed_Index;/* '<S4321>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_K_ECHCntrlKi;/* '<S1269>/Merge1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_K_ECHCntrlKp;/* '<S1269>/Merge' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_K_Index_T3_AS;/* '<S1834>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_M_MtrA_TorqAchieved;/* '<S3755>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_M_MtrA_TorqCmnd;/* '<S3754>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_M_MtrB_TorqAchieved;/* '<S3762>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_M_MtrB_TorqCmnd;/* '<S3761>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_M_MtrC_TorqAchieved;/* '<S3769>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_M_MtrC_TorqCmnd;/* '<S3768>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_ActvTotPwr;/* '<S1716>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_AdjstdHtrWishd_Pwr;/* '<S1730>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_AdjstdHtrWishd_Pwr_New;/* '<S1777>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_AdjstdHtrWishd_Pwr_old;/* '<S1728>/Merge' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_AvalPwrForThmr;/* '<S545>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_BCHHtrPwrReq;/* '<S3158>/MinMax' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_BCHHtrPwrReq_BCHWishedPwrLim;/* '<S3158>/MinMax1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_BCHWishedPower;/* '<S3158>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_BCHWishedPowerLim;/* '<S3179>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_BTLHtrMBC;/* '<S3142>/Sum3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_BTLHtrMBC_BfGrdLim;/* '<S3156>/Product' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_BattHtrPwrTgt_Lmtd;/* '<S3171>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Batt_HeatPwr_Raw;/* '<S3190>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_CabHtr_PwrRqst_HeatState;/* '<S1164>/Merge' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_CabPwrNeed_NormlRaw_0;/* '<S1265>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_CabPwrNeed_NormlRaw_PI;/* '<S1309>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_CabPwrNeed_Raw_0;/* '<S1212>/Merge' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Cab_HeatPwr_Raw;/* '<S1946>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Cab_N_Bat_HeatPwrTot_Limtd;/* '<S1953>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Cab_N_Bat_HeatPwrTot_Raw;/* '<S1162>/Subtraction2' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_CabinHeatPwrNeed_BD;/* '<S1222>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_CabinPwrNeed_BG;/* '<S1310>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_CabinPwrNeed_BlwrFlowMin;/* '<S1241>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_CabinPwrNeed_Raw;/* '<S1211>/MinMax2' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_CabinPwrNeed_RawLmtd0;/* '<S1226>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_CabinPwrNeed_RegFlow;/* '<S1243>/Switch3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_ChrgThermBdgt_AfterDial;/* '<S4058>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_ClntHeatAbsrbFrmEDU_Arb;/* '<S2416>/Switch1' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_P_DetMtrClng_Mtr1PwrLoss;/* '<S683>/Subtraction1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_P_DetMtrClng_Mtr2PwrLoss;/* '<S695>/Subtraction1' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_P_ECH_HtrPwrTgt_B4D;/* '<S1424>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_ECH_HtrPwrTgt_FuelEcnmy;/* '<S1641>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_ECH_HtrPwrTgt_Lim_APerWp;/* '<S1154>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_ECH_HtrPwrTgt_Lim_B4PWup;/* '<S1470>/SignalConversion' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_ECH_HtrPwrTgt_a;/* '<S1470>/Merge' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_ECH_HtrPwrTgt_b;/* '<S1598>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_ECH_HtrPwrTgt_c;/* '<S1605>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_ECH_HtrPwrTgt_d;/* '<S1612>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_ECH_HtrPwrTgt_e;/* '<S1642>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_ECH_HtrPwrTgt_f;/* '<S1644>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_ECH_HtrPwrTgt_g;/* '<S1652>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_ECH_HtrPwrTgt_h;/* '<S1660>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_EDUHeatAbsrbdByClnt_SpcfcHeatChng;/* '<S2407>/Product' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_EDUHeatLosstoAmb;/* '<S2408>/Product5' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_EDU_Heat_Battery_Available_B4Grd;/* '<S2448>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_EDU_Heat_Cabin_AvailableB4Grd;/* '<S2450>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_EngHeatngPwr;/* '<S1945>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_EngPwrWaste_AvailbRaw;/* '<S1688>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_EngPwrWaste_AvailbRaw_Unfltrd;/* '<S1472>/Switch8' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_EngPwrWaste_EngHot;/* '<S1715>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_EngPwrWaste_EngOn;/* '<S1714>/Vector' */
static VAR(float32, THMR_VAR_INIT)
    VeTHMR_P_FEDMHeatAbsrbdByClnt_ThrmlEnrgyBalnce;/* '<S2413>/Merge_Outport_64' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_P_FuCellMaxLimThStMch;
                                   /* '<S950>/ElVlv_3_Way_FuCell_PwrMaxLimTh' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_P_FuCellMaxLimThStep;/* '<S950>/Product2' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_P_HTCLTempMitgatn_HtrDRtPwr;/* '<S1433>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_HTLHeaterFLCReq;/* '<S2058>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_HTLHeaterFLCReq_B4Set;/* '<S2068>/Sum3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_HTLHeaterLQGReq;/* '<S2057>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_HTLHeaterLQGReq_B4Set;/* '<S2062>/Sum3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_HTLHeaterLQGReq_BfGrdLim;/* '<S2082>/Product' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_HTLHeaterLQGReq_BfGrdLimDlyd;/* '<S2055>/UnitDelay1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_HVC_BattHtrPwr_AD;/* '<S3159>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_HtrWishdPwr_Expctd;/* '<S1742>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_HtrWishdPwr_Init;/* '<S1743>/Switch1' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static VAR(float32, THMR_VAR_INIT) VeTHMR_P_LQGECH_MBCHTLLTL;/* '<S3249>/Sum3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static VAR(float32, THMR_VAR_INIT) VeTHMR_P_LQGECH_MBCHTLLTL_BfGrdLim;/* '<S3336>/Product' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_P_MBC_FBL_HtrPwr;/* '<S2096>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_MaxPowerHCCTIS;/* '<S1270>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnzt3_Htr2Pwr;/* '<S4162>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnztn1_Htr1Pwr;/* '<S4140>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnztn1_Htr2Pwr;/* '<S4160>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnztn1_Htr3Pwr;/* '<S4180>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnztn1_Htr4Pwr;/* '<S4200>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnztn2_Htr1Pwr;/* '<S4138>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnztn2_Htr2Pwr;/* '<S4158>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnztn2_Htr3Pwr;/* '<S4178>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnztn2_Htr4Pwr;/* '<S4198>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnztn3_Htr1Pwr;/* '<S4142>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnztn3_Htr3Pwr;/* '<S4182>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnztn3_Htr4Pwr;/* '<S4202>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnztn4_Htr1Pwr;/* '<S4144>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnztn4_Htr2Pwr;/* '<S4164>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnztn4_Htr3Pwr;/* '<S4184>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Mechnztn4_Htr4Pwr;/* '<S4204>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_MinCabPwrNeed_NormlRaw_PI;/* '<S1256>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_MinCabinPwrNeed_BG;/* '<S1257>/Switch3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_MtrAElecPwrCalcTot;/* '<S3777>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_MtrBElecPwrCalcTot;/* '<S3782>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_MtrCElecPwrCalcTot;/* '<S3789>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_NoMechnztn_Htr1Pwr;/* '<S4136>/ConstantValue1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_NoMechnztn_Htr2Pwr;/* '<S4156>/ConstantValue1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_NoMechnztn_Htr3Pwr;/* '<S4176>/ConstantValue1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_NoMechnztn_Htr4Pwr;/* '<S4196>/ConstantValue1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_PerWpCond_EngHeatPwr_Need;/* '<S1952>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_PerWp_HtrPwrTgt_Lim;/* '<S1471>/Merge' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_PwrAvaiConstraint;/* '<S1472>/Subtraction2' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_PwrAvaiConstraint_1;/* '<S1472>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_PwrBdgt_PwrLimitAvail_BD;/* '<S4547>/Switch1' */
static VAR(float32, THMR_VAR_INIT)
    VeTHMR_P_REDMHeatAbsrbdByClnt_ThrmlEnrgyBalnce;/* '<S2443>/Merge_Outport_64' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_Rear_HeatPwr;/* '<S1947>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_SharedBatt_HeatPwr_Raw;/* '<S1944>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_WCondWasteHeat_Avail_B4Grd;/* '<S2110>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_P_WCondWasteHeat_Net;/* '<S2108>/Product' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_BattCPV_PosReq;/* '<S2281>/Merge2' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_BattRad_Aiflow_AGS;/* '<S5431>/Selector1' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_BattRad_MaxFanSpeed_App;
                              /* '<S5364>/SigConvForSigProp_VariantSource3_0' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_CabVlvOpeng_Cmd;/* '<S1361>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_CabVlvOpeng_CmdRaw;/* '<S1348>/Product' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_ClntProp3WyVlv_Cmd_Raw;/* '<S1342>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_CndnsrPPU_AirFlwReq;
                              /* '<S5364>/SigConvForSigProp_VariantSource2_0' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_ECM_Aiflow_AGS;/* '<S5433>/Selector1' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_ECM_LTPsvPmpRq_AD;/* '<S107>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_ECM_MaxFanSpeed_App;
                              /* '<S5364>/SigConvForSigProp_VariantSource4_0' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_Emrgcy_NrmlzdFanSpeed;/* '<S5510>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_FBVlvLTR;/* '<S3090>/Gain' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_FCVlv_Balancing;/* '<S784>/Sum3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_FCVlv_PICmd;/* '<S782>/Switch' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_FC_HTR_Aiflow_AGS;/* '<S5434>/Selector1' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_FC_HTR_MaxFanSpeed_App;
                              /* '<S5364>/SigConvForSigProp_VariantSource1_0' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_Fan_ACP_SF;/* '<S5430>/Pct_Fan_Req_SF' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_Fan_ACP_SForThrshldOrgnl;/* '<S5430>/Switch5' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_HTLBypsVlv_Cmd;/* '<S1164>/Merge1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_HV_BatSOC;/* '<S244>/Switch' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_HeadPres_Aiflow_AGS;/* '<S5432>/Selector1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_HeadPres_MaxFanSpeed_App2;/* '<S5432>/MinMax2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_LQGLTRVlv_MBCHTLLTL;/* '<S3246>/Sum3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_LQGLTRVlv_MBCHTLLTL_BfGrdLim;/* '<S3339>/Product' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_LQGVHTL_MBCHTLLTL;/* '<S3250>/Sum3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_LQGVHTL_MBCHTLLTL_BfGrdLim;/* '<S3342>/Product' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_LQGVlvLTR;/* '<S3027>/Sum3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_LTRVlvDflt;/* '<S2293>/Merge2' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_LTRVlv_Balancing;/* '<S2794>/Sum3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_LTRVlv_PICmd;/* '<S2791>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_LTR_Aiflow_AGS;/* '<S5438>/Selector1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_LTR_MaxFanSpeed_App2;/* '<S5438>/MinMax1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_MaxFanSpeed_App2;/* '<S5364>/MinMax1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_Normlzd_Aftrrun;/* '<S5368>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_Normlzd_MaxFanSpeed_AftMax;/* '<S84>/MinMax2' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_Normlzd_MaxFanSpeed_B4D;/* '<S5396>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_NrmlzdFanSpd_LTRVlvCmd;/* '<S5386>/Vector' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_P1MotorReqDsbl

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_P1Motor_Aiflow_AGS;/* '<S5439>/Selector1' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_P1Motor_MaxFanSpeed_App2;
                               /* '<S5364>/SigConvForSigProp_VariantSource_0' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_PPU_Aiflow_AGS;/* '<S5440>/Selector1' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_PPU_MaxFanSpeed_App2;/* '<S5440>/MinMax2' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_Pct_RadFanSts_AftDial;/* '<S4016>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_APM2_Temp1;/* '<S3846>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_APM2_Temp2;/* '<S3852>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_APM3_Temp1;/* '<S3858>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_APM3_Temp2;/* '<S3864>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_APM_Temp1;/* '<S3871>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_APM_Temp2;/* '<S3878>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_AmbBasedOnVehSpd;/* '<S4813>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_BSG_ClntInTemp;/* '<S119>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_BSG_ClntOutTemp;/* '<S120>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_BSG_ClntOutTemp_AF;/* '<S140>/Switch5' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_BSG_ClntOutTemp_Fltr;/* '<S147>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_BSG_CntrlBoardTemp;/* '<S118>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_BSG_CntrlBoardTemp_AF;/* '<S126>/Switch5' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_BSG_CntrlBoardTemp_Fltr;/* '<S133>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_BSG_MtrCapctrTemp;/* '<S121>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_BSG_MtrRotorTemp;/* '<S117>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_BattClntMaxTgt;/* '<S367>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_CellTempMax;/* '<S4063>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_CellTempMin;/* '<S4082>/Gain' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_CoFuCellHiTInSp;/* '<S949>/Sum6' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_CoFuCellHiTInSpFil;/* '<S1020>/Gain' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_CoFuCellHiTInSpFilDFf;/* '<S981>/Product1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_CoFuCellHiTInSpFilFf;/* '<S988>/MinMax' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_CoFuCellHiTInSpFilFf_MP;/* '<S981>/Subtraction1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_CoFuCellHiTOutDelt;/* '<S1063>/Sum' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_CoFuCellHiTOutDelta;/* '<S994>/MinMax' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_CoFuCellHiTOutFil;/* '<S1021>/Switch2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_CoFuCellHiTOutSpFil;/* '<S1019>/Gain' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_CoFuCellHiTOutSpPwrLimOfs;/* '<S1018>/Switch1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_CoFuCellHiTSigOfs;/* '<S1001>/Switch3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_CoOutDeltaFuCellHiTHEX;/* '<S1100>/Gain' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_DifCoFuCellHiTOutSpDecHld_MP;/* '<S950>/Sum3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_DifFuCellInSpWaOutRadHiT;/* '<S999>/MinMax' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_DifWaOutRadFuCellOutHiT;/* '<S998>/MinMax' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_EngCoolantTemp;/* '<S3883>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_EstAmbAirTemp;/* '<S13>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_EstAmbAirTemp_Raw;/* '<S17>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_EstAmbAirTemp_Raw_B4D;/* '<S31>/Gain' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_FC_HTCLTgt_Arb;/* '<S729>/Subtraction17' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_FuCellHiTHEXIReg;/* '<S1126>/Switch2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_FuCellHiTHEXRegCtl;/* '<S1097>/MinMax' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_FuCellHiTHEXTInTarRegCtlFil;/* '<S1107>/Switch2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_FuCellHiTHEXTInTarRegCtlRaw;/* '<S905>/Switch2' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_HCCTISArb;/* '<S1800>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_HCCTOSArb;/* '<S1809>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_HCCTOS_Arb;/* '<S4404>/Add1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_HTAP_TmpIn;/* '<S1889>/Merge' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_HTCLHexInletTemp;/* '<S4416>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_HTLHeaterLQGIntgr;/* '<S2074>/Sum' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_HTLHeaterLQGIntgrDlyd;/* '<S2074>/UnitDelay' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_HTLHeaterLQGIntgr_Incr;/* '<S2074>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_HTLLQG_TrckError;/* '<S1170>/Sum1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_HTLPumpLQGIntgr;/* '<S2075>/Sum' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_HTLPumpLQGIntgrDlyd;/* '<S2075>/UnitDelay' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_HTLPumpLQGIntgr_Incr;/* '<S2075>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_HtrCorClnt_Tmp_In_AD;/* '<S82>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_InductionAirTemp_AD;/* '<S106>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_LTCLTemp4VlvCntrl;/* '<S5137>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_LTCLTgt_BattActvPsvHeating_B4D;/* '<S4627>/Sum2' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_LTCLVlvAllowTempDflt_Ambient;/* '<S5214>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_LTRInletTemp;/* '<S4111>/Switch2' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_LTRVlv_Tgt;/* '<S5133>/Merge' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_LTR_InletTemp;/* '<S4470>/Add1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MGU_AirInletTmp;/* '<S2804>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MGU_InvrtTmpCond;/* '<S2804>/Switch4' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MGU_InvrtTmpCond_Raw;/* '<S2840>/Sum3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MaxBattAllowPsv_NoOp;/* '<S373>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MinBattAllow_NewApp;/* '<S378>/Selector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MinBattAllow_OldApp;/* '<S377>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MtrA_InvrtrTemp;/* '<S3896>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MtrA_Temp;/* '<S3911>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MtrB_InvrtrTemp;/* '<S3903>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MtrB_Temp;/* '<S3917>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MtrC_CntrlBoardTemp;/* '<S3808>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MtrC_CntrlBoardTemp_AF;/* '<S3821>/Switch5' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MtrC_CntrlBoardTemp_Fltr;/* '<S3828>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MtrC_InvrtrTemp;/* '<S3805>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MtrC_RotorTemp;/* '<S3807>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_MtrC_Temp;/* '<S3806>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_P1P2p5_ClntOutTemp_AF;/* '<S177>/Switch5' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_P1P2p5_ClntOutTemp_Fltr;/* '<S184>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_P1P2p5_MtrB_ClntInTemp;/* '<S156>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_P1P2p5_MtrB_ClntOutTemp;/* '<S157>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp;/* '<S155>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp_AF;/* '<S163>/Switch5' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp_Fltr;/* '<S170>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_P1P2p5_MtrB_MtrCapctrTemp;/* '<S158>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_P1P2p5_MtrB_MtrRotorTemp;/* '<S154>/Switch1' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_PDCSurfTemp;/* '<S44>/Switch2' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_PPCTISTgt_Fan;/* '<S5122>/Switch6' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_Pump2OilTemp;/* '<S3931>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_T_PumpOilTemp;/* '<S3925>/Switch' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP;/* '<S991>/Multiport Switch' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_SumSampleFuCellHiToutGrd_MP;/* '<S968>/Multiport Switch' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_TransOilTemp;/* '<S3838>/Switch' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_WaFuCellDeltaDifSp;/* '<S902>/Subtraction4' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_WaFuCellDeltaT;/* '<S902>/Subtraction1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_WaFuCellPIDReg;/* '<S902>/Subtraction3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_WaFuCellPIDWaPmpReg;/* '<S931>/MinMax' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_WaFuCellPIDWaPmpRegRaw;/* '<S902>/Subtraction2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_WaOutRadHiTEstim;/* '<S1023>/Switch2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_WaOutRadHiTEstimRaw;/* '<S949>/MinMax3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_WaOutRadHiTFil;/* '<S1024>/Switch2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_T_iFuCellPwrLimTh;/* '<S950>/Gain2' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_U_HV_BatVolt_AD;/* '<S224>/Switch' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_AAD_RetrctArb;/* '<S37>/Logical4' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_AAD_RetrctReq_B4D;/* '<S37>/Logical1' */

#endif

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_AC_CompReq;/* '<S3947>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_AHPInletTempArb_FA;/* '<S1881>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_APM2_Temp1_FA;/* '<S3845>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_APM2_Temp2_FA;/* '<S3851>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_APM3_Temp1_FA;/* '<S3857>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_APM3_Temp2_FA;/* '<S3863>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_APM_Temp1_FA;/* '<S3870>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_APM_Temp2_FA;/* '<S3877>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_AftrRunFanRq_SF;/* '<S3615>/AND' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_AllPropValves;/* '<S599>/Logical' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_All_Prop_Vlv_Unpwrd;/* '<S592>/Logical' */

#endif

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_AlternatorMode_Actv;/* '<S4227>/Logical1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_AmbCabHeat_EngAllwd_AD;/* '<S1478>/Logical1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_AmbChk_PsvCool;/* '<S4814>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_AmbHardCab_HeatEngAllwd_AD;/* '<S1478>/Logical3' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_AmznDrvDprt;/* '<S38>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BCHWshdPwrInitlzd;/* '<S3185>/AND' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BCH_HtrFlty;/* '<S3176>/LogicalOperator1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BCH_P0E19_DTCSet;/* '<S3201>/LogicalOperator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BCH_P1DE0_DTCSet;/* '<S3200>/Logical Operator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BCH_U04B8_DTCSet;/* '<S3204>/LogicalOperator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BCH_U1008_DTCSet;/* '<S3202>/Logical Operator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BCH_U1009_DTCSet;/* '<S3203>/Logical Operator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BPCM_LIN_BusOff_FA;/* '<S227>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BPCM_LIN_BusOff_SgnlRcvd;/* '<S228>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BPCM_LOC_BCP_FA;/* '<S236>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BPCM_LOC_BCP_SgnlRcvd;/* '<S237>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BSG_ClntInTemp_FA;/* '<S119>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BSG_ClntOutTemp_FA;/* '<S120>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BSG_CntrlBoardTemp_FA;/* '<S118>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BSG_MtrCapctrTemp_FA;/* '<S121>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BSG_MtrRotorTemp_FA;/* '<S117>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BTIS_Amb_TempChk;/* '<S4844>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BTIS_PPCTIS_TempChk;/* '<S4842>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattActvPsvHeat;/* '<S4598>/Logical3' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattActvPsvHeat_Arb;/* '<S5056>/Gain' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattActvWasteheatRecvry_Req;/* '<S4734>/Logical5' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattActvWstHeatRcvry_Arb;/* '<S5051>/Gain' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattAllowed_B4D;/* '<S4098>/Logical5' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattAllowed_BS;/* '<S4098>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattAllowed_Cool;/* '<S4098>/Selector' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattAllowed_Heat;/* '<S4098>/Selector1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattAllowed_SeprtHtr;
                              /* '<S4226>/SigConvForSigProp_VariantSource1_0' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattAllowed_newtable;/* '<S4098>/Selector2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattCondEmergencyCool;/* '<S4735>/Logical1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattCondNew_BS;/* '<S4733>/Logical5' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattCondPlugin_Rq_BD;/* '<S208>/Logical' */

#endif

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattConditioning;/* '<S4347>/Logical8' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattCoolFlts_AllowRA_PsvCooling;
                                /* '<S261>/SigConvForSigProp_VariantSource_0' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattHTCLMixClnt_HeatReq;/* '<S4628>/Logical13' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattOpt_MoreTocab;/* '<S1178>/Logical3' */

#endif

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattPassiveCool;/* '<S4736>/Logical5' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattPassiveCool_Arb;/* '<S5055>/Gain' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattPassiveHeat;/* '<S4599>/Logical5' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattPassiveHeat_Arb;/* '<S5054>/Gain' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattPriorityOvercabin;/* '<S5286>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattPsvCoolDbnc;/* '<S4814>/Logical4' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_BattPsvHeat_CellTempChk;/* '<S4678>/LogicalOperator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabActvCool;/* '<S4918>/LogicalOperator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabActvHeat;/* '<S4919>/LogicalOperator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabActvPsvHeat;/* '<S4920>/LogicalOperator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabActvPsvHeat_Arb;/* '<S5052>/Gain' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabAllowCond;/* '<S4091>/Logical1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabAllowCond_0;/* '<S4091>/Logical2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabAllowed_B4D;/* '<S4251>/Selector' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabAllowed_BS;/* '<S4251>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabHeatPumpAllow;/* '<S4118>/LogicalOperator1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabHeatPumpAllowOhx;/* '<S4922>/LogicalOperator4' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabHeatPumpAllow_Ohx;/* '<S4982>/LogicalOperator9' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabHeatPumpAllow_Raw;/* '<S4922>/LogicalOperator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabHeatReq_Chk;/* '<S4250>/Logical4' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabHeatReq_NotAllow_0;/* '<S4253>/Logical1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabHeatReq_NotAllow_SOC;/* '<S4250>/Logical2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabRejFlag;/* '<S4254>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabReq_NotAllow_KeyOff_Acc;/* '<S4336>/Logical2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabReq_NotAllow_Key_RUN;/* '<S4337>/Logical1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabReq_NotAllow_SOC_OutOfFuel;/* '<S4334>/Logical2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabReq_NotAllow_SOC_Wall;/* '<S4335>/Logical2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CabinHeatEng_Allwd_AD;/* '<S1462>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CellMaxAbvMaxAllw;/* '<S4211>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CellMax_ActvCool;/* '<S4733>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CellMax_AmbTmpChk;/* '<S4846>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CellMax_BTISChk;/* '<S4841>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CellMax_PPCTISChk;/* '<S4840>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ChillVlvCktHi;/* '<S4751>/LogicalOperator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ClntChck_BatActvPsvHeat;/* '<S4647>/LogicalOperator1' */
static VAR(TeHCDR_e_BatteryThermalFault, THMR_VAR_INIT) VeTHMR_b_CompFlts;/* '<S2158>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CompressorFlts;/* '<S4738>/Logical9' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CompressorReqOn_0;/* '<S4101>/Logical4' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_CompressorReqOn_BS;/* '<S4385>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_DeIceDurationOn;/* '<S5000>/OR1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_DeIceStarted;/* '<S4985>/Logical4' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_DeIcingCmplt;/* '<S4985>/Logical9' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Defrost;/* '<S2160>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_DefrostVhclMode_AfterDial;/* '<S402>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_DrvDrAjar_AD;/* '<S3943>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ECHHeatReq;/* '<S1214>/LogicalOperator1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ECHWshdPwrInitialized;/* '<S1788>/AND' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ECM_LTPsvPmpRq_FA_AD;/* '<S107>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ECT_Sgnl_Rcvd;/* '<S3883>/Switch2' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EOP_Enbl;/* '<S711>/Switch1' */

#endif

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ESSR_EngOff;/* '<S4545>/Comparison9' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ElVlv3WayFuCell_Int_Hld;/* '<S965>/Logical Operator7' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ElVlv3WayReqDetDec;/* '<S963>/AND' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ElVlv3WayReqDetInc;/* '<S962>/AND' */

#endif

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EmergencyCool;/* '<S4735>/Logical6' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EmrgcyFanRq_Lv1;/* '<S2469>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EmrgcyFanRq_Lvl1_0;/* '<S2469>/Logical1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EmrgcyFanRq_Lvl2;/* '<S2470>/Logical1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EnblHVACPriorty;/* '<S403>/Logical1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EnblMinPwrFlow;/* '<S1218>/Logical' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EnblNormPwrFlow;/* '<S1212>/Logical11' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EnblPctPwrBasdCntrl;/* '<S1212>/Logical7' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Enbl_Ua;/* '<S1559>/Logical4' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Enbl_Ub;/* '<S1559>/Logical8' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Enbl_Uc;/* '<S1559>/Logical16' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Enbl_Ud;/* '<S1559>/Logical22' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Enbl_Ue;/* '<S1559>/Logical27' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Enbl_Uf;/* '<S1559>/Logical31' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Enbl_Ug;/* '<S1559>/Logical32' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EngAllow_HeatReq_HtrFlty_RA;/* '<S1497>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EngAllow_HeatReq_HtrFlty_RA_B4_Sw;/* '<S1497>/LogicalOperator1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EngCoolantTemp_FA;/* '<S3883>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EngOnReq_BattCritical_mHEV;/* '<S1153>/LogicalOperator2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EngOnReq_BattLoopEmrgncyCool_mHEV;/* '<S1153>/LogicalOperator1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EngPwrWaste_NonZero;/* '<S1472>/Logical3' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EngReq_HtrFlty_RA;/* '<S1497>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EngReq_HtrFlty_RA_B4D;/* '<S1542>/GreaterThan1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_EngSysLowFuel_AD;/* '<S3949>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_FCPsvCool_Req;/* '<S5074>/Logical5' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_FC_ActvPsvHeat_Req;/* '<S5091>/Logical2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_FC_BoostCool;/* '<S5073>/Logical1' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_FanReqOff;/* '<S1092>/AND' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Fan_ACP_pct_OrgnlOrNew;/* '<S5430>/Comparison4' */

#endif

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Flashing_Flag_AD;/* '<S4017>/Switch' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_FuCellHiTHEX_Int_Hld;/* '<S1098>/Logical Operator3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_FullBatt;/* '<S1175>/Logical' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_FullToCabin;/* '<S1181>/Logical8' */

#endif

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HCCT_ErrLargNegativ;/* '<S1550>/Logical2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HCP_LTP_FanAftRun_Rq_BD_SF;/* '<S3616>/AND' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HTAPFunPer_FltDtct_AD;/* '<S3996>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HTAuxPmpDryRunFA_AD;/* '<S3792>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HTAuxPump_FltDtctd_AD;/* '<S3995>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HTCV_LearnCheckd;/* '<S2120>/Logical2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HTCV_LearnCheckdRaw;/* '<S2120>/Logical3' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HTLHeaterLQGIntgr_Enbl;/* '<S2074>/Logical1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HTLPumpLQGIntgr_Enbl;/* '<S2075>/Logical1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HTSOV_Cmd_HeatState;/* '<S1164>/Merge3' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HTSOV_DelydOpn_1e;/* '<S1622>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HTSOV_DelydOpn_2e;/* '<S1555>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HTSO_VlvCmdAPerWp;/* '<S1154>/Switch3' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HT_AuxPmp_NotPerWup;/* '<S1879>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HT_CabVlvSts_FA_AD;/* '<S3999>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HT_Shtoff_VlvCmd;
                               /* '<S5644>/SigConvForSigProp_VariantSource_0' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HT_Shtoff_VlvCmd_B4D;/* '<S1440>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HT_Shtoff_VlvCmd_B4PWup;/* '<S1470>/Merge2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HVACPrrtyVhcleMode_AfterDial;/* '<S403>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HVAC_turnedOff_B4D;/* '<S4250>/Logical3' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HVC_BattHtrReqstd_StaFlow_AD;/* '<S3159>/Switch6' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HVC_BattHtrReqstd_StaFlow_Raw;/* '<S3165>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HVC_HtrReqstd_StaFlow_AD;/* '<S1159>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HVC_HtrReqstd_StaFlow_Raw;/* '<S1411>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HV_BatRdy_AD;/* '<S225>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HardCabHeatEng_Allwd_AD;/* '<S1478>/Logical4' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HeatReqTmrEnbld_HtrFlty_RA;/* '<S1541>/OR1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HghRfrgtPresFA_Arb;/* '<S301>/Switch1' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HiTPreHeatFuCell;/* '<S1098>/Logical Operator11' */

#endif

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HighVoltageRapidShtdwnCmnd_AD;/* '<S3941>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HtrCorClnt_Tmp_In_FA_AD;/* '<S82>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HtrWishdPwr_LwClntTmp;/* '<S1740>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_HtrWishdPwr_StillNotAval;/* '<S1740>/Logical1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_IceDetectedOHX;/* '<S4985>/Logical1' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblRA_BattCoolingFlt_PsvCool

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_InhibitRA4PsvCool_Flts;/* '<S278>/LogicalOperator2' */

#endif

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_InitWishPwr_StartUpEnb;/* '<S1748>/GreaterThan1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_InitWishdPwr_Enb;/* '<S1768>/Gain' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_KeyInRun;/* '<S4337>/Comparison1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_KeyXstnOffThisCycle;/* '<S3646>/OR1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_LTActPump_FltDtctd_AD;/* '<S3994>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_LTCLActvWstHeatRcvry_Arb;/* '<S5053>/Gain' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_LTPsvPump2Temp_FA_AD;/* '<S3998>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_LTPsvPump2_FltDtctd_AD;/* '<S3993>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_LTPsvPumpTemp_FA_AD;/* '<S3997>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_LTPsvPump_FltDtctd_AD;/* '<S3992>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_LearningOk;/* '<S2120>/Logical1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_LowPPCTIS_PsvCool;/* '<S4818>/Logical13' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_MainPmpCav_CondMet;/* '<S1450>/Logical3' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_MoreToBatt;/* '<S1183>/Logical3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_MoreToCabin;/* '<S1184>/Logical3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Mtr1_ClgRvrs_Hyst;/* '<S673>/Switch1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Mtr2_ClgRvrs_Hyst;/* '<S696>/Switch1' */

#endif

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_MtrA_InvrtrTempFA;/* '<S3895>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_MtrA_TempFA;/* '<S3910>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_MtrB_InvrtrTempFA;/* '<S3902>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_MtrB_TempFA;/* '<S3916>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_MtrC_CntrlBoardTemp_FA;/* '<S3808>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_MtrC_InvrtrTempFA;/* '<S3805>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_MtrC_RotorTemp_FA;/* '<S3807>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_MtrC_TempFA;/* '<S3806>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_NewHeatReqReset_HtrFlty_RA;/* '<S1497>/LogicalOperator5' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_NoBattCoolPerfFlt;/* '<S4750>/RelationalOperator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_NoCabLoSOCPwrBdgt_BattCond;/* '<S4347>/Logical10' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_NoCabLoSOCPwrBdgt_NoBattCond;/* '<S4347>/Logical15' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_NoCab_LowSOC_PwrBdgt;/* '<S4347>/Logical16' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_NoEACPerfFlt;/* '<S4752>/Logical Operator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_NoEngReqP1P4;/* '<S1472>/LogicalOperator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_NoLOCEAC;/* '<S4753>/Logical Operator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_NoPresSnsrLoFlt;/* '<S4748>/Logical Operator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_NoPresSnsrPerfFlt;/* '<S4749>/Logical Operator' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_NoPriority;/* '<S1175>/Logical1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_OnlyVlv1;/* '<S593>/Logical' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_OnlyVlv2;/* '<S594>/Logical' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_OnlyVlv3;/* '<S596>/Logical' */

#endif

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_OverTempImminent;/* '<S3946>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_P1B72_DTCSet;/* '<S1505>/Logical Operator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_P1B73_DTCSet;/* '<S1504>/Logical Operator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_P1P2p5_MtrB_ClntInTemp_FA;/* '<S156>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_P1P2p5_MtrB_ClntOutTemp_FA;/* '<S157>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_P1P2p5_MtrB_CntrlBoardTemp_FA;/* '<S155>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_P1P2p5_MtrB_MtrCapctrTemp_FA;/* '<S158>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_P1P2p5_MtrB_MtrRotorTemp_FA;/* '<S154>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PPCTIS_Amb_TempChk;/* '<S4888>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PPCTIS_BTIS_TempChk;/* '<S4815>/Logical6' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PerWpCntl_Case1;/* '<S1678>/Logical4' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PerWpCntl_Case2;/* '<S1679>/Logical4' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PerWpCntl_Case3;/* '<S1680>/Logical4' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PerWpCntl_Case4;/* '<S1681>/Logical4' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PerWpCntl_Case5;/* '<S1682>/Logical4' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PerWpCntl_Case6;/* '<S1683>/Logical4' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PerWp_HTSO_VlvCmd_B4D;/* '<S1471>/Merge2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PerWp_SystEngReq;/* '<S1471>/Merge1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PlugdIn_Or_Chrg;/* '<S4113>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PresSnsrHiFlt;/* '<S4747>/Logical Operator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PropSysActv_100ms_AD;/* '<S3837>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PsvCool_Cond1;/* '<S4814>/Logical2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PsvCool_Cond2;/* '<S4815>/Logical1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Pump2OilTemp_FA;/* '<S3930>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_PumpOilTemp_FA;/* '<S3924>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_REMDisabled;/* '<S3950>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_RadFanReqstd_StaFlow;/* '<S4495>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_RstKeyLtch_AftrRun;/* '<S71>/Unit Delay1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Switch2ActValue_Vlv_Init0;/* '<S1357>/GreaterThan1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ThermSystEng_Req_B4PWup;/* '<S1548>/OR2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ThermSystEng_Req_HeatState;/* '<S1988>/OR2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ThreeW_Prop_Valve1_Enb;/* '<S1342>/Logical3' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ThrmLdshed_CoolRq;/* '<S4227>/Logical2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ThrmLoad_Shed;/* '<S3955>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ThrmSysEng_Raw;/* '<S1470>/Merge1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ThrmSystEng_ReqAPerWp;/* '<S1154>/Switch2' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ThrmlCommFlts_InhibitMsg4;/* '<S4258>/LogicalOperator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_ThrmlNotAllow_BattWallPwr_Limitd;/* '<S4549>/Switch1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_TotPwrLess_ThanLimit;/* '<S1472>/Comparison3' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_TotPwrLess_ThanLimit_RS;/* '<S1472>/Switch5' */
static VAR(TeDMDR_e_TurtleMdSts, THMR_VAR_INIT) VeTHMR_b_TurtleMd;/* '<S3952>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_U0425_DTCSet;/* '<S1507>/RelationalOperator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_U1008_DTCSet;/* '<S1508>/Logical Operator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_U1009_DTCSet;/* '<S1509>/Logical Operator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_U1124_DTCSet;/* '<S1510>/Logical Operator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_U148E_DTCSet;/* '<S1506>/RelationalOperator' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Use_ECHTIS_For_OV;/* '<S1889>/Logical1' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Vlv1_N_2;/* '<S595>/Logical' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Vlv1_N_3;/* '<S597>/Logical' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_Vlv2_N_3;/* '<S598>/Logical' */

#endif

static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_WishPwrStil_NotAvalLatch;/* '<S1769>/OR1' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_isEngOff_LH;/* '<S4545>/Switch' */
static VAR(boolean, THMR_VAR_INIT) VeTHMR_b_thermalActivityCmplt_SF;/* '<S3617>/AND' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dQ_FEDMHeatGen;/* '<S2431>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dQ_REDMHeatGen;/* '<S2432>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dT_BattCPV_TempErr;/* '<S2281>/Merge3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dT_ECHClntCntrlTempTerr;/* '<S1214>/MinMax' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_dT_FCSDerate_Error;/* '<S790>/MinMax' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_dT_TCoFuCellHiTOutFil;/* '<S949>/Sum7' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_BattRadAirflw_ClsLp_PID;/* '<S3123>/Switch1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_ClngFlwRqrd_Mtr1;/* '<S671>/Switch1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_ClngFlwRqrd_Mtr1_Raw;/* '<S682>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_ClngFlwRqrd_Mtr1_Rvrs;/* '<S670>/Switch1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_ClngFlwRqrd_Mtr1_RvrsRaw;/* '<S677>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_ClngFlwRqrd_Mtr2;/* '<S694>/Switch1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_ClngFlwRqrd_Mtr2_Raw;/* '<S705>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_ClngFlwRqrd_Mtr2_Rvrs;/* '<S693>/Switch1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_ClngFlwRqrd_Mtr2_RvrsRaw;/* '<S700>/Vector' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_ClntErr_PID;/* '<S5551>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_ClntFlwRt_ThruLTR_AftLim;/* '<S2827>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_ClntFlwRt_ThruLTR_B4Grd;/* '<S2803>/Product2' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_ECM_LTPsvPmpFlw;/* '<S2927>/Product' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_ECM_LTPsvPmpFlw_Arb;/* '<S2906>/MinMax2' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_FBLTLFLOW;/* '<S3089>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_FBLTLFanAF;/* '<S3091>/Gain' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_FCAirflw_ClsLp_PID;/* '<S887>/Switch1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_FC_HTR_AirFlow_Need;/* '<S857>/Switch1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_FC_HTR_AirFlow_Raw;/* '<S863>/Vector' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_FanPID_AirFlwDsrd;/* '<S5387>/MinMax1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_HTLFlowMBCReq;/* '<S2059>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_HTLFlowMBCReq_B4Set;/* '<S2067>/Sum3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_HT_AuxPmpFlw_B4D;/* '<S1161>/Merge' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_HtrAirFlow_PID;/* '<S5539>/Switch' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_LQGFan_MBCHTLLTL;/* '<S3247>/Sum3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_LQGFan_MBCHTLLTL_BfGrdLim;/* '<S3337>/Product' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_LQGLTLFanAF;/* '<S3028>/Sum3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_LTAPFlwReq_Mod_1;/* '<S45>/Max' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_LTR_AirFlowRaw;/* '<S2803>/Switch10' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_LT_APM_Flw_Rq;/* '<S2932>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_MBC_FBL_Flow;/* '<S2095>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_MGU_ClntPumpFlw_B4D;/* '<S2825>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_MinAchvblArflwEst_Ohx;/* '<S5516>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_P1Motor_AirFlowRaw;/* '<S2826>/Vector' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_PSucErr_PID;/* '<S5564>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_dV_PresErr_PID;/* '<S5577>/Switch' */
static VAR(TeBRKR_e_AHH_ReadyStatus, THMR_VAR_INIT) VeTHMR_e_AHH_Ready_Status_AD;/* '<S3780>/Switch' */
static VAR(TeTMIR_e_ECM_LTP_FanAftRunRq, THMR_VAR_INIT)
    VeTHMR_e_AfterRunRqNew_SF;         /* '<S3620>/DataTypeConversion' */
static VAR(TeTHMR_e_AfterRunSM_State, THMR_VAR_INIT)
    VeTHMR_e_AftrRunStateMachine_SF;   /* '<S3618>/DataTypeConversion' */
static VAR(TeBPCR_e_LIN_BusOff, THMR_VAR_INIT) VeTHMR_e_BPCM_LIN_BusOff;/* '<S226>/Switch' */
static VAR(TeBPCR_e_LOC_BCP, THMR_VAR_INIT) VeTHMR_e_BPCM_LOC_BCP;/* '<S235>/Switch' */
static VAR(TeHVTR_e_HV_BatCntctrStat, THMR_VAR_INIT) VeTHMR_e_BatCntctrStat;/* '<S3956>/Switch' */
static VAR(TeTHMR_e_BatThrmlSt, THMR_VAR_INIT) VeTHMR_e_BatThrmlSt_B4D;/* '<S4586>/Switch1' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static VAR(float32, THMR_VAR_INIT) VeTHMR_e_BattRad_Aiflow_Idx_AGS;/* '<S5431>/Rounding2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

static VAR(float32, THMR_VAR_INIT) VeTHMR_e_BattRad_Aiflow_Idx_AGSOpen;/* '<S5431>/Rounding1' */

#endif

static VAR(sint16, THMR_VAR_INIT) VeTHMR_e_CabinPreCondReqStat_CAN;/* '<S314>/Selector' */
static VAR(TeOBCR_e_ChargingLevel, THMR_VAR_INIT) VeTHMR_e_ChargingLevel_AD;/* '<S49>/Switch' */
static VAR(TeTMIR_e_ECM_LTP_FanAftRunRq, THMR_VAR_INIT)
    VeTHMR_e_ECM_LTPFanAftRunRq_cf_SF; /* '<S3622>/DataTypeConversion' */
static VAR(TeTHMR_e_EmrgcyFanRq_Lvl, THMR_VAR_INIT) VeTHMR_e_EmrgcyFanRq_Lvl_B4D;/* '<S2741>/In1' */
static VAR(TeTHMR_e_Eng_Htr_HTSOV_St, THMR_VAR_INIT) VeTHMR_e_EngHtr_HTSOV_State;/* '<S1576>/Switch1' */
static VAR(TeESSR_e_EngStartStopSt, THMR_VAR_INIT) VeTHMR_e_EngStartStopSt_AD;/* '<S3948>/Switch' */
static VAR(TeTMIR_e_ECM_LTP_FanAftRunRq, THMR_VAR_INIT)
    VeTHMR_e_HCP_LTP_FanAftRun_Rq_BD_SF;/* '<S3621>/DataTypeConversion' */
static VAR(TeTMIR_e_ECM_LTP_FanAftRunRq, THMR_VAR_INIT)
    VeTHMR_e_HCP_LTP_FanAftRun_Rq_Max_SF;/* '<S3619>/DataTypeConversion' */
static VAR(TeTMIR_e_ECM_LTP_FanAftRunRq, THMR_VAR_INIT)
    VeTHMR_e_HCP_LTP_FanAftRun_Rq_cf_SF;/* '<S3623>/DataTypeConversion' */
static VAR(sint16, THMR_VAR_INIT) VeTHMR_e_HTAP_TempSrc_SF;/* '<S1931>/Gain' */
static VAR(TeTHMR_e_PumpOpState, THMR_VAR_INIT) VeTHMR_e_HTAuxPmp_Op_State;
                               /* '<S3692>/SigConvForSigProp_VariantSource_0' */
static VAR(TePMPR_e_FTSNA, THMR_VAR_INIT) VeTHMR_e_HTAuxPumpDryRun_AD;/* '<S3792>/Switch' */
static VAR(TeTHMR_e_HTCL_Heat_Distrib, THMR_VAR_INIT)
    VeTHMR_e_HTCL_Heat_Distrib_B4D;    /* '<S1158>/Switch' */
static VAR(TeTHMR_e_HTCL_Heat_Distrib, THMR_VAR_INIT)
    VeTHMR_e_HTCL_Heat_Distrib_B4D_New;/* '<S1158>/Selector1' */
static VAR(TeTHMR_e_HTCL_Heat_Distrib, THMR_VAR_INIT)
    VeTHMR_e_HTCL_Heat_Distrib_B4D_Old;/* '<S1158>/Merge' */
static VAR(TeTRIR_e_HVAC_ECO_State, THMR_VAR_INIT) VeTHMR_e_HVACECOModeSts;/* '<S3942>/Switch1' */
static VAR(TeTHMR_e_HVACPerf_Mode, THMR_VAR_INIT) VeTHMR_e_HVACPerf_Mode;/* '<S4286>/Switch1' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_e_HeadPres_Aiflow_Idx_AGS;/* '<S5432>/Rounding2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_e_HeadPres_Aiflow_Idx_AGSOpen;/* '<S5432>/Rounding1' */

#endif

static VAR(TeTHMR_e_HtrState, THMR_VAR_INIT) VeTHMR_e_Htr1_State;
                               /* '<S2215>/SigConvForSigProp_VariantSource_0' */
static VAR(TeTHMR_e_HtrState, THMR_VAR_INIT) VeTHMR_e_Htr1_State_B4SET;/* '<S4042>/DataTypeConversion' */
static VAR(TeTHMR_e_HtrState, THMR_VAR_INIT) VeTHMR_e_Htr2_State;
                               /* '<S2214>/SigConvForSigProp_VariantSource_0' */
static VAR(TeTHMR_e_HtrState, THMR_VAR_INIT) VeTHMR_e_Htr2_State_B4SET;/* '<S4043>/DataTypeConversion' */
static VAR(TeTHMR_e_HtrState, THMR_VAR_INIT) VeTHMR_e_Htr3_State;
                               /* '<S2216>/SigConvForSigProp_VariantSource_0' */
static VAR(TeTHMR_e_HtrState, THMR_VAR_INIT) VeTHMR_e_Htr3_State_B4SET;/* '<S4044>/DataTypeConversion' */
static VAR(TeTHMR_e_HtrState, THMR_VAR_INIT) VeTHMR_e_Htr4_State;
                               /* '<S2217>/SigConvForSigProp_VariantSource_0' */
static VAR(TeTHMR_e_HtrState, THMR_VAR_INIT) VeTHMR_e_Htr4_State_B4SET;/* '<S4045>/DataTypeConversion' */
static VAR(TeHPMR_e_HybSysState, THMR_VAR_INIT) VeTHMR_e_HybSysSt;/* '<S3954>/Switch' */
static VAR(TeTHMR_e_PumpOpState, THMR_VAR_INIT) VeTHMR_e_LTActPmp_Op_State;
                               /* '<S3691>/SigConvForSigProp_VariantSource_0' */
static VAR(TeTHMR_e_PumpOpState, THMR_VAR_INIT) VeTHMR_e_LTPsvPmp2_Op_State;
                               /* '<S3690>/SigConvForSigProp_VariantSource_0' */
static VAR(TeTHMR_e_PumpOpState, THMR_VAR_INIT) VeTHMR_e_LTPsvPmp_Op_State;
                               /* '<S3689>/SigConvForSigProp_VariantSource_0' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_e_LTR_Aiflow_Idx_AGS;/* '<S5438>/Rounding2' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_e_LTR_Aiflow_Idx_AGSOpen;/* '<S5438>/Rounding1' */
static VAR(TeTHMR_e_PPCTIS_OT, THMR_VAR_INIT) VeTHMR_e_PPCTIS_OT_BD;/* '<S2296>/Switch2' */
static VAR(TeOBCR_e_PwrLimReq, THMR_VAR_INIT) VeTHMR_e_PwrLevSet_AD;/* '<S49>/Switch2' */
static VAR(TeFSCR_e_RadFanState_Adjtd, THMR_VAR_INIT)
    VeTHMR_e_RadFan_State_B4SET;       /* '<S4040>/DataTypeConversion' */
static VAR(TeSSDR_e_KeySts, THMR_VAR_INIT) VeTHMR_e_SSDR_KeySts;/* '<S3945>/Switch' */
static VAR(TePLTR_e_ShipingMode, THMR_VAR_INIT) VeTHMR_e_ShippingMode;/* '<S3953>/Switch' */
static VAR(TeTRGR_e_TransRangeState, THMR_VAR_INIT) VeTHMR_e_TransDirctnSt;/* '<S3957>/Switch' */
static VAR(sint16, THMR_VAR_INIT) VeTHMR_i_Index4MinTempAllow_NewApp;/* '<S381>/Merge1' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_ProactiveChgActiveMinTempAllw;/* '<S382>/Product4' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_ProactiveChgPassiveMinTempAllw;/* '<S382>/Product6' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_PrsntWght4CabPrecMinTempAlw;/* '<S382>/Product1' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_PrsntWght4ChrgLvl1MinTempAllw;/* '<S382>/Product3' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_PrsntWght4ChrgLvl2MinTempAllw;/* '<S382>/Product5' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_PrsntWght4ChrgLvl3MinTempAllw;/* '<S382>/Product7' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_PrsntWght4ChrgPrepMinTempAllw;/* '<S382>/Product23' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_PrsntWght4DefrostMinTempAllw;/* '<S382>/Product9' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_PrsntWght4DschrgSysStsMinTempAllw;/* '<S382>/Product19' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_PrsntWght4HVACPrrtyMinTempAllw;/* '<S382>/Product8' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_PrsntWght4LoadShdLvl1MinTempAllw;/* '<S382>/Product2' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_PrsntWght4NrmlDrvMinTempAllw;/* '<S382>/Product25' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_PrsntWght4PrdicWupMinTempAllw;/* '<S382>/Product21' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_Wght4BattCoolNHeatOVReqTempAllow;/* '<S382>/Product12' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_Wght4BattCoolOVReqTempAllow;/* '<S382>/Product10' */
static VAR(uint16, THMR_VAR_INIT) VeTHMR_i_Wght4BattHeatOVReqTempAllow;/* '<S382>/Product11' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_DHiTRegFuCell;/* '<S964>/Merge3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_ElVlv3WayFuCellDif_MP;/* '<S947>/Divide1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_ElVlv3WayFuCellInt_MP;/* '<S947>/Switch2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_ElVlv3WayFuCellMixPt;/* '<S986>/Gain' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_ElVlv3WayFuCellMixPtSel;/* '<S948>/Switch1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_ElVlv3WayFuCellMixPtSp;/* '<S987>/Gain' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_ElVlv3WayFuCellPID;/* '<S945>/MinMax' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_ElVlv3WayFuCellPIDFlt;/* '<S1091>/Switch2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_ElVlv3WayFuCellPIDRaw;/* '<S947>/Sum1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_ElVlv3WayFuCellProp_MP;/* '<S947>/Product' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_ElVlv3WayFuCellReqBf;/* '<S903>/Switch2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_ElVlv3WayFuCellReqCtl;/* '<S946>/Sum2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_ElVlv3WayReqLnr;/* '<S961>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_ElVlv3WayReqLnrMax_MP;/* '<S958>/MinMax' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_ElVlv3WayReqLnrMin_MP;/* '<S957>/MinMax' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_Errorsum_MBC;/* '<S2085>/UnitDelay' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_HeatTranCoefOutRadHiT1_MP;/* '<S1012>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_HeatTranCoefOutRadHiT2_MP;/* '<S1013>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_HeatTranCoefOutRadHiT3_MP;/* '<S1014>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_HiTFuCellWaPmpCtlReq;/* '<S902>/MinMax2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_HiTSpdAirBasReq;/* '<S1076>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_HiTSpdAirMaxReq;/* '<S904>/MinMax1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_HiTSpdAirMinReq;/* '<S904>/MinMax' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_HiTSpdAirReq;/* '<S904>/MinMax4' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_HiTSpdAirSysReqTrim;/* '<S1064>/MinMax' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_IHiTRegFuCell;/* '<S964>/Merge2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_PHiTRegFuCell;/* '<S964>/Product2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_PwrFuCellMaxLimThStMchDelta;/* '<S950>/Unit Delay2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_RadBypFuCellHiTHEX;/* '<S1130>/Switch1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_SpdAirHiTSysReqFlt;/* '<S1090>/Switch2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_SpdAirHiTSysReq_MP;/* '<S1081>/MinMax' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_WaPmpFuCellDeltaReq;/* '<S925>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_WaPmpFuCellMin;/* '<S921>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_WaPmpFuCellPwrMaxLimThDeltaReq;/* '<S922>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_WaPmpFuCellReg;/* '<S923>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_k_WaPmpFuCellReq;/* '<S924>/Vector' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_n_AirHiTReq_MP;/* '<S1063>/Switch2' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_n_BSG_LTR_PmpSpdAct;/* '<S2803>/Product1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_n_BTLPumpMBC;/* '<S3143>/Sum3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_n_BTLPumpMBC_BfGrdLim;/* '<S3157>/Product' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_n_EngSpdInc_Req_BD;/* '<S2841>/Sum3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_n_HTLPumpMBCReq_B4Set;/* '<S2061>/Sum3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_n_HTLPumpMBCReq_BfGrdLim;/* '<S2083>/Product' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_n_HTLPumpMBCReq_BfGrdLimDlyd;/* '<S2055>/UnitDelay' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_n_HTLPump_MBCReq;/* '<S2056>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_n_InputSpeed;/* '<S3951>/Switch' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static VAR(float32, THMR_VAR_INIT) VeTHMR_n_LQGHCP_MBCHTLLTL;/* '<S3248>/Sum3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static VAR(float32, THMR_VAR_INIT) VeTHMR_n_LQGHCP_MBCHTLLTL_BfGrdLim;/* '<S3338>/Product' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static VAR(float32, THMR_VAR_INIT) VeTHMR_n_LQGPECP1_MBCHTLLTL;/* '<S3244>/Sum3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static VAR(float32, THMR_VAR_INIT) VeTHMR_n_LQGPECP1_MBCHTLLTL_BfGrdLim;/* '<S3340>/Product' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static VAR(float32, THMR_VAR_INIT) VeTHMR_n_LQGPECP2_MBCHTLLTL;/* '<S3245>/Sum3' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

static VAR(float32, THMR_VAR_INIT) VeTHMR_n_LQGPECP2_MBCHTLLTL_BfGrdLim;/* '<S3341>/Product' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_n_LTLPECP1_MBC;/* '<S3025>/Sum3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_n_LTLPECP2_MBC;/* '<S3026>/Sum3' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_n_LTPsvPump2RPMAct_B4SET;/* '<S3794>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_n_LTPsvPumpRPMAct_B4SET;/* '<S3793>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_n_MtrA_Spd;/* '<S3742>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_n_MtrB_Spd;/* '<S3743>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_n_MtrC_Spd;/* '<S3741>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_p_HghRfrgtPres_Arb;/* '<S302>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_p_HghRfrgtPres_B4SET;/* '<S2159>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_p_eACSuctnPress;/* '<S2161>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_r_AHH_StressFactor;/* '<S3781>/Switch' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_r_BattCabPriorityRatio_Fin;
                               /* '<S1148>/SigConvForSigProp_VariantSource_0' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

static VAR(float32, THMR_VAR_INIT) VeTHMR_r_BattCabRatioAftrMrg;/* '<S1175>/Merge' */

#endif

static VAR(uint32, THMR_VAR_INIT) VeTHMR_t_AfterRunTimeForRq_SF;/* '<S3642>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_t_EngTurnOff_DelayTim;/* '<S1550>/Merge3' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(float32, THMR_VAR_INIT) VeTHMR_t_LimFuCellPwrLimTh;/* '<S1054>/Vector' */

#endif

static VAR(float32, THMR_VAR_INIT) VeTHMR_t_RTC_InitDelay_SF;/* '<S3639>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_t_RadFanTurnONTimr_SF;/* '<S3643>/Gain' */
static VAR(uint32, THMR_VAR_INIT) VeTHMR_t_RealTimeClock_LastValue_SF;/* '<S3640>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_t_TimeRemainForAftrrun_SF;/* '<S3645>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_t_TmrDuration_HtrFlty_RA;/* '<S1532>/Switch1' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_t_WaitTimeFrAftrRun_SF;/* '<S3644>/Gain' */
static VAR(float32, THMR_VAR_INIT) VeTHMR_v_Vehicle;/* '<S3944>/Switch' */

#if !Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static VAR(float32, THMR_VAR_INIT) VeTHMR_y_ECM_Aiflow_Idx_AGS;/* '<S5433>/Rounding2' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

static VAR(float32, THMR_VAR_INIT) VeTHMR_y_ECM_Aiflow_Idx_AGSOpen;/* '<S5433>/Rounding1' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static VAR(float32, THMR_VAR_INIT) VeTHMR_y_FC_HTR_Aiflow_Idx_AGS;/* '<S5434>/Rounding2' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

static VAR(float32, THMR_VAR_INIT) VeTHMR_y_FC_HTR_Aiflow_Idx_AGSOpen;/* '<S5434>/Rounding1' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_P1MotorReqDsbl

static VAR(float32, THMR_VAR_INIT) VeTHMR_y_P1Motor_Aiflow_Idx_AGS;/* '<S5439>/Rounding2' */

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_P1MotorReqDsbl

static VAR(float32, THMR_VAR_INIT) VeTHMR_y_P1Motor_Aiflow_Idx_AGSOpen;/* '<S5439>/Rounding1' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_y_PPU_Aiflow_Idx_AGS;/* '<S5440>/Rounding2' */

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

static VAR(float32, THMR_VAR_INIT) VeTHMR_y_PPU_Aiflow_Idx_AGSOpen;/* '<S5440>/Rounding1' */

#endif

static VAR(uint8, THMR_VAR_INIT) VeTHMR_y_PumpEnbl_DS;/* '<Root>/DSM_2' */

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static VAR(sint32, THMR_VAR_INIT) VeTHMR_y_PwrFuCellMaxLimTh;
                                   /* '<S950>/ElVlv_3_Way_FuCell_PwrMaxLimTh' */

#endif

#define STOP_SEC_VAR_CLEARED_UNSPECIFIED_THMR
#include "MemMap.h"

/* Invariant block signals (default storage) */
#define START_SEC_CONST_UNSPECIFIED_THMR
#include "MemMap.h"

CONST(ConstB_THMR_ac_T, THMR_VAR_INIT) THMR_ac_ConstB =
{
    CeTPCR_e_SC_NotAwake,              /* '<S5679>/Const88' */
    CeTPCR_e_CabinPrec_Dflt,           /* '<S5679>/Const89' */
    CeTHMR_e_NoVlvPwrd,                /* '<S5679>/Const14' */
    CeTHMR_e_NoVlvPwrd,                /* '<S5679>/Const15' */
    CeTHMR_e_TempAllowNormalDrive,     /* '<S5679>/Const55' */
    CeTHMR_e_TempAllowNormalDrive,     /* '<S511>/Switch1' */
    CeTHMR_e_AllOpen,                  /* '<S5679>/Const17' */
    CeTHMR_e_NoPump_On,                /* '<S5679>/Const9' */
    CeTHMR_e_EmergencyLevel4,          /* '<S5679>/Const48' */
    CeTHMR_e_OilPumpEmrgCool_OFF,      /* '<S5679>/Const124' */
    CeTHMR_e_OilPumpEmrgCool_OFF,      /* '<S5679>/Const125' */
    CeTHMR_e_Balancing_LTCLVlvSt,      /* '<S5679>/Const111' */
    CeTHMR_e_LTCLBalancing,            /* '<S5679>/Const112' */
    CeTHMR_e_NormalMode,               /* '<S5679>/Const84' */
    CeTHMR_e_NoHeating,                /* '<S5679>/Const62' */
    CeTHMR_e_FCCondOff,                /* '<S5679>/Const140' */
    CeTHMR_e_NoStateSlctd,             /* '<S5679>/Const47' */
    CeTHMR_e_No_EmrgcyFanRq,           /* '<S5679>/Const21' */
    CeTHMR_e_Cab_NoConditioning,       /* '<S5679>/Const108' */
    CeTHMR_e_NoCabinHeating,           /* '<S5679>/Const109' */
    CeTHMR_e_NoActvHeat,               /* '<S5679>/Const133' */
    CeTHMR_e_NoCabinCooling,           /* '<S5679>/Const110' */
    CeTHMR_e_NoConditioning,           /* '<S5679>/Const41' */
    CeTHMR_e_ACOff,                    /* '<S5679>/Const45' */
    CeSRAR_e_NoFlt,                    /* '<S5679>/Const31' */
    CePDTR_e_No_Dischrg,               /* '<S5679>/Const26' */
    CeFSCR_e_RadFan_OFF,               /* '<S5679>/Const19' */
    CeBRDR_e_BatCltLvlNotLo            /* '<S5679>/Const40' */
};

#define STOP_SEC_CONST_UNSPECIFIED_THMR
#include "MemMap.h"

/* Constant parameters (default storage) */
#define START_SEC_CONST_UNSPECIFIED_THMR
#include "MemMap.h"

CONST(ConstP_THMR_ac_T, THMR_VAR_INIT) THMR_ac_ConstP =
{
    /* Computed Parameter: Vector_maxIndex
     * Referenced by: '<S419>/Vector'
     */
    {
        7U, 5U
    },

    /* Computed Parameter: Vector_maxIndex_j
     * Referenced by: '<S372>/Vector'
     */
    {
        17U, 5U
    },

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S367>/Vector'
     *   '<S368>/Vector'
     */
    {
        17U, 6U
    },

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S863>/Vector'
     *   '<S3112>/Vector'
     *   '<S2821>/Vector'
     *   '<S2822>/Vector'
     *   '<S2823>/Vector'
     *   '<S2824>/Vector'
     *   '<S2825>/Vector'
     *   '<S2826>/Vector'
     *   '<S677>/Vector'
     *   '<S682>/Vector'
     *   '<S700>/Vector'
     *   '<S705>/Vector'
     */
    {
        6U, 7U
    },

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S2431>/Vector'
     *   '<S2432>/Vector'
     *   '<S2877>/Vector'
     *   '<S2879>/Vector'
     *   '<S2881>/Vector'
     */
    {
        10U, 10U
    },

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S2942>/Vector'
     *   '<S2943>/Vector'
     *   '<S2944>/Vector'
     */
    {
        7U, 7U
    },

    /* Computed Parameter: Vector_maxIndex_b
     * Referenced by: '<S5515>/Vector'
     */
    {
        4U, 3U
    },

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S5601>/Vector'
     *   '<S5602>/Vector'
     *   '<S5603>/Vector'
     *   '<S5604>/Vector'
     *   '<S5605>/Vector'
     *   '<S5606>/Vector'
     *   '<S5607>/Vector'
     *   '<S5608>/Vector'
     *   '<S5609>/Vector'
     *   '<S5610>/Vector'
     *   '<S5612>/Vector'
     *   '<S5613>/Vector'
     *   '<S5456>/Vector'
     *   '<S5462>/Vector'
     *   '<S5463>/Vector'
     *   '<S5470>/Vector'
     *   '<S5477>/Vector'
     *   '<S5484>/Vector'
     *   '<S5500>/Vector'
     *   '<S5506>/Vector'
     *   '<S5507>/Vector'
     */
    {
        10U, 12U
    },

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S5455>/Vector'
     *   '<S5469>/Vector'
     *   '<S5476>/Vector'
     *   '<S5483>/Vector'
     *   '<S5499>/Vector'
     */
    {
        10U, 11U
    },

    /* Computed Parameter: Vector_maxIndex_a
     * Referenced by: '<S5516>/Vector'
     */
    {
        5U, 6U
    },

    /* Computed Parameter: Vector_maxIndex_p
     * Referenced by: '<S1929>/Vector'
     */
    {
        6U, 4U
    },

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S4875>/Vector'
     *   '<S4877>/Vector'
     */
    {
        2U, 4U
    },

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S780>/Vector'
     *   '<S781>/Vector'
     *   '<S885>/Vector'
     *   '<S886>/Vector'
     *   '<S5050>/Vector'
     *   '<S5060>/Vector'
     */
    {
        3U, 5U
    },

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S972>/Vector'
     *   '<S973>/Vector'
     *   '<S974>/Vector'
     *   '<S975>/Vector'
     *   '<S976>/Vector'
     *   '<S977>/Vector'
     */
    {
        8U, 6U
    },

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S923>/Vector'
     *   '<S924>/Vector'
     *   '<S1012>/Vector'
     *   '<S1013>/Vector'
     *   '<S1014>/Vector'
     *   '<S1079>/Vector'
     */
    {
        7U, 6U
    },

#endif

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S749>/Vector'
     *   '<S750>/Vector'
     *   '<S1252>/Vector'
     *   '<S1253>/Vector'
     *   '<S1255>/Vector'
     *   '<S1727>/Vector'
     *   '<S1270>/Vector'
     *   '<S5061>/Vector'
     *   '<S5065>/Vector'
     *   '<S1283>/Vector'
     *   '<S1284>/Vector'
     *   '<S1285>/Vector'
     *   '<S1286>/Vector'
     *   '<S1287>/Vector'
     *   '<S1288>/Vector'
     *   '<S1289>/Vector'
     *   '<S1290>/Vector'
     */
    {
        5U, 5U
    },

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* Computed Parameter: Vector_maxIndex_jo
     * Referenced by: '<S1053>/Vector'
     */
    {
        7U, 1U
    },

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* Computed Parameter: Vector_maxIndex_ja
     * Referenced by: '<S1054>/Vector'
     */
    {
        6U, 1U
    },

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S922>/Vector'
     *   '<S925>/Vector'
     */
    {
        5U, 4U
    },

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S1076>/Vector'
     *   '<S1089>/Vector'
     */
    {
        6U, 8U
    },

#endif

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S5514>/Vector'
     *   '<S2856>/Vector'
     *   '<S1086>/Vector'
     */
    {
        6U, 6U
    }
};

#define STOP_SEC_CONST_UNSPECIFIED_THMR
#include "MemMap.h"

/* Block signals (default storage) */
#define START_SEC_VAR_CLEARED_UNSPECIFIED_THMR
#include "MemMap.h"

VAR(B_THMR_ac_T, THMR_VAR_INIT) THMR_ac_B;

#define STOP_SEC_VAR_CLEARED_UNSPECIFIED_THMR
#include "MemMap.h"

/* Block states (default storage) */
#define START_SEC_VAR_CLEARED_UNSPECIFIED_THMR
#include "MemMap.h"

VAR(DW_THMR_ac_T, THMR_VAR_INIT) THMR_ac_DW;

#define STOP_SEC_VAR_CLEARED_UNSPECIFIED_THMR
#include "MemMap.h"

static FUNC(void, THMR_CODE_LOCAL) THMR_ac_CabinCmftMet_NoPriority(P2VAR(boolean,
    AUTOMATIC, THMR_VAR_INIT) rty_Out1);
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_HtrCor_Err(VAR(float32, AUTOMATIC)
    rtu_HCCTIS_Tgt, VAR(float32, AUTOMATIC) rtu_HCCTIS_Act, P2VAR(float32,
    AUTOMATIC, THMR_VAR_INIT) rty_HtrCore_TempErr);
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_NoHeat_HtrCore(P2VAR(float32,
    AUTOMATIC, THMR_VAR_INIT) rty_ECH_TempErr);
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_FC_Err(VAR(float32, AUTOMATIC)
    rtu_FCClnt_Tgt, VAR(float32, AUTOMATIC) rtu_HCCTOS, P2VAR(float32, AUTOMATIC,
    THMR_VAR_INIT) rty_FC_TempErr);
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_TempError_BattHeating(VAR(float32,
    AUTOMATIC) rtu_BTCL_Tgt, VAR(float32, AUTOMATIC) rtu_BTIS, P2VAR(float32,
    AUTOMATIC, THMR_VAR_INIT) rty_TempErr_BattHeating);
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_Fault(P2VAR(float32, AUTOMATIC,
    THMR_VAR_INIT) rty_Heat_Estim_FA, P2VAR(boolean, AUTOMATIC, THMR_VAR_INIT)
    rty_SNA_flag_FA);
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_EDM_Heat_Estimation(VAR(float32,
    AUTOMATIC) rtu_T_stator, VAR(float32, AUTOMATIC) rtu_T_oil_in, VAR(float32,
    AUTOMATIC) rtu_m_dot_coolant, VAR(float32, AUTOMATIC) rtu_m_dot_oil, VAR
    (float32, AUTOMATIC) rtu_alpha_1, VAR(float32, AUTOMATIC) rtu_alpha_2, VAR
    (float32, AUTOMATIC) rtu_alpha_3, VAR(float32, AUTOMATIC) rtu_alpha_4, VAR
    (float32, AUTOMATIC) rtu_alpha_5, VAR(float32, AUTOMATIC) rtu_sampling_time,
    VAR(float32, AUTOMATIC) rtu_EDM_Loss, P2VAR(float32, AUTOMATIC,
    THMR_VAR_INIT) rty_Heat_Estim, P2VAR(boolean, AUTOMATIC, THMR_VAR_INIT)
    rty_SNA_flag, P2VAR(DW_EDM_Heat_Estimation_THMR_a_T, AUTOMATIC,
                        THMR_VAR_INIT) localDW);
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_LTCL_Default_Pos(VAR(float32,
    AUTOMATIC) rtu_LTR_PID_Cmd_Balancing, P2VAR(float32, AUTOMATIC,
    THMR_VAR_INIT) rty_Clsd);
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_CondAirflow(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, THMR_VAR_INIT) rty_Out1);
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_IfAct1(P2VAR(float32, AUTOMATIC,
    THMR_VAR_INIT) rty_Out1);
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_Default(P2VAR(float32, AUTOMATIC,
    THMR_VAR_INIT) rty_Out1);

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static FUNC(void, THMR_CODE_LOCAL) THMR_ac_FCL_Cooling_Pos(P2VAR(float32,
    AUTOMATIC, THMR_VAR_INIT) rty_Clsd);

#endif

/* Forward declaration for local functions */
static void THMR__enter_atomic_AfterRunInit(void);
static void THMR_ac_AlternatorMode(const boolean *Logical4, const boolean
    *Gain_cm, const boolean *Switch2_e, const TeCITR_e_FOTA_Install_Type
    *Switch2_i, const TeTMIR_e_ECM_LTP_FanAftRunRq *Switch1_ed, const
    TeTHMR_e_EmrgcyFanRq_Lvl *Switch1_i);
static void THMR_ac_CalNewAfterRunRq(const boolean *Logical4, const boolean
    *Gain_cm, const boolean *Switch2_e, const TeCITR_e_FOTA_Install_Type
    *Switch2_i, const TeTMIR_e_ECM_LTP_FanAftRunRq *Switch1_ed, const
    TeTHMR_e_EmrgcyFanRq_Lvl *Switch1_i);
static void THMR_ac_DeterminAftrRunRq(const boolean *Logical4, const boolean
    *Switch2_e, const TeCITR_e_FOTA_Install_Type *Switch2_i, const
    TeTMIR_e_ECM_LTP_FanAftRunRq *Switch1_ed, const TeTHMR_e_EmrgcyFanRq_Lvl
    *Switch1_i);
static void THMR_ac_DetrmnAftrrunRq(void);
static void PlugInCharging_CmndOutOfAftrRun(const boolean *Gain_cm, const
    boolean *Switch2_e, const TeCITR_e_FOTA_Install_Type *Switch2_i);
static void THMR_enter_internal_ThermalMode(void);
static void THMR_ac_ThermalMode(const boolean *Gain_hm, const boolean *Gain_he,
    const boolean *Gain_n);
static void THMR_ac_Heater(void);
static void THMR_ac_Pumps(void);
static void THMR_ac_Control(const boolean *Gain_ju, const boolean *Gain_ia,
    const boolean *Gain_ma, const boolean *Gain_bl, const boolean *Logical7,
    const boolean *Gain_nh);

/*
 * Output and update for action system:
 *    '<S410>/CabinCmftMet_NoPriority'
 *    '<S403>/NoPriority'
 */
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_CabinCmftMet_NoPriority(P2VAR(boolean,
    AUTOMATIC, THMR_VAR_INIT) rty_Out1)
{
    /* SignalConversion generated from: '<S421>/Out1' incorporates:
     *  Constant: '<S421>/Constant'
     */
    *rty_Out1 = false;
}

/*
 * Output and update for action system:
 *    '<S2305>/HtrCor_Err'
 *    '<S1214>/HtrCor_Err'
 */
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_HtrCor_Err(VAR(float32, AUTOMATIC)
    rtu_HCCTIS_Tgt, VAR(float32, AUTOMATIC) rtu_HCCTIS_Act, P2VAR(float32,
    AUTOMATIC, THMR_VAR_INIT) rty_HtrCore_TempErr)
{
    /* Sum: '<S2347>/Subtraction1' */
    *rty_HtrCore_TempErr = rtu_HCCTIS_Tgt - rtu_HCCTIS_Act;
}

/*
 * Output and update for action system:
 *    '<S2305>/NoHeat_HtrCore'
 *    '<S2305>/NoHeat_Batt'
 *    '<S2305>/NoHeat_FC'
 *    '<S1214>/NoHeat_HtrCore'
 *    '<S1214>/NoHeat_Batt'
 *    '<S1214>/NoHeat_FC'
 */
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_NoHeat_HtrCore(P2VAR(float32,
    AUTOMATIC, THMR_VAR_INIT) rty_ECH_TempErr)
{
    /* SignalConversion generated from: '<S2350>/ECH_TempErr' incorporates:
     *  Constant: '<S2355>/Calib'
     */
    *rty_ECH_TempErr = KeTHMR_T_ECH_TempErrDef;
}

/*
 * Output and update for action system:
 *    '<S2305>/FC_Err'
 *    '<S1214>/FC_Err'
 */
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_FC_Err(VAR(float32, AUTOMATIC)
    rtu_FCClnt_Tgt, VAR(float32, AUTOMATIC) rtu_HCCTOS, P2VAR(float32, AUTOMATIC,
    THMR_VAR_INIT) rty_FC_TempErr)
{
    /* Sum: '<S2346>/Subtraction1' */
    *rty_FC_TempErr = rtu_FCClnt_Tgt - rtu_HCCTOS;
}

/*
 * Output and update for action system:
 *    '<S2281>/TempError_BattHeating'
 *    '<S1352>/TempError_BattHeating'
 */
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_TempError_BattHeating(VAR(float32,
    AUTOMATIC) rtu_BTCL_Tgt, VAR(float32, AUTOMATIC) rtu_BTIS, P2VAR(float32,
    AUTOMATIC, THMR_VAR_INIT) rty_TempErr_BattHeating)
{
    /* Sum: '<S2326>/Add1' */
    *rty_TempErr_BattHeating = rtu_BTCL_Tgt - rtu_BTIS;
}

/*
 * Output and update for action system:
 *    '<S2413>/Fault'
 *    '<S2443>/Fault'
 */
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_Fault(P2VAR(float32, AUTOMATIC,
    THMR_VAR_INIT) rty_Heat_Estim_FA, P2VAR(boolean, AUTOMATIC, THMR_VAR_INIT)
    rty_SNA_flag_FA)
{
    /* SignalConversion generated from: '<S2454>/Heat_Estim_FA' incorporates:
     *  Constant: '<S2454>/Constant1'
     */
    *rty_Heat_Estim_FA = 0.0F;

    /* SignalConversion generated from: '<S2454>/SNA_flag_FA' incorporates:
     *  Constant: '<S2454>/TRUEConstant4'
     */
    *rty_SNA_flag_FA = true;
}

/*
 * Output and update for action system:
 *    '<S2413>/EDM_Heat_Estimation'
 *    '<S2443>/EDM_Heat_Estimation'
 */
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_EDM_Heat_Estimation(VAR(float32,
    AUTOMATIC) rtu_T_stator, VAR(float32, AUTOMATIC) rtu_T_oil_in, VAR(float32,
    AUTOMATIC) rtu_m_dot_coolant, VAR(float32, AUTOMATIC) rtu_m_dot_oil, VAR
    (float32, AUTOMATIC) rtu_alpha_1, VAR(float32, AUTOMATIC) rtu_alpha_2, VAR
    (float32, AUTOMATIC) rtu_alpha_3, VAR(float32, AUTOMATIC) rtu_alpha_4, VAR
    (float32, AUTOMATIC) rtu_alpha_5, VAR(float32, AUTOMATIC) rtu_sampling_time,
    VAR(float32, AUTOMATIC) rtu_EDM_Loss, P2VAR(float32, AUTOMATIC,
    THMR_VAR_INIT) rty_Heat_Estim, P2VAR(boolean, AUTOMATIC, THMR_VAR_INIT)
    rty_SNA_flag, P2VAR(DW_EDM_Heat_Estimation_THMR_a_T, AUTOMATIC,
                        THMR_VAR_INIT) localDW)
{
    float32 rtb_Divide2_k;
    float32 rtb_Divide_j;
    float32 rtb_MathFunction;
    float32 rtb_MathFunction2;

    /* Product: '<S2453>/Divide' incorporates:
     *  Constant: '<S2453>/Constant1'
     *  Sum: '<S2453>/Add3'
     */
    rtb_Divide_j = (rtu_T_stator + rtu_T_oil_in) / 2.0F;

    /* Product: '<S2453>/Divide2' */
    rtb_Divide2_k = (rtu_alpha_5 * rtu_m_dot_oil) / rtu_m_dot_coolant;

    /* Math: '<S2453>/MathFunction2' incorporates:
     *  Product: '<S2453>/Divide3'
     */
    rtb_MathFunction2 = rtu_alpha_4 / rtu_m_dot_oil;

    /* Math: '<S2453>/MathFunction' incorporates:
     *  Constant: '<S2455>/Calib'
     */
    rtb_MathFunction = powf(rtb_MathFunction2, KeTHMR_k_NTUcte1);

    /* Math: '<S2453>/MathFunction2' incorporates:
     *  Constant: '<S2456>/Calib'
     */
    rtb_MathFunction2 = powf(rtb_MathFunction2, KeTHMR_k_NTUcte2);

    /* Sum: '<S2453>/Add5' incorporates:
     *  Constant: '<S2453>/Constant4'
     *  Constant: '<S2453>/Constant6'
     *  Math: '<S2453>/MathFunction1'
     *  Math: '<S2453>/MathFunction3'
     *  Product: '<S2453>/Divide1'
     *  Product: '<S2453>/Divide4'
     *  Product: '<S2453>/Divide5'
     *  Product: '<S2453>/Divide6'
     *  Product: '<S2453>/Divide7'
     *  Product: '<S2453>/Divide8'
     *  Sum: '<S2453>/Add1'
     *  Sum: '<S2453>/Add2'
     *  Sum: '<S2453>/Add4'
     *  Sum: '<S2453>/Add6'
     *  UnitDelay: '<S2453>/UnitDelay'
     *
     * About '<S2453>/MathFunction1':
     *  Operator: exp
     *
     * About '<S2453>/MathFunction3':
     *  Operator: exp
     */
    *rty_Heat_Estim = ((rtu_alpha_2 * rtu_EDM_Loss) - (((rtb_Divide_j -
                          localDW->UnitDelay_DSTATE) / rtu_sampling_time) *
                        rtu_alpha_1)) - ((((1.0F - expf(((expf((-rtb_Divide2_k) *
        rtb_MathFunction) - 1.0F) * rtb_MathFunction2) / rtb_Divide2_k)) *
        rtu_alpha_3) * rtu_m_dot_oil) * (rtu_T_oil_in - rtb_Divide_j));

    /* SignalConversion generated from: '<S2453>/SNA_flag' incorporates:
     *  Constant: '<S2453>/TRUEConstant4'
     */
    *rty_SNA_flag = false;

    /* Update for UnitDelay: '<S2453>/UnitDelay' */
    localDW->UnitDelay_DSTATE = rtb_Divide_j;
}

/*
 * Output and update for action system:
 *    '<S2293>/LTCL_Default_Pos'
 *    '<S724>/FCL_Balance_Pos'
 */
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_LTCL_Default_Pos(VAR(float32,
    AUTOMATIC) rtu_LTR_PID_Cmd_Balancing, P2VAR(float32, AUTOMATIC,
    THMR_VAR_INIT) rty_Clsd)
{
    /* Inport: '<S2752>/LTR_PID_Cmd_Balancing' */
    *rty_Clsd = rtu_LTR_PID_Cmd_Balancing;
}

/*
 * Output and update for action system:
 *    '<S2832>/CondAirflow'
 *    '<S2832>/oHXAirflow'
 *    '<S1889>/CalcFlowUsingECT'
 *    '<S1889>/CalcFlowUsing_HtrCorClnt_Tmp'
 */
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_CondAirflow(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, THMR_VAR_INIT) rty_Out1)
{
    /* Inport: '<S2837>/In1' */
    *rty_Out1 = rtu_In1;
}

/*
 * Output and update for action system:
 *    '<S2928>/IfAct1'
 *    '<S2928>/IfAct3'
 *    '<S2928>/IfAct5'
 *    '<S2928>/IfAct7'
 *    '<S2928>/IfAct9'
 *    '<S2928>/IfAct11'
 *    '<S2928>/IfAct13'
 *    '<S2928>/IfAct15'
 *    '<S2928>/IfAct17'
 */
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_IfAct1(P2VAR(float32, AUTOMATIC,
    THMR_VAR_INIT) rty_Out1)
{
    /* SignalConversion generated from: '<S2967>/Out1' incorporates:
     *  Constant: '<S2967>/Constant'
     */
    *rty_Out1 = 0.0F;
}

/*
 * Output and update for action system:
 *    '<S1889>/Default'
 *    '<S1161>/IfActionSubsystem1'
 */
static FUNC(void, THMR_CODE_LOCAL) THMR_ac_Default(P2VAR(float32, AUTOMATIC,
    THMR_VAR_INIT) rty_Out1)
{
    /* SignalConversion generated from: '<S1919>/Out1' incorporates:
     *  Constant: '<S1933>/Calib'
     */
    *rty_Out1 = KeTHMR_dV_HT_AuxPmpFlw_HtrOnDflt;
}

/*
 * Output and update for action system:
 *    '<S724>/FCL_Cooling_Pos'
 *    '<S724>/FCL_Dflt_Pos'
 */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

static FUNC(void, THMR_CODE_LOCAL) THMR_ac_FCL_Cooling_Pos(P2VAR(float32,
    AUTOMATIC, THMR_VAR_INIT) rty_Clsd)
{
    /* SignalConversion generated from: '<S760>/Clsd' incorporates:
     *  Constant: '<S764>/Calib'
     */
    *rty_Clsd = KeTHMR_Pct_FCVlv_CntThruRad;
}

#endif

/* Function for Chart: '<S71>/AfterRun' */
static void THMR__enter_atomic_AfterRunInit(void)
{
    /* Entry 'AfterRunInit': '<S3614>:1' */
    THMR_ac_DW.NeTHMR_t_PumpRunTmr = 0U;
    THMR_ac_B.VeTHMR_t_AfterRunTimeForRq = 0U;
    THMR_ac_B.VeTHMR_t_TimeRemainForAftrrun = 0.0F;
    THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B = KeTHMR_e_No_AfterRun;
    THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq = KeTHMR_e_No_AfterRun;
    THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M = KeTHMR_e_No_AfterRun;
    THMR_ac_B.VeTHMR_t_WaitTimeFrAftrRun = 0.0F;
    THMR_ac_B.VeTHMR_t_RadFanTurnONTimr = 0.0F;
    THMR_ac_B.VeTHMR_b_thermalActivityCmplt = false;
    THMR_ac_B.VeTHMR_b_AftrRunFanRq = false;
    THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
    THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_AfterRunInit;
}

/* Function for Chart: '<S71>/AfterRun' */
static void THMR_ac_AlternatorMode(const boolean *Logical4, const boolean
    *Gain_cm, const boolean *Switch2_e, const TeCITR_e_FOTA_Install_Type
    *Switch2_i, const TeTMIR_e_ECM_LTP_FanAftRunRq *Switch1_ed, const
    TeTHMR_e_EmrgcyFanRq_Lvl *Switch1_i)
{
    uint32 tmpRead;
    TePMDR_e_KeyStatus tmp_0;
    TeTMIR_e_ECM_LTP_FanAftRunRq tmp;
    TeTMIR_e_ECM_LTP_FanAftRunRq tmp_1;
    boolean tmp_2;
    THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_AlternatorMode;

    /* Inport: '<Root>/VePLTR_t_RTC_CurrentTime' */
    /* During 'AlternatorMode': '<S3614>:212' */
    /* Transition: '<S3614>:220' */
    /* Transition: '<S3614>:225' */
    (void)Rte_Read_VePLTR_t_RTC_CurrentTime_Value(&tmpRead);

    /* Switch: '<S43>/Switch2' incorporates:
     *  SignalConversion generated from: '<S2>/VePMDR_e_KeyStatus'
     *  Switch: '<S3629>/Switch1'
     *  Switch: '<S3630>/Switch1'
     *  Switch: '<S3653>/Switch1'
     */
    if ((((uint32)(*Switch2_i)) == CeCITR_e_FOTANow) || (((uint32)(*Switch2_i)) ==
         CeCITR_e_FOTASchedule))
    {
        /* Transition: '<S3614>:186' */
        /* Exit 'AlternatorMode': '<S3614>:212' */
        THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
        THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_FOTARequested;

        /* Entry 'FOTARequested': '<S3614>:180' */
        THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M = CeTMIR_e_No_AftRunRequest;
        THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
            THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
        THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_FOTARequested;
        THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
        THMR_ac_B.VeTHMR_b_AftrRunFanRq = false;
        THMR_ac_B.VeTHMR_b_thermalActivityCmplt = true;
    }
    else
    {
        tmp = THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
        tmp_0 = THMR_ac_B.TmpSignalConversionAtVePMDR_e_K;
        tmp_1 = THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B;
        tmp_2 = ((!THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i) || (*Gain_cm));
        if (((((((uint32)tmp) != CeTMIR_e_No_AftRunRequest) && (((uint32)tmp) !=
                CeTMIR_e_SNA_AftRunRequest)) && ((((uint32)tmp_0) ==
                CePMDR_e_KeySt_Off) || (((uint32)tmp_0) == CePMDR_e_KeySt_Acc)))
             && (*Logical4)) || (((((((uint32)tmp_1) !=
                 CeTMIR_e_No_AftRunRequest) && (((uint32)tmp_1) !=
                 CeTMIR_e_SNA_AftRunRequest)) && tmp_2) && (((uint32)tmp_0) ==
                CePMDR_e_KeySt_Off)) && (*Logical4)))
        {
            /* Transition: '<S3614>:215' */
            /* Transition: '<S3614>:242' */
            /* Transition: '<S3614>:235' */
            /* Transition: '<S3614>:236' */
            /* Transition: '<S3614>:237' */
            /* Exit 'AlternatorMode': '<S3614>:212' */
            THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                THMR_ac_IN_RadFanAndPumpCmmnd;

            /* Entry 'RadFanAndPumpCmmnd': '<S3614>:6' */
            THMR_ac_B.VeTHMR_b_AftrRunFanRq = (((KaTHMR_Cf_ECM_FanRqAftrRun
                [(*Switch1_ed)]) || (KaTHMR_Cf_HCP_FanRqAftrRun[(*Switch1_i)])) ||
                (KaTHMR_Cf_PIM_FanRqAftrRun[(THMR_ac_B.Switch1_ex)]));
            THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B =
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
            THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_CmmndRadFanAndPump;
            THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
        }
        else if ((((((uint32)tmp_0) != CePMDR_e_KeySt_Off) && (((uint32)tmp_0)
                    != CePMDR_e_KeySt_Acc)) || (((((uint32)tmp) ==
                     CeTMIR_e_No_AftRunRequest) || (((uint32)tmp) ==
                     CeTMIR_e_SNA_AftRunRequest)) &&
                   (THMR_ac_B.VeTHMR_t_WaitTimeFrAftrRun >=
                    KeTHMR_t_MaxWaitTimeFrAftrRnRq))) || (*Switch2_e))
        {
            /* Transition: '<S3614>:217' */
            /* Transition: '<S3614>:240' */
            /* Exit 'AlternatorMode': '<S3614>:212' */
            THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
            THMR_ac_B.RstKeyLtch = true;
            THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_AfterRunInit;
            THMR__enter_atomic_AfterRunInit();
        }
        else if (((((((uint32)tmp_1) == CeTMIR_e_No_AftRunRequest) || (((uint32)
                      tmp_1) == CeTMIR_e_SNA_AftRunRequest)) && tmp_2) &&
                  ((((uint32)tmp_0) == CePMDR_e_KeySt_Off) || (((uint32)tmp_0) ==
                    CePMDR_e_KeySt_Acc))) && (*Logical4))
        {
            /* Transition: '<S3614>:218' */
            /* Transition: '<S3614>:228' */
            /* Transition: '<S3614>:229' */
            /* Exit 'AlternatorMode': '<S3614>:212' */
            THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
            THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_AfterRunComplt;

            /* Entry 'AfterRunComplt': '<S3614>:53' */
            THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_AftrRunComplete;
            THMR_ac_DW.NeTHMR_t_PumpRunTmr = (THMR_ac_DW.NeTHMR_t_PumpRunTmr +
                tmpRead) - THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1;
            THMR_ac_B.VeTHMR_t_AfterRunTimeForRq = (uint32)
                KaTHMR_t_AfterRunTimeForRq
                [(THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq)];
            THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu = tmpRead;
        }
        else
        {
            /* Transition: '<S3614>:219' */
            /* Transition: '<S3614>:171' */
            /* Transition: '<S3614>:174' */
            /* Transition: '<S3614>:175' */
            if (THMR_ac_DW.NeTHMR_t_PumpRunTmr >
                    THMR_ac_B.VeTHMR_t_AfterRunTimeForRq)
            {
                /* Transition: '<S3614>:150' */
                /* Transition: '<S3614>:152' */
                /* Transition: '<S3614>:153' */
                /* Exit 'AlternatorMode': '<S3614>:212' */
                THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
                THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
                    CeTMIR_e_No_AftRunRequest;
                THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_SM_Entry;

                /* Entry 'SM_Entry': '<S3614>:60' */
                THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_ChartEntry;
                THMR_ac_B.VeTHMR_t_RTC_InitDelay = 0.0F;
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B =
                    KeTHMR_e_AfterRunDefault;
            }
            else
            {
                THMR_ac_DW.NeTHMR_t_PumpRunTmr += tmpRead -
                    THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu;
                THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu = tmpRead;
            }
        }
    }

    /* End of Switch: '<S43>/Switch2' */
}

/* Function for Chart: '<S71>/AfterRun' */
static void THMR_ac_CalNewAfterRunRq(const boolean *Logical4, const boolean
    *Gain_cm, const boolean *Switch2_e, const TeCITR_e_FOTA_Install_Type
    *Switch2_i, const TeTMIR_e_ECM_LTP_FanAftRunRq *Switch1_ed, const
    TeTHMR_e_EmrgcyFanRq_Lvl *Switch1_i)
{
    uint32 tmpRead;
    TePMDR_e_KeyStatus tmp;
    TeTMIR_e_ECM_LTP_FanAftRunRq tmp_0;
    boolean tmp_1;
    THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_CalNewAftrRunRq;

    /* Inport: '<Root>/VePLTR_t_RTC_CurrentTime' */
    /* During 'CalNewAfterRunRq': '<S3614>:14' */
    /* Transition: '<S3614>:206' */
    /* Transition: '<S3614>:198' */
    /* Transition: '<S3614>:199' */
    /* Transition: '<S3614>:201' */
    /* Transition: '<S3614>:204' */
    (void)Rte_Read_VePLTR_t_RTC_CurrentTime_Value(&tmpRead);

    /* Switch: '<S43>/Switch2' incorporates:
     *  SignalConversion generated from: '<S2>/VePMDR_e_KeyStatus'
     *  Switch: '<S3629>/Switch1'
     *  Switch: '<S3630>/Switch1'
     *  Switch: '<S3653>/Switch1'
     *  Switch: '<S3954>/Switch'
     */
    if ((((uint32)(*Switch2_i)) == CeCITR_e_FOTANow) || (((uint32)(*Switch2_i)) ==
         CeCITR_e_FOTASchedule))
    {
        /* Transition: '<S3614>:186' */
        /* Exit 'CalNewAfterRunRq': '<S3614>:14' */
        THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
        THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_FOTARequested;

        /* Entry 'FOTARequested': '<S3614>:180' */
        THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M = CeTMIR_e_No_AftRunRequest;
        THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
            THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
        THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_FOTARequested;
        THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
        THMR_ac_B.VeTHMR_b_AftrRunFanRq = false;
        THMR_ac_B.VeTHMR_b_thermalActivityCmplt = true;
    }
    else
    {
        /* Transition: '<S3614>:68' */
        /* Transition: '<S3614>:72' */
        /* Transition: '<S3614>:74' */
        /* Transition: '<S3614>:76' */
        /* Transition: '<S3614>:78' */
        tmp = THMR_ac_B.TmpSignalConversionAtVePMDR_e_K;
        if (((((uint32)tmp) != CePMDR_e_KeySt_Off) && (((uint32)tmp) !=
                CePMDR_e_KeySt_Acc)) || (*Switch2_e))
        {
            /* Transition: '<S3614>:82' */
            /* Transition: '<S3614>:84' */
            /* Transition: '<S3614>:85' */
            /* Exit 'CalNewAfterRunRq': '<S3614>:14' */
            THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
            THMR_ac_B.RstKeyLtch = true;
            THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_AfterRunInit;
            THMR__enter_atomic_AfterRunInit();
        }
        else
        {
            /* Transition: '<S3614>:172' */
            /* Transition: '<S3614>:174' */
            /* Transition: '<S3614>:175' */
            if (THMR_ac_DW.NeTHMR_t_PumpRunTmr >
                    THMR_ac_B.VeTHMR_t_AfterRunTimeForRq)
            {
                /* Transition: '<S3614>:150' */
                /* Transition: '<S3614>:152' */
                /* Transition: '<S3614>:153' */
                /* Exit 'CalNewAfterRunRq': '<S3614>:14' */
                THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
                THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
                    CeTMIR_e_No_AftRunRequest;
                THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_SM_Entry;

                /* Entry 'SM_Entry': '<S3614>:60' */
                THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_ChartEntry;
                THMR_ac_B.VeTHMR_t_RTC_InitDelay = 0.0F;
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B =
                    KeTHMR_e_AfterRunDefault;
            }
            else
            {
                tmp_0 = THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B;
                tmp_1 = ((!THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i) ||
                         (*Gain_cm));
                if ((((((((uint32)tmp_0) != CeTMIR_e_No_AftRunRequest) &&
                        (((uint32)tmp_0) != CeTMIR_e_SNA_AftRunRequest)) &&
                        tmp_1) && (((uint32)tmp) == CePMDR_e_KeySt_Off)) &&
                        (*Logical4)) && (((uint32)VeTHMR_e_HybSysSt) !=
                                         CeHPMR_e_OPERATIONAL_ALTERNATOR))
                {
                    /* Transition: '<S3614>:47' */
                    /* Transition: '<S3614>:90' */
                    /* Exit 'CalNewAfterRunRq': '<S3614>:14' */
                    THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                        THMR_ac_IN_RadFanAndPumpCmmnd;

                    /* Entry 'RadFanAndPumpCmmnd': '<S3614>:6' */
                    THMR_ac_B.VeTHMR_b_AftrRunFanRq =
                        (((KaTHMR_Cf_ECM_FanRqAftrRun[(*Switch1_ed)]) ||
                          (KaTHMR_Cf_HCP_FanRqAftrRun[(*Switch1_i)])) ||
                         (KaTHMR_Cf_PIM_FanRqAftrRun[(THMR_ac_B.Switch1_ex)]));
                    THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B =
                        THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
                    THMR_ac_B.VeTHMR_e_AftrRunStateMachine =
                        CeTHMR_e_CmmndRadFanAndPump;
                    THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
                }
                else if (((((((uint32)tmp_0) == CeTMIR_e_No_AftRunRequest) ||
                            (((uint32)tmp_0) == CeTMIR_e_SNA_AftRunRequest)) &&
                           tmp_1) && ((((uint32)tmp) == CePMDR_e_KeySt_Off) ||
                                      (((uint32)tmp) == CePMDR_e_KeySt_Acc))) &&
                         (*Logical4))
                {
                    /* Transition: '<S3614>:55' */
                    /* Exit 'CalNewAfterRunRq': '<S3614>:14' */
                    THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
                    THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                        THMR_ac_IN_AfterRunComplt;

                    /* Entry 'AfterRunComplt': '<S3614>:53' */
                    THMR_ac_B.VeTHMR_e_AftrRunStateMachine =
                        CeTHMR_e_AftrRunComplete;
                    THMR_ac_DW.NeTHMR_t_PumpRunTmr =
                        (THMR_ac_DW.NeTHMR_t_PumpRunTmr + tmpRead) -
                        THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1;
                    THMR_ac_B.VeTHMR_t_AfterRunTimeForRq = (uint32)
                        KaTHMR_t_AfterRunTimeForRq
                        [(THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq)];
                    THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu = tmpRead;
                }
                else if (((uint32)VeTHMR_e_HybSysSt) ==
                         CeHPMR_e_OPERATIONAL_ALTERNATOR)
                {
                    /* Transition: '<S3614>:214' */
                    /* Exit 'CalNewAfterRunRq': '<S3614>:14' */
                    THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
                    THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                        THMR_ac_IN_AlternatorMode;

                    /* Entry 'AlternatorMode': '<S3614>:212' */
                    THMR_ac_DW.VeTHMR_e_HCP_LTP_FanAftRun_Rq_A =
                        KaTHMR_Cf_AlternatorMode
                        [(THMR_ac_DW.VeTHMR_e_HCP_LTP_FanAftRun_Rq_A)];
                    THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
                    THMR_ac_B.VeTHMR_e_AftrRunStateMachine =
                        CeTHMR_e_AlternatorMode;
                }
                else
                {
                    THMR_ac_DW.NeTHMR_t_PumpRunTmr += tmpRead -
                        THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu;
                    THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu = tmpRead;
                }
            }
        }
    }

    /* End of Switch: '<S43>/Switch2' */
}

/* Function for Chart: '<S71>/AfterRun' */
static void THMR_ac_DeterminAftrRunRq(const boolean *Logical4, const boolean
    *Switch2_e, const TeCITR_e_FOTA_Install_Type *Switch2_i, const
    TeTMIR_e_ECM_LTP_FanAftRunRq *Switch1_ed, const TeTHMR_e_EmrgcyFanRq_Lvl
    *Switch1_i)
{
    uint32 tmpRead;
    TePMDR_e_KeyStatus tmp;
    TeTMIR_e_ECM_LTP_FanAftRunRq tmp_0;
    THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_DtermineAfterRunRequest;

    /* Inport: '<Root>/VePLTR_t_RTC_CurrentTime' */
    /* During 'DeterminAftrRunRq': '<S3614>:3' */
    /* Transition: '<S3614>:203' */
    /* Transition: '<S3614>:201' */
    /* Transition: '<S3614>:204' */
    (void)Rte_Read_VePLTR_t_RTC_CurrentTime_Value(&tmpRead);

    /* Switch: '<S43>/Switch2' incorporates:
     *  SignalConversion generated from: '<S2>/VePMDR_e_KeyStatus'
     *  Switch: '<S3629>/Switch1'
     *  Switch: '<S3630>/Switch1'
     *  Switch: '<S3653>/Switch1'
     *  Switch: '<S3954>/Switch'
     */
    if ((((uint32)(*Switch2_i)) == CeCITR_e_FOTANow) || (((uint32)(*Switch2_i)) ==
         CeCITR_e_FOTASchedule))
    {
        /* Transition: '<S3614>:186' */
        /* Exit 'DeterminAftrRunRq': '<S3614>:3' */
        THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
        THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_FOTARequested;

        /* Entry 'FOTARequested': '<S3614>:180' */
        THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M = CeTMIR_e_No_AftRunRequest;
        THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
            THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
        THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_FOTARequested;
        THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
        THMR_ac_B.VeTHMR_b_AftrRunFanRq = false;
        THMR_ac_B.VeTHMR_b_thermalActivityCmplt = true;
    }
    else
    {
        tmp = THMR_ac_B.TmpSignalConversionAtVePMDR_e_K;
        tmp_0 = THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
        if ((((((uint32)tmp) != CePMDR_e_KeySt_Off) && (((uint32)tmp) !=
                CePMDR_e_KeySt_Acc)) || (((((uint32)tmp_0) ==
                CeTMIR_e_No_AftRunRequest) || (((uint32)tmp_0) ==
                CeTMIR_e_SNA_AftRunRequest)) &&
                (THMR_ac_B.VeTHMR_t_WaitTimeFrAftrRun >=
                 KeTHMR_t_MaxWaitTimeFrAftrRnRq))) || (*Switch2_e))
        {
            /* Transition: '<S3614>:81' */
            /* Transition: '<S3614>:84' */
            /* Transition: '<S3614>:85' */
            /* Exit 'DeterminAftrRunRq': '<S3614>:3' */
            THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
            THMR_ac_B.RstKeyLtch = true;
            THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_AfterRunInit;
            THMR__enter_atomic_AfterRunInit();
        }
        else if (((((((uint32)tmp_0) != CeTMIR_e_No_AftRunRequest) && (((uint32)
                      tmp_0) != CeTMIR_e_SNA_AftRunRequest)) && ((((uint32)tmp) ==
                     CePMDR_e_KeySt_Off) || (((uint32)tmp) == CePMDR_e_KeySt_Acc)))
                  && (*Logical4)) && (((uint32)VeTHMR_e_HybSysSt) !=
                  CeHPMR_e_OPERATIONAL_ALTERNATOR))
        {
            /* Transition: '<S3614>:7' */
            /* Exit 'DeterminAftrRunRq': '<S3614>:3' */
            THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                THMR_ac_IN_RadFanAndPumpCmmnd;

            /* Entry 'RadFanAndPumpCmmnd': '<S3614>:6' */
            THMR_ac_B.VeTHMR_b_AftrRunFanRq = (((KaTHMR_Cf_ECM_FanRqAftrRun
                [(*Switch1_ed)]) || (KaTHMR_Cf_HCP_FanRqAftrRun[(*Switch1_i)])) ||
                (KaTHMR_Cf_PIM_FanRqAftrRun[(THMR_ac_B.Switch1_ex)]));
            THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B =
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
            THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_CmmndRadFanAndPump;
            THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
        }
        else if (((uint32)VeTHMR_e_HybSysSt) == CeHPMR_e_OPERATIONAL_ALTERNATOR)
        {
            /* Transition: '<S3614>:213' */
            /* Exit 'DeterminAftrRunRq': '<S3614>:3' */
            THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
            THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_AlternatorMode;

            /* Entry 'AlternatorMode': '<S3614>:212' */
            THMR_ac_DW.VeTHMR_e_HCP_LTP_FanAftRun_Rq_A =
                KaTHMR_Cf_AlternatorMode
                [(THMR_ac_DW.VeTHMR_e_HCP_LTP_FanAftRun_Rq_A)];
            THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
            THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_AlternatorMode;
        }
        else
        {
            THMR_ac_B.VeTHMR_e_ECM_LTPFanAftRunRq_cf =
                KaTHMR_Cf_ECM_LTP_FanAftRunRq[(*Switch1_ed)];
            THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_c =
                KaTHMR_Cf_HCP_LTP_FanAftrRunRq[(*Switch1_i)];
            THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M =
                KaTHMR_Cf_ECM_LTP_FanAftRunRq[(sint32)fmax((float64)((sint32)
                ((THMR_ac_B.VeTHMR_e_ECM_LTPFanAftRunRq_cf >
                  THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_c) ? ((sint32)
                THMR_ac_B.VeTHMR_e_ECM_LTPFanAftRunRq_cf) : ((sint32)
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_c))), (float64)
                KaTHMR_Cf_PIM_LTP_FanAftrRunRq[(THMR_ac_B.Switch1_ex)])];
            THMR_ac_DW.VeTHMR_e_HCP_LTP_FanAftRun_Rq_A =
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
            THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
            THMR_ac_B.VeTHMR_t_WaitTimeFrAftrRun += KeTHMR_t_THMRTaskRt;
        }
    }

    /* End of Switch: '<S43>/Switch2' */
}

/* Function for Chart: '<S71>/AfterRun' */
static void THMR_ac_DetrmnAftrrunRq(void)
{
    sint32 exitg1;
    TeTMIR_e_ECM_LTP_FanAftRunRq AfterRunIndex;

    /* Graphical Function 'DetrmnAftrrunRq': '<S3614>:16' */
    /* Transition: '<S3614>:17' */
    if (THMR_ac_B.VeTHMR_t_TimeRemainForAftrrun >= KeTHMR_t_MinAftrRunTime)
    {
        /* Transition: '<S3614>:21' */
        /* Transition: '<S3614>:24' */
        AfterRunIndex = CeTMIR_e_No_AftRunRequest;
        do
        {
            exitg1 = 0;
            if (((sint32)AfterRunIndex) < ((sint32)KeTHMR_i_AftrRunArryLim))
            {
                /* Transition: '<S3614>:26' */
                /* Transition: '<S3614>:28' */
                if (THMR_ac_B.VeTHMR_t_TimeRemainForAftrrun <= ((float32)
                        KaTHMR_t_AfterRunTimeForRq[(AfterRunIndex)]))
                {
                    /* Transition: '<S3614>:30' */
                    /* Transition: '<S3614>:42' */
                    THMR_ac_B.VeTHMR_e_AfterRunRqNew = AfterRunIndex;

                    /* Transition: '<S3614>:43' */
                    exitg1 = 1;
                }
                else
                {
                    /* Transition: '<S3614>:35' */
                    AfterRunIndex = KaTHMR_Cf_ECM_LTP_FanAftRunRq[((sint32)
                        AfterRunIndex) + 1];

                    /* Transition: '<S3614>:36' */
                    /* Transition: '<S3614>:37' */
                }
            }
            else
            {
                /* Transition: '<S3614>:39' */
                /* Transition: '<S3614>:41' */
                THMR_ac_B.VeTHMR_e_AfterRunRqNew = CeTMIR_e_No_AftRunRequest;
                exitg1 = 1;
            }
        }
        while (exitg1 == 0);

        /* Transition: '<S3614>:45' */
    }
    else
    {
        /* Transition: '<S3614>:46' */
        THMR_ac_B.VeTHMR_e_AfterRunRqNew = CeTMIR_e_No_AftRunRequest;
    }
}

/* Function for Chart: '<S71>/AfterRun' */
static void PlugInCharging_CmndOutOfAftrRun(const boolean *Gain_cm, const
    boolean *Switch2_e, const TeCITR_e_FOTA_Install_Type *Switch2_i)
{
    uint32 tmpRead;
    TePMDR_e_KeyStatus tmp;
    THMR_ac_B.VeTHMR_e_AftrRunStateMachine =
        CeTHMR_e_PlugInCharging_CmndOutOfAftrRun;

    /* Inport: '<Root>/VePLTR_t_RTC_CurrentTime' */
    /* During 'PlugInCharging_CmndOutOfAftrRun': '<S3614>:10' */
    /* Transition: '<S3614>:202' */
    /* Transition: '<S3614>:204' */
    (void)Rte_Read_VePLTR_t_RTC_CurrentTime_Value(&tmpRead);

    /* Switch: '<S43>/Switch2' incorporates:
     *  SignalConversion generated from: '<S2>/VePMDR_e_KeyStatus'
     */
    if ((((uint32)(*Switch2_i)) == CeCITR_e_FOTANow) || (((uint32)(*Switch2_i)) ==
         CeCITR_e_FOTASchedule))
    {
        /* Transition: '<S3614>:186' */
        /* Exit 'PlugInCharging_CmndOutOfAftrRun': '<S3614>:10' */
        THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
        THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_FOTARequested;

        /* Entry 'FOTARequested': '<S3614>:180' */
        THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M = CeTMIR_e_No_AftRunRequest;
        THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
            THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
        THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_FOTARequested;
        THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
        THMR_ac_B.VeTHMR_b_AftrRunFanRq = false;
        THMR_ac_B.VeTHMR_b_thermalActivityCmplt = true;
    }
    else
    {
        /* Transition: '<S3614>:59' */
        /* Transition: '<S3614>:69' */
        /* Transition: '<S3614>:72' */
        /* Transition: '<S3614>:74' */
        /* Transition: '<S3614>:76' */
        /* Transition: '<S3614>:78' */
        tmp = THMR_ac_B.TmpSignalConversionAtVePMDR_e_K;
        if (((((uint32)tmp) != CePMDR_e_KeySt_Off) && (((uint32)tmp) !=
                CePMDR_e_KeySt_Acc)) || (*Switch2_e))
        {
            /* Transition: '<S3614>:82' */
            /* Transition: '<S3614>:84' */
            /* Transition: '<S3614>:85' */
            /* Exit 'PlugInCharging_CmndOutOfAftrRun': '<S3614>:10' */
            THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
            THMR_ac_B.RstKeyLtch = true;
            THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_AfterRunInit;
            THMR__enter_atomic_AfterRunInit();
        }
        else
        {
            /* Transition: '<S3614>:169' */
            /* Transition: '<S3614>:171' */
            /* Transition: '<S3614>:174' */
            /* Transition: '<S3614>:175' */
            if (THMR_ac_DW.NeTHMR_t_PumpRunTmr >
                    THMR_ac_B.VeTHMR_t_AfterRunTimeForRq)
            {
                /* Transition: '<S3614>:150' */
                /* Transition: '<S3614>:152' */
                /* Transition: '<S3614>:153' */
                /* Exit 'PlugInCharging_CmndOutOfAftrRun': '<S3614>:10' */
                THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
                THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
                    CeTMIR_e_No_AftRunRequest;
                THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_SM_Entry;

                /* Entry 'SM_Entry': '<S3614>:60' */
                THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_ChartEntry;
                THMR_ac_B.VeTHMR_t_RTC_InitDelay = 0.0F;
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B =
                    KeTHMR_e_AfterRunDefault;
            }
            else if (((THMR_ac_DW.VeTHMR_b_isChargingTemp !=
                       THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i) || (*Gain_cm))
                     && ((((uint32)tmp) == CePMDR_e_KeySt_Off) || (((uint32)tmp)
                       == CePMDR_e_KeySt_Acc)))
            {
                /* Transition: '<S3614>:15' */
                /* Exit 'PlugInCharging_CmndOutOfAftrRun': '<S3614>:10' */
                THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead;
                THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                    THMR_ac_IN_CalNewAfterRunRq;

                /* Entry 'CalNewAfterRunRq': '<S3614>:14' */
                THMR_ac_B.VeTHMR_t_AfterRunTimeForRq = (uint32)
                    KaTHMR_t_AfterRunTimeForRq
                    [(THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq)];
                THMR_ac_B.VeTHMR_t_TimeRemainForAftrrun = (float32)((uint32)
                    (THMR_ac_B.VeTHMR_t_AfterRunTimeForRq -
                     THMR_ac_DW.NeTHMR_t_PumpRunTmr));
                THMR_ac_DetrmnAftrrunRq();
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M =
                    THMR_ac_B.VeTHMR_e_AfterRunRqNew;
                THMR_ac_DW.VeTHMR_e_HCP_LTP_FanAftRun_Rq_A =
                    THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B =
                    THMR_ac_B.VeTHMR_e_AfterRunRqNew;
                THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
                    THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B;
                THMR_ac_B.VeTHMR_e_AftrRunStateMachine =
                    CeTHMR_e_CalNewAftrRunRq;
                THMR_ac_B.VeTHMR_t_AfterRunTimeForRq = (uint32)
                    KaTHMR_t_AfterRunTimeForRq
                    [(THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq)];
                THMR_ac_DW.NeTHMR_t_PumpRunTmr = tmpRead -
                    THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1;
                THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu = tmpRead;
            }
            else
            {
                THMR_ac_DW.NeTHMR_t_PumpRunTmr += tmpRead -
                    THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu;
                THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu = tmpRead;
            }
        }
    }

    /* End of Switch: '<S43>/Switch2' */
}

/* Function for Chart: '<S83>/ThermalMode' */
static void THMR_enter_internal_ThermalMode(void)
{
    boolean guard1 = false;

    /* Constant: '<S5293>/Constant' incorporates:
     *  Constant: '<S5277>/Calib'
     */
    /* Entry Internal 'ThermalMode': '<S4096>:8' */
    /* Transition: '<S4096>:69' */
    guard1 = false;
    if (CeOBCR_e_NotPlugedIn_HCP != ((uint32)KeTHMR_e_PlugSts_RU_Test))
    {
        /* Transition: '<S4096>:68' */
        guard1 = true;
    }
    else if ((CeOBCR_e_NotPlugedIn_HCP == ((uint32)KeTHMR_e_PlugSts_RU_Test)) &&
             (((uint32)KeTHMR_e_PlugSts_RU_Test) == CeOBCR_e_NotPlugedIn_HCP))
    {
        /* Transition: '<S4096>:71' */
        THMR_ac_DW.is_ThermalMode = THMR_ac_IN_OffPlug;

        /* Constant: '<S4052>/Calib' */
        /* Entry Internal 'OffPlug': '<S4096>:16' */
        if ((((uint32)KeTHMR_e_IgnStatusIn_RU_Test) != CePMDR_e_PowerMode_Run) ||
            (((uint32)KeTHMR_e_IgnStatusIn_RU_Test) != CePMDR_e_PowerMode_Run))
        {
            /* Transition: '<S4096>:84' */
            /* Transition: '<S4096>:87' */
            THMR_ac_DW.is_OffPlug = THMR_ac_IN_VehicleOff;

            /* Entry 'VehicleOff': '<S4096>:18' */
        }
        else
        {
            /* Transition: '<S4096>:85' */
            THMR_ac_DW.is_OffPlug = THMR_ac_IN_VehicleOn;

            /* Entry 'VehicleOn': '<S4096>:17' */
        }
    }
    else if ((CeOBCR_e_NotPlugedIn_HCP == ((uint32)KeTHMR_e_PlugSts_RU_Test)) &&
             (((uint32)KeTHMR_e_PlugSts_RU_Test) == CeOBCR_e_PlugedIn_HCP))
    {
        /* Transition: '<S4096>:57' */
        THMR_ac_DW.is_ThermalMode = THMR_ac_IN_OnPlug;

        /* Constant: '<S4052>/Calib' */
        /* Entry Internal 'OnPlug': '<S4096>:9' */
        if ((((uint32)KeTHMR_e_IgnStatusIn_RU_Test) != CePMDR_e_PowerMode_Run) ||
            (((uint32)KeTHMR_e_IgnStatusIn_RU_Test) != CePMDR_e_PowerMode_Run))
        {
            /* Transition: '<S4096>:78' */
            /* Transition: '<S4096>:80' */
            THMR_ac_DW.is_OnPlug = THMR_ac_IN_VehicleOff;

            /* Entry 'VehicleOff': '<S4096>:10' */
        }
        else
        {
            /* Transition: '<S4096>:81' */
            THMR_ac_DW.is_OnPlug = THMR_ac_IN_VehicleOn;

            /* Entry 'VehicleOn': '<S4096>:11' */
        }
    }
    else
    {
        /* Transition: '<S4096>:72' */
        guard1 = true;
    }

    if (guard1)
    {
        THMR_ac_DW.is_ThermalMode = THMR_ac_IN_Init;

        /* Entry 'Init': '<S4096>:14' */
        THMR_ac_DW.Init_count = 0.0F;
    }

    /* End of Constant: '<S5293>/Constant' */
}

/* Function for Chart: '<S83>/ThermalMode' */
static void THMR_ac_ThermalMode(const boolean *Gain_hm, const boolean *Gain_he,
    const boolean *Gain_n)
{
    boolean tmp;
    boolean tmp_0;

    /* During 'ThermalMode': '<S4096>:8' */
    switch (THMR_ac_DW.is_ThermalMode)
    {
      case THMR_ac_IN_Fault:
        /* During 'Fault': '<S4096>:15' */
        tmp_0 = !(*Gain_n);
        tmp = !(*Gain_he);

        /* Constant: '<S5277>/Calib' */
        if ((tmp_0 && (((uint32)KeTHMR_e_PlugSts_RU_Test) ==
                       CeOBCR_e_PlugedIn_HCP)) && tmp)
        {
            /* Transition: '<S4096>:59' */
            THMR_ac_DW.is_ThermalMode = THMR_ac_IN_OnPlug;

            /* Constant: '<S4052>/Calib' */
            /* Entry Internal 'OnPlug': '<S4096>:9' */
            if ((((uint32)KeTHMR_e_IgnStatusIn_RU_Test) !=
                    CePMDR_e_PowerMode_Run) || (((uint32)
                    KeTHMR_e_IgnStatusIn_RU_Test) != CePMDR_e_PowerMode_Run))
            {
                /* Transition: '<S4096>:78' */
                /* Transition: '<S4096>:80' */
                THMR_ac_DW.is_OnPlug = THMR_ac_IN_VehicleOff;

                /* Entry 'VehicleOff': '<S4096>:10' */
            }
            else
            {
                /* Transition: '<S4096>:81' */
                THMR_ac_DW.is_OnPlug = THMR_ac_IN_VehicleOn;

                /* Entry 'VehicleOn': '<S4096>:11' */
            }
        }
        else if (*Gain_he)
        {
            /* Transition: '<S4096>:67' */
            THMR_ac_DW.is_ThermalMode = THMR_ac_IN_Standby;

            /* Entry 'Standby': '<S4096>:12' */
        }
        else
        {
            if ((tmp_0 && (((uint32)KeTHMR_e_PlugSts_RU_Test) ==
                           CeOBCR_e_NotPlugedIn_HCP)) && tmp)
            {
                /* Transition: '<S4096>:75' */
                THMR_ac_DW.is_ThermalMode = THMR_ac_IN_OffPlug;

                /* Constant: '<S4052>/Calib' */
                /* Entry Internal 'OffPlug': '<S4096>:16' */
                if ((((uint32)KeTHMR_e_IgnStatusIn_RU_Test) !=
                        CePMDR_e_PowerMode_Run) || (((uint32)
                        KeTHMR_e_IgnStatusIn_RU_Test) != CePMDR_e_PowerMode_Run))
                {
                    /* Transition: '<S4096>:84' */
                    /* Transition: '<S4096>:87' */
                    THMR_ac_DW.is_OffPlug = THMR_ac_IN_VehicleOff;

                    /* Entry 'VehicleOff': '<S4096>:18' */
                }
                else
                {
                    /* Transition: '<S4096>:85' */
                    THMR_ac_DW.is_OffPlug = THMR_ac_IN_VehicleOn;

                    /* Entry 'VehicleOn': '<S4096>:17' */
                }
            }
        }
        break;

      case THMR_ac_IN_Init:
        /* During 'Init': '<S4096>:14' */
        tmp_0 = !(*Gain_n);

        /* Constant: '<S5277>/Calib' */
        if (((THMR_ac_DW.Init_count > KeTHMR_Cnt_InitCount) && tmp_0) &&
                (((uint32)KeTHMR_e_PlugSts_RU_Test) == CeOBCR_e_PlugedIn_HCP))
        {
            /* Transition: '<S4096>:58' */
            THMR_ac_DW.is_ThermalMode = THMR_ac_IN_OnPlug;

            /* Constant: '<S4052>/Calib' */
            /* Entry Internal 'OnPlug': '<S4096>:9' */
            if ((((uint32)KeTHMR_e_IgnStatusIn_RU_Test) !=
                    CePMDR_e_PowerMode_Run) || (((uint32)
                    KeTHMR_e_IgnStatusIn_RU_Test) != CePMDR_e_PowerMode_Run))
            {
                /* Transition: '<S4096>:78' */
                /* Transition: '<S4096>:80' */
                THMR_ac_DW.is_OnPlug = THMR_ac_IN_VehicleOff;

                /* Entry 'VehicleOff': '<S4096>:10' */
            }
            else
            {
                /* Transition: '<S4096>:81' */
                THMR_ac_DW.is_OnPlug = THMR_ac_IN_VehicleOn;

                /* Entry 'VehicleOn': '<S4096>:11' */
            }
        }
        else if (*Gain_n)
        {
            /* Transition: '<S4096>:66' */
            THMR_ac_DW.is_ThermalMode = THMR_ac_IN_Fault;

            /* Entry 'Fault': '<S4096>:15' */
        }
        else if (((THMR_ac_DW.Init_count > KeTHMR_Cnt_InitCount) && tmp_0) &&
                 (((uint32)KeTHMR_e_PlugSts_RU_Test) == CeOBCR_e_NotPlugedIn_HCP))
        {
            /* Transition: '<S4096>:73' */
            THMR_ac_DW.is_ThermalMode = THMR_ac_IN_OffPlug;

            /* Constant: '<S4052>/Calib' */
            /* Entry Internal 'OffPlug': '<S4096>:16' */
            if ((((uint32)KeTHMR_e_IgnStatusIn_RU_Test) !=
                    CePMDR_e_PowerMode_Run) || (((uint32)
                    KeTHMR_e_IgnStatusIn_RU_Test) != CePMDR_e_PowerMode_Run))
            {
                /* Transition: '<S4096>:84' */
                /* Transition: '<S4096>:87' */
                THMR_ac_DW.is_OffPlug = THMR_ac_IN_VehicleOff;

                /* Entry 'VehicleOff': '<S4096>:18' */
            }
            else
            {
                /* Transition: '<S4096>:85' */
                THMR_ac_DW.is_OffPlug = THMR_ac_IN_VehicleOn;

                /* Entry 'VehicleOn': '<S4096>:17' */
            }
        }
        else
        {
            /* Transition: '<S4096>:47' */
            THMR_ac_DW.Init_count++;
        }
        break;

      case THMR_ac_IN_OffPlug:
        /* During 'OffPlug': '<S4096>:16' */
        tmp_0 = !(*Gain_n);

        /* Constant: '<S5277>/Calib' */
        if (((((uint32)KeTHMR_e_PlugSts_RU_Test) == CeOBCR_e_PlugedIn_HCP) &&
                tmp_0) && (!(*Gain_he)))
        {
            /* Transition: '<S4096>:56' */
            /* Exit Internal 'OffPlug': '<S4096>:16' */
            THMR_ac_DW.is_OffPlug = THMR_ac_IN_NO_ACTIVE_CHILD;
            THMR_ac_DW.is_ThermalMode = THMR_ac_IN_OnPlug;

            /* Constant: '<S4052>/Calib' */
            /* Entry Internal 'OnPlug': '<S4096>:9' */
            if ((((uint32)KeTHMR_e_IgnStatusIn_RU_Test) !=
                    CePMDR_e_PowerMode_Run) || (((uint32)
                    KeTHMR_e_IgnStatusIn_RU_Test) != CePMDR_e_PowerMode_Run))
            {
                /* Transition: '<S4096>:78' */
                /* Transition: '<S4096>:80' */
                THMR_ac_DW.is_OnPlug = THMR_ac_IN_VehicleOff;

                /* Entry 'VehicleOff': '<S4096>:10' */
            }
            else
            {
                /* Transition: '<S4096>:81' */
                THMR_ac_DW.is_OnPlug = THMR_ac_IN_VehicleOn;

                /* Entry 'VehicleOn': '<S4096>:11' */
            }
        }
        else if (*Gain_n)
        {
            /* Transition: '<S4096>:74' */
            /* Exit Internal 'OffPlug': '<S4096>:16' */
            THMR_ac_DW.is_OffPlug = THMR_ac_IN_NO_ACTIVE_CHILD;
            THMR_ac_DW.is_ThermalMode = THMR_ac_IN_Fault;

            /* Entry 'Fault': '<S4096>:15' */
        }
        else if ((*Gain_he) && tmp_0)
        {
            /* Transition: '<S4096>:76' */
            /* Exit Internal 'OffPlug': '<S4096>:16' */
            THMR_ac_DW.is_OffPlug = THMR_ac_IN_NO_ACTIVE_CHILD;
            THMR_ac_DW.is_ThermalMode = THMR_ac_IN_Standby;

            /* Entry 'Standby': '<S4096>:12' */
        }
        else if (((uint32)THMR_ac_DW.is_OffPlug) == THMR_ac_IN_VehicleOff)
        {
            /* Constant: '<S4052>/Calib' */
            /* During 'VehicleOff': '<S4096>:18' */
            if (((uint32)KeTHMR_e_IgnStatusIn_RU_Test) == CePMDR_e_PowerMode_Run)
            {
                /* Transition: '<S4096>:86' */
                THMR_ac_DW.is_OffPlug = THMR_ac_IN_VehicleOn;

                /* Entry 'VehicleOn': '<S4096>:17' */
            }
        }
        else
        {
            /* Constant: '<S4052>/Calib' */
            /* During 'VehicleOn': '<S4096>:17' */
            if (((uint32)KeTHMR_e_IgnStatusIn_RU_Test) != CePMDR_e_PowerMode_Run)
            {
                /* Transition: '<S4096>:83' */
                THMR_ac_DW.is_OffPlug = THMR_ac_IN_VehicleOff;

                /* Entry 'VehicleOff': '<S4096>:18' */
            }
        }
        break;

      case THMR_ac_IN_OnPlug:
        /* During 'OnPlug': '<S4096>:9' */
        tmp_0 = !(*Gain_n);
        if ((*Gain_he) && tmp_0)
        {
            /* Transition: '<S4096>:62' */
            /* Exit Internal 'OnPlug': '<S4096>:9' */
            THMR_ac_DW.is_OnPlug = THMR_ac_IN_NO_ACTIVE_CHILD;
            THMR_ac_DW.is_ThermalMode = THMR_ac_IN_Standby;

            /* Entry 'Standby': '<S4096>:12' */
        }
        else if (*Gain_n)
        {
            /* Transition: '<S4096>:61' */
            /* Exit Internal 'OnPlug': '<S4096>:9' */
            THMR_ac_DW.is_OnPlug = THMR_ac_IN_NO_ACTIVE_CHILD;
            THMR_ac_DW.is_ThermalMode = THMR_ac_IN_Fault;

            /* Entry 'Fault': '<S4096>:15' */
        }
        else if (((((uint32)KeTHMR_e_PlugSts_RU_Test) ==
                   CeOBCR_e_NotPlugedIn_HCP) && tmp_0) && (!(*Gain_he)))
        {
            /* Transition: '<S4096>:63' */
            /* Exit Internal 'OnPlug': '<S4096>:9' */
            THMR_ac_DW.is_OnPlug = THMR_ac_IN_NO_ACTIVE_CHILD;
            THMR_ac_DW.is_ThermalMode = THMR_ac_IN_OffPlug;

            /* Constant: '<S4052>/Calib' */
            /* Entry Internal 'OffPlug': '<S4096>:16' */
            if ((((uint32)KeTHMR_e_IgnStatusIn_RU_Test) !=
                    CePMDR_e_PowerMode_Run) || (((uint32)
                    KeTHMR_e_IgnStatusIn_RU_Test) != CePMDR_e_PowerMode_Run))
            {
                /* Transition: '<S4096>:84' */
                /* Transition: '<S4096>:87' */
                THMR_ac_DW.is_OffPlug = THMR_ac_IN_VehicleOff;

                /* Entry 'VehicleOff': '<S4096>:18' */
            }
            else
            {
                /* Transition: '<S4096>:85' */
                THMR_ac_DW.is_OffPlug = THMR_ac_IN_VehicleOn;

                /* Entry 'VehicleOn': '<S4096>:17' */
            }
        }
        else if (((uint32)THMR_ac_DW.is_OnPlug) == THMR_ac_IN_VehicleOff)
        {
            /* Constant: '<S4052>/Calib' */
            /* During 'VehicleOff': '<S4096>:10' */
            if (((uint32)KeTHMR_e_IgnStatusIn_RU_Test) == CePMDR_e_PowerMode_Run)
            {
                /* Transition: '<S4096>:82' */
                THMR_ac_DW.is_OnPlug = THMR_ac_IN_VehicleOn;

                /* Entry 'VehicleOn': '<S4096>:11' */
            }
        }
        else
        {
            /* Constant: '<S4052>/Calib' */
            /* During 'VehicleOn': '<S4096>:11' */
            if (((uint32)KeTHMR_e_IgnStatusIn_RU_Test) != CePMDR_e_PowerMode_Run)
            {
                /* Transition: '<S4096>:79' */
                THMR_ac_DW.is_OnPlug = THMR_ac_IN_VehicleOff;

                /* Entry 'VehicleOff': '<S4096>:10' */
            }
        }
        break;

      case THMR_ac_IN_Sleep:
        /* During 'Sleep': '<S4096>:13' */
        if (*Gain_hm)
        {
            /* Transition: '<S4096>:65' */
            THMR_ac_DW.is_ThermalMode = THMR_ac_IN_NO_ACTIVE_CHILD;
            THMR_enter_internal_ThermalMode();
        }
        break;

      default:
        /* During 'Standby': '<S4096>:12' */
        tmp_0 = !(*Gain_he);
        tmp = (tmp_0 && (!(*Gain_n)));

        /* Constant: '<S5277>/Calib' */
        if (tmp && (((uint32)KeTHMR_e_PlugSts_RU_Test) == CeOBCR_e_PlugedIn_HCP))
        {
            /* Transition: '<S4096>:60' */
            THMR_ac_DW.is_ThermalMode = THMR_ac_IN_OnPlug;

            /* Constant: '<S4052>/Calib' */
            /* Entry Internal 'OnPlug': '<S4096>:9' */
            if ((((uint32)KeTHMR_e_IgnStatusIn_RU_Test) !=
                    CePMDR_e_PowerMode_Run) || (((uint32)
                    KeTHMR_e_IgnStatusIn_RU_Test) != CePMDR_e_PowerMode_Run))
            {
                /* Transition: '<S4096>:78' */
                /* Transition: '<S4096>:80' */
                THMR_ac_DW.is_OnPlug = THMR_ac_IN_VehicleOff;

                /* Entry 'VehicleOff': '<S4096>:10' */
            }
            else
            {
                /* Transition: '<S4096>:81' */
                THMR_ac_DW.is_OnPlug = THMR_ac_IN_VehicleOn;

                /* Entry 'VehicleOn': '<S4096>:11' */
            }
        }
        else if ((!(*Gain_hm)) && (*Gain_he))
        {
            /* Transition: '<S4096>:64' */
            THMR_ac_DW.is_ThermalMode = THMR_ac_IN_Sleep;

            /* Entry 'Sleep': '<S4096>:13' */
        }
        else if (tmp && (((uint32)KeTHMR_e_PlugSts_RU_Test) ==
                         CeOBCR_e_NotPlugedIn_HCP))
        {
            /* Transition: '<S4096>:77' */
            THMR_ac_DW.is_ThermalMode = THMR_ac_IN_OffPlug;

            /* Constant: '<S4052>/Calib' */
            /* Entry Internal 'OffPlug': '<S4096>:16' */
            if ((((uint32)KeTHMR_e_IgnStatusIn_RU_Test) !=
                    CePMDR_e_PowerMode_Run) || (((uint32)
                    KeTHMR_e_IgnStatusIn_RU_Test) != CePMDR_e_PowerMode_Run))
            {
                /* Transition: '<S4096>:84' */
                /* Transition: '<S4096>:87' */
                THMR_ac_DW.is_OffPlug = THMR_ac_IN_VehicleOff;

                /* Entry 'VehicleOff': '<S4096>:18' */
            }
            else
            {
                /* Transition: '<S4096>:85' */
                THMR_ac_DW.is_OffPlug = THMR_ac_IN_VehicleOn;

                /* Entry 'VehicleOn': '<S4096>:17' */
            }
        }
        else
        {
            if (tmp_0 && (*Gain_n))
            {
                /* Transition: '<S4096>:70' */
                THMR_ac_DW.is_ThermalMode = THMR_ac_IN_Fault;

                /* Entry 'Fault': '<S4096>:15' */
            }
        }
        break;
    }
}

/* Function for Chart: '<S83>/ThermalMode' */
static void THMR_ac_Heater(void)
{
    boolean tmpRead;

    /* During 'Heater': '<S4096>:419' */
    /* During 'Htr1': '<S4096>:420' */
    switch (THMR_ac_DW.is_Htr1)
    {
      case THMR_ac_IN_Fault:
        THMR_ac_B.VeTHMR_e_Htr1 = CeTHMR_e_HtrFault;

        /* During 'Fault': '<S4096>:424' */
        if (!THMR_ac_B.Gain_h3)
        {
            /* Transition: '<S4096>:463' */
            /* Transition: '<S4096>:464' */
            /* Transition: '<S4096>:455' */
            THMR_ac_DW.is_Htr1 = THMR_ac_IN_Slct;

            /* Entry 'Slct': '<S4096>:422' */
            THMR_ac_B.VeTHMR_e_Htr1 = CeTHMR_e_HtrDefault;
        }
        else
        {
            if (!THMR_ac_B.TmpSignalConversionAtVeHCDR_b_H)
            {
                /* Transition: '<S4096>:459' */
                THMR_ac_DW.is_Htr1 = THMR_ac_IN_Off_b;

                /* Entry 'Off': '<S4096>:421' */
                THMR_ac_B.VeTHMR_e_Htr1 = CeTHMR_e_HtrOff;
            }
        }
        break;

      case THMR_ac_IN_Off_b:
        THMR_ac_B.VeTHMR_e_Htr1 = CeTHMR_e_HtrOff;

        /* During 'Off': '<S4096>:421' */
        if (!THMR_ac_B.Gain_h3)
        {
            /* Transition: '<S4096>:454' */
            THMR_ac_DW.is_Htr1 = THMR_ac_IN_Slct;

            /* Entry 'Slct': '<S4096>:422' */
            THMR_ac_B.VeTHMR_e_Htr1 = CeTHMR_e_HtrDefault;
        }
        else if (THMR_ac_B.TmpSignalConversionAtVeHCDR_b_H)
        {
            /* Transition: '<S4096>:460' */
            THMR_ac_DW.is_Htr1 = THMR_ac_IN_Fault;

            /* Entry 'Fault': '<S4096>:424' */
            THMR_ac_B.VeTHMR_e_Htr1 = CeTHMR_e_HtrFault;
        }
        else
        {
            if ((!THMR_ac_B.TmpSignalConversionAtVeHCDR_b_H) &&
                    (THMR_ac_B.Gain_nq))
            {
                /* Transition: '<S4096>:457' */
                THMR_ac_DW.is_Htr1 = THMR_ac_IN_On;

                /* Entry 'On': '<S4096>:423' */
                THMR_ac_B.VeTHMR_e_Htr1 = CeTHMR_e_HtrOn;
            }
        }
        break;

      case THMR_ac_IN_On:
        THMR_ac_B.VeTHMR_e_Htr1 = CeTHMR_e_HtrOn;

        /* During 'On': '<S4096>:423' */
        if (!THMR_ac_B.Gain_h3)
        {
            /* Transition: '<S4096>:462' */
            /* Transition: '<S4096>:456' */
            THMR_ac_DW.is_Htr1 = THMR_ac_IN_Slct;

            /* Entry 'Slct': '<S4096>:422' */
            THMR_ac_B.VeTHMR_e_Htr1 = CeTHMR_e_HtrDefault;
        }
        else if ((!THMR_ac_B.TmpSignalConversionAtVeHCDR_b_H) &&
                 (!THMR_ac_B.Gain_nq))
        {
            /* Transition: '<S4096>:458' */
            THMR_ac_DW.is_Htr1 = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:421' */
            THMR_ac_B.VeTHMR_e_Htr1 = CeTHMR_e_HtrOff;
        }
        else
        {
            if (THMR_ac_B.TmpSignalConversionAtVeHCDR_b_H)
            {
                /* Transition: '<S4096>:461' */
                THMR_ac_DW.is_Htr1 = THMR_ac_IN_Fault;

                /* Entry 'Fault': '<S4096>:424' */
                THMR_ac_B.VeTHMR_e_Htr1 = CeTHMR_e_HtrFault;
            }
        }
        break;

      default:
        THMR_ac_B.VeTHMR_e_Htr1 = CeTHMR_e_HtrDefault;

        /* During 'Slct': '<S4096>:422' */
        if (THMR_ac_B.Gain_h3)
        {
            /* Transition: '<S4096>:453' */
            THMR_ac_DW.is_Htr1 = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:421' */
            THMR_ac_B.VeTHMR_e_Htr1 = CeTHMR_e_HtrOff;
        }
        break;
    }

    /* During 'Htr2': '<S4096>:425' */
    switch (THMR_ac_DW.is_Htr2)
    {
      case THMR_ac_IN_Fault:
        THMR_ac_B.VeTHMR_e_Htr2 = CeTHMR_e_HtrFault;

        /* During 'Fault': '<S4096>:429' */
        if (!THMR_ac_B.Gain_a)
        {
            /* Transition: '<S4096>:476' */
            /* Transition: '<S4096>:477' */
            /* Transition: '<S4096>:468' */
            THMR_ac_DW.is_Htr2 = THMR_ac_IN_Slct;

            /* Entry 'Slct': '<S4096>:427' */
            THMR_ac_B.VeTHMR_e_Htr2 = CeTHMR_e_HtrDefault;
        }
        else
        {
            if (!THMR_ac_B.TmpSignalConversionAtVeHCDR_b_o)
            {
                /* Transition: '<S4096>:472' */
                THMR_ac_DW.is_Htr2 = THMR_ac_IN_Off_b;

                /* Entry 'Off': '<S4096>:426' */
                THMR_ac_B.VeTHMR_e_Htr2 = CeTHMR_e_HtrOff;
            }
        }
        break;

      case THMR_ac_IN_Off_b:
        THMR_ac_B.VeTHMR_e_Htr2 = CeTHMR_e_HtrOff;

        /* During 'Off': '<S4096>:426' */
        if (!THMR_ac_B.Gain_a)
        {
            /* Transition: '<S4096>:467' */
            THMR_ac_DW.is_Htr2 = THMR_ac_IN_Slct;

            /* Entry 'Slct': '<S4096>:427' */
            THMR_ac_B.VeTHMR_e_Htr2 = CeTHMR_e_HtrDefault;
        }
        else if (THMR_ac_B.TmpSignalConversionAtVeHCDR_b_o)
        {
            /* Transition: '<S4096>:473' */
            THMR_ac_DW.is_Htr2 = THMR_ac_IN_Fault;

            /* Entry 'Fault': '<S4096>:429' */
            THMR_ac_B.VeTHMR_e_Htr2 = CeTHMR_e_HtrFault;
        }
        else
        {
            if ((!THMR_ac_B.TmpSignalConversionAtVeHCDR_b_o) &&
                    (THMR_ac_B.Gain_jp))
            {
                /* Transition: '<S4096>:470' */
                THMR_ac_DW.is_Htr2 = THMR_ac_IN_On;

                /* Entry 'On': '<S4096>:428' */
                THMR_ac_B.VeTHMR_e_Htr2 = CeTHMR_e_HtrOn;
            }
        }
        break;

      case THMR_ac_IN_On:
        THMR_ac_B.VeTHMR_e_Htr2 = CeTHMR_e_HtrOn;

        /* During 'On': '<S4096>:428' */
        if (!THMR_ac_B.Gain_a)
        {
            /* Transition: '<S4096>:475' */
            /* Transition: '<S4096>:469' */
            THMR_ac_DW.is_Htr2 = THMR_ac_IN_Slct;

            /* Entry 'Slct': '<S4096>:427' */
            THMR_ac_B.VeTHMR_e_Htr2 = CeTHMR_e_HtrDefault;
        }
        else if ((!THMR_ac_B.TmpSignalConversionAtVeHCDR_b_o) &&
                 (!THMR_ac_B.Gain_jp))
        {
            /* Transition: '<S4096>:471' */
            THMR_ac_DW.is_Htr2 = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:426' */
            THMR_ac_B.VeTHMR_e_Htr2 = CeTHMR_e_HtrOff;
        }
        else
        {
            if (THMR_ac_B.TmpSignalConversionAtVeHCDR_b_o)
            {
                /* Transition: '<S4096>:474' */
                THMR_ac_DW.is_Htr2 = THMR_ac_IN_Fault;

                /* Entry 'Fault': '<S4096>:429' */
                THMR_ac_B.VeTHMR_e_Htr2 = CeTHMR_e_HtrFault;
            }
        }
        break;

      default:
        THMR_ac_B.VeTHMR_e_Htr2 = CeTHMR_e_HtrDefault;

        /* During 'Slct': '<S4096>:427' */
        if (THMR_ac_B.Gain_a)
        {
            /* Transition: '<S4096>:466' */
            THMR_ac_DW.is_Htr2 = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:426' */
            THMR_ac_B.VeTHMR_e_Htr2 = CeTHMR_e_HtrOff;
        }
        break;
    }

    /* Inport: '<Root>/VeHCDR_b_HV_Heater3_FltDtct' */
    /* During 'Htr3': '<S4096>:430' */
    (void)Rte_Read_VeHCDR_b_HV_Heater3_FltDtct_Value(&tmpRead);
    switch (THMR_ac_DW.is_Htr3)
    {
      case THMR_ac_IN_Fault:
        THMR_ac_B.VeTHMR_e_Htr3 = CeTHMR_e_HtrFault;

        /* During 'Fault': '<S4096>:434' */
        if (!THMR_ac_B.Gain_nhg)
        {
            /* Transition: '<S4096>:489' */
            /* Transition: '<S4096>:490' */
            /* Transition: '<S4096>:481' */
            THMR_ac_DW.is_Htr3 = THMR_ac_IN_Slct;

            /* Entry 'Slct': '<S4096>:432' */
            THMR_ac_B.VeTHMR_e_Htr3 = CeTHMR_e_HtrDefault;
        }
        else
        {
            if (!tmpRead)
            {
                /* Transition: '<S4096>:485' */
                THMR_ac_DW.is_Htr3 = THMR_ac_IN_Off_b;

                /* Entry 'Off': '<S4096>:431' */
                THMR_ac_B.VeTHMR_e_Htr3 = CeTHMR_e_HtrOff;
            }
        }
        break;

      case THMR_ac_IN_Off_b:
        THMR_ac_B.VeTHMR_e_Htr3 = CeTHMR_e_HtrOff;

        /* During 'Off': '<S4096>:431' */
        if (!THMR_ac_B.Gain_nhg)
        {
            /* Transition: '<S4096>:480' */
            THMR_ac_DW.is_Htr3 = THMR_ac_IN_Slct;

            /* Entry 'Slct': '<S4096>:432' */
            THMR_ac_B.VeTHMR_e_Htr3 = CeTHMR_e_HtrDefault;
        }
        else if (tmpRead)
        {
            /* Transition: '<S4096>:486' */
            THMR_ac_DW.is_Htr3 = THMR_ac_IN_Fault;

            /* Entry 'Fault': '<S4096>:434' */
            THMR_ac_B.VeTHMR_e_Htr3 = CeTHMR_e_HtrFault;
        }
        else
        {
            if (THMR_ac_B.Gain_cs)
            {
                /* Transition: '<S4096>:483' */
                THMR_ac_DW.is_Htr3 = THMR_ac_IN_On;

                /* Entry 'On': '<S4096>:433' */
                THMR_ac_B.VeTHMR_e_Htr3 = CeTHMR_e_HtrOn;
            }
        }
        break;

      case THMR_ac_IN_On:
        THMR_ac_B.VeTHMR_e_Htr3 = CeTHMR_e_HtrOn;

        /* During 'On': '<S4096>:433' */
        if (!THMR_ac_B.Gain_nhg)
        {
            /* Transition: '<S4096>:488' */
            /* Transition: '<S4096>:482' */
            THMR_ac_DW.is_Htr3 = THMR_ac_IN_Slct;

            /* Entry 'Slct': '<S4096>:432' */
            THMR_ac_B.VeTHMR_e_Htr3 = CeTHMR_e_HtrDefault;
        }
        else if ((!tmpRead) && (!THMR_ac_B.Gain_cs))
        {
            /* Transition: '<S4096>:484' */
            THMR_ac_DW.is_Htr3 = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:431' */
            THMR_ac_B.VeTHMR_e_Htr3 = CeTHMR_e_HtrOff;
        }
        else
        {
            if (tmpRead)
            {
                /* Transition: '<S4096>:487' */
                THMR_ac_DW.is_Htr3 = THMR_ac_IN_Fault;

                /* Entry 'Fault': '<S4096>:434' */
                THMR_ac_B.VeTHMR_e_Htr3 = CeTHMR_e_HtrFault;
            }
        }
        break;

      default:
        THMR_ac_B.VeTHMR_e_Htr3 = CeTHMR_e_HtrDefault;

        /* During 'Slct': '<S4096>:432' */
        if (THMR_ac_B.Gain_nhg)
        {
            /* Transition: '<S4096>:479' */
            THMR_ac_DW.is_Htr3 = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:431' */
            THMR_ac_B.VeTHMR_e_Htr3 = CeTHMR_e_HtrOff;
        }
        break;
    }

    /* During 'Htr4': '<S4096>:435' */
    switch (THMR_ac_DW.is_Htr4)
    {
      case THMR_ac_IN_Fault:
        THMR_ac_B.VeTHMR_e_Htr4 = CeTHMR_e_HtrFault;

        /* During 'Fault': '<S4096>:439' */
        if (!THMR_ac_B.Gain_l3)
        {
            /* Transition: '<S4096>:502' */
            /* Transition: '<S4096>:503' */
            /* Transition: '<S4096>:494' */
            THMR_ac_DW.is_Htr4 = THMR_ac_IN_Slct;

            /* Entry 'Slct': '<S4096>:437' */
            THMR_ac_B.VeTHMR_e_Htr4 = CeTHMR_e_HtrDefault;
        }
        else
        {
            if (!THMR_ac_B.TmpSignalConversionAtVeHCDR__os)
            {
                /* Transition: '<S4096>:498' */
                THMR_ac_DW.is_Htr4 = THMR_ac_IN_Off_b;

                /* Entry 'Off': '<S4096>:436' */
                THMR_ac_B.VeTHMR_e_Htr4 = CeTHMR_e_HtrOff;
            }
        }
        break;

      case THMR_ac_IN_Off_b:
        THMR_ac_B.VeTHMR_e_Htr4 = CeTHMR_e_HtrOff;

        /* During 'Off': '<S4096>:436' */
        if (!THMR_ac_B.Gain_l3)
        {
            /* Transition: '<S4096>:493' */
            THMR_ac_DW.is_Htr4 = THMR_ac_IN_Slct;

            /* Entry 'Slct': '<S4096>:437' */
            THMR_ac_B.VeTHMR_e_Htr4 = CeTHMR_e_HtrDefault;
        }
        else if (THMR_ac_B.TmpSignalConversionAtVeHCDR__os)
        {
            /* Transition: '<S4096>:499' */
            THMR_ac_DW.is_Htr4 = THMR_ac_IN_Fault;

            /* Entry 'Fault': '<S4096>:439' */
            THMR_ac_B.VeTHMR_e_Htr4 = CeTHMR_e_HtrFault;
        }
        else
        {
            if ((!THMR_ac_B.TmpSignalConversionAtVeHCDR__os) &&
                    (THMR_ac_B.Gain_mk))
            {
                /* Transition: '<S4096>:496' */
                THMR_ac_DW.is_Htr4 = THMR_ac_IN_On;

                /* Entry 'On': '<S4096>:438' */
                THMR_ac_B.VeTHMR_e_Htr4 = CeTHMR_e_HtrOn;
            }
        }
        break;

      case THMR_ac_IN_On:
        THMR_ac_B.VeTHMR_e_Htr4 = CeTHMR_e_HtrOn;

        /* During 'On': '<S4096>:438' */
        if (!THMR_ac_B.Gain_l3)
        {
            /* Transition: '<S4096>:501' */
            /* Transition: '<S4096>:495' */
            THMR_ac_DW.is_Htr4 = THMR_ac_IN_Slct;

            /* Entry 'Slct': '<S4096>:437' */
            THMR_ac_B.VeTHMR_e_Htr4 = CeTHMR_e_HtrDefault;
        }
        else if ((!THMR_ac_B.TmpSignalConversionAtVeHCDR__os) &&
                 (!THMR_ac_B.Gain_mk))
        {
            /* Transition: '<S4096>:497' */
            THMR_ac_DW.is_Htr4 = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:436' */
            THMR_ac_B.VeTHMR_e_Htr4 = CeTHMR_e_HtrOff;
        }
        else
        {
            if (THMR_ac_B.TmpSignalConversionAtVeHCDR__os)
            {
                /* Transition: '<S4096>:500' */
                THMR_ac_DW.is_Htr4 = THMR_ac_IN_Fault;

                /* Entry 'Fault': '<S4096>:439' */
                THMR_ac_B.VeTHMR_e_Htr4 = CeTHMR_e_HtrFault;
            }
        }
        break;

      default:
        THMR_ac_B.VeTHMR_e_Htr4 = CeTHMR_e_HtrDefault;

        /* During 'Slct': '<S4096>:437' */
        if (THMR_ac_B.Gain_l3)
        {
            /* Transition: '<S4096>:492' */
            THMR_ac_DW.is_Htr4 = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:436' */
            THMR_ac_B.VeTHMR_e_Htr4 = CeTHMR_e_HtrOff;
        }
        break;
    }
}

/* Function for Chart: '<S83>/ThermalMode' */
static void THMR_ac_Pumps(void)
{
    /* During 'Pumps': '<S4096>:507' */
    /* During 'PECP2': '<S4096>:512' */
    switch (THMR_ac_DW.is_PECP2)
    {
      case THMR_ac_IN_Fault:
        THMR_ac_B.VeTHMR_e_LTPsvPmp2_OpState = CeTHMR_e_PumpFault;

        /* During 'Fault': '<S4096>:514' */
        if (!THMR_ac_B.Gain_li)
        {
            /* Transition: '<S4096>:534' */
            THMR_ac_DW.is_PECP2 = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:513' */
            THMR_ac_B.VeTHMR_e_LTPsvPmp2_OpState = CeTHMR_e_PumpOff;
        }
        break;

      case THMR_ac_IN_Off_b:
        THMR_ac_B.VeTHMR_e_LTPsvPmp2_OpState = CeTHMR_e_PumpOff;

        /* During 'Off': '<S4096>:513' */
        if (THMR_ac_B.Gain_li)
        {
            /* Transition: '<S4096>:535' */
            THMR_ac_DW.is_PECP2 = THMR_ac_IN_Fault;

            /* Entry 'Fault': '<S4096>:514' */
            THMR_ac_B.VeTHMR_e_LTPsvPmp2_OpState = CeTHMR_e_PumpFault;
        }
        else
        {
            if ((!THMR_ac_B.Gain_li) && (THMR_ac_B.Gain_me))
            {
                /* Transition: '<S4096>:531' */
                THMR_ac_DW.is_PECP2 = THMR_ac_IN_On;

                /* Entry 'On': '<S4096>:515' */
                THMR_ac_B.VeTHMR_e_LTPsvPmp2_OpState = CeTHMR_e_PumpOn;
            }
        }
        break;

      default:
        THMR_ac_B.VeTHMR_e_LTPsvPmp2_OpState = CeTHMR_e_PumpOn;

        /* During 'On': '<S4096>:515' */
        if ((!THMR_ac_B.Gain_li) && (!THMR_ac_B.Gain_me))
        {
            /* Transition: '<S4096>:533' */
            THMR_ac_DW.is_PECP2 = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:513' */
            THMR_ac_B.VeTHMR_e_LTPsvPmp2_OpState = CeTHMR_e_PumpOff;
        }
        else
        {
            if (THMR_ac_B.Gain_li)
            {
                /* Transition: '<S4096>:532' */
                THMR_ac_DW.is_PECP2 = THMR_ac_IN_Fault;

                /* Entry 'Fault': '<S4096>:514' */
                THMR_ac_B.VeTHMR_e_LTPsvPmp2_OpState = CeTHMR_e_PumpFault;
            }
        }
        break;
    }

    /* During 'LTAP': '<S4096>:516' */
    switch (THMR_ac_DW.is_LTAP)
    {
      case THMR_ac_IN_Fault:
        THMR_ac_B.VeTHMR_e_LTActPmp_OpState = CeTHMR_e_PumpFault;

        /* During 'Fault': '<S4096>:518' */
        if (THMR_ac_B.Gain_ha)
        {
            /* Transition: '<S4096>:539' */
            THMR_ac_DW.is_LTAP = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:517' */
            THMR_ac_B.VeTHMR_e_LTActPmp_OpState = CeTHMR_e_PumpOff;
        }
        break;

      case THMR_ac_IN_Off_b:
        THMR_ac_B.VeTHMR_e_LTActPmp_OpState = CeTHMR_e_PumpOff;

        /* During 'Off': '<S4096>:517' */
        if (THMR_ac_B.Gain_ha)
        {
            /* Transition: '<S4096>:540' */
            THMR_ac_DW.is_LTAP = THMR_ac_IN_Fault;

            /* Entry 'Fault': '<S4096>:518' */
            THMR_ac_B.VeTHMR_e_LTActPmp_OpState = CeTHMR_e_PumpFault;
        }
        else
        {
            if ((!THMR_ac_B.Gain_ha) && (THMR_ac_B.Gain_mh))
            {
                /* Transition: '<S4096>:536' */
                THMR_ac_DW.is_LTAP = THMR_ac_IN_On;

                /* Entry 'On': '<S4096>:519' */
                THMR_ac_B.VeTHMR_e_LTActPmp_OpState = CeTHMR_e_PumpOn;
            }
        }
        break;

      default:
        THMR_ac_B.VeTHMR_e_LTActPmp_OpState = CeTHMR_e_PumpOn;

        /* During 'On': '<S4096>:519' */
        if ((!THMR_ac_B.Gain_ha) && (!THMR_ac_B.Gain_mh))
        {
            /* Transition: '<S4096>:537' */
            THMR_ac_DW.is_LTAP = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:517' */
            THMR_ac_B.VeTHMR_e_LTActPmp_OpState = CeTHMR_e_PumpOff;
        }
        else
        {
            if (THMR_ac_B.Gain_ha)
            {
                /* Transition: '<S4096>:538' */
                THMR_ac_DW.is_LTAP = THMR_ac_IN_Fault;

                /* Entry 'Fault': '<S4096>:518' */
                THMR_ac_B.VeTHMR_e_LTActPmp_OpState = CeTHMR_e_PumpFault;
            }
        }
        break;
    }

    /* During 'HTAP': '<S4096>:520' */
    switch (THMR_ac_DW.is_HTAP)
    {
      case THMR_ac_IN_Fault:
        THMR_ac_B.VeTHMR_e_HTAuxPmp_OpState = CeTHMR_e_PumpFault;

        /* During 'Fault': '<S4096>:522' */
        if (!THMR_ac_B.Gain_gh)
        {
            /* Transition: '<S4096>:544' */
            THMR_ac_DW.is_HTAP = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:521' */
            THMR_ac_B.VeTHMR_e_HTAuxPmp_OpState = CeTHMR_e_PumpOff;
        }
        break;

      case THMR_ac_IN_Off_b:
        THMR_ac_B.VeTHMR_e_HTAuxPmp_OpState = CeTHMR_e_PumpOff;

        /* During 'Off': '<S4096>:521' */
        if (THMR_ac_B.Gain_gh)
        {
            /* Transition: '<S4096>:542' */
            THMR_ac_DW.is_HTAP = THMR_ac_IN_Fault;

            /* Entry 'Fault': '<S4096>:522' */
            THMR_ac_B.VeTHMR_e_HTAuxPmp_OpState = CeTHMR_e_PumpFault;
        }
        else
        {
            if ((!THMR_ac_B.Gain_gh) && (THMR_ac_B.Gain_bz))
            {
                /* Transition: '<S4096>:541' */
                THMR_ac_DW.is_HTAP = THMR_ac_IN_On;

                /* Entry 'On': '<S4096>:523' */
                THMR_ac_B.VeTHMR_e_HTAuxPmp_OpState = CeTHMR_e_PumpOn;
            }
        }
        break;

      default:
        THMR_ac_B.VeTHMR_e_HTAuxPmp_OpState = CeTHMR_e_PumpOn;

        /* During 'On': '<S4096>:523' */
        if ((!THMR_ac_B.Gain_gh) && (!THMR_ac_B.Gain_bz))
        {
            /* Transition: '<S4096>:545' */
            THMR_ac_DW.is_HTAP = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:521' */
            THMR_ac_B.VeTHMR_e_HTAuxPmp_OpState = CeTHMR_e_PumpOff;
        }
        else
        {
            if (THMR_ac_B.Gain_gh)
            {
                /* Transition: '<S4096>:543' */
                THMR_ac_DW.is_HTAP = THMR_ac_IN_Fault;

                /* Entry 'Fault': '<S4096>:522' */
                THMR_ac_B.VeTHMR_e_HTAuxPmp_OpState = CeTHMR_e_PumpFault;
            }
        }
        break;
    }

    /* During 'PECP': '<S4096>:508' */
    switch (THMR_ac_DW.is_PECP)
    {
      case THMR_ac_IN_Fault:
        THMR_ac_B.VeTHMR_e_LTPsvPmp_OpState = CeTHMR_e_PumpFault;

        /* During 'Fault': '<S4096>:510' */
        if (!THMR_ac_B.Gain_py)
        {
            /* Transition: '<S4096>:528' */
            THMR_ac_DW.is_PECP = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:511' */
            THMR_ac_B.VeTHMR_e_LTPsvPmp_OpState = CeTHMR_e_PumpOff;
        }
        break;

      case THMR_ac_IN_Off_b:
        THMR_ac_B.VeTHMR_e_LTPsvPmp_OpState = CeTHMR_e_PumpOff;

        /* During 'Off': '<S4096>:511' */
        if (THMR_ac_B.Gain_py)
        {
            /* Transition: '<S4096>:529' */
            THMR_ac_DW.is_PECP = THMR_ac_IN_Fault;

            /* Entry 'Fault': '<S4096>:510' */
            THMR_ac_B.VeTHMR_e_LTPsvPmp_OpState = CeTHMR_e_PumpFault;
        }
        else
        {
            if ((!THMR_ac_B.Gain_py) && (THMR_ac_B.Gain_kx))
            {
                /* Transition: '<S4096>:525' */
                THMR_ac_DW.is_PECP = THMR_ac_IN_On;

                /* Entry 'On': '<S4096>:509' */
                THMR_ac_B.VeTHMR_e_LTPsvPmp_OpState = CeTHMR_e_PumpOn;
            }
        }
        break;

      default:
        THMR_ac_B.VeTHMR_e_LTPsvPmp_OpState = CeTHMR_e_PumpOn;

        /* During 'On': '<S4096>:509' */
        if ((!THMR_ac_B.Gain_py) && (!THMR_ac_B.Gain_kx))
        {
            /* Transition: '<S4096>:526' */
            THMR_ac_DW.is_PECP = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:511' */
            THMR_ac_B.VeTHMR_e_LTPsvPmp_OpState = CeTHMR_e_PumpOff;
        }
        else
        {
            if (THMR_ac_B.Gain_py)
            {
                /* Transition: '<S4096>:527' */
                THMR_ac_DW.is_PECP = THMR_ac_IN_Fault;

                /* Entry 'Fault': '<S4096>:510' */
                THMR_ac_B.VeTHMR_e_LTPsvPmp_OpState = CeTHMR_e_PumpFault;
            }
        }
        break;
    }
}

/* Function for Chart: '<S83>/ThermalMode' */
static void THMR_ac_Control(const boolean *Gain_ju, const boolean *Gain_ia,
    const boolean *Gain_ma, const boolean *Gain_bl, const boolean *Logical7,
    const boolean *Gain_nh)
{
    boolean tmp;
    boolean tmp_0;

    /* During 'Control': '<S4096>:19' */
    /* During 'ACComp': '<S4096>:24' */
    switch (THMR_ac_DW.is_ACComp)
    {
      case THMR_ac_IN_Fault:
        THMR_ac_B.VeTHMR_e_ACComp = CeTHMR_e_ACFaulty;

        /* During 'Fault': '<S4096>:27' */
        if (!(*Gain_ju))
        {
            /* Transition: '<S4096>:98' */
            THMR_ac_DW.is_ACComp = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:25' */
            THMR_ac_B.VeTHMR_e_ACComp = CeTHMR_e_ACOff;
        }
        break;

      case THMR_ac_IN_Off_b:
        THMR_ac_B.VeTHMR_e_ACComp = CeTHMR_e_ACOff;

        /* During 'Off': '<S4096>:25' */
        if (*Gain_ju)
        {
            /* Transition: '<S4096>:100' */
            THMR_ac_DW.is_ACComp = THMR_ac_IN_Fault;

            /* Entry 'Fault': '<S4096>:27' */
            THMR_ac_B.VeTHMR_e_ACComp = CeTHMR_e_ACFaulty;
        }
        else
        {
            if ((!(*Gain_ju)) && (THMR_ac_B.Gain_jf))
            {
                /* Transition: '<S4096>:99' */
                THMR_ac_DW.is_ACComp = THMR_ac_IN_On;

                /* Entry 'On': '<S4096>:26' */
                THMR_ac_B.VeTHMR_e_ACComp = CeTHMR_e_ACOn;
            }
        }
        break;

      case THMR_ac_IN_On:
        THMR_ac_B.VeTHMR_e_ACComp = CeTHMR_e_ACOn;

        /* During 'On': '<S4096>:26' */
        if (*Gain_ju)
        {
            /* Transition: '<S4096>:101' */
            THMR_ac_DW.is_ACComp = THMR_ac_IN_Fault;

            /* Entry 'Fault': '<S4096>:27' */
            THMR_ac_B.VeTHMR_e_ACComp = CeTHMR_e_ACFaulty;
        }
        else if (*Gain_bl)
        {
            /* Transition: '<S4096>:53' */
            THMR_ac_DW.is_ACComp = THMR_ac_IN_ValveTransition;

            /* Entry 'ValveTransition': '<S4096>:23' */
            THMR_ac_B.VeTHMR_e_ACComp = CeTHMR_e_ValveTransition;
        }
        else
        {
            if (((!(*Gain_ju)) && (!THMR_ac_B.Gain_jf)) && (!(*Gain_bl)))
            {
                /* Transition: '<S4096>:97' */
                THMR_ac_DW.is_ACComp = THMR_ac_IN_Off_b;

                /* Entry 'Off': '<S4096>:25' */
                THMR_ac_B.VeTHMR_e_ACComp = CeTHMR_e_ACOff;
            }
        }
        break;

      default:
        THMR_ac_B.VeTHMR_e_ACComp = CeTHMR_e_ValveTransition;

        /* During 'ValveTransition': '<S4096>:23' */
        if (*Gain_ju)
        {
            /* Transition: '<S4096>:52' */
            THMR_ac_DW.is_ACComp = THMR_ac_IN_Fault;

            /* Entry 'Fault': '<S4096>:27' */
            THMR_ac_B.VeTHMR_e_ACComp = CeTHMR_e_ACFaulty;
        }
        else
        {
            if (!(*Gain_bl))
            {
                /* Transition: '<S4096>:55' */
                THMR_ac_DW.is_ACComp = THMR_ac_IN_On;

                /* Entry 'On': '<S4096>:26' */
                THMR_ac_B.VeTHMR_e_ACComp = CeTHMR_e_ACOn;
            }
        }
        break;
    }

    /* During 'RadFan': '<S4096>:28' */
    switch (THMR_ac_DW.is_RadFan)
    {
      case THMR_ac_IN_Fault:
        THMR_ac_B.VeTHMR_e_RadFan = CeFSCR_e_RadFan_Faulty;

        /* During 'Fault': '<S4096>:30' */
        if (!(*Gain_ia))
        {
            /* Transition: '<S4096>:104' */
            THMR_ac_DW.is_RadFan = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:29' */
            THMR_ac_B.VeTHMR_e_RadFan = CeFSCR_e_RadFan_OFF;
        }
        break;

      case THMR_ac_IN_Off_b:
        THMR_ac_B.VeTHMR_e_RadFan = CeFSCR_e_RadFan_OFF;

        /* During 'Off': '<S4096>:29' */
        if (*Gain_ia)
        {
            /* Transition: '<S4096>:106' */
            THMR_ac_DW.is_RadFan = THMR_ac_IN_Fault;

            /* Entry 'Fault': '<S4096>:30' */
            THMR_ac_B.VeTHMR_e_RadFan = CeFSCR_e_RadFan_Faulty;
        }
        else
        {
            if ((!(*Gain_ia)) && (THMR_ac_B.Gain_bh))
            {
                /* Transition: '<S4096>:105' */
                THMR_ac_DW.is_RadFan = THMR_ac_IN_On;

                /* Entry 'On': '<S4096>:31' */
                THMR_ac_B.VeTHMR_e_RadFan = CeFSCR_e_RadFan_ON;
            }
        }
        break;

      default:
        THMR_ac_B.VeTHMR_e_RadFan = CeFSCR_e_RadFan_ON;

        /* During 'On': '<S4096>:31' */
        if ((!(*Gain_ia)) && (!THMR_ac_B.Gain_bh))
        {
            /* Transition: '<S4096>:103' */
            THMR_ac_DW.is_RadFan = THMR_ac_IN_Off_b;

            /* Entry 'Off': '<S4096>:29' */
            THMR_ac_B.VeTHMR_e_RadFan = CeFSCR_e_RadFan_OFF;
        }
        else
        {
            if (*Gain_ia)
            {
                /* Transition: '<S4096>:107' */
                THMR_ac_DW.is_RadFan = THMR_ac_IN_Fault;

                /* Entry 'Fault': '<S4096>:30' */
                THMR_ac_B.VeTHMR_e_RadFan = CeFSCR_e_RadFan_Faulty;
            }
        }
        break;
    }

    /* During 'RSV': '<S4096>:3' */
    switch (THMR_ac_DW.is_RSV)
    {
      case THMR_ac_IN_ChillerNFront:
        THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_ChillerNFront;

        /* During 'ChillerNFront': '<S4096>:6' */
        tmp = !(*Gain_ma);
        if (((THMR_ac_DW.RSV_count > KeTHMR_Cnt_RSVCount) && tmp) &&
                (((THMR_ac_B.Gain_du) && ((VeTHMR_b_BattPriorityOvercabin) ||
                (*Logical7))) && (!(*Gain_nh))))
        {
            /* Transition: '<S4096>:109' */
            THMR_ac_DW.is_RSV = THMR_ac_IN_ChillerOnly;

            /* Entry 'ChillerOnly': '<S4096>:5' */
            THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_ChillerOnly;
            THMR_ac_DW.RSV_count = 0.0F;
        }
        else if (*Gain_ma)
        {
            /* Transition: '<S4096>:111' */
            THMR_ac_DW.is_RSV = THMR_ac_IN_Fault_is;

            /* Entry 'Fault': '<S4096>:7' */
            THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_Faulty;
        }
        else if (((THMR_ac_DW.RSV_count > KeTHMR_Cnt_RSVCount) && tmp) &&
                 (((!THMR_ac_B.Gain_du) || ((THMR_ac_B.Switch1_b1 <=
                     KeTHMR_dT_ChillerFrntOnlyOff) && (!(*Logical7)))) ||
                  (*Gain_nh)))
        {
            /* Transition: '<S4096>:48' */
            THMR_ac_DW.is_RSV = THMR_ac_IN_OpenAll;

            /* Entry 'OpenAll': '<S4096>:1' */
            THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_AllOpen;
            THMR_ac_DW.RSV_count = 0.0F;
        }
        else
        {
            /* Transition: '<S4096>:45' */
            THMR_ac_DW.RSV_count++;
        }
        break;

      case THMR_ac_IN_ChillerOnly:
        THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_ChillerOnly;

        /* During 'ChillerOnly': '<S4096>:5' */
        if (*Gain_ma)
        {
            /* Transition: '<S4096>:108' */
            THMR_ac_DW.is_RSV = THMR_ac_IN_Fault_is;

            /* Entry 'Fault': '<S4096>:7' */
            THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_Faulty;
        }
        else if (((THMR_ac_DW.RSV_count > KeTHMR_Cnt_RSVCount) && (!(*Gain_ma)))
                 && (((!THMR_ac_B.Gain_du) || ((!VeTHMR_b_BattPriorityOvercabin)
                    && (!(*Logical7)))) || (*Gain_nh)))
        {
            /* Transition: '<S4096>:110' */
            THMR_ac_DW.is_RSV = THMR_ac_IN_ChillerNFront;

            /* Entry 'ChillerNFront': '<S4096>:6' */
            THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_ChillerNFront;
            THMR_ac_DW.RSV_count = 0.0F;
        }
        else
        {
            /* Transition: '<S4096>:94' */
            THMR_ac_DW.RSV_count++;
        }
        break;

      case THMR_ac_IN_EvapOnly:
        THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_EvapOnly;

        /* Constant: '<S4050>/Calib' */
        /* During 'EvapOnly': '<S4096>:21' */
        if ((((THMR_ac_DW.RSV_count > KeTHMR_Cnt_RSVCount) && (!(*Gain_ma))) &&
                ((THMR_ac_B.Gain_du) || (*Gain_nh))) || ((THMR_ac_B.Gain_ge) &&
                (!KeTHMR_b_LTActPump_ExpOff_OV)))
        {
            /* Transition: '<S4096>:93' */
            THMR_ac_DW.is_RSV = THMR_ac_IN_OpenAll;

            /* Entry 'OpenAll': '<S4096>:1' */
            THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_AllOpen;
            THMR_ac_DW.RSV_count = 0.0F;
        }
        else if (*Gain_ma)
        {
            /* Transition: '<S4096>:44' */
            THMR_ac_DW.is_RSV = THMR_ac_IN_Fault_is;

            /* Entry 'Fault': '<S4096>:7' */
            THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_Faulty;
        }
        else
        {
            /* Transition: '<S4096>:43' */
            THMR_ac_DW.RSV_count++;
        }

        /* End of Constant: '<S4050>/Calib' */
        break;

      case THMR_ac_IN_Fault_is:
        THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_Faulty;

        /* During 'Fault': '<S4096>:7' */
        if (!(*Gain_ma))
        {
            /* Transition: '<S4096>:50' */
            THMR_ac_DW.is_RSV = THMR_ac_IN_OpenAll;

            /* Entry 'OpenAll': '<S4096>:1' */
            THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_AllOpen;
            THMR_ac_DW.RSV_count = 0.0F;
        }
        break;

      default:
        THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_AllOpen;

        /* During 'OpenAll': '<S4096>:1' */
        if (*Gain_ma)
        {
            /* Transition: '<S4096>:90' */
            THMR_ac_DW.is_RSV = THMR_ac_IN_Fault_is;

            /* Entry 'Fault': '<S4096>:7' */
            THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_Faulty;
        }
        else
        {
            tmp = !(*Gain_ma);
            tmp_0 = !(*Gain_nh);
            if (((THMR_ac_DW.RSV_count > KeTHMR_Cnt_RSVCount) && tmp) &&
                    (((THMR_ac_B.Gain_du) && ((THMR_ac_B.Switch1_b1 >=
                    KeTHMR_dT_ChillerFrntOnlyOn) || (*Logical7))) && tmp_0))
            {
                /* Transition: '<S4096>:88' */
                THMR_ac_DW.is_RSV = THMR_ac_IN_ChillerNFront;

                /* Entry 'ChillerNFront': '<S4096>:6' */
                THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_ChillerNFront;
                THMR_ac_DW.RSV_count = 0.0F;
            }
            else if ((((THMR_ac_DW.RSV_count > KeTHMR_Cnt_RSVCount) && tmp) &&
                      ((!THMR_ac_B.Gain_du) && tmp_0)) && ((!THMR_ac_B.Gain_ge) ||
                      (KeTHMR_b_LTActPump_ExpOff_OV)))
            {
                /* Transition: '<S4096>:51' */
                THMR_ac_DW.is_RSV = THMR_ac_IN_EvapOnly;

                /* Entry 'EvapOnly': '<S4096>:21' */
                THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_EvapOnly;
                THMR_ac_DW.RSV_count = 0.0F;
            }
            else
            {
                /* Transition: '<S4096>:42' */
                THMR_ac_DW.RSV_count++;
            }
        }
        break;
    }

    THMR_ac_Heater();
    THMR_ac_Pumps();
}

/* Model step function for TID1 */
FUNC(void, THMR_CODE) THMR_FastTEF(void) /* Explicit Task: FastTEF */
{
    boolean tmpRead;
    boolean tmpRead_0;

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    boolean tmpRead_1;

#endif

    float32 rtb_TmpSignalConversionAtVeAATR;
    uint16 rtb_Switch1_mpr;
    boolean VeTHMR_b_OutAirTemp_Est_FA;
    boolean rtb_AND_ew0;
    boolean rtb_Comparison4_bhu;

    /* Inport: '<Root>/VeAATR_b_EstAmbAirTempFA' */
    (void)Rte_Read_VeAATR_b_EstAmbAirTempFA_Value(&VeTHMR_b_OutAirTemp_Est_FA);

    /* RootInportFunctionCallGenerator generated from: '<Root>/FastTEF' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_FastTEF'
     */
    /* SignalConversion generated from: '<S1>/VeAATR_T_EstAmbAirTemp' incorporates:
     *  Inport: '<Root>/VeAATR_T_EstAmbAirTemp'
     */
    (void)Rte_Read_VeAATR_T_EstAmbAirTemp_Value(&rtb_TmpSignalConversionAtVeAATR);

    /* S-Function (fcgen): '<S1>/FcnCallGen' incorporates:
     *  SubSystem: '<S1>/Subsystem2'
     */
    /* Switch: '<S16>/Switch' incorporates:
     *  Constant: '<S19>/Calib'
     */
    if (KeTHMR_b_OutAirTemp_EstV_SelDial)
    {
        /* Switch: '<S16>/Switch' incorporates:
         *  Constant: '<S18>/Calib'
         */
        VeTHMR_b_OutAirTemp_Est_FA = KeTHMR_b_OutAirTemp_EstV_Dial;
    }

    /* End of Switch: '<S16>/Switch' */

    /* RelationalOperator: '<S20>/Comparison4' incorporates:
     *  UnitDelay: '<S20>/UnitDelay'
     */
    rtb_Comparison4_bhu = (rtb_TmpSignalConversionAtVeAATR ==
                           THMR_ac_DW.UnitDelay_DSTATE_auj);

    /* Outputs for Atomic SubSystem: '<S20>/EdgeRising1' */
    /* Logic: '<S27>/AND' incorporates:
     *  Logic: '<S27>/OR1'
     *  UnitDelay: '<S27>/UnitDelay'
     */
    rtb_AND_ew0 = (rtb_Comparison4_bhu && (!THMR_ac_DW.UnitDelay_DSTATE_mge));

    /* Update for UnitDelay: '<S27>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_mge = rtb_Comparison4_bhu;

    /* End of Outputs for SubSystem: '<S20>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S20>/CountDownResetEnabled' */
    /* Switch: '<S26>/Switch1' incorporates:
     *  Constant: '<S26>/ConstantValue'
     *  Logic: '<S20>/Logical2'
     *  Logic: '<S20>/Logical5'
     *  RelationalOperator: '<S26>/GreaterThan'
     *  Switch: '<S26>/Switch2'
     *  UnitDelay: '<S26>/UnitDelay'
     */
    if ((!rtb_Comparison4_bhu) || rtb_AND_ew0)
    {
        /* Switch: '<S26>/Switch1' incorporates:
         *  Constant: '<S20>/ConstantValue3'
         *  Constant: '<S21>/Calib'
         *  Sum: '<S20>/Sum1'
         */
        rtb_Switch1_mpr = (uint16)((sint32)(((sint32)KeTHMR_Cnt_AmbTempDebnc_Tim)
            - 1));
    }
    else if (((sint32)THMR_ac_DW.UnitDelay_DSTATE_hs) > 0)
    {
        /* Switch: '<S26>/Switch2' incorporates:
         *  Constant: '<S26>/ConstantValue1'
         *  Sum: '<S26>/Subtraction'
         *  Switch: '<S26>/Switch1'
         *  UnitDelay: '<S26>/UnitDelay'
         */
        rtb_Switch1_mpr = (uint16)((sint32)(((sint32)
            THMR_ac_DW.UnitDelay_DSTATE_hs) - 1));
    }
    else
    {
        /* Switch: '<S26>/Switch1' incorporates:
         *  Switch: '<S26>/Switch2'
         *  UnitDelay: '<S26>/UnitDelay'
         */
        rtb_Switch1_mpr = THMR_ac_DW.UnitDelay_DSTATE_hs;
    }

    /* End of Switch: '<S26>/Switch1' */

    /* Update for UnitDelay: '<S26>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_hs = rtb_Switch1_mpr;

    /* Logic: '<S20>/Logical3' incorporates:
     *  Constant: '<S26>/ConstantValue2'
     *  RelationalOperator: '<S26>/GreaterThan1'
     */
    rtb_Comparison4_bhu = (((sint32)rtb_Switch1_mpr) <= 0);

    /* End of Outputs for SubSystem: '<S20>/CountDownResetEnabled' */

    /* Outputs for Atomic SubSystem: '<S20>/EdgeRising2' */
    /* Logic: '<S28>/AND' incorporates:
     *  Logic: '<S28>/OR1'
     *  UnitDelay: '<S28>/UnitDelay'
     */
    rtb_AND_ew0 = (rtb_Comparison4_bhu && (!THMR_ac_DW.UnitDelay_DSTATE_csp));

    /* Update for UnitDelay: '<S28>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_csp = rtb_Comparison4_bhu;

    /* End of Outputs for SubSystem: '<S20>/EdgeRising2' */

    /* Outputs for Enabled SubSystem: '<S20>/Subsystem2' incorporates:
     *  EnablePort: '<S30>/Enable'
     */
    /* Logic: '<S20>/Logical1' incorporates:
     *  Constant: '<S23>/Calib'
     *  Switch: '<S29>/Switch1'
     *  UnitDelay: '<S20>/UnitDelay2'
     */
    if (rtb_AND_ew0 || ((!KeTHMR_b_OAT_DisabDebnc_RST) &&
                        (THMR_ac_DW.UnitDelay2_DSTATE_nc)))
    {
        /* SignalConversion generated from: '<S30>/Out1' incorporates:
         *  Constant: '<S30>/ConstantValue1'
         */
        THMR_ac_B.OutportBufferForOut1_b = false;

        /* Gain: '<S31>/Gain' */
        VeTHMR_T_EstAmbAirTemp_Raw_B4D = rtb_TmpSignalConversionAtVeAATR;
    }

    /* End of Logic: '<S20>/Logical1' */
    /* End of Outputs for SubSystem: '<S20>/Subsystem2' */

    /* Switch: '<S17>/Switch' incorporates:
     *  Constant: '<S24>/Calib'
     *  Constant: '<S25>/Calib'
     *  Switch: '<S17>/Switch1'
     */
    if (KeTHMR_b_OutAirTemp_Est_SelDial)
    {
        /* Switch: '<S17>/Switch' incorporates:
         *  Constant: '<S22>/Calib'
         */
        VeTHMR_T_EstAmbAirTemp_Raw = KeTHMR_T_OutAirTemp_EstDial;
    }
    else if (KeTHMR_b_OutAirTemp_Est_NoDebounce)
    {
        /* Switch: '<S17>/Switch1' incorporates:
         *  Switch: '<S17>/Switch'
         */
        VeTHMR_T_EstAmbAirTemp_Raw = rtb_TmpSignalConversionAtVeAATR;
    }
    else
    {
        /* Switch: '<S17>/Switch' incorporates:
         *  Switch: '<S17>/Switch1'
         */
        VeTHMR_T_EstAmbAirTemp_Raw = VeTHMR_T_EstAmbAirTemp_Raw_B4D;
    }

    /* End of Switch: '<S17>/Switch' */
    /* End of Outputs for S-Function (fcgen): '<S1>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/FastTEF' */

    /* Inport: '<Root>/VeHPMR_b_BattCntctrOpenPndg' */
    (void)Rte_Read_VeHPMR_b_BattCntctrOpenPndg_Value(&tmpRead_0);

    /* Inport: '<Root>/VeHPMR_b_PropSysActv' */
    (void)Rte_Read_VeHPMR_b_PropSysActv_Value(&tmpRead);

    /* RootInportFunctionCallGenerator generated from: '<Root>/FastTEF' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_FastTEF'
     */
    /* S-Function (fcgen): '<S1>/FcnCallGen' incorporates:
     *  SubSystem: '<S1>/Subsystem2'
     */
    /* Switch: '<S13>/Switch' incorporates:
     *  Constant: '<S15>/Calib'
     *  Logic: '<S13>/Logical1'
     */
    if ((KeTHMR_b_OutAirTemp_AdjstEnb) && VeTHMR_b_OutAirTemp_Est_FA)
    {
        /* Switch: '<S13>/Switch' incorporates:
         *  Constant: '<S14>/Calib'
         */
        VeTHMR_T_EstAmbAirTemp = KeTHMR_T_OutAirTemp_EstFlt;
    }
    else
    {
        /* Switch: '<S13>/Switch' */
        VeTHMR_T_EstAmbAirTemp = VeTHMR_T_EstAmbAirTemp_Raw;
    }

    /* End of Switch: '<S13>/Switch' */

    /* Update for UnitDelay: '<S20>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_auj = rtb_TmpSignalConversionAtVeAATR;

    /* Update for UnitDelay: '<S20>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_nc = THMR_ac_B.OutportBufferForOut1_b;

    /* S-Function (fcgen): '<S1>/FcnCallGen' incorporates:
     *  SubSystem: '<S1>/HVBR_Override_req'
     */
    /* Switch: '<S5>/Switch1' incorporates:
     *  Constant: '<S9>/Calib'
     *  Inport: '<Root>/VeBTRR_b_HVBR_OvrdReq'
     *  SignalConversion generated from: '<S5>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    (void)Rte_Read_VeBTRR_b_HVBR_OvrdReq_Value(&tmpRead_1);
    if (KeTHMR_b_HVBR_OvrdReq_SD)
    {
        /* VariantMerge generated from: '<S5>/VariantSource' incorporates:
         *  Constant: '<S7>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_k = KeTHMR_b_HVBR_OvrdReq_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S5>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_k = tmpRead_1;
    }

#else

    /* VariantMerge generated from: '<S5>/VariantSource' incorporates:
     *  Constant: '<S8>/Calib'
     *  SignalConversion generated from: '<S5>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_k = KeTHMR_b_HVBR_OvrdReq_Dum4BSG;

#endif

    /* End of Switch: '<S5>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S1>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_b_HVBR_OvrdReq' incorporates:
     *  SignalConversion generated from: '<S1>/HVBR_Ovrd_Req_AD'
     */
    (void)Rte_Write_VeTHMR_b_HVBR_OvrdReq_Value(THMR_ac_B.VariantMerge_Fo_k);

    /* S-Function (fcgen): '<S1>/FcnCallGen' incorporates:
     *  SubSystem: '<S1>/Subsystem2'
     */
    /* Switch: '<S11>/Switch' incorporates:
     *  Constant: '<S33>/Calib'
     */
    if (KeTHMR_b_BattCntctrOpenPndg_Sel)
    {
        /* Merge: '<Root>/BattCntctrOpenPndg_AD_IRV_Merge' incorporates:
         *  Constant: '<S32>/Calib'
         *  SignalConversion generated from: '<S1>/BattCntctrOpenPndg_AD_write'
         */
        Rte_IrvWrite_THMR_FastTEF_BattCntctrOpenPndg_AD_write_IRV
            (KeTHMR_b_BattCntctrOpenPndg_D);
    }
    else
    {
        /* Merge: '<Root>/BattCntctrOpenPndg_AD_IRV_Merge' incorporates:
         *  SignalConversion generated from: '<S1>/BattCntctrOpenPndg_AD_write'
         */
        Rte_IrvWrite_THMR_FastTEF_BattCntctrOpenPndg_AD_write_IRV(tmpRead_0);
    }

    /* End of Switch: '<S11>/Switch' */
    /* End of Outputs for S-Function (fcgen): '<S1>/FcnCallGen' */

    /* Merge: '<Root>/OutAirTemp_EstV_AftDial_IRV_Merge' incorporates:
     *  SignalConversion generated from: '<S1>/OutAirTemp_EstV_AftDial_write'
     * */
    Rte_IrvWrite_THMR_FastTEF_OutAirTemp_EstV_AftDial_write_IRV
        (VeTHMR_b_OutAirTemp_Est_FA);

    /* S-Function (fcgen): '<S1>/FcnCallGen' incorporates:
     *  SubSystem: '<S1>/Subsystem2'
     */
    /* Merge: '<Root>/OutAirTemp_Est_AftDial_IRV_Merge' incorporates:
     *  SignalConversion: '<S13>/SignalConversion'
     *  SignalConversion generated from: '<S1>/OutAirTemp_Est_AftDial_write'
     */
    Rte_IrvWrite_THMR_FastTEF_OutAirTemp_Est_AftDial_write_IRV
        (VeTHMR_T_EstAmbAirTemp);

    /* Switch: '<S12>/Switch' incorporates:
     *  Constant: '<S35>/Calib'
     */
    if (KeTHMR_b_HV_PropSysActv_SelDial)
    {
        /* Merge: '<Root>/PropSysActv_AftDial_IRV_Merge' incorporates:
         *  Constant: '<S34>/Calib'
         *  SignalConversion generated from: '<S1>/PropSysActv_THMR_AftDial_write'
         */
        Rte_IrvWrite_THMR_FastTEF_PropSysActv_THMR_AftDial_write_IRV
            (KeTHMR_b_HV_PropSysActv_Dial);
    }
    else
    {
        /* Merge: '<Root>/PropSysActv_AftDial_IRV_Merge' incorporates:
         *  SignalConversion generated from: '<S1>/PropSysActv_THMR_AftDial_write'
         */
        Rte_IrvWrite_THMR_FastTEF_PropSysActv_THMR_AftDial_write_IRV(tmpRead);
    }

    /* End of Switch: '<S12>/Switch' */
    /* End of Outputs for S-Function (fcgen): '<S1>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/FastTEF' */
}

/* Model step function for TID2 */
FUNC(void, THMR_CODE) THMR_MedTEH(void) /* Explicit Task: MedTEH */
{
    /* local block i/o variables */
    float32 rtb_TmpSignalConversionAtVeBT_k;
    float32 rtb_TmpSignalConversionAtVeTR_h;
    float32 rtb_TmpSignalConversionAtVeCTRR;
    float32 rtb_VM_Conditional_Signal_FCCoo;
    float32 rtb_VM_Conditional_Signal_FC_Cl;
    float32 srch_dir[2];
    float32 x_i[2];
    float32 y[2];
    float32 z1[2];
    float32 tmpRead_0;
    float32 tmpRead_2;
    float32 tmpRead_3;
    float32 tmpRead_4;
    float32 tmpRead_5;
    float32 tmpRead_6;
    float32 tmpRead_7;
    float32 tmpRead_8;
    float32 tmpRead_9;
    float32 tmpRead_a;
    float32 tmpRead_c;
    float32 tmpRead_f;
    float32 tmpRead_h;
    float32 tmpRead_m;
    float32 tmpRead_n;
    float32 tmpRead_o;
    float32 tmpRead_p;
    float32 tmpRead_q;
    float32 tmpRead_r;
    float32 tmpRead_s;
    float32 tmpRead_t;
    float32 tmpRead_u;
    float32 tmpRead_w;
    float32 tmpRead_x;
    float32 tmpRead_y;
    TeBRKR_e_AHH_ReadyStatus tmpRead_v;
    TeESSR_e_EngStartStopSt tmpRead_g;
    TeHVTR_e_HV_BatCntctrStat tmpRead_i;
    TeOBCR_e_ChargingLevel tmpRead_b;
    TePMPR_e_FTSNA tmpRead_d;
    TeSSDR_e_KeySts tmpRead_l;
    TeTHMR_e_NewtonRaphsonSlvr flag_solver;
    TeTRGR_e_TransRangeState tmpRead_j;
    uint8 iteration_count;
    boolean aVarTruthTableCondition_4;
    boolean tmpRead;
    boolean tmpRead_1;
    boolean tmpRead_e;
    boolean tmpRead_k;

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    boolean tmpRead_z;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    boolean tmpRead_10;

#endif

    boolean tmpRead_11;

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    boolean tmpRead_12;

#endif

    float32 tmpRead_14;
    float32 tmpRead_1l;
    float32 tmpRead_1m;
    float32 tmpRead_1n;
    float32 tmpRead_1q;
    float32 tmpRead_1r;
    float32 tmpRead_1s;
    float32 tmpRead_1t;
    float32 tmpRead_1u;
    float32 tmpRead_1w;
    float32 tmpRead_1y;
    uint32 tmpRead_1b;
    sint16 tmpRead_1a;
    TeBPCR_e_LIN_BusOff tmpRead_1c;
    TeBPCR_e_LOC_BCP tmpRead_1d;
    TeDMDR_e_TurtleMdSts tmpRead_1h;
    TeHCDR_e_BatteryThermalFault tmpRead_18;
    TeHPMR_e_HybSysState tmpRead_19;
    TeOBCR_e_PwrLimReq tmpRead_1o;
    TePLTR_e_ShipingMode tmpRead_1k;
    TeTMIR_e_ECM_LTP_FanAftRunRq tmpRead_13;
    TeTMIR_e_ECM_LTP_FanAftRunRq tmpRead_15;
    TeTPCR_e_CabinPreCondReqStat tmpRead_1i;
    TeTRIR_e_HVAC_ECO_State tmpRead_1p;
    boolean tmpRead_16;
    boolean tmpRead_17;
    boolean tmpRead_1e;
    boolean tmpRead_1f;
    boolean tmpRead_1g;
    boolean tmpRead_1j;
    boolean tmpRead_1v;
    boolean tmpRead_1x;
    boolean tmpRead_1z;

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

    float32 tmpRead_20;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_RacePrepCrrntLim

    float32 tmpRead_21;

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

    TeHPMR_e_FC_MdCmd tmpRead_22;

#endif

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

    TeFCPR_e_ActualMode tmpRead_23;

#endif

    float32 rtb_Selector_c[3];
    float32 rtb_TmpSignalConversionAtSele_h[3];
    float32 rtb_TmpSignalConversionAtVeT_j5;
    sint16 s381_iter;
    uint16 rtb_ArrayAssignment16[16];
    sint8 rtAction;
    sint8 rtPrevAction;
    boolean rtb_Comparison3_bu;
    boolean rtb_Comparison4_cx;
    boolean rtb_Comparison5_c3m;
    boolean rtb_Comparison6_n3;
    boolean rtb_Logical18_d;
    boolean rtb_Logical5_bn;
    boolean rtb_Logical6_or;
    boolean rtb_Switch_hql;
    boolean rtb_TmpSignalConversionAtBattCn;
    boolean rtb_TmpSignalConversionAtOutAir;
    boolean rtb_TmpSignalConversionAtPropSy;
    boolean rtb_TmpSignalConversionAtVeCT_o;
    boolean rtb_TmpSignalConversionAtVePD_i;
    boolean rtb_TmpSignalConversionAtVePD_p;
    boolean rtb_TmpSignalConversionAtVeTP_c;

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    boolean rtb_TmpSignalConversionAtSele_i[3];

#endif

    float32 rtb_Selector2_o[3];
    float32 rtb_Selector3[3];
    float32 rtb_Selector4_n[3];
    float32 rtb_Merge1_i;
    float32 rtb_Product_gg;
    float32 rtb_TmpSignalConversionAtVeBTRR;
    float32 rtb_TmpSignalConversionAtVeFSCR;
    float32 rtb_TmpSignalConversionAtVeTM_n;
    float32 rtb_TmpSignalConversionAtVeT_fy;
    float32 rtb_TmpSignalConversionAtVeT_gg;
    boolean tmpForInput[45];
    boolean tmpForInput_0[13];
    boolean rtb_AND_fe;
    boolean rtb_Logical12_c2;
    boolean rtb_Logical12_cpl;
    boolean rtb_Logical12_dh;
    boolean rtb_Logical12_dt;
    boolean rtb_Logical12_e5;
    boolean rtb_Logical12_er;
    boolean rtb_Logical12_fs;
    boolean rtb_Logical12_gap;
    boolean rtb_Logical12_gu;
    boolean rtb_Logical12_gz;
    boolean rtb_Logical12_hd;
    boolean rtb_Logical12_hy;
    boolean rtb_Logical12_k5;
    boolean rtb_Logical12_pb;
    boolean rtb_Logical12_pv;
    boolean rtb_Logical15_o;
    boolean rtb_Logical17_h;
    boolean rtb_Logical17_o;
    boolean rtb_Logical1_bt;
    boolean rtb_Logical1_c0;
    boolean rtb_Logical1_gx;
    boolean rtb_Logical1_li;
    boolean rtb_Logical2_oq;
    boolean rtb_Logical3_at;
    boolean rtb_Logical3_oz;
    boolean rtb_Logical46_cr;
    boolean rtb_Logical46_fu;
    boolean rtb_Logical46_hh;
    boolean rtb_Logical46_j2;
    boolean rtb_Logical46_ov;
    boolean rtb_Logical4_iq;
    boolean rtb_Logical4_of;
    boolean rtb_TmpSignalConversionAtVeTM_j;
    boolean rtb_TmpSignalConversionAtVeT_c0;
    boolean rtb_TmpSignalConversionAtVeT_d5;
    boolean rtb_TmpSignalConversionAtVeT_ej;
    boolean rtb_TmpSignalConversionAtVeT_f5;
    boolean rtb_TmpSignalConversionAtVeT_ib;
    boolean rtb_TmpSignalConversionAtVeT_pw;
    boolean rtb_VM_Conditional_Signal_Use_M;
    boolean rtb_VariantMerge_For_Variant__n;

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    boolean rtb_Comparison5_l2[2];

#endif

    float32 rtb_TmpSignalConversionAtSelect[20];
    float32 rtb_Merge2_l;
    float32 rtb_MinMax1_c;
    float32 rtb_MinMax3_h;
    float32 rtb_MinMax7;
    float32 rtb_MinMax8;
    float32 rtb_Switch1_giu;
    float32 rtb_Switch2_pg;
    float32 rtb_Switch3_cr;
    float32 rtb_TmpSignalConversionAtVeBT_o;
    float32 rtb_TmpSignalConversionAtVeB_cl;
    float32 rtb_TmpSignalConversionAtVeB_nb;
    float32 rtb_TmpSignalConversionAtVeCT_i;
    float32 rtb_TmpSignalConversionAtVeFCPR;
    float32 rtb_TmpSignalConversionAtVeFCRR;
    float32 rtb_TmpSignalConversionAtVeHT_h;
    float32 rtb_TmpSignalConversionAtVeHT_k;
    float32 rtb_TmpSignalConversionAtVeHT_o;
    float32 rtb_TmpSignalConversionAtVeHT_p;
    float32 rtb_TmpSignalConversionAtVePMIR;
    float32 rtb_TmpSignalConversionAtVePMPR;
    float32 rtb_TmpSignalConversionAtVeTAIR;
    float32 rtb_TmpSignalConversionAtVeTFTR;
    float32 rtb_TmpSignalConversionAtVeTM_f;
    float32 rtb_TmpSignalConversionAtVeTRIR;
    float32 rtb_TmpSignalConversionAtVeT_ge;
    float32 rtb_TmpSignalConversionAtVeT_jp;
    float32 rtb_TmpSignalConversionAtVeT_n0;
    float32 rtb_UnitDelay_oqi;
    float32 rtb_VM_Conditional_Signal_HTLPu;
    float32 rtb_VM_Conditional_Signal_LTCL_;
    float32 rtb_VM_Conditional_Signal_PECP1;
    float32 rtb_VariantMerge_For_Variant_So;
    float32 rtb_VeTHMR_Pct_FCHTRRadFanCmd;
    uint16 rtb_Product_atp[19];
    uint8 rtb_TmpSignalConversionAtVePRXR;
    boolean rtb_LogicalOperator_dd1[7];
    boolean rtb_AND_de;
    boolean rtb_Gain_c;
    boolean rtb_Logical27;
    boolean rtb_Logical2_ioz;
    boolean rtb_Logical2_iq;
    boolean rtb_Logical3_pf;
    boolean rtb_Logical6_fk;
    boolean rtb_LogicalOperator1_fo;
    boolean rtb_LogicalOperator1_nm;
    boolean rtb_LogicalOperator3_jq;
    boolean rtb_LogicalOperator4_j;
    boolean rtb_LogicalOperator_aa;
    boolean rtb_LogicalOperator_dv;
    boolean rtb_LogicalOperator_iw;
    boolean rtb_LogicalOperator_lw;
    boolean rtb_RelationalOperator3_aj;
    boolean rtb_RelationalOperator7_p;
    boolean rtb_RelationalOperator9_h;
    boolean rtb_RelationalOperator_nw;
    boolean rtb_Switch1_btw;
    boolean rtb_Switch1_nqi;
    boolean rtb_Switch_az2;
    boolean rtb_TmpSignalConversionAtVeBT_f;
    boolean rtb_TmpSignalConversionAtVeBT_m;
    boolean rtb_TmpSignalConversionAtVeBT_p;
    boolean rtb_TmpSignalConversionAtVeB_ba;
    boolean rtb_TmpSignalConversionAtVeB_cu;
    boolean rtb_TmpSignalConversionAtVeB_jd;
    boolean rtb_TmpSignalConversionAtVeCPDR;
    boolean rtb_TmpSignalConversionAtVeCT_c;
    boolean rtb_TmpSignalConversionAtVeCT_d;
    boolean rtb_TmpSignalConversionAtVeCT_m;
    boolean rtb_TmpSignalConversionAtVeFC_a;
    boolean rtb_TmpSignalConversionAtVeF_hw;
    boolean rtb_TmpSignalConversionAtVePDTR;
    boolean rtb_TmpSignalConversionAtVePMTR;
    boolean rtb_TmpSignalConversionAtVePM_a;
    boolean rtb_TmpSignalConversionAtVeP_el;
    boolean rtb_TmpSignalConversionAtVeTM_o;
    boolean rtb_TmpSignalConversionAtVeTR_i;
    boolean rtb_TmpSignalConversionAtVeTR_k;
    boolean rtb_VM_Conditional_Signal_Use_c;
    boolean rtb_VariantMerge_For_Variant__b;
    boolean rtb_VariantMerge_For_Variant__j;
    boolean rtb_VariantMerge_For_Variant__m;
    boolean rtb_VariantMerge_For_Variant_da;
    boolean rtb_VariantMerge_For_Variant_ik;
    boolean rtb_VariantMerge_For_Variant_p3;

#if !Rte_SysCon_Variant_THMR_FUNC_RU_ShrdBattCab_Heater || Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0 || Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    boolean rtb_Gain_pg;

#endif

    float32 rtb_TmpSignalConversionAtVeF_n4;
    float32 rtb_TmpSignalConversionAtVeTA_c;
    float32 rtb_TmpSignalConversionAtVeT_dg;
    boolean rtb_Switch1_p1;
    boolean rtb_VariantMerge_For_Variant__p;

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    float32 rtb_TmpSignalConversionAtVeFC_f;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    float32 rtb_TmpSignalConversionAtVeF_ob;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    float32 rtb_Merge1;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    float32 rtb_TmpSignalConversionAtVeTR_p;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    boolean rtb_RelationalOperator5_o;

#endif

    sint32 rtb_DataTypeConversion2;
    float32 rtb_Sum3;
    float32 rtb_UnitDelay10;
    float32 rtb_UnitDelay11;
    float32 rtb_UnitDelay12;
    float32 rtb_UnitDelay13;
    float32 rtb_UnitDelay15;
    float32 rtb_UnitDelay9;

#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    float32 rtb_TmpSignalConversionAtVeFC_k;

#endif

    float32 rtb_TmpSignalConversionAtVeHTIR;
    boolean rtb_VariantMerge_For_Variant__o;

#if !(!Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd) || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI || Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    boolean rtb_Switch1_bkm;

#endif

#if !(!Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd) || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI || Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    boolean rtb_Switch1_abpr;

#endif

#if !(!Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd) || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

    boolean rtb_Switch1_fao;

#endif

#if !(!Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd) || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

    boolean rtb_Switch1_a2b;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

    float32 rtb_TmpSignalConversionAtVaCT_e[4];

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

    float32 rtb_TmpSignalConversionAtVaCT_j[4];

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_Switch2_m5d;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_Switch2_mkk;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

    float32 rtb_TmpSignalConversionAtVaC_ls[2];

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI || Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    float32 rtb_TmpSignalConversionAtVaCT_l[2];

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_Switch2_kq;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_TmpSignalConversionAtVaCTMR[2];

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI || Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    float32 rtb_TmpSignalConversionAtVaCT_o[2];

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_Switch2;

#endif

    float32 rtb_TmpSignalConversionAtVeTHMR;

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    boolean rtb_Logical1_k3[2];

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    boolean rtb_Logical1_oz[2];

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    boolean rtb_Logical1_bwd[2];

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    boolean rtb_Logical1_nb[2];

#endif

    float32 rtb_Switch1_pn[2];
    float32 rtb_Add_h;
    float32 rtb_Merge8;
    float32 rtb_Product1_nd;
    float32 rtb_Sum_e;
    float32 rtb_Switch10;
    float32 rtb_Switch11;
    float32 rtb_Switch15;
    float32 rtb_Switch1_dnd;
    float32 rtb_Switch1_i3;
    float32 rtb_Switch1_pi;
    float32 rtb_TmpSignalConversionAtVeCSVR;
    float32 rtb_TmpSignalConversionAtVePM_d;
    float32 rtb_TmpSignalConversionAtVePM_l;
    float32 rtb_TmpSignalConversionAtVePM_n;
    float32 rtb_TmpSignalConversionAtVeTA_n;
    float32 rtb_TmpSignalConversionAtVeTMIR;
    float32 rtb_TmpSignalConversionAtVeTPDR;
    float32 rtb_TmpSignalConversionAtVeT_je;
    float32 rtb_TmpSignalConversionAtVeT_jm;
    float32 rtb_TmpSignalConversionAtVeT_ms;
    float32 rtb_UnitDelay_nr;
    uint16 rtb_Switch_i3;
    sint8 rtb_Product9_h[20];
    boolean rtb_AND_c3;
    boolean rtb_AND_cn;
    boolean rtb_AND_fb;
    boolean rtb_AND_g2;
    boolean rtb_AND_hz;
    boolean rtb_AND_jo;
    boolean rtb_AND_ko5;
    boolean rtb_NotEqual_fo;
    boolean rtb_NotEqual_pl;
    boolean rtb_OR1_jc2;
    boolean rtb_TmpSignalConversionAtVeBT_e;
    boolean rtb_UnitDelay3_ff;
    boolean rtb_VariantMerge_For_Variant__l;
    boolean rtb_VeTHMR_b_AAD_RetrctReq_B4D;

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    float32 rtb_TmpSignalConversionAtVeF_l2;

#endif

    float32 rtb_Product9;
    uint8 rtb_Switch1_cw;
    uint8 rtb_Switch1_ev;

#if !(!Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd) || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

    float32 rtb_Switch1_ghr;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_product_e;

#endif

#if !(!Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd) || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

    float32 rtb_product1_p;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_product_k;

#endif

#if !(!Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd) || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

    float32 rtb_Sum7_fy;

#endif

#if !(!Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd) || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

    float32 rtb_Sum7_l;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_product_c;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_product1_n;

#endif

#if !(!Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd) || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_Switch1_iui;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_Sum7_f;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_product_ft;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_product1_i;

#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_Sum7;

#endif

    float32 rtb_SumSub1_ni;
    float32 rtb_Switch1_c5k;
    float32 rtb_Switch1_he;
    float32 rtb_Switch1_l3;
    float32 rtb_Switch1_nmk;
    float32 rtb_Switch1_oje;
    float32 rtb_UnitDelay_bv;
    float32 rtb_UnitDelay_cui;
    float32 rtb_UnitDelay_kww;
    float32 rtb_UnitDelay_o5;
    float32 rtb_UnitDelay_od;
    boolean rtb_AND_eb;
    boolean rtb_OR1_bn;
    boolean rtb_OR1_g4;

#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip || Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    float32 rtb_Sum2_aq;

#endif

    float32 rtb_Switch1_d;
    float32 rtb_Switch2_i1;
    boolean rtb_OR1_b3;
    boolean rtb_OR1_k3;
    boolean rtb_Switch1_az;
    boolean rtb_Switch1_cck;
    boolean rtb_Switch1_cys;
    boolean rtb_Switch1_hj;
    boolean rtb_TmpSignalConversionAtVeB_m4;

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    float32 rtb_Switch_eu;

#endif

    float32 rtb_Add2_m;
    float32 rtb_Switch_ii;
    boolean rtb_OR1_he;

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    float32 rtb_TmpSignalConversionAtVeP_jk;

#endif

#if !(!Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd) || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_Switch1_bqc;

#endif

#if !(!Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd) || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

    float32 rtb_Switch1_eih;

#endif

#if !(!Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd) || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    float32 rtb_Switch1_bhg;

#endif

    float32 rtb_Product_o0[7];
    float32 rtb_Switch1_pm;
    float32 rtb_Vector_h00;

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    float32 rtb_Switch3_l0;

#endif

    float32 rtb_Add4_m1;
    float32 rtb_Switch1_muc;
    float32 rtb_Switch1_ofq;
    float32 rtb_TmpSignalConversionAtVeTA_b;
    float32 rtb_TmpSignalConversionAtVeTM_p;
    float32 rtb_TmpSignalConversionAtVeTPCR;
    float32 rtb_TmpSignalConversionAtVeTP_i;

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    float32 rtb_TmpSignalConversionAtVeFC_p;

#endif

    TeAVTR_e_EVA_ThermalState rtb_TmpSignalConversionAtVeAVTR;
    TeBTRR_e_BatCritCondSt rtb_TmpSignalConversionAtVeB_kc;
    TeDMDR_e_DrvMd rtb_TmpSignalConversionAtVeDMIR;
    TeHTIR_e_HVC_HtrSts rtb_TmpSignalConversionAtVeHT_b;
    TeHTIR_e_HVC_HtrSts rtb_TmpSignalConversionAtVeHT_i;
    TeHTIR_e_HVC_HtrSts rtb_TmpSignalConversionAtVeHT_m;
    TePDTR_e_BattDischg_State rtb_TmpSignalConversionAtVePD_l;
    TeRCVR_e_Valve_Stuck_Status rtb_TmpSignalConversionAtVeRCVR;
    TeRCVR_e_Valve_Stuck_Status rtb_TmpSignalConversionAtVeRC_a;
    TeRCVR_e_Valve_Stuck_Status rtb_TmpSignalConversionAtVeRC_c;
    TeTHMR_e_EmrgcyFanRq_Lvl rtb_Switch1_ald;
    TeTHMR_e_VehThermSt rtb_Switch1_d1t;
    TeTPCR_e_CabinPreCondReqStat rtb_TmpSignalConversionAtVeTP_b;
    TeTPCR_e_PerWup_BattEngCond rtb_TmpSignalConversionAtVeTP_k;
    TeTPCR_e_ProactiveCondMode rtb_TmpSignalConversionAtVeT_h0;
    TeTPCR_e_ProactiveCondStatus rtb_TmpSignalConversionAtVeTP_g;
    TeTPCR_e_RacePrepState rtb_TmpSignalConversionAtVeTP_e;
    TeTPCR_e_ThrmPerWup_State rtb_TmpSignalConversionAtVeTP_d;
    TeTRIR_e_ClimateInfo rtb_TmpSignalConversionAtVeTR_f;
    TeVTLR_e_DschrgSysSts rtb_TmpSignalConversionAtVeVTLR;

#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent || Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    TeFCPR_e_FCPS_HTCoolReq rtb_TmpSignalConversionAtVeFC_o;

#endif

    sint32 i;
    float32 tmp[3];
    float32 tmp_0[3];
    float32 tmp_1[3];
    float32 Switch3_h[2];
    float32 Switch;
    float32 Switch1_e;
    float32 Switch4_d;
    float32 Switch_o;
    float32 TmpSignalConversionAtOutAirTemp;
    float32 VeTHMR_T_MinBattAllow;
    TeBRDR_e_BatCltLvlLo rtb_TmpSignalConversionAtVeBRDR;
    TeFCRR_e_FcTempRange rtb_TmpSignalConversionAtVeFC_i;
    TePMPR_e_FTSNA rtb_TmpSignalConversionAtVeP_pf;
    TePMTR_e_ThrmlDevisEnbl rtb_TmpSignalConversionAtVePM_f;
    TeRCVR_e_Valve_Stuck_Status rtb_TmpSignalConversionAtVeRC_k;
    TeTHMR_e_CabCoolThrmlState VeTHMR_e_CabCoolThermalState;
    TeTHMR_e_CabHeatThrmlState rtb_Switch1_o0g;
    TeTHMR_e_CabinThermalMode VeTHMR_e_CabThermalMode;
    TeTHMR_e_HtrState rtb_VariantMerge_For_Variant_ii;
    TeTHMR_e_PumpOpState rtb_VariantMerge_For_Variant__i;
    TeTPCR_e_SC_WakeUpSt rtb_TmpSignalConversionAtVeTP_a;
    boolean Gain_cm;
    boolean In1;
    boolean Merge3;
    boolean Switch2_e;
    boolean Switch5_i;
    boolean Switch9_a;
    boolean VeTHMR_b_DrvDrAjar;
    boolean VeTHMR_b_LTActPmp_ExpctdOff;
    boolean VeTHMR_b_LeaveKeyIn_RUN;
    boolean VeTHMR_b_SC_WkUpFlg;

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    float32 tmp_2[3];

#endif

    float32 tmp_5[36];
    float32 tmp_3[9];
    float32 tmp_4[7];
    float32 tmp_6[6];
    float32 tmp_7[6];
    float32 rtb_TmpSignalConversionAtVeT_ex[5];
    float32 rtb_UnitDelay_buv[4];

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    float32 tmp_8[10];

#endif

    sint32 exitg1;
    sint32 i_0;
    sint32 rtb_Logical1_b3_tmp;
    sint32 rtb_Logical1_du_tmp;
    sint32 rtb_Logical3_ks_tmp;
    float32 dy_dx_i_idx_0;
    uint32 VeTHMR_b_BCH_U04B8_DTCSet_tmp;
    uint32 VeTHMR_b_BCH_U1008_DTCSet_tmp;
    uint32 VeTHMR_b_BCH_U1008_DTCSet_tmp_0;
    uint32 VeTHMR_b_BCH_U1009_DTCSet_tmp;
    uint32 rtb_AND_bp_tmp;
    uint32 rtb_AND_bp_tmp_0;
    uint32 rtb_Logical2_lz_tmp;
    uint32 rtb_Logical2_lz_tmp_0;
    uint32 rtb_Logical2_lz_tmp_1;
    uint32 rtb_Logical2_lz_tmp_2;
    uint32 rtb_TmpSignalConversionAtVePD_0;
    uint32 rtb_TmpSignalConversionAtVePD_1;
    uint32 rtb_TmpSignalConversionAtVePD_2;
    uint32 rtb_TmpSignalConversionAtVePD_3;
    uint32 rtb_TmpSignalConversionAtVePD_4;
    uint32 rtb_TmpSignalConversionAtVePD_5;
    uint32 tmp_e;
    uint32 tmp_f;
    uint32 tmp_g;
    uint32 tmp_h;
    uint32 tmp_i;
    uint32 tmp_j;
    uint16 u1;
    TeCITR_e_FOTA_Install_Type Switch2_i;
    TePMDR_e_KeyStatus VeTHMR_b_KeyXstnOffThisCycle_tm;
    TeTHMR_e_BatThrmlSt VeTHMR_b_LearningOk_tmp;
    TeTHMR_e_BatThrmlSt rtb_LogicalOperator_gg_tmp;
    TeTHMR_e_CabHeatThrmlMode VeTHMR_b_CompressorReqOn_0_tmp;
    TeTHMR_e_EmrgcyFanRq_Lvl rtb_VariantMerge_For__adzsu0cfj;
    TeTHMR_e_FCThrmlState rtb_Logical17_o_tmp;
    TeTHMR_e_HTCL_Heat_Distrib tmp_c;
    TeTHMR_e_HVACPerf_Mode tmp_b;
    TeTHMR_e_LTCLThermalMode tmp_d;
    TeTHMR_e_LTCLVlvThrmlState rtb_Logical1_bnh_tmp;
    TeTHMR_e_OilPumpEmrgCoolState tmp_a;
    TeTHMR_e_PPCTIS_OT rtb_Logical15_j_tmp;
    TeTHMR_e_Pump_State tmp_9;
    TeTMIR_e_ECM_LTP_FanAftRunRq Switch1_ed;
    TeTMIR_e_ECM_LTP_FanAftRunRq rtb_RelationalOperator_kg_tmp;
    boolean Gain_bl;
    boolean Gain_nh;

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* DataStoreWrite: '<S2>/DSW_StatusByte_AC_RefrigTempSnsr4CktPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigTempSnsr4CktPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigTempSnsr4CktPerf_Value
        (&THMR_ac_DW.StatusByte_AC_RefrigTempSnsr4Ck);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_AC_RefrigPresSnsrDCktPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigPresSnsrDCktPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigPresSnsrDCktPerf_Value
        (&THMR_ac_DW.StatusByte_AC_RefrigPresSnsrD_d);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_AC_RefrigTempSnsr5CktPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigTempSnsr5CktPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigTempSnsr5CktPerf_Value
        (&THMR_ac_DW.StatusByte_AC_RefrigTempSnsr5Ck);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_AC_RefrigPresSnsrDCkt' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigPresSnsrDCkt'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigPresSnsrDCkt_Value
        (&THMR_ac_DW.StatusByte_AC_RefrigPresSnsrDCk);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_AC_RefrigTempSnsrDCkt' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigTempSnsrDCkt'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigTempSnsrDCkt_Value
        (&THMR_ac_DW.StatusByte_AC_RefrigTempSnsrDCk);

    /* DataStoreWrite: '<S2>/StatusByte_AC_RefrigTempSnsr5CktShotoBat' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigTempSnsr5CktShotoBat'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigTempSnsr5CktShotoBat_Value
        (&THMR_ac_DW.StatusByte_AC_RefrigTempSnsr5_d);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_AC_RefrigTempSnsr5CktShotoGro' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigTempSnsr5CktShotoGro'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigTempSnsr5CktShotoGro_Value
        (&THMR_ac_DW.StatusByte_AC_RefrigTempSnsr5_f);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_RadCooTempSnsr3CktPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_RadCooTempSnsr3CktPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_RadCooTempSnsr3CktPerf_Value
        (&THMR_ac_DW.StatusByte_RadCooTempSnsr3CktPe);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_RadCooTempSnsr3CktHi' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_RadCooTempSnsr3CktHi'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_RadCooTempSnsr3CktHi_Value
        (&THMR_ac_DW.StatusByte_RadCooTempSnsr3CktHi);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_RadCooTempSnsr3CktLo' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_RadCooTempSnsr3CktLo'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_RadCooTempSnsr3CktLo_Value
        (&THMR_ac_DW.StatusByte_RadCooTempSnsr3CktLo);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_LostComm_AGS_B' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostComm_AGS_B'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostComm_AGS_B_Value
        (&THMR_ac_DW.StatusByte_LostComm_AGS_B);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_LostComm_AGS_A' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostComm_AGS_A'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostComm_AGS_A_Value
        (&THMR_ac_DW.StatusByte_LostComm_AGS_A);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_AGS_B_Perf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AGS_B_Perf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AGS_B_Perf_Value
        (&THMR_ac_DW.StatusByte_AGS_B_Perf);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_AGS_A_Perf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AGS_A_Perf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AGS_A_Perf_Value
        (&THMR_ac_DW.StatusByte_AGS_A_Perf);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_LosCommBECM_A' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LosCommBECM_A'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LosCommBECM_A_Value
        (&THMR_ac_DW.StatusByte_LosCommBECM_A);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_LosCommBECM_A_CANC11' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LosCommBECM_A_CANC11'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LosCommBECM_A_CANC11_Value
        (&THMR_ac_DW.StatusByte_LosCommBECM_A_CANC11);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_LostCommEAC' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommEAC'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommEAC_Value
        (&THMR_ac_DW.StatusByte_LostCommEAC);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_EACPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_EACPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_EACPerf_Value
        (&THMR_ac_DW.StatusByte_EACPerf);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_CoolCtrlVlv1CktHi' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolCtrlVlv1CktHi'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolCtrlVlv1CktHi_Value
        (&THMR_ac_DW.StatusByte_CoolCtrlVlv1CktHi);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_BattCool' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_BattCool'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_BattCool_Value
        (&THMR_ac_DW.StatusByte_BattCool);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_AC_RefrigPresSnsrAPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigPresSnsrAPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigPresSnsrAPerf_Value
        (&THMR_ac_DW.StatusByte_AC_RefrigPresSnsrAPe);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_AC_RefrigPresSnsrALo' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigPresSnsrALo'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigPresSnsrALo_Value
        (&THMR_ac_DW.StatusByte_AC_RefrigPresSnsrALo);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_AC_RefrigPresSnsrAHi' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigPresSnsrAHi'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigPresSnsrAHi_Value
        (&THMR_ac_DW.StatusByte_AC_RefrigPresSnsrAHi);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_LostCommHB_CoolPmp' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommHB_CoolPmp'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommHB_CoolPmp_Value
        (&THMR_ac_DW.StatusByte_LostCommHB_CoolPmp);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_ThrmlRlyCtrlCkt' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_ThrmlRlyCtrlCkt'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_ThrmlRlyCtrlCkt_Value
        (&THMR_ac_DW.StatusByte_ThrmlRlyCtrlCkt);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_HiSpdCANCommBus' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_HiSpdCANCommBus'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_HiSpdCANCommBus_Value
        (&THMR_ac_DW.StatusByte_HiSpdCANCommBus);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_CommBus_B_Off' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CommBus_B_Off'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CommBus_B_Off_Value
        (&THMR_ac_DW.StatusByte_CommBus_B_Off);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_CommBusOff' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CommBusOff'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CommBusOff_Value
        (&THMR_ac_DW.StatusByte_CommBusOff);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_BattCoolPmpOveSpd' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_BattCoolPmpOveSpd'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_BattCoolPmpOveSpd_Value
        (&THMR_ac_DW.StatusByte_BattCoolPmpOveSpd);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_LostCommHB_CooltHtr4' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommHB_CooltHtr4'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommHB_CooltHtr4_Value
        (&THMR_ac_DW.StatusByte_LostCommHB_CooltHtr4);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_CoolantHeaterBPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantHeaterBPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantHeaterBPerf_Value
        (&THMR_ac_DW.StatusByte_CoolantHeaterBPerf);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_BattCoolPmpHtrBTempSnsrPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_BattCoolPmpHtrBTempSnsrPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_BattCoolPmpHtrBTempSnsrPerf_Value
        (&THMR_ac_DW.StatusByte_BattCoolPmpHtrBTempS);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_MtrElect_CoolPmpBTempSnsrPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_MtrElect_CoolPmpBTempSnsrPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_MtrElect_CoolPmpBTempSnsrPerf_Value
        (&THMR_ac_DW.StatusByte_MtrElect_CoolPmpBTem);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_MtrElect_CoolPmpATempSnsrPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_MtrElect_CoolPmpATempSnsrPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_MtrElect_CoolPmpATempSnsrPerf_Value
        (&THMR_ac_DW.StatusByte_MtrElect_CoolPmpATem);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_MtrElect_CT_SnsrPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_MtrElect_CT_SnsrPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_MtrElect_CT_SnsrPerf_Value
        (&THMR_ac_DW.StatusByte_MtrElect_CT_SnsrPerf);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_CT_SnsrPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CT_SnsrPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CT_SnsrPerf_Value
        (&THMR_ac_DW.StatusByte_CT_SnsrPerf);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_HybEvBatPacCoolCtrlVlvBPerfStkOff' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_HybEvBatPacCoolCtrlVlvBPerfStkOff'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_HybEvBatPacCoolCtrlVlvBPerfStkOff_Value
        (&THMR_ac_DW.StatusByte_HybEvBatPacCoolCtr_k);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_HybEvBatPacCoolCtrlVlv2CtrlCktLo' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_HybEvBatPacCoolCtrlVlv2CtrlCktLo'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_HybEvBatPacCoolCtrlVlv2CtrlCktLo_Value
        (&THMR_ac_DW.StatusByte_HybEvBatPacCoolCtrlV);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_MtrElect_CoolPumBCtrlPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_MtrElect_CoolPumBCtrlPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_MtrElect_CoolPumBCtrlPerf_Value
        (&THMR_ac_DW.StatusByte_MtrElect_CoolPumBCtr);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_MtrElect_CT_SnsrBPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_MtrElect_CT_SnsrBPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_MtrElect_CT_SnsrBPerf_Value
        (&THMR_ac_DW.StatusByte_MtrElect_CT_SnsrBPer);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_MtrElect_CT2_SnsrBCktLo' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_MtrElect_CT2_SnsrBCktLo'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_MtrElect_CT2_SnsrBCktLo_Value
        (&THMR_ac_DW.StatusByte_MtrElect_CT2_SnsrB_d);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_MtrElect_CT2_SnsrBCktHi' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_MtrElect_CT2_SnsrBCktHi'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_MtrElect_CT2_SnsrBCktHi_Value
        (&THMR_ac_DW.StatusByte_MtrElect_CT2_SnsrBCk);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_MtrElect_CooPumBOvrSpd' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_MtrElect_CooPumBOvrSpd'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_MtrElect_CooPumBOvrSpd_Value
        (&THMR_ac_DW.StatusByte_MtrElect_CooPumBOvrS);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_LostCommMtrElectCoolPmpB' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommMtrElectCoolPmpB'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommMtrElectCoolPmpB_Value
        (&THMR_ac_DW.StatusByte_LostCommMtrElectCo_b);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_PwrElecPmpPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_PwrElecPmpPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_PwrElecPmpPerf_Value
        (&THMR_ac_DW.StatusByte_PwrElecPmpPerf);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_MtrElect_CoolPumAOvrSpd' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_MtrElect_CoolPumAOvrSpd'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_MtrElect_CoolPumAOvrSpd_Value
        (&THMR_ac_DW.StatusByte_MtrElect_CoolPumAOvr);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_LostCommMtrElectCoolPmpA' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommMtrElectCoolPmpA'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommMtrElectCoolPmpA_Value
        (&THMR_ac_DW.StatusByte_LostCommMtrElectCool);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_CoolantVlvA_StkOpn' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantVlvA_StkOpn'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantVlvA_StkOpn_Value
        (&THMR_ac_DW.StatusByte_CoolantVlvA_StkOpn);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_CoolantVlvA_Perf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantVlvA_Perf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantVlvA_Perf_Value
        (&THMR_ac_DW.StatusByte_CoolantVlvA_Perf);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_CoolantVlvA_Ckt' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantVlvA_Ckt'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantVlvA_Ckt_Value
        (&THMR_ac_DW.StatusByte_CoolantVlvA_Ckt);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_CoolantVlvA_CktLo' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantVlvA_CktLo'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantVlvA_CktLo_Value
        (&THMR_ac_DW.StatusByte_CoolantVlvA_CktLo);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_CoolantVlvA_CktHi' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantVlvA_CktHi'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantVlvA_CktHi_Value
        (&THMR_ac_DW.StatusByte_CoolantVlvA_CktHi);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_ECT_Snsr4CktPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_ECT_Snsr4CktPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_ECT_Snsr4CktPerf_Value
        (&THMR_ac_DW.StatusByte_ECT_Snsr4CktPerf);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_ECT_Snsr4CktLo' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_ECT_Snsr4CktLo'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_ECT_Snsr4CktLo_Value
        (&THMR_ac_DW.StatusByte_ECT_Snsr4CktLo);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_ECT_Snsr4CktHi' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_ECT_Snsr4CktHi'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_ECT_Snsr4CktHi_Value
        (&THMR_ac_DW.StatusByte_ECT_Snsr4CktHi);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_CT3_SnsrPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CT3_SnsrPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CT3_SnsrPerf_Value
        (&THMR_ac_DW.StatusByte_CT3_SnsrPerf);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_CT3_SnsrCktLo' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CT3_SnsrCktLo'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CT3_SnsrCktLo_Value
        (&THMR_ac_DW.StatusByte_CT3_SnsrCktLo);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_CT3_SnsrCktHi' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CT3_SnsrCktHi'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CT3_SnsrCktHi_Value
        (&THMR_ac_DW.StatusByte_CT3_SnsrCktHi);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_LostCommCoolHtrA' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommCoolHtrA'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommCoolHtrA_Value
        (&THMR_ac_DW.StatusByte_LostCommCoolHtrA);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_LIN2_BusOff' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LIN2_BusOff'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LIN2_BusOff_Value
        (&THMR_ac_DW.StatusByte_LIN2_BusOff);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_LIN1_BusOff' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LIN1_BusOff'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LIN1_BusOff_Value
        (&THMR_ac_DW.StatusByte_LIN1_BusOff);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_InvData_ECH' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_InvData_ECH'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_InvData_ECH_Value
        (&THMR_ac_DW.StatusByte_InvData_ECH);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_InvData_EAH' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_InvData_EAH'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_InvData_EAH_Value
        (&THMR_ac_DW.StatusByte_InvData_EAH);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_ECH_TempOut' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_ECH_TempOut'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_ECH_TempOut_Value
        (&THMR_ac_DW.StatusByte_ECH_TempOut);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_ECH_TempIn' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_ECH_TempIn'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_ECH_TempIn_Value
        (&THMR_ac_DW.StatusByte_ECH_TempIn);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_LostCommCoolPmpA' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommCoolPmpA'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommCoolPmpA_Value
        (&THMR_ac_DW.StatusByte_LostCommCoolPmpA);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_CoolPmpACtrlCktPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolPmpACtrlCktPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolPmpACtrlCktPerf_Value
        (&THMR_ac_DW.StatusByte_CoolPmpACtrlCktPerf);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_BattCoolPmpPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_BattCoolPmpPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_BattCoolPmpPerf_Value
        (&THMR_ac_DW.StatusByte_BattCoolPmpPerf);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_BattCoolPmpATempSnsrPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_BattCoolPmpATempSnsrPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_BattCoolPmpATempSnsrPerf_Value
        (&THMR_ac_DW.StatusByte_BattCoolPmpATempSnsr);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_HB_CT_SnsrPerf' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_HB_CT_SnsrPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_HB_CT_SnsrPerf_Value
        (&THMR_ac_DW.StatusByte_HB_CT_SnsrPerf);

    /* DataStoreWrite: '<S2>/DSW_StatusByte_CoolOutTempSnsCkt' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolOutTempSnsCkt'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolOutTempSnsCkt_Value
        (&THMR_ac_DW.StatusByte_CoolOutTempSnsCkt);

    /* SignalConversion generated from: '<S2>/VeTMIR_Pct_BSG_PPU_AirFlwRq' incorporates:
     *  Inport: '<Root>/VeTMIR_Pct_BSG_PPU_AirFlwRq'
     */
    (void)Rte_Read_VeTMIR_Pct_BSG_PPU_AirFlwRq_Value
        (&rtb_TmpSignalConversionAtVeTMIR);

    /* SignalConversion generated from: '<S2>/VeTAIR_Pct_LTR_BypsVlv_ActlPstn' incorporates:
     *  Inport: '<Root>/VeTAIR_Pct_LTR_BypsVlv_ActlPstn'
     */
    (void)Rte_Read_VeTAIR_Pct_LTR_BypsVlv_ActlPstn_Value
        (&rtb_TmpSignalConversionAtVeTAIR);

    /* SignalConversion generated from: '<S2>/VeRCVR_e_LTR_Valve_Stuck_State' incorporates:
     *  Inport: '<Root>/VeRCVR_e_LTR_Valve_Stuck_State'
     */
    (void)Rte_Read_VeRCVR_e_LTR_Valve_Stuck_State_Value
        (&rtb_TmpSignalConversionAtVeRCVR);

    /* SignalConversion generated from: '<S2>/VeTAIR_Pct_ECM_AirflowRequest' */
#if !Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

    /* SignalConversion generated from: '<S2>/VeTAIR_Pct_ECM_AirflowRequest' incorporates:
     *  Inport: '<Root>/VeTAIR_Pct_ECM_AirflowRequest'
     */
    (void)Rte_Read_VeTAIR_Pct_ECM_AirflowRequest_Value
        (&rtb_TmpSignalConversionAtVeT_jm);

#endif

    /* End of SignalConversion generated from: '<S2>/VeTAIR_Pct_ECM_AirflowRequest' */

    /* SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read' incorporates:
     *  Merge: '<Root>/OutAirTemp_Est_AftDial_IRV_Merge'
     */
    TmpSignalConversionAtOutAirTemp =
        Rte_IrvRead_THMR_MedTEH_OutAirTemp_Est_AftDial_write_IRV();

    /* SignalConversion generated from: '<S2>/VeTAIR_n_CompSpdFdb' incorporates:
     *  Inport: '<Root>/VeTAIR_n_CompSpdFdb'
     */
    (void)Rte_Read_VeTAIR_n_CompSpdFdb_Value(&rtb_TmpSignalConversionAtVeTA_n);

    /* SignalConversion generated from: '<S2>/VePRXR_y_NumOfAGSUnits' incorporates:
     *  Inport: '<Root>/VePRXR_y_NumOfAGSUnits'
     */
    (void)Rte_Read_VePRXR_y_NumOfAGSUnits_Value(&rtb_TmpSignalConversionAtVePRXR);

    /* SignalConversion generated from: '<S2>/VeBTRR_T_CellTempMaxUsed' incorporates:
     *  Inport: '<Root>/VeBTRR_T_CellTempMaxUsed'
     */
    (void)Rte_Read_VeBTRR_T_CellTempMaxUsed_Value
        (&rtb_TmpSignalConversionAtVeBTRR);

    /* SignalConversion generated from: '<S2>/PropSysActv_AftDial_Read' incorporates:
     *  Merge: '<Root>/PropSysActv_AftDial_IRV_Merge'
     */
    rtb_TmpSignalConversionAtPropSy =
        Rte_IrvRead_THMR_MedTEH_PropSysActv_THMR_AftDial_write_IRV();

    /* SignalConversion generated from: '<S2>/VeBTRR_b_isCharging' incorporates:
     *  Inport: '<Root>/VeBTRR_b_isCharging'
     */
    (void)Rte_Read_VeBTRR_b_isCharging_Value
        (&THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i);

    /* SignalConversion generated from: '<S2>/VeBTRR_T_CellTempMinUsed' incorporates:
     *  Inport: '<Root>/VeBTRR_T_CellTempMinUsed'
     */
    (void)Rte_Read_VeBTRR_T_CellTempMinUsed_Value
        (&rtb_TmpSignalConversionAtVeBT_o);

    /* SignalConversion generated from: '<S2>/VeBTRR_dT_CellOverTemp' incorporates:
     *  Inport: '<Root>/VeBTRR_dT_CellOverTemp'
     */
    (void)Rte_Read_VeBTRR_dT_CellOverTemp_Value(&rtb_TmpSignalConversionAtVeB_cl);

    /* SignalConversion generated from: '<S2>/VeBTRR_b_HV_BatTempCrit_Cond' incorporates:
     *  Inport: '<Root>/VeBTRR_b_HV_BatTempCrit_Cond'
     */
    (void)Rte_Read_VeBTRR_b_HV_BatTempCrit_Cond_Value
        (&rtb_TmpSignalConversionAtVeB_cu);

    /* SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State' incorporates:
     *  Inport: '<Root>/VePDTR_e_EngOrBattPwrDschg_State'
     */
    (void)Rte_Read_VePDTR_e_EngOrBattPwrDschg_State_Value
        (&rtb_TmpSignalConversionAtVePD_l);

    /* SignalConversion generated from: '<S2>/BattCntctrOpenPndg_AD_Read' incorporates:
     *  Merge: '<Root>/BattCntctrOpenPndg_AD_IRV_Merge'
     */
    rtb_TmpSignalConversionAtBattCn =
        Rte_IrvRead_THMR_MedTEH_BattCntctrOpenPndg_AD_write_IRV();

    /* SignalConversion generated from: '<S2>/VePMTR_e_ThrmlDevEnbl' incorporates:
     *  Inport: '<Root>/VePMTR_e_ThrmlDevEnbl'
     */
    (void)Rte_Read_VePMTR_e_ThrmlDevEnbl_Value(&rtb_TmpSignalConversionAtVePM_f);

    /* SignalConversion generated from: '<S2>/VeHCDR_b_HVC_Heater_FltDtct' incorporates:
     *  Inport: '<Root>/VeHCDR_b_HVC_Heater_FltDtct'
     */
    (void)Rte_Read_VeHCDR_b_HVC_Heater_FltDtct_Value
        (&THMR_ac_B.TmpSignalConversionAtVeHCDR_b_H);

    /* SignalConversion generated from: '<S2>/VeHCDR_b_HV_Heater2_FltDtct' incorporates:
     *  Inport: '<Root>/VeHCDR_b_HV_Heater2_FltDtct'
     */
    (void)Rte_Read_VeHCDR_b_HV_Heater2_FltDtct_Value
        (&THMR_ac_B.TmpSignalConversionAtVeHCDR_b_o);

    /* SignalConversion generated from: '<S2>/VeHCDR_b_HV_Heater4_FltDtct' incorporates:
     *  Inport: '<Root>/VeHCDR_b_HV_Heater4_FltDtct'
     */
    (void)Rte_Read_VeHCDR_b_HV_Heater4_FltDtct_Value
        (&THMR_ac_B.TmpSignalConversionAtVeHCDR__os);

    /* SignalConversion generated from: '<S2>/VePMIR_e_LTActvPumpDryRun' incorporates:
     *  Inport: '<Root>/VePMIR_e_LTActvPumpDryRun'
     */
    (void)Rte_Read_VePMIR_e_LTActvPumpDryRun_Value
        (&rtb_TmpSignalConversionAtVeP_pf);

    /* SignalConversion generated from: '<S2>/VePMIR_b_LTActvPumpDryRun_FA' incorporates:
     *  Inport: '<Root>/VePMIR_b_LTActvPumpDryRun_FA'
     */
    (void)Rte_Read_VePMIR_b_LTActvPumpDryRun_FA_Value
        (&rtb_TmpSignalConversionAtVePM_a);

    /* SignalConversion generated from: '<S2>/VeCPDR_b_LTAP_FunPer_FltDtct' incorporates:
     *  Inport: '<Root>/VeCPDR_b_LTAP_FunPer_FltDtct'
     */
    (void)Rte_Read_VeCPDR_b_LTAP_FunPer_FltDtct_Value
        (&rtb_TmpSignalConversionAtVeCPDR);

    /* SignalConversion generated from: '<S2>/VeAVTR_e_EVA_ThrmlState' incorporates:
     *  Inport: '<Root>/VeAVTR_e_EVA_ThrmlState'
     */
    (void)Rte_Read_VeAVTR_e_EVA_ThrmlState_Value
        (&rtb_TmpSignalConversionAtVeAVTR);

    /* SignalConversion generated from: '<S2>/VeTMIR_T_PsvPmpClnt_TmpIn' incorporates:
     *  Inport: '<Root>/VeTMIR_T_PsvPmpClnt_TmpIn'
     */
    (void)Rte_Read_VeTMIR_T_PsvPmpClnt_TmpIn_Value
        (&rtb_TmpSignalConversionAtVeT_jp);

    /* SignalConversion generated from: '<S2>/VeBTRR_T_BTISBTIS2_Max' incorporates:
     *  Inport: '<Root>/VeBTRR_T_BTISBTIS2_Max'
     */
    (void)Rte_Read_VeBTRR_T_BTISBTIS2_Max_Value(&rtb_TmpSignalConversionAtVeBT_k);

    /* SignalConversion generated from: '<S2>/VeBRDR_e_HV_Bat_CltLvlLo' incorporates:
     *  Inport: '<Root>/VeBRDR_e_HV_Bat_CltLvlLo'
     */
    (void)Rte_Read_VeBRDR_e_HV_Bat_CltLvlLo_Value
        (&rtb_TmpSignalConversionAtVeBRDR);

    /* SignalConversion generated from: '<S2>/VePMIR_n_LTActvPumpRPMAct' incorporates:
     *  Inport: '<Root>/VePMIR_n_LTActvPumpRPMAct'
     */
    (void)Rte_Read_VePMIR_n_LTActvPumpRPMAct_Value
        (&rtb_TmpSignalConversionAtVePMIR);

    /* SignalConversion generated from: '<S2>/VeBTRR_b_VhclPlgdIn' incorporates:
     *  Inport: '<Root>/VeBTRR_b_VhclPlgdIn'
     */
    (void)Rte_Read_VeBTRR_b_VhclPlgdIn_Value(&rtb_TmpSignalConversionAtVeB_jd);

    /* SignalConversion generated from: '<S2>/VeTRIR_T_HV_BatClntTmpOut' incorporates:
     *  Inport: '<Root>/VeTRIR_T_HV_BatClntTmpOut'
     */
    (void)Rte_Read_VeTRIR_T_HV_BatClntTmpOut_Value
        (&rtb_TmpSignalConversionAtVeTRIR);

    /* SignalConversion generated from: '<S2>/VeTMIR_b_PsvPmpClnt_TmpIn_FA' incorporates:
     *  Inport: '<Root>/VeTMIR_b_PsvPmpClnt_TmpIn_FA'
     */
    (void)Rte_Read_VeTMIR_b_PsvPmpClnt_TmpIn_FA_Value
        (&rtb_TmpSignalConversionAtVeTM_o);

    /* SignalConversion generated from: '<S2>/VeTMIR_T_OnBrdChrg_ClntTmpIn' incorporates:
     *  Inport: '<Root>/VeTMIR_T_OnBrdChrg_ClntTmpIn'
     */
    (void)Rte_Read_VeTMIR_T_OnBrdChrg_ClntTmpIn_Value
        (&rtb_TmpSignalConversionAtVeTM_f);

    /* SignalConversion generated from: '<S2>/VePDTR_b_KeyRunCrnk_BattOV' incorporates:
     *  Inport: '<Root>/VePDTR_b_KeyRunCrnk_BattOV'
     */
    (void)Rte_Read_VePDTR_b_KeyRunCrnk_BattOV_Value
        (&rtb_TmpSignalConversionAtVePDTR);

    /* SignalConversion generated from: '<S2>/VePMTR_b_REM_CabHeatAction' incorporates:
     *  Inport: '<Root>/VePMTR_b_REM_CabHeatAction'
     */
    (void)Rte_Read_VePMTR_b_REM_CabHeatAction_Value
        (&rtb_TmpSignalConversionAtVePMTR);

    /* SignalConversion generated from: '<S2>/VePMTR_b_REM_CabCoolAction' incorporates:
     *  Inport: '<Root>/VePMTR_b_REM_CabCoolAction'
     */
    (void)Rte_Read_VePMTR_b_REM_CabCoolAction_Value
        (&rtb_TmpSignalConversionAtVeP_el);

    /* SignalConversion generated from: '<S2>/VeTPCR_e_ThrmPerWup_State' incorporates:
     *  Inport: '<Root>/VeTPCR_e_ThrmPerWup_State'
     */
    (void)Rte_Read_VeTPCR_e_ThrmPerWup_State_Value
        (&rtb_TmpSignalConversionAtVeTP_d);

    /* SignalConversion generated from: '<S2>/VeCTRR_b_HVAC_HeatReq' incorporates:
     *  Inport: '<Root>/VeCTRR_b_HVAC_HeatReq'
     */
    (void)Rte_Read_VeCTRR_b_HVAC_HeatReq_Value(&rtb_TmpSignalConversionAtVeCT_o);

    /* SignalConversion generated from: '<S2>/VeBTRR_b_ThrmlBatCoolingFlt' incorporates:
     *  Inport: '<Root>/VeBTRR_b_ThrmlBatCoolingFlt'
     */
    (void)Rte_Read_VeBTRR_b_ThrmlBatCoolingFlt_Value
        (&rtb_TmpSignalConversionAtVeBT_e);

    /* SignalConversion generated from: '<S2>/VeBTRR_b_Batt_CritOrMarg' incorporates:
     *  Inport: '<Root>/VeBTRR_b_Batt_CritOrMarg'
     */
    (void)Rte_Read_VeBTRR_b_Batt_CritOrMarg_Value
        (&rtb_TmpSignalConversionAtVeB_m4);

    /* SignalConversion generated from: '<S2>/VeTRIR_T_HtrCorClnt_TmpOut' incorporates:
     *  Inport: '<Root>/VeTRIR_T_HtrCorClnt_TmpOut'
     */
    (void)Rte_Read_VeTRIR_T_HtrCorClnt_TmpOut_Value
        (&rtb_TmpSignalConversionAtVeTR_h);

    /* SignalConversion generated from: '<S2>/VeCTRR_T_HtrCoreTmp_Tgt_Arb' incorporates:
     *  Inport: '<Root>/VeCTRR_T_HtrCoreTmp_Tgt_Arb'
     */
    (void)Rte_Read_VeCTRR_T_HtrCoreTmp_Tgt_Arb_Value
        (&rtb_TmpSignalConversionAtVeCTRR);

    /* SignalConversion generated from: '<S2>/VeBTRR_dT_CellUnderTemp' incorporates:
     *  Inport: '<Root>/VeBTRR_dT_CellUnderTemp'
     */
    (void)Rte_Read_VeBTRR_dT_CellUnderTemp_Value
        (&rtb_TmpSignalConversionAtVeB_nb);

    /* SignalConversion generated from: '<S2>/VeCTRR_dT_HtrCorTmp_Err' incorporates:
     *  Inport: '<Root>/VeCTRR_dT_HtrCorTmp_Err'
     */
    (void)Rte_Read_VeCTRR_dT_HtrCorTmp_Err_Value
        (&rtb_TmpSignalConversionAtVeCT_i);

    /* SignalConversion generated from: '<S2>/VeTAIR_Pct_HTL_BypsVlv_ActlPstn' incorporates:
     *  Inport: '<Root>/VeTAIR_Pct_HTL_BypsVlv_ActlPstn'
     */
    (void)Rte_Read_VeTAIR_Pct_HTL_BypsVlv_ActlPstn_Value
        (&rtb_TmpSignalConversionAtVeT_dg);

    /* SignalConversion generated from: '<S2>/VeTMIR_T_LTR_ClntTmpOut' incorporates:
     *  Inport: '<Root>/VeTMIR_T_LTR_ClntTmpOut'
     */
    (void)Rte_Read_VeTMIR_T_LTR_ClntTmpOut_Value
        (&rtb_TmpSignalConversionAtVeTM_p);

    /* SignalConversion generated from: '<S2>/VeTPCR_b_KeyOffCabCond' incorporates:
     *  Inport: '<Root>/VeTPCR_b_KeyOffCabCond'
     */
    (void)Rte_Read_VeTPCR_b_KeyOffCabCond_Value(&rtb_TmpSignalConversionAtVeTP_c);

    /* SignalConversion generated from: '<S2>/VePMIR_T_LTPsvPump2Temp' incorporates:
     *  Inport: '<Root>/VePMIR_T_LTPsvPump2Temp'
     */
    (void)Rte_Read_VePMIR_T_LTPsvPump2Temp_Value
        (&rtb_TmpSignalConversionAtVePM_l);

    /* SignalConversion generated from: '<S2>/VeRCVR_e_CPV_Valve_Stuck_State' incorporates:
     *  Inport: '<Root>/VeRCVR_e_CPV_Valve_Stuck_State'
     */
    (void)Rte_Read_VeRCVR_e_CPV_Valve_Stuck_State_Value
        (&rtb_TmpSignalConversionAtVeRC_k);

    /* SignalConversion generated from: '<S2>/VeRCVR_e_HTL_Valve_Stuck_State' incorporates:
     *  Inport: '<Root>/VeRCVR_e_HTL_Valve_Stuck_State'
     */
    (void)Rte_Read_VeRCVR_e_HTL_Valve_Stuck_State_Value
        (&rtb_TmpSignalConversionAtVeRC_a);

    /* SignalConversion generated from: '<S2>/VeBTRR_b_Batt_PsvCoolReq' incorporates:
     *  Inport: '<Root>/VeBTRR_b_Batt_PsvCoolReq'
     */
    (void)Rte_Read_VeBTRR_b_Batt_PsvCoolReq_Value
        (&rtb_TmpSignalConversionAtVeBT_p);

    /* SignalConversion generated from: '<S2>/VeBTRR_b_BattHeatReq' incorporates:
     *  Inport: '<Root>/VeBTRR_b_BattHeatReq'
     */
    (void)Rte_Read_VeBTRR_b_BattHeatReq_Value(&rtb_TmpSignalConversionAtVeB_ba);

    /* SignalConversion generated from: '<S2>/VePMPR_dV_BattFlw' incorporates:
     *  Inport: '<Root>/VePMPR_dV_BattFlw'
     */
    (void)Rte_Read_VePMPR_dV_BattFlw_Value(&rtb_TmpSignalConversionAtVePMPR);

    /* SignalConversion generated from: '<S2>/VeTMIR_T_ElecClntHtr_TmpIn' incorporates:
     *  Inport: '<Root>/VeTMIR_T_ElecClntHtr_TmpIn'
     */
    (void)Rte_Read_VeTMIR_T_ElecClntHtr_TmpIn_Value
        (&rtb_TmpSignalConversionAtVeT_n0);

    /* SignalConversion generated from: '<S2>/VeCTRR_b_RearHeaterReq' incorporates:
     *  Inport: '<Root>/VeCTRR_b_RearHeaterReq'
     */
    (void)Rte_Read_VeCTRR_b_RearHeaterReq_Value(&rtb_TmpSignalConversionAtVeCT_m);

    /* SignalConversion generated from: '<S2>/VeTAIR_T_OEXV_OutTempSens' incorporates:
     *  Inport: '<Root>/VeTAIR_T_OEXV_OutTempSens'
     */
    (void)Rte_Read_VeTAIR_T_OEXV_OutTempSens_Value
        (&rtb_TmpSignalConversionAtVeTA_c);

    /* SignalConversion generated from: '<S2>/VeVTLR_e_DschrgSysSts' incorporates:
     *  Inport: '<Root>/VeVTLR_e_DschrgSysSts'
     */
    (void)Rte_Read_VeVTLR_e_DschrgSysSts_Value(&rtb_TmpSignalConversionAtVeVTLR);

    /* SignalConversion generated from: '<S2>/VeFCPR_P_FCPS_ActPwr' incorporates:
     *  Inport: '<Root>/VeFCPR_P_FCPS_ActPwr'
     */
    (void)Rte_Read_VeFCPR_P_FCPS_ActPwr_Value(&rtb_TmpSignalConversionAtVeFCPR);

    /* SignalConversion generated from: '<S2>/VeFCRR_e_FcTempRange' incorporates:
     *  Inport: '<Root>/VeFCRR_e_FcTempRange'
     */
    (void)Rte_Read_VeFCRR_e_FcTempRange_Value(&rtb_TmpSignalConversionAtVeFC_i);

    /* SignalConversion generated from: '<S2>/VeFCRR_b_PwrSnkDispReq' */
#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

    /* SignalConversion generated from: '<S2>/VeFCRR_b_PwrSnkDispReq' incorporates:
     *  Inport: '<Root>/VeFCRR_b_PwrSnkDispReq'
     */
    (void)Rte_Read_VeFCRR_b_PwrSnkDispReq_Value(&rtb_TmpSignalConversionAtVeFC_a);

#endif

    /* End of SignalConversion generated from: '<S2>/VeFCRR_b_PwrSnkDispReq' */

    /* SignalConversion generated from: '<S2>/VeFCPR_b_FCPS_HV_AfterRunSts' incorporates:
     *  Inport: '<Root>/VeFCPR_b_FCPS_HV_AfterRunSts'
     */
    (void)Rte_Read_VeFCPR_b_FCPS_HV_AfterRunSts_Value
        (&rtb_TmpSignalConversionAtVeF_hw);

    /* SignalConversion generated from: '<S2>/VeFCRR_T_FcOutTempSetPoint' incorporates:
     *  Inport: '<Root>/VeFCRR_T_FcOutTempSetPoint'
     */
    (void)Rte_Read_VeFCRR_T_FcOutTempSetPoint_Value
        (&rtb_TmpSignalConversionAtVeFCRR);

    /* SignalConversion generated from: '<S2>/VeFCPR_T_FCPS_HTCoolOutTemp' incorporates:
     *  Inport: '<Root>/VeFCPR_T_FCPS_HTCoolOutTemp'
     */
    (void)Rte_Read_VeFCPR_T_FCPS_HTCoolOutTemp_Value
        (&rtb_TmpSignalConversionAtVeF_n4);

    /* SignalConversion generated from: '<S2>/VeTRIR_T_HeatExCool_TmpOut' incorporates:
     *  Inport: '<Root>/VeTRIR_T_HeatExCool_TmpOut'
     */
    (void)Rte_Read_VeTRIR_T_HeatExCool_TmpOut_Value
        (&rtb_TmpSignalConversionAtVeT_ge);

    /* SignalConversion generated from: '<S2>/VeHTIR_P_HVC_HtrPwrAct' incorporates:
     *  Inport: '<Root>/VeHTIR_P_HVC_HtrPwrAct'
     */
    (void)Rte_Read_VeHTIR_P_HVC_HtrPwrAct_Value(&rtb_TmpSignalConversionAtVeHTIR);

    /* SignalConversion generated from: '<S2>/VeRCVR_e_HtrCoreBypVlv_Stuck_State' incorporates:
     *  Inport: '<Root>/VeRCVR_e_HtrCoreBypVlv_Stuck_State'
     */
    (void)Rte_Read_VeRCVR_e_HtrCoreBypVlv_Stuck_State_Value
        (&rtb_TmpSignalConversionAtVeRC_c);

    /* SignalConversion generated from: '<S2>/VeFCPR_e_FCPS_HTCoolReq' */
#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent || Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* SignalConversion generated from: '<S2>/VeFCPR_e_FCPS_HTCoolReq' incorporates:
     *  Inport: '<Root>/VeFCPR_e_FCPS_HTCoolReq'
     */
    (void)Rte_Read_VeFCPR_e_FCPS_HTCoolReq_Value
        (&rtb_TmpSignalConversionAtVeFC_o);

#endif

    /* End of SignalConversion generated from: '<S2>/VeFCPR_e_FCPS_HTCoolReq' */

    /* SignalConversion generated from: '<S2>/VeCSVR_v_VehSpd' incorporates:
     *  Inport: '<Root>/VeCSVR_v_VehSpd'
     */
    (void)Rte_Read_VeCSVR_v_VehSpd_Value(&rtb_TmpSignalConversionAtVeCSVR);

    /* SignalConversion generated from: '<S2>/VeTFTR_T_TransOilTemp' incorporates:
     *  Inport: '<Root>/VeTFTR_T_TransOilTemp'
     */
    (void)Rte_Read_VeTFTR_T_TransOilTemp_Value(&rtb_TmpSignalConversionAtVeTFTR);

    /* SignalConversion generated from: '<S2>/VeTHMR_M_MtrC_TorqAchieved' incorporates:
     *  Inport: '<Root>/VeMTIR_M_MtrC_TorqAchieved'
     */
    (void)Rte_Read_VeMTIR_M_MtrC_TorqAchieved_Value
        (&rtb_TmpSignalConversionAtVeTHMR);

    /* SignalConversion generated from: '<S2>/VePMDR_e_KeyStatus' incorporates:
     *  Inport: '<Root>/VePMDR_e_KeyStatus'
     */
    (void)Rte_Read_VePMDR_e_KeyStatus_Value
        (&THMR_ac_B.TmpSignalConversionAtVePMDR_e_K);

    /* SignalConversion generated from: '<S2>/VaCTMR_T_MtrCConTmps' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    /* SignalConversion generated from: '<S2>/VaCTMR_T_MtrCConTmps' incorporates:
     *  Inport: '<Root>/VaCTMR_T_MtrCConTmps'
     */
    (void)Rte_Read_VaCTMR_T_MtrCConTmps_Value(rtb_TmpSignalConversionAtVaCTMR);

#endif

    /* End of SignalConversion generated from: '<S2>/VaCTMR_T_MtrCConTmps' */

    /* SignalConversion generated from: '<S2>/VaCTMR_T_MtrCConTmpsLim' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    /* SignalConversion generated from: '<S2>/VaCTMR_T_MtrCConTmpsLim' incorporates:
     *  Inport: '<Root>/VaCTMR_T_MtrCConTmpsLim'
     */
    (void)Rte_Read_VaCTMR_T_MtrCConTmpsLim_Value(rtb_TmpSignalConversionAtVaCT_o);

#endif

    /* End of SignalConversion generated from: '<S2>/VaCTMR_T_MtrCConTmpsLim' */

    /* SignalConversion generated from: '<S2>/VaCTMR_T_MtrBConTmps' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

    /* SignalConversion generated from: '<S2>/VaCTMR_T_MtrBConTmps' incorporates:
     *  Inport: '<Root>/VaCTMR_T_MtrBConTmps'
     */
    (void)Rte_Read_VaCTMR_T_MtrBConTmps_Value(rtb_TmpSignalConversionAtVaC_ls);

#endif

    /* End of SignalConversion generated from: '<S2>/VaCTMR_T_MtrBConTmps' */

    /* SignalConversion generated from: '<S2>/VaCTMR_T_MtrBConTmpsLim' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

    /* SignalConversion generated from: '<S2>/VaCTMR_T_MtrBConTmpsLim' incorporates:
     *  Inport: '<Root>/VaCTMR_T_MtrBConTmpsLim'
     */
    (void)Rte_Read_VaCTMR_T_MtrBConTmpsLim_Value(rtb_TmpSignalConversionAtVaCT_l);

#endif

    /* End of SignalConversion generated from: '<S2>/VaCTMR_T_MtrBConTmpsLim' */

    /* SignalConversion generated from: '<S2>/VaCTMR_T_MtrAConTmps' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam || Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

    /* SignalConversion generated from: '<S2>/VaCTMR_T_MtrAConTmps' incorporates:
     *  Inport: '<Root>/VaCTMR_T_MtrAConTmps'
     */
    (void)Rte_Read_VaCTMR_T_MtrAConTmps_Value(rtb_TmpSignalConversionAtVaCT_e);

#endif

    /* End of SignalConversion generated from: '<S2>/VaCTMR_T_MtrAConTmps' */

    /* SignalConversion generated from: '<S2>/VaCTMR_T_MtrAConTmpsLim' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

    /* SignalConversion generated from: '<S2>/VaCTMR_T_MtrAConTmpsLim' incorporates:
     *  Inport: '<Root>/VaCTMR_T_MtrAConTmpsLim'
     */
    (void)Rte_Read_VaCTMR_T_MtrAConTmpsLim_Value(rtb_TmpSignalConversionAtVaCT_j);

#endif

    /* End of SignalConversion generated from: '<S2>/VaCTMR_T_MtrAConTmpsLim' */

    /* SignalConversion generated from: '<S2>/VeHTIR_e_HV_ElecClntHtr4_Sts' incorporates:
     *  Inport: '<Root>/VeHTIR_e_HV_ElecClntHtr4_Sts'
     */
    (void)Rte_Read_VeHTIR_e_HV_ElecClntHtr4_Sts_Value
        (&rtb_TmpSignalConversionAtVeHT_i);

    /* SignalConversion generated from: '<S2>/VeHTIR_P_HVC_Htr4PwrExpectd' incorporates:
     *  Inport: '<Root>/VeHTIR_P_HVC_Htr4PwrExpectd'
     */
    (void)Rte_Read_VeHTIR_P_HVC_Htr4PwrExpectd_Value
        (&rtb_TmpSignalConversionAtVeHT_k);

    /* SignalConversion generated from: '<S2>/VeBTRR_b_PerWup_BatToCond' incorporates:
     *  Inport: '<Root>/VeBTRR_b_PerWup_BatToCond'
     */
    (void)Rte_Read_VeBTRR_b_PerWup_BatToCond_Value
        (&rtb_TmpSignalConversionAtVeBT_f);

    /* SignalConversion generated from: '<S2>/VeTMIR_Pct_BSG_LTR_PmpSpdAct' incorporates:
     *  Inport: '<Root>/VeTMIR_Pct_BSG_LTR_PmpSpdAct'
     */
    (void)Rte_Read_VeTMIR_Pct_BSG_LTR_PmpSpdAct_Value
        (&rtb_TmpSignalConversionAtVeT_je);

    /* SignalConversion generated from: '<S2>/OutAirTemp_EstV_AftDial_Read' incorporates:
     *  Merge: '<Root>/OutAirTemp_EstV_AftDial_IRV_Merge'
     */
    rtb_TmpSignalConversionAtOutAir =
        Rte_IrvRead_THMR_MedTEH_OutAirTemp_EstV_AftDial_write_IRV();

    /* SignalConversion generated from: '<S2>/VeTMIR_b_OnBrdChrg_ClntTmpIn_FA' incorporates:
     *  Inport: '<Root>/VeTMIR_b_OnBrdChrg_ClntTmpIn_FA'
     */
    (void)Rte_Read_VeTMIR_b_OnBrdChrg_ClntTmpIn_FA_Value
        (&rtb_TmpSignalConversionAtVeT_ej);

    /* SignalConversion generated from: '<S2>/VeTMIR_T_OBCMTemp1' incorporates:
     *  Inport: '<Root>/VeTMIR_T_OBCMTemp1'
     */
    (void)Rte_Read_VeTMIR_T_OBCMTemp1_Value(&rtb_TmpSignalConversionAtVeT_fy);

    /* SignalConversion generated from: '<S2>/VeTMIR_b_OBCMTemp1_FA' incorporates:
     *  Inport: '<Root>/VeTMIR_b_OBCMTemp1_FA'
     */
    (void)Rte_Read_VeTMIR_b_OBCMTemp1_FA_Value(&rtb_TmpSignalConversionAtVeTM_j);

    /* SignalConversion generated from: '<S2>/VeTMIR_T_OBCMTemp2' incorporates:
     *  Inport: '<Root>/VeTMIR_T_OBCMTemp2'
     */
    (void)Rte_Read_VeTMIR_T_OBCMTemp2_Value(&rtb_TmpSignalConversionAtVeTM_n);

    /* SignalConversion generated from: '<S2>/VeTMIR_b_OBCMTemp2_FA' incorporates:
     *  Inport: '<Root>/VeTMIR_b_OBCMTemp2_FA'
     */
    (void)Rte_Read_VeTMIR_b_OBCMTemp2_FA_Value(&rtb_TmpSignalConversionAtVeT_f5);

    /* SignalConversion generated from: '<S2>/VeFSCR_Pct_RadFanCmd' incorporates:
     *  Inport: '<Root>/VeFSCR_Pct_RadFanCmd'
     */
    (void)Rte_Read_VeFSCR_Pct_RadFanCmd_Value(&rtb_TmpSignalConversionAtVeFSCR);

    /* SignalConversion generated from: '<S2>/VeTMIR_T_CntrlBrdTmp_Snsr2_AD' incorporates:
     *  Inport: '<Root>/VeTMIR_T_CntrlBrdTmp_Snsr2_AD'
     */
    (void)Rte_Read_VeTMIR_T_CntrlBrdTmp_Snsr2_AD_Value
        (&rtb_TmpSignalConversionAtVeT_gg);

    /* SignalConversion generated from: '<S2>/VeTMIR_b_CntrlBrdTmp_Snsr2_FA_AD' incorporates:
     *  Inport: '<Root>/VeTMIR_b_CntrlBrdTmp_Snsr2_FA_AD'
     */
    (void)Rte_Read_VeTMIR_b_CntrlBrdTmp_Snsr2_FA_AD_Value
        (&rtb_TmpSignalConversionAtVeT_pw);

    /* SignalConversion generated from: '<S2>/VeTMIR_b_TCU_Load_Index_FA' incorporates:
     *  Inport: '<Root>/VeTMIR_b_TCU_Load_Index_FA'
     */
    (void)Rte_Read_VeTMIR_b_TCU_Load_Index_FA_Value
        (&rtb_TmpSignalConversionAtVeT_d5);

    /* SignalConversion generated from: '<S2>/VeTMIR_b_OBCMTemp3_FA_AD' incorporates:
     *  Inport: '<Root>/VeTMIR_b_OBCMTemp3_FA_AD'
     */
    (void)Rte_Read_VeTMIR_b_OBCMTemp3_FA_AD_Value
        (&rtb_TmpSignalConversionAtVeT_ib);

    /* SignalConversion generated from: '<S2>/VeTMIR_b_OBCMTemp4_FA_AD' incorporates:
     *  Inport: '<Root>/VeTMIR_b_OBCMTemp4_FA_AD'
     */
    (void)Rte_Read_VeTMIR_b_OBCMTemp4_FA_AD_Value
        (&rtb_TmpSignalConversionAtVeT_c0);

    /* SignalConversion generated from: '<S2>/VePMPR_dV_LTRFlw' incorporates:
     *  Inport: '<Root>/VePMPR_dV_LTRFlw'
     */
    (void)Rte_Read_VePMPR_dV_LTRFlw_Value(&rtb_TmpSignalConversionAtVePM_d);

    /* SignalConversion generated from: '<S2>/VeTPCR_e_CabinPreCondReqStat' incorporates:
     *  Inport: '<Root>/VeTPCR_e_CabinPreCondReqStat'
     */
    (void)Rte_Read_VeTPCR_e_CabinPreCondReqStat_Value
        (&rtb_TmpSignalConversionAtVeTP_b);

    /* SignalConversion generated from: '<S2>/VeTPCR_e_PerWup_BattEngCond_State' incorporates:
     *  Inport: '<Root>/VeTPCR_e_PerWup_BattEngCond_State'
     */
    (void)Rte_Read_VeTPCR_e_PerWup_BattEngCond_State_Value
        (&rtb_TmpSignalConversionAtVeTP_k);

    /* SignalConversion generated from: '<S2>/VeTPCR_dT_PerWpCond_EngTmpErr' incorporates:
     *  Inport: '<Root>/VeTPCR_dT_PerWpCond_EngTmpErr'
     */
    (void)Rte_Read_VeTPCR_dT_PerWpCond_EngTmpErr_Value
        (&rtb_TmpSignalConversionAtVeTPCR);

    /* SignalConversion generated from: '<S2>/VeBTRR_e_HV_BatTempCrit_CondState_New' incorporates:
     *  Inport: '<Root>/VeBTRR_e_HV_BatTempCrit_CondState_New'
     */
    (void)Rte_Read_VeBTRR_e_HV_BatTempCrit_CondState_New_Value
        (&rtb_TmpSignalConversionAtVeB_kc);

    /* SignalConversion generated from: '<S2>/VeTPCR_dT_PerWpCond_BatTmpErr' incorporates:
     *  Inport: '<Root>/VeTPCR_dT_PerWpCond_BatTmpErr'
     */
    (void)Rte_Read_VeTPCR_dT_PerWpCond_BatTmpErr_Value
        (&rtb_TmpSignalConversionAtVeTP_i);

    /* SignalConversion generated from: '<S2>/VeHTIR_P_HVC_HtrPwrExpectd' incorporates:
     *  Inport: '<Root>/VeHTIR_P_HVC_HtrPwrExpectd'
     */
    (void)Rte_Read_VeHTIR_P_HVC_HtrPwrExpectd_Value
        (&rtb_TmpSignalConversionAtVeHT_p);

    /* SignalConversion generated from: '<S2>/VeHTIR_e_HV_ElecClntHtr_Sts' incorporates:
     *  Inport: '<Root>/VeHTIR_e_HV_ElecClntHtr_Sts'
     */
    (void)Rte_Read_VeHTIR_e_HV_ElecClntHtr_Sts_Value
        (&rtb_TmpSignalConversionAtVeHT_b);

    /* SignalConversion generated from: '<S2>/VeHTIR_T_HVC_HtrClntIn_Temp' incorporates:
     *  Inport: '<Root>/VeHTIR_T_HVC_HtrClntIn_Temp'
     */
    (void)Rte_Read_VeHTIR_T_HVC_HtrClntIn_Temp_Value
        (&rtb_TmpSignalConversionAtVeHT_o);

    /* SignalConversion generated from: '<S2>/VeCTRR_b_HardCabHeat_Req' incorporates:
     *  Inport: '<Root>/VeCTRR_b_HardCabHeat_Req'
     */
    (void)Rte_Read_VeCTRR_b_HardCabHeat_Req_Value
        (&rtb_TmpSignalConversionAtVeCT_c);

    /* SignalConversion generated from: '<S2>/VeCTRR_b_CabPriorityHigh' incorporates:
     *  Inport: '<Root>/VeCTRR_b_CabPriorityHigh'
     */
    (void)Rte_Read_VeCTRR_b_CabPriorityHigh_Value
        (&rtb_TmpSignalConversionAtVeCT_d);

    /* SignalConversion generated from: '<S2>/VeTAIR_T_FtEvapTmp' incorporates:
     *  Inport: '<Root>/VeTAIR_T_FtEvapTmp'
     */
    (void)Rte_Read_VeTAIR_T_FtEvapTmp_Value(&rtb_TmpSignalConversionAtVeT_j5);

    /* SignalConversion generated from: '<S2>/VeTRIR_b_AHP_EnblReq' incorporates:
     *  Inport: '<Root>/VeTRIR_b_AHP_EnblReq'
     */
    (void)Rte_Read_VeTRIR_b_AHP_EnblReq_Value(&rtb_TmpSignalConversionAtVeTR_i);

    /* SignalConversion generated from: '<S2>/VeBTRR_b_HVBattPriority' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

    /* SignalConversion generated from: '<S2>/VeBTRR_b_HVBattPriority' incorporates:
     *  Inport: '<Root>/VeBTRR_b_HVBattPriority'
     */
    (void)Rte_Read_VeBTRR_b_HVBattPriority_Value
        (&rtb_TmpSignalConversionAtVeBT_m);

#endif

    /* End of SignalConversion generated from: '<S2>/VeBTRR_b_HVBattPriority' */

    /* SignalConversion generated from: '<S2>/VeHTIR_e_HV_ElecClntHtr2_Sts' incorporates:
     *  Inport: '<Root>/VeHTIR_e_HV_ElecClntHtr2_Sts'
     */
    (void)Rte_Read_VeHTIR_e_HV_ElecClntHtr2_Sts_Value
        (&rtb_TmpSignalConversionAtVeHT_m);

    /* SignalConversion generated from: '<S2>/VeDMIR_e_DrvMdRaw' incorporates:
     *  Inport: '<Root>/VeDMIR_e_DrvMdRaw'
     */
    (void)Rte_Read_VeDMIR_e_DrvMdRaw_Value(&rtb_TmpSignalConversionAtVeDMIR);

    /* SignalConversion generated from: '<S2>/VeTPDR_P_CabinHeater_PwrBdgt_Avail' incorporates:
     *  Inport: '<Root>/VeTPDR_P_CabinHeater_PwrBdgt_Avail'
     */
    (void)Rte_Read_VeTPDR_P_CabinHeater_PwrBdgt_Avail_Value
        (&rtb_TmpSignalConversionAtVeTPDR);

    /* SignalConversion generated from: '<S2>/VePMPR_dV_HtrFlw' incorporates:
     *  Inport: '<Root>/VePMPR_dV_HtrFlw'
     */
    (void)Rte_Read_VePMPR_dV_HtrFlw_Value(&rtb_TmpSignalConversionAtVePM_n);

    /* SignalConversion generated from: '<S2>/VeHTIR_T_HVC_HtrClntOut_Temp' incorporates:
     *  Inport: '<Root>/VeHTIR_T_HVC_HtrClntOut_Temp'
     */
    (void)Rte_Read_VeHTIR_T_HVC_HtrClntOut_Temp_Value
        (&rtb_TmpSignalConversionAtVeHT_h);

    /* SignalConversion generated from: '<S2>/VeTPDR_P_RearHtr_PwrBdgt_Avail' incorporates:
     *  Inport: '<Root>/VeTPDR_P_RearHtr_PwrBdgt_Avail'
     */
    (void)Rte_Read_VeTPDR_P_RearHtr_PwrBdgt_Avail_Value
        (&rtb_TmpSignalConversionAtVeT_ms);

    /* SignalConversion generated from: '<S2>/VeTRIR_e_ClimateInfo' incorporates:
     *  Inport: '<Root>/VeTRIR_e_ClimateInfo'
     */
    (void)Rte_Read_VeTRIR_e_ClimateInfo_Value(&rtb_TmpSignalConversionAtVeTR_f);

    /* SignalConversion generated from: '<S2>/VeTRIR_b_ClimateInfo_FA' incorporates:
     *  Inport: '<Root>/VeTRIR_b_ClimateInfo_FA'
     */
    (void)Rte_Read_VeTRIR_b_ClimateInfo_FA_Value
        (&rtb_TmpSignalConversionAtVeTR_k);

    /* SignalConversion generated from: '<S2>/VeTAIR_Pct_FrtBlwrCmd' incorporates:
     *  Inport: '<Root>/VeTAIR_Pct_FrtBlwrCmd'
     */
    (void)Rte_Read_VeTAIR_Pct_FrtBlwrCmd_Value(&rtb_TmpSignalConversionAtVeTA_b);

    /* SignalConversion generated from: '<S2>/VeFCPR_I_FCPS_Curr' incorporates:
     *  SignalConversion generated from: '<S2>/VeFCPR_P_FCPS_LongTiDchaPwrLim'
     *  SignalConversion generated from: '<S2>/VeFCPR_T_FCPS_HTCoolDeltaSp'
     *  SignalConversion generated from: '<S2>/VeFCPR_T_FCPS_HTCoolInTemp'
     *  SignalConversion generated from: '<S2>/VeFCPR_T_FCPS_HTCoolOutTempSp'
     *  SignalConversion generated from: '<S2>/VePMIR_n_FCCPmpActSpd'
     *  SignalConversion generated from: '<S2>/VeTRIR_T_HtmpRadCool_TmpIn'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* SignalConversion generated from: '<S2>/VeFCPR_I_FCPS_Curr' incorporates:
     *  Inport: '<Root>/VeFCPR_I_FCPS_Curr'
     */
    (void)Rte_Read_VeFCPR_I_FCPS_Curr_Value(&rtb_TmpSignalConversionAtVeFC_p);

    /* SignalConversion generated from: '<S2>/VeFCPR_T_FCPS_HTCoolDeltaSp' incorporates:
     *  Inport: '<Root>/VeFCPR_T_FCPS_HTCoolDeltaSp'
     */
    (void)Rte_Read_VeFCPR_T_FCPS_HTCoolDeltaSp_Value
        (&rtb_TmpSignalConversionAtVeF_ob);

    /* SignalConversion generated from: '<S2>/VeFCPR_T_FCPS_HTCoolInTemp' incorporates:
     *  Inport: '<Root>/VeFCPR_T_FCPS_HTCoolInTemp'
     */
    (void)Rte_Read_VeFCPR_T_FCPS_HTCoolInTemp_Value
        (&rtb_TmpSignalConversionAtVeFC_f);

    /* SignalConversion generated from: '<S2>/VeTRIR_T_HtmpRadCool_TmpIn' incorporates:
     *  Inport: '<Root>/VeTRIR_T_HtmpRadCool_TmpIn'
     */
    (void)Rte_Read_VeTRIR_T_HtmpRadCool_TmpIn_Value
        (&rtb_TmpSignalConversionAtVeTR_p);

    /* SignalConversion generated from: '<S2>/VeFCPR_T_FCPS_HTCoolOutTempSp' incorporates:
     *  Inport: '<Root>/VeFCPR_T_FCPS_HTCoolOutTempSp'
     */
    (void)Rte_Read_VeFCPR_T_FCPS_HTCoolOutTempSp_Value
        (&rtb_TmpSignalConversionAtVeFC_k);

    /* SignalConversion generated from: '<S2>/VePMIR_n_FCCPmpActSpd' incorporates:
     *  Inport: '<Root>/VePMIR_n_FCCPmpActSpd'
     */
    (void)Rte_Read_VePMIR_n_FCCPmpActSpd_Value(&rtb_TmpSignalConversionAtVeP_jk);

    /* SignalConversion generated from: '<S2>/VeFCPR_P_FCPS_LongTiDchaPwrLim' incorporates:
     *  Inport: '<Root>/VeFCPR_P_FCPS_LongTiDchaPwrLim'
     */
    (void)Rte_Read_VeFCPR_P_FCPS_LongTiDchaPwrLim_Value
        (&rtb_TmpSignalConversionAtVeF_l2);

#endif

    /* End of SignalConversion generated from: '<S2>/VeFCPR_I_FCPS_Curr' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeBPCR_U_HV_BatVolt' */
    (void)Rte_Read_VeBPCR_U_HV_BatVolt_Value(&rtb_Switch1_oje);

    /* Inport: '<Root>/VePMIR_b_TransAuxPump2OilTemp_FA' */
    (void)Rte_Read_VePMIR_b_TransAuxPump2OilTemp_FA_Value(&VeTHMR_b_DrvDrAjar);

    /* Inport: '<Root>/VePMIR_T_TransAuxPump2OilTemp' */
    (void)Rte_Read_VePMIR_T_TransAuxPump2OilTemp_Value(&rtb_UnitDelay_bv);

    /* Inport: '<Root>/VePMIR_b_TransAuxPumpOilTemp_FA' */
    (void)Rte_Read_VePMIR_b_TransAuxPumpOilTemp_FA_Value(&rtb_Logical12_k5);

    /* Inport: '<Root>/VePMIR_T_TransAuxPumpOilTemp' */
    (void)Rte_Read_VePMIR_T_TransAuxPumpOilTemp_Value(&tmpRead_1m);

    /* Inport: '<Root>/VeBPCR_b_BPCM_LOC_BCP_SgnlRcvd' */
    (void)Rte_Read_VeBPCR_b_BPCM_LOC_BCP_SgnlRcvd_Value(&rtb_Logical12_hy);

    /* Inport: '<Root>/VeBPCR_b_BPCM_LOC_BCP_FA' */
    (void)Rte_Read_VeBPCR_b_BPCM_LOC_BCP_FA_Value(&rtb_Logical46_fu);

    /* Inport: '<Root>/VeBPCR_e_BPCM_LOC_BCP' */
    (void)Rte_Read_VeBPCR_e_BPCM_LOC_BCP_Value(&tmpRead_1d);

    /* Inport: '<Root>/VeBPCR_b_BPCM_LIN_BusOff_SgnlRcvd' */
    (void)Rte_Read_VeBPCR_b_BPCM_LIN_BusOff_SgnlRcvd_Value(&rtb_Logical46_j2);

    /* Inport: '<Root>/VeBPCR_b_BPCM_LIN_BusOff_FA' */
    (void)Rte_Read_VeBPCR_b_BPCM_LIN_BusOff_FA_Value(&rtb_Logical46_cr);

    /* Inport: '<Root>/VeBPCR_e_BPCM_LIN_BusOff' */
    (void)Rte_Read_VeBPCR_e_BPCM_LIN_BusOff_Value(&tmpRead_1c);

    /* Inport: '<Root>/VeBPCR_Pct_HV_BatPackSOC_Arb' */
    (void)Rte_Read_VeBPCR_Pct_HV_BatPackSOC_Arb_Value(&tmpRead_8);

    /* Inport: '<Root>/VeBPCR_b_HVBatRdy' */
    (void)Rte_Read_VeBPCR_b_HVBatRdy_Value(&rtb_Logical46_hh);

    /* Inport: '<Root>/VeIDCR_b_APMTemp2_FA' */
    (void)Rte_Read_VeIDCR_b_APMTemp2_FA_Value(&rtb_Logical17_h);

    /* Inport: '<Root>/VeIDCR_T_APMTemp2' */
    (void)Rte_Read_VeIDCR_T_APMTemp2_Value(&tmpRead_7);

    /* Inport: '<Root>/VeIDCR_b_APMTemp1_FA' */
    (void)Rte_Read_VeIDCR_b_APMTemp1_FA_Value(&rtb_Logical1_c0);

    /* Inport: '<Root>/VeIDCR_T_APMTemp1' */
    (void)Rte_Read_VeIDCR_T_APMTemp1_Value(&tmpRead_6);

    /* Inport: '<Root>/VeINVR_b_MtrB_InvrtrTempFA' */
    (void)Rte_Read_VeINVR_b_MtrB_InvrtrTempFA_Value(&rtb_Logical1_li);

    /* Inport: '<Root>/VeINVR_T_MtrB_InvrtrTemp' */
    (void)Rte_Read_VeINVR_T_MtrB_InvrtrTemp_Value(&tmpRead_5);

    /* Inport: '<Root>/VeINVR_b_MtrA_InvrtrTempFA' */
    (void)Rte_Read_VeINVR_b_MtrA_InvrtrTempFA_Value(&rtb_Logical1_gx);

    /* Inport: '<Root>/VeINVR_T_MtrA_InvrtrTemp' */
    (void)Rte_Read_VeINVR_T_MtrA_InvrtrTemp_Value(&tmpRead_4);

    /* Inport: '<Root>/VeINVR_b_MtrB_TempFA' */
    (void)Rte_Read_VeINVR_b_MtrB_TempFA_Value(&rtb_Logical2_oq);

    /* Inport: '<Root>/VeINVR_T_MtrB_Temp' */
    (void)Rte_Read_VeINVR_T_MtrB_Temp_Value(&tmpRead_3);

    /* Inport: '<Root>/VeINVR_b_MtrA_TempFA' */
    (void)Rte_Read_VeINVR_b_MtrA_TempFA_Value(&rtb_AND_fe);

    /* Inport: '<Root>/VeINVR_T_MtrA_Temp' */
    (void)Rte_Read_VeINVR_T_MtrA_Temp_Value(&tmpRead_2);

    /* Inport: '<Root>/VeENGR_b_ECT_Sgnl_Rcvd' */
    (void)Rte_Read_VeENGR_b_ECT_Sgnl_Rcvd_Value(&rtb_Logical6_fk);

    /* Inport: '<Root>/VeENGR_b_ECT_SnsrFA' */
    (void)Rte_Read_VeENGR_b_ECT_SnsrFA_Value(&tmpRead_1);

    /* Inport: '<Root>/VeENGR_T_EngCoolantTemp' */
    (void)Rte_Read_VeENGR_T_EngCoolantTemp_Value(&tmpRead_0);

    /* Inport: '<Root>/VeHPMR_b_PropSysActv' */
    (void)Rte_Read_VeHPMR_b_PropSysActv_Value(&tmpRead);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* SignalConversion generated from: '<S2>/VeTPCR_e_ProactiveCondStat' incorporates:
     *  Inport: '<Root>/VeTPCR_e_ProactiveCondStat'
     */
    (void)Rte_Read_VeTPCR_e_ProactiveCondStat_Value
        (&rtb_TmpSignalConversionAtVeTP_g);

    /* SignalConversion generated from: '<S2>/VeTPCR_e_ProactiveCondMode' incorporates:
     *  Inport: '<Root>/VeTPCR_e_ProactiveCondMode'
     */
    (void)Rte_Read_VeTPCR_e_ProactiveCondMode_Value
        (&rtb_TmpSignalConversionAtVeT_h0);

    /* SignalConversion generated from: '<S2>/VePDTR_b_OV_EPD_BattCool_Req' incorporates:
     *  Inport: '<Root>/VePDTR_b_OV_EPD_BattCool_Req'
     */
    (void)Rte_Read_VePDTR_b_OV_EPD_BattCool_Req_Value
        (&rtb_TmpSignalConversionAtVePD_p);

    /* SignalConversion generated from: '<S2>/VePDTR_b_OV_EPD_BattHeat_Req' incorporates:
     *  Inport: '<Root>/VePDTR_b_OV_EPD_BattHeat_Req'
     */
    (void)Rte_Read_VePDTR_b_OV_EPD_BattHeat_Req_Value
        (&rtb_TmpSignalConversionAtVePD_i);

    /* SignalConversion generated from: '<S2>/VeTPCR_e_RacePrepState' incorporates:
     *  Inport: '<Root>/VeTPCR_e_RacePrepState'
     */
    (void)Rte_Read_VeTPCR_e_RacePrepState_Value(&rtb_TmpSignalConversionAtVeTP_e);

    /* SignalConversion generated from: '<S2>/VeTPCR_e_SC_WakeUp' incorporates:
     *  Inport: '<Root>/VeTPCR_e_SC_WakeUp'
     */
    (void)Rte_Read_VeTPCR_e_SC_WakeUp_Value(&rtb_TmpSignalConversionAtVeTP_a);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem20'
     */
    /* Switch: '<S3883>/Switch' incorporates:
     *  Constant: '<S3887>/Calib'
     */
    if (KeTHMR_b_EngClntTmp_Out_SelDial)
    {
        /* Switch: '<S3883>/Switch' incorporates:
         *  Constant: '<S3884>/Calib'
         */
        VeTHMR_T_EngCoolantTemp = KeTHMR_T_EngClntTmp_Out_Dial;
    }
    else
    {
        /* Switch: '<S3883>/Switch' */
        VeTHMR_T_EngCoolantTemp = tmpRead_0;
    }

    /* End of Switch: '<S3883>/Switch' */

    /* Switch: '<S3883>/Switch1' incorporates:
     *  Constant: '<S3889>/Calib'
     */
    if (KeTHMR_b_EngCoolantTemp_FA_SD)
    {
        /* Switch: '<S3883>/Switch1' incorporates:
         *  Constant: '<S3888>/Calib'
         */
        VeTHMR_b_EngCoolantTemp_FA = KeTHMR_b_EngCoolantTemp_FA_D;
    }
    else
    {
        /* Switch: '<S3883>/Switch1' */
        VeTHMR_b_EngCoolantTemp_FA = tmpRead_1;
    }

    /* End of Switch: '<S3883>/Switch1' */

    /* Switch: '<S3883>/Switch2' incorporates:
     *  Constant: '<S3886>/Calib'
     */
    if (KeTHMR_b_ECT_Sgnl_Rcvd_SD)
    {
        /* Switch: '<S3883>/Switch2' incorporates:
         *  Constant: '<S3885>/Calib'
         */
        VeTHMR_b_ECT_Sgnl_Rcvd = KeTHMR_b_ECT_Sgnl_Rcvd_D;
    }
    else
    {
        /* Switch: '<S3883>/Switch2' */
        VeTHMR_b_ECT_Sgnl_Rcvd = rtb_Logical6_fk;
    }

    /* End of Switch: '<S3883>/Switch2' */

    /* Switch: '<S3838>/Switch' incorporates:
     *  Constant: '<S3939>/Calib'
     */
    if (KeTHMR_b_SumpOilTmp_SelDial)
    {
        /* Switch: '<S3838>/Switch' incorporates:
         *  Constant: '<S3938>/Calib'
         */
        VeTHMR_T_TransOilTemp = KeTHMR_T_SumpOilTmp_Dial;
    }
    else
    {
        /* Switch: '<S3838>/Switch' */
        VeTHMR_T_TransOilTemp = rtb_TmpSignalConversionAtVeTFTR;
    }

    /* End of Switch: '<S3838>/Switch' */

    /* Switch: '<S3837>/Switch' incorporates:
     *  Constant: '<S3936>/Calib'
     */
    if (KeTHMR_b_PropSysActv_100msSD)
    {
        /* Switch: '<S3837>/Switch' incorporates:
         *  Constant: '<S3937>/Calib'
         */
        VeTHMR_b_PropSysActv_100ms_AD = KeTHMR_b_PropSysActv_100ms_D;
    }
    else
    {
        /* Switch: '<S3837>/Switch' */
        VeTHMR_b_PropSysActv_100ms_AD = tmpRead;
    }

    /* End of Switch: '<S3837>/Switch' */

    /* Switch: '<S3911>/Switch' incorporates:
     *  Constant: '<S3915>/Calib'
     */
    if (KeTHMR_b_MtrA_Temp_SelDial)
    {
        /* Switch: '<S3911>/Switch' incorporates:
         *  Constant: '<S3914>/Calib'
         */
        VeTHMR_T_MtrA_Temp = KeTHMR_T_MtrA_TempDial;
    }
    else
    {
        /* Switch: '<S3911>/Switch' */
        VeTHMR_T_MtrA_Temp = tmpRead_2;
    }

    /* End of Switch: '<S3911>/Switch' */

    /* Switch: '<S3910>/Switch' incorporates:
     *  Constant: '<S3913>/Calib'
     */
    if (KeTHMR_b_MtrA_TempFA_SelDial)
    {
        /* Switch: '<S3910>/Switch' incorporates:
         *  Constant: '<S3912>/Calib'
         */
        VeTHMR_b_MtrA_TempFA = KeTHMR_b_MtrA_TempDial_FA;
    }
    else
    {
        /* Switch: '<S3910>/Switch' */
        VeTHMR_b_MtrA_TempFA = rtb_AND_fe;
    }

    /* End of Switch: '<S3910>/Switch' */

    /* Switch: '<S3917>/Switch' incorporates:
     *  Constant: '<S3921>/Calib'
     */
    if (KeTHMR_b_MtrB_Temp_SelDial)
    {
        /* Switch: '<S3917>/Switch' incorporates:
         *  Constant: '<S3920>/Calib'
         */
        VeTHMR_T_MtrB_Temp = KeTHMR_T_MtrB_TempDial;
    }
    else
    {
        /* Switch: '<S3917>/Switch' */
        VeTHMR_T_MtrB_Temp = tmpRead_3;
    }

    /* End of Switch: '<S3917>/Switch' */

    /* Switch: '<S3916>/Switch' incorporates:
     *  Constant: '<S3919>/Calib'
     */
    if (KeTHMR_b_MtrB_TempFA_SelDial)
    {
        /* Switch: '<S3916>/Switch' incorporates:
         *  Constant: '<S3918>/Calib'
         */
        VeTHMR_b_MtrB_TempFA = KeTHMR_b_MtrB_TempDial_FA;
    }
    else
    {
        /* Switch: '<S3916>/Switch' */
        VeTHMR_b_MtrB_TempFA = rtb_Logical2_oq;
    }

    /* End of Switch: '<S3916>/Switch' */

    /* Switch: '<S3896>/Switch' incorporates:
     *  Constant: '<S3900>/Calib'
     */
    if (KeTHMR_b_MtrA_InvrtrTemp_SelDial)
    {
        /* Switch: '<S3896>/Switch' incorporates:
         *  Constant: '<S3899>/Calib'
         */
        VeTHMR_T_MtrA_InvrtrTemp = KeTHMR_T_MtrA_InvrtrTempDial;
    }
    else
    {
        /* Switch: '<S3896>/Switch' */
        VeTHMR_T_MtrA_InvrtrTemp = tmpRead_4;
    }

    /* End of Switch: '<S3896>/Switch' */

    /* Switch: '<S3895>/Switch' incorporates:
     *  Constant: '<S3898>/Calib'
     */
    if (KeTHMR_b_MtrA_InvrtrTempFA_SelDial)
    {
        /* Switch: '<S3895>/Switch' incorporates:
         *  Constant: '<S3897>/Calib'
         */
        VeTHMR_b_MtrA_InvrtrTempFA = KeTHMR_b_MtrA_InvrtrTempDial_FA;
    }
    else
    {
        /* Switch: '<S3895>/Switch' */
        VeTHMR_b_MtrA_InvrtrTempFA = rtb_Logical1_gx;
    }

    /* End of Switch: '<S3895>/Switch' */

    /* Switch: '<S3903>/Switch' incorporates:
     *  Constant: '<S3907>/Calib'
     */
    if (KeTHMR_b_MtrB_InvrtrTemp_SelDial)
    {
        /* Switch: '<S3903>/Switch' incorporates:
         *  Constant: '<S3906>/Calib'
         */
        VeTHMR_T_MtrB_InvrtrTemp = KeTHMR_T_MtrB_InvrtrTempDial;
    }
    else
    {
        /* Switch: '<S3903>/Switch' */
        VeTHMR_T_MtrB_InvrtrTemp = tmpRead_5;
    }

    /* End of Switch: '<S3903>/Switch' */

    /* Switch: '<S3902>/Switch' incorporates:
     *  Constant: '<S3905>/Calib'
     */
    if (KeTHMR_b_MtrB_InvrtrTempFA_SelDial)
    {
        /* Switch: '<S3902>/Switch' incorporates:
         *  Constant: '<S3904>/Calib'
         */
        VeTHMR_b_MtrB_InvrtrTempFA = KeTHMR_b_MtrB_InvrtrTempDial_FA;
    }
    else
    {
        /* Switch: '<S3902>/Switch' */
        VeTHMR_b_MtrB_InvrtrTempFA = rtb_Logical1_li;
    }

    /* End of Switch: '<S3902>/Switch' */

    /* Switch: '<S3871>/Switch' incorporates:
     *  Constant: '<S3875>/Calib'
     */
    if (KeTHMR_b_APM_Temp1_SD)
    {
        /* Switch: '<S3871>/Switch' incorporates:
         *  Constant: '<S3874>/Calib'
         */
        VeTHMR_T_APM_Temp1 = KeTHMR_T_APM_Temp1_D;
    }
    else
    {
        /* Switch: '<S3871>/Switch' */
        VeTHMR_T_APM_Temp1 = tmpRead_6;
    }

    /* End of Switch: '<S3871>/Switch' */

    /* Switch: '<S3870>/Switch' incorporates:
     *  Constant: '<S3873>/Calib'
     */
    if (KeTHMR_b_APM_Temp1_FA_SD)
    {
        /* Switch: '<S3870>/Switch' incorporates:
         *  Constant: '<S3872>/Calib'
         */
        VeTHMR_b_APM_Temp1_FA = KeTHMR_b_APM_Temp1_FA_D;
    }
    else
    {
        /* Switch: '<S3870>/Switch' */
        VeTHMR_b_APM_Temp1_FA = rtb_Logical1_c0;
    }

    /* End of Switch: '<S3870>/Switch' */

    /* Switch: '<S3878>/Switch' incorporates:
     *  Constant: '<S3882>/Calib'
     */
    if (KeTHMR_b_APM_Temp2_SD)
    {
        /* Switch: '<S3878>/Switch' incorporates:
         *  Constant: '<S3881>/Calib'
         */
        VeTHMR_T_APM_Temp2 = KeTHMR_T_APM_Temp2_D;
    }
    else
    {
        /* Switch: '<S3878>/Switch' */
        VeTHMR_T_APM_Temp2 = tmpRead_7;
    }

    /* End of Switch: '<S3878>/Switch' */

    /* Switch: '<S3877>/Switch' incorporates:
     *  Constant: '<S3880>/Calib'
     */
    if (KeTHMR_b_APM_Temp2_FA_SD)
    {
        /* Switch: '<S3877>/Switch' incorporates:
         *  Constant: '<S3879>/Calib'
         */
        VeTHMR_b_APM_Temp2_FA = KeTHMR_b_APM_Temp2_FA_D;
    }
    else
    {
        /* Switch: '<S3877>/Switch' */
        VeTHMR_b_APM_Temp2_FA = rtb_Logical17_h;
    }

    /* End of Switch: '<S3877>/Switch' */

    /* Switch: '<S3846>/Switch' incorporates:
     *  Constant: '<S3850>/Calib'
     */
    if (KeTHMR_b_APM2_Temp1_SD)
    {
        /* Switch: '<S3846>/Switch' incorporates:
         *  Constant: '<S3849>/Calib'
         */
        VeTHMR_T_APM2_Temp1 = KeTHMR_T_APM2_Temp1_D;
    }
    else
    {
        /* Switch: '<S3846>/Switch' incorporates:
         *  Constant: '<Root>/Constant'
         */
        VeTHMR_T_APM2_Temp1 = 0.0F;
    }

    /* End of Switch: '<S3846>/Switch' */

    /* Switch: '<S3845>/Switch' incorporates:
     *  Constant: '<S3847>/Calib'
     *  Constant: '<S3848>/Calib'
     */
    VeTHMR_b_APM2_Temp1_FA = ((KeTHMR_b_APM2_Temp1_FA_SD) &&
        (KeTHMR_b_APM2_Temp1_FA_D));

    /* Switch: '<S3852>/Switch' incorporates:
     *  Constant: '<S3856>/Calib'
     */
    if (KeTHMR_b_APM2_Temp2_SD)
    {
        /* Switch: '<S3852>/Switch' incorporates:
         *  Constant: '<S3855>/Calib'
         */
        VeTHMR_T_APM2_Temp2 = KeTHMR_T_APM2_Temp2_D;
    }
    else
    {
        /* Switch: '<S3852>/Switch' incorporates:
         *  Constant: '<Root>/Constant1'
         */
        VeTHMR_T_APM2_Temp2 = 0.0F;
    }

    /* End of Switch: '<S3852>/Switch' */

    /* Switch: '<S3851>/Switch' incorporates:
     *  Constant: '<S3853>/Calib'
     *  Constant: '<S3854>/Calib'
     */
    VeTHMR_b_APM2_Temp2_FA = ((KeTHMR_b_APM2_Temp2_FA_SD) &&
        (KeTHMR_b_APM2_Temp2_FA_D));

    /* Switch: '<S3858>/Switch' incorporates:
     *  Constant: '<S3862>/Calib'
     */
    if (KeTHMR_b_APM3_Temp1_SD)
    {
        /* Switch: '<S3858>/Switch' incorporates:
         *  Constant: '<S3861>/Calib'
         */
        VeTHMR_T_APM3_Temp1 = KeTHMR_T_APM3_Temp1_D;
    }
    else
    {
        /* Switch: '<S3858>/Switch' incorporates:
         *  Constant: '<Root>/Constant2'
         */
        VeTHMR_T_APM3_Temp1 = 0.0F;
    }

    /* End of Switch: '<S3858>/Switch' */

    /* Switch: '<S3857>/Switch' incorporates:
     *  Constant: '<S3859>/Calib'
     *  Constant: '<S3860>/Calib'
     */
    VeTHMR_b_APM3_Temp1_FA = ((KeTHMR_b_APM3_Temp1_FA_SD) &&
        (KeTHMR_b_APM3_Temp1_FA_D));

    /* Switch: '<S3864>/Switch' incorporates:
     *  Constant: '<S3868>/Calib'
     */
    if (KeTHMR_b_APM3_Temp2_SD)
    {
        /* Switch: '<S3864>/Switch' incorporates:
         *  Constant: '<S3867>/Calib'
         */
        VeTHMR_T_APM3_Temp2 = KeTHMR_T_APM3_Temp2_D;
    }
    else
    {
        /* Switch: '<S3864>/Switch' incorporates:
         *  Constant: '<Root>/Constant3'
         */
        VeTHMR_T_APM3_Temp2 = 0.0F;
    }

    /* End of Switch: '<S3864>/Switch' */

    /* Switch: '<S3863>/Switch' incorporates:
     *  Constant: '<S3865>/Calib'
     *  Constant: '<S3866>/Calib'
     */
    VeTHMR_b_APM3_Temp2_FA = ((KeTHMR_b_APM3_Temp2_FA_SD) &&
        (KeTHMR_b_APM3_Temp2_FA_D));

    /* Switch: '<S3925>/Switch' incorporates:
     *  Constant: '<S3929>/Calib'
     */
    if (KeTHMR_b_PumpOilTemp_SD)
    {
        /* Switch: '<S3925>/Switch' incorporates:
         *  Constant: '<S3928>/Calib'
         */
        VeTHMR_T_PumpOilTemp = KeTHMR_T_PumpOilTemp_D;
    }
    else
    {
        /* Switch: '<S3925>/Switch' */
        VeTHMR_T_PumpOilTemp = tmpRead_1m;
    }

    /* End of Switch: '<S3925>/Switch' */

    /* Switch: '<S3924>/Switch' incorporates:
     *  Constant: '<S3927>/Calib'
     */
    if (KeTHMR_b_PumpOilTemp_FA_SD)
    {
        /* Switch: '<S3924>/Switch' incorporates:
         *  Constant: '<S3926>/Calib'
         */
        VeTHMR_b_PumpOilTemp_FA = KeTHMR_b_PumpOilTemp_FA_D;
    }
    else
    {
        /* Switch: '<S3924>/Switch' */
        VeTHMR_b_PumpOilTemp_FA = rtb_Logical12_k5;
    }

    /* End of Switch: '<S3924>/Switch' */

    /* Switch: '<S3931>/Switch' incorporates:
     *  Constant: '<S3935>/Calib'
     */
    if (KeTHMR_b_Pump2OilTemp_SD)
    {
        /* Switch: '<S3931>/Switch' incorporates:
         *  Constant: '<S3934>/Calib'
         */
        VeTHMR_T_Pump2OilTemp = KeTHMR_T_Pump2OilTemp_D;
    }
    else
    {
        /* Switch: '<S3931>/Switch' */
        VeTHMR_T_Pump2OilTemp = rtb_UnitDelay_bv;
    }

    /* End of Switch: '<S3931>/Switch' */

    /* Switch: '<S3930>/Switch' incorporates:
     *  Constant: '<S3933>/Calib'
     */
    if (KeTHMR_b_Pump2OilTemp_FA_SD)
    {
        /* Switch: '<S3930>/Switch' incorporates:
         *  Constant: '<S3932>/Calib'
         */
        VeTHMR_b_Pump2OilTemp_FA = KeTHMR_b_Pump2OilTemp_FA_D;
    }
    else
    {
        /* Switch: '<S3930>/Switch' */
        VeTHMR_b_Pump2OilTemp_FA = VeTHMR_b_DrvDrAjar;
    }

    /* End of Switch: '<S3930>/Switch' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Battery_Related_InputOverwrite_Block'
     */
    /* Switch: '<S225>/Switch' incorporates:
     *  Constant: '<S250>/Calib'
     */
    if (KeTHMR_b_HV_BatRdy_SelDial)
    {
        /* Switch: '<S225>/Switch' incorporates:
         *  Constant: '<S249>/Calib'
         */
        VeTHMR_b_HV_BatRdy_AD = KeTHMR_b_HV_BatRdy_Dial;
    }
    else
    {
        /* Switch: '<S225>/Switch' */
        VeTHMR_b_HV_BatRdy_AD = rtb_Logical46_hh;
    }

    /* End of Switch: '<S225>/Switch' */

    /* Switch: '<S244>/Switch' incorporates:
     *  Constant: '<S246>/Calib'
     */
    if (KeTHMR_b_HV_BatPckSOC_SelDial)
    {
        /* Switch: '<S244>/Switch' incorporates:
         *  Constant: '<S245>/Calib'
         */
        VeTHMR_Pct_HV_BatSOC = KeTHMR_Pct_HV_BatPckSOC_Dial;
    }
    else
    {
        /* Switch: '<S244>/Switch' */
        VeTHMR_Pct_HV_BatSOC = tmpRead_8;
    }

    /* End of Switch: '<S244>/Switch' */

    /* Switch: '<S226>/Switch' incorporates:
     *  Constant: '<S229>/Calib'
     */
    if (KeTHMR_b_BPCM_LIN_BusOff_SD)
    {
        /* Switch: '<S226>/Switch' incorporates:
         *  Constant: '<S230>/Calib'
         */
        VeTHMR_e_BPCM_LIN_BusOff = KeTHMR_e_BPCM_LIN_BusOff_D;
    }
    else
    {
        /* Switch: '<S226>/Switch' incorporates:
         *  Inport: '<Root>/VeBPCR_e_BPCM_LIN_BusOff'
         */
        VeTHMR_e_BPCM_LIN_BusOff = tmpRead_1c;
    }

    /* End of Switch: '<S226>/Switch' */

    /* Switch: '<S227>/Switch' incorporates:
     *  Constant: '<S232>/Calib'
     */
    if (KeTHMR_b_BPCM_LIN_BusOff_FA_SD)
    {
        /* Switch: '<S227>/Switch' incorporates:
         *  Constant: '<S231>/Calib'
         */
        VeTHMR_b_BPCM_LIN_BusOff_FA = KeTHMR_b_BPCM_LIN_BusOff_FA_D;
    }
    else
    {
        /* Switch: '<S227>/Switch' */
        VeTHMR_b_BPCM_LIN_BusOff_FA = rtb_Logical46_cr;
    }

    /* End of Switch: '<S227>/Switch' */

    /* Switch: '<S228>/Switch' incorporates:
     *  Constant: '<S234>/Calib'
     */
    if (KeTHMR_b_BPCM_LIN_BusOff_SgnlRcvd_SD)
    {
        /* Switch: '<S228>/Switch' incorporates:
         *  Constant: '<S233>/Calib'
         */
        VeTHMR_b_BPCM_LIN_BusOff_SgnlRcvd = KeTHMR_b_BPCM_LIN_BusOff_SgnlRcvd_D;
    }
    else
    {
        /* Switch: '<S228>/Switch' */
        VeTHMR_b_BPCM_LIN_BusOff_SgnlRcvd = rtb_Logical46_j2;
    }

    /* End of Switch: '<S228>/Switch' */

    /* Switch: '<S235>/Switch' incorporates:
     *  Constant: '<S238>/Calib'
     */
    if (KeTHMR_b_BPCM_LOC_BCP_SD)
    {
        /* Switch: '<S235>/Switch' incorporates:
         *  Constant: '<S239>/Calib'
         */
        VeTHMR_e_BPCM_LOC_BCP = KeTHMR_e_BPCM_LOC_BCP_D;
    }
    else
    {
        /* Switch: '<S235>/Switch' incorporates:
         *  Inport: '<Root>/VeBPCR_e_BPCM_LOC_BCP'
         */
        VeTHMR_e_BPCM_LOC_BCP = tmpRead_1d;
    }

    /* End of Switch: '<S235>/Switch' */

    /* Switch: '<S236>/Switch' incorporates:
     *  Constant: '<S241>/Calib'
     */
    if (KeTHMR_b_BPCM_LOC_BCP_FA_SD)
    {
        /* Switch: '<S236>/Switch' incorporates:
         *  Constant: '<S240>/Calib'
         */
        VeTHMR_b_BPCM_LOC_BCP_FA = KeTHMR_b_BPCM_LOC_BCP_FA_D;
    }
    else
    {
        /* Switch: '<S236>/Switch' */
        VeTHMR_b_BPCM_LOC_BCP_FA = rtb_Logical46_fu;
    }

    /* End of Switch: '<S236>/Switch' */

    /* Switch: '<S237>/Switch' incorporates:
     *  Constant: '<S243>/Calib'
     */
    if (KeTHMR_b_BPCM_LOC_BCP_SgnlRcvd_SD)
    {
        /* Switch: '<S237>/Switch' incorporates:
         *  Constant: '<S242>/Calib'
         */
        VeTHMR_b_BPCM_LOC_BCP_SgnlRcvd = KeTHMR_b_BPCM_LOC_BCP_SgnlRcvd_D;
    }
    else
    {
        /* Switch: '<S237>/Switch' */
        VeTHMR_b_BPCM_LOC_BCP_SgnlRcvd = rtb_Logical12_hy;
    }

    /* End of Switch: '<S237>/Switch' */

    /* Switch: '<S224>/Switch' incorporates:
     *  Constant: '<S248>/Calib'
     */
    if (KeTHMR_b_HV_BatVolt_SD)
    {
        /* Switch: '<S224>/Switch' incorporates:
         *  Constant: '<S247>/Calib'
         */
        VeTHMR_U_HV_BatVolt_AD = KeTHMR_U_HV_BatVolt_D;
    }
    else
    {
        /* Switch: '<S224>/Switch' */
        VeTHMR_U_HV_BatVolt_AD = rtb_Switch1_oje;
    }

    /* End of Switch: '<S224>/Switch' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HVAC_EAC1'
     */
    /* Switch: '<S2159>/Switch' incorporates:
     *  Constant: '<S2166>/Calib'
     *  Inport: '<Root>/VeTAIR_p_HghRfrgtPres'
     */
    if (KeTHMR_b_HghRfrgtPres_SelDial)
    {
        /* Switch: '<S2159>/Switch' incorporates:
         *  Constant: '<S2165>/Calib'
         */
        VeTHMR_p_HghRfrgtPres_B4SET = KeTHMR_P_HghRfrgtPres_Dial;
    }
    else
    {
        (void)Rte_Read_VeTAIR_p_HghRfrgtPres_Value(&tmpRead_9);

        /* Switch: '<S2159>/Switch' incorporates:
         *  Constant: '<S2164>/Calib'
         *  Inport: '<Root>/VeTAIR_p_HghRfrgtPres'
         *  Product: '<S2159>/Product'
         */
        VeTHMR_p_HghRfrgtPres_B4SET = tmpRead_9 * KeTHMR_Cf_Bar2KPa;
    }

    /* End of Switch: '<S2159>/Switch' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeTAIR_b_WinshldDfrst' */
    (void)Rte_Read_VeTAIR_b_WinshldDfrst_Value(&tmpRead_1f);

    /* Inport: '<Root>/VeHCDR_e_BatteryThermalFault' */
    (void)Rte_Read_VeHCDR_e_BatteryThermalFault_Value(&tmpRead_18);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HVAC_EAC1'
     */
    /* Switch: '<S2158>/Switch' incorporates:
     *  Constant: '<S2162>/Calib'
     */
    if (KeTHMR_b_CompFlts_SD)
    {
        /* Switch: '<S2158>/Switch' incorporates:
         *  Constant: '<S2163>/Calib'
         */
        VeTHMR_b_CompFlts = KeTHMR_e_CompFlts_D;
    }
    else
    {
        /* Switch: '<S2158>/Switch' incorporates:
         *  Inport: '<Root>/VeHCDR_e_BatteryThermalFault'
         */
        VeTHMR_b_CompFlts = tmpRead_18;
    }

    /* End of Switch: '<S2158>/Switch' */

    /* Switch: '<S2160>/Switch' incorporates:
     *  Constant: '<S2168>/Calib'
     */
    if (KeTHMR_b_Defrost_SD)
    {
        /* Switch: '<S2160>/Switch' incorporates:
         *  Constant: '<S2167>/Calib'
         */
        VeTHMR_b_Defrost = KeTHMR_b_Defrost_D;
    }
    else
    {
        /* Switch: '<S2160>/Switch' */
        VeTHMR_b_Defrost = tmpRead_1f;
    }

    /* End of Switch: '<S2160>/Switch' */

    /* Switch: '<S2161>/Switch' incorporates:
     *  Constant: '<S2170>/Calib'
     *  Inport: '<Root>/VeRCVR_p_eACSuctionPressure'
     */
    if (KeTHMR_b_SuctnPress_SD)
    {
        /* Switch: '<S2161>/Switch' incorporates:
         *  Constant: '<S2171>/Calib'
         */
        VeTHMR_p_eACSuctnPress = KeTHMR_p_SuctnPress_D;
    }
    else
    {
        (void)Rte_Read_VeRCVR_p_eACSuctionPressure_Value(&tmpRead_1q);

        /* Switch: '<S2161>/Switch' incorporates:
         *  Constant: '<S2169>/Calib'
         *  Inport: '<Root>/VeRCVR_p_eACSuctionPressure'
         *  Product: '<S2161>/Product1'
         */
        VeTHMR_p_eACSuctnPress = tmpRead_1q * KeTHMR_Cf_SuctionPressCnvrsFctr;
    }

    /* End of Switch: '<S2161>/Switch' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeHTDR_P_MtrCElecPwrCalcTot' */
    (void)Rte_Read_VeHTDR_P_MtrCElecPwrCalcTot_Value(&tmpRead_1t);

    /* Inport: '<Root>/VeHTDR_M_MtrC_TorqCmnd' */
    (void)Rte_Read_VeHTDR_M_MtrC_TorqCmnd_Value(&tmpRead_1s);

    /* Inport: '<Root>/VeMSPR_n_MtrC_Spd' */
    (void)Rte_Read_VeMSPR_n_MtrC_Spd_Value(&tmpRead_1r);

    /* Inport: '<Root>/VeTRIR_e_HVACECOModeSts' */
    (void)Rte_Read_VeTRIR_e_HVACECOModeSts_Value(&tmpRead_1p);

    /* Inport: '<Root>/VeOBCR_e_PwrLevSet' */
    (void)Rte_Read_VeOBCR_e_PwrLevSet_Value(&tmpRead_1o);

    /* Inport: '<Root>/VeOBCR_I_ChrgCrntReqDelta' */
    (void)Rte_Read_VeOBCR_I_ChrgCrntReqDelta_Value(&tmpRead_1n);

    /* Inport: '<Root>/VePLTR_e_ShippingMode' */
    (void)Rte_Read_VePLTR_e_ShippingMode_Value(&tmpRead_1k);

    /* Inport: '<Root>/VePLTR_b_REMDisabled' */
    (void)Rte_Read_VePLTR_b_REMDisabled_Value(&rtb_AND_g2);

    /* Inport: '<Root>/VeTMIR_b_ECMDrvDoorAjar' */
    (void)Rte_Read_VeTMIR_b_ECMDrvDoorAjar_Value(&tmpRead_1j);

    /* Inport: '<Root>/VeDMDR_e_TurtleMdSts' */
    (void)Rte_Read_VeDMDR_e_TurtleMdSts_Value(&tmpRead_1h);

    /* Inport: '<Root>/VeDFIR_b_Flashing_InProgress' */
    (void)Rte_Read_VeDFIR_b_Flashing_InProgress_Value(&tmpRead_1g);

    /* Inport: '<Root>/VeSRAR_b_ThmlLoadShdActv' */
    (void)Rte_Read_VeSRAR_b_ThmlLoadShdActv_Value(&rtb_OR1_he);

    /* Inport: '<Root>/VeHPMR_e_HybSysSt' */
    (void)Rte_Read_VeHPMR_e_HybSysSt_Value(&tmpRead_19);

    /* Inport: '<Root>/VePMPR_b_HTAuxPump_Flt_Dtctd' */
    (void)Rte_Read_VePMPR_b_HTAuxPump_Flt_Dtctd_Value(&rtb_Logical3_at);

    /* Inport: '<Root>/VePMPR_b_LTActPump_Flt_Dtctd' */
    (void)Rte_Read_VePMPR_b_LTActPump_Flt_Dtctd_Value(&rtb_Logical4_of);

    /* Inport: '<Root>/VePMPR_b_LTPsvPump2_Flt_Dtctd' */
    (void)Rte_Read_VePMPR_b_LTPsvPump2_Flt_Dtctd_Value(&rtb_Logical12_fs);

    /* Inport: '<Root>/VePMPR_b_LTPsvPump_Flt_Dtctd' */
    (void)Rte_Read_VePMPR_b_LTPsvPump_Flt_Dtctd_Value(&rtb_Logical12_hd);

    /* Inport: '<S81>/In1' incorporates:
     *  Inport: '<Root>/VeFSCR_b_RadFan_FltDtct'
     */
    (void)Rte_Read_VeFSCR_b_RadFan_FltDtct_Value(&In1);

    /* Inport: '<Root>/VePMIR_b_LTPsvPump2Temp_FA' */
    (void)Rte_Read_VePMIR_b_LTPsvPump2Temp_FA_Value(&rtb_Logical12_gu);

    /* Inport: '<Root>/VePMIR_n_LTPsvPump2RPMAct' */
    (void)Rte_Read_VePMIR_n_LTPsvPump2RPMAct_Value(&tmpRead_14);

    /* Inport: '<Root>/VeINVR_b_MtrA_CtrlBoard_Temp_FA' */
    (void)Rte_Read_VeINVR_b_MtrA_CtrlBoard_Temp_FA_Value(&rtb_Logical12_c2);

    /* Inport: '<Root>/VeINVR_T_MtrA_CtrlBoard_Temp' */
    (void)Rte_Read_VeINVR_T_MtrA_CtrlBoard_Temp_Value(&tmpRead_x);

    /* Inport: '<Root>/VeINVR_b_MtrA_RotrTemp_FA' */
    (void)Rte_Read_VeINVR_b_MtrA_RotrTemp_FA_Value(&rtb_Logical12_gap);

    /* Inport: '<Root>/VeINVR_T_MtrA_RotrTemp' */
    (void)Rte_Read_VeINVR_T_MtrA_RotrTemp_Value(&tmpRead_w);

    /* Inport: '<Root>/VePMIR_b_LTPsvPumpTemp_FA' */
    (void)Rte_Read_VePMIR_b_LTPsvPumpTemp_FA_Value(&rtb_Logical12_cpl);

    /* Inport: '<Root>/VeCPDR_b_HTAP_FunPer_FltDtct' */
    (void)Rte_Read_VeCPDR_b_HTAP_FunPer_FltDtct_Value(&rtb_Logical17_o);

    /* Inport: '<Root>/VeTAIR_b_HT_CabVlvSts_FA' */
    (void)Rte_Read_VeTAIR_b_HT_CabVlvSts_FA_Value(&rtb_Logical12_pb);

    /* Inport: '<Root>/VeBRKR_e_AHH_Ready_Status' */
    (void)Rte_Read_VeBRKR_e_AHH_Ready_Status_Value(&tmpRead_v);

    /* Inport: '<Root>/VeHTDR_r_AHH_StressFactor' */
    (void)Rte_Read_VeHTDR_r_AHH_StressFactor_Value(&tmpRead_u);

    /* Inport: '<Root>/VeHTDR_P_MtrBElecPwrCalcTot' */
    (void)Rte_Read_VeHTDR_P_MtrBElecPwrCalcTot_Value(&tmpRead_t);

    /* Inport: '<Root>/VeHTDR_P_MtrAElecPwrCalcTot' */
    (void)Rte_Read_VeHTDR_P_MtrAElecPwrCalcTot_Value(&tmpRead_s);

    /* Inport: '<Root>/VeMTIR_M_MtrB_TorqAchieved' */
    (void)Rte_Read_VeMTIR_M_MtrB_TorqAchieved_Value(&tmpRead_r);

    /* Inport: '<Root>/VeHTDR_M_MtrB_TorqCmnd' */
    (void)Rte_Read_VeHTDR_M_MtrB_TorqCmnd_Value(&tmpRead_q);

    /* Inport: '<Root>/VeMTIR_M_MtrA_TorqAchieved' */
    (void)Rte_Read_VeMTIR_M_MtrA_TorqAchieved_Value(&tmpRead_p);

    /* Inport: '<Root>/VeHTDR_M_MtrA_TorqCmnd' */
    (void)Rte_Read_VeHTDR_M_MtrA_TorqCmnd_Value(&tmpRead_o);

    /* Inport: '<Root>/VeMSPR_n_MtrB_Spd' */
    (void)Rte_Read_VeMSPR_n_MtrB_Spd_Value(&tmpRead_n);

    /* Inport: '<Root>/VeMSPR_n_MtrA_Spd' */
    (void)Rte_Read_VeMSPR_n_MtrA_Spd_Value(&tmpRead_m);

    /* Inport: '<Root>/VeENGR_b_EngSysLowFuel' */
    (void)Rte_Read_VeENGR_b_EngSysLowFuel_Value(&rtb_Logical12_e5);

    /* Inport: '<Root>/VeIMPR_b_HighVoltageRapidShtdwnCmnd' */
    (void)Rte_Read_VeIMPR_b_HighVoltageRapidShtdwnCmnd_Value(&rtb_Logical12_dh);

    /* Inport: '<Root>/VeTAIR_b_ACCompReq' */
    (void)Rte_Read_VeTAIR_b_ACCompReq_Value(&rtb_Logical12_er);

    /* Inport: '<Root>/VeACCR_b_OverTempImminent' */
    (void)Rte_Read_VeACCR_b_OverTempImminent_Value(&rtb_Logical12_gz);

    /* Inport: '<Root>/VeSSDR_e_KeySts' */
    (void)Rte_Read_VeSSDR_e_KeySts_Value(&tmpRead_l);

    /* Inport: '<Root>/VePLTR_b_DrvDrAjar' */
    (void)Rte_Read_VePLTR_b_DrvDrAjar_Value(&tmpRead_k);

    /* Inport: '<Root>/VeTRGR_e_TransDirctnSt' */
    (void)Rte_Read_VeTRGR_e_TransDirctnSt_Value(&tmpRead_j);

    /* Inport: '<Root>/VeBPCR_e_HV_BatCntctrStat' */
    (void)Rte_Read_VeBPCR_e_HV_BatCntctrStat_Value(&tmpRead_i);

    /* Inport: '<Root>/VeTISR_n_InputSpeed' */
    (void)Rte_Read_VeTISR_n_InputSpeed_Value(&tmpRead_h);

    /* Inport: '<Root>/VeESSR_e_EngStartStopSt' */
    (void)Rte_Read_VeESSR_e_EngStartStopSt_Value(&tmpRead_g);

    /* Inport: '<Root>/VeTAIR_Pct_RadFanSts' */
    (void)Rte_Read_VeTAIR_Pct_RadFanSts_Value(&tmpRead_f);

    /* Inport: '<Root>/VePMIR_b_HTAuxPumpDryRun_FA' */
    (void)Rte_Read_VePMIR_b_HTAuxPumpDryRun_FA_Value(&tmpRead_e);

    /* Inport: '<Root>/VePMIR_e_HTAuxPumpDryRun' */
    (void)Rte_Read_VePMIR_e_HTAuxPumpDryRun_Value(&tmpRead_d);

    /* Inport: '<Root>/VePMIR_n_LTPsvPump_RPMAct' */
    (void)Rte_Read_VePMIR_n_LTPsvPump_RPMAct_Value(&tmpRead_c);

    /* Inport: '<Root>/VeOBCR_e_ChargingLevel' */
    (void)Rte_Read_VeOBCR_e_ChargingLevel_Value(&tmpRead_b);

    /* Inport: '<Root>/VeOBCR_P_AvalPwrForThmr' */
    (void)Rte_Read_VeOBCR_P_AvalPwrForThmr_Value(&tmpRead_a);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Charging_inputsignals'
     */
    /* Switch: '<S545>/Switch' incorporates:
     *  Constant: '<S547>/Calib'
     */
    if (KeTHMR_b_AvalPwrForThmr_SelDial)
    {
        /* Switch: '<S545>/Switch' incorporates:
         *  Constant: '<S546>/Calib'
         */
        VeTHMR_P_AvalPwrForThmr = KeTHMR_P_AvalPwrForThmr_Dial;
    }
    else
    {
        /* Switch: '<S545>/Switch' */
        VeTHMR_P_AvalPwrForThmr = tmpRead_a;
    }

    /* End of Switch: '<S545>/Switch' */

    /* Switch: '<S49>/Switch' incorporates:
     *  Constant: '<S540>/Calib'
     */
    if (KeTHMR_b_ChargingLevel_SelDial)
    {
        /* Switch: '<S49>/Switch' incorporates:
         *  Constant: '<S543>/Calib'
         */
        VeTHMR_e_ChargingLevel_AD = KeTHMR_e_ChargingLevel_Dial;
    }
    else
    {
        /* Switch: '<S49>/Switch' incorporates:
         *  Inport: '<Root>/VeOBCR_e_ChargingLevel'
         */
        VeTHMR_e_ChargingLevel_AD = tmpRead_b;
    }

    /* End of Switch: '<S49>/Switch' */

    /* Switch: '<S49>/Switch1' incorporates:
     *  Constant: '<S541>/Calib'
     */
    if (KeTHMR_b_ChrgCrntReqDelta_SD)
    {
        /* Switch: '<S49>/Switch1' incorporates:
         *  Constant: '<S539>/Calib'
         */
        VeTHMR_I_ChrgCrntReqDelta_AD = KeTHMR_I_ChrgCrntReqDelta_D;
    }
    else
    {
        /* Switch: '<S49>/Switch1' */
        VeTHMR_I_ChrgCrntReqDelta_AD = tmpRead_1n;
    }

    /* End of Switch: '<S49>/Switch1' */

    /* Switch: '<S49>/Switch2' incorporates:
     *  Constant: '<S542>/Calib'
     */
    if (KeTHMR_b_PwrLevSet_SD)
    {
        /* Switch: '<S49>/Switch2' incorporates:
         *  Constant: '<S544>/Calib'
         */
        VeTHMR_e_PwrLevSet_AD = KeTHMR_e_PwrLevSet_D;
    }
    else
    {
        /* Switch: '<S49>/Switch2' incorporates:
         *  Inport: '<Root>/VeOBCR_e_PwrLevSet'
         */
        VeTHMR_e_PwrLevSet_AD = tmpRead_1o;
    }

    /* End of Switch: '<S49>/Switch2' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem1'
     */
    /* Switch: '<S3793>/Switch' incorporates:
     *  Constant: '<S3799>/Calib'
     */
    if (KeTHMR_b_LT_PsvPmpSts_SelDial)
    {
        /* Switch: '<S3793>/Switch' incorporates:
         *  Constant: '<S3800>/Calib'
         */
        VeTHMR_n_LTPsvPumpRPMAct_B4SET = KeTHMR_n_LT_PsvPmpSts_Dial;
    }
    else
    {
        /* Switch: '<S3793>/Switch' */
        VeTHMR_n_LTPsvPumpRPMAct_B4SET = tmpRead_c;
    }

    /* End of Switch: '<S3793>/Switch' */

    /* Switch: '<S3792>/Switch' incorporates:
     *  Constant: '<S3797>/Calib'
     */
    if (KeTHMR_b_HTAuxPumpDryRun_SD)
    {
        /* Switch: '<S3792>/Switch' incorporates:
         *  Constant: '<S3798>/Calib'
         */
        VeTHMR_e_HTAuxPumpDryRun_AD = KeTHMR_e_HTAuxPumpDryRun_D;
    }
    else
    {
        /* Switch: '<S3792>/Switch' incorporates:
         *  Inport: '<Root>/VePMIR_e_HTAuxPumpDryRun'
         */
        VeTHMR_e_HTAuxPumpDryRun_AD = tmpRead_d;
    }

    /* End of Switch: '<S3792>/Switch' */

    /* Switch: '<S3792>/Switch1' incorporates:
     *  Constant: '<S3796>/Calib'
     */
    if (KeTHMR_b_HTAuxPmpDryRunFA_SD)
    {
        /* Switch: '<S3792>/Switch1' incorporates:
         *  Constant: '<S3795>/Calib'
         */
        VeTHMR_b_HTAuxPmpDryRunFA_AD = KeTHMR_b_HTAuxPmpDryRunFA_D;
    }
    else
    {
        /* Switch: '<S3792>/Switch1' */
        VeTHMR_b_HTAuxPmpDryRunFA_AD = tmpRead_e;
    }

    /* End of Switch: '<S3792>/Switch1' */

    /* Switch: '<S3794>/Switch' incorporates:
     *  Constant: '<S3801>/Calib'
     */
    if (KeTHMR_b_LT_PsvPmp2Sts_SelDial)
    {
        /* Switch: '<S3794>/Switch' incorporates:
         *  Constant: '<S3802>/Calib'
         */
        VeTHMR_n_LTPsvPump2RPMAct_B4SET = KeTHMR_n_LT_PsvPmp2Sts_Dial;
    }
    else
    {
        /* Switch: '<S3794>/Switch' */
        VeTHMR_n_LTPsvPump2RPMAct_B4SET = tmpRead_14;
    }

    /* End of Switch: '<S3794>/Switch' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem5'
     */
    /* Switch: '<S4016>/Switch' incorporates:
     *  Constant: '<S4019>/Calib'
     */
    if (KeTHMR_b_RadFanSts_SelDial)
    {
        /* Switch: '<S4016>/Switch' incorporates:
         *  Constant: '<S4018>/Calib'
         */
        VeTHMR_Pct_RadFanSts_AftDial = KeTHMR_Pct_RadFanSts_Dial;
    }
    else
    {
        /* Switch: '<S4016>/Switch' */
        VeTHMR_Pct_RadFanSts_AftDial = tmpRead_f;
    }

    /* End of Switch: '<S4016>/Switch' */

    /* Switch: '<S4017>/Switch' incorporates:
     *  Constant: '<S4021>/Calib'
     */
    if (KeTHMR_b_Flashing_Flag_SD)
    {
        /* Switch: '<S4017>/Switch' incorporates:
         *  Constant: '<S4020>/Calib'
         */
        VeTHMR_b_Flashing_Flag_AD = KeTHMR_b_Flashing_Flag_D;
    }
    else
    {
        /* Switch: '<S4017>/Switch' */
        VeTHMR_b_Flashing_Flag_AD = tmpRead_1g;
    }

    /* End of Switch: '<S4017>/Switch' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem3'
     */
    /* Switch: '<S3948>/Switch' incorporates:
     *  Constant: '<S3972>/Calib'
     */
    if (KeTHMR_b_EngStartStopSt_SelDial)
    {
        /* Switch: '<S3948>/Switch' incorporates:
         *  Constant: '<S3973>/Calib'
         */
        VeTHMR_e_EngStartStopSt_AD = KeTHMR_e_EngStartStopSt_Dial;
    }
    else
    {
        /* Switch: '<S3948>/Switch' incorporates:
         *  Inport: '<Root>/VeESSR_e_EngStartStopSt'
         */
        VeTHMR_e_EngStartStopSt_AD = tmpRead_g;
    }

    /* End of Switch: '<S3948>/Switch' */

    /* Switch: '<S3951>/Switch' incorporates:
     *  Constant: '<S3978>/Calib'
     */
    if (KeTHMR_b_EngSpd_SelDial)
    {
        /* Switch: '<S3951>/Switch' incorporates:
         *  Constant: '<S3979>/Calib'
         */
        VeTHMR_n_InputSpeed = KeTHMR_n_EngSpd_Dial;
    }
    else
    {
        /* Switch: '<S3951>/Switch' */
        VeTHMR_n_InputSpeed = tmpRead_h;
    }

    /* End of Switch: '<S3951>/Switch' */

    /* Switch: '<S3956>/Switch' incorporates:
     *  Constant: '<S3988>/Calib'
     */
    if (KeTHMR_b_BatCntctrStat_SelDial)
    {
        /* Switch: '<S3956>/Switch' incorporates:
         *  Constant: '<S3989>/Calib'
         */
        VeTHMR_e_BatCntctrStat = KeTHMR_e_BatCntctrStat_Dial;
    }
    else
    {
        /* Switch: '<S3956>/Switch' incorporates:
         *  Inport: '<Root>/VeBPCR_e_HV_BatCntctrStat'
         */
        VeTHMR_e_BatCntctrStat = tmpRead_i;
    }

    /* End of Switch: '<S3956>/Switch' */

    /* Switch: '<S3957>/Switch' incorporates:
     *  Constant: '<S3990>/Calib'
     */
    if (KeTHMR_b_TransDirctnSt_SelDial)
    {
        /* Switch: '<S3957>/Switch' incorporates:
         *  Constant: '<S3991>/Calib'
         */
        VeTHMR_e_TransDirctnSt = KeTHMR_e_TransDirctnSt_Dial;
    }
    else
    {
        /* Switch: '<S3957>/Switch' incorporates:
         *  Inport: '<Root>/VeTRGR_e_TransDirctnSt'
         */
        VeTHMR_e_TransDirctnSt = tmpRead_j;
    }

    /* End of Switch: '<S3957>/Switch' */

    /* Switch: '<S3944>/Switch' incorporates:
     *  Constant: '<S3964>/Calib'
     */
    if (KeTHMR_b_VehicleSpd_SelDial)
    {
        /* Switch: '<S3944>/Switch' incorporates:
         *  Constant: '<S3965>/Calib'
         */
        VeTHMR_v_Vehicle = KeTHMR_v_VehicleSpd_Dial;
    }
    else
    {
        /* Switch: '<S3944>/Switch' */
        VeTHMR_v_Vehicle = rtb_TmpSignalConversionAtVeCSVR;
    }

    /* End of Switch: '<S3944>/Switch' */

    /* Switch: '<S3943>/Switch' incorporates:
     *  Constant: '<S3963>/Calib'
     */
    if (KeTHMR_b_DrvDrAjar_SelDial)
    {
        /* Switch: '<S3943>/Switch' incorporates:
         *  Constant: '<S3962>/Calib'
         */
        VeTHMR_b_DrvDrAjar_AD = KeTHMR_b_DrvDrAjar_Dial;
    }
    else
    {
        /* Switch: '<S3943>/Switch' */
        VeTHMR_b_DrvDrAjar_AD = tmpRead_k;
    }

    /* End of Switch: '<S3943>/Switch' */

    /* Switch: '<S79>/Switch' incorporates:
     *  Constant: '<S3940>/Calib'
     */
    if (KeTHMR_b_SelCBCDoorAjar)
    {
        /* Switch: '<S79>/Switch' */
        VeTHMR_b_DrvDrAjar = VeTHMR_b_DrvDrAjar_AD;
    }
    else
    {
        /* Switch: '<S79>/Switch' */
        VeTHMR_b_DrvDrAjar = tmpRead_1j;
    }

    /* End of Switch: '<S79>/Switch' */

    /* Switch: '<S3945>/Switch' incorporates:
     *  Constant: '<S3966>/Calib'
     */
    if (KeTHMR_b_SSDR_KeySts_SD)
    {
        /* Switch: '<S3945>/Switch' incorporates:
         *  Constant: '<S3967>/Calib'
         */
        VeTHMR_e_SSDR_KeySts = KeTHMR_e_SSDR_KeySts_Dial;
    }
    else
    {
        /* Switch: '<S3945>/Switch' incorporates:
         *  Inport: '<Root>/VeSSDR_e_KeySts'
         */
        VeTHMR_e_SSDR_KeySts = tmpRead_l;
    }

    /* End of Switch: '<S3945>/Switch' */

    /* Switch: '<S3946>/Switch' incorporates:
     *  Constant: '<S3969>/Calib'
     */
    if (KeTHMR_b_OverTempImminent_SelDial)
    {
        /* Switch: '<S3946>/Switch' incorporates:
         *  Constant: '<S3968>/Calib'
         */
        VeTHMR_b_OverTempImminent = KeTHMR_b_OverTempImminent_Dial;
    }
    else
    {
        /* Switch: '<S3946>/Switch' */
        VeTHMR_b_OverTempImminent = rtb_Logical12_gz;
    }

    /* End of Switch: '<S3946>/Switch' */

    /* Switch: '<S3947>/Switch' incorporates:
     *  Constant: '<S3971>/Calib'
     */
    if (KeTHMR_b_AC_CompReq_SelDial)
    {
        /* Switch: '<S3947>/Switch' incorporates:
         *  Constant: '<S3970>/Calib'
         */
        VeTHMR_b_AC_CompReq = KeTHMR_b_AC_CompReq_Dial;
    }
    else
    {
        /* Switch: '<S3947>/Switch' */
        VeTHMR_b_AC_CompReq = rtb_Logical12_er;
    }

    /* End of Switch: '<S3947>/Switch' */

    /* Switch: '<S3941>/Switch' incorporates:
     *  Constant: '<S3959>/Calib'
     */
    if (KeTHMR_b_HighVoltageRapidShtdwnCmnd_Sel)
    {
        /* Switch: '<S3941>/Switch' incorporates:
         *  Constant: '<S3958>/Calib'
         */
        VeTHMR_b_HighVoltageRapidShtdwnCmnd_AD =
            KeTHMR_b_HighVoltageRapidShtdwnCmnd_Dial;
    }
    else
    {
        /* Switch: '<S3941>/Switch' */
        VeTHMR_b_HighVoltageRapidShtdwnCmnd_AD = rtb_Logical12_dh;
    }

    /* End of Switch: '<S3941>/Switch' */

    /* Switch: '<S3949>/Switch' incorporates:
     *  Constant: '<S3975>/Calib'
     */
    if (KeTHMR_b_EngSysLowFuel_Sel)
    {
        /* Switch: '<S3949>/Switch' incorporates:
         *  Constant: '<S3974>/Calib'
         */
        VeTHMR_b_EngSysLowFuel_AD = KeTHMR_b_EngSysLowFuel_Dial;
    }
    else
    {
        /* Switch: '<S3949>/Switch' */
        VeTHMR_b_EngSysLowFuel_AD = rtb_Logical12_e5;
    }

    /* End of Switch: '<S3949>/Switch' */

    /* Switch: '<S3954>/Switch' incorporates:
     *  Constant: '<S3984>/Calib'
     */
    if (KeTHMR_b_HybSysSt_SelDial)
    {
        /* Switch: '<S3954>/Switch' incorporates:
         *  Constant: '<S3985>/Calib'
         */
        VeTHMR_e_HybSysSt = KeTHMR_e_HybSysSt_Dial;
    }
    else
    {
        /* Switch: '<S3954>/Switch' incorporates:
         *  Inport: '<Root>/VeHPMR_e_HybSysSt'
         */
        VeTHMR_e_HybSysSt = tmpRead_19;
    }

    /* End of Switch: '<S3954>/Switch' */

    /* Switch: '<S3955>/Switch' incorporates:
     *  Constant: '<S3987>/Calib'
     */
    if (KeTHMR_b_ThrmLoad_Shed_SelDial)
    {
        /* Switch: '<S3955>/Switch' incorporates:
         *  Constant: '<S3986>/Calib'
         */
        VeTHMR_b_ThrmLoad_Shed = KeTHMR_b_ThrmLoad_Shed_Dial;
    }
    else
    {
        /* Switch: '<S3955>/Switch' */
        VeTHMR_b_ThrmLoad_Shed = rtb_OR1_he;
    }

    /* End of Switch: '<S3955>/Switch' */

    /* Switch: '<S3952>/Switch' incorporates:
     *  Constant: '<S3980>/Calib'
     */
    if (Rte_Prm_KeTHMR_b_TurtleMd_SelDial_KeTHMR_b_TurtleMd_SelDial())
    {
        /* Switch: '<S3952>/Switch' incorporates:
         *  Constant: '<S3981>/Calib'
         */
        VeTHMR_b_TurtleMd =
            Rte_Prm_KeTHMR_e_TurtleMd_Dial_KeTHMR_e_TurtleMd_Dial();
    }
    else
    {
        /* Switch: '<S3952>/Switch' incorporates:
         *  Inport: '<Root>/VeDMDR_e_TurtleMdSts'
         */
        VeTHMR_b_TurtleMd = tmpRead_1h;
    }

    /* End of Switch: '<S3952>/Switch' */

    /* Switch: '<S3950>/Switch' incorporates:
     *  Constant: '<S3977>/Calib'
     */
    if (KeTHMR_b_REMDisabled_SD)
    {
        /* Switch: '<S3950>/Switch' incorporates:
         *  Constant: '<S3976>/Calib'
         */
        VeTHMR_b_REMDisabled = KeTHMR_b_REMDisabled_D;
    }
    else
    {
        /* Switch: '<S3950>/Switch' */
        VeTHMR_b_REMDisabled = rtb_AND_g2;
    }

    /* End of Switch: '<S3950>/Switch' */

    /* Switch: '<S3953>/Switch' incorporates:
     *  Constant: '<S3982>/Calib'
     */
    if (KeTHMR_b_ShippingMode_SD)
    {
        /* Switch: '<S3953>/Switch' incorporates:
         *  Constant: '<S3983>/Calib'
         */
        VeTHMR_e_ShippingMode = KeTHMR_e_ShippingMode_D;
    }
    else
    {
        /* Switch: '<S3953>/Switch' incorporates:
         *  Inport: '<Root>/VePLTR_e_ShippingMode'
         */
        VeTHMR_e_ShippingMode = tmpRead_1k;
    }

    /* End of Switch: '<S3953>/Switch' */

    /* Switch: '<S3942>/Switch1' incorporates:
     *  Constant: '<S3960>/Calib'
     */
    if (KeTHMR_b_HVACECOModeSts_SD)
    {
        /* Switch: '<S3942>/Switch1' incorporates:
         *  Constant: '<S3961>/Calib'
         */
        VeTHMR_e_HVACECOModeSts = KeTHMR_e_HVACECOModeSts_D;
    }
    else
    {
        /* Switch: '<S3942>/Switch1' incorporates:
         *  Inport: '<Root>/VeTRIR_e_HVACECOModeSts'
         */
        VeTHMR_e_HVACECOModeSts = tmpRead_1p;
    }

    /* End of Switch: '<S3942>/Switch1' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem'
     */
    /* Switch: '<S3742>/Switch' incorporates:
     *  Constant: '<S3746>/Calib'
     */
    if (KeTHMR_b_MtrA_Spd_SelDial)
    {
        /* Switch: '<S3742>/Switch' incorporates:
         *  Constant: '<S3747>/Calib'
         */
        VeTHMR_n_MtrA_Spd = KeTHMR_n_MtrA_SpdDial;
    }
    else
    {
        /* Switch: '<S3742>/Switch' */
        VeTHMR_n_MtrA_Spd = tmpRead_m;
    }

    /* End of Switch: '<S3742>/Switch' */

    /* Switch: '<S3743>/Switch' incorporates:
     *  Constant: '<S3748>/Calib'
     */
    if (KeTHMR_b_MtrB_Spd_SelDial)
    {
        /* Switch: '<S3743>/Switch' incorporates:
         *  Constant: '<S3749>/Calib'
         */
        VeTHMR_n_MtrB_Spd = KeTHMR_n_MtrB_SpdDial;
    }
    else
    {
        /* Switch: '<S3743>/Switch' */
        VeTHMR_n_MtrB_Spd = tmpRead_n;
    }

    /* End of Switch: '<S3743>/Switch' */

    /* Switch: '<S3741>/Switch' incorporates:
     *  Constant: '<S3744>/Calib'
     */
    if (KeTHMR_b_MtrC_Spd_SelDial)
    {
        /* Switch: '<S3741>/Switch' incorporates:
         *  Constant: '<S3745>/Calib'
         */
        VeTHMR_n_MtrC_Spd = KeTHMR_n_MtrC_SpdDial;
    }
    else
    {
        /* Switch: '<S3741>/Switch' */
        VeTHMR_n_MtrC_Spd = tmpRead_1r;
    }

    /* End of Switch: '<S3741>/Switch' */

    /* Switch: '<S3754>/Switch' incorporates:
     *  Constant: '<S3759>/Calib'
     */
    if (KeTHMR_b_MtrA_TorqCmnd_SelDial)
    {
        /* Switch: '<S3754>/Switch' incorporates:
         *  Constant: '<S3758>/Calib'
         */
        VeTHMR_M_MtrA_TorqCmnd = KeTHMR_M_MtrA_TorqCmndDial;
    }
    else
    {
        /* Switch: '<S3754>/Switch' */
        VeTHMR_M_MtrA_TorqCmnd = tmpRead_o;
    }

    /* End of Switch: '<S3754>/Switch' */

    /* Switch: '<S3755>/Switch' incorporates:
     *  Constant: '<S3757>/Calib'
     */
    if (KeTHMR_b_MtrA_TorqAchieved_SelDial)
    {
        /* Switch: '<S3755>/Switch' incorporates:
         *  Constant: '<S3756>/Calib'
         */
        VeTHMR_M_MtrA_TorqAchieved = KeTHMR_M_MtrA_TorqAchievedDial;
    }
    else
    {
        /* Switch: '<S3755>/Switch' */
        VeTHMR_M_MtrA_TorqAchieved = tmpRead_p;
    }

    /* End of Switch: '<S3755>/Switch' */

    /* Switch: '<S3761>/Switch' incorporates:
     *  Constant: '<S3766>/Calib'
     */
    if (KeTHMR_b_MtrB_TorqCmnd_SelDial)
    {
        /* Switch: '<S3761>/Switch' incorporates:
         *  Constant: '<S3765>/Calib'
         */
        VeTHMR_M_MtrB_TorqCmnd = KeTHMR_M_MtrB_TorqCmndDial;
    }
    else
    {
        /* Switch: '<S3761>/Switch' */
        VeTHMR_M_MtrB_TorqCmnd = tmpRead_q;
    }

    /* End of Switch: '<S3761>/Switch' */

    /* Switch: '<S3762>/Switch' incorporates:
     *  Constant: '<S3764>/Calib'
     */
    if (KeTHMR_b_MtrB_TorqAchieved_SelDial)
    {
        /* Switch: '<S3762>/Switch' incorporates:
         *  Constant: '<S3763>/Calib'
         */
        VeTHMR_M_MtrB_TorqAchieved = KeTHMR_M_MtrB_TorqAchievedDial;
    }
    else
    {
        /* Switch: '<S3762>/Switch' */
        VeTHMR_M_MtrB_TorqAchieved = tmpRead_r;
    }

    /* End of Switch: '<S3762>/Switch' */

    /* Switch: '<S3768>/Switch' incorporates:
     *  Constant: '<S3773>/Calib'
     */
    if (KeTHMR_b_MtrC_TorqCmnd_SelDial)
    {
        /* Switch: '<S3768>/Switch' incorporates:
         *  Constant: '<S3772>/Calib'
         */
        VeTHMR_M_MtrC_TorqCmnd = KeTHMR_M_MtrC_TorqCmndDial;
    }
    else
    {
        /* Switch: '<S3768>/Switch' */
        VeTHMR_M_MtrC_TorqCmnd = tmpRead_1s;
    }

    /* End of Switch: '<S3768>/Switch' */

    /* Switch: '<S3769>/Switch' incorporates:
     *  Constant: '<S3771>/Calib'
     */
    if (KeTHMR_b_MtrC_TorqAchieved_SelDial)
    {
        /* Switch: '<S3769>/Switch' incorporates:
         *  Constant: '<S3770>/Calib'
         */
        VeTHMR_M_MtrC_TorqAchieved = KeTHMR_M_MtrC_TorqAchievedDial;
    }
    else
    {
        /* Switch: '<S3769>/Switch' */
        VeTHMR_M_MtrC_TorqAchieved = rtb_TmpSignalConversionAtVeTHMR;
    }

    /* End of Switch: '<S3769>/Switch' */

    /* Switch: '<S3777>/Switch' incorporates:
     *  Constant: '<S3779>/Calib'
     */
    if (KeTHMR_b_MtrA_ElecPwrCalc_Tot_SelDial)
    {
        /* Switch: '<S3777>/Switch' incorporates:
         *  Constant: '<S3778>/Calib'
         */
        VeTHMR_P_MtrAElecPwrCalcTot = KeTHMR_P_MtrA_ElecPwrCalc_TotDial;
    }
    else
    {
        /* Switch: '<S3777>/Switch' */
        VeTHMR_P_MtrAElecPwrCalcTot = tmpRead_s;
    }

    /* End of Switch: '<S3777>/Switch' */

    /* Switch: '<S3782>/Switch' incorporates:
     *  Constant: '<S3788>/Calib'
     */
    if (KeTHMR_b_MtrB_ElecPwrCalc_Tot_SelDial)
    {
        /* Switch: '<S3782>/Switch' incorporates:
         *  Constant: '<S3787>/Calib'
         */
        VeTHMR_P_MtrBElecPwrCalcTot = KeTHMR_P_MtrB_ElecPwrCalc_TotDial;
    }
    else
    {
        /* Switch: '<S3782>/Switch' */
        VeTHMR_P_MtrBElecPwrCalcTot = tmpRead_t;
    }

    /* End of Switch: '<S3782>/Switch' */

    /* Switch: '<S3781>/Switch' incorporates:
     *  Constant: '<S3785>/Calib'
     */
    if (KeTHMR_b_AHH_StressFactor_SD)
    {
        /* Switch: '<S3781>/Switch' incorporates:
         *  Constant: '<S3786>/Calib'
         */
        VeTHMR_r_AHH_StressFactor = KeTHMR_r_AHH_StressFactor_D;
    }
    else
    {
        /* Switch: '<S3781>/Switch' */
        VeTHMR_r_AHH_StressFactor = tmpRead_u;
    }

    /* End of Switch: '<S3781>/Switch' */

    /* Switch: '<S3780>/Switch' incorporates:
     *  Constant: '<S3783>/Calib'
     */
    if (KeTHMR_b_AHH_ReadyStatus_SD)
    {
        /* Switch: '<S3780>/Switch' incorporates:
         *  Constant: '<S3784>/Calib'
         */
        VeTHMR_e_AHH_Ready_Status_AD = KeTHMR_e_AHH_Ready_Status_D;
    }
    else
    {
        /* Switch: '<S3780>/Switch' incorporates:
         *  Inport: '<Root>/VeBRKR_e_AHH_Ready_Status'
         */
        VeTHMR_e_AHH_Ready_Status_AD = tmpRead_v;
    }

    /* End of Switch: '<S3780>/Switch' */

    /* Switch: '<S3789>/Switch' incorporates:
     *  Constant: '<S3791>/Calib'
     */
    if (KeTHMR_b_MtrC_ElecPwrCalc_Tot_SelDial)
    {
        /* Switch: '<S3789>/Switch' incorporates:
         *  Constant: '<S3790>/Calib'
         */
        VeTHMR_P_MtrCElecPwrCalcTot = KeTHMR_P_MtrC_ElecPwrCalc_TotDial;
    }
    else
    {
        /* Switch: '<S3789>/Switch' */
        VeTHMR_P_MtrCElecPwrCalcTot = tmpRead_1t;
    }

    /* End of Switch: '<S3789>/Switch' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem4'
     */
    /* Switch: '<S3999>/Switch' incorporates:
     *  Constant: '<S4015>/Calib'
     */
    if (KeTHMR_b_HT_CabVlvSts_FA_SD)
    {
        /* Switch: '<S3999>/Switch' incorporates:
         *  Constant: '<S4014>/Calib'
         */
        VeTHMR_b_HT_CabVlvSts_FA_AD = KeTHMR_b_HT_CabVlvSts_FA_Dial;
    }
    else
    {
        /* Switch: '<S3999>/Switch' */
        VeTHMR_b_HT_CabVlvSts_FA_AD = rtb_Logical12_pb;
    }

    /* End of Switch: '<S3999>/Switch' */

    /* Switch: '<S3996>/Switch' incorporates:
     *  Constant: '<S4008>/Calib'
     */
    if (KeTHMR_b_HTAPFunPer_FltDtct_D)
    {
        /* Switch: '<S3996>/Switch' incorporates:
         *  Constant: '<S4009>/Calib'
         */
        VeTHMR_b_HTAPFunPer_FltDtct_AD = KeTHMR_b_HTAPFunPer_FltDtct_SD;
    }
    else
    {
        /* Switch: '<S3996>/Switch' */
        VeTHMR_b_HTAPFunPer_FltDtct_AD = rtb_Logical17_o;
    }

    /* End of Switch: '<S3996>/Switch' */

    /* Switch: '<S3997>/Switch' incorporates:
     *  Constant: '<S4011>/Calib'
     */
    if (KeTHMR_b_LTPsvPumpTemp_FA_SD)
    {
        /* Switch: '<S3997>/Switch' incorporates:
         *  Constant: '<S4010>/Calib'
         */
        VeTHMR_b_LTPsvPumpTemp_FA_AD = KeTHMR_b_LTPsvPumpTemp_FA_D;
    }
    else
    {
        /* Switch: '<S3997>/Switch' */
        VeTHMR_b_LTPsvPumpTemp_FA_AD = rtb_Logical12_cpl;
    }

    /* End of Switch: '<S3997>/Switch' */

    /* Switch: '<S3998>/Switch' incorporates:
     *  Constant: '<S4013>/Calib'
     */
    if (KeTHMR_b_LTPsvPump2Temp_FA_SD)
    {
        /* Switch: '<S3998>/Switch' incorporates:
         *  Constant: '<S4012>/Calib'
         */
        VeTHMR_b_LTPsvPump2Temp_FA_AD = KeTHMR_b_LTPsvPump2Temp_FA_D;
    }
    else
    {
        /* Switch: '<S3998>/Switch' */
        VeTHMR_b_LTPsvPump2Temp_FA_AD = rtb_Logical12_gu;
    }

    /* End of Switch: '<S3998>/Switch' */

    /* Switch: '<S3992>/Switch' incorporates:
     *  Constant: '<S4001>/Calib'
     */
    if (KeTHMR_b_LTPsvPump_FltDtctd_SD)
    {
        /* Switch: '<S3992>/Switch' incorporates:
         *  Constant: '<S4000>/Calib'
         */
        VeTHMR_b_LTPsvPump_FltDtctd_AD = KeTHMR_b_LTPsvPump_FltDtctd_D;
    }
    else
    {
        /* Switch: '<S3992>/Switch' */
        VeTHMR_b_LTPsvPump_FltDtctd_AD = rtb_Logical12_hd;
    }

    /* End of Switch: '<S3992>/Switch' */

    /* Switch: '<S3993>/Switch' incorporates:
     *  Constant: '<S4003>/Calib'
     */
    if (KeTHMR_b_LTPsvPump2_FltDtctd_SD)
    {
        /* Switch: '<S3993>/Switch' incorporates:
         *  Constant: '<S4002>/Calib'
         */
        VeTHMR_b_LTPsvPump2_FltDtctd_AD = KeTHMR_b_LTPsvPump2_FltDtctd_D;
    }
    else
    {
        /* Switch: '<S3993>/Switch' */
        VeTHMR_b_LTPsvPump2_FltDtctd_AD = rtb_Logical12_fs;
    }

    /* End of Switch: '<S3993>/Switch' */

    /* Switch: '<S3994>/Switch' incorporates:
     *  Constant: '<S4005>/Calib'
     */
    if (KeTHMR_b_LTActPump_FltDtctd_SD)
    {
        /* Switch: '<S3994>/Switch' incorporates:
         *  Constant: '<S4004>/Calib'
         */
        VeTHMR_b_LTActPump_FltDtctd_AD = KeTHMR_b_LTActPump_FltDtctd_D;
    }
    else
    {
        /* Switch: '<S3994>/Switch' */
        VeTHMR_b_LTActPump_FltDtctd_AD = rtb_Logical4_of;
    }

    /* End of Switch: '<S3994>/Switch' */

    /* Switch: '<S3995>/Switch' incorporates:
     *  Constant: '<S4007>/Calib'
     */
    if (KeTHMR_b_HTAuxPump_FltDtctd_SD)
    {
        /* Switch: '<S3995>/Switch' incorporates:
         *  Constant: '<S4006>/Calib'
         */
        VeTHMR_b_HTAuxPump_FltDtctd_AD = KeTHMR_b_HTAuxPump_FltDtctd_D;
    }
    else
    {
        /* Switch: '<S3995>/Switch' */
        VeTHMR_b_HTAuxPump_FltDtctd_AD = rtb_Logical3_at;
    }

    /* End of Switch: '<S3995>/Switch' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/BSG_Overwrite'
     */
    /* Switch: '<S117>/Switch1' incorporates:
     *  Constant: '<S125>/Calib'
     */
    if (KeTHMR_b_BSG_Rotor_Temp_SD)
    {
        /* Switch: '<S117>/Switch1' incorporates:
         *  Constant: '<S122>/Calib'
         */
        VeTHMR_T_BSG_MtrRotorTemp = KeTHMR_T_BSG_Rotor_Temp_D;
    }
    else
    {
        /* Switch: '<S117>/Switch1' */
        VeTHMR_T_BSG_MtrRotorTemp = tmpRead_w;
    }

    /* End of Switch: '<S117>/Switch1' */

    /* Switch: '<S117>/Switch2' incorporates:
     *  Constant: '<S124>/Calib'
     */
    if (KeTHMR_b_BSG_Rotor_Temp_FA_SD)
    {
        /* Switch: '<S117>/Switch2' incorporates:
         *  Constant: '<S123>/Calib'
         */
        VeTHMR_b_BSG_MtrRotorTemp_FA = KeTHMR_b_BSG_Rotor_Temp_FA_D;
    }
    else
    {
        /* Switch: '<S117>/Switch2' */
        VeTHMR_b_BSG_MtrRotorTemp_FA = rtb_Logical12_gap;
    }

    /* End of Switch: '<S117>/Switch2' */

    /* Switch: '<S118>/Switch1' incorporates:
     *  Constant: '<S130>/Calib'
     */
    if (KeTHMR_b_BSG_CntrlBoardTemp_SD)
    {
        /* Switch: '<S118>/Switch1' incorporates:
         *  Constant: '<S127>/Calib'
         */
        VeTHMR_T_BSG_CntrlBoardTemp = KeTHMR_T_BSG_CntrlBoardTemp_D;
    }
    else
    {
        /* Switch: '<S118>/Switch1' */
        VeTHMR_T_BSG_CntrlBoardTemp = tmpRead_x;
    }

    /* End of Switch: '<S118>/Switch1' */

    /* Switch: '<S118>/Switch2' incorporates:
     *  Constant: '<S129>/Calib'
     */
    if (KeTHMR_b_BSG_CntrlBoardTemp_FA_SD)
    {
        /* Switch: '<S118>/Switch2' incorporates:
         *  Constant: '<S128>/Calib'
         */
        VeTHMR_b_BSG_CntrlBoardTemp_FA = KeTHMR_b_BSG_CntrlBoardTemp_FA_D;
    }
    else
    {
        /* Switch: '<S118>/Switch2' */
        VeTHMR_b_BSG_CntrlBoardTemp_FA = rtb_Logical12_c2;
    }

    /* End of Switch: '<S118>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S126>/EdgeFalling' */
    /* Logic: '<S134>/AND' incorporates:
     *  Logic: '<S134>/OR1'
     *  UnitDelay: '<S134>/UnitDelay'
     */
    rtb_AND_g2 = ((!VeTHMR_b_BSG_CntrlBoardTemp_FA) &&
                  (THMR_ac_DW.UnitDelay_DSTATE_kit));

    /* Update for UnitDelay: '<S134>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kit = VeTHMR_b_BSG_CntrlBoardTemp_FA;

    /* End of Outputs for SubSystem: '<S126>/EdgeFalling' */

    /* Outputs for Atomic SubSystem: '<S126>/DigitalLowpassResetEnabled' */
    /* Switch: '<S131>/Switch1' */
    if (rtb_AND_g2)
    {
        /* Switch: '<S131>/Switch1' incorporates:
         *  Constant: '<S126>/ConstantValue2'
         */
        rtb_Switch1_oje = 0.0F;
    }
    else
    {
        /* Switch: '<S131>/Switch1' incorporates:
         *  Constant: '<S126>/ConstantValue1'
         *  Product: '<S131>/Multiplication'
         *  Sum: '<S131>/Subtraction'
         *  Sum: '<S131>/Summation'
         *  UnitDelay: '<S131>/UnitDelay'
         */
        rtb_Switch1_oje = ((VeTHMR_T_BSG_CntrlBoardTemp -
                            THMR_ac_DW.UnitDelay_DSTATE_k4) * 0.05F) +
            THMR_ac_DW.UnitDelay_DSTATE_k4;
    }

    /* End of Switch: '<S131>/Switch1' */

    /* Update for UnitDelay: '<S131>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_k4 = rtb_Switch1_oje;

    /* End of Outputs for SubSystem: '<S126>/DigitalLowpassResetEnabled' */

    /* Outputs for Atomic SubSystem: '<S126>/DigitalLowpassResetEnabled1' */
    /* Switch: '<S132>/Switch1' */
    if (rtb_AND_g2)
    {
        /* Switch: '<S132>/Switch1' incorporates:
         *  Constant: '<S126>/ConstantValue2'
         */
        rtb_Switch1_oje = 0.0F;
    }
    else
    {
        /* Switch: '<S132>/Switch1' incorporates:
         *  Constant: '<S126>/ConstantValue1'
         *  Product: '<S132>/Multiplication'
         *  Sum: '<S132>/Subtraction'
         *  Sum: '<S132>/Summation'
         *  UnitDelay: '<S132>/UnitDelay'
         */
        rtb_Switch1_oje = ((rtb_Switch1_oje - THMR_ac_DW.UnitDelay_DSTATE_by) *
                           0.05F) + THMR_ac_DW.UnitDelay_DSTATE_by;
    }

    /* End of Switch: '<S132>/Switch1' */

    /* Update for UnitDelay: '<S132>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_by = rtb_Switch1_oje;

    /* End of Outputs for SubSystem: '<S126>/DigitalLowpassResetEnabled1' */

    /* Outputs for Atomic SubSystem: '<S126>/DigitalLowpassResetEnabled2' */
    /* UnitDelay: '<S133>/UnitDelay' */
    rtb_UnitDelay_bv = THMR_ac_DW.UnitDelay_DSTATE_gc;

    /* Switch: '<S133>/Switch1' */
    if (rtb_AND_g2)
    {
        /* Switch: '<S133>/Switch1' incorporates:
         *  Constant: '<S126>/ConstantValue2'
         */
        VeTHMR_T_BSG_CntrlBoardTemp_Fltr = 0.0F;
    }
    else
    {
        /* Switch: '<S133>/Switch1' incorporates:
         *  Constant: '<S126>/ConstantValue1'
         *  Product: '<S133>/Multiplication'
         *  Sum: '<S133>/Subtraction'
         *  Sum: '<S133>/Summation'
         */
        VeTHMR_T_BSG_CntrlBoardTemp_Fltr = ((rtb_Switch1_oje - rtb_UnitDelay_bv)
            * 0.05F) + rtb_UnitDelay_bv;
    }

    /* End of Switch: '<S133>/Switch1' */
    /* End of Outputs for SubSystem: '<S126>/DigitalLowpassResetEnabled2' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeINVR_b_MtrA_ClntOut_Temp_FA' */
    (void)Rte_Read_VeINVR_b_MtrA_ClntOut_Temp_FA_Value(&rtb_AND_jo);

    /* Inport: '<Root>/VeINVR_T_MtrA_ClntOut_Temp' */
    (void)Rte_Read_VeINVR_T_MtrA_ClntOut_Temp_Value(&rtb_Switch1_c5k);

    /* Inport: '<Root>/VeINVR_b_MtrA_ClntIn_Temp_FA' */
    (void)Rte_Read_VeINVR_b_MtrA_ClntIn_Temp_FA_Value(&rtb_AND_eb);

    /* Inport: '<Root>/VeINVR_T_MtrA_ClntIn_Temp' */
    (void)Rte_Read_VeINVR_T_MtrA_ClntIn_Temp_Value(&rtb_UnitDelay_o5);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/BSG_Overwrite'
     */
    /* Outputs for Atomic SubSystem: '<S126>/DigitalLowpassResetEnabled2' */
    /* Update for UnitDelay: '<S133>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_gc = VeTHMR_T_BSG_CntrlBoardTemp_Fltr;

    /* End of Outputs for SubSystem: '<S126>/DigitalLowpassResetEnabled2' */

    /* Switch: '<S126>/Switch5' incorporates:
     *  Constant: '<S135>/Calib'
     */
    if (KeTHMR_b_BSG_CntrlBoardTemp_Fltr_Sel)
    {
        /* Switch: '<S126>/Switch5' */
        VeTHMR_T_BSG_CntrlBoardTemp_AF = VeTHMR_T_BSG_CntrlBoardTemp_Fltr;
    }
    else
    {
        /* Switch: '<S126>/Switch5' */
        VeTHMR_T_BSG_CntrlBoardTemp_AF = VeTHMR_T_BSG_CntrlBoardTemp;
    }

    /* End of Switch: '<S126>/Switch5' */

    /* Switch: '<S119>/Switch1' incorporates:
     *  Constant: '<S139>/Calib'
     */
    if (KeTHMR_b_BSG_ClntInTemp_SD)
    {
        /* Switch: '<S119>/Switch1' incorporates:
         *  Constant: '<S136>/Calib'
         */
        VeTHMR_T_BSG_ClntInTemp = KeTHMR_T_BSG_ClntInTemp_D;
    }
    else
    {
        /* Switch: '<S119>/Switch1' */
        VeTHMR_T_BSG_ClntInTemp = rtb_UnitDelay_o5;
    }

    /* End of Switch: '<S119>/Switch1' */

    /* Switch: '<S119>/Switch2' incorporates:
     *  Constant: '<S138>/Calib'
     */
    if (KeTHMR_b_BSG_ClntInTemp_FA_SD)
    {
        /* Switch: '<S119>/Switch2' incorporates:
         *  Constant: '<S137>/Calib'
         */
        VeTHMR_b_BSG_ClntInTemp_FA = KeTHMR_b_BSG_ClntInTemp_FA_D;
    }
    else
    {
        /* Switch: '<S119>/Switch2' */
        VeTHMR_b_BSG_ClntInTemp_FA = rtb_AND_eb;
    }

    /* End of Switch: '<S119>/Switch2' */

    /* Switch: '<S120>/Switch1' incorporates:
     *  Constant: '<S144>/Calib'
     */
    if (KeTHMR_b_BSG_ClntOutTemp_SD)
    {
        /* Switch: '<S120>/Switch1' incorporates:
         *  Constant: '<S141>/Calib'
         */
        VeTHMR_T_BSG_ClntOutTemp = KeTHMR_T_BSG_ClntOutTemp_D;
    }
    else
    {
        /* Switch: '<S120>/Switch1' */
        VeTHMR_T_BSG_ClntOutTemp = rtb_Switch1_c5k;
    }

    /* End of Switch: '<S120>/Switch1' */

    /* Switch: '<S120>/Switch2' incorporates:
     *  Constant: '<S143>/Calib'
     */
    if (KeTHMR_b_BSG_ClntOutTemp_FA_SD)
    {
        /* Switch: '<S120>/Switch2' incorporates:
         *  Constant: '<S142>/Calib'
         */
        VeTHMR_b_BSG_ClntOutTemp_FA = KeTHMR_b_BSG_ClntOutTemp_FA_D;
    }
    else
    {
        /* Switch: '<S120>/Switch2' */
        VeTHMR_b_BSG_ClntOutTemp_FA = rtb_AND_jo;
    }

    /* End of Switch: '<S120>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S140>/EdgeFalling' */
    /* Logic: '<S148>/AND' incorporates:
     *  Logic: '<S148>/OR1'
     *  UnitDelay: '<S148>/UnitDelay'
     */
    rtb_AND_jo = ((!VeTHMR_b_BSG_ClntOutTemp_FA) &&
                  (THMR_ac_DW.UnitDelay_DSTATE_h2));

    /* Update for UnitDelay: '<S148>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_h2 = VeTHMR_b_BSG_ClntOutTemp_FA;

    /* End of Outputs for SubSystem: '<S140>/EdgeFalling' */

    /* Outputs for Atomic SubSystem: '<S140>/DigitalLowpassResetEnabled' */
    /* Switch: '<S145>/Switch1' */
    if (rtb_AND_jo)
    {
        /* Switch: '<S145>/Switch1' incorporates:
         *  Constant: '<S140>/ConstantValue2'
         */
        rtb_Switch1_c5k = 0.0F;
    }
    else
    {
        /* Switch: '<S145>/Switch1' incorporates:
         *  Constant: '<S140>/ConstantValue1'
         *  Product: '<S145>/Multiplication'
         *  Sum: '<S145>/Subtraction'
         *  Sum: '<S145>/Summation'
         *  UnitDelay: '<S145>/UnitDelay'
         */
        rtb_Switch1_c5k = ((VeTHMR_T_BSG_ClntOutTemp -
                            THMR_ac_DW.UnitDelay_DSTATE_ip) * 0.05F) +
            THMR_ac_DW.UnitDelay_DSTATE_ip;
    }

    /* End of Switch: '<S145>/Switch1' */

    /* Update for UnitDelay: '<S145>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ip = rtb_Switch1_c5k;

    /* End of Outputs for SubSystem: '<S140>/DigitalLowpassResetEnabled' */

    /* Outputs for Atomic SubSystem: '<S140>/DigitalLowpassResetEnabled1' */
    /* Switch: '<S146>/Switch1' */
    if (rtb_AND_jo)
    {
        /* Switch: '<S146>/Switch1' incorporates:
         *  Constant: '<S140>/ConstantValue2'
         */
        rtb_Switch1_c5k = 0.0F;
    }
    else
    {
        /* Switch: '<S146>/Switch1' incorporates:
         *  Constant: '<S140>/ConstantValue1'
         *  Product: '<S146>/Multiplication'
         *  Sum: '<S146>/Subtraction'
         *  Sum: '<S146>/Summation'
         *  UnitDelay: '<S146>/UnitDelay'
         */
        rtb_Switch1_c5k = ((rtb_Switch1_c5k - THMR_ac_DW.UnitDelay_DSTATE_jo) *
                           0.05F) + THMR_ac_DW.UnitDelay_DSTATE_jo;
    }

    /* End of Switch: '<S146>/Switch1' */

    /* Update for UnitDelay: '<S146>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_jo = rtb_Switch1_c5k;

    /* End of Outputs for SubSystem: '<S140>/DigitalLowpassResetEnabled1' */

    /* Outputs for Atomic SubSystem: '<S140>/DigitalLowpassResetEnabled2' */
    /* UnitDelay: '<S147>/UnitDelay' */
    rtb_UnitDelay_o5 = THMR_ac_DW.UnitDelay_DSTATE_ib;

    /* Switch: '<S147>/Switch1' */
    if (rtb_AND_jo)
    {
        /* Switch: '<S147>/Switch1' incorporates:
         *  Constant: '<S140>/ConstantValue2'
         */
        VeTHMR_T_BSG_ClntOutTemp_Fltr = 0.0F;
    }
    else
    {
        /* Switch: '<S147>/Switch1' incorporates:
         *  Constant: '<S140>/ConstantValue1'
         *  Product: '<S147>/Multiplication'
         *  Sum: '<S147>/Subtraction'
         *  Sum: '<S147>/Summation'
         */
        VeTHMR_T_BSG_ClntOutTemp_Fltr = ((rtb_Switch1_c5k - rtb_UnitDelay_o5) *
            0.05F) + rtb_UnitDelay_o5;
    }

    /* End of Switch: '<S147>/Switch1' */
    /* End of Outputs for SubSystem: '<S140>/DigitalLowpassResetEnabled2' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeINVR_b_MtrB_CtrlBoard_Temp_FA' */
    (void)Rte_Read_VeINVR_b_MtrB_CtrlBoard_Temp_FA_Value(&rtb_AND_ko5);

    /* Inport: '<Root>/VeINVR_T_MtrB_CtrlBoard_Temp' */
    (void)Rte_Read_VeINVR_T_MtrB_CtrlBoard_Temp_Value(&rtb_Switch1_nmk);

    /* Inport: '<Root>/VeINVR_b_MtrB_RotrTemp_FA' */
    (void)Rte_Read_VeINVR_b_MtrB_RotrTemp_FA_Value(&rtb_Comparison5_c3m);

    /* Inport: '<Root>/VeINVR_T_MtrB_RotrTemp' */
    (void)Rte_Read_VeINVR_T_MtrB_RotrTemp_Value(&rtb_UnitDelay_od);

    /* Inport: '<Root>/VeINVR_b_MtrA_CapctrTemp_FA' */
    (void)Rte_Read_VeINVR_b_MtrA_CapctrTemp_FA_Value(&rtb_Logical5_bn);

    /* Inport: '<Root>/VeINVR_T_MtrA_CapctrTemp' */
    (void)Rte_Read_VeINVR_T_MtrA_CapctrTemp_Value(&dy_dx_i_idx_0);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/BSG_Overwrite'
     */
    /* Outputs for Atomic SubSystem: '<S140>/DigitalLowpassResetEnabled2' */
    /* Update for UnitDelay: '<S147>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ib = VeTHMR_T_BSG_ClntOutTemp_Fltr;

    /* End of Outputs for SubSystem: '<S140>/DigitalLowpassResetEnabled2' */

    /* Switch: '<S140>/Switch5' incorporates:
     *  Constant: '<S149>/Calib'
     */
    if (KeTHMR_b_BSG_ClntOutTemp_Fltr_Sel)
    {
        /* Switch: '<S140>/Switch5' */
        VeTHMR_T_BSG_ClntOutTemp_AF = VeTHMR_T_BSG_ClntOutTemp_Fltr;
    }
    else
    {
        /* Switch: '<S140>/Switch5' */
        VeTHMR_T_BSG_ClntOutTemp_AF = VeTHMR_T_BSG_ClntOutTemp;
    }

    /* End of Switch: '<S140>/Switch5' */

    /* Switch: '<S121>/Switch1' incorporates:
     *  Constant: '<S153>/Calib'
     */
    if (KeTHMR_b_BSG_MtrCapctrTemp_SD)
    {
        /* Switch: '<S121>/Switch1' incorporates:
         *  Constant: '<S150>/Calib'
         */
        VeTHMR_T_BSG_MtrCapctrTemp = KeTHMR_T_BSG_MtrCapctrTemp_D;
    }
    else
    {
        /* Switch: '<S121>/Switch1' */
        VeTHMR_T_BSG_MtrCapctrTemp = dy_dx_i_idx_0;
    }

    /* End of Switch: '<S121>/Switch1' */

    /* Switch: '<S121>/Switch2' incorporates:
     *  Constant: '<S152>/Calib'
     */
    if (KeTHMR_b_BSG_MtrCapctrTemp_FA_SD)
    {
        /* Switch: '<S121>/Switch2' incorporates:
         *  Constant: '<S151>/Calib'
         */
        VeTHMR_b_BSG_MtrCapctrTemp_FA = KeTHMR_b_BSG_MtrCapctrTemp_FA_D;
    }
    else
    {
        /* Switch: '<S121>/Switch2' */
        VeTHMR_b_BSG_MtrCapctrTemp_FA = rtb_Logical5_bn;
    }

    /* End of Switch: '<S121>/Switch2' */

    /* Switch: '<S154>/Switch1' incorporates:
     *  Constant: '<S162>/Calib'
     */
    if (KeTHMR_b_P1P2p5_MtrB_Rotor_Temp_SD)
    {
        /* Switch: '<S154>/Switch1' incorporates:
         *  Constant: '<S159>/Calib'
         */
        VeTHMR_T_P1P2p5_MtrB_MtrRotorTemp = KeTHMR_T_P1P2p5_MtrB_Rotor_Temp_D;
    }
    else
    {
        /* Switch: '<S154>/Switch1' */
        VeTHMR_T_P1P2p5_MtrB_MtrRotorTemp = rtb_UnitDelay_od;
    }

    /* End of Switch: '<S154>/Switch1' */

    /* Switch: '<S154>/Switch2' incorporates:
     *  Constant: '<S161>/Calib'
     */
    if (KeTHMR_b_P1P2p5_MtrB_Rotor_Temp_FA_SD)
    {
        /* Switch: '<S154>/Switch2' incorporates:
         *  Constant: '<S160>/Calib'
         */
        VeTHMR_b_P1P2p5_MtrB_MtrRotorTemp_FA =
            KeTHMR_b_P1P2p5_MtrB_Rotor_Temp_FA_D;
    }
    else
    {
        /* Switch: '<S154>/Switch2' */
        VeTHMR_b_P1P2p5_MtrB_MtrRotorTemp_FA = rtb_Comparison5_c3m;
    }

    /* End of Switch: '<S154>/Switch2' */

    /* Switch: '<S155>/Switch1' incorporates:
     *  Constant: '<S167>/Calib'
     */
    if (KeTHMR_b_P1P2p5_MtrB_CntrlBoardTemp_SD)
    {
        /* Switch: '<S155>/Switch1' incorporates:
         *  Constant: '<S164>/Calib'
         */
        VeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp =
            KeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp_D;
    }
    else
    {
        /* Switch: '<S155>/Switch1' */
        VeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp = rtb_Switch1_nmk;
    }

    /* End of Switch: '<S155>/Switch1' */

    /* Switch: '<S155>/Switch2' incorporates:
     *  Constant: '<S166>/Calib'
     */
    if (KeTHMR_b_P1P2p5_MtrB_CntrlBoardTemp_FA_SD)
    {
        /* Switch: '<S155>/Switch2' incorporates:
         *  Constant: '<S165>/Calib'
         */
        VeTHMR_b_P1P2p5_MtrB_CntrlBoardTemp_FA =
            KeTHMR_b_P1P2p5_MtrB_CntrlBoardTemp_FA_D;
    }
    else
    {
        /* Switch: '<S155>/Switch2' */
        VeTHMR_b_P1P2p5_MtrB_CntrlBoardTemp_FA = rtb_AND_ko5;
    }

    /* End of Switch: '<S155>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S163>/EdgeFalling' */
    /* Logic: '<S171>/AND' incorporates:
     *  Logic: '<S171>/OR1'
     *  UnitDelay: '<S171>/UnitDelay'
     */
    rtb_AND_ko5 = ((!VeTHMR_b_P1P2p5_MtrB_CntrlBoardTemp_FA) &&
                   (THMR_ac_DW.UnitDelay_DSTATE_hvz));

    /* Update for UnitDelay: '<S171>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_hvz = VeTHMR_b_P1P2p5_MtrB_CntrlBoardTemp_FA;

    /* End of Outputs for SubSystem: '<S163>/EdgeFalling' */

    /* Outputs for Atomic SubSystem: '<S163>/DigitalLowpassResetEnabled' */
    /* Switch: '<S168>/Switch1' */
    if (rtb_AND_ko5)
    {
        /* Switch: '<S168>/Switch1' incorporates:
         *  Constant: '<S163>/ConstantValue2'
         */
        rtb_Switch1_nmk = 0.0F;
    }
    else
    {
        /* Switch: '<S168>/Switch1' incorporates:
         *  Constant: '<S163>/ConstantValue1'
         *  Product: '<S168>/Multiplication'
         *  Sum: '<S168>/Subtraction'
         *  Sum: '<S168>/Summation'
         *  UnitDelay: '<S168>/UnitDelay'
         */
        rtb_Switch1_nmk = ((VeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp -
                            THMR_ac_DW.UnitDelay_DSTATE_oa) * 0.05F) +
            THMR_ac_DW.UnitDelay_DSTATE_oa;
    }

    /* End of Switch: '<S168>/Switch1' */

    /* Update for UnitDelay: '<S168>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_oa = rtb_Switch1_nmk;

    /* End of Outputs for SubSystem: '<S163>/DigitalLowpassResetEnabled' */

    /* Outputs for Atomic SubSystem: '<S163>/DigitalLowpassResetEnabled1' */
    /* Switch: '<S169>/Switch1' */
    if (rtb_AND_ko5)
    {
        /* Switch: '<S169>/Switch1' incorporates:
         *  Constant: '<S163>/ConstantValue2'
         */
        rtb_Switch1_nmk = 0.0F;
    }
    else
    {
        /* Switch: '<S169>/Switch1' incorporates:
         *  Constant: '<S163>/ConstantValue1'
         *  Product: '<S169>/Multiplication'
         *  Sum: '<S169>/Subtraction'
         *  Sum: '<S169>/Summation'
         *  UnitDelay: '<S169>/UnitDelay'
         */
        rtb_Switch1_nmk = ((rtb_Switch1_nmk - THMR_ac_DW.UnitDelay_DSTATE_o2) *
                           0.05F) + THMR_ac_DW.UnitDelay_DSTATE_o2;
    }

    /* End of Switch: '<S169>/Switch1' */

    /* Update for UnitDelay: '<S169>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_o2 = rtb_Switch1_nmk;

    /* End of Outputs for SubSystem: '<S163>/DigitalLowpassResetEnabled1' */

    /* Outputs for Atomic SubSystem: '<S163>/DigitalLowpassResetEnabled2' */
    /* UnitDelay: '<S170>/UnitDelay' */
    rtb_UnitDelay_od = THMR_ac_DW.UnitDelay_DSTATE_cd;

    /* Switch: '<S170>/Switch1' */
    if (rtb_AND_ko5)
    {
        /* Switch: '<S170>/Switch1' incorporates:
         *  Constant: '<S163>/ConstantValue2'
         */
        VeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp_Fltr = 0.0F;
    }
    else
    {
        /* Switch: '<S170>/Switch1' incorporates:
         *  Constant: '<S163>/ConstantValue1'
         *  Product: '<S170>/Multiplication'
         *  Sum: '<S170>/Subtraction'
         *  Sum: '<S170>/Summation'
         */
        VeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp_Fltr = ((rtb_Switch1_nmk -
            rtb_UnitDelay_od) * 0.05F) + rtb_UnitDelay_od;
    }

    /* End of Switch: '<S170>/Switch1' */
    /* End of Outputs for SubSystem: '<S163>/DigitalLowpassResetEnabled2' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeINVR_b_MtrB_ClntOut_Temp_FA' */
    (void)Rte_Read_VeINVR_b_MtrB_ClntOut_Temp_FA_Value(&rtb_AND_cn);

    /* Inport: '<Root>/VeINVR_T_MtrB_ClntOut_Temp' */
    (void)Rte_Read_VeINVR_T_MtrB_ClntOut_Temp_Value(&rtb_Switch1_he);

    /* Inport: '<Root>/VeINVR_b_MtrB_ClntIn_Temp_FA' */
    (void)Rte_Read_VeINVR_b_MtrB_ClntIn_Temp_FA_Value(&Switch5_i);

    /* Inport: '<Root>/VeINVR_T_MtrB_ClntIn_Temp' */
    (void)Rte_Read_VeINVR_T_MtrB_ClntIn_Temp_Value(&rtb_UnitDelay_cui);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/BSG_Overwrite'
     */
    /* Outputs for Atomic SubSystem: '<S163>/DigitalLowpassResetEnabled2' */
    /* Update for UnitDelay: '<S170>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_cd = VeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp_Fltr;

    /* End of Outputs for SubSystem: '<S163>/DigitalLowpassResetEnabled2' */

    /* Switch: '<S163>/Switch5' incorporates:
     *  Constant: '<S172>/Calib'
     */
    if (KeTHMR_b_P1P2p5_MtrB_CntrlBoardTemp_Fltr_Sel)
    {
        /* Switch: '<S163>/Switch5' */
        VeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp_AF =
            VeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp_Fltr;
    }
    else
    {
        /* Switch: '<S163>/Switch5' */
        VeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp_AF =
            VeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp;
    }

    /* End of Switch: '<S163>/Switch5' */

    /* Switch: '<S156>/Switch1' incorporates:
     *  Constant: '<S176>/Calib'
     */
    if (KeTHMR_b_P1P2p5_MtrB_ClntInTemp_SD)
    {
        /* Switch: '<S156>/Switch1' incorporates:
         *  Constant: '<S173>/Calib'
         */
        VeTHMR_T_P1P2p5_MtrB_ClntInTemp = KeTHMR_T_P1P2p5_MtrB_ClntInTemp_D;
    }
    else
    {
        /* Switch: '<S156>/Switch1' */
        VeTHMR_T_P1P2p5_MtrB_ClntInTemp = rtb_UnitDelay_cui;
    }

    /* End of Switch: '<S156>/Switch1' */

    /* Switch: '<S156>/Switch2' incorporates:
     *  Constant: '<S175>/Calib'
     */
    if (KeTHMR_b_P1P2p5_MtrB_ClntInTemp_FA_SD)
    {
        /* Switch: '<S156>/Switch2' incorporates:
         *  Constant: '<S174>/Calib'
         */
        VeTHMR_b_P1P2p5_MtrB_ClntInTemp_FA =
            KeTHMR_b_P1P2p5_MtrB_ClntInTemp_FA_D;
    }
    else
    {
        /* Switch: '<S156>/Switch2' */
        VeTHMR_b_P1P2p5_MtrB_ClntInTemp_FA = Switch5_i;
    }

    /* End of Switch: '<S156>/Switch2' */

    /* Switch: '<S157>/Switch1' incorporates:
     *  Constant: '<S181>/Calib'
     */
    if (KeTHMR_b_P1P2p5_MtrB_ClntOutTemp_SD)
    {
        /* Switch: '<S157>/Switch1' incorporates:
         *  Constant: '<S178>/Calib'
         */
        VeTHMR_T_P1P2p5_MtrB_ClntOutTemp = KeTHMR_T_P1P2p5_MtrB_ClntOutTemp_D;
    }
    else
    {
        /* Switch: '<S157>/Switch1' */
        VeTHMR_T_P1P2p5_MtrB_ClntOutTemp = rtb_Switch1_he;
    }

    /* End of Switch: '<S157>/Switch1' */

    /* Switch: '<S157>/Switch2' incorporates:
     *  Constant: '<S180>/Calib'
     */
    if (KeTHMR_b_P1P2p5_MtrB_ClntOutTemp_FA_SD)
    {
        /* Switch: '<S157>/Switch2' incorporates:
         *  Constant: '<S179>/Calib'
         */
        VeTHMR_b_P1P2p5_MtrB_ClntOutTemp_FA =
            KeTHMR_b_P1P2p5_MtrB_ClntOutTemp_FA_D;
    }
    else
    {
        /* Switch: '<S157>/Switch2' */
        VeTHMR_b_P1P2p5_MtrB_ClntOutTemp_FA = rtb_AND_cn;
    }

    /* End of Switch: '<S157>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S177>/EdgeFalling' */
    /* Logic: '<S185>/AND' incorporates:
     *  Logic: '<S185>/OR1'
     *  UnitDelay: '<S185>/UnitDelay'
     */
    rtb_AND_cn = ((!VeTHMR_b_P1P2p5_MtrB_ClntOutTemp_FA) &&
                  (THMR_ac_DW.UnitDelay_DSTATE_jic));

    /* Update for UnitDelay: '<S185>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_jic = VeTHMR_b_P1P2p5_MtrB_ClntOutTemp_FA;

    /* End of Outputs for SubSystem: '<S177>/EdgeFalling' */

    /* Outputs for Atomic SubSystem: '<S177>/DigitalLowpassResetEnabled' */
    /* Switch: '<S182>/Switch1' */
    if (rtb_AND_cn)
    {
        /* Switch: '<S182>/Switch1' incorporates:
         *  Constant: '<S177>/ConstantValue2'
         */
        rtb_Switch1_he = 0.0F;
    }
    else
    {
        /* Switch: '<S182>/Switch1' incorporates:
         *  Constant: '<S177>/ConstantValue1'
         *  Product: '<S182>/Multiplication'
         *  Sum: '<S182>/Subtraction'
         *  Sum: '<S182>/Summation'
         *  UnitDelay: '<S182>/UnitDelay'
         */
        rtb_Switch1_he = ((VeTHMR_T_P1P2p5_MtrB_ClntOutTemp -
                           THMR_ac_DW.UnitDelay_DSTATE_h0) * 0.05F) +
            THMR_ac_DW.UnitDelay_DSTATE_h0;
    }

    /* End of Switch: '<S182>/Switch1' */

    /* Update for UnitDelay: '<S182>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_h0 = rtb_Switch1_he;

    /* End of Outputs for SubSystem: '<S177>/DigitalLowpassResetEnabled' */

    /* Outputs for Atomic SubSystem: '<S177>/DigitalLowpassResetEnabled1' */
    /* Switch: '<S183>/Switch1' */
    if (rtb_AND_cn)
    {
        /* Switch: '<S183>/Switch1' incorporates:
         *  Constant: '<S177>/ConstantValue2'
         */
        rtb_Switch1_he = 0.0F;
    }
    else
    {
        /* Switch: '<S183>/Switch1' incorporates:
         *  Constant: '<S177>/ConstantValue1'
         *  Product: '<S183>/Multiplication'
         *  Sum: '<S183>/Subtraction'
         *  Sum: '<S183>/Summation'
         *  UnitDelay: '<S183>/UnitDelay'
         */
        rtb_Switch1_he = ((rtb_Switch1_he - THMR_ac_DW.UnitDelay_DSTATE_jdg) *
                          0.05F) + THMR_ac_DW.UnitDelay_DSTATE_jdg;
    }

    /* End of Switch: '<S183>/Switch1' */

    /* Update for UnitDelay: '<S183>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_jdg = rtb_Switch1_he;

    /* End of Outputs for SubSystem: '<S177>/DigitalLowpassResetEnabled1' */

    /* Outputs for Atomic SubSystem: '<S177>/DigitalLowpassResetEnabled2' */
    /* UnitDelay: '<S184>/UnitDelay' */
    rtb_UnitDelay_cui = THMR_ac_DW.UnitDelay_DSTATE_ilt;

    /* Switch: '<S184>/Switch1' */
    if (rtb_AND_cn)
    {
        /* Switch: '<S184>/Switch1' incorporates:
         *  Constant: '<S177>/ConstantValue2'
         */
        VeTHMR_T_P1P2p5_ClntOutTemp_Fltr = 0.0F;
    }
    else
    {
        /* Switch: '<S184>/Switch1' incorporates:
         *  Constant: '<S177>/ConstantValue1'
         *  Product: '<S184>/Multiplication'
         *  Sum: '<S184>/Subtraction'
         *  Sum: '<S184>/Summation'
         */
        VeTHMR_T_P1P2p5_ClntOutTemp_Fltr = ((rtb_Switch1_he - rtb_UnitDelay_cui)
            * 0.05F) + rtb_UnitDelay_cui;
    }

    /* End of Switch: '<S184>/Switch1' */
    /* End of Outputs for SubSystem: '<S177>/DigitalLowpassResetEnabled2' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeINVR_b_MtrC_CtrlBoard_Temp_FA' */
    (void)Rte_Read_VeINVR_b_MtrC_CtrlBoard_Temp_FA_Value(&rtb_AND_c3);

    /* Inport: '<Root>/VeINVR_T_MtrC_CtrlBoard_Temp' */
    (void)Rte_Read_VeINVR_T_MtrC_CtrlBoard_Temp_Value(&rtb_Switch1_l3);

    /* Inport: '<Root>/VeINVR_b_MtrC_RotrTemp_FA' */
    (void)Rte_Read_VeINVR_b_MtrC_RotrTemp_FA_Value(&rtb_OR1_g4);

    /* Inport: '<Root>/VeINVR_T_MtrC_RotrTemp' */
    (void)Rte_Read_VeINVR_T_MtrC_RotrTemp_Value(&rtb_UnitDelay_kww);

    /* Inport: '<Root>/VeINVR_b_MtrC_InvrtrTempFA' */
    (void)Rte_Read_VeINVR_b_MtrC_InvrtrTempFA_Value(&rtb_Logical18_d);

    /* Inport: '<Root>/VeINVR_T_MtrC_InvrtrTemp' */
    (void)Rte_Read_VeINVR_T_MtrC_InvrtrTemp_Value(&VeTHMR_T_MinBattAllow);

    /* Inport: '<Root>/VeINVR_b_MtrC_TempFA' */
    (void)Rte_Read_VeINVR_b_MtrC_TempFA_Value(&rtb_Logical6_or);

    /* Inport: '<Root>/VeINVR_T_MtrC_Temp' */
    (void)Rte_Read_VeINVR_T_MtrC_Temp_Value(&rtb_UnitDelay_nr);

    /* Inport: '<Root>/VePLTR_b_DriverDetected' */
    (void)Rte_Read_VePLTR_b_DriverDetected_Value(&rtb_Comparison3_bu);

    /* Inport: '<Root>/VeCITR_e_FOTA_Install_Type' */
    (void)Rte_Read_VeCITR_e_FOTA_Install_Type_Value(&Switch2_i);

    /* Inport: '<Root>/VeINVR_b_MtrB_CapctrTemp_FA' */
    (void)Rte_Read_VeINVR_b_MtrB_CapctrTemp_FA_Value(&Switch9_a);

    /* Inport: '<Root>/VeINVR_T_MtrB_CapctrTemp' */
    (void)Rte_Read_VeINVR_T_MtrB_CapctrTemp_Value(&Switch4_d);

    /* Inport: '<Root>/VeTRIR_b_HtrCorClnt_TmpIn_FA' */
    (void)Rte_Read_VeTRIR_b_HtrCorClnt_TmpIn_FA_Value(&rtb_Comparison4_cx);

    /* Inport: '<Root>/VeTRIR_T_HtrCorClnt_TmpIn' */
    (void)Rte_Read_VeTRIR_T_HtrCorClnt_TmpIn_Value(&rtb_Switch15);

    /* Inport: '<Root>/VeENGR_T_InductionAirTemp' */
    (void)Rte_Read_VeENGR_T_InductionAirTemp_Value(&rtb_Switch10);

    /* Inport: '<Root>/VePMIR_b_ECM_LTPsvPumpRq_FA' */
    (void)Rte_Read_VePMIR_b_ECM_LTPsvPumpRq_FA_Value(&rtb_Comparison6_n3);

    /* Inport: '<Root>/VePMIR_Pct_ECM_LTPsvPumpRq' */
    (void)Rte_Read_VePMIR_Pct_ECM_LTPsvPumpRq_Value(&rtb_Switch11);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/BSG_Overwrite'
     */
    /* Outputs for Atomic SubSystem: '<S177>/DigitalLowpassResetEnabled2' */
    /* Update for UnitDelay: '<S184>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ilt = VeTHMR_T_P1P2p5_ClntOutTemp_Fltr;

    /* End of Outputs for SubSystem: '<S177>/DigitalLowpassResetEnabled2' */

    /* Switch: '<S177>/Switch5' incorporates:
     *  Constant: '<S186>/Calib'
     */
    if (KeTHMR_b_BSG_ClntOutTemp_Fltr_Sel)
    {
        /* Switch: '<S177>/Switch5' */
        VeTHMR_T_P1P2p5_ClntOutTemp_AF = VeTHMR_T_P1P2p5_ClntOutTemp_Fltr;
    }
    else
    {
        /* Switch: '<S177>/Switch5' */
        VeTHMR_T_P1P2p5_ClntOutTemp_AF = VeTHMR_T_P1P2p5_MtrB_ClntOutTemp;
    }

    /* End of Switch: '<S177>/Switch5' */

    /* Switch: '<S158>/Switch1' incorporates:
     *  Constant: '<S190>/Calib'
     */
    if (KeTHMR_b_P1P2p5_MtrB_MtrCapctrTemp_SD)
    {
        /* Switch: '<S158>/Switch1' incorporates:
         *  Constant: '<S187>/Calib'
         */
        VeTHMR_T_P1P2p5_MtrB_MtrCapctrTemp =
            KeTHMR_T_P1P2p5_MtrB_MtrCapctrTemp_D;
    }
    else
    {
        /* Switch: '<S158>/Switch1' */
        VeTHMR_T_P1P2p5_MtrB_MtrCapctrTemp = Switch4_d;
    }

    /* End of Switch: '<S158>/Switch1' */

    /* Switch: '<S158>/Switch2' incorporates:
     *  Constant: '<S189>/Calib'
     */
    if (KeTHMR_b_P1P2p5_MtrB_MtrCapctrTemp_FA_SD)
    {
        /* Switch: '<S158>/Switch2' incorporates:
         *  Constant: '<S188>/Calib'
         */
        VeTHMR_b_P1P2p5_MtrB_MtrCapctrTemp_FA =
            KeTHMR_b_P1P2p5_MtrB_MtrCapctrTemp_FA_D;
    }
    else
    {
        /* Switch: '<S158>/Switch2' */
        VeTHMR_b_P1P2p5_MtrB_MtrCapctrTemp_FA = Switch9_a;
    }

    /* End of Switch: '<S158>/Switch2' */

    /* Switch: '<S39>/Switch4' incorporates:
     *  Constant: '<S108>/Calib'
     *  Switch: '<S39>/Switch5'
     *  Switch: '<S39>/Switch6'
     *  Switch: '<S39>/Switch7'
     *  Switch: '<S39>/Switch8'
     *  Switch: '<S39>/Switch9'
     */
    if (KeTHMR_b_Slct_BSGMtrA_P1P2p5MtrB)
    {
        /* Switch: '<S39>/Switch4' */
        Switch4_d = VeTHMR_T_BSG_ClntInTemp;

        /* Switch: '<S39>/Switch5' */
        Switch5_i = VeTHMR_b_BSG_ClntInTemp_FA;

        /* Switch: '<S39>/Switch6' */
        rtb_Switch1_he = VeTHMR_T_BSG_ClntOutTemp_AF;

        /* Switch: '<S39>/Switch7' */
        rtb_AND_cn = VeTHMR_b_BSG_ClntOutTemp_FA;

        /* Switch: '<S39>/Switch8' */
        rtb_UnitDelay_cui = VeTHMR_T_BSG_MtrCapctrTemp;

        /* Switch: '<S39>/Switch9' */
        Switch9_a = VeTHMR_b_BSG_MtrCapctrTemp_FA;
    }
    else
    {
        /* Switch: '<S39>/Switch4' */
        Switch4_d = VeTHMR_T_P1P2p5_MtrB_ClntInTemp;

        /* Switch: '<S39>/Switch5' */
        Switch5_i = VeTHMR_b_P1P2p5_MtrB_ClntInTemp_FA;

        /* Switch: '<S39>/Switch6' */
        rtb_Switch1_he = VeTHMR_T_P1P2p5_ClntOutTemp_AF;

        /* Switch: '<S39>/Switch7' */
        rtb_AND_cn = VeTHMR_b_P1P2p5_MtrB_ClntOutTemp_FA;

        /* Switch: '<S39>/Switch8' */
        rtb_UnitDelay_cui = VeTHMR_T_P1P2p5_MtrB_MtrCapctrTemp;

        /* Switch: '<S39>/Switch9' */
        Switch9_a = VeTHMR_b_P1P2p5_MtrB_MtrCapctrTemp_FA;
    }

    /* End of Switch: '<S39>/Switch4' */

    /* Switch: '<S107>/Switch1' incorporates:
     *  Constant: '<S114>/Calib'
     */
    if (KeTHMR_b_ECM_LTPsvPmpRq_D)
    {
        /* Switch: '<S107>/Switch1' incorporates:
         *  Constant: '<S113>/Calib'
         */
        VeTHMR_Pct_ECM_LTPsvPmpRq_AD = KeTHMR_Pct_ECM_LTPsvPmpRq_SD;
    }
    else
    {
        /* Switch: '<S107>/Switch1' */
        VeTHMR_Pct_ECM_LTPsvPmpRq_AD = rtb_Switch11;
    }

    /* End of Switch: '<S107>/Switch1' */

    /* Switch: '<S107>/Switch2' incorporates:
     *  Constant: '<S116>/Calib'
     */
    if (KeTHMR_b_ECM_LTPsvPmpRq_FA_SD)
    {
        /* Switch: '<S107>/Switch2' incorporates:
         *  Constant: '<S115>/Calib'
         */
        VeTHMR_b_ECM_LTPsvPmpRq_FA_AD = KeTHMR_b_ECM_LTPsvPmpRq_FA_D;
    }
    else
    {
        /* Switch: '<S107>/Switch2' */
        VeTHMR_b_ECM_LTPsvPmpRq_FA_AD = rtb_Comparison6_n3;
    }

    /* End of Switch: '<S107>/Switch2' */

    /* Switch: '<S106>/Switch1' incorporates:
     *  Constant: '<S112>/Calib'
     */
    if (KeTHMR_b_InductionAirTemp_SD)
    {
        /* Switch: '<S106>/Switch1' incorporates:
         *  Constant: '<S111>/Calib'
         */
        VeTHMR_T_InductionAirTemp_AD = KeTHMR_T_InductionAirTemp_D;
    }
    else
    {
        /* Switch: '<S106>/Switch1' */
        VeTHMR_T_InductionAirTemp_AD = rtb_Switch10;
    }

    /* End of Switch: '<S106>/Switch1' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem6'
     */
    /* Switch: '<S82>/Switch1' incorporates:
     *  Constant: '<S4025>/Calib'
     */
    if (KeTHMR_b_HtrCorClnt_Tmp_In_SD)
    {
        /* Switch: '<S82>/Switch1' incorporates:
         *  Constant: '<S4022>/Calib'
         */
        VeTHMR_T_HtrCorClnt_Tmp_In_AD = KeTHMR_T_HtrCorClnt_Tmp_In_D;
    }
    else
    {
        /* Switch: '<S82>/Switch1' */
        VeTHMR_T_HtrCorClnt_Tmp_In_AD = rtb_Switch15;
    }

    /* End of Switch: '<S82>/Switch1' */

    /* Switch: '<S82>/Switch2' incorporates:
     *  Constant: '<S4024>/Calib'
     */
    if (KeTHMR_b_HtrCorClnt_Tmp_In_FA_SD)
    {
        /* Switch: '<S82>/Switch2' incorporates:
         *  Constant: '<S4023>/Calib'
         */
        VeTHMR_b_HtrCorClnt_Tmp_In_FA_AD = KeTHMR_b_HtrCorClnt_Tmp_In_FA_D;
    }
    else
    {
        /* Switch: '<S82>/Switch2' */
        VeTHMR_b_HtrCorClnt_Tmp_In_FA_AD = rtb_Comparison4_cx;
    }

    /* End of Switch: '<S82>/Switch2' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/CITRInputTriggered'
     */
    /* Switch: '<S43>/Switch2' incorporates:
     *  Constant: '<S257>/Calib'
     */
    if (KeTHMR_b_FOTA_Install_Type_SD)
    {
        /* Switch: '<S43>/Switch2' incorporates:
         *  Constant: '<S258>/Calib'
         */
        Switch2_i = KeTHMR_e_FOTA_Install_Type_D;
    }

    /* End of Switch: '<S43>/Switch2' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/AmznDriver'
     */
    /* Switch: '<S38>/Switch2' incorporates:
     *  Constant: '<S105>/Calib'
     */
    if (KeTHMR_b_AmznDrvDprt_SD)
    {
        /* Switch: '<S38>/Switch2' incorporates:
         *  Constant: '<S104>/Calib'
         */
        VeTHMR_b_AmznDrvDprt = KeTHMR_b_AmznDrvDprt_D;
    }
    else
    {
        /* Switch: '<S38>/Switch2' */
        VeTHMR_b_AmznDrvDprt = rtb_Comparison3_bu;
    }

    /* End of Switch: '<S38>/Switch2' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem13'
     */
    /* Switch: '<S3806>/Switch' incorporates:
     *  Constant: '<S3816>/Calib'
     */
    if (KeTHMR_b_MtrC_Temp_SD)
    {
        /* Switch: '<S3806>/Switch' incorporates:
         *  Constant: '<S3813>/Calib'
         */
        VeTHMR_T_MtrC_Temp = KeTHMR_T_MtrC_Temp_D;
    }
    else
    {
        /* Switch: '<S3806>/Switch' */
        VeTHMR_T_MtrC_Temp = rtb_UnitDelay_nr;
    }

    /* End of Switch: '<S3806>/Switch' */

    /* Switch: '<S3806>/Switch1' incorporates:
     *  Constant: '<S3815>/Calib'
     */
    if (KeTHMR_b_MtrC_Temp_FA_SD)
    {
        /* Switch: '<S3806>/Switch1' incorporates:
         *  Constant: '<S3814>/Calib'
         */
        VeTHMR_b_MtrC_TempFA = KeTHMR_b_MtrC_Temp_FA_D;
    }
    else
    {
        /* Switch: '<S3806>/Switch1' */
        VeTHMR_b_MtrC_TempFA = rtb_Logical6_or;
    }

    /* End of Switch: '<S3806>/Switch1' */

    /* Switch: '<S3805>/Switch' incorporates:
     *  Constant: '<S3812>/Calib'
     */
    if (KeTHMR_b_MtrC_InvrtrTemp_SD)
    {
        /* Switch: '<S3805>/Switch' incorporates:
         *  Constant: '<S3809>/Calib'
         */
        VeTHMR_T_MtrC_InvrtrTemp = KeTHMR_T_MtrC_InvrtrTemp_D;
    }
    else
    {
        /* Switch: '<S3805>/Switch' */
        VeTHMR_T_MtrC_InvrtrTemp = VeTHMR_T_MinBattAllow;
    }

    /* End of Switch: '<S3805>/Switch' */

    /* Switch: '<S3805>/Switch1' incorporates:
     *  Constant: '<S3811>/Calib'
     */
    if (KeTHMR_b_MtrC_InvrtrTemp_FA_SD)
    {
        /* Switch: '<S3805>/Switch1' incorporates:
         *  Constant: '<S3810>/Calib'
         */
        VeTHMR_b_MtrC_InvrtrTempFA = KeTHMR_b_MtrC_InvrtrTemp_FA_D;
    }
    else
    {
        /* Switch: '<S3805>/Switch1' */
        VeTHMR_b_MtrC_InvrtrTempFA = rtb_Logical18_d;
    }

    /* End of Switch: '<S3805>/Switch1' */

    /* Switch: '<S3807>/Switch1' incorporates:
     *  Constant: '<S3820>/Calib'
     */
    if (KeTHMR_b_MtrC_Rotor_Temp_SD)
    {
        /* Switch: '<S3807>/Switch1' incorporates:
         *  Constant: '<S3817>/Calib'
         */
        VeTHMR_T_MtrC_RotorTemp = KeTHMR_T_MtrC_Rotor_Temp_D;
    }
    else
    {
        /* Switch: '<S3807>/Switch1' */
        VeTHMR_T_MtrC_RotorTemp = rtb_UnitDelay_kww;
    }

    /* End of Switch: '<S3807>/Switch1' */

    /* Switch: '<S3807>/Switch2' incorporates:
     *  Constant: '<S3819>/Calib'
     */
    if (KeTHMR_b_MtrC_Rotor_Temp_FA_SD)
    {
        /* Switch: '<S3807>/Switch2' incorporates:
         *  Constant: '<S3818>/Calib'
         */
        VeTHMR_b_MtrC_RotorTemp_FA = KeTHMR_b_MtrC_Rotor_Temp_FA_D;
    }
    else
    {
        /* Switch: '<S3807>/Switch2' */
        VeTHMR_b_MtrC_RotorTemp_FA = rtb_OR1_g4;
    }

    /* End of Switch: '<S3807>/Switch2' */

    /* Switch: '<S3808>/Switch1' incorporates:
     *  Constant: '<S3825>/Calib'
     */
    if (KeTHMR_b_MtrC_CntrlBoardTemp_SD)
    {
        /* Switch: '<S3808>/Switch1' incorporates:
         *  Constant: '<S3822>/Calib'
         */
        VeTHMR_T_MtrC_CntrlBoardTemp = KeTHMR_T_MtrC_CntrlBoardTemp_D;
    }
    else
    {
        /* Switch: '<S3808>/Switch1' */
        VeTHMR_T_MtrC_CntrlBoardTemp = rtb_Switch1_l3;
    }

    /* End of Switch: '<S3808>/Switch1' */

    /* Switch: '<S3808>/Switch2' incorporates:
     *  Constant: '<S3824>/Calib'
     */
    if (KeTHMR_b_MtrC_CntrlBoardTemp_FA_SD)
    {
        /* Switch: '<S3808>/Switch2' incorporates:
         *  Constant: '<S3823>/Calib'
         */
        VeTHMR_b_MtrC_CntrlBoardTemp_FA = KeTHMR_b_MtrC_CntrlBoardTemp_FA_D;
    }
    else
    {
        /* Switch: '<S3808>/Switch2' */
        VeTHMR_b_MtrC_CntrlBoardTemp_FA = rtb_AND_c3;
    }

    /* End of Switch: '<S3808>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S3821>/EdgeFalling' */
    /* Logic: '<S3829>/AND' incorporates:
     *  Logic: '<S3829>/OR1'
     *  UnitDelay: '<S3829>/UnitDelay'
     */
    rtb_AND_c3 = ((!VeTHMR_b_MtrC_CntrlBoardTemp_FA) &&
                  (THMR_ac_DW.UnitDelay_DSTATE_kau));

    /* Update for UnitDelay: '<S3829>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kau = VeTHMR_b_MtrC_CntrlBoardTemp_FA;

    /* End of Outputs for SubSystem: '<S3821>/EdgeFalling' */

    /* Outputs for Atomic SubSystem: '<S3821>/DigitalLowpassResetEnabled' */
    /* Switch: '<S3826>/Switch1' */
    if (rtb_AND_c3)
    {
        /* Switch: '<S3826>/Switch1' incorporates:
         *  Constant: '<S3821>/ConstantValue2'
         */
        rtb_Switch1_l3 = 0.0F;
    }
    else
    {
        /* Switch: '<S3826>/Switch1' incorporates:
         *  Constant: '<S3831>/Calib'
         *  Product: '<S3826>/Multiplication'
         *  Sum: '<S3826>/Subtraction'
         *  Sum: '<S3826>/Summation'
         *  UnitDelay: '<S3826>/UnitDelay'
         */
        rtb_Switch1_l3 = ((VeTHMR_T_MtrC_CntrlBoardTemp -
                           THMR_ac_DW.UnitDelay_DSTATE_ko) *
                          KeTHMR_k_MtrC_CntrlBoardTemp_FltrCoeff) +
            THMR_ac_DW.UnitDelay_DSTATE_ko;
    }

    /* End of Switch: '<S3826>/Switch1' */

    /* Update for UnitDelay: '<S3826>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ko = rtb_Switch1_l3;

    /* End of Outputs for SubSystem: '<S3821>/DigitalLowpassResetEnabled' */

    /* Outputs for Atomic SubSystem: '<S3821>/DigitalLowpassResetEnabled1' */
    /* Switch: '<S3827>/Switch1' */
    if (rtb_AND_c3)
    {
        /* Switch: '<S3827>/Switch1' incorporates:
         *  Constant: '<S3821>/ConstantValue2'
         */
        rtb_Switch1_l3 = 0.0F;
    }
    else
    {
        /* Switch: '<S3827>/Switch1' incorporates:
         *  Constant: '<S3831>/Calib'
         *  Product: '<S3827>/Multiplication'
         *  Sum: '<S3827>/Subtraction'
         *  Sum: '<S3827>/Summation'
         *  UnitDelay: '<S3827>/UnitDelay'
         */
        rtb_Switch1_l3 = ((rtb_Switch1_l3 - THMR_ac_DW.UnitDelay_DSTATE_gx) *
                          KeTHMR_k_MtrC_CntrlBoardTemp_FltrCoeff) +
            THMR_ac_DW.UnitDelay_DSTATE_gx;
    }

    /* End of Switch: '<S3827>/Switch1' */

    /* Update for UnitDelay: '<S3827>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_gx = rtb_Switch1_l3;

    /* End of Outputs for SubSystem: '<S3821>/DigitalLowpassResetEnabled1' */

    /* Outputs for Atomic SubSystem: '<S3821>/DigitalLowpassResetEnabled2' */
    /* UnitDelay: '<S3828>/UnitDelay' */
    rtb_UnitDelay_kww = THMR_ac_DW.UnitDelay_DSTATE_avt;

    /* Switch: '<S3828>/Switch1' */
    if (rtb_AND_c3)
    {
        /* Switch: '<S3828>/Switch1' incorporates:
         *  Constant: '<S3821>/ConstantValue2'
         */
        VeTHMR_T_MtrC_CntrlBoardTemp_Fltr = 0.0F;
    }
    else
    {
        /* Switch: '<S3828>/Switch1' incorporates:
         *  Constant: '<S3831>/Calib'
         *  Product: '<S3828>/Multiplication'
         *  Sum: '<S3828>/Subtraction'
         *  Sum: '<S3828>/Summation'
         */
        VeTHMR_T_MtrC_CntrlBoardTemp_Fltr = ((rtb_Switch1_l3 - rtb_UnitDelay_kww)
            * KeTHMR_k_MtrC_CntrlBoardTemp_FltrCoeff) + rtb_UnitDelay_kww;
    }

    /* End of Switch: '<S3828>/Switch1' */
    /* End of Outputs for SubSystem: '<S3821>/DigitalLowpassResetEnabled2' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeGENR_b_HVDspt_Enbl' */
    (void)Rte_Read_VeGENR_b_HVDspt_Enbl_Value(&Switch2_e);

    /* Inport: '<Root>/VeRCVR_b_HTCV_Learning_Req' */
    (void)Rte_Read_VeRCVR_b_HTCV_Learning_Req_Value(&Merge3);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem13'
     */
    /* Outputs for Atomic SubSystem: '<S3821>/DigitalLowpassResetEnabled2' */
    /* Update for UnitDelay: '<S3828>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_avt = VeTHMR_T_MtrC_CntrlBoardTemp_Fltr;

    /* End of Outputs for SubSystem: '<S3821>/DigitalLowpassResetEnabled2' */

    /* Switch: '<S3821>/Switch5' incorporates:
     *  Constant: '<S3830>/Calib'
     */
    if (KeTHMR_b_MtrC_CntrlBoardTemp_Fltr_Sel)
    {
        /* Switch: '<S3821>/Switch5' */
        VeTHMR_T_MtrC_CntrlBoardTemp_AF = VeTHMR_T_MtrC_CntrlBoardTemp_Fltr;
    }
    else
    {
        /* Switch: '<S3821>/Switch5' */
        VeTHMR_T_MtrC_CntrlBoardTemp_AF = VeTHMR_T_MtrC_CntrlBoardTemp;
    }

    /* End of Switch: '<S3821>/Switch5' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem12'
     */
    /* Switch: '<S76>/Switch2' incorporates:
     *  Constant: '<S3804>/Calib'
     */
    if (KeTHMR_b_HVDspt_Enbl_SD)
    {
        /* Switch: '<S76>/Switch2' incorporates:
         *  Constant: '<S3803>/Calib'
         */
        Switch2_e = KeTHMR_b_HVDspt_Enbl_D;
    }

    /* End of Switch: '<S76>/Switch2' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCV_Learning_Enbl'
     */
    /* Logic: '<S2120>/Logical1' incorporates:
     *  Constant: '<S2133>/Constant'
     *  Constant: '<S2134>/Constant'
     *  Constant: '<S2135>/Calib'
     *  Constant: '<S2136>/Calib'
     *  Constant: '<S2137>/Calib'
     *  Constant: '<S2148>/Calib'
     *  Constant: '<S2149>/Constant'
     *  Constant: '<S2150>/Calib'
     *  Constant: '<S2151>/Constant'
     *  Constant: '<S2152>/Constant'
     *  Constant: '<S2153>/Constant'
     *  Constant: '<S2154>/Calib'
     *  Constant: '<S2155>/Calib'
     *  Constant: '<S2156>/Constant'
     *  Constant: '<S2157>/Calib'
     *  Logic: '<S2125>/Logical1'
     *  Logic: '<S2125>/Logical3'
     *  Logic: '<S2125>/Logical4'
     *  Logic: '<S2126>/Logical3'
     *  Logic: '<S2128>/Logical4'
     *  Logic: '<S2129>/Logical5'
     *  Logic: '<S2130>/Logical1'
     *  Logic: '<S2130>/Logical2'
     *  Logic: '<S2130>/Logical7'
     *  Logic: '<S2130>/Logical8'
     *  Logic: '<S2131>/Logical6'
     *  RelationalOperator: '<S2125>/Comparison1'
     *  RelationalOperator: '<S2125>/Comparison2'
     *  RelationalOperator: '<S2126>/Comparison1'
     *  RelationalOperator: '<S2128>/Comparison2'
     *  RelationalOperator: '<S2129>/Comparison3'
     *  RelationalOperator: '<S2130>/Comparison1'
     *  RelationalOperator: '<S2130>/Comparison5'
     *  RelationalOperator: '<S2130>/Comparison6'
     *  RelationalOperator: '<S2131>/Comparison4'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     *  SignalConversion generated from: '<S2>/VeTPCR_e_ThrmPerWup_State'
     *  Switch: '<S4586>/Switch1'
     */
    VeTHMR_b_LearningOk = (((((((KeTHMR_b_HTCV_LearnOk_BatCondDsb) ||
        (((KeTHMR_b_HTCV_LearnOkDsb_BatBalancin) || (CeTHMR_e_Balancing ==
        ((uint32)VeTHMR_e_BatThrmlSt_B4D))) || (((uint32)VeTHMR_e_BatThrmlSt_B4D)
        == CeTHMR_e_NoConditioning))) && ((!rtb_TmpSignalConversionAtVeCT_o) ||
        (KeTHMR_b_HTCV_LearnOkCab_HeatReqDsbl))) && ((!VeTHMR_b_AC_CompReq) ||
        (KeTHMR_b_HTCV_LearnOkCab_CoolReqDsbl))) && ((((uint32)
        rtb_TmpSignalConversionAtVePD_l) == CePDTR_e_No_Dischrg) ||
        (KeTHMR_b_HTCV_LearnOkBat_OV_Dsbl))) && ((((CeTPCR_e_OkCabinPrec !=
        ((uint32)rtb_TmpSignalConversionAtVeTP_b)) || ((((uint32)
        rtb_TmpSignalConversionAtVeTP_b) != CeTPCR_e_CabinPrec_SP_Reached) &&
        (KeTHMR_b_EnblCabPrecSPR_HTCVLrn))) && (((uint32)
        rtb_TmpSignalConversionAtVeTP_b) != CeTPCR_e_CabinPrec_Dflt)) ||
        (KeTHMR_b_HTCV_LearnOk_RS_Dsbl))) && ((((uint32)
        rtb_TmpSignalConversionAtVeTP_d) == CeTPCR_e_Default_PerWup) ||
                            (KeTHMR_b_HTCV_LearnOkPeriod_WpDsbl)));

    /* Logic: '<S2120>/Logical3' incorporates:
     *  Constant: '<S2115>/Constant1'
     *  Constant: '<S2115>/Constant2'
     *  Constant: '<S2116>/Constant1'
     *  Constant: '<S2116>/Constant2'
     *  Constant: '<S2117>/Constant1'
     *  Constant: '<S2117>/Constant2'
     *  Constant: '<S2138>/Constant1'
     *  Constant: '<S2138>/Constant2'
     *  Constant: '<S2139>/Constant1'
     *  Constant: '<S2139>/Constant2'
     *  Constant: '<S2144>/Calib'
     *  Constant: '<S2145>/Calib'
     *  Constant: '<S2146>/Calib'
     *  Constant: '<S2147>/Calib'
     *  DataStoreRead: '<S2115>/StatusByte_CoolantVlvA_CktHi'
     *  DataStoreRead: '<S2116>/StatusByte_CoolantVlvA_CktLo'
     *  DataStoreRead: '<S2117>/StatusByte_CoolantVlvA_Ckt'
     *  DataStoreRead: '<S2138>/StatusByte_CoolantVlvA_Perf'
     *  DataStoreRead: '<S2139>/StatusByte_CoolantVlvA_StkOpn'
     *  Logic: '<S2115>/Logical Operator'
     *  Logic: '<S2116>/Logical Operator'
     *  Logic: '<S2117>/Logical Operator'
     *  Logic: '<S2127>/Logical1'
     *  Logic: '<S2138>/Logical Operator'
     *  Logic: '<S2139>/Logical Operator'
     *  Logic: '<S2140>/Logical2'
     *  Logic: '<S2140>/Logical6'
     *  Logic: '<S2141>/Logical2'
     *  Logic: '<S2141>/Logical6'
     *  Logic: '<S2142>/Logical2'
     *  Logic: '<S2142>/Logical6'
     *  Logic: '<S2143>/Logical2'
     *  Logic: '<S2143>/Logical6'
     *  Logic: '<S58>/Logical1'
     *  RelationalOperator: '<S2115>/Relational Operator1'
     *  RelationalOperator: '<S2115>/Relational Operator2'
     *  RelationalOperator: '<S2116>/Relational Operator1'
     *  RelationalOperator: '<S2116>/Relational Operator2'
     *  RelationalOperator: '<S2117>/Relational Operator1'
     *  RelationalOperator: '<S2117>/Relational Operator2'
     *  RelationalOperator: '<S2138>/Relational Operator1'
     *  RelationalOperator: '<S2138>/Relational Operator2'
     *  RelationalOperator: '<S2139>/Relational Operator1'
     *  RelationalOperator: '<S2139>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S2115>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2115>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S2116>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2116>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S2117>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2117>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S2138>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2138>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S2139>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2139>/Bitwise Operator2'
     */
    VeTHMR_b_HTCV_LearnCheckdRaw = ((VeTHMR_b_LearningOk) &&
        (((((!VeTHMR_b_HT_CabVlvSts_FA_AD) ||
            (KeTHMR_b_HTCV_LearnOkPeriod_Sts_FA_Dsbl)) && ((((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_StkOpn) & 1U) == 0U) || ((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_StkOpn) & 64U) != 0U)) ||
        (KeTHMR_b_HTCV_LearnOkPeriod_LeakFltDsbl))) && ((((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_Perf) & 1U) == 0U) || ((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_Perf) & 64U) != 0U)) ||
        (KeTHMR_b_HTCV_LearnOkPeriod_StuckFltDsbl))) && ((((((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_Ckt) & 1U) == 0U) || ((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_Ckt) & 64U) != 0U)) && (((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_CktLo) & 1U) == 0U) || ((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_CktLo) & 64U) != 0U))) && (((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_CktHi) & 1U) == 0U) || ((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_CktHi) & 64U) != 0U))) ||
        (KeTHMR_b_HTCV_LearnOkPeriod_WpDsbl))));

    /* Outputs for Atomic SubSystem: '<S2120>/EdgeRising1' */
    /* Logic: '<S2122>/AND' incorporates:
     *  Logic: '<S2122>/OR1'
     *  UnitDelay: '<S2122>/UnitDelay'
     *  UnitDelay: '<S58>/UnitDelay1'
     */
    rtb_AND_c3 = ((THMR_ac_DW.UnitDelay1_DSTATE_co) &&
                  (!THMR_ac_DW.UnitDelay_DSTATE_muu));

    /* Update for UnitDelay: '<S2122>/UnitDelay' incorporates:
     *  UnitDelay: '<S58>/UnitDelay1'
     */
    THMR_ac_DW.UnitDelay_DSTATE_muu = THMR_ac_DW.UnitDelay1_DSTATE_co;

    /* End of Outputs for SubSystem: '<S2120>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S2120>/CountDownResetTriggerEnabled1' */
    /* Outputs for Atomic SubSystem: '<S2121>/EdgeRising' */
    /* Logic: '<S2132>/OR1' incorporates:
     *  UnitDelay: '<S2132>/UnitDelay'
     */
    rtb_OR1_g4 = !THMR_ac_DW.UnitDelay_DSTATE_ptb;

    /* Update for UnitDelay: '<S2132>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ptb = rtb_AND_c3;

    /* Switch: '<S2121>/Switch1' incorporates:
     *  Constant: '<S2121>/ConstantValue'
     *  Logic: '<S2121>/AND'
     *  Logic: '<S2132>/AND'
     *  RelationalOperator: '<S2121>/GreaterThan'
     *  Switch: '<S2121>/Switch2'
     *  UnitDelay: '<S2121>/UnitDelay'
     *  UnitDelay: '<S58>/UnitDelay1'
     */
    if (rtb_AND_c3 && rtb_OR1_g4)
    {
        /* Switch: '<S2121>/Switch1' incorporates:
         *  Constant: '<S2124>/Calib'
         */
        rtb_Switch1_l3 = KeTHMR_t_HTCV_LearnOnWait_Tim;
    }
    else if ((THMR_ac_DW.UnitDelay1_DSTATE_co) &&
             (THMR_ac_DW.UnitDelay_DSTATE_my > 0.0F))
    {
        /* Switch: '<S2121>/Switch2' incorporates:
         *  Constant: '<S2121>/ConstantValue1'
         *  Sum: '<S2121>/Subtraction'
         *  Switch: '<S2121>/Switch1'
         *  UnitDelay: '<S2121>/UnitDelay'
         */
        rtb_Switch1_l3 = THMR_ac_DW.UnitDelay_DSTATE_my - 1.0F;
    }
    else
    {
        /* Switch: '<S2121>/Switch1' incorporates:
         *  Switch: '<S2121>/Switch2'
         *  UnitDelay: '<S2121>/UnitDelay'
         */
        rtb_Switch1_l3 = THMR_ac_DW.UnitDelay_DSTATE_my;
    }

    /* End of Switch: '<S2121>/Switch1' */
    /* End of Outputs for SubSystem: '<S2121>/EdgeRising' */

    /* Update for UnitDelay: '<S2121>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_my = rtb_Switch1_l3;

    /* Logic: '<S2120>/Logical2' incorporates:
     *  Constant: '<S2121>/ConstantValue2'
     *  Constant: '<S2123>/Calib'
     *  Logic: '<S2120>/Logical9'
     *  RelationalOperator: '<S2121>/GreaterThan1'
     */
    VeTHMR_b_HTCV_LearnCheckd = ((VeTHMR_b_HTCV_LearnCheckdRaw) ||
        ((rtb_Switch1_l3 > 0.0F) && (KeTHMR_b_HTCV_LearnOnWait_Dsbl)));

    /* End of Outputs for SubSystem: '<S2120>/CountDownResetTriggerEnabled1' */

    /* Outputs for IfAction SubSystem: '<S58>/HTCV_LearningDsbl' incorporates:
     *  ActionPort: '<S2118>/ActionPort'
     */
    /* Outputs for IfAction SubSystem: '<S58>/HTCV_LearningEnb' incorporates:
     *  ActionPort: '<S2119>/ActionPort'
     */
    /* If: '<S58>/If1' incorporates:
     *  Logic: '<S58>/Logical2'
     *  Merge: '<S58>/Merge3'
     *  RelationalOperator: '<S58>/Comparison8'
     *  SignalConversion generated from: '<S2118>/HTCV_LearnDisbl'
     *  SignalConversion generated from: '<S2119>/HTCV_LearnEnb'
     */
    Merge3 = (Merge3 && (VeTHMR_b_HTCV_LearnCheckd));

    /* End of Outputs for SubSystem: '<S58>/HTCV_LearningEnb' */
    /* End of Outputs for SubSystem: '<S58>/HTCV_LearningDsbl' */

    /* Update for UnitDelay: '<S58>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_co = Merge3;

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Cell_Min_Max_Temp_Used'
     */
    /* Logic: '<S405>/Logical9' incorporates:
     *  RelationalOperator: '<S405>/Comparison1'
     *  RelationalOperator: '<S405>/Comparison2'
     */
    rtb_AND_c3 = (rtb_TmpSignalConversionAtVePD_p &&
                  (!rtb_TmpSignalConversionAtVePD_i));

    /* Logic: '<S405>/Logical10' incorporates:
     *  RelationalOperator: '<S405>/Comparison13'
     *  RelationalOperator: '<S405>/Comparison14'
     */
    rtb_OR1_g4 = ((!rtb_TmpSignalConversionAtVePD_p) &&
                  rtb_TmpSignalConversionAtVePD_i);

    /* Logic: '<S405>/Logical12' incorporates:
     *  RelationalOperator: '<S405>/Comparison15'
     *  RelationalOperator: '<S405>/Comparison16'
     */
    rtb_TmpSignalConversionAtVePD_p = (rtb_TmpSignalConversionAtVePD_p &&
        rtb_TmpSignalConversionAtVePD_i);

    /* Logic: '<S405>/Logical16' incorporates:
     *  Constant: '<S467>/Constant'
     *  Constant: '<S468>/Constant'
     *  Constant: '<S483>/Calib'
     *  Logic: '<S405>/Logical17'
     *  RelationalOperator: '<S405>/Comparison18'
     *  RelationalOperator: '<S405>/Comparison19'
     */
    rtb_TmpSignalConversionAtVePD_i = ((((uint32)rtb_TmpSignalConversionAtVeTP_e)
        == CeTPCR_e_RacePrepActiveTrack) || ((((uint32)
        rtb_TmpSignalConversionAtVeTP_e) == CeTPCR_e_RacePrepSPRTrack) &&
        (KeTHMR_b_EnblRacePrepTrack_VehThrmlSt)));

    /* Logic: '<S405>/Logical18' incorporates:
     *  Constant: '<S470>/Constant'
     *  Constant: '<S471>/Constant'
     *  Constant: '<S482>/Calib'
     *  Logic: '<S405>/Logical19'
     *  RelationalOperator: '<S405>/Comparison20'
     *  RelationalOperator: '<S405>/Comparison21'
     */
    rtb_Logical18_d = ((((uint32)rtb_TmpSignalConversionAtVeTP_e) ==
                        CeTPCR_e_RacePrepActiveDrag) || ((((uint32)
                          rtb_TmpSignalConversionAtVeTP_e) ==
                         CeTPCR_e_RacePrepSPRDrag) &&
                        (KeTHMR_b_EnblRacePrepDrag_VehThrmlSt)));

    /* RelationalOperator: '<S405>/Comparison8' incorporates:
     *  SignalConversion generated from: '<S405>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblCabPrecSPR_VehThrmlSt

    /* Switch: '<S404>/Switch' incorporates:
     *  Constant: '<S452>/Constant'
     */
    rtb_Switch_hql = (((uint32)rtb_TmpSignalConversionAtVeTP_b) ==
                      CeTPCR_e_CabinPrec_SP_Reached);

#else

    /* Switch: '<S404>/Switch' incorporates:
     *  Constant: '<S405>/Constant'
     *  SignalConversion generated from: '<S405>/VariantSource'
     */
    rtb_Switch_hql = false;

#endif

    /* End of RelationalOperator: '<S405>/Comparison8' */

    /* Logic: '<S405>/Logical7' incorporates:
     *  Logic: '<S405>/Logical14'
     */
    rtb_AND_fe = !rtb_TmpSignalConversionAtPropSy;

    /* Logic: '<S405>/Logical6' incorporates:
     *  Constant: '<S451>/Constant'
     *  Logic: '<S405>/Logical1'
     *  Logic: '<S405>/Logical11'
     *  Logic: '<S405>/Logical7'
     *  RelationalOperator: '<S405>/Comparison7'
     */
    rtb_Logical6_or = ((((((uint32)rtb_TmpSignalConversionAtVeTP_b) ==
                          CeTPCR_e_OkCabinPrec) || rtb_Switch_hql) ||
                        rtb_TmpSignalConversionAtVeTP_c) && (rtb_AND_fe &&
                        (!VeTHMR_b_PlugdIn_Or_Chrg)));

    /* RelationalOperator: '<S405>/Comparison3' incorporates:
     *  Constant: '<S447>/Constant'
     *  Switch: '<S49>/Switch'
     */
    rtb_Comparison3_bu = (CeOBCR_e_ChargingLvlAC1 == ((uint32)
                           VeTHMR_e_ChargingLevel_AD));

    /* RelationalOperator: '<S405>/Comparison4' incorporates:
     *  Constant: '<S448>/Constant'
     *  RelationalOperator: '<S405>/Comparison3'
     *  Switch: '<S49>/Switch'
     */
    rtb_Comparison4_cx = (CeOBCR_e_ChargingLvlAC2 == ((uint32)
                           VeTHMR_e_ChargingLevel_AD));

    /* RelationalOperator: '<S405>/Comparison6' incorporates:
     *  Constant: '<S449>/Constant'
     *  RelationalOperator: '<S405>/Comparison3'
     *  Switch: '<S49>/Switch'
     */
    rtb_Comparison6_n3 = (CeOBCR_e_ChargingLvlDC2 == ((uint32)
                           VeTHMR_e_ChargingLevel_AD));

    /* Logic: '<S405>/Logical13' incorporates:
     *  Constant: '<S466>/Constant'
     *  Constant: '<S481>/Calib'
     *  Constant: '<S485>/Calib'
     *  Logic: '<S405>/Logical15'
     *  RelationalOperator: '<S405>/Comparison17'
     *  SignalConversion generated from: '<S2>/VeVTLR_e_DschrgSysSts'
     */
    rtb_AND_ko5 = ((((KeTHMR_b_OffBoardPwrPnlPrsnt) || rtb_AND_fe) && (((uint32)
                      rtb_TmpSignalConversionAtVeVTLR) == CeVTLR_e_DschrgActv)) &&
                   (KeTHMR_b_DschrgActvEnbl_VehThrmlSt));

    /* RelationalOperator: '<S405>/Comparison5' incorporates:
     *  Constant: '<S484>/Calib'
     *  Switch: '<S405>/Switch1'
     */
    rtb_Comparison5_c3m = ((KeTHMR_b_Loadshed_Slct_New) &&
                           (VeTHMR_b_ThrmLoad_Shed));

    /* Switch: '<S404>/Switch' incorporates:
     *  Constant: '<S460>/Constant'
     *  Constant: '<S461>/Constant'
     *  Constant: '<S486>/Calib'
     *  Logic: '<S405>/Logical3'
     *  Logic: '<S405>/Logical4'
     *  RelationalOperator: '<S405>/Comparison10'
     *  RelationalOperator: '<S405>/Comparison9'
     */
    rtb_Switch_hql = ((((uint32)rtb_TmpSignalConversionAtVeTP_g) ==
                       CeTPCR_e_ProactiveCondOn) || ((((uint32)
                         rtb_TmpSignalConversionAtVeTP_g) ==
                        CeTPCR_e_ProactiveCondSPR) &&
                       (KeTHMR_b_ProactiveCondSPREnbl)));

    /* Logic: '<S405>/Logical5' incorporates:
     *  Constant: '<S459>/Constant'
     *  RelationalOperator: '<S405>/Comparison11'
     */
    rtb_Logical5_bn = (rtb_Switch_hql && (((uint32)
                         rtb_TmpSignalConversionAtVeT_h0) ==
                        CeTPCR_e_ActiveProactiveCond));

    /* Logic: '<S405>/Logical8' incorporates:
     *  Constant: '<S458>/Constant'
     *  RelationalOperator: '<S405>/Comparison12'
     */
    rtb_Switch_hql = (rtb_Switch_hql && (((uint32)
                        rtb_TmpSignalConversionAtVeT_h0) ==
                       CeTPCR_e_PassiveProativeCond));

    /* Outputs for Atomic SubSystem: '<S403>/Hysteresis1' */
    /* Switch: '<S411>/Switch1' incorporates:
     *  Constant: '<S414>/Calib'
     *  RelationalOperator: '<S411>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeBTRR > KeTHMR_T_BattWrm_EnblHVACPriorty)
    {
        /* Switch: '<S411>/Switch1' incorporates:
         *  Constant: '<S411>/ConstantValue'
         */
        rtb_AND_jo = true;
    }
    else
    {
        /* Switch: '<S411>/Switch1' incorporates:
         *  Constant: '<S413>/Calib'
         *  RelationalOperator: '<S411>/GreaterThan1'
         *  UnitDelay: '<S411>/UnitDelay'
         */
        rtb_AND_jo = ((rtb_TmpSignalConversionAtVeBTRR >=
                       KeTHMR_T_BattHot_DsblHVACPriority) &&
                      (THMR_ac_DW.UnitDelay_DSTATE_jbe));
    }

    /* End of Switch: '<S411>/Switch1' */

    /* Update for UnitDelay: '<S411>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_jbe = rtb_AND_jo;

    /* End of Outputs for SubSystem: '<S403>/Hysteresis1' */

    /* Outputs for Atomic SubSystem: '<S403>/TurnOffDelaySampleModified1' */
    /* Outputs for Atomic SubSystem: '<S418>/EdgeFalling1' */
    /* Logic: '<S443>/OR1' incorporates:
     *  Logic: '<S418>/AND'
     */
    rtb_AND_fe = !rtb_AND_jo;

    /* Logic: '<S443>/AND' incorporates:
     *  Logic: '<S443>/OR1'
     *  UnitDelay: '<S443>/UnitDelay'
     */
    rtb_AND_eb = (rtb_AND_fe && (THMR_ac_DW.UnitDelay_DSTATE_mz5));

    /* Update for UnitDelay: '<S443>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_mz5 = rtb_AND_jo;

    /* End of Outputs for SubSystem: '<S418>/EdgeFalling1' */

    /* Switch: '<S418>/Switch' incorporates:
     *  MinMax: '<S418>/Minimum1'
     *  UnitDelay: '<S418>/UnitDelay'
     */
    if (rtb_AND_eb)
    {
        /* Switch: '<S418>/Switch' incorporates:
         *  Constant: '<S412>/Calib'
         */
        rtb_Switch_i3 = KeTHMR_Cnt_BattPriority_KeepBattCond;
    }
    else
    {
        if (((sint32)THMR_ac_DW.UnitDelay_DSTATE_cj) > 1)
        {
            /* MinMax: '<S418>/Minimum1' incorporates:
             *  UnitDelay: '<S418>/UnitDelay'
             */
            u1 = THMR_ac_DW.UnitDelay_DSTATE_cj;
        }
        else
        {
            /* MinMax: '<S418>/Minimum1' */
            u1 = 1U;
        }

        /* Switch: '<S418>/Switch' incorporates:
         *  Constant: '<S418>/ConstantValue'
         *  Sum: '<S418>/Summation'
         */
        rtb_Switch_i3 = (uint16)((sint32)(((sint32)u1) - 1));
    }

    /* End of Switch: '<S418>/Switch' */
    /* End of Outputs for SubSystem: '<S403>/TurnOffDelaySampleModified1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeTAIR_T_FtEvapTmp_Tgt' */
    (void)Rte_Read_VeTAIR_T_FtEvapTmp_Tgt_Value(&rtb_Add_h);

    /* Inport: '<Root>/VeACCR_b_eAC4CabInhibtd' */
    (void)Rte_Read_VeACCR_b_eAC4CabInhibtd_Value(&rtb_AND_fb);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Cell_Min_Max_Temp_Used'
     */
    /* Outputs for Atomic SubSystem: '<S403>/TurnOffDelaySampleModified1' */
    /* Update for UnitDelay: '<S418>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_cj = rtb_Switch_i3;

    /* Logic: '<S403>/Logical1' incorporates:
     *  Constant: '<S409>/Constant'
     *  Constant: '<S418>/ConstantValue2'
     *  Logic: '<S403>/LogicalOperator'
     *  Logic: '<S403>/LogicalOperator1'
     *  Logic: '<S418>/AND'
     *  Lookup_n-D: '<S419>/Vector'
     *  RelationalOperator: '<S409>/Comparison4'
     *  RelationalOperator: '<S418>/GreaterThan'
     *  Rounding: '<S409>/Rounding3'
     *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
     *  SignalConversion generated from: '<S2>/VeTAIR_Pct_FrtBlwrCmd'
     */
    VeTHMR_b_EnblHVACPriorty = ((((VeTHMR_b_AC_CompReq) && (ceilf
        (look2_iflf_binlcapw(rtb_TmpSignalConversionAtVeTA_b,
        TmpSignalConversionAtOutAirTemp, ((const float32 *)
        &(KxTHMR_r_EnblBattCabPrty_BlwrAmb[0])), ((const float32 *)
        &(KyTHMR_r_EnblBattCabPrty_BlwrAmb[0])), ((const float32 *)
        &(KtTHMR_r_EnblBattCabPrty_BlwrAmb[0])), THMR_ac_ConstP.Vector_maxIndex,
        8U)) >= 1.0F)) && (rtb_AND_fe && (((sint32)rtb_Switch_i3) <= 0))) &&
        (!rtb_AND_fb));

    /* End of Outputs for SubSystem: '<S403>/TurnOffDelaySampleModified1' */

    /* Sum: '<S403>/Add' */
    rtb_Add_h = rtb_TmpSignalConversionAtVeT_j5 - rtb_Add_h;

    /* If: '<S403>/If1' */
    rtPrevAction = THMR_ac_DW.If1_ActiveSubsystem;
    rtAction = (sint8)((!VeTHMR_b_EnblHVACPriorty) ? 1 : 0);
    THMR_ac_DW.If1_ActiveSubsystem = rtAction;
    if (rtAction == 0)
    {
        if (0 != rtPrevAction)
        {
            /* SystemReset for IfAction SubSystem: '<S403>/CabinPriority' incorporates:
             *  ActionPort: '<S410>/ActionPort'
             */
            /* SystemReset for Atomic SubSystem: '<S410>/EdgeRising2' */
            /* SystemReset for If: '<S403>/If1' incorporates:
             *  UnitDelay: '<S424>/UnitDelay'
             *  UnitDelay: '<S425>/UnitDelay'
             *  UnitDelay: '<S431>/UnitDelay1'
             *  UnitDelay: '<S431>/UnitDelay3'
             *  UnitDelay: '<S433>/UnitDelay'
             *  UnitDelay: '<S434>/UnitDelay'
             *  UnitDelay: '<S435>/FixPtUnitDelay1'
             *  UnitDelay: '<S435>/FixPtUnitDelay2'
             *  UnitDelay: '<S436>/FixPtUnitDelay1'
             *  UnitDelay: '<S436>/FixPtUnitDelay2'
             *  UnitDelay: '<S437>/UnitDelay1'
             *  UnitDelay: '<S437>/UnitDelay3'
             *  UnitDelay: '<S439>/UnitDelay'
             *  UnitDelay: '<S440>/UnitDelay'
             *  UnitDelay: '<S441>/FixPtUnitDelay1'
             *  UnitDelay: '<S441>/FixPtUnitDelay2'
             *  UnitDelay: '<S442>/FixPtUnitDelay1'
             *  UnitDelay: '<S442>/FixPtUnitDelay2'
             */
            THMR_ac_DW.UnitDelay_DSTATE_ef = false;

            /* End of SystemReset for SubSystem: '<S410>/EdgeRising2' */

            /* SystemReset for Atomic SubSystem: '<S422>/Debounce1' */
            THMR_ac_DW.UnitDelay3_DSTATE_fa = false;
            THMR_ac_DW.UnitDelay1_DSTATE_bz = false;
            THMR_ac_DW.FixPtUnitDelay2_DSTATE_gt = 0U;
            THMR_ac_DW.FixPtUnitDelay1_DSTATE_cz = 0U;
            THMR_ac_DW.FixPtUnitDelay2_DSTATE_lz = 0U;
            THMR_ac_DW.FixPtUnitDelay1_DSTATE_l = false;

            /* SystemReset for Atomic SubSystem: '<S431>/EdgeBi' */
            THMR_ac_DW.UnitDelay_DSTATE_mdt = false;

            /* End of SystemReset for SubSystem: '<S431>/EdgeBi' */

            /* SystemReset for Atomic SubSystem: '<S431>/SignalLatchOnWithReset1' */
            THMR_ac_DW.UnitDelay_DSTATE_eg = false;

            /* End of SystemReset for SubSystem: '<S431>/SignalLatchOnWithReset1' */
            /* End of SystemReset for SubSystem: '<S422>/Debounce1' */

            /* SystemReset for Atomic SubSystem: '<S423>/Debounce2' */
            THMR_ac_DW.UnitDelay3_DSTATE_plm = false;
            THMR_ac_DW.UnitDelay1_DSTATE_c4 = false;
            THMR_ac_DW.FixPtUnitDelay2_DSTATE_bh = 0U;
            THMR_ac_DW.FixPtUnitDelay1_DSTATE_bx = 0U;
            THMR_ac_DW.FixPtUnitDelay2_DSTATE_k = 0U;
            THMR_ac_DW.FixPtUnitDelay1_DSTATE_e = false;

            /* SystemReset for Atomic SubSystem: '<S437>/EdgeBi' */
            THMR_ac_DW.UnitDelay_DSTATE_om = false;

            /* End of SystemReset for SubSystem: '<S437>/EdgeBi' */

            /* SystemReset for Atomic SubSystem: '<S437>/SignalLatchOnWithReset' */
            THMR_ac_DW.UnitDelay_DSTATE_mkj = false;

            /* End of SystemReset for SubSystem: '<S437>/SignalLatchOnWithReset' */
            /* End of SystemReset for SubSystem: '<S423>/Debounce2' */

            /* SystemReset for Atomic SubSystem: '<S410>/EdgeRising1' */
            THMR_ac_DW.UnitDelay_DSTATE_ns = false;

            /* End of SystemReset for SubSystem: '<S410>/EdgeRising1' */
            /* End of SystemReset for SubSystem: '<S403>/CabinPriority' */
        }

        /* Outputs for IfAction SubSystem: '<S403>/CabinPriority' incorporates:
         *  ActionPort: '<S410>/ActionPort'
         */
        /* Outputs for Atomic SubSystem: '<S410>/EdgeRising2' */
        /* Logic: '<S425>/AND' incorporates:
         *  Constant: '<S427>/Calib'
         *  Logic: '<S425>/OR1'
         *  UnitDelay: '<S425>/UnitDelay'
         */
        rtb_AND_fb = ((KeTHMR_b_ResetCabPriortyDbnc) &&
                      (!THMR_ac_DW.UnitDelay_DSTATE_ef));

        /* Update for UnitDelay: '<S425>/UnitDelay' incorporates:
         *  Constant: '<S427>/Calib'
         */
        THMR_ac_DW.UnitDelay_DSTATE_ef = KeTHMR_b_ResetCabPriortyDbnc;

        /* End of Outputs for SubSystem: '<S410>/EdgeRising2' */

        /* Logic: '<S410>/LogicalOperator2' incorporates:
         *  Logic: '<S410>/LogicalOperator3'
         *  Lookup_n-D: '<S430>/Vector'
         *  RelationalOperator: '<S410>/Comparison2'
         *  SignalConversion generated from: '<S2>/VeTAIR_Pct_FrtBlwrCmd'
         */
        rtb_AND_fb = ((!rtb_AND_fb) && (rtb_Add_h <= look1_iflf_binlcapw
                       (rtb_TmpSignalConversionAtVeTA_b, ((const float32 *)
                         &(KxTHMR_dT_CabPriorty_Blwr_EvapErrLow[0])), ((const
                          float32 *)&(KtTHMR_dT_CabPriorty_Blwr_EvapErrLow[0])),
                        5U)));

        /* Outputs for Atomic SubSystem: '<S422>/Debounce1' */
        /* Outputs for Atomic SubSystem: '<S431>/EdgeBi' */
        /* RelationalOperator: '<S433>/NotEqual' incorporates:
         *  UnitDelay: '<S433>/UnitDelay'
         */
        rtb_AND_jo = (rtb_AND_fb != THMR_ac_DW.UnitDelay_DSTATE_mdt);

        /* Update for UnitDelay: '<S433>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_mdt = rtb_AND_fb;

        /* End of Outputs for SubSystem: '<S431>/EdgeBi' */

        /* Logic: '<S431>/Logical1' incorporates:
         *  UnitDelay: '<S431>/UnitDelay1'
         */
        rtb_AND_eb = (rtb_AND_jo || (THMR_ac_DW.UnitDelay1_DSTATE_bz));

        /* Outputs for Atomic SubSystem: '<S431>/SignalLatchOnWithReset1' */
        /* Logic: '<S434>/OR1' incorporates:
         *  Logic: '<S434>/NOT'
         *  Logic: '<S434>/OR'
         *  UnitDelay: '<S431>/UnitDelay3'
         *  UnitDelay: '<S434>/UnitDelay'
         */
        rtb_AND_g2 = ((THMR_ac_DW.UnitDelay3_DSTATE_fa) || ((!rtb_AND_eb) &&
                       (THMR_ac_DW.UnitDelay_DSTATE_eg)));

        /* Update for UnitDelay: '<S434>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_eg = rtb_AND_g2;

        /* End of Outputs for SubSystem: '<S431>/SignalLatchOnWithReset1' */

        /* Switch: '<S436>/Init' incorporates:
         *  Constant: '<S436>/InitialCondition'
         *  Logic: '<S436>/FixPtLogicalOperator'
         *  Logic: '<S436>/Logical2'
         *  UnitDelay: '<S436>/FixPtUnitDelay1'
         *  UnitDelay: '<S436>/FixPtUnitDelay2'
         */
        if (rtb_AND_eb || (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_gt) == 0))
        {
            rtb_Switch_i3 = 0U;
        }
        else
        {
            rtb_Switch_i3 = THMR_ac_DW.FixPtUnitDelay1_DSTATE_cz;
        }

        /* End of Switch: '<S436>/Init' */

        /* Switch: '<S442>/Init' incorporates:
         *  Sum: '<S431>/Sum1'
         *  Switch: '<S431>/Switch2'
         */
        rtb_Switch_i3 = (uint16)(((uint32)(rtb_AND_g2 ? 1U : 0U)) + ((uint32)
            rtb_Switch_i3));

        /* RelationalOperator: '<S431>/Equal1' incorporates:
         *  Constant: '<S432>/Calib'
         */
        rtb_AND_g2 = (rtb_Switch_i3 >= KeTHMR_Cnt_CabPriorty_EnblBattCondDbnc);

        /* Switch: '<S431>/Switch' */
        if (!rtb_AND_g2)
        {
            /* Switch: '<S435>/Init' incorporates:
             *  Logic: '<S435>/Logical2'
             *  UnitDelay: '<S435>/FixPtUnitDelay2'
             */
            if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_lz) != 0)
            {
                /* Switch: '<S431>/Switch' incorporates:
                 *  UnitDelay: '<S435>/FixPtUnitDelay1'
                 */
                rtb_AND_fb = THMR_ac_DW.FixPtUnitDelay1_DSTATE_l;
            }

            /* End of Switch: '<S435>/Init' */
        }

        /* End of Switch: '<S431>/Switch' */

        /* Update for UnitDelay: '<S431>/UnitDelay3' */
        THMR_ac_DW.UnitDelay3_DSTATE_fa = rtb_AND_jo;

        /* Update for UnitDelay: '<S431>/UnitDelay1' */
        THMR_ac_DW.UnitDelay1_DSTATE_bz = rtb_AND_g2;

        /* Update for UnitDelay: '<S436>/FixPtUnitDelay2' incorporates:
         *  Constant: '<S436>/FixPtConstant'
         */
        THMR_ac_DW.FixPtUnitDelay2_DSTATE_gt = 1U;

        /* Switch: '<S436>/Reset' */
        if (rtb_AND_eb)
        {
            /* Update for UnitDelay: '<S436>/FixPtUnitDelay1' incorporates:
             *  Constant: '<S436>/InitialCondition'
             */
            THMR_ac_DW.FixPtUnitDelay1_DSTATE_cz = 0U;
        }
        else
        {
            /* Update for UnitDelay: '<S436>/FixPtUnitDelay1' */
            THMR_ac_DW.FixPtUnitDelay1_DSTATE_cz = rtb_Switch_i3;
        }

        /* End of Switch: '<S436>/Reset' */

        /* Update for UnitDelay: '<S435>/FixPtUnitDelay2' incorporates:
         *  Constant: '<S435>/FixPtConstant'
         */
        THMR_ac_DW.FixPtUnitDelay2_DSTATE_lz = 1U;

        /* Update for UnitDelay: '<S435>/FixPtUnitDelay1' */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_l = rtb_AND_fb;

        /* End of Outputs for SubSystem: '<S422>/Debounce1' */

        /* RelationalOperator: '<S410>/Comparison3' incorporates:
         *  Lookup_n-D: '<S429>/Vector'
         *  SignalConversion generated from: '<S2>/VeTAIR_Pct_FrtBlwrCmd'
         */
        rtb_AND_jo = (rtb_Add_h >= look1_iflf_binlcapw
                      (rtb_TmpSignalConversionAtVeTA_b, ((const float32 *)
                        &(KxTHMR_dT_CabPriorty_Blwr_EvapErrHigh[0])), ((const
                         float32 *)&(KtTHMR_dT_CabPriorty_Blwr_EvapErrHigh[0])),
                       5U));

        /* Outputs for Atomic SubSystem: '<S423>/Debounce2' */
        /* Outputs for Atomic SubSystem: '<S437>/EdgeBi' */
        /* RelationalOperator: '<S439>/NotEqual' incorporates:
         *  UnitDelay: '<S439>/UnitDelay'
         */
        rtb_AND_eb = (rtb_AND_jo != THMR_ac_DW.UnitDelay_DSTATE_om);

        /* Update for UnitDelay: '<S439>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_om = rtb_AND_jo;

        /* End of Outputs for SubSystem: '<S437>/EdgeBi' */

        /* Logic: '<S437>/Logical1' incorporates:
         *  UnitDelay: '<S437>/UnitDelay1'
         */
        rtb_AND_g2 = (rtb_AND_eb || (THMR_ac_DW.UnitDelay1_DSTATE_c4));

        /* Outputs for Atomic SubSystem: '<S437>/SignalLatchOnWithReset' */
        /* Logic: '<S440>/OR1' incorporates:
         *  Logic: '<S440>/NOT'
         *  Logic: '<S440>/OR'
         *  UnitDelay: '<S437>/UnitDelay3'
         *  UnitDelay: '<S440>/UnitDelay'
         */
        rtb_OR1_he = ((THMR_ac_DW.UnitDelay3_DSTATE_plm) || ((!rtb_AND_g2) &&
                       (THMR_ac_DW.UnitDelay_DSTATE_mkj)));

        /* Update for UnitDelay: '<S440>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_mkj = rtb_OR1_he;

        /* End of Outputs for SubSystem: '<S437>/SignalLatchOnWithReset' */

        /* Switch: '<S442>/Init' incorporates:
         *  Constant: '<S442>/InitialCondition'
         *  Logic: '<S442>/FixPtLogicalOperator'
         *  Logic: '<S442>/Logical2'
         *  UnitDelay: '<S442>/FixPtUnitDelay1'
         *  UnitDelay: '<S442>/FixPtUnitDelay2'
         */
        if (rtb_AND_g2 || (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_bh) == 0))
        {
            rtb_Switch_i3 = 0U;
        }
        else
        {
            rtb_Switch_i3 = THMR_ac_DW.FixPtUnitDelay1_DSTATE_bx;
        }

        /* End of Switch: '<S442>/Init' */

        /* Sum: '<S437>/Sum1' incorporates:
         *  Switch: '<S437>/Switch2'
         */
        rtb_Switch_i3 = (uint16)(((uint32)(rtb_OR1_he ? 1U : 0U)) + ((uint32)
            rtb_Switch_i3));

        /* RelationalOperator: '<S437>/Equal1' incorporates:
         *  Constant: '<S438>/Calib'
         */
        rtb_OR1_he = (rtb_Switch_i3 >= KeTHMR_Cnt_CabPriorty_DsblBattCondDbnc);

        /* Switch: '<S437>/Switch' */
        if (!rtb_OR1_he)
        {
            /* Switch: '<S441>/Init' incorporates:
             *  Logic: '<S441>/Logical2'
             *  UnitDelay: '<S441>/FixPtUnitDelay2'
             */
            if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_k) != 0)
            {
                /* Switch: '<S437>/Switch' incorporates:
                 *  UnitDelay: '<S441>/FixPtUnitDelay1'
                 */
                rtb_AND_jo = THMR_ac_DW.FixPtUnitDelay1_DSTATE_e;
            }

            /* End of Switch: '<S441>/Init' */
        }

        /* End of Switch: '<S437>/Switch' */

        /* Update for UnitDelay: '<S437>/UnitDelay3' */
        THMR_ac_DW.UnitDelay3_DSTATE_plm = rtb_AND_eb;

        /* Update for UnitDelay: '<S437>/UnitDelay1' */
        THMR_ac_DW.UnitDelay1_DSTATE_c4 = rtb_OR1_he;

        /* Update for UnitDelay: '<S442>/FixPtUnitDelay2' incorporates:
         *  Constant: '<S442>/FixPtConstant'
         */
        THMR_ac_DW.FixPtUnitDelay2_DSTATE_bh = 1U;

        /* Switch: '<S442>/Reset' */
        if (rtb_AND_g2)
        {
            /* Update for UnitDelay: '<S442>/FixPtUnitDelay1' incorporates:
             *  Constant: '<S442>/InitialCondition'
             */
            THMR_ac_DW.FixPtUnitDelay1_DSTATE_bx = 0U;
        }
        else
        {
            /* Update for UnitDelay: '<S442>/FixPtUnitDelay1' */
            THMR_ac_DW.FixPtUnitDelay1_DSTATE_bx = rtb_Switch_i3;
        }

        /* End of Switch: '<S442>/Reset' */

        /* Update for UnitDelay: '<S441>/FixPtUnitDelay2' incorporates:
         *  Constant: '<S441>/FixPtConstant'
         */
        THMR_ac_DW.FixPtUnitDelay2_DSTATE_k = 1U;

        /* Update for UnitDelay: '<S441>/FixPtUnitDelay1' */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_e = rtb_AND_jo;

        /* End of Outputs for SubSystem: '<S423>/Debounce2' */

        /* Outputs for Atomic SubSystem: '<S410>/EdgeRising1' */
        /* Logic: '<S424>/AND' incorporates:
         *  Constant: '<S426>/Calib'
         *  Logic: '<S424>/OR1'
         *  UnitDelay: '<S424>/UnitDelay'
         */
        rtb_AND_eb = ((KeTHMR_b_InitDfltCabPriorty) &&
                      (!THMR_ac_DW.UnitDelay_DSTATE_ns));

        /* Update for UnitDelay: '<S424>/UnitDelay' incorporates:
         *  Constant: '<S426>/Calib'
         */
        THMR_ac_DW.UnitDelay_DSTATE_ns = KeTHMR_b_InitDfltCabPriorty;

        /* End of Outputs for SubSystem: '<S410>/EdgeRising1' */

        /* If: '<S410>/If2' incorporates:
         *  Constant: '<S428>/Calib'
         *  Logic: '<S410>/LogicalOperator'
         *  RelationalOperator: '<S410>/Comparison1'
         */
        if (rtb_AND_fb && (rtb_TmpSignalConversionAtVeTA_n <=
                           KeTHMR_n_CabPriorty_MinEACrpmEnblBattCond))
        {
            /* Outputs for IfAction SubSystem: '<S410>/CabinCmftMet_NoPriority' incorporates:
             *  ActionPort: '<S421>/ActionPort'
             */
            THMR_ac_CabinCmftMet_NoPriority(&THMR_ac_B.Merge_n);

            /* End of Outputs for SubSystem: '<S410>/CabinCmftMet_NoPriority' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S410>/CabDemandHigh_Prioritize' incorporates:
             *  ActionPort: '<S420>/ActionPort'
             */
            /* Merge: '<S403>/Merge' incorporates:
             *  Logic: '<S410>/LogicalOperator1'
             *  SignalConversion generated from: '<S420>/Out1'
             */
            THMR_ac_B.Merge_n = ((rtb_AND_jo || rtb_AND_eb) ||
                                 (THMR_ac_B.Merge_n));

            /* End of Outputs for SubSystem: '<S410>/CabDemandHigh_Prioritize' */
        }

        /* End of If: '<S410>/If2' */
        /* End of Outputs for SubSystem: '<S403>/CabinPriority' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S403>/NoPriority' incorporates:
         *  ActionPort: '<S417>/ActionPort'
         */
        THMR_ac_CabinCmftMet_NoPriority(&THMR_ac_B.Merge_n);

        /* End of Outputs for SubSystem: '<S403>/NoPriority' */
    }

    /* End of If: '<S403>/If1' */

    /* Switch: '<S403>/Switch' incorporates:
     *  Constant: '<S416>/Calib'
     */
    if (KeTHMR_b_HVACPrrtyVhcleMode_DialSlct)
    {
        /* Switch: '<S403>/Switch' incorporates:
         *  Constant: '<S415>/Calib'
         */
        VeTHMR_b_HVACPrrtyVhcleMode_AfterDial = KeTHMR_b_HVACPrrtyVhcleMode_Dial;
    }
    else
    {
        /* Switch: '<S403>/Switch' */
        VeTHMR_b_HVACPrrtyVhcleMode_AfterDial = THMR_ac_B.Merge_n;
    }

    /* End of Switch: '<S403>/Switch' */

    /* Switch: '<S402>/Switch' incorporates:
     *  Constant: '<S408>/Calib'
     */
    if (KeTHMR_b_DefrostVhcleMode_DialSlct)
    {
        /* Switch: '<S402>/Switch' incorporates:
         *  Constant: '<S407>/Calib'
         */
        VeTHMR_b_DefrostVhclMode_AfterDial = KeTHMR_b_DefrostVhcleMode_Dial;
    }
    else
    {
        /* Switch: '<S402>/Switch' incorporates:
         *  Constant: '<S406>/Calib'
         *  Logic: '<S402>/Logical2'
         *  RelationalOperator: '<S402>/Comparison5'
         *  RelationalOperator: '<S402>/Comparison6'
         *  RelationalOperator: '<S402>/Comparison7'
         */
        VeTHMR_b_DefrostVhclMode_AfterDial = ((rtb_TmpSignalConversionAtPropSy &&
            (VeTHMR_b_Defrost)) && (TmpSignalConversionAtOutAirTemp <=
            KeTHMR_T_MaxDefrostAmb));
    }

    /* End of Switch: '<S402>/Switch' */

    /* Switch: '<S506>/Switch1' incorporates:
     *  Switch: '<S508>/Switch1'
     *  Switch: '<S514>/Switch1'
     *  Switch: '<S518>/Switch1'
     *  Switch: '<S520>/Switch1'
     *  Switch: '<S522>/Switch1'
     *  Switch: '<S524>/Switch1'
     *  Switch: '<S526>/Switch1'
     *  Switch: '<S528>/Switch1'
     *  Switch: '<S530>/Switch1'
     *  Switch: '<S532>/Switch1'
     *  Switch: '<S534>/Switch1'
     *  Switch: '<S536>/Switch1'
     *  Switch: '<S538>/Switch1'
     */
    if (rtb_AND_c3)
    {
        /* Switch: '<S506>/Switch1' incorporates:
         *  Constant: '<S405>/ConstantValue1'
         */
        VeTHMR_Cnt_VehThermSt = 13.0F;
    }
    else if (rtb_OR1_g4)
    {
        /* Switch: '<S508>/Switch1' incorporates:
         *  Constant: '<S405>/ConstantValue2'
         *  Switch: '<S506>/Switch1'
         */
        VeTHMR_Cnt_VehThermSt = 14.0F;
    }
    else if (rtb_TmpSignalConversionAtVePD_p)
    {
        /* Switch: '<S524>/Switch1' incorporates:
         *  Constant: '<S405>/ConstantValue20'
         *  Switch: '<S506>/Switch1'
         *  Switch: '<S508>/Switch1'
         */
        VeTHMR_Cnt_VehThermSt = 15.0F;
    }
    else if (rtb_TmpSignalConversionAtVePD_i)
    {
        /* Switch: '<S520>/Switch1' incorporates:
         *  Constant: '<S405>/ConstantValue21'
         *  Switch: '<S506>/Switch1'
         *  Switch: '<S508>/Switch1'
         *  Switch: '<S524>/Switch1'
         */
        VeTHMR_Cnt_VehThermSt = 16.0F;
    }
    else if (rtb_Logical18_d)
    {
        /* Switch: '<S522>/Switch1' incorporates:
         *  Constant: '<S405>/ConstantValue22'
         *  Switch: '<S506>/Switch1'
         *  Switch: '<S508>/Switch1'
         *  Switch: '<S520>/Switch1'
         *  Switch: '<S524>/Switch1'
         */
        VeTHMR_Cnt_VehThermSt = 17.0F;
    }
    else if (rtb_Logical6_or)
    {
        /* Switch: '<S526>/Switch1' incorporates:
         *  Constant: '<S405>/ConstantValue3'
         *  Switch: '<S506>/Switch1'
         *  Switch: '<S508>/Switch1'
         *  Switch: '<S520>/Switch1'
         *  Switch: '<S522>/Switch1'
         *  Switch: '<S524>/Switch1'
         */
        VeTHMR_Cnt_VehThermSt = 10.0F;
    }
    else if (rtb_Comparison3_bu)
    {
        /* Switch: '<S528>/Switch1' incorporates:
         *  Constant: '<S405>/ConstantValue4'
         *  Switch: '<S506>/Switch1'
         *  Switch: '<S508>/Switch1'
         *  Switch: '<S520>/Switch1'
         *  Switch: '<S522>/Switch1'
         *  Switch: '<S524>/Switch1'
         *  Switch: '<S526>/Switch1'
         */
        VeTHMR_Cnt_VehThermSt = 6.0F;
    }
    else if (rtb_Comparison4_cx)
    {
        /* Switch: '<S530>/Switch1' incorporates:
         *  Constant: '<S405>/ConstantValue5'
         *  Switch: '<S506>/Switch1'
         *  Switch: '<S508>/Switch1'
         *  Switch: '<S520>/Switch1'
         *  Switch: '<S522>/Switch1'
         *  Switch: '<S524>/Switch1'
         *  Switch: '<S526>/Switch1'
         *  Switch: '<S528>/Switch1'
         */
        VeTHMR_Cnt_VehThermSt = 7.0F;
    }
    else if (rtb_Comparison6_n3)
    {
        /* Switch: '<S536>/Switch1' incorporates:
         *  Constant: '<S405>/ConstantValue6'
         *  Switch: '<S506>/Switch1'
         *  Switch: '<S508>/Switch1'
         *  Switch: '<S520>/Switch1'
         *  Switch: '<S522>/Switch1'
         *  Switch: '<S524>/Switch1'
         *  Switch: '<S526>/Switch1'
         *  Switch: '<S528>/Switch1'
         *  Switch: '<S530>/Switch1'
         */
        VeTHMR_Cnt_VehThermSt = 8.0F;
    }
    else if (rtb_AND_ko5)
    {
        /* Switch: '<S514>/Switch1' incorporates:
         *  Constant: '<S405>/ConstantValue12'
         *  Switch: '<S506>/Switch1'
         *  Switch: '<S508>/Switch1'
         *  Switch: '<S520>/Switch1'
         *  Switch: '<S522>/Switch1'
         *  Switch: '<S524>/Switch1'
         *  Switch: '<S526>/Switch1'
         *  Switch: '<S528>/Switch1'
         *  Switch: '<S530>/Switch1'
         *  Switch: '<S536>/Switch1'
         */
        VeTHMR_Cnt_VehThermSt = 9.0F;
    }
    else if (rtb_Comparison5_c3m)
    {
        /* Switch: '<S534>/Switch1' incorporates:
         *  Constant: '<S405>/ConstantValue7'
         *  Switch: '<S506>/Switch1'
         *  Switch: '<S508>/Switch1'
         *  Switch: '<S514>/Switch1'
         *  Switch: '<S520>/Switch1'
         *  Switch: '<S522>/Switch1'
         *  Switch: '<S524>/Switch1'
         *  Switch: '<S526>/Switch1'
         *  Switch: '<S528>/Switch1'
         *  Switch: '<S530>/Switch1'
         *  Switch: '<S536>/Switch1'
         */
        VeTHMR_Cnt_VehThermSt = 2.0F;
    }
    else if (rtb_Logical5_bn)
    {
        /* Switch: '<S532>/Switch1' incorporates:
         *  Constant: '<S405>/ConstantValue8'
         *  Switch: '<S506>/Switch1'
         *  Switch: '<S508>/Switch1'
         *  Switch: '<S514>/Switch1'
         *  Switch: '<S520>/Switch1'
         *  Switch: '<S522>/Switch1'
         *  Switch: '<S524>/Switch1'
         *  Switch: '<S526>/Switch1'
         *  Switch: '<S528>/Switch1'
         *  Switch: '<S530>/Switch1'
         *  Switch: '<S534>/Switch1'
         *  Switch: '<S536>/Switch1'
         */
        VeTHMR_Cnt_VehThermSt = 3.0F;
    }
    else if (rtb_Switch_hql)
    {
        /* Switch: '<S538>/Switch1' incorporates:
         *  Constant: '<S405>/ConstantValue9'
         *  Switch: '<S506>/Switch1'
         *  Switch: '<S508>/Switch1'
         *  Switch: '<S514>/Switch1'
         *  Switch: '<S520>/Switch1'
         *  Switch: '<S522>/Switch1'
         *  Switch: '<S524>/Switch1'
         *  Switch: '<S526>/Switch1'
         *  Switch: '<S528>/Switch1'
         *  Switch: '<S530>/Switch1'
         *  Switch: '<S532>/Switch1'
         *  Switch: '<S534>/Switch1'
         *  Switch: '<S536>/Switch1'
         */
        VeTHMR_Cnt_VehThermSt = 4.0F;
    }
    else if (VeTHMR_b_HVACPrrtyVhcleMode_AfterDial)
    {
        /* Switch: '<S518>/Switch1' incorporates:
         *  Constant: '<S405>/ConstantValue10'
         *  Switch: '<S506>/Switch1'
         *  Switch: '<S508>/Switch1'
         *  Switch: '<S514>/Switch1'
         *  Switch: '<S520>/Switch1'
         *  Switch: '<S522>/Switch1'
         *  Switch: '<S524>/Switch1'
         *  Switch: '<S526>/Switch1'
         *  Switch: '<S528>/Switch1'
         *  Switch: '<S530>/Switch1'
         *  Switch: '<S532>/Switch1'
         *  Switch: '<S534>/Switch1'
         *  Switch: '<S536>/Switch1'
         *  Switch: '<S538>/Switch1'
         */
        VeTHMR_Cnt_VehThermSt = 5.0F;
    }
    else
    {
        /* Switch: '<S506>/Switch1' incorporates:
         *  Switch: '<S508>/Switch1'
         *  Switch: '<S514>/Switch1'
         *  Switch: '<S516>/Switch1'
         *  Switch: '<S518>/Switch1'
         *  Switch: '<S520>/Switch1'
         *  Switch: '<S522>/Switch1'
         *  Switch: '<S524>/Switch1'
         *  Switch: '<S526>/Switch1'
         *  Switch: '<S528>/Switch1'
         *  Switch: '<S530>/Switch1'
         *  Switch: '<S532>/Switch1'
         *  Switch: '<S534>/Switch1'
         *  Switch: '<S536>/Switch1'
         *  Switch: '<S538>/Switch1'
         */
        VeTHMR_Cnt_VehThermSt = (float32)(VeTHMR_b_DefrostVhclMode_AfterDial ?
            1.0F : 0.0F);
    }

    /* End of Switch: '<S506>/Switch1' */

    /* Lookup_n-D: '<S372>/Vector' incorporates:
     *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
     *  Switch: '<S506>/Switch1'
     */
    rtb_Add_h = look2_iflf_binlcapw(VeTHMR_Cnt_VehThermSt,
        TmpSignalConversionAtOutAirTemp, ((const float32 *)
        &(KxTHMR_T_CellTempMaxAllow[0])), ((const float32 *)
        &(KyTHMR_T_CellTempMaxAllow[0])), ((const float32 *)
        &(KtTHMR_T_CellTempMaxAllow[0])), THMR_ac_ConstP.Vector_maxIndex_j, 18U);

    /* Lookup_n-D: '<S373>/Vector' incorporates:
     *  Switch: '<S506>/Switch1'
     */
    VeTHMR_T_MaxBattAllowPsv_NoOp = look1_iflf_binlcapw(VeTHMR_Cnt_VehThermSt,
        ((const float32 *)&(KxTHMR_T_CellTempMaxAllowPsv[0])), ((const float32 *)
        &(KtTHMR_T_CellTempMaxAllowPsv[0])), 17U);

    /* Switch: '<S364>/Switch1' incorporates:
     *  Constant: '<S374>/Calib'
     *  Logic: '<S370>/LogicalOperator'
     */
    if ((KeTHMR_b_SelectNewTempTgt_PsvRA) &&
            (VeTHMR_b_BattCoolFlts_AllowRA_PsvCooling))
    {
        /* Switch: '<S364>/Switch1' incorporates:
         *  Constant: '<S371>/Calib'
         */
        rtb_Switch1_l3 = KeTHMR_T_CellTempMaxAllw_PsvRA_BattCoolFltd;
    }
    else
    {
        /* Switch: '<S364>/Switch1' */
        rtb_Switch1_l3 = VeTHMR_T_MaxBattAllowPsv_NoOp;
    }

    /* End of Switch: '<S364>/Switch1' */

    /* Lookup_n-D: '<S376>/Vector' incorporates:
     *  Switch: '<S506>/Switch1'
     */
    rtb_UnitDelay_kww = look1_iflf_binlcapw(VeTHMR_Cnt_VehThermSt, ((const
        float32 *)&(KxTHMR_T_CellTempMinAllowPsv[0])), ((const float32 *)
        &(KtTHMR_T_CellTempMinAllowPsv[0])), 17U);

    /* Lookup_n-D: '<S377>/Vector' incorporates:
     *  Switch: '<S506>/Switch1'
     */
    VeTHMR_T_MinBattAllow_OldApp = look1_iflf_binlcapw(VeTHMR_Cnt_VehThermSt, ((
        const float32 *)&(KxTHMR_T_TempMinAllow[0])), ((const float32 *)
        &(KtTHMR_T_TempMinAllow[0])), 17U);

    /* Product: '<S382>/Product1' incorporates:
     *  Constant: '<S391>/Calib'
     */
    VeTHMR_i_PrsntWght4CabPrecMinTempAlw = (uint16)((sint32)(rtb_Logical6_or ?
        ((sint32)KeTHMR_i_Wght4CabPrecMinTempAllow) : 0));

    /* Assignment: '<S379>/ArrayAssignment3' incorporates:
     *  Assignment: '<S379>/ArrayAssignment16'
     *  Constant: '<S379>/ConstantValue1'
     */
    rtb_ArrayAssignment16[0] = VeTHMR_i_PrsntWght4CabPrecMinTempAlw;

    /* Product: '<S382>/Product3' incorporates:
     *  Constant: '<S392>/Calib'
     */
    VeTHMR_i_PrsntWght4ChrgLvl1MinTempAllw = (uint16)((sint32)
        (rtb_Comparison3_bu ? ((sint32)KeTHMR_i_Wght4ChrgLvl1MinTempAllow) : 0));

    /* Assignment: '<S379>/ArrayAssignment4' incorporates:
     *  Assignment: '<S379>/ArrayAssignment16'
     */
    rtb_ArrayAssignment16[1] = VeTHMR_i_PrsntWght4ChrgLvl1MinTempAllw;

    /* Product: '<S382>/Product5' incorporates:
     *  Constant: '<S393>/Calib'
     */
    VeTHMR_i_PrsntWght4ChrgLvl2MinTempAllw = (uint16)((sint32)
        (rtb_Comparison4_cx ? ((sint32)KeTHMR_i_Wght4ChrgLvl2MinTempAllow) : 0));

    /* Assignment: '<S379>/ArrayAssignment5' incorporates:
     *  Assignment: '<S379>/ArrayAssignment16'
     */
    rtb_ArrayAssignment16[2] = VeTHMR_i_PrsntWght4ChrgLvl2MinTempAllw;

    /* Product: '<S382>/Product7' incorporates:
     *  Constant: '<S394>/Calib'
     */
    VeTHMR_i_PrsntWght4ChrgLvl3MinTempAllw = (uint16)((sint32)
        (rtb_Comparison6_n3 ? ((sint32)KeTHMR_i_Wght4ChrgLvl3MinTempAllow) : 0));

    /* Assignment: '<S379>/ArrayAssignment6' incorporates:
     *  Assignment: '<S379>/ArrayAssignment16'
     */
    rtb_ArrayAssignment16[3] = VeTHMR_i_PrsntWght4ChrgLvl3MinTempAllw;

    /* Product: '<S382>/Product2' incorporates:
     *  Constant: '<S399>/Calib'
     */
    VeTHMR_i_PrsntWght4LoadShdLvl1MinTempAllw = (uint16)((sint32)
        (rtb_Comparison5_c3m ? ((sint32)KeTHMR_i_Wght4LoadShed1MinTempAllow) : 0));

    /* Assignment: '<S379>/ArrayAssignment7' incorporates:
     *  Assignment: '<S379>/ArrayAssignment16'
     */
    rtb_ArrayAssignment16[4] = VeTHMR_i_PrsntWght4LoadShdLvl1MinTempAllw;

    /* Product: '<S382>/Product4' incorporates:
     *  Constant: '<S386>/Calib'
     */
    VeTHMR_i_ProactiveChgActiveMinTempAllw = (uint16)((sint32)(rtb_Logical5_bn ?
        ((sint32)KeTHMR_i_ProactiveChgActiveMinTempAllow) : 0));

    /* Assignment: '<S379>/ArrayAssignment8' incorporates:
     *  Assignment: '<S379>/ArrayAssignment16'
     */
    rtb_ArrayAssignment16[5] = VeTHMR_i_ProactiveChgActiveMinTempAllw;

    /* Product: '<S382>/Product6' incorporates:
     *  Constant: '<S387>/Calib'
     */
    VeTHMR_i_ProactiveChgPassiveMinTempAllw = (uint16)((sint32)(rtb_Switch_hql ?
        ((sint32)KeTHMR_i_ProactiveChgPassiveMinTempAllow) : 0));

    /* Assignment: '<S379>/ArrayAssignment9' incorporates:
     *  Assignment: '<S379>/ArrayAssignment16'
     */
    rtb_ArrayAssignment16[6] = VeTHMR_i_ProactiveChgPassiveMinTempAllw;

    /* Product: '<S382>/Product8' incorporates:
     *  Constant: '<S398>/Calib'
     */
    VeTHMR_i_PrsntWght4HVACPrrtyMinTempAllw = (uint16)((sint32)
        (VeTHMR_b_HVACPrrtyVhcleMode_AfterDial ? ((sint32)
        KeTHMR_i_Wght4HVACPriorityMinTempAllow) : 0));

    /* Assignment: '<S379>/ArrayAssignment10' incorporates:
     *  Assignment: '<S379>/ArrayAssignment16'
     */
    rtb_ArrayAssignment16[7] = VeTHMR_i_PrsntWght4HVACPrrtyMinTempAllw;

    /* Product: '<S382>/Product9' incorporates:
     *  Constant: '<S396>/Calib'
     */
    VeTHMR_i_PrsntWght4DefrostMinTempAllw = (uint16)((sint32)
        (VeTHMR_b_DefrostVhclMode_AfterDial ? ((sint32)
        KeTHMR_i_Wght4DefrostMinTempAllow) : 0));

    /* Assignment: '<S379>/ArrayAssignment11' incorporates:
     *  Assignment: '<S379>/ArrayAssignment16'
     */
    rtb_ArrayAssignment16[8] = VeTHMR_i_PrsntWght4DefrostMinTempAllw;

    /* Product: '<S382>/Product19' incorporates:
     *  Constant: '<S397>/Calib'
     */
    VeTHMR_i_PrsntWght4DschrgSysStsMinTempAllw = (uint16)((sint32)(rtb_AND_ko5 ?
        ((sint32)KeTHMR_i_Wght4DschrgSysStsMinTempAllow) : 0));

    /* Assignment: '<S379>/ArrayAssignment12' incorporates:
     *  Assignment: '<S379>/ArrayAssignment16'
     */
    rtb_ArrayAssignment16[9] = VeTHMR_i_PrsntWght4DschrgSysStsMinTempAllw;

    /* Product: '<S382>/Product21' incorporates:
     *  Constant: '<S362>/FALSEConstant1'
     */
    VeTHMR_i_PrsntWght4PrdicWupMinTempAllw = 0U;

    /* Assignment: '<S379>/ArrayAssignment1' incorporates:
     *  Assignment: '<S379>/ArrayAssignment16'
     */
    rtb_ArrayAssignment16[10] = VeTHMR_i_PrsntWght4PrdicWupMinTempAllw;

    /* Product: '<S382>/Product23' incorporates:
     *  Constant: '<S362>/FALSEConstant1'
     */
    VeTHMR_i_PrsntWght4ChrgPrepMinTempAllw = 0U;

    /* Assignment: '<S379>/ArrayAssignment13' incorporates:
     *  Assignment: '<S379>/ArrayAssignment16'
     */
    rtb_ArrayAssignment16[11] = VeTHMR_i_PrsntWght4ChrgPrepMinTempAllw;

    /* Switch: '<S505>/Switch1' incorporates:
     *  Switch: '<S507>/Switch1'
     *  Switch: '<S513>/Switch1'
     *  Switch: '<S515>/Switch1'
     *  Switch: '<S517>/Switch1'
     *  Switch: '<S519>/Switch1'
     *  Switch: '<S521>/Switch1'
     *  Switch: '<S523>/Switch1'
     *  Switch: '<S525>/Switch1'
     *  Switch: '<S527>/Switch1'
     *  Switch: '<S529>/Switch1'
     *  Switch: '<S531>/Switch1'
     *  Switch: '<S533>/Switch1'
     *  Switch: '<S535>/Switch1'
     *  Switch: '<S537>/Switch1'
     */
    if (rtb_AND_c3)
    {
        /* Switch: '<S505>/Switch1' incorporates:
         *  Constant: '<S462>/Constant'
         */
        rtb_Switch1_d1t = CeTHMR_e_TempAllowBattCoolOV;
    }
    else if (rtb_OR1_g4)
    {
        /* Switch: '<S507>/Switch1' incorporates:
         *  Constant: '<S464>/Constant'
         *  Switch: '<S505>/Switch1'
         */
        rtb_Switch1_d1t = CeTHMR_e_TempAllowBattHeatOV;
    }
    else if (rtb_TmpSignalConversionAtVePD_p)
    {
        /* Switch: '<S523>/Switch1' incorporates:
         *  Constant: '<S465>/Constant'
         *  Switch: '<S505>/Switch1'
         *  Switch: '<S507>/Switch1'
         */
        rtb_Switch1_d1t = CeTHMR_e_TempAllowBattCoolNHeatOV;
    }
    else if (rtb_TmpSignalConversionAtVePD_i)
    {
        /* Switch: '<S519>/Switch1' incorporates:
         *  Constant: '<S469>/Constant'
         *  Switch: '<S505>/Switch1'
         *  Switch: '<S507>/Switch1'
         *  Switch: '<S523>/Switch1'
         */
        rtb_Switch1_d1t = CeTHMR_e_RacePrepTrackModeActv;
    }
    else if (rtb_Logical18_d)
    {
        /* Switch: '<S521>/Switch1' incorporates:
         *  Constant: '<S472>/Constant'
         *  Switch: '<S505>/Switch1'
         *  Switch: '<S507>/Switch1'
         *  Switch: '<S519>/Switch1'
         *  Switch: '<S523>/Switch1'
         */
        rtb_Switch1_d1t = CeTHMR_e_RacePrepDragModeActv;
    }
    else if (rtb_Logical6_or)
    {
        /* Switch: '<S525>/Switch1' incorporates:
         *  Constant: '<S457>/Constant'
         *  Switch: '<S505>/Switch1'
         *  Switch: '<S507>/Switch1'
         *  Switch: '<S519>/Switch1'
         *  Switch: '<S521>/Switch1'
         *  Switch: '<S523>/Switch1'
         */
        rtb_Switch1_d1t = CeTHMR_e_TempAllowCabinPrecond;
    }
    else if (rtb_Comparison3_bu)
    {
        /* Switch: '<S527>/Switch1' incorporates:
         *  Constant: '<S476>/Constant'
         *  Switch: '<S505>/Switch1'
         *  Switch: '<S507>/Switch1'
         *  Switch: '<S519>/Switch1'
         *  Switch: '<S521>/Switch1'
         *  Switch: '<S523>/Switch1'
         *  Switch: '<S525>/Switch1'
         */
        rtb_Switch1_d1t = CeTHMR_e_TempAllowChargeLevel1;
    }
    else if (rtb_Comparison4_cx)
    {
        /* Switch: '<S529>/Switch1' incorporates:
         *  Constant: '<S474>/Constant'
         *  Switch: '<S505>/Switch1'
         *  Switch: '<S507>/Switch1'
         *  Switch: '<S519>/Switch1'
         *  Switch: '<S521>/Switch1'
         *  Switch: '<S523>/Switch1'
         *  Switch: '<S525>/Switch1'
         *  Switch: '<S527>/Switch1'
         */
        rtb_Switch1_d1t = CeTHMR_e_TempAllowChargeLevel2;
    }
    else if (rtb_Comparison6_n3)
    {
        /* Switch: '<S535>/Switch1' incorporates:
         *  Constant: '<S475>/Constant'
         *  Switch: '<S505>/Switch1'
         *  Switch: '<S507>/Switch1'
         *  Switch: '<S519>/Switch1'
         *  Switch: '<S521>/Switch1'
         *  Switch: '<S523>/Switch1'
         *  Switch: '<S525>/Switch1'
         *  Switch: '<S527>/Switch1'
         *  Switch: '<S529>/Switch1'
         */
        rtb_Switch1_d1t = CeTHMR_e_TempAllowChargeLevel3;
    }
    else if (rtb_AND_ko5)
    {
        /* Switch: '<S513>/Switch1' incorporates:
         *  Constant: '<S456>/Constant'
         *  Switch: '<S505>/Switch1'
         *  Switch: '<S507>/Switch1'
         *  Switch: '<S519>/Switch1'
         *  Switch: '<S521>/Switch1'
         *  Switch: '<S523>/Switch1'
         *  Switch: '<S525>/Switch1'
         *  Switch: '<S527>/Switch1'
         *  Switch: '<S529>/Switch1'
         *  Switch: '<S535>/Switch1'
         */
        rtb_Switch1_d1t = CeTHMR_e_TempAllowPowerPanel;
    }
    else if (rtb_Comparison5_c3m)
    {
        /* Switch: '<S533>/Switch1' incorporates:
         *  Constant: '<S453>/Constant'
         *  Switch: '<S505>/Switch1'
         *  Switch: '<S507>/Switch1'
         *  Switch: '<S513>/Switch1'
         *  Switch: '<S519>/Switch1'
         *  Switch: '<S521>/Switch1'
         *  Switch: '<S523>/Switch1'
         *  Switch: '<S525>/Switch1'
         *  Switch: '<S527>/Switch1'
         *  Switch: '<S529>/Switch1'
         *  Switch: '<S535>/Switch1'
         */
        rtb_Switch1_d1t = CeTHMR_e_TempAllowLoadShed1;
    }
    else if (rtb_Logical5_bn)
    {
        /* Switch: '<S531>/Switch1' incorporates:
         *  Constant: '<S454>/Constant'
         *  Switch: '<S505>/Switch1'
         *  Switch: '<S507>/Switch1'
         *  Switch: '<S513>/Switch1'
         *  Switch: '<S519>/Switch1'
         *  Switch: '<S521>/Switch1'
         *  Switch: '<S523>/Switch1'
         *  Switch: '<S525>/Switch1'
         *  Switch: '<S527>/Switch1'
         *  Switch: '<S529>/Switch1'
         *  Switch: '<S533>/Switch1'
         *  Switch: '<S535>/Switch1'
         */
        rtb_Switch1_d1t = CeTHMR_e_DCProactChargPrepActive;
    }
    else if (rtb_Switch_hql)
    {
        /* Switch: '<S537>/Switch1' incorporates:
         *  Constant: '<S455>/Constant'
         *  Switch: '<S505>/Switch1'
         *  Switch: '<S507>/Switch1'
         *  Switch: '<S513>/Switch1'
         *  Switch: '<S519>/Switch1'
         *  Switch: '<S521>/Switch1'
         *  Switch: '<S523>/Switch1'
         *  Switch: '<S525>/Switch1'
         *  Switch: '<S527>/Switch1'
         *  Switch: '<S529>/Switch1'
         *  Switch: '<S531>/Switch1'
         *  Switch: '<S533>/Switch1'
         *  Switch: '<S535>/Switch1'
         */
        rtb_Switch1_d1t = CeTHMR_e_DCProactChargPrepPassive;
    }
    else if (VeTHMR_b_HVACPrrtyVhcleMode_AfterDial)
    {
        /* Switch: '<S517>/Switch1' incorporates:
         *  Constant: '<S463>/Constant'
         *  Switch: '<S505>/Switch1'
         *  Switch: '<S507>/Switch1'
         *  Switch: '<S513>/Switch1'
         *  Switch: '<S519>/Switch1'
         *  Switch: '<S521>/Switch1'
         *  Switch: '<S523>/Switch1'
         *  Switch: '<S525>/Switch1'
         *  Switch: '<S527>/Switch1'
         *  Switch: '<S529>/Switch1'
         *  Switch: '<S531>/Switch1'
         *  Switch: '<S533>/Switch1'
         *  Switch: '<S535>/Switch1'
         *  Switch: '<S537>/Switch1'
         */
        rtb_Switch1_d1t = CeTHMR_e_TempAllowHVACPriority;
    }
    else if (VeTHMR_b_DefrostVhclMode_AfterDial)
    {
        /* Switch: '<S515>/Switch1' incorporates:
         *  Constant: '<S473>/Constant'
         *  Switch: '<S505>/Switch1'
         *  Switch: '<S507>/Switch1'
         *  Switch: '<S513>/Switch1'
         *  Switch: '<S517>/Switch1'
         *  Switch: '<S519>/Switch1'
         *  Switch: '<S521>/Switch1'
         *  Switch: '<S523>/Switch1'
         *  Switch: '<S525>/Switch1'
         *  Switch: '<S527>/Switch1'
         *  Switch: '<S529>/Switch1'
         *  Switch: '<S531>/Switch1'
         *  Switch: '<S533>/Switch1'
         *  Switch: '<S535>/Switch1'
         *  Switch: '<S537>/Switch1'
         */
        rtb_Switch1_d1t = CeTHMR_e_TempAllowDefrost;
    }
    else
    {
        /* Switch: '<S505>/Switch1' incorporates:
         *  Switch: '<S507>/Switch1'
         *  Switch: '<S511>/Switch1'
         *  Switch: '<S513>/Switch1'
         *  Switch: '<S515>/Switch1'
         *  Switch: '<S517>/Switch1'
         *  Switch: '<S519>/Switch1'
         *  Switch: '<S521>/Switch1'
         *  Switch: '<S523>/Switch1'
         *  Switch: '<S525>/Switch1'
         *  Switch: '<S527>/Switch1'
         *  Switch: '<S529>/Switch1'
         *  Switch: '<S531>/Switch1'
         *  Switch: '<S533>/Switch1'
         *  Switch: '<S535>/Switch1'
         *  Switch: '<S537>/Switch1'
         */
        rtb_Switch1_d1t = THMR_ac_ConstB.Switch1_k;
    }

    /* End of Switch: '<S505>/Switch1' */

    /* Switch: '<S404>/Switch' incorporates:
     *  Constant: '<S444>/Constant'
     *  Constant: '<S445>/Calib'
     *  Constant: '<S446>/Calib'
     *  DataTypeConversion: '<S450>/DataTypeConversion'
     *  RelationalOperator: '<S404>/Comparison3'
     *  Switch: '<S505>/Switch1'
     */
    if (KeTHMR_b_NormalDrvVhclMode_DialSlct)
    {
        rtb_AND_fe = KeTHMR_b_NormalDrvVhclMode_Dial;
    }
    else
    {
        rtb_AND_fe = (((uint32)rtb_Switch1_d1t) == CeTHMR_e_TempAllowNormalDrive);
    }

    /* End of Switch: '<S404>/Switch' */

    /* Product: '<S382>/Product25' incorporates:
     *  Constant: '<S400>/Calib'
     */
    VeTHMR_i_PrsntWght4NrmlDrvMinTempAllw = (uint16)((sint32)(rtb_AND_fe ?
        ((sint32)KeTHMR_i_Wght4NormalDrvMinTempAllow) : 0));

    /* Assignment: '<S379>/ArrayAssignment2' incorporates:
     *  Assignment: '<S379>/ArrayAssignment16'
     */
    rtb_ArrayAssignment16[12] = VeTHMR_i_PrsntWght4NrmlDrvMinTempAllw;

    /* Product: '<S382>/Product10' incorporates:
     *  Constant: '<S389>/Calib'
     */
    VeTHMR_i_Wght4BattCoolOVReqTempAllow = (uint16)((sint32)(rtb_AND_c3 ?
        ((sint32)KeTHMR_i_Wght4BattCoolOVReqTempAllow) : 0));

    /* Assignment: '<S379>/ArrayAssignment14' incorporates:
     *  Assignment: '<S379>/ArrayAssignment16'
     */
    rtb_ArrayAssignment16[13] = VeTHMR_i_Wght4BattCoolOVReqTempAllow;

    /* Product: '<S382>/Product11' incorporates:
     *  Constant: '<S390>/Calib'
     */
    VeTHMR_i_Wght4BattHeatOVReqTempAllow = (uint16)((sint32)(rtb_OR1_g4 ?
        ((sint32)KeTHMR_i_Wght4BattHeatOVReqTempAllow) : 0));

    /* Assignment: '<S379>/ArrayAssignment15' incorporates:
     *  Assignment: '<S379>/ArrayAssignment16'
     */
    rtb_ArrayAssignment16[14] = VeTHMR_i_Wght4BattHeatOVReqTempAllow;

    /* Product: '<S382>/Product12' incorporates:
     *  Constant: '<S388>/Calib'
     */
    VeTHMR_i_Wght4BattCoolNHeatOVReqTempAllow = (uint16)((sint32)
        (rtb_TmpSignalConversionAtVePD_p ? ((sint32)
        KeTHMR_i_Wght4BattCoolNHeatOVReqTempAllow) : 0));

    /* Assignment: '<S379>/ArrayAssignment16' */
    rtb_ArrayAssignment16[15] = VeTHMR_i_Wght4BattCoolNHeatOVReqTempAllow;

    /* Outputs for Iterator SubSystem: '<S378>/Subsystem' incorporates:
     *  ForIterator: '<S381>/ForIterator'
     */
    for (s381_iter = 1; s381_iter < 17; s381_iter++)
    {
        /* Switch: '<S381>/Switch' incorporates:
         *  RelationalOperator: '<S381>/Comparison20'
         */
        if (s381_iter == 1)
        {
            /* Switch: '<S381>/Switch' incorporates:
             *  Constant: '<S381>/ConstantValue'
             */
            rtb_Switch_i3 = 0U;
        }
        else
        {
            /* Switch: '<S381>/Switch' incorporates:
             *  UnitDelay: '<S381>/UnitDelay1'
             */
            rtb_Switch_i3 = THMR_ac_DW.UnitDelay1_DSTATE_ge;
        }

        /* End of Switch: '<S381>/Switch' */

        /* Selector: '<S381>/Selector' */
        u1 = rtb_ArrayAssignment16[s381_iter - 1];

        /* If: '<S381>/If' incorporates:
         *  Selector: '<S381>/Selector'
         */
        if ((u1 < rtb_Switch_i3) || (u1 == rtb_Switch_i3))
        {
            /* Outputs for IfAction SubSystem: '<S381>/IfActionSubsystem' incorporates:
             *  ActionPort: '<S384>/ActionPort'
             */
            /* Update for UnitDelay: '<S381>/UnitDelay1' incorporates:
             *  Inport: '<S384>/In1'
             *  Merge: '<S381>/Merge'
             */
            THMR_ac_DW.UnitDelay1_DSTATE_ge = rtb_Switch_i3;

            /* Merge: '<S381>/Merge1' incorporates:
             *  Inport: '<S384>/In2'
             *  UnitDelay: '<S381>/UnitDelay'
             */
            VeTHMR_i_Index4MinTempAllow_NewApp = THMR_ac_DW.UnitDelay_DSTATE_j4;

            /* End of Outputs for SubSystem: '<S381>/IfActionSubsystem' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S381>/IfActionSubsystem1' incorporates:
             *  ActionPort: '<S385>/ActionPort'
             */
            /* Update for UnitDelay: '<S381>/UnitDelay1' incorporates:
             *  Inport: '<S385>/In1'
             *  Merge: '<S381>/Merge'
             */
            THMR_ac_DW.UnitDelay1_DSTATE_ge = u1;

            /* Merge: '<S381>/Merge1' incorporates:
             *  Inport: '<S385>/In2'
             */
            VeTHMR_i_Index4MinTempAllow_NewApp = s381_iter;

            /* End of Outputs for SubSystem: '<S381>/IfActionSubsystem1' */
        }

        /* End of If: '<S381>/If' */

        /* Update for UnitDelay: '<S381>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_j4 = VeTHMR_i_Index4MinTempAllow_NewApp;
    }

    /* End of Outputs for SubSystem: '<S378>/Subsystem' */

    /* Selector: '<S378>/Selector' incorporates:
     *  Constant: '<S380>/Calib'
     */
    VeTHMR_T_MinBattAllow_NewApp =
        KaTHMR_T_TmpMinAllwBsdOnPrrty[VeTHMR_i_Index4MinTempAllow_NewApp - 1];

    /* Switch: '<S365>/Switch' incorporates:
     *  Constant: '<S375>/Calib'
     */
    if (KeTHMR_b_SelectCellMinTempAllow_newApp)
    {
        /* Switch: '<S365>/Switch' */
        VeTHMR_T_MinBattAllow = VeTHMR_T_MinBattAllow_NewApp;
    }
    else
    {
        /* Switch: '<S365>/Switch' */
        VeTHMR_T_MinBattAllow = VeTHMR_T_MinBattAllow_OldApp;
    }

    /* End of Switch: '<S365>/Switch' */

    /* Switch: '<S363>/Switch2' incorporates:
     *  Constant: '<S366>/Calib'
     */
    if (KeTHMR_b_BattClntMaxTgt_UseTempAllowMode)
    {
        rtb_Switch10 = VeTHMR_Cnt_VehThermSt;
    }
    else
    {
        rtb_Switch10 = TmpSignalConversionAtOutAirTemp;
    }

    /* End of Switch: '<S363>/Switch2' */

    /* Lookup_n-D: '<S367>/Vector' incorporates:
     *  SignalConversion generated from: '<S2>/VeBTRR_T_CellTempMaxUsed'
     */
    VeTHMR_T_BattClntMaxTgt = look2_iflf_binlcapw(rtb_Switch10,
        rtb_TmpSignalConversionAtVeBTRR, ((const float32 *)
        &(KxTHMR_T_BattClntMaxTgt[0])), ((const float32 *)
        &(KyTHMR_T_BattClntMaxTgt[0])), ((const float32 *)
        &(KtTHMR_T_BattClntMaxTgt[0])), THMR_ac_ConstP.pooled33, 18U);

    /* Lookup_n-D: '<S368>/Vector' incorporates:
     *  SignalConversion generated from: '<S2>/VeBTRR_T_CellTempMinUsed'
     *  Switch: '<S506>/Switch1'
     */
    THMR_ac_B.Vector_h = look2_iflf_binlcapw(VeTHMR_Cnt_VehThermSt,
        rtb_TmpSignalConversionAtVeBT_o, ((const float32 *)
        &(KxTHMR_T_BattClntMinTgt[0])), ((const float32 *)
        &(KyTHMR_T_BattClntMinTgt[0])), ((const float32 *)
        &(KtTHMR_T_BattClntMinTgt[0])), THMR_ac_ConstP.pooled33, 18U);

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    /* Outputs for Function Call SubSystem: '<S2>/DetMtrClng' */

    /* SignalConversion generated from: '<S663>/Selector' */
    tmp[0] = VeTHMR_T_MtrA_Temp;
    tmp[1] = VeTHMR_T_MtrB_Temp;
    tmp[2] = VeTHMR_T_MtrC_Temp;

    /* SignalConversion generated from: '<S663>/Selector1' */
    rtb_TmpSignalConversionAtSele_i[0] = VeTHMR_b_MtrA_TempFA;
    rtb_TmpSignalConversionAtSele_i[1] = VeTHMR_b_MtrB_TempFA;
    rtb_TmpSignalConversionAtSele_i[2] = VeTHMR_b_MtrC_TempFA;

    /* SignalConversion generated from: '<S663>/Selector2' */
    tmp_0[0] = VeTHMR_n_MtrA_Spd;
    tmp_0[1] = VeTHMR_n_MtrB_Spd;
    tmp_0[2] = VeTHMR_n_MtrC_Spd;

    /* SignalConversion generated from: '<S663>/Selector3' */
    tmp_1[0] = VeTHMR_M_MtrA_TorqAchieved;
    tmp_1[1] = VeTHMR_M_MtrB_TorqAchieved;
    tmp_1[2] = VeTHMR_M_MtrC_TorqAchieved;

    /* SignalConversion generated from: '<S663>/Selector4' */
    tmp_2[0] = VeTHMR_M_MtrA_TorqCmnd;
    tmp_2[1] = VeTHMR_M_MtrB_TorqCmnd;
    tmp_2[2] = VeTHMR_M_MtrC_TorqCmnd;
    for (i = 0; i < 3; i++)
    {
        /* Selector: '<S663>/Selector' incorporates:
         *  Constant: '<S709>/Calib'
         */
        rtb_Selector_c[i] = tmp[KaTHMR_y_RearFrontEDM_MtrClng[(i)]];

        /* Selector: '<S663>/Selector2' incorporates:
         *  Constant: '<S709>/Calib'
         */
        rtb_Selector2_o[i] = tmp_0[KaTHMR_y_RearFrontEDM_MtrClng[(i)]];

        /* Selector: '<S663>/Selector3' incorporates:
         *  Constant: '<S709>/Calib'
         */
        rtb_Selector3[i] = tmp_1[KaTHMR_y_RearFrontEDM_MtrClng[(i)]];

        /* Selector: '<S663>/Selector4' incorporates:
         *  Constant: '<S709>/Calib'
         */
        rtb_Selector4_n[i] = tmp_2[KaTHMR_y_RearFrontEDM_MtrClng[(i)]];
    }

    /* SignalConversion generated from: '<S663>/Selector5' */
    rtb_TmpSignalConversionAtSele_h[0] = VeTHMR_P_MtrAElecPwrCalcTot;
    rtb_TmpSignalConversionAtSele_h[1] = VeTHMR_P_MtrBElecPwrCalcTot;
    rtb_TmpSignalConversionAtSele_h[2] = VeTHMR_P_MtrCElecPwrCalcTot;

    /* Logic: '<S661>/AND2' incorporates:
     *  Logic: '<S662>/AND5'
     */
    rtb_AND_fe = !VeTHMR_b_PropSysActv_100ms_AD;

    /* If: '<S661>/If' incorporates:
     *  Constant: '<S658>/Calib'
     *  Constant: '<S674>/Calib'
     *  Constant: '<S709>/Calib'
     *  Logic: '<S661>/AND'
     *  Logic: '<S661>/AND2'
     *  Logic: '<S661>/AND3'
     *  RelationalOperator: '<S661>/GreaterThanorEqual2'
     *  RelationalOperator: '<S673>/GreaterThan'
     *  Selector: '<S663>/Selector1'
     *  Switch: '<S673>/Switch1'
     */
    if (((rtb_Selector_c[0] >= KeTHMR_T_MtrHiCoolThresh) ||
            (rtb_TmpSignalConversionAtSele_i[KaTHMR_y_RearFrontEDM_MtrClng[0]]))
        && rtb_AND_fe)
    {
        /* Outputs for IfAction SubSystem: '<S661>/motor1_hot' incorporates:
         *  ActionPort: '<S669>/ActionPort'
         */
        /* MinMax: '<S661>/MinMax1' incorporates:
         *  Constant: '<S660>/Calib'
         *  Gain: '<S686>/Gain'
         */
        rtb_UnitDelay_nr = KeTHMR_dV_MtrMinCool;

        /* End of Outputs for SubSystem: '<S661>/motor1_hot' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S661>/Flow_1' incorporates:
         *  ActionPort: '<S666>/ActionPort'
         */
        /* Outputs for Atomic SubSystem: '<S670>/Hysteresis2' */
        if (rtb_Selector_c[0] > KeTHMR_T_MotTemp_1_Hyst_RvrsHi)
        {
            /* Switch: '<S673>/Switch1' incorporates:
             *  Constant: '<S673>/ConstantValue'
             */
            VeTHMR_b_Mtr1_ClgRvrs_Hyst = true;
        }
        else
        {
            /* Switch: '<S673>/Switch1' incorporates:
             *  Constant: '<S675>/Calib'
             *  RelationalOperator: '<S673>/GreaterThan1'
             *  UnitDelay: '<S673>/UnitDelay'
             */
            VeTHMR_b_Mtr1_ClgRvrs_Hyst = ((rtb_Selector_c[0] >=
                KeTHMR_T_MotTemp_1_Hyst_RvrsLow) &&
                (THMR_ac_DW.UnitDelay_DSTATE_brl));
        }

        /* Update for UnitDelay: '<S673>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_brl = VeTHMR_b_Mtr1_ClgRvrs_Hyst;

        /* End of Outputs for SubSystem: '<S670>/Hysteresis2' */

        /* UnitDelay: '<S672>/UnitDelay' */
        rtb_UnitDelay_nr = THMR_ac_DW.UnitDelay_DSTATE_hk;

        /* End of Outputs for SubSystem: '<S661>/Flow_1' */

        /* Switch: '<S661>/Switch' incorporates:
         *  Constant: '<S667>/Calib'
         */
        if (KeTHMR_b_Mtr1_TorqAchievedEnbl)
        {
            rtb_Switch10 = rtb_Selector3[0];
        }
        else
        {
            rtb_Switch10 = rtb_Selector4_n[0];
        }

        /* End of Switch: '<S661>/Switch' */

        /* Outputs for IfAction SubSystem: '<S661>/Flow_1' incorporates:
         *  ActionPort: '<S666>/ActionPort'
         */
        /* Sum: '<S683>/Subtraction1' incorporates:
         *  Abs: '<S672>/Abs'
         *  Constant: '<S657>/Calib'
         *  Gain: '<S672>/Gain'
         *  Product: '<S672>/Product'
         *  Product: '<S683>/Multiplication'
         *  Selector: '<S663>/Selector5'
         *  Sum: '<S672>/Sum'
         *  Sum: '<S683>/Subtraction'
         */
        VeTHMR_P_DetMtrClng_Mtr1PwrLoss = ((fabsf
            (rtb_TmpSignalConversionAtSele_h[KaTHMR_y_RearFrontEDM_MtrClng[0]] -
             ((0.0001047F * rtb_Selector2_o[0]) * rtb_Switch10)) -
            rtb_UnitDelay_nr) * KeTHMR_K_MtrPwrLossFilt) + rtb_UnitDelay_nr;

        /* Lookup_n-D: '<S677>/Vector' incorporates:
         *  Sum: '<S683>/Subtraction1'
         */
        VeTHMR_dV_ClngFlwRqrd_Mtr1_RvrsRaw = look2_iflf_binlcapw(rtb_Selector_c
            [0], VeTHMR_P_DetMtrClng_Mtr1PwrLoss, ((const float32 *)
            &(KxTHMR_dV_ClngFlowRqrdMtr1_Reverse[0])), ((const float32 *)
            &(KyTHMR_dV_ClngFlowRqrdMtr1_Reverse[0])), ((const float32 *)
            &(KtTHMR_dV_ClngFlowRqrdMtr1_Reverse[0])), THMR_ac_ConstP.pooled34,
            7U);

        /* Switch: '<S670>/Switch1' */
        if (VeTHMR_b_Mtr1_ClgRvrs_Hyst)
        {
            /* Switch: '<S670>/Switch1' */
            VeTHMR_dV_ClngFlwRqrd_Mtr1_Rvrs = VeTHMR_dV_ClngFlwRqrd_Mtr1_RvrsRaw;
        }
        else
        {
            /* Switch: '<S670>/Switch1' incorporates:
             *  Constant: '<S676>/Calib'
             */
            VeTHMR_dV_ClngFlwRqrd_Mtr1_Rvrs = KeTHMR_dV_MotTemp_1_RvrsFlwMin;
        }

        /* End of Switch: '<S670>/Switch1' */

        /* Outputs for Atomic SubSystem: '<S671>/Hysteresis2' */
        /* Switch: '<S678>/Switch1' incorporates:
         *  Constant: '<S679>/Calib'
         *  RelationalOperator: '<S678>/GreaterThan'
         */
        if (rtb_Selector_c[0] > KeTHMR_T_MotTemp_1_Hyst_Hi)
        {
            /* Switch: '<S678>/Switch1' incorporates:
             *  Constant: '<S678>/ConstantValue'
             */
            rtb_AND_fb = true;
        }
        else
        {
            /* Switch: '<S678>/Switch1' incorporates:
             *  Constant: '<S680>/Calib'
             *  RelationalOperator: '<S678>/GreaterThan1'
             *  UnitDelay: '<S678>/UnitDelay'
             */
            rtb_AND_fb = ((rtb_Selector_c[0] >= KeTHMR_T_MotTemp_1_Hyst_Low) &&
                          (THMR_ac_DW.UnitDelay_DSTATE_a2b));
        }

        /* End of Switch: '<S678>/Switch1' */

        /* Update for UnitDelay: '<S678>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_a2b = rtb_AND_fb;

        /* End of Outputs for SubSystem: '<S671>/Hysteresis2' */

        /* Lookup_n-D: '<S682>/Vector' incorporates:
         *  Sum: '<S683>/Subtraction1'
         */
        VeTHMR_dV_ClngFlwRqrd_Mtr1_Raw = look2_iflf_binlcapw(rtb_Selector_c[0],
            VeTHMR_P_DetMtrClng_Mtr1PwrLoss, ((const float32 *)
            &(KxTHMR_dV_ClngFlowRqrdMtr1[0])), ((const float32 *)
            &(KyTHMR_dV_ClngFlowRqrdMtr1[0])), ((const float32 *)
            &(KtTHMR_dV_ClngFlowRqrdMtr1[0])), THMR_ac_ConstP.pooled34, 7U);

        /* Switch: '<S671>/Switch1' */
        if (rtb_AND_fb)
        {
            /* Switch: '<S671>/Switch1' */
            VeTHMR_dV_ClngFlwRqrd_Mtr1 = VeTHMR_dV_ClngFlwRqrd_Mtr1_Raw;
        }
        else
        {
            /* Switch: '<S671>/Switch1' incorporates:
             *  Constant: '<S681>/Calib'
             */
            VeTHMR_dV_ClngFlwRqrd_Mtr1 = KeTHMR_dV_MotTemp_1_FlwMin;
        }

        /* End of Switch: '<S671>/Switch1' */

        /* Switch: '<S666>/Switch' incorporates:
         *  Constant: '<S665>/Constant'
         *  RelationalOperator: '<S661>/Equal15'
         *  Switch: '<S3957>/Switch'
         */
        if (((uint32)VeTHMR_e_TransDirctnSt) == CeTRGR_e_TransRangeReverse)
        {
            /* MinMax: '<S661>/MinMax1' */
            rtb_UnitDelay_nr = VeTHMR_dV_ClngFlwRqrd_Mtr1_Rvrs;
        }
        else
        {
            /* MinMax: '<S661>/MinMax1' */
            rtb_UnitDelay_nr = VeTHMR_dV_ClngFlwRqrd_Mtr1;
        }

        /* End of Switch: '<S666>/Switch' */

        /* Update for UnitDelay: '<S672>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_hk = VeTHMR_P_DetMtrClng_Mtr1PwrLoss;

        /* End of Outputs for SubSystem: '<S661>/Flow_1' */
    }

    /* End of If: '<S661>/If' */

    /* Switch generated from: '<S663>/Switch13' incorporates:
     *  Constant: '<S710>/Calib'
     */
    if (KeTHMR_b_FrontRearWhlSpds_Mtr1_Mtr2_Slctr)
    {
        rtb_TmpSignalConversionAtVePD_i = THMR_ac_B.Switch9;
        rtb_TmpSignalConversionAtVePD_p = THMR_ac_B.Switch12_l;
    }
    else
    {
        rtb_TmpSignalConversionAtVePD_i = THMR_ac_B.Switch10_n;
        rtb_TmpSignalConversionAtVePD_p = THMR_ac_B.Switch11_p;
    }

    /* Switch: '<S668>/Switch15' incorporates:
     *  Constant: '<S710>/Calib'
     *  Logic: '<S668>/AND1'
     *  Switch generated from: '<S663>/Switch13'
     */
    if (rtb_TmpSignalConversionAtVePD_i || rtb_TmpSignalConversionAtVePD_p)
    {
        /* Switch: '<S668>/Switch15' incorporates:
         *  Constant: '<S684>/Calib'
         */
        rtb_Switch15 = KeTHMR_dV_WhlSpdFA_OilFlwRtDiffTgt1;
    }
    else
    {
        if (KeTHMR_b_FrontRearWhlSpds_Mtr1_Mtr2_Slctr)
        {
            /* Switch generated from: '<S663>/Switch13' */
            rtb_Switch10 = THMR_ac_B.Switch5;

            /* Switch generated from: '<S663>/Switch13' */
            rtb_Switch15 = THMR_ac_B.Switch8;
        }
        else
        {
            /* Switch generated from: '<S663>/Switch13' */
            rtb_Switch10 = THMR_ac_B.Switch6;

            /* Switch generated from: '<S663>/Switch13' */
            rtb_Switch15 = THMR_ac_B.Switch7;
        }

        /* Switch: '<S668>/Switch15' incorporates:
         *  Abs: '<S668>/Abs'
         *  Lookup_n-D: '<S685>/Vector'
         *  Sum: '<S668>/Add3'
         */
        rtb_Switch15 = look1_iflf_binlcapw(fabsf(rtb_Switch10 - rtb_Switch15),
            ((const float32 *)&(KxTHMR_dV_WhlSpdDiff_OilFlwRtDiffTgt1[0])), ((
            const float32 *)&(KtTHMR_dV_WhlSpdDiff_OilFlwRtDiffTgt1[0])), 4U);
    }

    /* End of Switch: '<S668>/Switch15' */

    /* MinMax: '<S661>/MinMax1' */
    rtb_UnitDelay_nr = fmaxf(fmaxf(rtb_UnitDelay_nr, THMR_ac_B.Switch2_f),
        rtb_Switch15);

    /* MinMax: '<S661>/MinMax' */
    THMR_ac_B.LeTHMR_dV_MtrA_CoolFlwCmd = fminf(rtb_UnitDelay_nr,
        THMR_ac_B.Switch1_fj);

    /* If: '<S662>/If1' incorporates:
     *  Constant: '<S658>/Calib'
     *  Constant: '<S709>/Calib'
     *  Logic: '<S662>/AND1'
     *  Logic: '<S662>/AND4'
     *  RelationalOperator: '<S662>/GreaterThanorEqual1'
     *  Selector: '<S663>/Selector1'
     */
    if (((rtb_Selector_c[1] >= KeTHMR_T_MtrHiCoolThresh) ||
            (rtb_TmpSignalConversionAtSele_i[KaTHMR_y_RearFrontEDM_MtrClng[1]]))
        && rtb_AND_fe)
    {
        /* Outputs for IfAction SubSystem: '<S662>/motor2_hot' incorporates:
         *  ActionPort: '<S691>/ActionPort'
         */
        /* Merge: '<S662>/Merge2' incorporates:
         *  Constant: '<S660>/Calib'
         *  Gain: '<S708>/Gain'
         */
        rtb_UnitDelay_nr = KeTHMR_dV_MtrMinCool;

        /* End of Outputs for SubSystem: '<S662>/motor2_hot' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S662>/Flow_2' incorporates:
         *  ActionPort: '<S688>/ActionPort'
         */
        /* UnitDelay: '<S692>/UnitDelay' */
        rtb_UnitDelay_nr = THMR_ac_DW.UnitDelay_DSTATE_gnu;

        /* End of Outputs for SubSystem: '<S662>/Flow_2' */

        /* Switch: '<S662>/Switch1' incorporates:
         *  Constant: '<S689>/Calib'
         */
        if (KeTHMR_b_Mtr2_TorqAchievedEnbl)
        {
            rtb_Switch10 = rtb_Selector3[1];
        }
        else
        {
            rtb_Switch10 = rtb_Selector4_n[1];
        }

        /* End of Switch: '<S662>/Switch1' */

        /* Outputs for IfAction SubSystem: '<S662>/Flow_2' incorporates:
         *  ActionPort: '<S688>/ActionPort'
         */
        /* Sum: '<S695>/Subtraction1' incorporates:
         *  Abs: '<S692>/Abs'
         *  Constant: '<S657>/Calib'
         *  Gain: '<S692>/Gain1'
         *  Product: '<S692>/Product1'
         *  Product: '<S695>/Multiplication'
         *  Selector: '<S663>/Selector5'
         *  Sum: '<S692>/Sum2'
         *  Sum: '<S695>/Subtraction'
         */
        VeTHMR_P_DetMtrClng_Mtr2PwrLoss = ((fabsf
            (rtb_TmpSignalConversionAtSele_h[KaTHMR_y_RearFrontEDM_MtrClng[1]] -
             ((0.0001047F * rtb_Selector2_o[1]) * rtb_Switch10)) -
            rtb_UnitDelay_nr) * KeTHMR_K_MtrPwrLossFilt) + rtb_UnitDelay_nr;

        /* Outputs for Atomic SubSystem: '<S693>/Hysteresis2' */
        /* Switch: '<S696>/Switch1' incorporates:
         *  Constant: '<S697>/Calib'
         *  RelationalOperator: '<S696>/GreaterThan'
         */
        if (rtb_Selector_c[1] > KeTHMR_T_MotTemp_2_Hyst_RvrsHi)
        {
            /* Switch: '<S696>/Switch1' incorporates:
             *  Constant: '<S696>/ConstantValue'
             */
            VeTHMR_b_Mtr2_ClgRvrs_Hyst = true;
        }
        else
        {
            /* Switch: '<S696>/Switch1' incorporates:
             *  Constant: '<S698>/Calib'
             *  RelationalOperator: '<S696>/GreaterThan1'
             *  UnitDelay: '<S696>/UnitDelay'
             */
            VeTHMR_b_Mtr2_ClgRvrs_Hyst = ((rtb_Selector_c[1] >=
                KeTHMR_T_MotTemp_2_Hyst_RvrsLow) &&
                (THMR_ac_DW.UnitDelay_DSTATE_ahr));
        }

        /* End of Switch: '<S696>/Switch1' */

        /* Update for UnitDelay: '<S696>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_ahr = VeTHMR_b_Mtr2_ClgRvrs_Hyst;

        /* End of Outputs for SubSystem: '<S693>/Hysteresis2' */

        /* Lookup_n-D: '<S700>/Vector' incorporates:
         *  Sum: '<S695>/Subtraction1'
         */
        VeTHMR_dV_ClngFlwRqrd_Mtr2_RvrsRaw = look2_iflf_binlcapw(rtb_Selector_c
            [1], VeTHMR_P_DetMtrClng_Mtr2PwrLoss, ((const float32 *)
            &(KxTHMR_dV_ClngFlowRqrdMtr2_Reverse[0])), ((const float32 *)
            &(KyTHMR_dV_ClngFlowRqrdMtr2_Reverse[0])), ((const float32 *)
            &(KtTHMR_dV_ClngFlowRqrdMtr2_Reverse[0])), THMR_ac_ConstP.pooled34,
            7U);

        /* Switch: '<S693>/Switch1' */
        if (VeTHMR_b_Mtr2_ClgRvrs_Hyst)
        {
            /* Switch: '<S693>/Switch1' */
            VeTHMR_dV_ClngFlwRqrd_Mtr2_Rvrs = VeTHMR_dV_ClngFlwRqrd_Mtr2_RvrsRaw;
        }
        else
        {
            /* Switch: '<S693>/Switch1' incorporates:
             *  Constant: '<S699>/Calib'
             */
            VeTHMR_dV_ClngFlwRqrd_Mtr2_Rvrs = KeTHMR_dV_MotTemp_2_RvrsFlwMin;
        }

        /* End of Switch: '<S693>/Switch1' */

        /* Outputs for Atomic SubSystem: '<S694>/Hysteresis2' */
        /* Switch: '<S701>/Switch1' incorporates:
         *  Constant: '<S702>/Calib'
         *  RelationalOperator: '<S701>/GreaterThan'
         */
        if (rtb_Selector_c[1] > KeTHMR_T_MotTemp_2_Hyst_Hi)
        {
            /* Switch: '<S701>/Switch1' incorporates:
             *  Constant: '<S701>/ConstantValue'
             */
            rtb_AND_fb = true;
        }
        else
        {
            /* Switch: '<S701>/Switch1' incorporates:
             *  Constant: '<S703>/Calib'
             *  RelationalOperator: '<S701>/GreaterThan1'
             *  UnitDelay: '<S701>/UnitDelay'
             */
            rtb_AND_fb = ((rtb_Selector_c[1] >= KeTHMR_T_MotTemp_2_Hyst_Low) &&
                          (THMR_ac_DW.UnitDelay_DSTATE_e3z));
        }

        /* End of Switch: '<S701>/Switch1' */

        /* Update for UnitDelay: '<S701>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_e3z = rtb_AND_fb;

        /* End of Outputs for SubSystem: '<S694>/Hysteresis2' */

        /* Lookup_n-D: '<S705>/Vector' incorporates:
         *  Sum: '<S695>/Subtraction1'
         */
        VeTHMR_dV_ClngFlwRqrd_Mtr2_Raw = look2_iflf_binlcapw(rtb_Selector_c[1],
            VeTHMR_P_DetMtrClng_Mtr2PwrLoss, ((const float32 *)
            &(KxTHMR_dV_ClngFlowRqrdMtr2[0])), ((const float32 *)
            &(KyTHMR_dV_ClngFlowRqrdMtr2[0])), ((const float32 *)
            &(KtTHMR_dV_ClngFlowRqrdMtr2[0])), THMR_ac_ConstP.pooled34, 7U);

        /* Switch: '<S694>/Switch1' */
        if (rtb_AND_fb)
        {
            /* Switch: '<S694>/Switch1' */
            VeTHMR_dV_ClngFlwRqrd_Mtr2 = VeTHMR_dV_ClngFlwRqrd_Mtr2_Raw;
        }
        else
        {
            /* Switch: '<S694>/Switch1' incorporates:
             *  Constant: '<S704>/Calib'
             */
            VeTHMR_dV_ClngFlwRqrd_Mtr2 = KeTHMR_dV_MotTemp_2_FlwMin;
        }

        /* End of Switch: '<S694>/Switch1' */

        /* Switch: '<S688>/Switch' incorporates:
         *  Constant: '<S687>/Constant'
         *  RelationalOperator: '<S662>/Equal1'
         *  Switch: '<S3957>/Switch'
         */
        if (((uint32)VeTHMR_e_TransDirctnSt) == CeTRGR_e_TransRangeReverse)
        {
            /* Merge: '<S662>/Merge2' */
            rtb_UnitDelay_nr = VeTHMR_dV_ClngFlwRqrd_Mtr2_Rvrs;
        }
        else
        {
            /* Merge: '<S662>/Merge2' */
            rtb_UnitDelay_nr = VeTHMR_dV_ClngFlwRqrd_Mtr2;
        }

        /* End of Switch: '<S688>/Switch' */

        /* Update for UnitDelay: '<S692>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_gnu = VeTHMR_P_DetMtrClng_Mtr2PwrLoss;

        /* End of Outputs for SubSystem: '<S662>/Flow_2' */
    }

    /* End of If: '<S662>/If1' */

    /* Outputs for Atomic SubSystem: '<S664>/Hysteresis2' */
    /* Switch: '<S711>/Switch1' incorporates:
     *  Constant: '<S713>/Calib'
     *  RelationalOperator: '<S711>/GreaterThan'
     */
    if (rtb_Selector_c[1] > KeTHMR_T_Mtr2_EOP_On_RSP)
    {
        /* Switch: '<S711>/Switch1' incorporates:
         *  Constant: '<S711>/ConstantValue'
         */
        VeTHMR_b_EOP_Enbl = true;
    }
    else
    {
        /* Switch: '<S711>/Switch1' incorporates:
         *  Constant: '<S712>/Calib'
         *  RelationalOperator: '<S711>/GreaterThan1'
         *  UnitDelay: '<S711>/UnitDelay'
         */
        VeTHMR_b_EOP_Enbl = ((rtb_Selector_c[1] >= KeTHMR_T_Mtr2_EOP_Off_LSP) &&
                             (THMR_ac_DW.UnitDelay_DSTATE_fq));
    }

    /* End of Switch: '<S711>/Switch1' */

    /* Update for UnitDelay: '<S711>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_fq = VeTHMR_b_EOP_Enbl;

    /* End of Outputs for SubSystem: '<S664>/Hysteresis2' */

    /* Switch: '<S53>/Switch' incorporates:
     *  Constant: '<S659>/Calib'
     *  Switch: '<S664>/Switch'
     */
    if (KeTHMR_b_SelKMGen2EDMOilFlwStratgy)
    {
        /* Switch generated from: '<S663>/Switch14' incorporates:
         *  Constant: '<S710>/Calib'
         */
        if (KeTHMR_b_FrontRearWhlSpds_Mtr1_Mtr2_Slctr)
        {
            rtb_AND_fe = THMR_ac_B.Switch10_n;
            rtb_TmpSignalConversionAtVePD_i = THMR_ac_B.Switch11_p;
        }
        else
        {
            rtb_AND_fe = THMR_ac_B.Switch9;
            rtb_TmpSignalConversionAtVePD_i = THMR_ac_B.Switch12_l;
        }

        /* Switch: '<S690>/Switch16' incorporates:
         *  Constant: '<S710>/Calib'
         *  Logic: '<S690>/AND2'
         *  Switch generated from: '<S663>/Switch14'
         */
        if (rtb_AND_fe || rtb_TmpSignalConversionAtVePD_i)
        {
            /* MinMax: '<S662>/MinMax1' incorporates:
             *  Constant: '<S706>/Calib'
             */
            rtb_Switch15 = KeTHMR_dV_WhlSpdFA_OilFlwRtDiffTgt2;
        }
        else
        {
            if (KeTHMR_b_FrontRearWhlSpds_Mtr1_Mtr2_Slctr)
            {
                /* Switch generated from: '<S663>/Switch14' */
                rtb_Switch10 = THMR_ac_B.Switch6;

                /* Switch generated from: '<S663>/Switch14' */
                rtb_Switch15 = THMR_ac_B.Switch7;
            }
            else
            {
                /* Switch generated from: '<S663>/Switch14' */
                rtb_Switch10 = THMR_ac_B.Switch5;

                /* Switch generated from: '<S663>/Switch14' */
                rtb_Switch15 = THMR_ac_B.Switch8;
            }

            /* MinMax: '<S662>/MinMax1' incorporates:
             *  Abs: '<S690>/Abs1'
             *  Lookup_n-D: '<S707>/Vector'
             *  Sum: '<S690>/Add1'
             */
            rtb_Switch15 = look1_iflf_binlcapw(fabsf(rtb_Switch10 - rtb_Switch15),
                ((const float32 *)&(KxTHMR_dV_WhlSpdDiff_OilFlwRtDiffTgt2[0])),
                ((const float32 *)&(KtTHMR_dV_WhlSpdDiff_OilFlwRtDiffTgt2[0])),
                4U);
        }

        /* End of Switch: '<S690>/Switch16' */

        /* MinMax: '<S662>/MinMax1' */
        rtb_Switch15 = fmaxf(fmaxf(rtb_UnitDelay_nr, THMR_ac_B.Switch3_fg),
                             rtb_Switch15);

        /* Switch: '<S53>/Switch' incorporates:
         *  MinMax: '<S662>/MinMax'
         */
        THMR_ac_B.Switch_a = fminf(rtb_Switch15, THMR_ac_B.Switch4_h);
    }
    else if (VeTHMR_b_EOP_Enbl)
    {
        /* Switch: '<S664>/Switch' incorporates:
         *  Constant: '<S714>/Calib'
         *  Switch: '<S53>/Switch'
         */
        THMR_ac_B.Switch_a = KeTHMR_dV_EOP_Dsrd_Flw;
    }
    else
    {
        /* Switch: '<S53>/Switch' incorporates:
         *  Constant: '<S664>/Constant'
         *  Switch: '<S664>/Switch'
         */
        THMR_ac_B.Switch_a = 0.0F;
    }

    /* End of Switch: '<S53>/Switch' */

    /* End of Outputs for SubSystem: '<S2>/DetMtrClng' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
#endif

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Calibrations'
     */
    /* Switch: '<S45>/Switch' incorporates:
     *  Constant: '<S268>/Calib'
     */
    if (KeTHMR_b_CabinPreCondActive_SD)
    {
        /* Switch: '<S45>/Switch' incorporates:
         *  Constant: '<S267>/Calib'
         */
        rtb_Switch_hql = KeTHMR_b_CabinPreCondActive_Dial;
    }
    else
    {
        /* Switch: '<S45>/Switch' incorporates:
         *  Constant: '<S262>/Constant'
         *  Constant: '<S263>/Constant'
         *  Constant: '<S269>/Calib'
         *  Logic: '<S45>/Logical1'
         *  Logic: '<S45>/Logical3'
         *  RelationalOperator: '<S45>/Comparison2'
         *  RelationalOperator: '<S45>/Comparison8'
         *  SignalConversion generated from: '<S2>/VeTPCR_e_CabinPreCondReqStat'
         */
        rtb_Switch_hql = ((((uint32)rtb_TmpSignalConversionAtVeTP_b) ==
                           CeTPCR_e_OkCabinPrec) || ((((uint32)
                             rtb_TmpSignalConversionAtVeTP_b) ==
                            CeTPCR_e_CabinPrec_SP_Reached) &&
                           (KeTHMR_b_EnblCabPrecSPR_PrecStat2)));
    }

    /* End of Switch: '<S45>/Switch' */

    /* SignalConversion generated from: '<S45>/Out3' incorporates:
     *  Constant: '<S273>/Calib'
     */
    THMR_ac_B.OutportBufferForOut3 = KeTHMR_b_ThreeW_N_Prop_Valve2_Dial;

    /* SignalConversion generated from: '<S45>/Out4' incorporates:
     *  Constant: '<S274>/Calib'
     */
    THMR_ac_B.OutportBufferForOut4 = KeTHMR_b_ThreeW_N_Prop_Valve3_Dial;

    /* SignalConversion generated from: '<S45>/Out5' incorporates:
     *  Constant: '<S275>/Calib'
     */
    THMR_ac_B.VeTHMR_b_ThreeW_Prop_Valve2_Enb = KeTHMR_b_ThreeW_Prop_Valve2_Dial;

    /* SignalConversion generated from: '<S45>/Out6' incorporates:
     *  Constant: '<S276>/Calib'
     */
    THMR_ac_B.VeTHMR_b_ThreeW_Prop_Valve3_Enb = KeTHMR_b_ThreeW_Prop_Valve3_Dial;

    /* S-Function (sfix_bitop): '<S285>/BitwiseOperator1' incorporates:
     *  Logic: '<S282>/Logical1'
     *  Logic: '<S282>/Logical7'
     *  Logic: '<S282>/Logical8'
     *  Logic: '<S283>/Logical20'
     *  Logic: '<S283>/Logical3'
     *  Logic: '<S283>/Logical5'
     *  Logic: '<S285>/LogicalOperator'
     *  Logic: '<S286>/LogicalOperator'
     *  Logic: '<S289>/LogicalOperator'
     *  Logic: '<S290>/LogicalOperator'
     *  RelationalOperator: '<S285>/RelationalOperator1'
     *  RelationalOperator: '<S285>/RelationalOperator2'
     *  RelationalOperator: '<S286>/RelationalOperator1'
     *  RelationalOperator: '<S286>/RelationalOperator2'
     *  RelationalOperator: '<S289>/RelationalOperator1'
     *  RelationalOperator: '<S289>/RelationalOperator2'
     *  RelationalOperator: '<S290>/RelationalOperator1'
     *  RelationalOperator: '<S290>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S285>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S286>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S286>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S289>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S289>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S290>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S290>/BitwiseOperator2'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblRA_BattCoolingFlt_PsvCool

    /* Logic: '<S282>/Logical1' incorporates:
     *  Constant: '<S285>/Constant1'
     *  Constant: '<S285>/Constant2'
     *  Constant: '<S286>/Constant1'
     *  Constant: '<S286>/Constant2'
     *  Constant: '<S287>/Calib'
     *  Constant: '<S288>/Calib'
     *  DataStoreRead: '<S285>/StatusByte_CoolOutTempSnsCkt'
     *  DataStoreRead: '<S286>/StatusByte_HB_CT_SnsrPerf'
     */
    rtb_Logical1_bt = (((((((sint32)THMR_ac_DW.StatusByte_HB_CT_SnsrPerf) & 1) >
                          0) && ((((uint32)THMR_ac_DW.StatusByte_HB_CT_SnsrPerf)
                           & 64U) == 0U)) && (KeTHMR_b_BTISFlty_Disbl_RA4PsvCool))
                       || ((((((sint32)THMR_ac_DW.StatusByte_CoolOutTempSnsCkt)
                           & 1) > 0) && ((((uint32)
                            THMR_ac_DW.StatusByte_CoolOutTempSnsCkt) & 64U) ==
                          0U)) && (KeTHMR_b_BTOSFlty_Disbl_RA4PsvCool)));

    /* Logic: '<S283>/Logical3' incorporates:
     *  Constant: '<S289>/Constant1'
     *  Constant: '<S289>/Constant2'
     *  Constant: '<S290>/Constant1'
     *  Constant: '<S290>/Constant2'
     *  Constant: '<S291>/Calib'
     *  Constant: '<S292>/Calib'
     *  DataStoreRead: '<S289>/StatusByte_BattCoolPmpATempSnsrPerf'
     *  DataStoreRead: '<S290>/StatusByte_BattCoolPmpPerf'
     */
    rtb_Logical3_oz = (((((((sint32)THMR_ac_DW.StatusByte_BattCoolPmpPerf) & 1) >
                          0) && ((((uint32)THMR_ac_DW.StatusByte_BattCoolPmpPerf)
                           & 64U) == 0U)) &&
                        (KeTHMR_b_LTAPPerfFlt_Disbl_RA4PsvCool)) || ((((((sint32)
                            THMR_ac_DW.StatusByte_BattCoolPmpATempSnsr) & 1) > 0)
                         && ((((uint32)
                            THMR_ac_DW.StatusByte_BattCoolPmpATempSnsr) & 64U) ==
                          0U)) && (KeTHMR_b_LTAPTempFlt_Disbl_RA4PsvCool)));

#endif

    /* End of S-Function (sfix_bitop): '<S285>/BitwiseOperator1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* S-Function (sfix_bitop): '<S299>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S299>/StatusByte_AC_RefrigPresSnsrALo'
     *  S-Function (sfix_bitop): '<S4514>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S4748>/Bitwise Operator2'
     */
    rtb_TmpSignalConversionAtVePD_0 = ((uint32)
        THMR_ac_DW.StatusByte_AC_RefrigPresSnsrALo) & 1U;

    /* S-Function (sfix_bitop): '<S299>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S299>/StatusByte_AC_RefrigPresSnsrALo'
     *  S-Function (sfix_bitop): '<S4514>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4748>/Bitwise Operator1'
     */
    rtb_TmpSignalConversionAtVePD_1 = ((uint32)
        THMR_ac_DW.StatusByte_AC_RefrigPresSnsrALo) & 64U;

    /* S-Function (sfix_bitop): '<S298>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S298>/StatusByte_AC_RefrigPresSnsrAHi'
     *  S-Function (sfix_bitop): '<S4513>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S4747>/Bitwise Operator2'
     */
    rtb_TmpSignalConversionAtVePD_2 = ((uint32)
        THMR_ac_DW.StatusByte_AC_RefrigPresSnsrAHi) & 1U;

    /* S-Function (sfix_bitop): '<S298>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S298>/StatusByte_AC_RefrigPresSnsrAHi'
     *  S-Function (sfix_bitop): '<S4513>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4747>/Bitwise Operator1'
     */
    rtb_TmpSignalConversionAtVePD_3 = ((uint32)
        THMR_ac_DW.StatusByte_AC_RefrigPresSnsrAHi) & 64U;

    /* S-Function (sfix_bitop): '<S300>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S300>/StatusByte_AC_RefrigPresSnsrAPerf'
     *  S-Function (sfix_bitop): '<S4515>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S4749>/Bitwise Operator2'
     */
    rtb_TmpSignalConversionAtVePD_4 = ((uint32)
        THMR_ac_DW.StatusByte_AC_RefrigPresSnsrAPe) & 1U;

    /* S-Function (sfix_bitop): '<S300>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S300>/StatusByte_AC_RefrigPresSnsrAPerf'
     *  S-Function (sfix_bitop): '<S4515>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4749>/Bitwise Operator1'
     */
    rtb_TmpSignalConversionAtVePD_5 = ((uint32)
        THMR_ac_DW.StatusByte_AC_RefrigPresSnsrAPe) & 64U;

    /* Logic: '<S265>/Logical16' incorporates:
     *  Constant: '<S298>/Constant1'
     *  Constant: '<S298>/Constant2'
     *  Constant: '<S299>/Constant1'
     *  Constant: '<S299>/Constant2'
     *  Constant: '<S300>/Constant1'
     *  Constant: '<S300>/Constant2'
     *  Constant: '<S303>/Calib'
     *  Constant: '<S304>/Calib'
     *  Constant: '<S305>/Calib'
     *  Logic: '<S265>/Logical1'
     *  Logic: '<S265>/Logical2'
     *  Logic: '<S265>/Logical3'
     *  Logic: '<S298>/Logical Operator'
     *  Logic: '<S299>/Logical Operator'
     *  Logic: '<S300>/Logical Operator'
     *  RelationalOperator: '<S298>/Relational Operator1'
     *  RelationalOperator: '<S298>/Relational Operator2'
     *  RelationalOperator: '<S299>/Relational Operator1'
     *  RelationalOperator: '<S299>/Relational Operator2'
     *  RelationalOperator: '<S300>/Relational Operator1'
     *  RelationalOperator: '<S300>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S298>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S298>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S299>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S299>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S300>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S300>/Bitwise Operator2'
     */
    rtb_TmpSignalConversionAtVePD_p = (((((rtb_TmpSignalConversionAtVePD_0 != 0U)
        && (rtb_TmpSignalConversionAtVePD_1 == 0U)) &&
        (KeTHMR_b_Enbl_HghRfrgtPres_CrctLow_flt)) ||
        (((rtb_TmpSignalConversionAtVePD_2 != 0U) &&
          (rtb_TmpSignalConversionAtVePD_3 == 0U)) &&
         (KeTHMR_b_Enbl_HghRfrgtPres_CrctHigh_flt))) ||
        (((rtb_TmpSignalConversionAtVePD_4 != 0U) &&
          (rtb_TmpSignalConversionAtVePD_5 == 0U)) &&
         (KeTHMR_b_Enbl_HghRfrgtPres_Rtnlty_flt)));

    /* Switch: '<S302>/Switch1' incorporates:
     *  Inport: '<Root>/VeTAIR_p_OEXV_OutPressSens'
     */
    if (rtb_TmpSignalConversionAtVePD_p)
    {
        (void)Rte_Read_VeTAIR_p_OEXV_OutPressSens_Value(&rtb_Merge1_i);

        /* Switch: '<S302>/Switch1' incorporates:
         *  Constant: '<S266>/Calib'
         *  Inport: '<Root>/VeTAIR_p_OEXV_OutPressSens'
         *  Product: '<S45>/Product2'
         */
        VeTHMR_p_HghRfrgtPres_Arb = rtb_Merge1_i * KeTHMR_Cf_Bar2KPa_OEXVOutPres;
    }
    else
    {
        /* Switch: '<S302>/Switch1' */
        VeTHMR_p_HghRfrgtPres_Arb = VeTHMR_p_HghRfrgtPres_B4SET;
    }

    /* End of Switch: '<S302>/Switch1' */

    /* Logic: '<S284>/Logical2' incorporates:
     *  Inport: '<Root>/VeBTRR_b_BattCoolFlts'
     *  Logic: '<S261>/LogicalOperator'
     *  Logic: '<S261>/LogicalOperator3'
     *  Logic: '<S278>/LogicalOperator1'
     *  Logic: '<S278>/LogicalOperator2'
     *  Logic: '<S284>/Logical1'
     *  SignalConversion generated from: '<S261>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblRA_BattCoolingFlt_PsvCool

    /* Outputs for Atomic SubSystem: '<S261>/Hysteresis6' */
    /* Outputs for Atomic SubSystem: '<S284>/Hysteresis3' */
    /* Switch: '<S293>/Switch1' incorporates:
     *  Constant: '<S294>/Calib'
     *  RelationalOperator: '<S293>/GreaterThan'
     */
    if (VeTHMR_p_HghRfrgtPres_Arb > KeTHMR_P_PressSnsrThLo_AllwRA4PsvCool)
    {
        /* Switch: '<S293>/Switch1' incorporates:
         *  Constant: '<S293>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVePD_i = true;
    }
    else
    {
        /* Switch: '<S293>/Switch1' incorporates:
         *  Constant: '<S295>/Calib'
         *  RelationalOperator: '<S293>/GreaterThan1'
         *  UnitDelay: '<S293>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVePD_i = ((VeTHMR_p_HghRfrgtPres_Arb >=
            KeTHMR_P_PressSnsrThLo_RejectRA4PsvCool) &&
            (THMR_ac_DW.UnitDelay_DSTATE_ct));
    }

    /* End of Switch: '<S293>/Switch1' */

    /* Update for UnitDelay: '<S293>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ct = rtb_TmpSignalConversionAtVePD_i;

    /* Logic: '<S278>/LogicalOperator2' incorporates:
     *  Constant: '<S296>/Calib'
     *  Constant: '<S297>/Calib'
     */
    VeTHMR_b_InhibitRA4PsvCool_Flts = ((rtb_Logical3_oz ||
        (((rtb_TmpSignalConversionAtVePD_i || (KeTHMR_b_Dsbl_PressSnsrThChk4RA))
          && In1) && (KeTHMR_b_FanFlty_Disbl_RA4PsvCool))) || rtb_Logical1_bt);

    /* Switch: '<S279>/Switch1' incorporates:
     *  Constant: '<S280>/Calib'
     *  RelationalOperator: '<S279>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeBTRR > KeTHMR_T_CellTempMax_AllowRA4BattCool)
    {
        /* Switch: '<S279>/Switch1' incorporates:
         *  Constant: '<S279>/ConstantValue'
         */
        rtb_Logical1_bt = true;
    }
    else
    {
        /* Switch: '<S279>/Switch1' incorporates:
         *  Constant: '<S281>/Calib'
         *  RelationalOperator: '<S279>/GreaterThan1'
         *  UnitDelay: '<S279>/UnitDelay'
         */
        rtb_Logical1_bt = ((rtb_TmpSignalConversionAtVeBTRR >=
                            KeTHMR_T_CellTempMax_RejectRA4BattCool) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_psu));
    }

    /* End of Switch: '<S279>/Switch1' */

    /* Update for UnitDelay: '<S279>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_psu = rtb_Logical1_bt;
    (void)Rte_Read_VeBTRR_b_BattCoolFlts_Value(&rtb_VariantMerge_For_Variant__n);

    /* VariantMerge generated from: '<S261>/VariantSource' incorporates:
     *  Inport: '<Root>/VeBTRR_b_BattCoolFlts'
     */
    rtb_VariantMerge_For_Variant__n = (((!VeTHMR_b_InhibitRA4PsvCool_Flts) &&
        rtb_VariantMerge_For_Variant__n) && rtb_Logical1_bt);

    /* End of Outputs for SubSystem: '<S284>/Hysteresis3' */
    /* End of Outputs for SubSystem: '<S261>/Hysteresis6' */
#else

    /* VariantMerge generated from: '<S261>/VariantSource' incorporates:
     *  Constant: '<S261>/Constant'
     *  SignalConversion generated from: '<S261>/VariantSource'
     */
    rtb_VariantMerge_For_Variant__n = false;

#endif

    /* End of Logic: '<S284>/Logical2' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeTAIR_b_OEXV_OutPressSens_FA' */
    (void)Rte_Read_VeTAIR_b_OEXV_OutPressSens_FA_Value(&rtb_Logical12_dt);

    /* Inport: '<Root>/VeTAIR_b_HghRfrgtPres_FA' */
    (void)Rte_Read_VeTAIR_b_HghRfrgtPres_FA_Value(&rtb_Logical12_pv);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Calibrations'
     */
    /* SignalConversion generated from: '<S261>/VariantSource' */
    VeTHMR_b_BattCoolFlts_AllowRA_PsvCooling = rtb_VariantMerge_For_Variant__n;

    /* Switch: '<S301>/Switch1' */
    if (rtb_TmpSignalConversionAtVePD_p)
    {
        /* Switch: '<S301>/Switch1' */
        VeTHMR_b_HghRfrgtPresFA_Arb = rtb_Logical12_dt;
    }
    else
    {
        /* Switch: '<S301>/Switch1' */
        VeTHMR_b_HghRfrgtPresFA_Arb = rtb_Logical12_pv;
    }

    /* End of Switch: '<S301>/Switch1' */

    /* Lookup_n-D: '<S277>/Vector' incorporates:
     *  SignalConversion generated from: '<S45>/VariantSource'
     */
#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

    /* Product: '<S45>/Product' incorporates:
     *  Merge: '<S2281>/Merge2'
     */
    rtb_Product_gg = look1_iflf_binlcapw(VeTHMR_Pct_BattCPV_PosReq, ((const
        float32 *)&(KxTHMR_Pct_BTCLPstnFlwpct[0])), ((const float32 *)
        &(KtTHMR_Pct_BTCLPstnFlwpct[0])), 8U);

#else

    /* Product: '<S45>/Product' incorporates:
     *  Constant: '<S45>/ConstantValue11'
     *  SignalConversion generated from: '<S45>/VariantSource'
     */
    rtb_Product_gg = 1.0F;

#endif

    /* End of Lookup_n-D: '<S277>/Vector' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeBTRR_dV_LT_ActPmpFlw' */
    (void)Rte_Read_VeBTRR_dV_LT_ActPmpFlw_Value(&rtb_Switch1_i3);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Calibrations'
     */
    /* Product: '<S45>/Product' */
    rtb_Product_gg *= rtb_Switch1_i3;

    /* MinMax: '<S45>/Max' incorporates:
     *  Constant: '<S270>/Calib'
     *  Product: '<S45>/Product1'
     */
    VeTHMR_dV_LTAPFlwReq_Mod_1 = fmaxf(KeTHMR_b_IncldAPMflw_LTAPFlow ?
        VeTHMR_dV_LT_APM_Flw_Rq : 0.0F, rtb_Product_gg);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* SignalConversion generated from: '<S62>/Use_MBC_HTL_LTCL' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    /* VariantMerge generated from: '<S62>/Use_MBC_HTL_LTCL' */
    rtb_VM_Conditional_Signal_Use_M = THMR_ac_B.Logical1;

#else

    /* VariantMerge generated from: '<S62>/Use_MBC_HTL_LTCL' incorporates:
     *  SignalConversion generated from: '<S62>/Use_MBC_HTL_LTCL'
     */
    rtb_VM_Conditional_Signal_Use_M = false;

#endif

    /* End of SignalConversion generated from: '<S62>/Use_MBC_HTL_LTCL' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeTMIR_b_CntrlBrdTmp_Snsr1_FA_AD' */
    (void)Rte_Read_VeTMIR_b_CntrlBrdTmp_Snsr1_FA_AD_Value(&rtb_Logical46_ov);

    /* Inport: '<Root>/VeTMIR_T_CntrlBrdTmp_Snsr1_AD' */
    (void)Rte_Read_VeTMIR_T_CntrlBrdTmp_Snsr1_AD_Value(&rtb_Merge8);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Logic: '<S2536>/Logical11' incorporates:
     *  Logic: '<S2477>/Logical11'
     */
    rtb_Logical46_fu = !VeTHMR_b_MtrA_TempFA;

    /* Logic: '<S2536>/Logical12' incorporates:
     *  Constant: '<S2591>/Calib'
     *  Constant: '<S2645>/Calib'
     *  Constant: '<S2646>/Calib'
     *  Logic: '<S2536>/Logical11'
     *  Logic: '<S2536>/Logical2'
     *  Logic: '<S2536>/Logical29'
     *  Logic: '<S2536>/Logical46'
     *  RelationalOperator: '<S2536>/Comparison4'
     */
    rtb_Logical12_dt = (((KeTHMR_b_MtrA_Temp_OT_ThrsldEnbld) &&
                         ((VeTHMR_T_MtrA_Temp >= KeTHMR_T_MtrA_Temp_Max) &&
                          rtb_Logical46_fu)) || ((VeTHMR_b_MtrA_TempFA) &&
                         (KeTHMR_b_MtrA_Temp_FA_Enbld)));

    /* Logic: '<S2537>/Logical11' incorporates:
     *  Logic: '<S2478>/Logical11'
     */
    rtb_Logical46_j2 = !VeTHMR_b_MtrA_InvrtrTempFA;

    /* Logic: '<S2537>/Logical12' incorporates:
     *  Constant: '<S2588>/Calib'
     *  Constant: '<S2639>/Calib'
     *  Constant: '<S2640>/Calib'
     *  Logic: '<S2537>/Logical11'
     *  Logic: '<S2537>/Logical2'
     *  Logic: '<S2537>/Logical29'
     *  Logic: '<S2537>/Logical46'
     *  RelationalOperator: '<S2537>/Comparison4'
     */
    rtb_Logical12_pv = (((KeTHMR_b_MtrA_InvrtrTemp_OT_ThrsldEnbld) &&
                         ((VeTHMR_T_MtrA_InvrtrTemp >=
                           KeTHMR_T_MtrA_InvrtrTemp_Max) && rtb_Logical46_j2)) ||
                        ((VeTHMR_b_MtrA_InvrtrTempFA) &&
                         (KeTHMR_b_MtrA_InvrtrTemp_FA_Enbld)));

    /* Logic: '<S2542>/Logical12' incorporates:
     *  Constant: '<S2596>/Calib'
     *  Constant: '<S2655>/Calib'
     *  Constant: '<S2656>/Calib'
     *  Logic: '<S2542>/Logical11'
     *  Logic: '<S2542>/Logical2'
     *  Logic: '<S2542>/Logical29'
     *  Logic: '<S2542>/Logical46'
     *  RelationalOperator: '<S2542>/Comparison4'
     */
    rtb_Logical1_bt = (((KeTHMR_b_MtrB_Temp_OT_ThrsldEnbld) &&
                        ((VeTHMR_T_MtrB_Temp >= KeTHMR_T_MtrB_Temp_Max) &&
                         (!VeTHMR_b_MtrB_TempFA))) || ((VeTHMR_b_MtrB_TempFA) &&
                        (KeTHMR_b_MtrB_Temp_FA_Enbld)));

    /* Logic: '<S2543>/Logical12' incorporates:
     *  Constant: '<S2593>/Calib'
     *  Constant: '<S2649>/Calib'
     *  Constant: '<S2650>/Calib'
     *  Logic: '<S2543>/Logical11'
     *  Logic: '<S2543>/Logical2'
     *  Logic: '<S2543>/Logical29'
     *  Logic: '<S2543>/Logical46'
     *  RelationalOperator: '<S2543>/Comparison4'
     */
    rtb_Logical3_oz = (((KeTHMR_b_MtrB_InvrtrTemp_OT_ThrsldEnbld) &&
                        ((VeTHMR_T_MtrB_InvrtrTemp >=
                          KeTHMR_T_MtrB_InvrtrTemp_Max) &&
                         (!VeTHMR_b_MtrB_InvrtrTempFA))) ||
                       ((VeTHMR_b_MtrB_InvrtrTempFA) &&
                        (KeTHMR_b_MtrB_InvrtrTemp_FA_Enbld)));

    /* Logic: '<S2544>/Logical11' incorporates:
     *  Logic: '<S2474>/Logical11'
     */
    rtb_Logical1_c0 = !rtb_TmpSignalConversionAtVeTM_j;

    /* Logic: '<S2544>/Logical12' incorporates:
     *  Constant: '<S2602>/Calib'
     *  Constant: '<S2667>/Calib'
     *  Constant: '<S2668>/Calib'
     *  Logic: '<S2544>/Logical11'
     *  Logic: '<S2544>/Logical2'
     *  Logic: '<S2544>/Logical29'
     *  Logic: '<S2544>/Logical46'
     *  RelationalOperator: '<S2544>/Comparison4'
     */
    rtb_VariantMerge_For_Variant__n = (((KeTHMR_b_OBCMTemp1_OT_ThrsldEnbld) &&
        ((rtb_TmpSignalConversionAtVeT_fy >= KeTHMR_T_OBCMTemp1_HiMax) &&
         rtb_Logical1_c0)) || (rtb_TmpSignalConversionAtVeTM_j &&
        (KeTHMR_b_OBCMTemp1_FA_Enbld)));

    /* Logic: '<S2545>/Logical11' incorporates:
     *  Logic: '<S2475>/Logical11'
     */
    rtb_Logical1_li = !rtb_TmpSignalConversionAtVeT_f5;

    /* Logic: '<S2545>/Logical12' incorporates:
     *  Constant: '<S2603>/Calib'
     *  Constant: '<S2669>/Calib'
     *  Constant: '<S2670>/Calib'
     *  Logic: '<S2545>/Logical11'
     *  Logic: '<S2545>/Logical2'
     *  Logic: '<S2545>/Logical29'
     *  Logic: '<S2545>/Logical46'
     *  RelationalOperator: '<S2545>/Comparison4'
     */
    rtb_TmpSignalConversionAtVePD_p = (((KeTHMR_b_OBCMTemp2_OT_ThrsldEnbld) &&
        ((rtb_TmpSignalConversionAtVeTM_n >= KeTHMR_T_OBCMTemp2_HiMax) &&
         rtb_Logical1_li)) || (rtb_TmpSignalConversionAtVeT_f5 &&
        (KeTHMR_b_OBCMTemp2_FA_Enbld)));

    /* Logic: '<S2546>/Logical12' incorporates:
     *  Constant: '<S2579>/Calib'
     *  Constant: '<S2617>/Calib'
     *  Constant: '<S2618>/Calib'
     *  Logic: '<S2546>/Logical11'
     *  Logic: '<S2546>/Logical2'
     *  Logic: '<S2546>/Logical29'
     *  Logic: '<S2546>/Logical46'
     *  RelationalOperator: '<S2546>/Comparison4'
     */
    rtb_TmpSignalConversionAtVePD_i = (((KeTHMR_b_APM_Temp1_OT_ThrsldEnbld) &&
        ((VeTHMR_T_APM_Temp1 >= KeTHMR_T_APM_Temp1_HiMax) &&
         (!VeTHMR_b_APM_Temp1_FA))) || ((VeTHMR_b_APM_Temp1_FA) &&
        (KeTHMR_b_APM_Temp1_FA_Enbld)));

    /* Logic: '<S2547>/Logical12' incorporates:
     *  Constant: '<S2580>/Calib'
     *  Constant: '<S2619>/Calib'
     *  Constant: '<S2620>/Calib'
     *  Logic: '<S2547>/Logical11'
     *  Logic: '<S2547>/Logical2'
     *  Logic: '<S2547>/Logical29'
     *  Logic: '<S2547>/Logical46'
     *  RelationalOperator: '<S2547>/Comparison4'
     */
    rtb_AND_c3 = (((KeTHMR_b_APM_Temp2_OT_ThrsldEnbld) && ((VeTHMR_T_APM_Temp2 >=
                     KeTHMR_T_APM_Temp2_HiMax) && (!VeTHMR_b_APM_Temp2_FA))) ||
                  ((VeTHMR_b_APM_Temp2_FA) && (KeTHMR_b_APM_Temp2_FA_Enbld)));

    /* Logic: '<S2548>/Logical46' incorporates:
     *  Constant: '<S2607>/Calib'
     *  Constant: '<S2684>/Calib'
     *  RelationalOperator: '<S2548>/Comparison4'
     */
    rtb_OR1_g4 = ((KeTHMR_b_TransOilTmp_OT_ThrsldEnbld) &&
                  (VeTHMR_T_TransOilTemp >= KeTHMR_T_TransOilTmp_HiMax));

    /* Logic: '<S2549>/Logical29' incorporates:
     *  Constant: '<S2675>/Calib'
     */
    rtb_Logical18_d = (rtb_TmpSignalConversionAtVeT_ej &&
                       (KeTHMR_b_OnBrdChrg_ClntTmpIn_FA_Enb));

    /* Logic: '<S2538>/Logical29' incorporates:
     *  Constant: '<S2636>/Calib'
     */
    rtb_Logical6_or = ((VeTHMR_b_HghRfrgtPresFA_Arb) &&
                       (KeTHMR_b_HghRfrgtPres_FA_Enb));

    /* Switch: '<S2472>/Switch' incorporates:
     *  Constant: '<S2742>/Calib'
     *  Switch: '<S2472>/Switch1'
     */
    if (KeTHMR_b_CntrlBrdTmp_Src)
    {
        /* Merge: '<S2928>/Merge1' */
        rtb_Merge1_i = VeTHMR_T_BSG_CntrlBoardTemp_AF;

        /* Logic: '<S2479>/Logical46' */
        rtb_Logical46_ov = VeTHMR_b_BSG_CntrlBoardTemp_FA;
    }
    else
    {
        /* Merge: '<S2928>/Merge1' */
        rtb_Merge1_i = rtb_Merge8;
    }

    /* End of Switch: '<S2472>/Switch' */

    /* Logic: '<S2553>/Logical11' incorporates:
     *  Logic: '<S2479>/Logical11'
     */
    rtb_Logical46_cr = !rtb_Logical46_ov;

    /* Logic: '<S2553>/Logical12' incorporates:
     *  Constant: '<S2587>/Calib'
     *  Constant: '<S2637>/Calib'
     *  Constant: '<S2638>/Calib'
     *  Logic: '<S2553>/Logical11'
     *  Logic: '<S2553>/Logical2'
     *  Logic: '<S2553>/Logical29'
     *  Logic: '<S2553>/Logical46'
     *  RelationalOperator: '<S2553>/Comparison4'
     */
    rtb_Comparison3_bu = (((KeTHMR_b_MtrA_CntrlBoard_Temp_OT_ThrsldEnbld) &&
                           ((rtb_Merge1_i >= KeTHMR_T_MtrA_CntrlBoard_Temp_Max) &&
                            rtb_Logical46_cr)) || (rtb_Logical46_ov &&
                           (KeTHMR_b_MtrA_CntrlBoard_Temp_FA_Enbld)));

    /* Logic: '<S2554>/Logical12' incorporates:
     *  Constant: '<S2584>/Calib'
     *  Constant: '<S2627>/Calib'
     *  Constant: '<S2628>/Calib'
     *  Logic: '<S2554>/Logical11'
     *  Logic: '<S2554>/Logical2'
     *  Logic: '<S2554>/Logical29'
     *  Logic: '<S2554>/Logical46'
     *  RelationalOperator: '<S2554>/Comparison4'
     */
    Switch5_i = (((KeTHMR_b_Clnt_In_Temp_OT_ThrsldEnbld) && ((Switch4_d >=
                    KeTHMR_T_Clnt_In_Temp_Max) && (!Switch5_i))) || (Switch5_i &&
                  (KeTHMR_b_Clnt_In_Temp_FA_Enbld)));

    /* Logic: '<S2556>/Logical12' incorporates:
     *  Constant: '<S2585>/Calib'
     *  Constant: '<S2629>/Calib'
     *  Constant: '<S2630>/Calib'
     *  Logic: '<S2556>/Logical11'
     *  Logic: '<S2556>/Logical2'
     *  Logic: '<S2556>/Logical29'
     *  Logic: '<S2556>/Logical46'
     *  RelationalOperator: '<S2556>/Comparison4'
     */
    rtb_AND_cn = (((KeTHMR_b_Clnt_Out_Temp_OT_ThrsldEnbld) && ((rtb_Switch1_he >=
                     KeTHMR_T_Clnt_Out_Temp_Max) && (!rtb_AND_cn))) ||
                  (rtb_AND_cn && (KeTHMR_b_Clnt_Out_Temp_FA_Enbld)));

    /* Logic: '<S2557>/Logical11' incorporates:
     *  Logic: '<S2480>/Logical11'
     */
    rtb_Logical17_h = !VeTHMR_b_BSG_MtrRotorTemp_FA;

    /* Logic: '<S2557>/Logical12' incorporates:
     *  Constant: '<S2590>/Calib'
     *  Constant: '<S2643>/Calib'
     *  Constant: '<S2644>/Calib'
     *  Logic: '<S2557>/Logical11'
     *  Logic: '<S2557>/Logical2'
     *  Logic: '<S2557>/Logical29'
     *  Logic: '<S2557>/Logical46'
     *  RelationalOperator: '<S2557>/Comparison4'
     */
    rtb_Comparison4_cx = (((KeTHMR_b_MtrA_Rotor_Temp_OT_ThrsldEnbld) &&
                           ((VeTHMR_T_BSG_MtrRotorTemp >=
        KeTHMR_T_MtrA_Rotor_Temp_Max) && rtb_Logical17_h)) ||
                          ((VeTHMR_b_BSG_MtrRotorTemp_FA) &&
                           (KeTHMR_b_MtrA_Rotor_Temp_FA_Enbld)));

    /* Logic: '<S2558>/Logical12' incorporates:
     *  Constant: '<S2606>/Calib'
     *  Constant: '<S2676>/Calib'
     *  Constant: '<S2677>/Calib'
     *  Logic: '<S2558>/Logical11'
     *  Logic: '<S2558>/Logical2'
     *  Logic: '<S2558>/Logical29'
     *  Logic: '<S2558>/Logical46'
     *  RelationalOperator: '<S2558>/Comparison4'
     */
    rtb_TmpSignalConversionAtOutAir = (((KeTHMR_b_OutAirTemp_Est_OT_ThrsldEnbld)
        && ((TmpSignalConversionAtOutAirTemp >= KeTHMR_T_OutAirTemp_Est_Max) &&
            (!rtb_TmpSignalConversionAtOutAir))) ||
        (rtb_TmpSignalConversionAtOutAir && (KeTHMR_b_OutAirTemp_Est_FA_Enbld)));

    /* Logic: '<S2559>/Logical11' incorporates:
     *  Logic: '<S2481>/Logical11'
     */
    rtb_AND_fb = !Switch9_a;

    /* Logic: '<S2559>/Logical12' incorporates:
     *  Constant: '<S2601>/Calib'
     *  Constant: '<S2665>/Calib'
     *  Constant: '<S2666>/Calib'
     *  Logic: '<S2559>/Logical11'
     *  Logic: '<S2559>/Logical2'
     *  Logic: '<S2559>/Logical29'
     *  Logic: '<S2559>/Logical46'
     *  RelationalOperator: '<S2559>/Comparison4'
     */
    rtb_Comparison6_n3 = (((KeTHMR_b_MtrCapctrTemp_OT_ThrsldEnbld) &&
                           ((rtb_UnitDelay_cui >= KeTHMR_T_MtrCapctrTemp_Max) &&
                            rtb_AND_fb)) || (Switch9_a &&
                           (KeTHMR_b_MtrCapctrTemp_FA_Enbld)));

    /* Switch: '<S2296>/Switch2' incorporates:
     *  Inport: '<Root>/VeTHDR_b_PPCTIS_OT_FltDtct'
     */
    if (rtb_TmpSignalConversionAtVeTM_o)
    {
        /* Switch: '<S2296>/Switch2' incorporates:
         *  Constant: '<S3094>/Constant'
         */
        VeTHMR_e_PPCTIS_OT_BD = CeTHMR_e_EmergencyLevel1;
    }
    else
    {
        (void)Rte_Read_VeTHDR_b_PPCTIS_OT_FltDtct_Value(&rtb_Logical15_o);

        /* Switch: '<S2296>/Switch3' incorporates:
         *  Inport: '<Root>/VeTHDR_b_PPCTIS_OT_FltDtct'
         */
        if (rtb_Logical15_o)
        {
            /* Switch: '<S2296>/Switch2' incorporates:
             *  Constant: '<S3092>/Constant'
             */
            VeTHMR_e_PPCTIS_OT_BD = CeTHMR_e_EmergencyLevel3;
        }
        else
        {
            /* Switch: '<S2296>/Switch2' incorporates:
             *  Constant: '<S3093>/Constant'
             */
            VeTHMR_e_PPCTIS_OT_BD = CeTHMR_e_EmergencyLevel4;
        }

        /* End of Switch: '<S2296>/Switch3' */
    }

    /* End of Switch: '<S2296>/Switch2' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeTMIR_b_LTR_ClntTmpOut_FA' */
    (void)Rte_Read_VeTMIR_b_LTR_ClntTmpOut_FA_Value(&rtb_Logical4_iq);

    /* Inport: '<Root>/VeTMIR_T_OBCMTemp4_AD' */
    (void)Rte_Read_VeTMIR_T_OBCMTemp4_AD_Value(&rtb_Switch1_ofq);

    /* Inport: '<Root>/VeTMIR_T_OBCMTemp3_AD' */
    (void)Rte_Read_VeTMIR_T_OBCMTemp3_AD_Value(&rtb_Add4_m1);

    /* Inport: '<Root>/VeTMIR_Pct_TCU_Load_Index' */
    (void)Rte_Read_VeTMIR_Pct_TCU_Load_Index_Value(&rtb_Switch1_muc);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Cals'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* RelationalOperator: '<S2689>/Comparison19' incorporates:
     *  RelationalOperator: '<S2689>/Comparison18'
     *  RelationalOperator: '<S5073>/RelationalOperator'
     *  RelationalOperator: '<S5134>/RelationalOperator3'
     *  Switch: '<S2296>/Switch2'
     *  Switch: '<S316>/Switch'
     */
    rtb_Logical15_j_tmp = VeTHMR_e_PPCTIS_OT_BD;

    /* Logic: '<S2689>/Logical15' incorporates:
     *  Constant: '<S2678>/Calib'
     *  Constant: '<S2679>/Calib'
     *  Constant: '<S2701>/Constant'
     *  Constant: '<S2702>/Constant'
     *  Logic: '<S2689>/Logical13'
     *  Logic: '<S2689>/Logical14'
     *  RelationalOperator: '<S2689>/Comparison18'
     *  RelationalOperator: '<S2689>/Comparison19'
     *  Switch: '<S2296>/Switch2'
     */
    rtb_Logical15_o = (((CeTHMR_e_EmergencyLevel3 == ((uint32)
                          VeTHMR_e_PPCTIS_OT_BD)) || ((((uint32)
                           VeTHMR_e_PPCTIS_OT_BD) == CeTHMR_e_EmergencyLevel1) &&
                         (KeTHMR_b_PPCTIS_OT_SNA_RemActEnb))) &&
                       (KeTHMR_b_PPCTIS_OT_RemActEnb));

    /* Logic: '<S2560>/Logical11' incorporates:
     *  Logic: '<S2482>/Logical11'
     */
    rtb_Logical46_hh = !rtb_TmpSignalConversionAtVeT_pw;

    /* Logic: '<S2560>/Logical12' incorporates:
     *  Constant: '<S2586>/Calib'
     *  Constant: '<S2631>/Calib'
     *  Constant: '<S2632>/Calib'
     *  Logic: '<S2560>/Logical11'
     *  Logic: '<S2560>/Logical2'
     *  Logic: '<S2560>/Logical29'
     *  Logic: '<S2560>/Logical46'
     *  RelationalOperator: '<S2560>/Comparison4'
     */
    rtb_AND_ko5 = (((KeTHMR_b_CntrlBrdTmp_Snsr2OT_ThrsldEnbld) &&
                    ((rtb_TmpSignalConversionAtVeT_gg >=
                      KeTHMR_T_CntrlBrdTmp_Snsr2_TempMax) && rtb_Logical46_hh)) ||
                   (rtb_TmpSignalConversionAtVeT_pw &&
                    (KeTHMR_b_CntrlBrdTmp_Snsr2_FA_Enbld)));

    /* Logic: '<S2551>/Logical17' incorporates:
     *  Constant: '<S2695>/Constant'
     *  Constant: '<S2696>/Constant'
     *  Constant: '<S2697>/Calib'
     *  Logic: '<S2551>/Logical16'
     *  RelationalOperator: '<S2551>/Comparison20'
     *  RelationalOperator: '<S2551>/Comparison21'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     */
    rtb_Comparison5_c3m = (((((uint32)rtb_TmpSignalConversionAtVePD_l) ==
        CePDTR_e_Dischrg_BatTempNotOpt) || (((uint32)
        rtb_TmpSignalConversionAtVePD_l) == CePDTR_e_Dischrg_ForcBatCool_Hys)) &&
                           (KeTHMR_b_Enbl_RadFanFor_PowerDisp));

    /* Logic: '<S2539>/Logical1' incorporates:
     *  Constant: '<S2680>/Calib'
     *  Constant: '<S2681>/Calib'
     *  Logic: '<S2539>/Logical2'
     *  Logic: '<S2539>/Logical29'
     */
    rtb_Logical5_bn = ((((VeTHMR_b_LTPsvPumpTemp_FA_AD) &&
                         (VeTHMR_b_LTPsvPump2Temp_FA_AD)) &&
                        (KeTHMR_b_PsvPump_DualChk_Enbl)) ||
                       ((VeTHMR_b_LTPsvPumpTemp_FA_AD) &&
                        (KeTHMR_b_PsvPump_SingleChk_Enbl)));

    /* Logic: '<S2692>/Logical12' incorporates:
     *  Constant: '<S2574>/Calib'
     *  Constant: '<S2682>/Calib'
     *  Constant: '<S2683>/Calib'
     *  Logic: '<S2692>/Logical11'
     *  Logic: '<S2692>/Logical2'
     *  Logic: '<S2692>/Logical29'
     *  Logic: '<S2692>/Logical46'
     *  RelationalOperator: '<S2692>/Comparison4'
     */
    rtb_TmpSignalConversionAtVeT_d5 = (((KeTHMR_b_TCU_Load_Index_Chk_Enbl) &&
        ((rtb_Switch1_muc >= KeTHMR_Pct_TCU_Load_Index_Max_Alwd) &&
         (!rtb_TmpSignalConversionAtVeT_d5))) ||
        (rtb_TmpSignalConversionAtVeT_d5 && (KeTHMR_b_TCU_Load_Index_FA_Chk_Enbl)));

    /* Logic: '<S2687>/Logical12' incorporates:
     *  Constant: '<S2604>/Calib'
     *  Constant: '<S2671>/Calib'
     *  Constant: '<S2672>/Calib'
     *  Logic: '<S2687>/Logical11'
     *  Logic: '<S2687>/Logical2'
     *  Logic: '<S2687>/Logical29'
     *  Logic: '<S2687>/Logical46'
     *  RelationalOperator: '<S2687>/Comparison4'
     */
    rtb_TmpSignalConversionAtVeT_ib = (((KeTHMR_b_OBCMTemp3_Chk_Enbl) &&
        ((rtb_Add4_m1 >= KeTHMR_T_OBCMTemp3_Max_Alwd) &&
         (!rtb_TmpSignalConversionAtVeT_ib))) ||
        (rtb_TmpSignalConversionAtVeT_ib && (KeTHMR_b_OBCMTemp3_FA_Chk_Enbl)));

    /* Logic: '<S2688>/Logical12' incorporates:
     *  Constant: '<S2605>/Calib'
     *  Constant: '<S2673>/Calib'
     *  Constant: '<S2674>/Calib'
     *  Logic: '<S2688>/Logical11'
     *  Logic: '<S2688>/Logical2'
     *  Logic: '<S2688>/Logical29'
     *  Logic: '<S2688>/Logical46'
     *  RelationalOperator: '<S2688>/Comparison4'
     */
    rtb_AND_jo = (((KeTHMR_b_OBCMTemp4_Chk_Enbl) && ((rtb_Switch1_ofq >=
                     KeTHMR_T_OBCMTemp4_Max_Alwd) &&
                    (!rtb_TmpSignalConversionAtVeT_c0))) ||
                  (rtb_TmpSignalConversionAtVeT_c0 &&
                   (KeTHMR_b_OBCMTemp4_FA_Chk_Enbl)));

    /* Logic: '<S2550>/Logical17' incorporates:
     *  Constant: '<S2694>/Calib'
     */
    rtb_AND_eb = (In1 && (KeTHMR_b_Enbl_EmrgyRun2_ForFanFault));

    /* Logic: '<S2686>/Logical17' incorporates:
     *  Constant: '<S2715>/Constant1'
     *  Constant: '<S2715>/Constant2'
     *  DataStoreRead: '<S2715>/StatusByte_MtrElect_CoolPmpATempSnsrPerf'
     *  Logic: '<S2715>/Logical Operator'
     *  RelationalOperator: '<S2715>/Relational Operator1'
     *  RelationalOperator: '<S2715>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S2715>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2715>/Bitwise Operator2'
     */
    rtb_AND_g2 = (((((uint32)THMR_ac_DW.StatusByte_MtrElect_CoolPmpATem) & 1U)
                   != 0U) && ((((uint32)
                     THMR_ac_DW.StatusByte_MtrElect_CoolPmpATem) & 64U) == 0U));

    /* Logic: '<S2691>/Logical' incorporates:
     *  Constant: '<S2714>/Constant'
     *  DataStoreRead: '<S2714>/StatusByte_MtrElect_CT_SnsrPerf'
     *  RelationalOperator: '<S2714>/RelationalOperator'
     *  S-Function (sfix_bitop): '<S2714>/BitwiseOperator7'
     */
    rtb_OR1_he = ((((sint32)THMR_ac_DW.StatusByte_MtrElect_CT_SnsrPerf) & 1) > 0);

    /* Logic: '<S2690>/Logical3' incorporates:
     *  Constant: '<S2713>/Constant'
     *  DataStoreRead: '<S2713>/StatusByte_CT_SnsrPerf'
     *  RelationalOperator: '<S2713>/RelationalOperator'
     *  S-Function (sfix_bitop): '<S2713>/BitwiseOperator7'
     */
    rtb_Logical3_at = ((((sint32)THMR_ac_DW.StatusByte_CT_SnsrPerf) & 1) > 0);

    /* Logic: '<S2693>/Logical4' incorporates:
     *  Constant: '<S2716>/Constant1'
     *  Constant: '<S2716>/Constant2'
     *  DataStoreRead: '<S2716>/StatusByte_MtrElect_CoolPmpBTempSnsrPerf'
     *  Logic: '<S2716>/Logical Operator'
     *  RelationalOperator: '<S2716>/Relational Operator1'
     *  RelationalOperator: '<S2716>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S2716>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2716>/Bitwise Operator2'
     */
    rtb_Logical4_of = (((((uint32)THMR_ac_DW.StatusByte_MtrElect_CoolPmpBTem) &
                         1U) != 0U) && ((((uint32)
                          THMR_ac_DW.StatusByte_MtrElect_CoolPmpBTem) & 64U) ==
                        0U));

    /* Logic: '<S2693>/Logical6' incorporates:
     *  Logic: '<S2693>/Logical8'
     */
    rtb_TmpSignalConversionAtVeT_c0 = (rtb_OR1_he || rtb_Logical3_at);

    /* Logic: '<S2693>/Logical4' incorporates:
     *  Constant: '<S2717>/Calib'
     *  Constant: '<S2718>/Calib'
     *  Constant: '<S2719>/Calib'
     *  Constant: '<S2720>/Calib'
     *  Constant: '<S2721>/Calib'
     *  Logic: '<S2693>/Logical1'
     *  Logic: '<S2693>/Logical17'
     *  Logic: '<S2693>/Logical2'
     *  Logic: '<S2693>/Logical3'
     *  Logic: '<S2693>/Logical5'
     *  Logic: '<S2693>/Logical6'
     *  Logic: '<S2693>/Logical7'
     *  Logic: '<S2693>/Logical8'
     *  Logic: '<S2693>/Logical9'
     */
    rtb_Logical4_of = (((((rtb_AND_g2 && (rtb_TmpSignalConversionAtVeT_c0 ||
                            (rtb_Logical4_of ||
        (KeTHMR_b_Enbl_EmrgyRun_P0CEA_SngPmp)))) &&
                          (KeTHMR_b_Enbl_EmrgyRun_P0CEA)) || (rtb_OR1_he &&
                          (KeTHMR_b_Enbl_EmrgyRun_P0A01))) || (rtb_Logical3_at &&
                         (KeTHMR_b_Enbl_EmrgyRun_P0CEF))) || ((rtb_Logical4_of &&
                         (rtb_TmpSignalConversionAtVeT_c0 || rtb_AND_g2)) &&
                        (KeTHMR_b_Enbl_EmrgyRun_P1EA3)));

    /* S-Function (sfix_bitop): '<S2704>/BitwiseOperator7' incorporates:
     *  DataStoreRead: '<S2704>/StatusByte_PwrElecPmpPerf'
     *  S-Function (sfix_bitop): '<S2370>/BitwiseOperator7'
     */
    rtb_Logical3_ks_tmp = ((sint32)THMR_ac_DW.StatusByte_PwrElecPmpPerf) & 1;

    /* Logic: '<S2690>/Logical3' incorporates:
     *  Constant: '<S2703>/Constant1'
     *  Constant: '<S2703>/Constant2'
     *  Constant: '<S2704>/Constant'
     *  Constant: '<S2705>/Calib'
     *  Constant: '<S2706>/Calib'
     *  Constant: '<S2707>/Calib'
     *  DataStoreRead: '<S2703>/StatusByte_MtrElect_CoolPumBCtrlPerf'
     *  Logic: '<S2690>/Logical1'
     *  Logic: '<S2690>/Logical11'
     *  Logic: '<S2690>/Logical2'
     *  Logic: '<S2703>/Logical Operator'
     *  RelationalOperator: '<S2703>/Relational Operator1'
     *  RelationalOperator: '<S2703>/Relational Operator2'
     *  RelationalOperator: '<S2704>/RelationalOperator'
     *  S-Function (sfix_bitop): '<S2703>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2703>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S2704>/BitwiseOperator7'
     */
    rtb_Logical3_at = ((((rtb_Logical3_ks_tmp > 0) &&
                         (KeTHMR_b_Enbl_EmrgyRun_P0C73)) &&
                        (!KeTHMR_b_EmrgyRunSwitchLv1or2_P0C73)) || ((((((uint32)
                            THMR_ac_DW.StatusByte_MtrElect_CoolPumBCtr) & 1U) !=
                          0U) && ((((uint32)
                            THMR_ac_DW.StatusByte_MtrElect_CoolPumBCtr) & 64U) ==
                          0U)) && (KeTHMR_b_Enbl_EmrgyRun_P0C74)));

    /* Logic: '<S2691>/Logical' incorporates:
     *  Constant: '<S2708>/Constant'
     *  Constant: '<S2709>/Constant'
     *  Constant: '<S2710>/Calib'
     *  Constant: '<S2711>/Calib'
     *  Constant: '<S2712>/Calib'
     *  DataStoreRead: '<S2708>/StatusByte_HybEvBatPacCoolCtrlVlv2CtrlCktLo'
     *  DataStoreRead: '<S2709>/StatusByte_HybEvBatPacCoolCtrlVlvBPerfStkOff'
     *  Logic: '<S2691>/Logical2'
     *  Logic: '<S2691>/Logical3'
     *  Logic: '<S2691>/Logical4'
     *  RelationalOperator: '<S2691>/Comparison4'
     *  RelationalOperator: '<S2708>/RelationalOperator'
     *  RelationalOperator: '<S2709>/RelationalOperator'
     *  S-Function (sfix_bitop): '<S2708>/BitwiseOperator7'
     *  S-Function (sfix_bitop): '<S2709>/BitwiseOperator7'
     */
    rtb_OR1_he = (((((((sint32)THMR_ac_DW.StatusByte_HybEvBatPacCoolCtr_k) & 2) >
                     0) && (KeTHMR_b_BatClntVlvBStkOn_En)) || (((((sint32)
                       THMR_ac_DW.StatusByte_HybEvBatPacCoolCtrlV) & 2) > 0) &&
                    (KeTHMR_b_BatClntVlv2CtrlCktLo_En))) &&
                  (rtb_TmpSignalConversionAtVeBTRR >
                   KeTHMR_T_BatCellTemp_Thrshld_Emgncy_Cooling));

    /* S-Function (sfix_bitop): '<S2568>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S2568>/StatusByte_MtrElect_CT_SnsrBPerf'
     *  S-Function (sfix_bitop): '<S2515>/Bitwise Operator2'
     */
    rtb_AND_bp_tmp = ((uint32)THMR_ac_DW.StatusByte_MtrElect_CT_SnsrBPer) & 1U;

    /* S-Function (sfix_bitop): '<S2568>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S2568>/StatusByte_MtrElect_CT_SnsrBPerf'
     *  S-Function (sfix_bitop): '<S2515>/Bitwise Operator1'
     */
    rtb_AND_bp_tmp_0 = ((uint32)THMR_ac_DW.StatusByte_MtrElect_CT_SnsrBPer) &
        64U;

    /* Logic: '<S2686>/Logical17' incorporates:
     *  Constant: '<S2568>/Constant1'
     *  Constant: '<S2568>/Constant2'
     *  Constant: '<S2700>/Calib'
     *  Logic: '<S2568>/Logical Operator'
     *  Logic: '<S2686>/Logical1'
     *  RelationalOperator: '<S2568>/Relational Operator1'
     *  RelationalOperator: '<S2568>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S2568>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2568>/Bitwise Operator2'
     */
    rtb_AND_g2 = ((rtb_Logical4_iq || ((rtb_AND_bp_tmp != 0U) &&
                    (rtb_AND_bp_tmp_0 == 0U))) && (KeTHMR_b_Enbl_LRCTOS_FA));

    /* Logic: '<S2540>/Logical12' incorporates:
     *  Constant: '<S2600>/Calib'
     *  Constant: '<S2663>/Calib'
     *  Constant: '<S2664>/Calib'
     *  Logic: '<S2540>/Logical11'
     *  Logic: '<S2540>/Logical2'
     *  Logic: '<S2540>/Logical29'
     *  Logic: '<S2540>/Logical46'
     *  RelationalOperator: '<S2540>/Comparison4'
     */
    rtb_Logical12_fs = (((KeTHMR_b_MtrC_Temp_OT_ThrsldEnbld) &&
                         ((VeTHMR_T_MtrC_Temp >= KeTHMR_T_MtrC_Temp_Max) &&
                          (!VeTHMR_b_MtrC_TempFA))) || ((VeTHMR_b_MtrC_TempFA) &&
                         (KeTHMR_b_MtrC_Temp_FA_Enbld)));

    /* Logic: '<S2541>/Logical12' incorporates:
     *  Constant: '<S2598>/Calib'
     *  Constant: '<S2659>/Calib'
     *  Constant: '<S2660>/Calib'
     *  Logic: '<S2541>/Logical11'
     *  Logic: '<S2541>/Logical2'
     *  Logic: '<S2541>/Logical29'
     *  Logic: '<S2541>/Logical46'
     *  RelationalOperator: '<S2541>/Comparison4'
     */
    rtb_Logical12_hd = (((KeTHMR_b_MtrC_InvrtrTemp_OT_ThrsldEnbld) &&
                         ((VeTHMR_T_MtrC_InvrtrTemp >=
                           KeTHMR_T_MtrC_InvrtrTemp_Max) &&
                          (!VeTHMR_b_MtrC_InvrtrTempFA))) ||
                        ((VeTHMR_b_MtrC_InvrtrTempFA) &&
                         (KeTHMR_b_MtrC_InvrtrTemp_FA_Enbld)));

    /* Logic: '<S2561>/Logical12' incorporates:
     *  Constant: '<S2599>/Calib'
     *  Constant: '<S2661>/Calib'
     *  Constant: '<S2662>/Calib'
     *  Logic: '<S2561>/Logical11'
     *  Logic: '<S2561>/Logical2'
     *  Logic: '<S2561>/Logical29'
     *  Logic: '<S2561>/Logical46'
     *  RelationalOperator: '<S2561>/Comparison4'
     */
    rtb_Logical12_gu = (((KeTHMR_b_MtrC_Rotor_Temp_OT_ThrsldEnbld) &&
                         ((VeTHMR_T_MtrC_RotorTemp >=
                           KeTHMR_T_MtrC_Rotor_Temp_Max) &&
                          (!VeTHMR_b_MtrC_RotorTemp_FA))) ||
                        ((VeTHMR_b_MtrC_RotorTemp_FA) &&
                         (KeTHMR_b_MtrC_Rotor_FA_Enbld)));

    /* Logic: '<S2562>/Logical12' incorporates:
     *  Constant: '<S2597>/Calib'
     *  Constant: '<S2657>/Calib'
     *  Constant: '<S2658>/Calib'
     *  Logic: '<S2562>/Logical11'
     *  Logic: '<S2562>/Logical2'
     *  Logic: '<S2562>/Logical29'
     *  Logic: '<S2562>/Logical46'
     *  RelationalOperator: '<S2562>/Comparison4'
     */
    rtb_Logical12_c2 = (((KeTHMR_b_MtrC_CntrlBoardTemp_OT_ThrsldEnbld) &&
                         ((VeTHMR_T_MtrC_CntrlBoardTemp_AF >=
                           KeTHMR_T_MtrC_CntrlBoardTemp_Max) &&
                          (!VeTHMR_b_MtrC_CntrlBoardTemp_FA))) ||
                        ((VeTHMR_b_MtrC_CntrlBoardTemp_FA) &&
                         (KeTHMR_b_MtrC_CntrlBoardTemp_FA_Enbld)));

    /* Logic: '<S2563>/Logical12' incorporates:
     *  Constant: '<S2595>/Calib'
     *  Constant: '<S2653>/Calib'
     *  Constant: '<S2654>/Calib'
     *  Logic: '<S2563>/Logical11'
     *  Logic: '<S2563>/Logical2'
     *  Logic: '<S2563>/Logical29'
     *  Logic: '<S2563>/Logical46'
     *  RelationalOperator: '<S2563>/Comparison4'
     */
    rtb_Logical12_gap = (((KeTHMR_b_MtrB_Rotor_Temp_OT_ThrsldEnbld) &&
                          ((VeTHMR_T_P1P2p5_MtrB_MtrRotorTemp >=
                            KeTHMR_T_MtrB_Rotor_Temp_Max) &&
                           (!VeTHMR_b_P1P2p5_MtrB_MtrRotorTemp_FA))) ||
                         ((VeTHMR_b_P1P2p5_MtrB_MtrRotorTemp_FA) &&
                          (KeTHMR_b_MtrB_Rotor_Temp_FA_Enbld)));

    /* Logic: '<S2555>/Logical12' incorporates:
     *  Constant: '<S2592>/Calib'
     *  Constant: '<S2647>/Calib'
     *  Constant: '<S2648>/Calib'
     *  Logic: '<S2555>/Logical11'
     *  Logic: '<S2555>/Logical2'
     *  Logic: '<S2555>/Logical29'
     *  Logic: '<S2555>/Logical46'
     *  RelationalOperator: '<S2555>/Comparison4'
     */
    rtb_Logical12_cpl = (((KeTHMR_b_MtrB_CntrlBoard_Temp_OT_ThrsldEnbld) &&
                          ((VeTHMR_T_P1P2p5_MtrB_CntrlBoardTemp_AF >=
                            KeTHMR_T_MtrB_CntrlBoard_Temp_Max) &&
                           (!VeTHMR_b_P1P2p5_MtrB_CntrlBoardTemp_FA))) ||
                         ((VeTHMR_b_P1P2p5_MtrB_CntrlBoardTemp_FA) &&
                          (KeTHMR_b_MtrB_CntrlBoard_Temp_FA_Enbld)));

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* RelationalOperator: '<S2552>/Comparison20' incorporates:
     *  Merge: '<S4573>/Merge2'
     *  RelationalOperator: '<S1164>/Comparison3'
     *  RelationalOperator: '<S1215>/RelationalOperator0'
     *  RelationalOperator: '<S1215>/RelationalOperator1'
     *  RelationalOperator: '<S2293>/Comparison4'
     */
    rtb_Logical17_o_tmp = THMR_ac_B.VeTHMR_e_FCThrmlState;

    /* Logic: '<S2552>/Logical17' incorporates:
     *  Constant: '<S2698>/Constant'
     *  Constant: '<S2699>/Calib'
     *  RelationalOperator: '<S2552>/Comparison20'
     */
    rtb_Logical17_o = ((((uint32)rtb_Logical17_o_tmp) == CeTHMR_e_FCBoostCool) &&
                       (KeTHMR_b_LTCLEmrgncyRun_FCBoostCool));

    /* Logic: '<S2530>/Logical12' incorporates:
     *  Constant: '<S2581>/Calib'
     *  Constant: '<S2621>/Calib'
     *  Constant: '<S2622>/Calib'
     *  Logic: '<S2530>/Logical11'
     *  Logic: '<S2530>/Logical2'
     *  Logic: '<S2530>/Logical29'
     *  Logic: '<S2530>/Logical46'
     *  RelationalOperator: '<S2530>/Comparison4'
     */
    rtb_Logical12_pb = (((KeTHMR_b_BstCnvtrLwrIGBT_Chk_Enbl) &&
                         ((THMR_ac_B.Switch2 >=
                           KeTHMR_T_BstCnvtrLwrIGBT_Max_Alwd) &&
                          (!THMR_ac_B.Switch1_o))) || ((THMR_ac_B.Switch1_o) &&
                         (KeTHMR_b_BstCnvtrLwrIGBT_FA_Chk_Enbl)));

    /* Logic: '<S2531>/Logical12' incorporates:
     *  Constant: '<S2582>/Calib'
     *  Constant: '<S2623>/Calib'
     *  Constant: '<S2624>/Calib'
     *  Logic: '<S2531>/Logical11'
     *  Logic: '<S2531>/Logical2'
     *  Logic: '<S2531>/Logical29'
     *  Logic: '<S2531>/Logical46'
     *  RelationalOperator: '<S2531>/Comparison4'
     */
    rtb_Logical12_e5 = (((KeTHMR_b_BstCnvtrReactorTmp_Chk_Enbl) &&
                         ((THMR_ac_B.Switch3 >=
                           KeTHMR_T_BstCnvtrReactorTmp_Max_Alwd) &&
                          (!THMR_ac_B.Switch5_c))) || ((THMR_ac_B.Switch5_c) &&
                         (KeTHMR_b_BstCnvtrReactorTmpFA_Chk_Enbl)));

    /* Logic: '<S2532>/Logical12' incorporates:
     *  Constant: '<S2583>/Calib'
     *  Constant: '<S2625>/Calib'
     *  Constant: '<S2626>/Calib'
     *  Logic: '<S2532>/Logical11'
     *  Logic: '<S2532>/Logical2'
     *  Logic: '<S2532>/Logical29'
     *  Logic: '<S2532>/Logical46'
     *  RelationalOperator: '<S2532>/Comparison4'
     */
    rtb_Logical12_dh = (((KeTHMR_b_BstCnvtrUpprIGBT_Chk_Enbl) &&
                         ((THMR_ac_B.Switch4 >=
                           KeTHMR_T_BstCnvtrUpprIGBT_Max_Alwd) &&
                          (!THMR_ac_B.Switch6_g))) || ((THMR_ac_B.Switch6_g) &&
                         (KeTHMR_b_BstCnvtrUpprIGBT_FA_Chk_Enbl)));

    /* Logic: '<S2526>/Logical12' incorporates:
     *  Constant: '<S2575>/Calib'
     *  Constant: '<S2609>/Calib'
     *  Constant: '<S2610>/Calib'
     *  Logic: '<S2526>/Logical11'
     *  Logic: '<S2526>/Logical2'
     *  Logic: '<S2526>/Logical29'
     *  Logic: '<S2526>/Logical46'
     *  RelationalOperator: '<S2526>/Comparison4'
     */
    rtb_Logical12_er = (((KeTHMR_b_APM2_Temp1_OT_ThrsldEnbld) &&
                         ((VeTHMR_T_APM2_Temp1 >= KeTHMR_T_APM2_Temp1_HiMax) &&
                          (!VeTHMR_b_APM2_Temp1_FA))) ||
                        ((VeTHMR_b_APM2_Temp1_FA) &&
                         (KeTHMR_b_APM2_Temp1_FA_Enbld)));

    /* Logic: '<S2527>/Logical12' incorporates:
     *  Constant: '<S2576>/Calib'
     *  Constant: '<S2611>/Calib'
     *  Constant: '<S2612>/Calib'
     *  Logic: '<S2527>/Logical11'
     *  Logic: '<S2527>/Logical2'
     *  Logic: '<S2527>/Logical29'
     *  Logic: '<S2527>/Logical46'
     *  RelationalOperator: '<S2527>/Comparison4'
     */
    rtb_Logical12_gz = (((KeTHMR_b_APM2_Temp2_OT_ThrsldEnbld) &&
                         ((VeTHMR_T_APM2_Temp2 >= KeTHMR_T_APM2_Temp2_HiMax) &&
                          (!VeTHMR_b_APM2_Temp2_FA))) ||
                        ((VeTHMR_b_APM2_Temp2_FA) &&
                         (KeTHMR_b_APM2_Temp2_FA_Enbld)));

    /* Logic: '<S2528>/Logical12' incorporates:
     *  Constant: '<S2577>/Calib'
     *  Constant: '<S2613>/Calib'
     *  Constant: '<S2614>/Calib'
     *  Logic: '<S2528>/Logical11'
     *  Logic: '<S2528>/Logical2'
     *  Logic: '<S2528>/Logical29'
     *  Logic: '<S2528>/Logical46'
     *  RelationalOperator: '<S2528>/Comparison4'
     */
    rtb_Logical12_k5 = (((KeTHMR_b_APM3_Temp1_OT_ThrsldEnbld) &&
                         ((VeTHMR_T_APM3_Temp1 >= KeTHMR_T_APM3_Temp1_HiMax) &&
                          (!VeTHMR_b_APM3_Temp1_FA))) ||
                        ((VeTHMR_b_APM3_Temp1_FA) &&
                         (KeTHMR_b_APM3_Temp1_FA_Enbld)));

    /* Logic: '<S2529>/Logical12' incorporates:
     *  Constant: '<S2578>/Calib'
     *  Constant: '<S2615>/Calib'
     *  Constant: '<S2616>/Calib'
     *  Logic: '<S2529>/Logical11'
     *  Logic: '<S2529>/Logical2'
     *  Logic: '<S2529>/Logical29'
     *  Logic: '<S2529>/Logical46'
     *  RelationalOperator: '<S2529>/Comparison4'
     */
    rtb_Logical12_hy = (((KeTHMR_b_APM3_Temp2_OT_ThrsldEnbld) &&
                         ((VeTHMR_T_APM3_Temp2 >= KeTHMR_T_APM3_Temp2_HiMax) &&
                          (!VeTHMR_b_APM3_Temp2_FA))) ||
                        ((VeTHMR_b_APM3_Temp2_FA) &&
                         (KeTHMR_b_APM3_Temp2_FA_Enbld)));

    /* Chart: '<S2279>/StateflowChart' incorporates:
     *  Constant: '<S2298>/Calib'
     *  Constant: '<S2299>/Calib'
     *  Logic: '<S2279>/Logical4'
     *  RelationalOperator: '<S2279>/Comparison1'
     *  RelationalOperator: '<S2279>/Comparison7'
     *  Switch: '<S3780>/Switch'
     *  UnitDelay: '<S2279>/UnitDelay'
     */
    /* Gateway: THMR_FUNC_RU_MedTEH/LTCL/AHH_SF_and_Status/StateflowChart */
    /* During: THMR_FUNC_RU_MedTEH/LTCL/AHH_SF_and_Status/StateflowChart */
    if (((uint32)THMR_ac_DW.is_active_c35_THMR_ac) == 0U)
    {
        /* Entry: THMR_FUNC_RU_MedTEH/LTCL/AHH_SF_and_Status/StateflowChart */
        THMR_ac_DW.is_active_c35_THMR_ac = 1U;

        /* Entry Internal: THMR_FUNC_RU_MedTEH/LTCL/AHH_SF_and_Status/StateflowChart */
        /* Transition: '<S2300>:1' */
        THMR_ac_DW.is_c35_THMR_ac = THMR_ac_IN_No_Extended_Cooling;

        /* Entry 'No_Extended_Cooling': '<S2300>:4' */
        THMR_ac_DW.count_p = 0.0F;
    }
    else if (((sint32)THMR_ac_DW.is_c35_THMR_ac) == 1)
    {
        /* During 'Extended_Cooling': '<S2300>:3' */
        if (THMR_ac_DW.count_p >= KeTHMR_t_Extnd_Max_Cooling_for_Max_AHH_SF)
        {
            /* Transition: '<S2300>:2' */
            THMR_ac_DW.is_c35_THMR_ac = THMR_ac_IN_No_Extended_Cooling;

            /* Entry 'No_Extended_Cooling': '<S2300>:4' */
            THMR_ac_DW.count_p = 0.0F;
        }
        else
        {
            THMR_ac_B.Output_AHH_SF = 1.0F;
            THMR_ac_B.Output_AHH_Ready_Status = CeBRKR_e_AHH_NotReady;
            THMR_ac_DW.count_p += 0.1F;
        }
    }
    else
    {
        /* During 'No_Extended_Cooling': '<S2300>:4' */
        if ((VeTHMR_r_AHH_StressFactor < KeTHMR_r_AHH_StresFact_Max) &&
                (KeTHMR_r_AHH_StresFact_Max <= THMR_ac_DW.UnitDelay_DSTATE_dp))
        {
            /* Transition: '<S2300>:5' */
            THMR_ac_DW.is_c35_THMR_ac = THMR_ac_IN_Extended_Cooling;

            /* Entry 'Extended_Cooling': '<S2300>:3' */
            THMR_ac_DW.count_p = 0.2F;
        }
        else
        {
            THMR_ac_B.Output_AHH_SF = VeTHMR_r_AHH_StressFactor;
            THMR_ac_B.Output_AHH_Ready_Status = VeTHMR_e_AHH_Ready_Status_AD;
        }
    }

    /* End of Chart: '<S2279>/StateflowChart' */

    /* Logic: '<S2470>/Logical4' incorporates:
     *  Constant: '<S2608>/Calib'
     *  Constant: '<S2633>/Calib'
     *  Constant: '<S2685>/Calib'
     *  Logic: '<S2470>/Logical3'
     *  Logic: '<S2534>/Logical46'
     *  RelationalOperator: '<S2534>/Comparison4'
     */
    rtb_Logical4_iq = (((KeTHMR_b_AHH_StresFact_ThrsldEnbld) &&
                        (THMR_ac_B.Output_AHH_SF >=
                         KeTHMR_r_EOPEmrgCool_AHH_StresFact_Max)) &&
                       (KeTHMR_b_EOPEmrgCool_AHH_Enbld));

    /* Logic: '<S2470>/Logical5' incorporates:
     *  Constant: '<S2589>/Calib'
     *  Constant: '<S2634>/Calib'
     *  Constant: '<S2641>/Calib'
     *  Constant: '<S2642>/Calib'
     *  Logic: '<S2470>/Logical46'
     *  Logic: '<S2533>/Logical11'
     *  Logic: '<S2533>/Logical12'
     *  Logic: '<S2533>/Logical2'
     *  Logic: '<S2533>/Logical29'
     *  Logic: '<S2533>/Logical46'
     *  RelationalOperator: '<S2533>/Comparison4'
     */
    rtb_TmpSignalConversionAtVeT_c0 = (((rtb_Logical12_dt &&
        (KeTHMR_b_EOPEmrgCool_MtrA_Enbld)) ||
        (((KeTHMR_b_MtrA_OilPumpTemp_ThrsldEnbld) && ((VeTHMR_T_PumpOilTemp >=
        KeTHMR_T_MtrA_OilPumpTemp_Max) && (!VeTHMR_b_PumpOilTemp_FA))) ||
         ((VeTHMR_b_PumpOilTemp_FA) && (KeTHMR_b_MtrA_OilPumpTemp_FA_Enbld)))) ||
        rtb_Logical4_iq);

    /* Logic: '<S2470>/Logical4' incorporates:
     *  Constant: '<S2594>/Calib'
     *  Constant: '<S2635>/Calib'
     *  Constant: '<S2651>/Calib'
     *  Constant: '<S2652>/Calib'
     *  Logic: '<S2470>/Logical2'
     *  Logic: '<S2535>/Logical11'
     *  Logic: '<S2535>/Logical12'
     *  Logic: '<S2535>/Logical2'
     *  Logic: '<S2535>/Logical29'
     *  Logic: '<S2535>/Logical46'
     *  RelationalOperator: '<S2535>/Comparison4'
     */
    rtb_Logical4_iq = ((rtb_Logical4_iq || (rtb_Logical1_bt &&
                         (KeTHMR_b_EOPEmrgCool_MtrB_Enbld))) ||
                       (((KeTHMR_b_MtrB_OilPumpTemp_ThrsldEnbld) &&
                         ((VeTHMR_T_Pump2OilTemp >=
                           KeTHMR_T_MtrB_OilPumpTemp_Max) &&
                          (!VeTHMR_b_Pump2OilTemp_FA))) ||
                        ((VeTHMR_b_Pump2OilTemp_FA) &&
                         (KeTHMR_b_MtrB_OilPumpTemp_FA_Enbld))));

    /* Logic: '<S2470>/Logical1' */
    tmpForInput[0] = rtb_Logical12_dt;
    tmpForInput[1] = rtb_Logical12_pv;
    tmpForInput[2] = rtb_Logical1_bt;
    tmpForInput[3] = rtb_Logical3_oz;
    tmpForInput[4] = rtb_VariantMerge_For_Variant__n;
    tmpForInput[5] = rtb_TmpSignalConversionAtVePD_p;
    tmpForInput[6] = rtb_TmpSignalConversionAtVePD_i;
    tmpForInput[7] = rtb_AND_c3;
    tmpForInput[8] = rtb_OR1_g4;
    tmpForInput[9] = rtb_Logical18_d;
    tmpForInput[10] = rtb_Logical6_or;
    tmpForInput[11] = rtb_Comparison3_bu;
    tmpForInput[12] = Switch5_i;
    tmpForInput[13] = rtb_AND_cn;
    tmpForInput[14] = rtb_Comparison4_cx;
    tmpForInput[15] = rtb_TmpSignalConversionAtOutAir;
    tmpForInput[16] = rtb_Comparison6_n3;
    tmpForInput[17] = rtb_Logical15_o;
    tmpForInput[18] = rtb_AND_ko5;
    tmpForInput[19] = rtb_Comparison5_c3m;
    tmpForInput[20] = rtb_Logical5_bn;
    tmpForInput[21] = rtb_TmpSignalConversionAtVeT_d5;
    tmpForInput[22] = rtb_TmpSignalConversionAtVeT_ib;
    tmpForInput[23] = rtb_AND_jo;
    tmpForInput[24] = rtb_AND_eb;
    tmpForInput[25] = rtb_Logical4_of;
    tmpForInput[26] = rtb_Logical3_at;
    tmpForInput[27] = rtb_OR1_he;
    tmpForInput[28] = rtb_AND_g2;
    tmpForInput[29] = rtb_Logical12_fs;
    tmpForInput[30] = rtb_Logical12_hd;
    tmpForInput[31] = rtb_Logical12_gu;
    tmpForInput[32] = rtb_Logical12_c2;
    tmpForInput[33] = rtb_Logical12_gap;
    tmpForInput[34] = rtb_Logical12_cpl;
    tmpForInput[35] = rtb_Logical17_o;
    tmpForInput[36] = rtb_Logical12_pb;
    tmpForInput[37] = rtb_Logical12_e5;
    tmpForInput[38] = rtb_Logical12_dh;
    tmpForInput[39] = rtb_Logical12_er;
    tmpForInput[40] = rtb_Logical12_gz;
    tmpForInput[41] = rtb_Logical12_k5;
    tmpForInput[42] = rtb_Logical12_hy;
    tmpForInput[43] = rtb_TmpSignalConversionAtVeT_c0;
    tmpForInput[44] = rtb_Logical4_iq;
    rtb_AND_fe = rtb_Logical12_dt;
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 44;
            rtb_DataTypeConversion2++)
    {
        rtb_AND_fe = (rtb_AND_fe || (tmpForInput[rtb_DataTypeConversion2 + 1]));
    }

    /* Logic: '<S2470>/Logical1' */
    VeTHMR_b_EmrgcyFanRq_Lvl2 = rtb_AND_fe;

    /* Logic: '<S2474>/Logical46' incorporates:
     *  Constant: '<S2496>/Calib'
     *  Constant: '<S2505>/Calib'
     *  Logic: '<S2474>/Logical2'
     *  RelationalOperator: '<S2474>/Comparison4'
     */
    rtb_TmpSignalConversionAtVeTM_j = ((KeTHMR_b_OBCMTemp1_Lo_OT_ThrsldEnbl) &&
        ((rtb_TmpSignalConversionAtVeT_fy >= KeTHMR_T_OBCMTemp1_LoMax) &&
         rtb_Logical1_c0));

    /* Logic: '<S2475>/Logical46' incorporates:
     *  Constant: '<S2497>/Calib'
     *  Constant: '<S2506>/Calib'
     *  Logic: '<S2475>/Logical2'
     *  RelationalOperator: '<S2475>/Comparison4'
     */
    rtb_TmpSignalConversionAtVeT_f5 = ((KeTHMR_b_OBCMTemp2_Lo_OT_ThrsldEnbl) &&
        ((rtb_TmpSignalConversionAtVeTM_n >= KeTHMR_T_OBCMTemp2_LoMax) &&
         rtb_Logical1_li));

    /* Logic: '<S2477>/Logical46' incorporates:
     *  Constant: '<S2494>/Calib'
     *  Constant: '<S2503>/Calib'
     *  Logic: '<S2477>/Logical2'
     *  RelationalOperator: '<S2477>/Comparison4'
     */
    rtb_Logical46_fu = ((KeTHMR_b_MtrA_TempLo_OT_ThrsldEnbld) &&
                        ((VeTHMR_T_MtrA_Temp >= KeTHMR_T_MtrA_Temp_LoMax) &&
                         rtb_Logical46_fu));

    /* Logic: '<S2478>/Logical46' incorporates:
     *  Constant: '<S2493>/Calib'
     *  Constant: '<S2502>/Calib'
     *  Logic: '<S2478>/Logical2'
     *  RelationalOperator: '<S2478>/Comparison4'
     */
    rtb_Logical46_j2 = ((KeTHMR_b_MtrA_InvrtrTempLo_OT_ThrsldEnbld) &&
                        ((VeTHMR_T_MtrA_InvrtrTemp >=
                          KeTHMR_T_MtrA_InvrtrTemp_LoMax) && rtb_Logical46_j2));

    /* Logic: '<S2479>/Logical46' incorporates:
     *  Constant: '<S2492>/Calib'
     *  Constant: '<S2499>/Calib'
     *  Logic: '<S2479>/Logical2'
     *  RelationalOperator: '<S2479>/Comparison4'
     */
    rtb_Logical46_ov = ((KeTHMR_b_CntrlBoard_TempLo_OT_ThrsldEnbld) &&
                        ((rtb_Merge1_i >= KeTHMR_T_CntrlBoard_Temp_LoMax) &&
                         rtb_Logical46_cr));

    /* Logic: '<S2480>/Logical46' incorporates:
     *  Constant: '<S2498>/Calib'
     *  Constant: '<S2507>/Calib'
     *  Logic: '<S2480>/Logical2'
     *  RelationalOperator: '<S2480>/Comparison4'
     */
    rtb_Logical46_cr = ((KeTHMR_b_Rotor_TempLo_OT_ThrsldEnbld) &&
                        ((VeTHMR_T_BSG_MtrRotorTemp >= KeTHMR_T_Rotor_Temp_LoMax)
                         && rtb_Logical17_h));

    /* Logic: '<S2481>/Logical46' incorporates:
     *  Constant: '<S2495>/Calib'
     *  Constant: '<S2504>/Calib'
     *  Logic: '<S2481>/Logical2'
     *  RelationalOperator: '<S2481>/Comparison4'
     */
    Switch9_a = ((KeTHMR_b_MtrCapctrTempLo_OT_ThrsldEnbld) &&
                 ((rtb_UnitDelay_cui >= KeTHMR_T_MtrCapctrTemp_LoMax) &&
                  rtb_AND_fb));

    /* Logic: '<S2482>/Logical46' incorporates:
     *  Constant: '<S2473>/Calib'
     *  Constant: '<S2500>/Calib'
     *  Logic: '<S2482>/Logical2'
     *  RelationalOperator: '<S2482>/Comparison4'
     */
    rtb_Logical46_hh = ((KeTHMR_b_CntrlBrdTmp_Snsr2_OTLo_Enbld) &&
                        ((rtb_TmpSignalConversionAtVeT_gg >=
                          KeTHMR_T_CntrlBrdTmp_Snsr2_LoMax) && rtb_Logical46_hh));

    /* Logic: '<S2476>/Logical17' incorporates:
     *  Constant: '<S2512>/Calib'
     */
    rtb_Logical17_h = (In1 && (KeTHMR_b_Enbl_EmrgyRun1_ForFanFault));

    /* Logic: '<S2508>/Logical1' incorporates:
     *  Constant: '<S2513>/Constant1'
     *  Constant: '<S2513>/Constant2'
     *  Constant: '<S2514>/Constant1'
     *  Constant: '<S2514>/Constant2'
     *  Constant: '<S2515>/Constant1'
     *  Constant: '<S2515>/Constant2'
     *  Constant: '<S2516>/Calib'
     *  Constant: '<S2517>/Calib'
     *  Constant: '<S2518>/Calib'
     *  DataStoreRead: '<S2513>/StatusByte_MtrElect_CT2_SnsrBCktHi'
     *  DataStoreRead: '<S2514>/StatusByte_MtrElect_CT2_SnsrBCktLo'
     *  Logic: '<S2508>/Logical'
     *  Logic: '<S2508>/Logical2'
     *  Logic: '<S2508>/Logical3'
     *  Logic: '<S2513>/Logical Operator'
     *  Logic: '<S2514>/Logical Operator'
     *  Logic: '<S2515>/Logical Operator'
     *  RelationalOperator: '<S2513>/Relational Operator1'
     *  RelationalOperator: '<S2513>/Relational Operator2'
     *  RelationalOperator: '<S2514>/Relational Operator1'
     *  RelationalOperator: '<S2514>/Relational Operator2'
     *  RelationalOperator: '<S2515>/Relational Operator1'
     *  RelationalOperator: '<S2515>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S2513>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2513>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S2514>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2514>/Bitwise Operator2'
     */
    rtb_Logical1_c0 = ((((KeTHMR_b_Enbl_EmrgyRun1_SnsrBCktLo) && (((((uint32)
        THMR_ac_DW.StatusByte_MtrElect_CT2_SnsrB_d) & 1U) != 0U) && ((((uint32)
        THMR_ac_DW.StatusByte_MtrElect_CT2_SnsrB_d) & 64U) == 0U))) ||
                        ((KeTHMR_b_Enbl_EmrgyRun1_SnsrBCktHi) && (((((uint32)
        THMR_ac_DW.StatusByte_MtrElect_CT2_SnsrBCk) & 1U) != 0U) && ((((uint32)
        THMR_ac_DW.StatusByte_MtrElect_CT2_SnsrBCk) & 64U) == 0U)))) ||
                       ((KeTHMR_b_Enbl_EmrgyRun1_SnsrBPerf) && ((rtb_AND_bp_tmp
                          != 0U) && (rtb_AND_bp_tmp_0 == 0U))));

    /* S-Function (sfix_bitop): '<S2483>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S2483>/StatusByte_LostCommMtrElectCoolPmpA'
     *  S-Function (sfix_bitop): '<S2368>/Bitwise Operator2'
     */
    rtb_AND_bp_tmp = ((uint32)THMR_ac_DW.StatusByte_LostCommMtrElectCool) & 1U;

    /* S-Function (sfix_bitop): '<S2483>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S2483>/StatusByte_LostCommMtrElectCoolPmpA'
     *  S-Function (sfix_bitop): '<S2368>/Bitwise Operator1'
     */
    rtb_AND_bp_tmp_0 = ((uint32)THMR_ac_DW.StatusByte_LostCommMtrElectCool) &
        64U;

    /* S-Function (sfix_bitop): '<S2486>/BitwiseOperator7' incorporates:
     *  DataStoreRead: '<S2486>/StatusByte_MtrElect_CoolPumAOvrSpd'
     *  S-Function (sfix_bitop): '<S2369>/BitwiseOperator7'
     *  S-Function (sfix_bitop): '<S3016>/BitwiseOperator7'
     */
    rtb_Logical1_du_tmp = ((sint32)THMR_ac_DW.StatusByte_MtrElect_CoolPumAOvr) &
        1;

    /* Logic: '<S2509>/Logical1' incorporates:
     *  Constant: '<S2483>/Constant1'
     *  Constant: '<S2483>/Constant2'
     *  Constant: '<S2486>/Constant'
     *  Constant: '<S2519>/Calib'
     *  Constant: '<S2520>/Calib'
     *  Logic: '<S2483>/Logical Operator'
     *  Logic: '<S2509>/Logical17'
     *  Logic: '<S2509>/Logical2'
     *  RelationalOperator: '<S2483>/Relational Operator1'
     *  RelationalOperator: '<S2483>/Relational Operator2'
     *  RelationalOperator: '<S2486>/RelationalOperator'
     *  S-Function (sfix_bitop): '<S2483>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2483>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S2486>/BitwiseOperator7'
     */
    rtb_Logical1_li = ((((rtb_AND_bp_tmp != 0U) && (rtb_AND_bp_tmp_0 == 0U)) &&
                        (KeTHMR_b_Enbl_PECP_LOC_Flag)) || ((rtb_Logical1_du_tmp >
                         0) && (KeTHMR_b_Enbl_PECP_DryRun_Flag)));

    /* S-Function (sfix_bitop): '<S2485>/BitwiseOperator7' incorporates:
     *  DataStoreRead: '<S2485>/StatusByte_MtrElect_CooPumBOvrSpd'
     *  S-Function (sfix_bitop): '<S3014>/BitwiseOperator7'
     */
    rtb_Logical1_b3_tmp = ((sint32)THMR_ac_DW.StatusByte_MtrElect_CooPumBOvrS) &
        1;

    /* Logic: '<S2510>/Logical1' incorporates:
     *  Constant: '<S2484>/Constant1'
     *  Constant: '<S2484>/Constant2'
     *  Constant: '<S2485>/Constant'
     *  Constant: '<S2521>/Calib'
     *  Constant: '<S2522>/Calib'
     *  DataStoreRead: '<S2484>/StatusByte_LostCommMtrElectCoolPmpB'
     *  Logic: '<S2484>/Logical Operator'
     *  Logic: '<S2510>/Logical17'
     *  Logic: '<S2510>/Logical2'
     *  RelationalOperator: '<S2484>/Relational Operator1'
     *  RelationalOperator: '<S2484>/Relational Operator2'
     *  RelationalOperator: '<S2485>/RelationalOperator'
     *  S-Function (sfix_bitop): '<S2484>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2484>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S2485>/BitwiseOperator7'
     */
    rtb_Logical1_gx = (((((((uint32)THMR_ac_DW.StatusByte_LostCommMtrElectCo_b)
                           & 1U) != 0U) && ((((uint32)
                            THMR_ac_DW.StatusByte_LostCommMtrElectCo_b) & 64U) ==
                          0U)) && (KeTHMR_b_Enbl_PECP2_LOC_Flag)) ||
                       ((rtb_Logical1_b3_tmp > 0) &&
                        (KeTHMR_b_Enbl_PECP2_DryRun_Flag)));

    /* Logic: '<S2511>/Logical2' incorporates:
     *  Constant: '<S2523>/Constant'
     *  Constant: '<S2524>/Calib'
     *  Constant: '<S2525>/Calib'
     *  DataStoreRead: '<S2523>/StatusByte_PwrElecPmpPerf'
     *  RelationalOperator: '<S2523>/Relational Operator'
     *  S-Function (sfix_bitop): '<S2523>/Bitwise Operator7'
     */
    rtb_Logical2_oq = ((((((uint32)THMR_ac_DW.StatusByte_PwrElecPmpPerf) & 1U)
                         != 0U) && (KeTHMR_b_Enbl_EmrgyRun_P0C73)) &&
                       (KeTHMR_b_EmrgyRunSwitchLv1or2_P0C73));

    /* Logic: '<S2469>/Logical1' */
    tmpForInput_0[0] = rtb_TmpSignalConversionAtVeTM_j;
    tmpForInput_0[1] = rtb_TmpSignalConversionAtVeT_f5;
    tmpForInput_0[2] = rtb_Logical46_fu;
    tmpForInput_0[3] = rtb_Logical46_j2;
    tmpForInput_0[4] = rtb_Logical46_ov;
    tmpForInput_0[5] = rtb_Logical46_cr;
    tmpForInput_0[6] = Switch9_a;
    tmpForInput_0[7] = rtb_Logical46_hh;
    tmpForInput_0[8] = rtb_Logical17_h;
    tmpForInput_0[9] = rtb_Logical1_c0;
    tmpForInput_0[10] = rtb_Logical1_li;
    tmpForInput_0[11] = rtb_Logical1_gx;
    tmpForInput_0[12] = rtb_Logical2_oq;
    rtb_AND_fe = rtb_TmpSignalConversionAtVeTM_j;
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 12;
            rtb_DataTypeConversion2++)
    {
        rtb_AND_fe = (rtb_AND_fe || (tmpForInput_0[rtb_DataTypeConversion2 + 1]));
    }

    /* Logic: '<S2469>/Logical1' */
    VeTHMR_b_EmrgcyFanRq_Lvl1_0 = rtb_AND_fe;

    /* Switch: '<S2469>/Switch' incorporates:
     *  Constant: '<S2490>/Calib'
     *  Constant: '<S2491>/Calib'
     *  Constant: '<S2501>/Calib'
     *  Logic: '<S2469>/Logical3'
     *  RelationalOperator: '<S2469>/Comparison2'
     *  RelationalOperator: '<S2469>/Comparison4'
     */
    VeTHMR_b_EmrgcyFanRq_Lv1 = ((((KeTHMR_Pct_FanCmdOff_Hi <=
        rtb_TmpSignalConversionAtVeFSCR) || (rtb_TmpSignalConversionAtVeFSCR <=
        KeTHMR_Pct_FanCmdOff_Lo)) || (KeTHMR_b_DisblChkFanOffEmrLvl1)) &&
        (VeTHMR_b_EmrgcyFanRq_Lvl1_0));

    /* RelationalOperator: '<S2471>/Comparison1' */
    rtb_AND_fe = !VeTHMR_b_EmrgcyFanRq_Lvl2;

    /* Switch: '<S2728>/Switch1' incorporates:
     *  Logic: '<S2471>/Logical1'
     *  Logic: '<S2471>/Logical7'
     *  RelationalOperator: '<S2471>/Comparison2'
     *  RelationalOperator: '<S2471>/Comparison4'
     *  RelationalOperator: '<S2471>/Comparison5'
     *  Switch: '<S2729>/Switch1'
     *  Switch: '<S2730>/Switch1'
     */
    if (rtb_AND_fe && (!VeTHMR_b_EmrgcyFanRq_Lv1))
    {
        /* Switch: '<S2728>/Switch1' incorporates:
         *  Constant: '<S2723>/Constant'
         */
        rtb_Switch1_ald = CeTHMR_e_No_EmrgcyFanRq;
    }
    else if (rtb_AND_fe && (VeTHMR_b_EmrgcyFanRq_Lv1))
    {
        /* Switch: '<S2729>/Switch1' incorporates:
         *  Constant: '<S2724>/Constant'
         *  Switch: '<S2728>/Switch1'
         */
        rtb_Switch1_ald = CeTHMR_e_Low_EmrgcyFanRq_Lv1;
    }
    else if (VeTHMR_b_EmrgcyFanRq_Lvl2)
    {
        /* Switch: '<S2730>/Switch1' incorporates:
         *  Constant: '<S2725>/Constant'
         *  Switch: '<S2728>/Switch1'
         *  Switch: '<S2729>/Switch1'
         */
        rtb_Switch1_ald = CeTHMR_e_High_EmrgcyFanRq_Lv2;
    }
    else
    {
        /* Switch: '<S2728>/Switch1' incorporates:
         *  Constant: '<S2726>/Constant'
         *  Switch: '<S2729>/Switch1'
         *  Switch: '<S2730>/Switch1'
         */
        rtb_Switch1_ald = CeTHMR_e_SNA_EmrgcyFanRq;
    }

    /* End of Switch: '<S2728>/Switch1' */

    /* Switch: '<S2471>/Switch' incorporates:
     *  Constant: '<S2735>/Calib'
     *  Inport: '<Root>/VeTMIR_y_OBCMTemp1_Dbg'
     *  Inport: '<Root>/VeTMIR_y_OBCMTemp2_Dbg'
     */
    if (KeTHMR_b_EmrgncyFanFlashing_App_Sel)
    {
        (void)Rte_Read_VeTMIR_y_OBCMTemp2_Dbg_Value(&iteration_count);
        (void)Rte_Read_VeTMIR_y_OBCMTemp1_Dbg_Value(&rtb_Switch1_ev);

        /* Switch: '<S2731>/Switch1' incorporates:
         *  Constant: '<S2471>/ConstantValue1'
         *  Constant: '<S2471>/ConstantValue2'
         *  Constant: '<S2733>/Calib'
         *  Constant: '<S2736>/Calib'
         *  Inport: '<Root>/VeTMIR_y_OBCMTemp1_Dbg'
         *  Inport: '<Root>/VeTMIR_y_OBCMTemp2_Dbg'
         *  Logic: '<S2471>/Logical'
         *  Logic: '<S2471>/Logical2'
         *  Logic: '<S2471>/Logical3'
         *  RelationalOperator: '<S2471>/Comparison6'
         *  RelationalOperator: '<S2471>/Comparison7'
         */
        if ((((((sint32)rtb_Switch1_ev) == 4) && (((sint32)iteration_count) == 4))
             && (KeTHMR_b_DbgDsblEmrgcyRunApp_Enbl)) ||
                ((VeTHMR_b_Flashing_Flag_AD) &&
                 (KeTHMR_b_FlagDsblEmrgcyRunApp_Enbl)))
        {
            /* Switch: '<S2471>/Switch' incorporates:
             *  Constant: '<S2727>/Constant'
             */
            rtb_Switch1_ald = CeTHMR_e_No_EmrgcyFanRq;
        }

        /* End of Switch: '<S2731>/Switch1' */
    }

    /* End of Switch: '<S2471>/Switch' */

    /* RelationalOperator: '<S2722>/Comparison4' incorporates:
     *  Switch: '<S2471>/Switch'
     *  UnitDelay: '<S2722>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeT_pw = (rtb_Switch1_ald ==
        THMR_ac_DW.UnitDelay_DSTATE_it);

    /* Outputs for Atomic SubSystem: '<S2722>/EdgeRising1' */
    /* Logic: '<S2738>/AND' incorporates:
     *  Logic: '<S2738>/OR1'
     *  UnitDelay: '<S2738>/UnitDelay'
     */
    rtb_AND_fe = (rtb_TmpSignalConversionAtVeT_pw &&
                  (!THMR_ac_DW.UnitDelay_DSTATE_fi3));

    /* Update for UnitDelay: '<S2738>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_fi3 = rtb_TmpSignalConversionAtVeT_pw;

    /* End of Outputs for SubSystem: '<S2722>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S2722>/CountDownResetEnabled' */
    /* Switch: '<S2737>/Switch1' incorporates:
     *  Constant: '<S2737>/ConstantValue'
     *  Logic: '<S2722>/Logical2'
     *  Logic: '<S2722>/Logical4'
     *  RelationalOperator: '<S2737>/GreaterThan'
     *  Switch: '<S2737>/Switch2'
     *  UnitDelay: '<S2737>/UnitDelay'
     */
    if (rtb_AND_fe || (!rtb_TmpSignalConversionAtVeT_pw))
    {
        /* Switch: '<S2737>/Switch1' incorporates:
         *  Constant: '<S2722>/ConstantValue3'
         *  Constant: '<S2732>/Calib'
         *  Sum: '<S2722>/Sum1'
         */
        rtb_Switch_i3 = (uint16)((sint32)(((sint32)
            KeTHMR_Cnt_EmergencyRun_DbncTime) - 1));
    }
    else if (((sint32)THMR_ac_DW.UnitDelay_DSTATE_c5) > 0)
    {
        /* Switch: '<S2737>/Switch2' incorporates:
         *  Constant: '<S2737>/ConstantValue1'
         *  Sum: '<S2737>/Subtraction'
         *  Switch: '<S2737>/Switch1'
         *  UnitDelay: '<S2737>/UnitDelay'
         */
        rtb_Switch_i3 = (uint16)((sint32)(((sint32)
            THMR_ac_DW.UnitDelay_DSTATE_c5) - 1));
    }
    else
    {
        /* Switch: '<S2737>/Switch1' incorporates:
         *  Switch: '<S2737>/Switch2'
         *  UnitDelay: '<S2737>/UnitDelay'
         */
        rtb_Switch_i3 = THMR_ac_DW.UnitDelay_DSTATE_c5;
    }

    /* End of Switch: '<S2737>/Switch1' */

    /* Update for UnitDelay: '<S2737>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_c5 = rtb_Switch_i3;

    /* Logic: '<S2722>/Logical3' incorporates:
     *  Constant: '<S2737>/ConstantValue2'
     *  RelationalOperator: '<S2737>/GreaterThan1'
     */
    rtb_TmpSignalConversionAtVeT_pw = (((sint32)rtb_Switch_i3) <= 0);

    /* End of Outputs for SubSystem: '<S2722>/CountDownResetEnabled' */

    /* Outputs for Atomic SubSystem: '<S2722>/EdgeRising2' */
    /* Logic: '<S2739>/AND' incorporates:
     *  Logic: '<S2739>/OR1'
     *  UnitDelay: '<S2739>/UnitDelay'
     */
    rtb_AND_fe = (rtb_TmpSignalConversionAtVeT_pw &&
                  (!THMR_ac_DW.UnitDelay_DSTATE_obr));

    /* Update for UnitDelay: '<S2739>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_obr = rtb_TmpSignalConversionAtVeT_pw;

    /* End of Outputs for SubSystem: '<S2722>/EdgeRising2' */

    /* Outputs for Enabled SubSystem: '<S2722>/Subsystem2' incorporates:
     *  EnablePort: '<S2741>/Enable'
     */
    /* Logic: '<S2722>/Logical1' incorporates:
     *  Constant: '<S2734>/Calib'
     *  Inport: '<S2741>/In1'
     *  Switch: '<S2471>/Switch'
     *  Switch: '<S2740>/Switch1'
     *  UnitDelay: '<S2722>/UnitDelay2'
     */
    if (rtb_AND_fe || ((!KeTHMR_b_EmergencyRun_DisableDebounceRST) &&
                       (THMR_ac_DW.UnitDelay2_DSTATE_ez)))
    {
        /* SignalConversion generated from: '<S2741>/Out1' incorporates:
         *  Constant: '<S2741>/ConstantValue1'
         */
        THMR_ac_B.OutportBufferForOut1 = false;
        VeTHMR_e_EmrgcyFanRq_Lvl_B4D = rtb_Switch1_ald;
    }

    /* End of Logic: '<S2722>/Logical1' */
    /* End of Outputs for SubSystem: '<S2722>/Subsystem2' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* Outputs for IfAction SubSystem: '<S1161>/Subsystem2' incorporates:
     *  ActionPort: '<S1889>/ActionPort'
     */
    /* Outputs for IfAction SubSystem: '<S2281>/BattCPV_Error_Arbitratn_HTLReq' incorporates:
     *  ActionPort: '<S2305>/ActionPort'
     */
    /* If: '<S1161>/If' incorporates:
     *  If: '<S2281>/TempErr_BTLPosition'
     *  Merge: '<S4570>/Merge1'
     *  RelationalOperator: '<S1162>/Comparison2'
     *  RelationalOperator: '<S1162>/Comparison5'
     *  RelationalOperator: '<S1164>/Comparison1'
     *  RelationalOperator: '<S1164>/Comparison12'
     *  RelationalOperator: '<S1164>/Comparison7'
     *  RelationalOperator: '<S1164>/Comparison8'
     *  RelationalOperator: '<S1173>/Comparison4'
     *  RelationalOperator: '<S1352>/Comparison7'
     *  RelationalOperator: '<S1352>/Comparison8'
     *  RelationalOperator: '<S1399>/Comparison4'
     *  RelationalOperator: '<S1930>/Comparison4'
     *  RelationalOperator: '<S2284>/Comparison2'
     *  RelationalOperator: '<S2297>/Comparison2'
     *  RelationalOperator: '<S2323>/Comparison1'
     *  RelationalOperator: '<S2323>/Comparison4'
     *  RelationalOperator: '<S2351>/Comparison5'
     *  RelationalOperator: '<S2351>/Comparison6'
     *  Switch: '<S1166>/Switch1'
     *  Switch: '<S1889>/Switch1'
     */
    rtb_Switch1_o0g = THMR_ac_B.VeTHMR_e_CabHeatThermalState;

    /* End of Outputs for SubSystem: '<S2281>/BattCPV_Error_Arbitratn_HTLReq' */
    /* End of Outputs for SubSystem: '<S1161>/Subsystem2' */

    /* Logic: '<S2297>/Logical1' incorporates:
     *  Constant: '<S3095>/Constant'
     *  Constant: '<S3096>/Constant'
     *  Constant: '<S3097>/Constant'
     *  Constant: '<S3098>/Constant'
     *  Constant: '<S3099>/Constant'
     *  Constant: '<S3100>/Calib'
     *  Inport: '<S2741>/In1'
     *  Logic: '<S2297>/Logical46'
     *  RelationalOperator: '<S2297>/Comparison1'
     *  RelationalOperator: '<S2297>/Comparison2'
     *  RelationalOperator: '<S2297>/Comparison3'
     *  RelationalOperator: '<S2297>/Comparison4'
     *  RelationalOperator: '<S2297>/Comparison5'
     *  Switch: '<S4586>/Switch1'
     */
    rtb_TmpSignalConversionAtVeT_pw = ((((((((uint32)rtb_Switch1_o0g) !=
        CeTHMR_e_CabinActivePassiveHeating) && (((uint32)VeTHMR_e_BatThrmlSt_B4D)
        != CeTHMR_e_ActvPsvHeating)) && (((uint32)VeTHMR_e_BatThrmlSt_B4D) !=
        CeTHMR_e_PassiveCooling)) && (((uint32)VeTHMR_e_BatThrmlSt_B4D) !=
        CeTHMR_e_PassiveHeating)) && (((uint32)VeTHMR_e_EmrgcyFanRq_Lvl_B4D) ==
        CeTHMR_e_No_EmrgcyFanRq)) && (KeTHMR_b_LTLMBCEnbl));

    /* Switch: '<S2803>/Switch14' incorporates:
     *  Constant: '<S2807>/Calib'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_ArbPECTOS4FanCntrl)
    {
        /* VariantMerge generated from: '<S2803>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_p = VeTHMR_T_LTRInletTemp;
    }
    else
    {
        /* VariantMerge generated from: '<S2803>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_p = rtb_TmpSignalConversionAtVeTM_f;
    }

#endif

    /* End of Switch: '<S2803>/Switch14' */

    /* Outputs for Atomic SubSystem: '<S2804>/GradientLimiter' */
    /* Switch: '<S2859>/Switch1' incorporates:
     *  UnitDelay: '<S2840>/UnitDelay'
     */
    rtb_Product_gg = THMR_ac_DW.UnitDelay_DSTATE_nz;

    /* End of Outputs for SubSystem: '<S2804>/GradientLimiter' */

    /* Switch: '<S2804>/Switch2' incorporates:
     *  Constant: '<S2845>/Calib'
     */
    if (VeTHMR_b_MtrA_InvrtrTempFA)
    {
        rtb_Switch10 = KeTHMR_T_MtrA_InvrtTmp_Dflt;
    }
    else
    {
        rtb_Switch10 = VeTHMR_T_MtrA_InvrtrTemp;
    }

    /* End of Switch: '<S2804>/Switch2' */

    /* Switch: '<S2804>/Switch3' incorporates:
     *  Constant: '<S2842>/Calib'
     */
    if (VeTHMR_b_BSG_CntrlBoardTemp_FA)
    {
        rtb_Switch15 = KeTHMR_T_CntrlBoardTmp_Dflt;
    }
    else
    {
        rtb_Switch15 = VeTHMR_T_BSG_CntrlBoardTemp_AF;
    }

    /* End of Switch: '<S2804>/Switch3' */

    /* Outputs for Atomic SubSystem: '<S2804>/GradientLimiter' */
    /* Sum: '<S2840>/Sum2' incorporates:
     *  MinMax: '<S2804>/MinMax4'
     */
    rtb_TmpSignalConversionAtVeT_fy = fmaxf(rtb_Switch10, rtb_Switch15) -
        rtb_Product_gg;

    /* Outputs for Atomic SubSystem: '<S2840>/Limiter' */
    /* Switch: '<S2858>/Switch1' incorporates:
     *  Constant: '<S2844>/Calib'
     *  RelationalOperator: '<S2858>/RelationalOperator'
     */
    if (KeTHMR_T_InvrtTmpConditioning_Up < rtb_TmpSignalConversionAtVeT_fy)
    {
        /* Switch: '<S2464>/Switch1' */
        rtb_Switch1_i3 = KeTHMR_T_InvrtTmpConditioning_Up;
    }
    else
    {
        /* Switch: '<S2464>/Switch1' */
        rtb_Switch1_i3 = rtb_TmpSignalConversionAtVeT_fy;
    }

    /* End of Switch: '<S2858>/Switch1' */

    /* Switch: '<S2858>/Switch' incorporates:
     *  Constant: '<S2843>/Calib'
     *  RelationalOperator: '<S2858>/RelationalOperator1'
     */
    if (rtb_Switch1_i3 <= KeTHMR_T_InvrtTmpConditioning_Dwn)
    {
        rtb_Switch1_i3 = KeTHMR_T_InvrtTmpConditioning_Dwn;
    }

    /* End of Switch: '<S2858>/Switch' */
    /* End of Outputs for SubSystem: '<S2840>/Limiter' */

    /* Sum: '<S2840>/Sum3' */
    VeTHMR_T_MGU_InvrtTmpCond_Raw = rtb_Switch1_i3 + rtb_Product_gg;

    /* Update for UnitDelay: '<S2840>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_nz = VeTHMR_T_MGU_InvrtTmpCond_Raw;

    /* End of Outputs for SubSystem: '<S2804>/GradientLimiter' */

    /* Switch: '<S2804>/Switch4' incorporates:
     *  Logic: '<S2804>/Logical8'
     */
    if ((VeTHMR_b_MtrA_InvrtrTempFA) && (VeTHMR_b_BSG_CntrlBoardTemp_FA))
    {
        /* Switch: '<S2804>/Switch4' */
        VeTHMR_T_MGU_InvrtTmpCond = VeTHMR_T_MtrA_Temp;
    }
    else
    {
        /* Switch: '<S2804>/Switch4' */
        VeTHMR_T_MGU_InvrtTmpCond = VeTHMR_T_MGU_InvrtTmpCond_Raw;
    }

    /* End of Switch: '<S2804>/Switch4' */

    /* Switch: '<S2803>/Switch8' incorporates:
     *  Constant: '<S2811>/Calib'
     */
#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_MGU_ClntTmpOut_Enb)
    {
        /* VariantMerge generated from: '<S2803>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_p = rtb_Switch1_he;
    }
    else
    {
        /* VariantMerge generated from: '<S2803>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_p = VeTHMR_T_MGU_InvrtTmpCond;
    }

#endif

    /* End of Switch: '<S2803>/Switch8' */

    /* S-Function (fcgen): '<S62>/Function-CallGenerator' incorporates:
     *  SubSystem: '<S62>/FunctionCall'
     */
    /* S-Function (fcgen): '<S2288>/Function-CallGenerator1' incorporates:
     *  SubSystem: '<S62>/MBC_LTCL'
     */
    /* Sum: '<S2295>/Add4' incorporates:
     *  Sum: '<S3024>/Add4'
     */
    rtb_Product_gg = VeTHMR_T_PPCTISTgt_Fan - rtb_TmpSignalConversionAtVeT_jp;

    /* SignalConversion generated from: '<S3071>/Product' incorporates:
     *  UnitDelay: '<S3021>/UnitDelay'
     *  UnitDelay: '<S3057>/UnitDelay'
     */
    for (i = 0; i < 3; i++)
    {
        rtb_UnitDelay_buv[i] = THMR_ac_DW.UnitDelay_DSTATE_cg[i];
    }

    rtb_UnitDelay_buv[3] = THMR_ac_DW.UnitDelay_DSTATE_ig;

    /* End of SignalConversion generated from: '<S3071>/Product' */

    /* Product: '<S3071>/Product' incorporates:
     *  Constant: '<S3060>/Calib'
     *  Gain: '<S3023>/Gain1'
     */
    rtb_TmpSignalConversionAtVeT_fy = 0.0F;
    for (i = 0; i < 4; i++)
    {
        rtb_TmpSignalConversionAtVeT_fy += (-KaTHMR_k_KLQGPCEP1MBC[(i)]) *
            rtb_UnitDelay_buv[i];
    }

    /* Outputs for Atomic SubSystem: '<S3019>/Limiter1' */
    /* Switch: '<S3046>/Switch1' incorporates:
     *  Constant: '<S3040>/Calib'
     *  Product: '<S3071>/Product'
     *  RelationalOperator: '<S3046>/RelationalOperator'
     */
    if (KeTHMR_n_MaxLimitLTLPECP1MBC < rtb_TmpSignalConversionAtVeT_fy)
    {
        /* Switch: '<S3057>/Switch1' */
        rtb_Switch1_ofq = KeTHMR_n_MaxLimitLTLPECP1MBC;
    }
    else
    {
        /* Switch: '<S3057>/Switch1' */
        rtb_Switch1_ofq = rtb_TmpSignalConversionAtVeT_fy;
    }

    /* End of Switch: '<S3046>/Switch1' */
    /* End of Outputs for SubSystem: '<S3019>/Limiter1' */

    /* Outputs for Atomic SubSystem: '<S3019>/GradientLimiter1' */
    /* Switch: '<S3053>/Switch1' incorporates:
     *  UnitDelay: '<S3025>/UnitDelay'
     */
    rtb_Switch1_muc = THMR_ac_DW.UnitDelay_DSTATE_h1;

    /* End of Outputs for SubSystem: '<S3019>/GradientLimiter1' */

    /* Outputs for Atomic SubSystem: '<S3019>/Limiter1' */
    /* Switch: '<S3046>/Switch' incorporates:
     *  Constant: '<S3042>/Calib'
     *  RelationalOperator: '<S3046>/RelationalOperator1'
     */
    if (rtb_Switch1_ofq <= KeTHMR_n_MinLimitLTLPECP1MBC)
    {
        rtb_Switch1_ofq = KeTHMR_n_MinLimitLTLPECP1MBC;
    }

    /* End of Switch: '<S3046>/Switch' */
    /* End of Outputs for SubSystem: '<S3019>/Limiter1' */

    /* Outputs for Atomic SubSystem: '<S3019>/GradientLimiter1' */
    /* Sum: '<S3025>/Sum2' */
    rtb_TmpSignalConversionAtVeTM_n = rtb_Switch1_ofq - rtb_Switch1_muc;

    /* Outputs for Atomic SubSystem: '<S3025>/Limiter' */
    /* Switch: '<S3050>/Switch1' incorporates:
     *  Constant: '<S3044>/Calib'
     *  RelationalOperator: '<S3050>/RelationalOperator'
     */
    if (KeTHMR_n_UGrdLimitLTLPECP1MBC < rtb_TmpSignalConversionAtVeTM_n)
    {
        /* Switch: '<S3057>/Switch1' */
        rtb_Switch1_ofq = KeTHMR_n_UGrdLimitLTLPECP1MBC;
    }
    else
    {
        /* Switch: '<S3057>/Switch1' */
        rtb_Switch1_ofq = rtb_TmpSignalConversionAtVeTM_n;
    }

    /* End of Switch: '<S3050>/Switch1' */

    /* Switch: '<S3050>/Switch' incorporates:
     *  Constant: '<S3038>/Calib'
     *  RelationalOperator: '<S3050>/RelationalOperator1'
     */
    if (rtb_Switch1_ofq <= KeTHMR_n_DGrdLimitLTLPECP1MBC)
    {
        rtb_Switch1_ofq = KeTHMR_n_DGrdLimitLTLPECP1MBC;
    }

    /* End of Switch: '<S3050>/Switch' */
    /* End of Outputs for SubSystem: '<S3025>/Limiter' */

    /* Sum: '<S3025>/Sum3' */
    VeTHMR_n_LTLPECP1_MBC = rtb_Switch1_ofq + rtb_Switch1_muc;

    /* Update for UnitDelay: '<S3025>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_h1 = VeTHMR_n_LTLPECP1_MBC;

    /* End of Outputs for SubSystem: '<S3019>/GradientLimiter1' */

    /* SignalConversion generated from: '<S3070>/Product' incorporates:
     *  UnitDelay: '<S3021>/UnitDelay'
     *  UnitDelay: '<S3054>/UnitDelay'
     */
    for (i = 0; i < 3; i++)
    {
        rtb_UnitDelay_buv[i] = THMR_ac_DW.UnitDelay_DSTATE_cg[i];
    }

    rtb_UnitDelay_buv[3] = THMR_ac_DW.UnitDelay_DSTATE_ac;

    /* End of SignalConversion generated from: '<S3070>/Product' */

    /* Product: '<S3070>/Product' incorporates:
     *  Constant: '<S3061>/Calib'
     *  Gain: '<S3023>/Gain'
     */
    rtb_TmpSignalConversionAtVeTM_n = 0.0F;
    for (i = 0; i < 4; i++)
    {
        rtb_TmpSignalConversionAtVeTM_n += (-KaTHMR_k_KLQGPCEP2MBC[(i)]) *
            rtb_UnitDelay_buv[i];
    }

    /* Outputs for Atomic SubSystem: '<S3019>/Limiter2' */
    /* Switch: '<S3047>/Switch1' incorporates:
     *  Constant: '<S3041>/Calib'
     *  Product: '<S3070>/Product'
     *  RelationalOperator: '<S3047>/RelationalOperator'
     */
    if (KeTHMR_n_MaxLimitLTLPECP2MBC < rtb_TmpSignalConversionAtVeTM_n)
    {
        /* Switch: '<S3057>/Switch1' */
        rtb_Switch1_ofq = KeTHMR_n_MaxLimitLTLPECP2MBC;
    }
    else
    {
        /* Switch: '<S3057>/Switch1' */
        rtb_Switch1_ofq = rtb_TmpSignalConversionAtVeTM_n;
    }

    /* End of Switch: '<S3047>/Switch1' */
    /* End of Outputs for SubSystem: '<S3019>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S3019>/GradientLimiter2' */
    /* Switch: '<S3053>/Switch1' incorporates:
     *  UnitDelay: '<S3026>/UnitDelay'
     */
    rtb_Switch1_muc = THMR_ac_DW.UnitDelay_DSTATE_bb;

    /* End of Outputs for SubSystem: '<S3019>/GradientLimiter2' */

    /* Outputs for Atomic SubSystem: '<S3019>/Limiter2' */
    /* Switch: '<S3047>/Switch' incorporates:
     *  Constant: '<S3043>/Calib'
     *  RelationalOperator: '<S3047>/RelationalOperator1'
     */
    if (rtb_Switch1_ofq <= KeTHMR_n_MinLimitLTLPECP2MBC)
    {
        rtb_Switch1_ofq = KeTHMR_n_MinLimitLTLPECP2MBC;
    }

    /* End of Switch: '<S3047>/Switch' */
    /* End of Outputs for SubSystem: '<S3019>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S3019>/GradientLimiter2' */
    /* Sum: '<S3026>/Sum2' */
    rtb_TmpSignalConversionAtVeFSCR = rtb_Switch1_ofq - rtb_Switch1_muc;

    /* Outputs for Atomic SubSystem: '<S3026>/Limiter' */
    /* Switch: '<S3051>/Switch1' incorporates:
     *  Constant: '<S3045>/Calib'
     *  RelationalOperator: '<S3051>/RelationalOperator'
     */
    if (KeTHMR_n_UGrdLimitLTLPECP2MBC < rtb_TmpSignalConversionAtVeFSCR)
    {
        /* Switch: '<S3057>/Switch1' */
        rtb_Switch1_ofq = KeTHMR_n_UGrdLimitLTLPECP2MBC;
    }
    else
    {
        /* Switch: '<S3057>/Switch1' */
        rtb_Switch1_ofq = rtb_TmpSignalConversionAtVeFSCR;
    }

    /* End of Switch: '<S3051>/Switch1' */

    /* Switch: '<S3051>/Switch' incorporates:
     *  Constant: '<S3039>/Calib'
     *  RelationalOperator: '<S3051>/RelationalOperator1'
     */
    if (rtb_Switch1_ofq <= KeTHMR_n_DGrdLimitLTLPECP2MBC)
    {
        rtb_Switch1_ofq = KeTHMR_n_DGrdLimitLTLPECP2MBC;
    }

    /* End of Switch: '<S3051>/Switch' */
    /* End of Outputs for SubSystem: '<S3026>/Limiter' */

    /* Sum: '<S3026>/Sum3' */
    VeTHMR_n_LTLPECP2_MBC = rtb_Switch1_ofq + rtb_Switch1_muc;

    /* Update for UnitDelay: '<S3026>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_bb = VeTHMR_n_LTLPECP2_MBC;

    /* End of Outputs for SubSystem: '<S3019>/GradientLimiter2' */

    /* SignalConversion generated from: '<S3068>/Product' incorporates:
     *  UnitDelay: '<S3021>/UnitDelay'
     *  UnitDelay: '<S3055>/UnitDelay'
     */
    for (i = 0; i < 3; i++)
    {
        rtb_UnitDelay_buv[i] = THMR_ac_DW.UnitDelay_DSTATE_cg[i];
    }

    rtb_UnitDelay_buv[3] = THMR_ac_DW.UnitDelay_DSTATE_fg;

    /* End of SignalConversion generated from: '<S3068>/Product' */

    /* Product: '<S3068>/Product' incorporates:
     *  Constant: '<S3059>/Calib'
     *  Gain: '<S3023>/Gain4'
     */
    rtb_TmpSignalConversionAtVeFSCR = 0.0F;
    for (i = 0; i < 4; i++)
    {
        rtb_TmpSignalConversionAtVeFSCR += (-KaTHMR_k_KLQGLTLVMBC[(i)]) *
            rtb_UnitDelay_buv[i];
    }

    /* Outputs for Atomic SubSystem: '<S3019>/Limiter3' */
    /* Switch: '<S3048>/Switch1' incorporates:
     *  Constant: '<S3019>/ConstantValue'
     *  Constant: '<S3031>/Calib'
     *  Product: '<S3068>/Product'
     *  RelationalOperator: '<S3048>/RelationalOperator'
     *  Sum: '<S3019>/Sum1'
     */
    if (KeTHMR_Pct_MaxLimitLTLTRVMBC < (rtb_TmpSignalConversionAtVeFSCR - 100.0F))
    {
        /* Switch: '<S3057>/Switch1' */
        rtb_Switch1_ofq = KeTHMR_Pct_MaxLimitLTLTRVMBC;
    }
    else
    {
        /* Switch: '<S3057>/Switch1' */
        rtb_Switch1_ofq = rtb_TmpSignalConversionAtVeFSCR - 100.0F;
    }

    /* End of Switch: '<S3048>/Switch1' */
    /* End of Outputs for SubSystem: '<S3019>/Limiter3' */

    /* Outputs for Atomic SubSystem: '<S3019>/GradientLimiter3' */
    /* Switch: '<S3053>/Switch1' incorporates:
     *  UnitDelay: '<S3027>/UnitDelay'
     */
    rtb_Switch1_muc = THMR_ac_DW.UnitDelay_DSTATE_j5;

    /* End of Outputs for SubSystem: '<S3019>/GradientLimiter3' */

    /* Outputs for Atomic SubSystem: '<S3019>/Limiter3' */
    /* Switch: '<S3048>/Switch' incorporates:
     *  Constant: '<S3032>/Calib'
     *  RelationalOperator: '<S3048>/RelationalOperator1'
     */
    if (rtb_Switch1_ofq <= KeTHMR_Pct_MinLimitLTLTRVMBC)
    {
        rtb_Switch1_ofq = KeTHMR_Pct_MinLimitLTLTRVMBC;
    }

    /* End of Switch: '<S3048>/Switch' */
    /* End of Outputs for SubSystem: '<S3019>/Limiter3' */

    /* Outputs for Atomic SubSystem: '<S3019>/GradientLimiter3' */
    /* Sum: '<S3027>/Sum2' */
    rtb_TmpSignalConversionAtVeT_gg = rtb_Switch1_ofq - rtb_Switch1_muc;

    /* Outputs for Atomic SubSystem: '<S3027>/Limiter' */
    /* Switch: '<S3052>/Switch1' incorporates:
     *  Constant: '<S3033>/Calib'
     *  RelationalOperator: '<S3052>/RelationalOperator'
     */
    if (KeTHMR_Pct_UGrdLimitLTLTRVMBC < rtb_TmpSignalConversionAtVeT_gg)
    {
        /* Switch: '<S3057>/Switch1' */
        rtb_Switch1_ofq = KeTHMR_Pct_UGrdLimitLTLTRVMBC;
    }
    else
    {
        /* Switch: '<S3057>/Switch1' */
        rtb_Switch1_ofq = rtb_TmpSignalConversionAtVeT_gg;
    }

    /* End of Switch: '<S3052>/Switch1' */

    /* Switch: '<S3052>/Switch' incorporates:
     *  Constant: '<S3030>/Calib'
     *  RelationalOperator: '<S3052>/RelationalOperator1'
     */
    if (rtb_Switch1_ofq <= KeTHMR_Pct_DGrdLimitLTLTRVMBC)
    {
        rtb_Switch1_ofq = KeTHMR_Pct_DGrdLimitLTLTRVMBC;
    }

    /* End of Switch: '<S3052>/Switch' */
    /* End of Outputs for SubSystem: '<S3027>/Limiter' */

    /* Sum: '<S3027>/Sum3' */
    VeTHMR_Pct_LQGVlvLTR = rtb_Switch1_ofq + rtb_Switch1_muc;

    /* Update for UnitDelay: '<S3027>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_j5 = VeTHMR_Pct_LQGVlvLTR;

    /* End of Outputs for SubSystem: '<S3019>/GradientLimiter3' */

    /* SignalConversion generated from: '<S3069>/Product' incorporates:
     *  UnitDelay: '<S3021>/UnitDelay'
     *  UnitDelay: '<S3056>/UnitDelay'
     */
    for (i = 0; i < 3; i++)
    {
        rtb_UnitDelay_buv[i] = THMR_ac_DW.UnitDelay_DSTATE_cg[i];
    }

    rtb_UnitDelay_buv[3] = THMR_ac_DW.UnitDelay_DSTATE_mm;

    /* End of SignalConversion generated from: '<S3069>/Product' */

    /* Product: '<S3069>/Product' incorporates:
     *  Constant: '<S3058>/Calib'
     *  Gain: '<S3023>/Gain2'
     */
    rtb_TmpSignalConversionAtVeT_gg = 0.0F;
    for (i = 0; i < 4; i++)
    {
        rtb_TmpSignalConversionAtVeT_gg += (-KaTHMR_k_KLQGFANMBC[(i)]) *
            rtb_UnitDelay_buv[i];
    }

    /* Product: '<S3019>/Product' incorporates:
     *  Constant: '<S3029>/Calib'
     *  Product: '<S3069>/Product'
     */
    rtb_Switch1_ofq = rtb_TmpSignalConversionAtVeT_gg *
        KeTHMR_Cf_LTLFanAFConfctr;

    /* Outputs for Atomic SubSystem: '<S3019>/Limiter4' */
    /* Switch: '<S3049>/Switch1' incorporates:
     *  Constant: '<S3035>/Calib'
     *  RelationalOperator: '<S3049>/RelationalOperator'
     */
    if (KeTHMR_dV_MaxLimitLTLFanAFBC < rtb_Switch1_ofq)
    {
        /* Switch: '<S3057>/Switch1' */
        rtb_Switch1_ofq = KeTHMR_dV_MaxLimitLTLFanAFBC;
    }

    /* End of Switch: '<S3049>/Switch1' */

    /* Switch: '<S3049>/Switch' incorporates:
     *  Constant: '<S3036>/Calib'
     *  RelationalOperator: '<S3049>/RelationalOperator1'
     */
    if (rtb_Switch1_ofq > KeTHMR_dV_MinLimitLTLFanAFBC)
    {
        /* Switch: '<S3049>/Switch' */
        rtb_Switch1_muc = rtb_Switch1_ofq;
    }
    else
    {
        /* Switch: '<S3049>/Switch' */
        rtb_Switch1_muc = KeTHMR_dV_MinLimitLTLFanAFBC;
    }

    /* End of Switch: '<S3049>/Switch' */
    /* End of Outputs for SubSystem: '<S3019>/Limiter4' */

    /* Outputs for Atomic SubSystem: '<S3019>/GradientLimiter4' */
    /* Switch: '<S3057>/Switch1' incorporates:
     *  UnitDelay: '<S3028>/UnitDelay'
     */
    rtb_Switch1_ofq = THMR_ac_DW.UnitDelay_DSTATE_n0;

    /* Sum: '<S3028>/Sum2' */
    rtb_Switch1_muc -= rtb_Switch1_ofq;

    /* Outputs for Atomic SubSystem: '<S3028>/Limiter' */
    /* Switch: '<S3053>/Switch1' incorporates:
     *  Constant: '<S3037>/Calib'
     *  RelationalOperator: '<S3053>/RelationalOperator'
     */
    if (KeTHMR_dV_UGrdLimitLTLFanAFBC < rtb_Switch1_muc)
    {
        /* Switch: '<S3053>/Switch1' */
        rtb_Switch1_muc = KeTHMR_dV_UGrdLimitLTLFanAFBC;
    }

    /* End of Switch: '<S3053>/Switch1' */

    /* Switch: '<S3053>/Switch' incorporates:
     *  Constant: '<S3034>/Calib'
     *  RelationalOperator: '<S3053>/RelationalOperator1'
     */
    if (rtb_Switch1_muc <= KeTHMR_dV_DGrdLimitLTLFanAFBC)
    {
        rtb_Switch1_muc = KeTHMR_dV_DGrdLimitLTLFanAFBC;
    }

    /* End of Switch: '<S3053>/Switch' */
    /* End of Outputs for SubSystem: '<S3028>/Limiter' */

    /* Sum: '<S3028>/Sum3' */
    VeTHMR_dV_LQGLTLFanAF = rtb_Switch1_muc + rtb_Switch1_ofq;

    /* Update for UnitDelay: '<S3028>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_n0 = VeTHMR_dV_LQGLTLFanAF;

    /* End of Outputs for SubSystem: '<S3019>/GradientLimiter4' */

    /* Switch: '<S3054>/Switch1' incorporates:
     *  Constant: '<S3054>/ConstantValue'
     *  Constant: '<S3054>/ConstantValue1'
     *  Constant: '<S3054>/ConstantValue2'
     *  Constant: '<S3054>/ConstantValue3'
     *  Constant: '<S3066>/Calib'
     *  Constant: '<S3067>/Calib'
     *  Logic: '<S3054>/Logical'
     *  Logic: '<S3054>/Logical1'
     *  Logic: '<S3054>/Logical2'
     *  Product: '<S3054>/Product1'
     *  RelationalOperator: '<S3054>/Comparison'
     *  RelationalOperator: '<S3054>/Comparison1'
     *  RelationalOperator: '<S3054>/Comparison2'
     *  RelationalOperator: '<S3054>/Comparison3'
     *  Sum: '<S2295>/Add4'
     *  UnitDelay: '<S3023>/UnitDelay'
     */
    if (((rtb_Product_gg < 0.0F) && (THMR_ac_DW.UnitDelay_DSTATE_f4 >=
            KeTHMR_n_MaxAntWdLTLPECPMBC)) || ((rtb_Product_gg > 0.0F) &&
            (THMR_ac_DW.UnitDelay_DSTATE_f4 <= KeTHMR_n_MinAntWdLTLPECPMBC)))
    {
        rtb_Add4_m1 = 0.0F;
    }
    else
    {
        rtb_Add4_m1 = 0.1F * rtb_Product_gg;
    }

    /* End of Switch: '<S3054>/Switch1' */

    /* Update for UnitDelay: '<S3054>/UnitDelay' incorporates:
     *  Sum: '<S3054>/Sum'
     */
    THMR_ac_DW.UnitDelay_DSTATE_ac += rtb_Add4_m1;

    /* Switch: '<S3055>/Switch1' incorporates:
     *  Constant: '<S3055>/ConstantValue'
     *  Constant: '<S3055>/ConstantValue1'
     *  Constant: '<S3055>/ConstantValue2'
     *  Constant: '<S3055>/ConstantValue3'
     *  Constant: '<S3062>/Calib'
     *  Constant: '<S3063>/Calib'
     *  Logic: '<S3055>/Logical'
     *  Logic: '<S3055>/Logical1'
     *  Logic: '<S3055>/Logical2'
     *  Product: '<S3055>/Product1'
     *  RelationalOperator: '<S3055>/Comparison'
     *  RelationalOperator: '<S3055>/Comparison1'
     *  RelationalOperator: '<S3055>/Comparison2'
     *  RelationalOperator: '<S3055>/Comparison3'
     *  Sum: '<S2295>/Add4'
     *  UnitDelay: '<S3023>/UnitDelay2'
     */
    if (((rtb_Product_gg > 0.0F) && (THMR_ac_DW.UnitDelay2_DSTATE_cr >=
            KeTHMR_Pct_MaxAntWdLTLLTRVMBC)) || ((rtb_Product_gg < 0.0F) &&
            (THMR_ac_DW.UnitDelay2_DSTATE_cr <= KeTHMR_Pct_MinAntWdLTLLTRVMBC)))
    {
        rtb_Add4_m1 = 0.0F;
    }
    else
    {
        rtb_Add4_m1 = 0.1F * rtb_Product_gg;
    }

    /* End of Switch: '<S3055>/Switch1' */

    /* Update for UnitDelay: '<S3055>/UnitDelay' incorporates:
     *  Sum: '<S3055>/Sum'
     */
    THMR_ac_DW.UnitDelay_DSTATE_fg += rtb_Add4_m1;

    /* Switch: '<S3056>/Switch1' incorporates:
     *  Constant: '<S3056>/ConstantValue'
     *  Constant: '<S3056>/ConstantValue1'
     *  Constant: '<S3056>/ConstantValue2'
     *  Constant: '<S3056>/ConstantValue3'
     *  Constant: '<S3064>/Calib'
     *  Constant: '<S3065>/Calib'
     *  Logic: '<S3056>/Logical'
     *  Logic: '<S3056>/Logical1'
     *  Logic: '<S3056>/Logical2'
     *  Product: '<S3056>/Product1'
     *  RelationalOperator: '<S3056>/Comparison'
     *  RelationalOperator: '<S3056>/Comparison1'
     *  RelationalOperator: '<S3056>/Comparison2'
     *  RelationalOperator: '<S3056>/Comparison3'
     *  Sum: '<S2295>/Add4'
     *  UnitDelay: '<S3023>/UnitDelay3'
     */
    if (((rtb_Product_gg < 0.0F) && (THMR_ac_DW.UnitDelay3_DSTATE_l1 >=
            KeTHMR_dV_MaxAntWdLTLFANMBC)) || ((rtb_Product_gg > 0.0F) &&
            (THMR_ac_DW.UnitDelay3_DSTATE_l1 <= KeTHMR_dV_MinAntWdLTLFANMBC)))
    {
        rtb_Add4_m1 = 0.0F;
    }
    else
    {
        rtb_Add4_m1 = 0.1F * rtb_Product_gg;
    }

    /* End of Switch: '<S3056>/Switch1' */

    /* Update for UnitDelay: '<S3056>/UnitDelay' incorporates:
     *  Sum: '<S3056>/Sum'
     */
    THMR_ac_DW.UnitDelay_DSTATE_mm += rtb_Add4_m1;

    /* Switch: '<S3057>/Switch1' incorporates:
     *  Constant: '<S3057>/ConstantValue1'
     *  Constant: '<S3057>/ConstantValue2'
     *  Constant: '<S3066>/Calib'
     *  Constant: '<S3067>/Calib'
     *  Logic: '<S3057>/Logical'
     *  Logic: '<S3057>/Logical1'
     *  Logic: '<S3057>/Logical2'
     *  RelationalOperator: '<S3057>/Comparison'
     *  RelationalOperator: '<S3057>/Comparison1'
     *  RelationalOperator: '<S3057>/Comparison2'
     *  RelationalOperator: '<S3057>/Comparison3'
     *  Sum: '<S2295>/Add4'
     *  UnitDelay: '<S3023>/UnitDelay1'
     */
    if (((rtb_Product_gg > 0.0F) && (THMR_ac_DW.UnitDelay1_DSTATE_nc >=
            KeTHMR_n_MaxAntWdLTLPECPMBC)) || ((rtb_Product_gg < 0.0F) &&
            (THMR_ac_DW.UnitDelay1_DSTATE_nc <= KeTHMR_n_MinAntWdLTLPECPMBC)))
    {
        /* Switch: '<S3057>/Switch1' incorporates:
         *  Constant: '<S3057>/ConstantValue3'
         */
        rtb_Switch1_ofq = 0.0F;
    }
    else
    {
        /* Switch: '<S3057>/Switch1' incorporates:
         *  Constant: '<S3057>/ConstantValue'
         *  Product: '<S3057>/Product1'
         */
        rtb_Switch1_ofq = 0.1F * rtb_Product_gg;
    }

    /* End of Switch: '<S3057>/Switch1' */

    /* MATLAB Function: '<S3024>/PIController3' incorporates:
     *  Constant: '<S3024>/ConstantValue'
     *  Constant: '<S3077>/Calib'
     *  Constant: '<S3084>/Calib'
     *  Constant: '<S3085>/Calib'
     *  UnitDelay: '<S3024>/UnitDelay'
     */
    /* MATLAB Function 'THMR_FUNC_RU_MedTEH/LTCL/MBC_LTCL/LTLC_FBL_Controller/PIController3': '<S3088>:1' */
    /* '<S3088>:1:4' */
    rtb_Merge1_i = ((KeTHMR_k_KiLTCLFBL * THMR_ac_DW.UnitDelay_DSTATE_ix) * 0.1F)
        + (KeTHMR_k_KpLTCLFBL * rtb_Product_gg);
    if (KeTHMR_b_AntiWindupLTCLFBL)
    {
        /* Update for UnitDelay: '<S3024>/UnitDelay' incorporates:
         *  UnitDelay: '<S3024>/UnitDelay2'
         */
        /* '<S3088>:1:6' */
        /* '<S3088>:1:7' */
        THMR_ac_DW.UnitDelay_DSTATE_ix += THMR_ac_DW.UnitDelay2_DSTATE_dp *
            rtb_Product_gg;
    }
    else if (rtb_Merge1_i < 0.0F)
    {
        /* Update for UnitDelay: '<S3024>/UnitDelay' */
        /* '<S3088>:1:9' */
        /* '<S3088>:1:10' */
        THMR_ac_DW.UnitDelay_DSTATE_ix += rtb_Product_gg;
    }
    else
    {
        /* '<S3088>:1:12' */
    }

    /* MATLAB Function: '<S3024>/LTL_FBL_Controller_Anti' incorporates:
     *  Constant: '<S3024>/ConstantValue3'
     *  Constant: '<S3024>/ConstantValue4'
     *  Constant: '<S3072>/Calib'
     *  Constant: '<S3073>/Calib'
     *  Constant: '<S3081>/Calib'
     *  MATLAB Function: '<S3024>/PIController3'
     *  Product: '<S3024>/Product1'
     *  Sum: '<S3024>/Sum1'
     */
    /* MATLAB Function 'THMR_FUNC_RU_MedTEH/LTCL/MBC_LTCL/LTLC_FBL_Controller/LTL_FBL_Controller_Anti': '<S3087>:1' */
    /* '<S3087>:1:5' */
    /* '<S3087>:1:7' */
    /* '<S3087>:1:8' */
    /* '<S3087>:1:11' */
    /* '<S3087>:1:14' */
    /* '<S3087>:1:15' */
    /* '<S3087>:1:16' */
    rtb_Switch10 = (((rtb_TmpSignalConversionAtVeTM_f + 273.0F) -
                     TmpSignalConversionAtOutAirTemp) -
                    (((rtb_TmpSignalConversionAtVeTM_f + 273.0F) -
                      (rtb_TmpSignalConversionAtVeTR_h + 273.0F)) * (1.0F -
                      (THMR_ac_B.VeTHMR_Pct_HTL_BypsVlv_Cmd / 100.0F)))) *
        KaTHMR_k_PLTLC[3];
    if (rtb_Switch10 != 0.0F)
    {
        /* '<S3087>:1:20' */
        /* '<S3087>:1:21' */
        rtb_Add4_m1 = (-0.5F * rtb_Merge1_i) / rtb_Switch10;
    }
    else
    {
        /* '<S3087>:1:23' */
        rtb_Add4_m1 = 1.0F;
    }

    /* '<S3087>:1:25' */
    rtb_Add4_m1 = fminf(1.0F, rtb_Add4_m1);

    /* '<S3087>:1:26' */
    rtb_Add4_m1 = fmaxf(0.0F, rtb_Add4_m1);

    /* '<S3087>:1:28' */
    /* '<S3087>:1:29' */
    rtb_Add4_m1 = (-logf(1.0F - rtb_Add4_m1)) * KaTHMR_k_PLTLC[5];

    /* '<S3087>:1:30' */
    /* '<S3087>:1:32' */
    /* '<S3087>:1:34' */
    rtb_Switch1_muc = ((2.0F * rtb_Add4_m1) * KaTHMR_k_PLTLC[7]) *
        KaTHMR_k_WLTL[1];

    /* '<S3087>:1:35' */
    rtb_Merge1_i = rtb_Switch1_muc;

    /* '<S3087>:1:36' */
    rtb_Switch1_muc = fminf(KeTHMR_dV_MaxFlowLTR, rtb_Switch1_muc);

    /* Gain: '<S3091>/Gain' incorporates:
     *  Constant: '<S3083>/Calib'
     *  MATLAB Function: '<S3024>/LTL_FBL_Controller_Anti'
     */
    /* '<S3087>:1:37' */
    VeTHMR_dV_FBLTLFanAF = fmaxf(KeTHMR_dV_MinFlowLTR, rtb_Switch1_muc);

    /* MATLAB Function: '<S3024>/LTL_FBL_Controller_Anti' incorporates:
     *  Constant: '<S3076>/Calib'
     *  Constant: '<S3078>/Calib'
     *  Constant: '<S3080>/Calib'
     *  Constant: '<S3082>/Calib'
     *  Constant: '<S3086>/Calib'
     */
    if (KeTHMR_b_MotorOutltTempCtrlEnbl)
    {
        /* '<S3087>:1:43' */
        if ((rtb_TmpSignalConversionAtVeT_jp + 273.0F) !=
                (rtb_TmpSignalConversionAtVeTM_f + 273.0F))
        {
            /* '<S3087>:1:44' */
            /* '<S3087>:1:45' */
            rtb_Product_gg = (((KeTHMR_T_LTRClntTmpOutTgt + 273.0F) -
                               (rtb_TmpSignalConversionAtVeTM_f + 273.0F)) *
                              KeTHMR_k_KpMotorOutltTemp) /
                ((rtb_TmpSignalConversionAtVeT_jp + 273.0F) -
                 (rtb_TmpSignalConversionAtVeTM_f + 273.0F));
        }
        else
        {
            /* '<S3087>:1:47' */
            rtb_Product_gg = KeTHMR_dV_MaxFlowLTL;
        }

        /* '<S3087>:1:49' */
        rtb_Product_gg = fminf(KeTHMR_dV_MaxFlowLTL, rtb_Product_gg);

        /* '<S3087>:1:50' */
        rtb_Product_gg = fmaxf(KeTHMR_dV_MinFlowLTL, rtb_Product_gg);
    }
    else
    {
        /* '<S3087>:1:53' */
        rtb_Product_gg = rtb_TmpSignalConversionAtVePM_d;
    }

    /* Gain: '<S3089>/Gain' incorporates:
     *  MATLAB Function: '<S3024>/LTL_FBL_Controller_Anti'
     */
    /* '<S3087>:1:59' */
    /* '<S3087>:1:60' */
    /* '<S3087>:1:61' */
    VeTHMR_dV_FBLTLFLOW = rtb_Product_gg;

    /* Gain: '<S3090>/Gain' incorporates:
     *  Constant: '<S3072>/Calib'
     *  Constant: '<S3073>/Calib'
     *  Constant: '<S3074>/Calib'
     *  Constant: '<S3075>/Calib'
     *  MATLAB Function: '<S3024>/LTL_FBL_Controller_Anti'
     */
    VeTHMR_Pct_FBVlvLTR = fmaxf(KeTHMR_Pct_LTCLVlvMin, fminf
        (KeTHMR_Pct_LTCLVlvMax, (1.0F - (fminf(rtb_TmpSignalConversionAtVePM_d,
        ((2.0F * rtb_Add4_m1) * KaTHMR_k_PLTLC[6]) * KaTHMR_k_WLTL[0]) /
        rtb_Product_gg)) * 100.0F));

    /* Switch: '<S2295>/Switch3' incorporates:
     *  Constant: '<S3022>/Calib'
     */
    if (KeTHMR_b_LTCLFBLEnbl)
    {
        /* Switch: '<S2295>/Switch3' */
        Switch3_h[0] = VeTHMR_Pct_FBVlvLTR;
        Switch3_h[1] = VeTHMR_dV_FBLTLFanAF;
    }
    else
    {
        /* Switch: '<S2295>/Switch3' */
        Switch3_h[0] = VeTHMR_Pct_LQGVlvLTR;
        Switch3_h[1] = VeTHMR_dV_LQGLTLFanAF;
    }

    /* End of Switch: '<S2295>/Switch3' */

    /* SignalConversion generated from: '<S2295>/LTCLFBLEnbl' incorporates:
     *  Constant: '<S3022>/Calib'
     */
    THMR_ac_B.OutportBufferForLTCLFBLEnbl = KeTHMR_b_LTCLFBLEnbl;

    /* SignalConversion generated from: '<S3021>/Gain1' incorporates:
     *  Product: '<S3068>/Product'
     *  Product: '<S3069>/Product'
     *  Product: '<S3070>/Product'
     *  Product: '<S3071>/Product'
     */
    rtb_TmpSignalConversionAtVeT_ex[0] = rtb_TmpSignalConversionAtVeTM_n;
    rtb_TmpSignalConversionAtVeT_ex[1] = rtb_TmpSignalConversionAtVeT_fy;
    rtb_TmpSignalConversionAtVeT_ex[2] = rtb_TmpSignalConversionAtVeFSCR;
    rtb_TmpSignalConversionAtVeT_ex[3] = rtb_TmpSignalConversionAtVeT_gg;
    rtb_TmpSignalConversionAtVeT_ex[4] = THMR_ac_B.VariantMerge_Fo_p;
    for (i = 0; i < 3; i++)
    {
        /* Sum: '<S3021>/Add1' incorporates:
         *  Constant: '<S3020>/Calib'
         *  Constant: '<S3021>/Constant'
         *  Gain: '<S3021>/Gain2'
         */
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 3;
                rtb_DataTypeConversion2++)
        {
            i_0 = (3 * i) + rtb_DataTypeConversion2;
            tmp_3[i_0] = KaTHMR_k_AkalmanMLTLMBC[(i_0)] -
                (KaTHMR_k_LkalmanMLTLMBC[(rtb_DataTypeConversion2)] *
                 KaTHMR_k_CkalmanMLTLMBC[(i)]);
        }

        /* End of Sum: '<S3021>/Add1' */

        /* Sum: '<S3021>/Add' incorporates:
         *  Constant: '<S3020>/Calib'
         *  Gain: '<S3021>/Gain1'
         *  Product: '<S3021>/Product'
         */
        rtb_Switch10 = 0.0F;
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 5;
                rtb_DataTypeConversion2++)
        {
            rtb_Switch10 += KaTHMR_k_BkalmanMLTLMBC[(3 * rtb_DataTypeConversion2)
                + i] * rtb_TmpSignalConversionAtVeT_ex[rtb_DataTypeConversion2];
        }

        tmp[i] = (KaTHMR_k_LkalmanMLTLMBC[(i)] * rtb_TmpSignalConversionAtVeT_jp)
            + rtb_Switch10;
    }

    /* Product: '<S3021>/Product1' incorporates:
     *  UnitDelay: '<S3021>/UnitDelay'
     */
    for (i = 0; i < 3; i++)
    {
        tmp_0[i] = 0.0F;
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 3;
                rtb_DataTypeConversion2++)
        {
            tmp_0[i] += tmp_3[(3 * rtb_DataTypeConversion2) + i] *
                THMR_ac_DW.UnitDelay_DSTATE_cg[rtb_DataTypeConversion2];
        }
    }

    /* End of Product: '<S3021>/Product1' */

    /* Update for UnitDelay: '<S3021>/UnitDelay' incorporates:
     *  Sum: '<S3021>/Add'
     */
    for (i = 0; i < 3; i++)
    {
        THMR_ac_DW.UnitDelay_DSTATE_cg[i] = tmp[i] + tmp_0[i];
    }

    /* End of Update for UnitDelay: '<S3021>/UnitDelay' */

    /* Update for UnitDelay: '<S3057>/UnitDelay' incorporates:
     *  Sum: '<S3057>/Sum'
     */
    THMR_ac_DW.UnitDelay_DSTATE_ig += rtb_Switch1_ofq;

    /* Update for UnitDelay: '<S3023>/UnitDelay' incorporates:
     *  Product: '<S3070>/Product'
     */
    THMR_ac_DW.UnitDelay_DSTATE_f4 = rtb_TmpSignalConversionAtVeTM_n;

    /* Update for UnitDelay: '<S3023>/UnitDelay2' incorporates:
     *  Product: '<S3068>/Product'
     */
    THMR_ac_DW.UnitDelay2_DSTATE_cr = rtb_TmpSignalConversionAtVeFSCR;

    /* Update for UnitDelay: '<S3023>/UnitDelay3' incorporates:
     *  Product: '<S3069>/Product'
     */
    THMR_ac_DW.UnitDelay3_DSTATE_l1 = rtb_TmpSignalConversionAtVeT_gg;

    /* Update for UnitDelay: '<S3023>/UnitDelay1' incorporates:
     *  Product: '<S3071>/Product'
     */
    THMR_ac_DW.UnitDelay1_DSTATE_nc = rtb_TmpSignalConversionAtVeT_fy;

    /* Update for UnitDelay: '<S3024>/UnitDelay2' incorporates:
     *  Constant: '<S3079>/Calib'
     *  RelationalOperator: '<S3024>/Comparison2'
     */
    THMR_ac_DW.UnitDelay2_DSTATE_dp = (float32)((rtb_Merge1_i >
        KeTHMR_dV_LtrAfAwuMin) ? 1 : 0);

    /* End of Outputs for S-Function (fcgen): '<S2288>/Function-CallGenerator1' */
    /* End of Outputs for S-Function (fcgen): '<S62>/Function-CallGenerator' */

    /* Switch: '<S2282>/Switch3' incorporates:
     *  DataStoreRead: '<S62>/DataStoreRead1'
     *  DataStoreWrite: '<S62>/DataStoreWrite1'
     *  Logic: '<S62>/Logical3'
     *  Logic: '<S62>/Logical4'
     *  Logic: '<S62>/Or'
     *  S-Function (sfix_bitop): '<S2401>/FixPt Bitwise Operator3'
     *  S-Function (sfix_bitop): '<S2401>/FixPt Bitwise Operator4'
     *  S-Function (sfix_bitop): '<S2401>/FixPt Bitwise Operator5'
     *  S-Function (sfix_bitop): '<S2402>/FixPt Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2403>/FixPt Bitwise Operator3'
     *  S-Function (sfix_bitop): '<S2403>/FixPt Bitwise Operator4'
     *  S-Function (sfix_bitop): '<S2403>/FixPt Bitwise Operator5'
     *  S-Function (sfix_bitop): '<S2404>/FixPt Bitwise Operator1'
     *  Switch: '<S2283>/Switch3'
     */
    if (rtb_VM_Conditional_Signal_Use_M || (rtb_TmpSignalConversionAtVeT_pw && (
            !THMR_ac_B.OutportBufferForLTCLFBLEnbl)))
    {
        VeTHMR_y_PumpEnbl_DS = (uint8)(VeTHMR_y_PumpEnbl_DS | ((uint8)6));
    }
    else
    {
        VeTHMR_y_PumpEnbl_DS = (uint8)(~((uint8)(((uint8)(~((uint8)(~((uint8)
            (((uint8)(~VeTHMR_y_PumpEnbl_DS)) | ((uint8)2))))))) | ((uint8)4))));
    }

    /* End of Switch: '<S2282>/Switch3' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeBTRR_b_BattCoolReq_CPV_RA' */
    (void)Rte_Read_VeBTRR_b_BattCoolReq_CPV_RA_Value(&rtb_NotEqual_pl);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* SignalConversion generated from: '<S62>/FC_ClntTgt' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* VariantMerge generated from: '<S62>/FC_ClntTgt' */
    rtb_VM_Conditional_Signal_FC_Cl = THMR_ac_B.Switch10;

#else

    /* VariantMerge generated from: '<S62>/FC_ClntTgt' incorporates:
     *  SignalConversion generated from: '<S62>/FC_ClntTgt'
     */
    rtb_VM_Conditional_Signal_FC_Cl = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S62>/FC_ClntTgt' */

    /* Lookup_n-D: '<S2314>/Vector' incorporates:
     *  SignalConversion generated from: '<S1148>/VariantSource'
     */
    rtb_TmpSignalConversionAtVeT_fy = look1_iflf_binlcapw
        (VeTHMR_r_BattCabPriorityRatio_Fin, ((const float32 *)
          &(KxTHMR_r_BattCabPrioRatioFrHTLVlv[0])), ((const float32 *)
          &(KtTHMR_r_BattCabPrioRatioFrHTLVlv[0])), 4U);

    /* RelationalOperator: '<S2281>/Comparison5' incorporates:
     *  DataTypeConversion: '<S1842>/DataTypeConversion'
     */
    tmp_c = THMR_ac_B.DataTypeConversion_i;

    /* If: '<S2281>/TempErr_BTLPosition' incorporates:
     *  Constant: '<S2310>/Constant'
     *  Constant: '<S2311>/Constant'
     *  Constant: '<S2312>/Calib'
     *  Logic: '<S2281>/LogicalOperator3'
     *  Logic: '<S2281>/LogicalOperator4'
     *  RelationalOperator: '<S2281>/Comparison5'
     */
    if ((((((uint32)tmp_c) == CeTHMR_e_BatteryNCabinHeating) || (((uint32)tmp_c)
           == CeTHMR_e_CabinHeating)) && (THMR_ac_B.VariantMerge_Fo_at)) &&
            (KeTHMR_b_BTLHTLDrctConnct))
    {
        /* Outputs for IfAction SubSystem: '<S2281>/BattCPV_Error_Arbitratn_HTLReq' incorporates:
         *  ActionPort: '<S2305>/ActionPort'
         */
        /* If: '<S2305>/If1' incorporates:
         *  Constant: '<S2356>/Constant'
         *  Constant: '<S2357>/Constant'
         *  Logic: '<S2305>/Logical1'
         *  Logic: '<S2305>/Logical2'
         *  Logic: '<S2351>/Logical2'
         *  RelationalOperator: '<S2351>/Comparison5'
         *  RelationalOperator: '<S2351>/Comparison6'
         */
        if (((CeTHMR_e_CabinActiveHeating == ((uint32)rtb_Switch1_o0g)) ||
                (((uint32)rtb_Switch1_o0g) == CeTHMR_e_CabinActivePassiveHeating))
            && (!THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0))
        {
            /* Outputs for IfAction SubSystem: '<S2305>/HtrCor_Err' incorporates:
             *  ActionPort: '<S2347>/ActionPort'
             */
            THMR_ac_HtrCor_Err(VeTHMR_T_HtrCorClnt_Tmp_In_AD,
                               rtb_TmpSignalConversionAtVeCTRR,
                               &rtb_TmpSignalConversionAtVeFSCR);

            /* End of Outputs for SubSystem: '<S2305>/HtrCor_Err' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S2305>/NoHeat_HtrCore' incorporates:
             *  ActionPort: '<S2350>/ActionPort'
             */
            THMR_ac_NoHeat_HtrCore(&rtb_TmpSignalConversionAtVeFSCR);

            /* End of Outputs for SubSystem: '<S2305>/NoHeat_HtrCore' */
        }

        /* End of If: '<S2305>/If1' */

        /* SignalConversion generated from: '<S2305>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

        /* VariantMerge generated from: '<S2305>/VariantSource' incorporates:
         *  Constant: '<S2305>/Constant'
         */
        rtb_VariantMerge_For_Variant__l = false;

#else

        /* VariantMerge generated from: '<S2305>/VariantSource' incorporates:
         *  SignalConversion generated from: '<S2305>/VariantSource'
         */
        rtb_VariantMerge_For_Variant__l = THMR_ac_B.VeTHMR_b_FCHeatAllwd;

#endif

        /* End of SignalConversion generated from: '<S2305>/VariantSource' */

        /* If: '<S2305>/If4' */
        if (rtb_VariantMerge_For_Variant__l)
        {
            /* Outputs for IfAction SubSystem: '<S2305>/FC_Err' incorporates:
             *  ActionPort: '<S2346>/ActionPort'
             */
            THMR_ac_FC_Err(rtb_VM_Conditional_Signal_FC_Cl,
                           rtb_TmpSignalConversionAtVeTR_h,
                           &rtb_TmpSignalConversionAtVeTM_n);

            /* End of Outputs for SubSystem: '<S2305>/FC_Err' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S2305>/NoHeat_FC' incorporates:
             *  ActionPort: '<S2349>/ActionPort'
             */
            THMR_ac_NoHeat_HtrCore(&rtb_TmpSignalConversionAtVeTM_n);

            /* End of Outputs for SubSystem: '<S2305>/NoHeat_FC' */
        }

        /* End of If: '<S2305>/If4' */

        /* MinMax: '<S2305>/MinMax' */
        rtb_TmpSignalConversionAtVeFSCR = fmaxf(rtb_TmpSignalConversionAtVeFSCR,
            rtb_TmpSignalConversionAtVeTM_n);

        /* If: '<S2305>/If3' incorporates:
         *  Constant: '<S2358>/Constant'
         *  Constant: '<S2359>/Constant'
         *  Logic: '<S2352>/LogicalOperator'
         *  RelationalOperator: '<S2352>/Comparison3'
         *  RelationalOperator: '<S2352>/Comparison4'
         *  Switch: '<S4586>/Switch1'
         */
        if ((CeTHMR_e_PassiveHeating == ((uint32)VeTHMR_e_BatThrmlSt_B4D)) ||
                (((uint32)VeTHMR_e_BatThrmlSt_B4D) == CeTHMR_e_ActvPsvHeating))
        {
            /* Outputs for IfAction SubSystem: '<S2305>/Batt_ClntErr' incorporates:
             *  ActionPort: '<S2345>/ActionPort'
             */
            /* Merge: '<S2305>/Merge3' incorporates:
             *  Sum: '<S2345>/Subtraction1'
             */
            rtb_TmpSignalConversionAtVeTM_n = THMR_ac_B.Vector_h -
                rtb_TmpSignalConversionAtVeBT_k;

            /* End of Outputs for SubSystem: '<S2305>/Batt_ClntErr' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S2305>/NoHeat_Batt' incorporates:
             *  ActionPort: '<S2348>/ActionPort'
             */
            THMR_ac_NoHeat_HtrCore(&rtb_TmpSignalConversionAtVeTM_n);

            /* End of Outputs for SubSystem: '<S2305>/NoHeat_Batt' */
        }

        /* End of If: '<S2305>/If3' */

        /* Merge: '<S2281>/Merge3' incorporates:
         *  Constant: '<S2305>/ConstantValue'
         *  Product: '<S2305>/Product'
         *  Product: '<S2305>/Product1'
         *  Sum: '<S2305>/Add4'
         *  Sum: '<S2305>/Sum1'
         */
        VeTHMR_dT_BattCPV_TempErr = (rtb_TmpSignalConversionAtVeT_fy *
            rtb_TmpSignalConversionAtVeTM_n) - ((1.0F -
            rtb_TmpSignalConversionAtVeT_fy) * rtb_TmpSignalConversionAtVeFSCR);

        /* End of Outputs for SubSystem: '<S2281>/BattCPV_Error_Arbitratn_HTLReq' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2281>/TempError_BattHeating' incorporates:
         *  ActionPort: '<S2326>/ActionPort'
         */
        THMR_ac_TempError_BattHeating(THMR_ac_B.Vector_h,
            rtb_TmpSignalConversionAtVeBT_k, (&(VeTHMR_dT_BattCPV_TempErr)));

        /* End of Outputs for SubSystem: '<S2281>/TempError_BattHeating' */
    }

    /* If: '<S2281>/LTCL_Valve_Pos1' incorporates:
     *  Constant: '<S2368>/Constant1'
     *  Constant: '<S2368>/Constant2'
     *  Constant: '<S2369>/Constant'
     *  Constant: '<S2370>/Constant'
     *  Constant: '<S2371>/Calib'
     *  Constant: '<S2372>/Calib'
     *  Constant: '<S2373>/Calib'
     *  Constant: '<S2374>/Constant'
     *  Constant: '<S2375>/Constant'
     *  Constant: '<S2376>/Constant'
     *  Constant: '<S2377>/Constant'
     *  Constant: '<S2378>/Calib'
     *  Constant: '<S2379>/Constant'
     *  Constant: '<S2380>/Constant'
     *  Constant: '<S2381>/Constant'
     *  Constant: '<S2383>/Constant'
     *  Constant: '<S2384>/Constant'
     *  Constant: '<S2385>/Constant'
     *  Constant: '<S2386>/Constant'
     *  Constant: '<S2387>/Calib'
     *  Constant: '<S2390>/Constant'
     *  Constant: '<S2391>/Constant'
     *  Constant: '<S2392>/Constant'
     *  Constant: '<S2393>/Constant'
     *  Constant: '<S2394>/Constant'
     *  Constant: '<S2395>/Constant'
     *  Constant: '<S2396>/Constant'
     *  Constant: '<S2397>/Constant'
     *  Constant: '<S2398>/Constant'
     *  Constant: '<S2399>/Constant'
     *  Constant: '<S2400>/Calib'
     *  Logic: '<S2281>/Logical1'
     *  Logic: '<S2317>/LOCAnd'
     *  Logic: '<S2317>/LogicalOperator1'
     *  Logic: '<S2317>/LogicalOperator2'
     *  Logic: '<S2317>/LogicalOperator3'
     *  Logic: '<S2318>/Logical1'
     *  Logic: '<S2318>/Logical2'
     *  Logic: '<S2318>/Logical3'
     *  Logic: '<S2319>/Logical'
     *  Logic: '<S2319>/Logical1'
     *  Logic: '<S2321>/Logical2'
     *  Logic: '<S2322>/Logical2'
     *  Logic: '<S2323>/Logical1'
     *  Logic: '<S2323>/Logical2'
     *  Logic: '<S2324>/Logical1'
     *  Logic: '<S2324>/LogicalOperator2'
     *  Logic: '<S2368>/Logical Operator'
     *  Logic: '<S2382>/Logical1'
     *  Logic: '<S2382>/Logical2'
     *  RelationalOperator: '<S2318>/Comparison1'
     *  RelationalOperator: '<S2318>/Comparison2'
     *  RelationalOperator: '<S2318>/Comparison3'
     *  RelationalOperator: '<S2318>/Comparison5'
     *  RelationalOperator: '<S2319>/Comparison1'
     *  RelationalOperator: '<S2319>/Comparison2'
     *  RelationalOperator: '<S2319>/Comparison4'
     *  RelationalOperator: '<S2321>/Comparison2'
     *  RelationalOperator: '<S2321>/Comparison3'
     *  RelationalOperator: '<S2322>/Comparison2'
     *  RelationalOperator: '<S2322>/Comparison3'
     *  RelationalOperator: '<S2323>/Comparison1'
     *  RelationalOperator: '<S2323>/Comparison2'
     *  RelationalOperator: '<S2323>/Comparison3'
     *  RelationalOperator: '<S2323>/Comparison4'
     *  RelationalOperator: '<S2324>/Comparison1'
     *  RelationalOperator: '<S2324>/Comparison2'
     *  RelationalOperator: '<S2368>/Relational Operator1'
     *  RelationalOperator: '<S2368>/Relational Operator2'
     *  RelationalOperator: '<S2369>/RelationalOperator'
     *  RelationalOperator: '<S2370>/RelationalOperator'
     *  RelationalOperator: '<S2382>/Comparison1'
     *  RelationalOperator: '<S2382>/Comparison2'
     *  RelationalOperator: '<S2382>/Comparison3'
     *  RelationalOperator: '<S2382>/Comparison4'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     *  Switch: '<S4586>/Switch1'
     *  UnitDelay: '<S2281>/UnitDelay'
     */
    rtPrevAction = THMR_ac_DW.LTCL_Valve_Pos1_ActiveSubsystem;
    if (((((KeTHMR_b_PECP_LOC_FrcCPV_RA_Enbl) && ((rtb_AND_bp_tmp != 0U) &&
            (rtb_AND_bp_tmp_0 == 0U))) || ((KeTHMR_b_PECP_Perf_FrcCPV_RA_Enbl) &&
           (rtb_Logical3_ks_tmp > 0))) || ((KeTHMR_b_PECP_DR_FrcCPV_RA_Enbl) &&
            (rtb_Logical1_du_tmp > 0))) || rtb_NotEqual_pl)
    {
        rtAction = 0;
    }
    else
    {
        /* RelationalOperator: '<S2318>/Comparison3' incorporates:
         *  Merge: '<S4575>/Merge1'
         *  RelationalOperator: '<S2321>/Comparison3'
         *  RelationalOperator: '<S2322>/Comparison3'
         */
        tmp_d = THMR_ac_B.VeTHMR_e_LTCLThrmlMode;
        if (((((CeTHMR_e_PassiveHeating != ((uint32)VeTHMR_e_BatThrmlSt_B4D)) &&
               (((uint32)VeTHMR_e_BatThrmlSt_B4D) != CeTHMR_e_PassiveCooling)) &&
              (((uint32)VeTHMR_e_BatThrmlSt_B4D) != CeTHMR_e_ActvPsvHeating)) &&
             (((uint32)tmp_d) != CeTHMR_e_LTCLActvWasteHeatRcvry)) ||
                ((THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0) &&
                 (KeTHMR_b_PerWupOvrrd4CPV)))
        {
            rtAction = 1;
        }
        else if (((((uint32)VeTHMR_e_BatThrmlSt_B4D) == CeTHMR_e_ActvPsvHeating)
                  && (((uint32)THMR_ac_DW.UnitDelay_DSTATE_jx) ==
                      CeTHMR_e_LTCLActvPsvHeating)) &&
                 ((CeTHMR_e_CabinActivePassiveHeating == ((uint32)
                    rtb_Switch1_o0g)) || (((uint32)rtb_Switch1_o0g) ==
                   CeTHMR_e_CabinActiveHeating)))
        {
            rtAction = 2;
        }
        else if ((((CeTHMR_e_PassiveHeating == ((uint32)VeTHMR_e_BatThrmlSt_B4D))
                   || (((uint32)VeTHMR_e_BatThrmlSt_B4D) ==
                       CeTHMR_e_ActvPsvHeating)) &&
                  (THMR_ac_B.VariantMerge_Fo_at)) && (KeTHMR_b_BTLHTLDrctConnct))
        {
            rtAction = 3;
        }
        else if ((((CeTHMR_e_PassiveHeating == ((uint32)VeTHMR_e_BatThrmlSt_B4D))
                   || (((uint32)VeTHMR_e_BatThrmlSt_B4D) ==
                       CeTHMR_e_PassiveCooling)) || (((uint32)
                    VeTHMR_e_BatThrmlSt_B4D) == CeTHMR_e_ActvPsvHeating)) &&
                 (((((((uint32)rtb_TmpSignalConversionAtVePD_l) !=
                      CePDTR_e_Dischrg_BatTempNotOpt) && (((uint32)
                       rtb_TmpSignalConversionAtVePD_l) !=
                      CePDTR_e_Dischrg_ForcBatCool_Hys)) && (((uint32)
                      rtb_TmpSignalConversionAtVePD_l) !=
                     CePDTR_e_Dischrg_BatAndCab_Cndtn)) && (((uint32)
                     rtb_TmpSignalConversionAtVePD_l) !=
                    CePDTR_e_Dischrg_ForcBatHeat_Hys)) ||
                  (KeTHMR_b_LINPrplVlv_BatOV_Ovrd)))
        {
            rtAction = 4;
        }
        else if ((((uint32)VeTHMR_e_BatThrmlSt_B4D) ==
                  CeTHMR_e_BTLActvWasteHeatRcvry) && (((uint32)tmp_d) ==
                  CeTHMR_e_LTCLActvWasteHeatRcvry))
        {
            rtAction = 5;
        }
        else if ((((uint32)VeTHMR_e_BatThrmlSt_B4D) == CeTHMR_e_NoConditioning) &&
                 (((uint32)tmp_d) == CeTHMR_e_LTCLActvWasteHeatRcvry))
        {
            rtAction = 6;
        }
        else
        {
            rtAction = 7;
        }
    }

    THMR_ac_DW.LTCL_Valve_Pos1_ActiveSubsystem = rtAction;
    switch (rtAction)
    {
      case 0:
        /* Outputs for IfAction SubSystem: '<S2281>/BTLVlv_OpenAllPorts' incorporates:
         *  ActionPort: '<S2303>/ActionPort'
         */
        /* Merge: '<S2281>/Merge2' incorporates:
         *  Constant: '<S2327>/Calib'
         *  SignalConversion generated from: '<S2303>/OpenAllPorts'
         */
        VeTHMR_Pct_BattCPV_PosReq = KeTHMR_Pct_LINPrplVlv_AllPortsOpen;

        /* End of Outputs for SubSystem: '<S2281>/BTLVlv_OpenAllPorts' */
        break;

      case 1:
        /* Outputs for IfAction SubSystem: '<S2281>/BatteryLoop_toChiller' incorporates:
         *  ActionPort: '<S2308>/ActionPort'
         */
        /* Merge: '<S2281>/Merge2' incorporates:
         *  Constant: '<S2362>/Calib'
         *  SignalConversion generated from: '<S2308>/BattOnlyChiller'
         */
        VeTHMR_Pct_BattCPV_PosReq = KeTHMR_Pct_LINPrplVlv_TwoLoops;

        /* End of Outputs for SubSystem: '<S2281>/BatteryLoop_toChiller' */
        break;

      case 2:
        /* Outputs for IfAction SubSystem: '<S2281>/LTCLBTL_PartiallyComb' incorporates:
         *  ActionPort: '<S2315>/ActionPort'
         */
        /* Merge: '<S2281>/Merge2' incorporates:
         *  Constant: '<S2366>/Calib'
         *  SignalConversion generated from: '<S2315>/BattOnlyChiller'
         */
        VeTHMR_Pct_BattCPV_PosReq = KeTHMR_Pct_LINPrplVlv_LTCLBTLPrtlyComb;

        /* End of Outputs for SubSystem: '<S2281>/LTCLBTL_PartiallyComb' */
        break;

      case 3:
        if (rtAction != rtPrevAction)
        {
            /* SystemReset for IfAction SubSystem: '<S2281>/BTLVlv_fr_BattActvPsv_HeatingProp' incorporates:
             *  ActionPort: '<S2304>/ActionPort'
             */
            /* SystemReset for Atomic SubSystem: '<S2330>/EdgeBi' */
            /* SystemReset for If: '<S2281>/LTCL_Valve_Pos1' incorporates:
             *  UnitDelay: '<S2331>/UnitDelay'
             *  UnitDelay: '<S2332>/UnitDelay'
             *  UnitDelay: '<S2333>/UnitDelay'
             *  UnitDelay: '<S2342>/UnitDelay'
             */
            THMR_ac_DW.UnitDelay_DSTATE_k3 = false;

            /* End of SystemReset for SubSystem: '<S2330>/EdgeBi' */

            /* SystemReset for Atomic SubSystem: '<S2330>/EdgeRising' */
            THMR_ac_DW.UnitDelay_DSTATE_kcu = false;

            /* End of SystemReset for SubSystem: '<S2330>/EdgeRising' */

            /* SystemReset for Atomic SubSystem: '<S2330>/PIControl' */
            THMR_ac_DW.UnitDelay_DSTATE_ix3 = 0.0F;

            /* End of SystemReset for SubSystem: '<S2330>/PIControl' */

            /* SystemReset for Atomic SubSystem: '<S2330>/GradientLimiter' */
            THMR_ac_DW.UnitDelay_DSTATE_ch = 0.0F;

            /* End of SystemReset for SubSystem: '<S2330>/GradientLimiter' */
            /* End of SystemReset for SubSystem: '<S2281>/BTLVlv_fr_BattActvPsv_HeatingProp' */
        }

        /* Outputs for IfAction SubSystem: '<S2281>/BTLVlv_fr_BattActvPsv_HeatingProp' incorporates:
         *  ActionPort: '<S2304>/ActionPort'
         */
        /* Outputs for Atomic SubSystem: '<S2330>/EdgeBi' */
        /* RelationalOperator: '<S2331>/NotEqual' incorporates:
         *  UnitDelay: '<S2331>/UnitDelay'
         */
        rtb_NotEqual_pl = !THMR_ac_DW.UnitDelay_DSTATE_k3;

        /* Update for UnitDelay: '<S2331>/UnitDelay' incorporates:
         *  Constant: '<S2304>/TRUEConstant1'
         */
        THMR_ac_DW.UnitDelay_DSTATE_k3 = true;

        /* End of Outputs for SubSystem: '<S2330>/EdgeBi' */

        /* Outputs for Atomic SubSystem: '<S2330>/EdgeRising' */
        /* Logic: '<S2332>/AND' incorporates:
         *  Logic: '<S2332>/OR1'
         *  UnitDelay: '<S2332>/UnitDelay'
         */
        rtb_VariantMerge_For_Variant__l = !THMR_ac_DW.UnitDelay_DSTATE_kcu;

        /* Update for UnitDelay: '<S2332>/UnitDelay' incorporates:
         *  Constant: '<S2330>/TRUEConstant'
         */
        THMR_ac_DW.UnitDelay_DSTATE_kcu = true;

        /* End of Outputs for SubSystem: '<S2330>/EdgeRising' */

        /* Outputs for Atomic SubSystem: '<S2330>/PIControl' */
        /* Switch: '<S2342>/Switch' incorporates:
         *  Logic: '<S2330>/Logical1'
         */
        if (rtb_VariantMerge_For_Variant__l || rtb_NotEqual_pl)
        {
            /* Switch: '<S2342>/Switch' incorporates:
             *  Constant: '<S2338>/Calib'
             */
            rtb_TmpSignalConversionAtVeT_fy = KeTHMR_Pct_BTLVlvPI_IV;
        }
        else
        {
            /* Switch: '<S2342>/Switch' incorporates:
             *  Constant: '<S2328>/Calib'
             *  Constant: '<S2330>/Constant2'
             *  Product: '<S2342>/Multiplication2'
             *  Sum: '<S2342>/Sum//Sub'
             *  UnitDelay: '<S2342>/UnitDelay'
             */
            rtb_TmpSignalConversionAtVeT_fy = ((VeTHMR_dT_BattCPV_TempErr * 0.1F)
                * KeTHMR_K_BTLVlvPICont_Ki) + THMR_ac_DW.UnitDelay_DSTATE_ix3;
        }

        /* End of Switch: '<S2342>/Switch' */

        /* Outputs for Atomic SubSystem: '<S2342>/integral_term' */
        /* Switch: '<S2344>/Switch1' incorporates:
         *  Constant: '<S2336>/Calib'
         *  RelationalOperator: '<S2344>/RelationalOperator'
         */
        if (KeTHMR_Pct_BTLVlvITerm_Max < rtb_TmpSignalConversionAtVeT_fy)
        {
            /* Switch: '<S2341>/Switch1' */
            rtb_TmpSignalConversionAtVeT_fy = KeTHMR_Pct_BTLVlvITerm_Max;
        }

        /* End of Switch: '<S2344>/Switch1' */

        /* Switch: '<S2344>/Switch' incorporates:
         *  Constant: '<S2337>/Calib'
         *  RelationalOperator: '<S2344>/RelationalOperator1'
         */
        if (rtb_TmpSignalConversionAtVeT_fy <= KeTHMR_Pct_BTLVlvITerm_Min)
        {
            /* Switch: '<S2344>/Switch' */
            rtb_TmpSignalConversionAtVeT_fy = KeTHMR_Pct_BTLVlvITerm_Min;
        }

        /* End of Switch: '<S2344>/Switch' */
        /* End of Outputs for SubSystem: '<S2342>/integral_term' */

        /* Update for UnitDelay: '<S2342>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_ix3 = rtb_TmpSignalConversionAtVeT_fy;

        /* Outputs for Atomic SubSystem: '<S2330>/GradientLimiter' */
        /* Sum: '<S2333>/Sum2' incorporates:
         *  Constant: '<S2329>/Calib'
         *  Product: '<S2342>/proportional_term'
         *  Sum: '<S2342>/Sum//Sub1'
         *  UnitDelay: '<S2333>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeT_fy = ((VeTHMR_dT_BattCPV_TempErr *
            KeTHMR_K_BTLVlvPICont_Kp) + rtb_TmpSignalConversionAtVeT_fy) -
            THMR_ac_DW.UnitDelay_DSTATE_ch;

        /* End of Outputs for SubSystem: '<S2330>/PIControl' */

        /* Outputs for Atomic SubSystem: '<S2333>/Limiter' */
        /* Switch: '<S2343>/Switch1' incorporates:
         *  Constant: '<S2340>/Calib'
         *  RelationalOperator: '<S2343>/RelationalOperator'
         */
        if (KeTHMR_dPct_BTLVlvCntrl_LU < rtb_TmpSignalConversionAtVeT_fy)
        {
            /* Switch: '<S2343>/Switch1' */
            rtb_TmpSignalConversionAtVeT_fy = KeTHMR_dPct_BTLVlvCntrl_LU;
        }

        /* End of Switch: '<S2343>/Switch1' */

        /* Switch: '<S2343>/Switch' incorporates:
         *  Constant: '<S2339>/Calib'
         *  RelationalOperator: '<S2343>/RelationalOperator1'
         */
        if (rtb_TmpSignalConversionAtVeT_fy <= KeTHMR_dPct_BTLVlvCntrl_LD)
        {
            rtb_TmpSignalConversionAtVeT_fy = KeTHMR_dPct_BTLVlvCntrl_LD;
        }

        /* End of Switch: '<S2343>/Switch' */
        /* End of Outputs for SubSystem: '<S2333>/Limiter' */

        /* Sum: '<S2333>/Sum3' incorporates:
         *  UnitDelay: '<S2333>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeT_fy += THMR_ac_DW.UnitDelay_DSTATE_ch;

        /* Update for UnitDelay: '<S2333>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_ch = rtb_TmpSignalConversionAtVeT_fy;

        /* End of Outputs for SubSystem: '<S2330>/GradientLimiter' */

        /* Outputs for Atomic SubSystem: '<S2330>/Limiter' */
        /* Switch: '<S2341>/Switch1' incorporates:
         *  Constant: '<S2334>/Calib'
         *  RelationalOperator: '<S2341>/RelationalOperator'
         */
        if (KeTHMR_Pct_BTLVlvCntrl_Max < rtb_TmpSignalConversionAtVeT_fy)
        {
            /* Switch: '<S2341>/Switch1' */
            rtb_TmpSignalConversionAtVeT_fy = KeTHMR_Pct_BTLVlvCntrl_Max;
        }

        /* End of Switch: '<S2341>/Switch1' */

        /* Switch: '<S2341>/Switch' incorporates:
         *  Constant: '<S2335>/Calib'
         *  RelationalOperator: '<S2341>/RelationalOperator1'
         */
        if (rtb_TmpSignalConversionAtVeT_fy > KeTHMR_Pct_BTLVlvCntrl_Min)
        {
            /* Merge: '<S2281>/Merge2' */
            VeTHMR_Pct_BattCPV_PosReq = rtb_TmpSignalConversionAtVeT_fy;
        }
        else
        {
            /* Merge: '<S2281>/Merge2' */
            VeTHMR_Pct_BattCPV_PosReq = KeTHMR_Pct_BTLVlvCntrl_Min;
        }

        /* End of Switch: '<S2341>/Switch' */
        /* End of Outputs for SubSystem: '<S2330>/Limiter' */
        /* End of Outputs for SubSystem: '<S2281>/BTLVlv_fr_BattActvPsv_HeatingProp' */
        break;

      case 4:
        /* Outputs for IfAction SubSystem: '<S2281>/Batt_LTCL_SingleLoop_ChillerBypss' incorporates:
         *  ActionPort: '<S2306>/ActionPort'
         */
        /* Merge: '<S2281>/Merge2' incorporates:
         *  Constant: '<S2360>/Calib'
         *  SignalConversion generated from: '<S2306>/Batt_LTCL_Common'
         */
        VeTHMR_Pct_BattCPV_PosReq = KeTHMR_Pct_LINPrplVlv_SingleLoop;

        /* End of Outputs for SubSystem: '<S2281>/Batt_LTCL_SingleLoop_ChillerBypss' */
        break;

      case 5:
        /* Outputs for IfAction SubSystem: '<S2281>/Batt_LTCL_toChiller' incorporates:
         *  ActionPort: '<S2307>/ActionPort'
         */
        /* Merge: '<S2281>/Merge2' incorporates:
         *  Constant: '<S2361>/Calib'
         *  SignalConversion generated from: '<S2307>/Batt_LTCL_toChiller'
         */
        VeTHMR_Pct_BattCPV_PosReq = KeTHMR_Pct_LINPrplVlv_TwoLoops_BattLTCLComb;

        /* End of Outputs for SubSystem: '<S2281>/Batt_LTCL_toChiller' */
        break;

      case 6:
        /* Outputs for IfAction SubSystem: '<S2281>/LTCL_toChiller' incorporates:
         *  ActionPort: '<S2316>/ActionPort'
         */
        /* Merge: '<S2281>/Merge2' incorporates:
         *  Constant: '<S2367>/Calib'
         *  SignalConversion generated from: '<S2316>/LTCL_toChiller'
         */
        VeTHMR_Pct_BattCPV_PosReq = KeTHMR_Pct_LINPrplVlv_TwoLoops_LTCLCool;

        /* End of Outputs for SubSystem: '<S2281>/LTCL_toChiller' */
        break;

      default:
        /* Outputs for IfAction SubSystem: '<S2281>/Else_Dftl' incorporates:
         *  ActionPort: '<S2309>/ActionPort'
         */
        /* Switch: '<S2309>/Switch2' incorporates:
         *  Constant: '<S2365>/Calib'
         */
        if (KeTHMR_b_LINPrplVlv_PrplMd)
        {
            /* Merge: '<S2281>/Merge2' incorporates:
             *  Constant: '<S2363>/Calib'
             */
            VeTHMR_Pct_BattCPV_PosReq = KeTHMR_Pct_LINPrplVlv_PrplMdReq;
        }
        else
        {
            /* Merge: '<S2281>/Merge2' incorporates:
             *  Constant: '<S2364>/Calib'
             */
            VeTHMR_Pct_BattCPV_PosReq = KeTHMR_Pct_LINPrplVlv_TwoLoops;
        }

        /* End of Switch: '<S2309>/Switch2' */
        /* End of Outputs for SubSystem: '<S2281>/Else_Dftl' */
        break;
    }

    /* End of If: '<S2281>/LTCL_Valve_Pos1' */

    /* SignalConversion generated from: '<S2285>/Selector' */
    tmp[0] = VeTHMR_T_MtrA_Temp;
    tmp[1] = VeTHMR_T_MtrB_Temp;
    tmp[2] = VeTHMR_T_MtrC_Temp;
    for (i = 0; i < 3; i++)
    {
        /* Selector: '<S2285>/Selector' incorporates:
         *  Constant: '<S2418>/Calib'
         */
        rtb_Selector_c[i] = tmp[KaTHMR_i_RearFrontGEN_HeatFlwTgt[(i)]];
    }

    /* Switch: '<S2864>/Switch5' incorporates:
     *  Constant: '<S2875>/Calib'
     */
    if (KeTHMR_b_RearEDM_FrontEDM_UseOilTemp)
    {
        /* Switch: '<S2864>/Switch5' */
        rtb_TmpSignalConversionAtVeFSCR = VeTHMR_T_Pump2OilTemp;
    }
    else
    {
        /* Switch: '<S2864>/Switch5' */
        rtb_TmpSignalConversionAtVeFSCR = VeTHMR_T_PumpOilTemp;
    }

    /* End of Switch: '<S2864>/Switch5' */

    /* Switch: '<S2928>/Switch3' incorporates:
     *  Constant: '<S2989>/Calib'
     */
    if (KeTHMR_b_LT_PrssFlwRunning_Slct)
    {
        /* Merge: '<S2928>/Merge' incorporates:
         *  Constant: '<S2991>/Calib'
         *  Product: '<S2928>/Product'
         *  Sum: '<S2928>/Subtraction'
         */
        rtb_TmpSignalConversionAtVeT_fy = (VeTHMR_n_LTPsvPump2RPMAct_B4SET -
            VeTHMR_n_LTPsvPumpRPMAct_B4SET) * KeTHMR_k_alpha;
    }
    else
    {
        /* Merge: '<S2928>/Merge' incorporates:
         *  UnitDelay: '<S2928>/UnitDelay1'
         */
        rtb_TmpSignalConversionAtVeT_fy = THMR_ac_DW.UnitDelay1_DSTATE_ly;
    }

    /* End of Switch: '<S2928>/Switch3' */

    /* Switch: '<S2928>/Switch1' incorporates:
     *  Constant: '<S2990>/Calib'
     *  UnitDelay: '<S2928>/UnitDelay'
     */
    if (KeTHMR_b_LT_PsvPmpRunning_Slct)
    {
        rtb_Switch10 = VeTHMR_n_LTPsvPumpRPMAct_B4SET;
    }
    else
    {
        rtb_Switch10 = THMR_ac_DW.UnitDelay_DSTATE_hr;
    }

    /* End of Switch: '<S2928>/Switch1' */

    /* Logic: '<S2928>/LogicalOperator1' incorporates:
     *  Constant: '<S2992>/Calib'
     *  Constant: '<S2993>/Calib'
     *  Logic: '<S2928>/LogicalOperator2'
     *  Logic: '<S2928>/LogicalOperator3'
     *  RelationalOperator: '<S2928>/RelationalOperator4'
     *  RelationalOperator: '<S2928>/RelationalOperator5'
     */
    rtb_NotEqual_pl = (((VeTHMR_b_EmrgcyFanRq_Lv1) && (rtb_Switch10 <
                         KeTHMR_n_LT_PsvPmpRPM_Min)) ||
                       ((VeTHMR_b_EmrgcyFanRq_Lv1) &&
                        (rtb_TmpSignalConversionAtVeT_fy <
                         KeTHMR_n_LT_PrssFlwRPM_Min)));

    /* Logic: '<S2469>/Logical5' incorporates:
     *  Constant: '<S2487>/Calib'
     *  Logic: '<S2469>/Logical2'
     */
    tmpForInput_0[0] = (rtb_TmpSignalConversionAtVeTM_j &&
                        (KaTHMR_i_ERLv1_Branch1Select[0]));
    tmpForInput_0[1] = (rtb_TmpSignalConversionAtVeT_f5 &&
                        (KaTHMR_i_ERLv1_Branch1Select[1]));
    tmpForInput_0[2] = (rtb_Logical46_fu && (KaTHMR_i_ERLv1_Branch1Select[2]));
    tmpForInput_0[3] = (rtb_Logical46_j2 && (KaTHMR_i_ERLv1_Branch1Select[3]));
    tmpForInput_0[4] = (rtb_Logical46_ov && (KaTHMR_i_ERLv1_Branch1Select[4]));
    tmpForInput_0[5] = (rtb_Logical46_cr && (KaTHMR_i_ERLv1_Branch1Select[5]));
    tmpForInput_0[6] = (Switch9_a && (KaTHMR_i_ERLv1_Branch1Select[6]));
    tmpForInput_0[7] = (rtb_Logical46_hh && (KaTHMR_i_ERLv1_Branch1Select[7]));
    tmpForInput_0[8] = (rtb_Logical17_h && (KaTHMR_i_ERLv1_Branch1Select[8]));
    tmpForInput_0[9] = (rtb_Logical1_c0 && (KaTHMR_i_ERLv1_Branch1Select[9]));
    tmpForInput_0[10] = (rtb_Logical1_li && (KaTHMR_i_ERLv1_Branch1Select[10]));
    tmpForInput_0[11] = (rtb_Logical1_gx && (KaTHMR_i_ERLv1_Branch1Select[11]));
    tmpForInput_0[12] = (rtb_Logical2_oq && (KaTHMR_i_ERLv1_Branch1Select[12]));

    /* Logic: '<S2469>/Logical6' */
    rtb_AND_fe = tmpForInput_0[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 12;
            rtb_DataTypeConversion2++)
    {
        rtb_AND_fe = (rtb_AND_fe || (tmpForInput_0[rtb_DataTypeConversion2 + 1]));
    }

    /* If: '<S2928>/If' incorporates:
     *  Logic: '<S2469>/Logical6'
     *  Logic: '<S2928>/Logical3'
     */
    if (rtb_NotEqual_pl && rtb_AND_fe)
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct' incorporates:
         *  ActionPort: '<S2966>/Action Port'
         */
        /* Merge: '<S2928>/Merge' incorporates:
         *  Constant: '<S2994>/Calib'
         *  SignalConversion generated from: '<S2966>/Out1'
         */
        rtb_TmpSignalConversionAtVeT_fy = KeTHMR_dV_Branch1_Emrgcy_LV1;

        /* End of Outputs for SubSystem: '<S2928>/IfAct' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct1' incorporates:
         *  ActionPort: '<S2967>/Action Port'
         */
        THMR_ac_IfAct1(&rtb_TmpSignalConversionAtVeT_fy);

        /* End of Outputs for SubSystem: '<S2928>/IfAct1' */
    }

    /* End of If: '<S2928>/If' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Fan_Shutt_Command'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/ActiveAirDam_ThermalRequest'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/ProcessAftrRunRq'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/ThermalAirflow_Arb'
     */
    /* RelationalOperator: '<S2928>/Relational Operator6' incorporates:
     *  Inport: '<S2741>/In1'
     *  RelationalOperator: '<S37>/Comparison5'
     *  RelationalOperator: '<S4819>/RelationalOperator3'
     *  RelationalOperator: '<S5131>/RelationalOperator3'
     *  RelationalOperator: '<S5365>/Comparison1'
     *  RelationalOperator: '<S5365>/Comparison4'
     *  RelationalOperator: '<S71>/Comparison4'
     *  Switch: '<S1136>/Switch1'
     *  Switch: '<S3630>/Switch1'
     *  Switch: '<S5510>/Switch1'
     */
    rtb_VariantMerge_For__adzsu0cfj = VeTHMR_e_EmrgcyFanRq_Lvl_B4D;

    /* Logic: '<S2928>/Logical7' incorporates:
     *  Constant: '<S2965>/Constant'
     *  Inport: '<S2741>/In1'
     *  RelationalOperator: '<S2928>/Relational Operator6'
     */
    rtb_VariantMerge_For_Variant__l = ((VeTHMR_b_EmrgcyFanRq_Lvl2) || (((uint32)
        VeTHMR_e_EmrgcyFanRq_Lvl_B4D) == CeTHMR_e_SNA_EmrgcyFanRq));

    /* Logic: '<S2470>/Logical11' incorporates:
     *  Constant: '<S2571>/Calib'
     *  Logic: '<S2470>/Logical9'
     */
    tmpForInput[0] = (rtb_Logical12_dt && (KaTHMR_i_ERLv2_Branch1Select[0]));
    tmpForInput[1] = (rtb_Logical12_pv && (KaTHMR_i_ERLv2_Branch1Select[1]));
    tmpForInput[2] = (rtb_Logical1_bt && (KaTHMR_i_ERLv2_Branch1Select[2]));
    tmpForInput[3] = (rtb_Logical3_oz && (KaTHMR_i_ERLv2_Branch1Select[3]));
    tmpForInput[4] = (rtb_VariantMerge_For_Variant__n &&
                      (KaTHMR_i_ERLv2_Branch1Select[4]));
    tmpForInput[5] = (rtb_TmpSignalConversionAtVePD_p &&
                      (KaTHMR_i_ERLv2_Branch1Select[5]));
    tmpForInput[6] = (rtb_TmpSignalConversionAtVePD_i &&
                      (KaTHMR_i_ERLv2_Branch1Select[6]));
    tmpForInput[7] = (rtb_AND_c3 && (KaTHMR_i_ERLv2_Branch1Select[7]));
    tmpForInput[8] = (rtb_OR1_g4 && (KaTHMR_i_ERLv2_Branch1Select[8]));
    tmpForInput[9] = (rtb_Logical18_d && (KaTHMR_i_ERLv2_Branch1Select[9]));
    tmpForInput[10] = (rtb_Logical6_or && (KaTHMR_i_ERLv2_Branch1Select[10]));
    tmpForInput[11] = (rtb_Comparison3_bu && (KaTHMR_i_ERLv2_Branch1Select[11]));
    tmpForInput[12] = (Switch5_i && (KaTHMR_i_ERLv2_Branch1Select[12]));
    tmpForInput[13] = (rtb_AND_cn && (KaTHMR_i_ERLv2_Branch1Select[13]));
    tmpForInput[14] = (rtb_Comparison4_cx && (KaTHMR_i_ERLv2_Branch1Select[14]));
    tmpForInput[15] = (rtb_TmpSignalConversionAtOutAir &&
                       (KaTHMR_i_ERLv2_Branch1Select[15]));
    tmpForInput[16] = (rtb_Comparison6_n3 && (KaTHMR_i_ERLv2_Branch1Select[16]));
    tmpForInput[17] = (rtb_Logical15_o && (KaTHMR_i_ERLv2_Branch1Select[17]));
    tmpForInput[18] = (rtb_AND_ko5 && (KaTHMR_i_ERLv2_Branch1Select[18]));
    tmpForInput[19] = (rtb_Comparison5_c3m && (KaTHMR_i_ERLv2_Branch1Select[19]));
    tmpForInput[20] = (rtb_Logical5_bn && (KaTHMR_i_ERLv2_Branch1Select[20]));
    tmpForInput[21] = (rtb_TmpSignalConversionAtVeT_d5 &&
                       (KaTHMR_i_ERLv2_Branch1Select[21]));
    tmpForInput[22] = (rtb_TmpSignalConversionAtVeT_ib &&
                       (KaTHMR_i_ERLv2_Branch1Select[22]));
    tmpForInput[23] = (rtb_AND_jo && (KaTHMR_i_ERLv2_Branch1Select[23]));
    tmpForInput[24] = (rtb_AND_eb && (KaTHMR_i_ERLv2_Branch1Select[24]));
    tmpForInput[25] = (rtb_Logical4_of && (KaTHMR_i_ERLv2_Branch1Select[25]));
    tmpForInput[26] = (rtb_Logical3_at && (KaTHMR_i_ERLv2_Branch1Select[26]));
    tmpForInput[27] = (rtb_OR1_he && (KaTHMR_i_ERLv2_Branch1Select[27]));
    tmpForInput[28] = (rtb_AND_g2 && (KaTHMR_i_ERLv2_Branch1Select[28]));
    tmpForInput[29] = (rtb_Logical12_fs && (KaTHMR_i_ERLv2_Branch1Select[29]));
    tmpForInput[30] = (rtb_Logical12_hd && (KaTHMR_i_ERLv2_Branch1Select[30]));
    tmpForInput[31] = (rtb_Logical12_gu && (KaTHMR_i_ERLv2_Branch1Select[31]));
    tmpForInput[32] = (rtb_Logical12_c2 && (KaTHMR_i_ERLv2_Branch1Select[32]));
    tmpForInput[33] = (rtb_Logical12_gap && (KaTHMR_i_ERLv2_Branch1Select[33]));
    tmpForInput[34] = (rtb_Logical12_cpl && (KaTHMR_i_ERLv2_Branch1Select[34]));
    tmpForInput[35] = (rtb_Logical17_o && (KaTHMR_i_ERLv2_Branch1Select[35]));
    tmpForInput[36] = (rtb_Logical12_pb && (KaTHMR_i_ERLv2_Branch1Select[36]));
    tmpForInput[37] = (rtb_Logical12_e5 && (KaTHMR_i_ERLv2_Branch1Select[37]));
    tmpForInput[38] = (rtb_Logical12_dh && (KaTHMR_i_ERLv2_Branch1Select[38]));
    tmpForInput[39] = (rtb_Logical12_er && (KaTHMR_i_ERLv2_Branch1Select[39]));
    tmpForInput[40] = (rtb_Logical12_gz && (KaTHMR_i_ERLv2_Branch1Select[40]));
    tmpForInput[41] = (rtb_Logical12_k5 && (KaTHMR_i_ERLv2_Branch1Select[41]));
    tmpForInput[42] = (rtb_Logical12_hy && (KaTHMR_i_ERLv2_Branch1Select[42]));
    tmpForInput[43] = (rtb_TmpSignalConversionAtVeT_c0 &&
                       (KaTHMR_i_ERLv2_Branch1Select[43]));
    tmpForInput[44] = (rtb_Logical4_iq && (KaTHMR_i_ERLv2_Branch1Select[44]));

    /* Logic: '<S2470>/Logical6' */
    rtb_AND_fe = tmpForInput[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 44;
            rtb_DataTypeConversion2++)
    {
        rtb_AND_fe = (rtb_AND_fe || (tmpForInput[rtb_DataTypeConversion2 + 1]));
    }

    /* If: '<S2928>/If1' incorporates:
     *  Logic: '<S2470>/Logical6'
     *  Logic: '<S2928>/Logical5'
     */
    if (rtb_VariantMerge_For_Variant__l && rtb_AND_fe)
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct2' incorporates:
         *  ActionPort: '<S2976>/Action Port'
         */
        /* Merge: '<S2928>/Merge1' incorporates:
         *  Constant: '<S2999>/Calib'
         *  SignalConversion generated from: '<S2976>/Out1'
         */
        rtb_Merge1_i = KeTHMR_dV_Branch1_Emrgcy_LV2;

        /* End of Outputs for SubSystem: '<S2928>/IfAct2' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct3' incorporates:
         *  ActionPort: '<S2977>/Action Port'
         */
        THMR_ac_IfAct1(&rtb_Merge1_i);

        /* End of Outputs for SubSystem: '<S2928>/IfAct3' */
    }

    /* End of If: '<S2928>/If1' */

    /* Switch: '<S2927>/Switch1' */
    if (VeTHMR_b_ECM_LTPsvPmpRq_FA_AD)
    {
        /* Switch: '<S2927>/Switch1' incorporates:
         *  Constant: '<S2960>/Calib'
         */
        rtb_TmpSignalConversionAtVeTM_n = KeTHMR_Pct_ECM_LT_PsvPmpRq_Max;
    }
    else
    {
        /* Switch: '<S2927>/Switch1' */
        rtb_TmpSignalConversionAtVeTM_n = VeTHMR_Pct_ECM_LTPsvPmpRq_AD;
    }

    /* End of Switch: '<S2927>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S2927>/ProtectedDivision' */
    /* Switch: '<S2962>/Switch1' incorporates:
     *  Constant: '<S2962>/ConstantValue'
     *  RelationalOperator: '<S2962>/NotEqual'
     */
    if (rtb_TmpSignalConversionAtVeTM_n != 0.0F)
    {
        /* Switch: '<S2962>/Switch1' incorporates:
         *  Constant: '<S2927>/ConstantValue'
         *  Product: '<S2962>/Division'
         */
        rtb_TmpSignalConversionAtVeTM_n /= 100.0F;
    }
    else
    {
        /* Switch: '<S2962>/Switch1' incorporates:
         *  Constant: '<S2962>/ConstantValue4'
         *  Switch: '<S2962>/Switch2'
         *  Switch: '<S2962>/Switch3'
         */
        rtb_TmpSignalConversionAtVeTM_n = 0.0F;
    }

    /* End of Switch: '<S2962>/Switch1' */
    /* End of Outputs for SubSystem: '<S2927>/ProtectedDivision' */

    /* Product: '<S2927>/Product' incorporates:
     *  Constant: '<S2961>/Calib'
     */
    VeTHMR_dV_ECM_LTPsvPmpFlw = rtb_TmpSignalConversionAtVeTM_n *
        KeTHMR_dV_ECM_LTPsvPmpRq_Max;

    /* SignalConversion generated from: '<S2864>/Selector' */
    tmp[0] = VeTHMR_M_MtrA_TorqCmnd;
    tmp[1] = VeTHMR_M_MtrB_TorqCmnd;
    tmp[2] = VeTHMR_M_MtrC_TorqCmnd;

    /* SignalConversion generated from: '<S2864>/Selector1' */
    tmp_0[0] = VeTHMR_M_MtrA_TorqAchieved;
    tmp_0[1] = VeTHMR_M_MtrB_TorqAchieved;
    tmp_0[2] = VeTHMR_M_MtrC_TorqAchieved;

    /* SignalConversion generated from: '<S2285>/Selector1' incorporates:
     *  SignalConversion generated from: '<S2864>/Selector2'
     */
    rtb_Selector4_n[0] = VeTHMR_n_MtrA_Spd;
    rtb_Selector4_n[1] = VeTHMR_n_MtrB_Spd;
    rtb_Selector4_n[2] = VeTHMR_n_MtrC_Spd;

    /* SignalConversion generated from: '<S2864>/Selector2' */
    tmp_1[0] = VeTHMR_n_MtrA_Spd;
    tmp_1[1] = VeTHMR_n_MtrB_Spd;
    tmp_1[2] = VeTHMR_n_MtrC_Spd;
    for (i = 0; i < 3; i++)
    {
        /* Selector: '<S2864>/Selector' incorporates:
         *  Constant: '<S2870>/Calib'
         */
        rtb_Selector2_o[i] = tmp[KaTHMR_i_RearFrontGEN_HeatFlwTgt[(i)]];

        /* Selector: '<S2864>/Selector1' incorporates:
         *  Constant: '<S2870>/Calib'
         */
        rtb_Selector3[i] = tmp_0[KaTHMR_i_RearFrontGEN_HeatFlwTgt[(i)]];

        /* Selector: '<S2864>/Selector2' incorporates:
         *  Constant: '<S2870>/Calib'
         */
        rtb_TmpSignalConversionAtSele_h[i] =
            tmp_1[KaTHMR_i_RearFrontGEN_HeatFlwTgt[(i)]];
    }

    /* RelationalOperator: '<S2805>/RelationalOperator' incorporates:
     *  SignalConversion generated from: '<S2805>/VariantSource'
     *  SignalConversion generated from: '<S2869>/VariantSource'
     *  Switch: '<S2805>/Switch2'
     * */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (rtb_TmpSignalConversionAtVeTM_o)
    {
        /* VariantMerge generated from: '<S2805>/VariantSource' incorporates:
         *  Constant: '<S2867>/Calib'
         */
        rtb_VariantMerge_For_Variant_So = KeTHMR_T_PsvPmpClnt_FltSet;
    }
    else
    {
        /* VariantMerge generated from: '<S2805>/VariantSource' */
        rtb_VariantMerge_For_Variant_So = rtb_TmpSignalConversionAtVeT_jp;
    }

    /* RelationalOperator: '<S62>/RelationalOperator' incorporates:
     *  Constant: '<S2869>/Constant'
     */
    rtb_RelationalOperator_nw = false;

#else

    /* VariantMerge generated from: '<S2805>/VariantSource' incorporates:
     *  SignalConversion generated from: '<S2805>/VariantSource'
     */
    rtb_VariantMerge_For_Variant_So = Switch4_d;

    /* RelationalOperator: '<S62>/RelationalOperator' incorporates:
     *  Constant: '<S2869>/Constant1'
     *  SignalConversion generated from: '<S2869>/VariantSource'
     */
    rtb_RelationalOperator_nw = true;

#endif

    /* End of RelationalOperator: '<S2805>/RelationalOperator' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/ProcessAftrRunRq'
     */
    /* RelationalOperator: '<S2869>/RelationalOperator2' incorporates:
     *  Chart: '<S71>/AfterRun'
     *  DataStoreRead: '<S2869>/DataStoreRead'
     *  RelationalOperator: '<S2869>/RelationalOperator3'
     */
    rtb_RelationalOperator_kg_tmp = THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq;

    /* RelationalOperator: '<S62>/RelationalOperator' incorporates:
     *  Constant: '<S3010>/Constant'
     *  Constant: '<S3011>/Constant'
     *  Constant: '<S3012>/Constant'
     *  Constant: '<S3013>/Constant'
     *  Constant: '<S3014>/Constant'
     *  Constant: '<S3015>/Constant'
     *  Constant: '<S3016>/Constant'
     *  Constant: '<S3017>/Constant'
     *  Constant: '<S3018>/Calib'
     *  DataStoreRead: '<S3015>/StatusByte_MtrElect_CooPumBOvrSpd'
     *  DataStoreRead: '<S3017>/StatusByte_MtrElect_CoolPumAOvrSpd'
     *  Logic: '<S2869>/LogicalOperator'
     *  Logic: '<S2869>/LogicalOperator1'
     *  Logic: '<S2869>/LogicalOperator2'
     *  Logic: '<S2869>/LogicalOperator3'
     *  Logic: '<S2869>/LogicalOperator4'
     *  RelationalOperator: '<S2869>/RelationalOperator'
     *  RelationalOperator: '<S2869>/RelationalOperator1'
     *  RelationalOperator: '<S2869>/RelationalOperator2'
     *  RelationalOperator: '<S2869>/RelationalOperator3'
     *  RelationalOperator: '<S3014>/RelationalOperator'
     *  RelationalOperator: '<S3015>/RelationalOperator'
     *  RelationalOperator: '<S3016>/RelationalOperator'
     *  RelationalOperator: '<S3017>/RelationalOperator'
     *  S-Function (sfix_bitop): '<S3015>/BitwiseOperator7'
     *  S-Function (sfix_bitop): '<S3017>/BitwiseOperator7'
     *  Switch: '<S3945>/Switch'
     */
    rtb_RelationalOperator_nw = (((((((((CeSSDR_e_KeyCrank == ((uint32)
        VeTHMR_e_SSDR_KeySts)) || (((uint32)VeTHMR_e_SSDR_KeySts) ==
        CeSSDR_e_KeyPostCrnk)) || rtb_TmpSignalConversionAtPropSy) ||
        rtb_TmpSignalConversionAtVeTM_o) || ((CeTMIR_e_SNA_AftRunRequest !=
        ((uint32)rtb_RelationalOperator_kg_tmp)) && (((uint32)
        rtb_RelationalOperator_kg_tmp) != CeTMIR_e_No_AftRunRequest))) ||
        ((rtb_Logical1_du_tmp > 0) && ((((sint32)
        THMR_ac_DW.StatusByte_MtrElect_CoolPumAOvr) & 2) > 0))) || (((((sint32)
        THMR_ac_DW.StatusByte_MtrElect_CooPumBOvrS) & 2) > 0) &&
        (rtb_Logical1_b3_tmp > 0))) || rtb_RelationalOperator_nw) ||
        (KeTHMR_b_IDCM_BsdFlwTgt_Dsbl));

    /* Switch: '<S2866>/Switch2' incorporates:
     *  Switch: '<S2866>/Switch3'
     */
    if (rtb_RelationalOperator_nw)
    {
        /* Switch: '<S2866>/Switch1' incorporates:
         *  Constant: '<S2930>/Constant'
         *  RelationalOperator: '<S2866>/RelationalOperator'
         *  Switch: '<S3948>/Switch'
         */
        if (((uint32)VeTHMR_e_EngStartStopSt_AD) != CeESSR_e_EngOff)
        {
            /* Switch: '<S2864>/Switch3' incorporates:
             *  Constant: '<S2872>/Calib'
             */
            if (KeTHMR_b_GEN_UseTorqCmnd)
            {
                rtb_Switch10 = rtb_Selector2_o[2];
            }
            else
            {
                rtb_Switch10 = rtb_Selector3[2];
            }

            /* End of Switch: '<S2864>/Switch3' */

            /* Selector: '<S2864>/Selector2' incorporates:
             *  Constant: '<S2870>/Calib'
             */
            rtb_TmpSignalConversionAtVeT_gg =
                rtb_Selector4_n[KaTHMR_i_RearFrontGEN_HeatFlwTgt[2]];

            /* Lookup_n-D: '<S2879>/Vector' incorporates:
             *  Selector: '<S2864>/Selector2'
             */
            rtb_TmpSignalConversionAtVeTM_n = look2_iflf_binlcapw(rtb_Switch10,
                rtb_TmpSignalConversionAtVeT_gg, ((const float32 *)
                &(KxTHMR_dQ_GEN_ActHeat[0])), ((const float32 *)
                &(KyTHMR_dQ_GEN_ActHeat[0])), ((const float32 *)
                &(KtTHMR_dQ_GEN_ActHeat[0])), THMR_ac_ConstP.pooled35, 11U);

            /* Lookup_n-D: '<S2880>/Vector' */
            rtb_TmpSignalConversionAtVeT_gg = look1_iflf_binlcapw
                (rtb_TmpSignalConversionAtVeT_gg, ((const float32 *)
                  &(KxTHMR_dQ_GEN_MaxHeat[0])), ((const float32 *)
                  &(KtTHMR_dQ_GEN_MaxHeat[0])), 10U);

            /* Outputs for Atomic SubSystem: '<S2864>/ProtectedDivision2' */
            /* Switch: '<S2891>/Switch1' incorporates:
             *  Constant: '<S2891>/ConstantValue'
             *  Constant: '<S2891>/ConstantValue1'
             *  Constant: '<S2891>/ConstantValue2'
             *  Constant: '<S2891>/ConstantValue3'
             *  Logic: '<S2891>/AND'
             *  RelationalOperator: '<S2891>/GreaterThanorEqual'
             *  RelationalOperator: '<S2891>/GreaterThanorEqual1'
             *  RelationalOperator: '<S2891>/NotEqual'
             *  RelationalOperator: '<S2891>/NotEqual1'
             *  Switch: '<S2891>/Switch2'
             *  Switch: '<S2891>/Switch3'
             */
            if ((rtb_TmpSignalConversionAtVeTM_n != 0.0F) &&
                    (rtb_TmpSignalConversionAtVeT_gg != 0.0F))
            {
                /* Switch: '<S2891>/Switch1' incorporates:
                 *  Product: '<S2891>/Division'
                 */
                rtb_TmpSignalConversionAtVeTM_n /=
                    rtb_TmpSignalConversionAtVeT_gg;
            }
            else if (rtb_TmpSignalConversionAtVeTM_n > 0.0F)
            {
                /* Switch: '<S2891>/Switch2' incorporates:
                 *  Constant: '<S2891>/MAXFLOAT'
                 *  Switch: '<S2891>/Switch1'
                 */
                rtb_TmpSignalConversionAtVeTM_n = 3.402823466E+38F;
            }
            else if (rtb_TmpSignalConversionAtVeTM_n < 0.0F)
            {
                /* Switch: '<S2891>/Switch3' incorporates:
                 *  Constant: '<S2891>/MINFLOAT'
                 *  Switch: '<S2891>/Switch1'
                 *  Switch: '<S2891>/Switch2'
                 */
                rtb_TmpSignalConversionAtVeTM_n = -3.402823466E+38F;
            }
            else
            {
                /* Switch: '<S2891>/Switch1' incorporates:
                 *  Constant: '<S2891>/ConstantValue4'
                 *  Switch: '<S2891>/Switch2'
                 *  Switch: '<S2891>/Switch3'
                 */
                rtb_TmpSignalConversionAtVeTM_n = 0.0F;
            }

            /* End of Switch: '<S2891>/Switch1' */
            /* End of Outputs for SubSystem: '<S2864>/ProtectedDivision2' */

            /* SignalConversion generated from: '<S3007>/Selector1' incorporates:
             *  Lookup_n-D: '<S2885>/Vector'
             *  Lookup_n-D: '<S2886>/Vector'
             *  MinMax: '<S2864>/MinMax2'
             *  Product: '<S2864>/Product2'
             *  Switch: '<S2866>/Switch1'
             *  Switch: '<S2866>/Switch2'
             *  VariantMerge generated from: '<S2805>/VariantSource'
             */
            rtb_TmpSignalConversionAtSelect[3] = fmaxf
                (rtb_TmpSignalConversionAtVeTM_n * look1_iflf_binlcapw
                 (rtb_VariantMerge_For_Variant_So, ((const float32 *)
                   &(KxTHMR_dV_GEN_FlwTgt[0])), ((const float32 *)
                   &(KtTHMR_dV_GEN_FlwTgt[0])), 6U), look1_iflf_binlcapw
                 (rtb_VariantMerge_For_Variant_So, ((const float32 *)
                   &(KxTHMR_dV_GEN_MinFlw[0])), ((const float32 *)
                   &(KtTHMR_dV_GEN_MinFlw[0])), 6U));
        }
        else
        {
            /* SignalConversion generated from: '<S3007>/Selector1' incorporates:
             *  Constant: '<S2866>/ConstantValue'
             *  Switch: '<S2866>/Switch1'
             *  Switch: '<S2866>/Switch2'
             */
            rtb_TmpSignalConversionAtSelect[3] = 0.0F;
        }

        /* End of Switch: '<S2866>/Switch1' */

        /* Switch: '<S2866>/Switch4' incorporates:
         *  Constant: '<S2929>/Constant'
         *  Constant: '<S2931>/Calib'
         *  Logic: '<S2866>/LogicalOperator'
         *  RelationalOperator: '<S2866>/RelationalOperator'
         *  RelationalOperator: '<S2866>/RelationalOperator1'
         *  Switch: '<S3948>/Switch'
         */
        if ((((uint32)VeTHMR_e_EngStartStopSt_AD) != CeESSR_e_EngOff) ||
                (KeTHMR_b_GEN_PIM_EngOff_Ovrd))
        {
            /* SignalConversion generated from: '<S3007>/Selector1' incorporates:
             *  Lookup_n-D: '<S2935>/Vector'
             *  Switch: '<S2866>/Switch3'
             *  Switch: '<S2866>/Switch4'
             *  VariantMerge generated from: '<S2805>/VariantSource'
             */
            rtb_TmpSignalConversionAtSelect[4] = look1_iflf_binlcapw
                (rtb_VariantMerge_For_Variant_So, ((const float32 *)
                  &(KxTHMR_dV_GEN_PIM_FlwTgt[0])), ((const float32 *)
                  &(KtTHMR_dV_GEN_PIM_FlwTgt[0])), 10U);
        }
        else
        {
            /* SignalConversion generated from: '<S3007>/Selector1' incorporates:
             *  Constant: '<S2866>/ConstantValue3'
             *  Switch: '<S2866>/Switch3'
             *  Switch: '<S2866>/Switch4'
             */
            rtb_TmpSignalConversionAtSelect[4] = 0.0F;
        }

        /* End of Switch: '<S2866>/Switch4' */
    }
    else
    {
        /* SignalConversion generated from: '<S3007>/Selector1' incorporates:
         *  Constant: '<S2866>/ConstantValue1'
         *  Constant: '<S2866>/ConstantValue2'
         *  Switch: '<S2866>/Switch2'
         *  Switch: '<S2866>/Switch3'
         */
        rtb_TmpSignalConversionAtSelect[3] = 0.0F;
        rtb_TmpSignalConversionAtSelect[4] = 0.0F;
    }

    /* End of Switch: '<S2866>/Switch2' */

    /* Switch: '<S2864>/Switch1' incorporates:
     *  Constant: '<S2871>/Calib'
     */
    if (KeTHMR_b_FrontEDM_UseTorqCmnd)
    {
        /* Switch: '<S2864>/Switch1' */
        rtb_Add4_m1 = rtb_Selector2_o[1];
    }
    else
    {
        /* Switch: '<S2864>/Switch1' */
        rtb_Add4_m1 = rtb_Selector3[1];
    }

    /* End of Switch: '<S2864>/Switch1' */

    /* Selector: '<S2864>/Selector2' incorporates:
     *  Constant: '<S2870>/Calib'
     */
    rtb_TmpSignalConversionAtVeTM_n =
        rtb_Selector4_n[KaTHMR_i_RearFrontGEN_HeatFlwTgt[1]];

    /* Lookup_n-D: '<S2877>/Vector' incorporates:
     *  Selector: '<S2864>/Selector2'
     *  Switch: '<S2864>/Switch1'
     */
    rtb_TmpSignalConversionAtVeT_gg = look2_iflf_binlcapw(rtb_Add4_m1,
        rtb_TmpSignalConversionAtVeTM_n, ((const float32 *)
        &(KxTHMR_dQ_FrontEDM_ActHeat[0])), ((const float32 *)
        &(KyTHMR_dQ_FrontEDM_ActHeat[0])), ((const float32 *)
        &(KtTHMR_dQ_FrontEDM_ActHeat[0])), THMR_ac_ConstP.pooled35, 11U);

    /* Lookup_n-D: '<S2878>/Vector' */
    rtb_Switch1_muc = look1_iflf_binlcapw(rtb_TmpSignalConversionAtVeTM_n, ((
        const float32 *)&(KxTHMR_dQ_FrontEDM_MaxHeat[0])), ((const float32 *)
        &(KtTHMR_dQ_FrontEDM_MaxHeat[0])), 10U);

    /* Outputs for Atomic SubSystem: '<S2864>/ProtectedDivision1' */
    /* Switch: '<S2890>/Switch1' incorporates:
     *  Constant: '<S2890>/ConstantValue'
     *  Constant: '<S2890>/ConstantValue1'
     *  Constant: '<S2890>/ConstantValue2'
     *  Constant: '<S2890>/ConstantValue3'
     *  Logic: '<S2890>/AND'
     *  RelationalOperator: '<S2890>/GreaterThanorEqual'
     *  RelationalOperator: '<S2890>/GreaterThanorEqual1'
     *  RelationalOperator: '<S2890>/NotEqual'
     *  RelationalOperator: '<S2890>/NotEqual1'
     *  Switch: '<S2890>/Switch2'
     *  Switch: '<S2890>/Switch3'
     */
    if ((rtb_TmpSignalConversionAtVeT_gg != 0.0F) && (rtb_Switch1_muc != 0.0F))
    {
        /* Switch: '<S2890>/Switch1' incorporates:
         *  Product: '<S2890>/Division'
         */
        rtb_TmpSignalConversionAtVeT_gg /= rtb_Switch1_muc;
    }
    else if (rtb_TmpSignalConversionAtVeT_gg > 0.0F)
    {
        /* Switch: '<S2890>/Switch2' incorporates:
         *  Constant: '<S2890>/MAXFLOAT'
         *  Switch: '<S2890>/Switch1'
         */
        rtb_TmpSignalConversionAtVeT_gg = 3.402823466E+38F;
    }
    else if (rtb_TmpSignalConversionAtVeT_gg < 0.0F)
    {
        /* Switch: '<S2890>/Switch3' incorporates:
         *  Constant: '<S2890>/MINFLOAT'
         *  Switch: '<S2890>/Switch1'
         *  Switch: '<S2890>/Switch2'
         */
        rtb_TmpSignalConversionAtVeT_gg = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2890>/Switch1' incorporates:
         *  Constant: '<S2890>/ConstantValue4'
         *  Switch: '<S2890>/Switch2'
         *  Switch: '<S2890>/Switch3'
         */
        rtb_TmpSignalConversionAtVeT_gg = 0.0F;
    }

    /* End of Switch: '<S2890>/Switch1' */
    /* End of Outputs for SubSystem: '<S2864>/ProtectedDivision1' */

    /* MinMax: '<S2864>/MinMax1' incorporates:
     *  Lookup_n-D: '<S2883>/Vector'
     *  Lookup_n-D: '<S2884>/Vector'
     *  Product: '<S2864>/Product1'
     *  VariantMerge generated from: '<S2805>/VariantSource'
     */
    rtb_Switch1_muc = fmaxf(rtb_TmpSignalConversionAtVeT_gg *
                            look1_iflf_binlcapw(rtb_VariantMerge_For_Variant_So,
        ((const float32 *)&(KxTHMR_dV_FrontEDM_FlwTgt[0])), ((const float32 *)
        &(KtTHMR_dV_FrontEDM_FlwTgt[0])), 6U), look1_iflf_binlcapw
                            (rtb_VariantMerge_For_Variant_So, ((const float32 *)
        &(KxTHMR_dV_FrontEDM_MinFlw[0])), ((const float32 *)
        &(KtTHMR_dV_FrontEDM_MinFlw[0])), 6U));

    /* Switch: '<S2864>/Switch2' incorporates:
     *  Constant: '<S2876>/Calib'
     */
    if (KeTHMR_b_RearEDM_UseTorqCmnd)
    {
        /* Switch: '<S2864>/Switch2' */
        rtb_TmpSignalConversionAtVeT_gg = rtb_Selector2_o[0];
    }
    else
    {
        /* Switch: '<S2864>/Switch2' */
        rtb_TmpSignalConversionAtVeT_gg = rtb_Selector3[0];
    }

    /* End of Switch: '<S2864>/Switch2' */

    /* Selector: '<S2864>/Selector2' incorporates:
     *  Constant: '<S2870>/Calib'
     */
    rtb_TmpSignalConversionAtVeTM_n =
        rtb_Selector4_n[KaTHMR_i_RearFrontGEN_HeatFlwTgt[0]];

    /* Lookup_n-D: '<S2881>/Vector' incorporates:
     *  Selector: '<S2864>/Selector2'
     *  Switch: '<S2864>/Switch2'
     */
    rtb_Product_gg = look2_iflf_binlcapw(rtb_TmpSignalConversionAtVeT_gg,
        rtb_TmpSignalConversionAtVeTM_n, ((const float32 *)
        &(KxTHMR_dQ_RearEDM_ActHeat[0])), ((const float32 *)
        &(KyTHMR_dQ_RearEDM_ActHeat[0])), ((const float32 *)
        &(KtTHMR_dQ_RearEDM_ActHeat[0])), THMR_ac_ConstP.pooled35, 11U);

    /* Lookup_n-D: '<S2882>/Vector' */
    rtb_Switch1_i3 = look1_iflf_binlcapw(rtb_TmpSignalConversionAtVeTM_n, ((
        const float32 *)&(KxTHMR_dQ_RearEDM_MaxHeat[0])), ((const float32 *)
        &(KtTHMR_dQ_RearEDM_MaxHeat[0])), 10U);

    /* Outputs for Atomic SubSystem: '<S2864>/ProtectedDivision' */
    /* Switch: '<S2889>/Switch1' incorporates:
     *  Constant: '<S2889>/ConstantValue'
     *  Constant: '<S2889>/ConstantValue1'
     *  Constant: '<S2889>/ConstantValue2'
     *  Constant: '<S2889>/ConstantValue3'
     *  Logic: '<S2889>/AND'
     *  RelationalOperator: '<S2889>/GreaterThanorEqual'
     *  RelationalOperator: '<S2889>/GreaterThanorEqual1'
     *  RelationalOperator: '<S2889>/NotEqual'
     *  RelationalOperator: '<S2889>/NotEqual1'
     *  Switch: '<S2889>/Switch2'
     *  Switch: '<S2889>/Switch3'
     */
    if ((rtb_Product_gg != 0.0F) && (rtb_Switch1_i3 != 0.0F))
    {
        /* Switch: '<S2889>/Switch1' incorporates:
         *  Product: '<S2889>/Division'
         */
        rtb_Product_gg /= rtb_Switch1_i3;
    }
    else if (rtb_Product_gg > 0.0F)
    {
        /* Switch: '<S2889>/Switch2' incorporates:
         *  Constant: '<S2889>/MAXFLOAT'
         *  Switch: '<S2889>/Switch1'
         */
        rtb_Product_gg = 3.402823466E+38F;
    }
    else if (rtb_Product_gg < 0.0F)
    {
        /* Switch: '<S2889>/Switch3' incorporates:
         *  Constant: '<S2889>/MINFLOAT'
         *  Switch: '<S2889>/Switch1'
         *  Switch: '<S2889>/Switch2'
         */
        rtb_Product_gg = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2889>/Switch1' incorporates:
         *  Constant: '<S2889>/ConstantValue4'
         *  Switch: '<S2889>/Switch2'
         *  Switch: '<S2889>/Switch3'
         */
        rtb_Product_gg = 0.0F;
    }

    /* End of Switch: '<S2889>/Switch1' */
    /* End of Outputs for SubSystem: '<S2864>/ProtectedDivision' */

    /* MinMax: '<S2864>/MinMax' incorporates:
     *  Lookup_n-D: '<S2887>/Vector'
     *  Lookup_n-D: '<S2888>/Vector'
     *  Product: '<S2864>/Product'
     *  VariantMerge generated from: '<S2805>/VariantSource'
     */
    rtb_Product_gg = fmaxf(rtb_Product_gg * look1_iflf_binlcapw
                           (rtb_VariantMerge_For_Variant_So, ((const float32 *)
        &(KxTHMR_dV_RearEDM_FlwTgt[0])), ((const float32 *)
        &(KtTHMR_dV_RearEDM_FlwTgt[0])), 6U), look1_iflf_binlcapw
                           (rtb_VariantMerge_For_Variant_So, ((const float32 *)
        &(KxTHMR_dV_RearEDM_MinFlw[0])), ((const float32 *)
        &(KtTHMR_dV_RearEDM_MinFlw[0])), 6U));

    /* RelationalOperator: '<S2925>/RelationalOperator2' incorporates:
     *  RelationalOperator: '<S2925>/RelationalOperator3'
     *  Switch: '<S2948>/Switch1'
     */
    tmpRead_v = THMR_ac_B.Output_AHH_Ready_Status;

    /* Switch: '<S2948>/Switch1' incorporates:
     *  Constant: '<S2946>/Constant'
     *  Constant: '<S2947>/Constant'
     *  Constant: '<S2952>/Calib'
     *  Logic: '<S2925>/LogicalOperator'
     *  RelationalOperator: '<S2925>/RelationalOperator1'
     *  RelationalOperator: '<S2925>/RelationalOperator2'
     *  RelationalOperator: '<S2925>/RelationalOperator3'
     *  Switch: '<S2949>/Switch1'
     */
    if ((THMR_ac_B.Output_AHH_SF >= KeTHMR_r_AHH_StresFact_Min) && (((uint32)
            tmpRead_v) != CeBRKR_e_AHH_Active))
    {
        /* Switch: '<S2948>/Switch1' incorporates:
         *  Lookup_n-D: '<S2953>/Vector'
         *  Lookup_n-D: '<S2954>/Vector'
         *  MinMax: '<S2925>/MinMax'
         *  MinMax: '<S2925>/MinMax1'
         */
        rtb_Switch1_pn[0] = fmaxf(look1_iflf_binlcapw(THMR_ac_B.Output_AHH_SF,
            ((const float32 *)&(KxTHMR_dV_AHH_LT_FrontEDM_FlwTgt[0])), ((const
            float32 *)&(KtTHMR_dV_AHH_LT_FrontEDM_FlwTgt[0])), 6U),
            rtb_Switch1_muc);
        rtb_Switch1_pn[1] = fmaxf(look1_iflf_binlcapw(THMR_ac_B.Output_AHH_SF,
            ((const float32 *)&(KxTHMR_dV_AHH_LT_RearEDM_FlwTgt[0])), ((const
            float32 *)&(KtTHMR_dV_AHH_LT_RearEDM_FlwTgt[0])), 10U),
            rtb_Product_gg);
    }
    else if (((uint32)tmpRead_v) == CeBRKR_e_AHH_Active)
    {
        /* Switch: '<S2948>/Switch1' incorporates:
         *  Constant: '<S2950>/Calib'
         *  Constant: '<S2951>/Calib'
         *  MinMax: '<S2925>/MinMax2'
         *  MinMax: '<S2925>/MinMax3'
         *  Switch: '<S2949>/Switch1'
         */
        rtb_Switch1_pn[0] = fmaxf(KeTHMR_dV_LT_FrontEDM_AHH_Actv,
            rtb_Switch1_muc);
        rtb_Switch1_pn[1] = fmaxf(KeTHMR_dV_LT_RearEDM_AHH_Actv, rtb_Product_gg);
    }
    else
    {
        /* Switch: '<S2948>/Switch1' incorporates:
         *  Switch: '<S2949>/Switch1'
         */
        rtb_Switch1_pn[0] = rtb_Switch1_muc;
        rtb_Switch1_pn[1] = rtb_Product_gg;
    }

    /* Lookup_n-D: '<S2932>/Vector' incorporates:
     *  VariantMerge generated from: '<S2805>/VariantSource'
     */
    VeTHMR_dV_LT_APM_Flw_Rq = look1_iflf_binlcapw
        (rtb_VariantMerge_For_Variant_So, ((const float32 *)
          &(KxTHMR_dV_APM_ClntFlw[0])), ((const float32 *)
          &(KtTHMR_dV_APM_ClntFlw[0])), 6U);

    /* Switch: '<S2864>/Switch4' incorporates:
     *  Constant: '<S2875>/Calib'
     */
    if (KeTHMR_b_RearEDM_FrontEDM_UseOilTemp)
    {
        /* Switch: '<S2864>/Switch4' */
        rtb_Switch1_muc = VeTHMR_T_PumpOilTemp;
    }
    else
    {
        /* Switch: '<S2864>/Switch4' */
        rtb_Switch1_muc = VeTHMR_T_Pump2OilTemp;
    }

    /* End of Switch: '<S2864>/Switch4' */

    /* Switch: '<S2866>/Switch7' incorporates:
     *  Switch: '<S2866>/Switch10'
     *  Switch: '<S2866>/Switch11'
     *  Switch: '<S2866>/Switch8'
     *  Switch: '<S2866>/Switch9'
     */
    if (rtb_RelationalOperator_nw)
    {
        /* SignalConversion generated from: '<S3007>/Selector1' incorporates:
         *  Lookup_n-D: '<S2942>/Vector'
         *  Lookup_n-D: '<S2944>/Vector'
         *  Switch: '<S2864>/Switch4'
         *  Switch: '<S2864>/Switch5'
         *  Switch: '<S2866>/Switch7'
         *  Switch: '<S2866>/Switch8'
         *  VariantMerge generated from: '<S2805>/VariantSource'
         */
        rtb_TmpSignalConversionAtSelect[10] = look2_iflf_binlcapw
            (rtb_VariantMerge_For_Variant_So, rtb_Switch1_muc, ((const float32 *)
              &(KxTHMR_dV_TransOilCooler_ClntFlw_Rear_EDM[0])), ((const float32 *)
              &(KyTHMR_dV_TransOilCooler_ClntFlw_Rear_EDM[0])), ((const float32 *)
              &(KtTHMR_dV_TransOilCooler_ClntFlw_Rear_EDM[0])),
             THMR_ac_ConstP.pooled36, 8U);
        rtb_TmpSignalConversionAtSelect[11] = look2_iflf_binlcapw
            (rtb_VariantMerge_For_Variant_So, rtb_TmpSignalConversionAtVeFSCR,
             ((const float32 *)&(KxTHMR_dV_TransOilCooler_ClntFlw_Front_EDM[0])),
             ((const float32 *)&(KyTHMR_dV_TransOilCooler_ClntFlw_Front_EDM[0])),
             ((const float32 *)&(KtTHMR_dV_TransOilCooler_ClntFlw_Front_EDM[0])),
             THMR_ac_ConstP.pooled36, 8U);

        /* Switch: '<S2864>/Switch6' incorporates:
         *  Constant: '<S2873>/Calib'
         *  Constant: '<S2874>/Calib'
         *  Switch: '<S2864>/Switch7'
         */
        if (KeTHMR_b_MtrA_TempUse)
        {
            rtb_Switch10 = VeTHMR_T_MtrA_Temp;
        }
        else if (KeTHMR_b_MtrBorC_TempUse)
        {
            /* Switch: '<S2864>/Switch7' */
            rtb_Switch10 = VeTHMR_T_MtrB_Temp;
        }
        else
        {
            rtb_Switch10 = VeTHMR_T_MtrC_Temp;
        }

        /* End of Switch: '<S2864>/Switch6' */

        /* SignalConversion generated from: '<S3007>/Selector1' incorporates:
         *  Lookup_n-D: '<S2940>/Vector'
         *  Lookup_n-D: '<S2941>/Vector'
         *  Lookup_n-D: '<S2943>/Vector'
         *  Switch: '<S2866>/Switch10'
         *  Switch: '<S2866>/Switch11'
         *  Switch: '<S2866>/Switch9'
         *  VariantMerge generated from: '<S2805>/VariantSource'
         */
        rtb_TmpSignalConversionAtSelect[12] = look2_iflf_binlcapw
            (rtb_VariantMerge_For_Variant_So, rtb_Switch10, ((const float32 *)
              &(KxTHMR_dV_TransOilCooler_ClntFlw_GEN[0])), ((const float32 *)
              &(KyTHMR_dV_TransOilCooler_ClntFlw_GEN[0])), ((const float32 *)
              &(KtTHMR_dV_TransOilCooler_ClntFlw_GEN[0])),
             THMR_ac_ConstP.pooled36, 8U);
        rtb_TmpSignalConversionAtSelect[13] = look1_iflf_binlcapw
            (rtb_VariantMerge_For_Variant_So, ((const float32 *)
              &(KxTHMR_dV_PIM_Front_ClntFlw[0])), ((const float32 *)
              &(KtTHMR_dV_PIM_Front_ClntFlw[0])), 8U);
        rtb_TmpSignalConversionAtSelect[14] = look1_iflf_binlcapw
            (rtb_VariantMerge_For_Variant_So, ((const float32 *)
              &(KxTHMR_dV_PIM_Rear_ClntFlw[0])), ((const float32 *)
              &(KtTHMR_dV_PIM_Rear_ClntFlw[0])), 8U);
    }
    else
    {
        /* SignalConversion generated from: '<S3007>/Selector1' incorporates:
         *  Constant: '<S2866>/ConstantValue10'
         *  Constant: '<S2866>/ConstantValue6'
         *  Constant: '<S2866>/ConstantValue7'
         *  Constant: '<S2866>/ConstantValue8'
         *  Constant: '<S2866>/ConstantValue9'
         *  Switch: '<S2866>/Switch10'
         *  Switch: '<S2866>/Switch11'
         *  Switch: '<S2866>/Switch7'
         *  Switch: '<S2866>/Switch8'
         *  Switch: '<S2866>/Switch9'
         */
        rtb_TmpSignalConversionAtSelect[10] = 0.0F;
        rtb_TmpSignalConversionAtSelect[11] = 0.0F;
        rtb_TmpSignalConversionAtSelect[12] = 0.0F;
        rtb_TmpSignalConversionAtSelect[13] = 0.0F;
        rtb_TmpSignalConversionAtSelect[14] = 0.0F;
    }

    /* End of Switch: '<S2866>/Switch7' */

    /* Merge: '<S2928>/Merge8' incorporates:
     *  Lookup_n-D: '<S2934>/Vector'
     *  VariantMerge generated from: '<S2805>/VariantSource'
     */
    rtb_Merge8 = look1_iflf_binlcapw(rtb_VariantMerge_For_Variant_So, ((const
        float32 *)&(KxTHMR_dV_DCDC_ClntFlw[0])), ((const float32 *)
        &(KtTHMR_dV_DCDC_ClntFlw[0])), 8U);

    /* Switch: '<S2464>/Switch1' incorporates:
     *  Lookup_n-D: '<S2933>/Vector'
     *  VariantMerge generated from: '<S2805>/VariantSource'
     */
    rtb_Switch1_i3 = look1_iflf_binlcapw(rtb_VariantMerge_For_Variant_So, ((
        const float32 *)&(KxTHMR_dV_DCBC_ClntFlw[0])), ((const float32 *)
        &(KtTHMR_dV_DCBC_ClntFlw[0])), 8U);

    /* SignalConversion generated from: '<S3007>/Selector1' incorporates:
     *  Constant: '<S2945>/ConstantValue'
     *  Lookup_n-D: '<S2936>/Vector'
     *  Switch: '<S302>/Switch1'
     */
    rtb_TmpSignalConversionAtSelect[0] = 0.0F;
    rtb_TmpSignalConversionAtSelect[1] = look1_iflf_binlcapw
        (VeTHMR_p_HghRfrgtPres_Arb, ((const float32 *)
          &(KxTHMR_dV_HeadPres_LTPsvPmpFlw[0])), ((const float32 *)
          &(KtTHMR_dV_HeadPres_LTPsvPmpFlw[0])), 6U);
    rtb_TmpSignalConversionAtSelect[2] = VeTHMR_dV_ECM_LTPsvPmpFlw;

    /* Switch: '<S2866>/Switch5' incorporates:
     *  Switch: '<S2866>/Switch6'
     */
    if (rtb_RelationalOperator_nw)
    {
        /* SignalConversion generated from: '<S3007>/Selector1' */
        rtb_TmpSignalConversionAtSelect[5] = rtb_Switch1_pn[0];
        rtb_TmpSignalConversionAtSelect[6] = rtb_Switch1_pn[1];
    }
    else
    {
        /* SignalConversion generated from: '<S3007>/Selector1' incorporates:
         *  Constant: '<S2866>/ConstantValue4'
         *  Constant: '<S2866>/ConstantValue5'
         */
        rtb_TmpSignalConversionAtSelect[5] = 0.0F;
        rtb_TmpSignalConversionAtSelect[6] = 0.0F;
    }

    /* End of Switch: '<S2866>/Switch5' */

    /* SignalConversion generated from: '<S3007>/Selector1' incorporates:
     *  Lookup_n-D: '<S2937>/Vector'
     *  Lookup_n-D: '<S2938>/Vector'
     *  Lookup_n-D: '<S2939>/Vector'
     *  VariantMerge generated from: '<S2805>/VariantSource'
     */
    rtb_TmpSignalConversionAtSelect[7] = look1_iflf_binlcapw
        (rtb_VariantMerge_For_Variant_So, ((const float32 *)
          &(KxTHMR_dV_IDCM_FlwTgt[0])), ((const float32 *)
          &(KtTHMR_dV_IDCM_FlwTgt[0])), 8U);
    rtb_TmpSignalConversionAtSelect[8] = look1_iflf_binlcapw
        (rtb_VariantMerge_For_Variant_So, ((const float32 *)
          &(KxTHMR_dV_OBCM_ClntFlw[0])), ((const float32 *)
          &(KtTHMR_dV_OBCM_ClntFlw[0])), 8U);
    rtb_TmpSignalConversionAtSelect[9] = VeTHMR_dV_LT_APM_Flw_Rq;
    rtb_TmpSignalConversionAtSelect[15] = rtb_Merge8;
    rtb_TmpSignalConversionAtSelect[16] = look1_iflf_binlcapw
        (rtb_VariantMerge_For_Variant_So, ((const float32 *)
          &(KxTHMR_dV_PCU_ClntFlw[0])), ((const float32 *)
          &(KtTHMR_dV_PCU_ClntFlw[0])), 8U);
    rtb_TmpSignalConversionAtSelect[17] = VeTHMR_dV_LTAPFlwReq_Mod_1;
    rtb_TmpSignalConversionAtSelect[18] = rtb_Switch1_i3;

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Switch: '<S2926>/Switch' incorporates:
     *  Constant: '<S2955>/Constant1'
     *  Constant: '<S2955>/Constant2'
     *  Constant: '<S2956>/Constant1'
     *  Constant: '<S2956>/Constant2'
     *  Constant: '<S2957>/Calib'
     *  Constant: '<S2958>/Calib'
     *  DataStoreRead: '<S2955>/StatusByte_BattCoolPmpPerf'
     *  DataStoreRead: '<S2956>/StatusByte_LostCommHB_CoolPmp'
     *  Logic: '<S2926>/Logical20'
     *  Logic: '<S2926>/Logical3'
     *  Logic: '<S2926>/Logical5'
     *  Logic: '<S2955>/Logical Operator'
     *  Logic: '<S2956>/Logical Operator'
     *  RelationalOperator: '<S2955>/Relational Operator1'
     *  RelationalOperator: '<S2955>/Relational Operator2'
     *  RelationalOperator: '<S2956>/Relational Operator1'
     *  RelationalOperator: '<S2956>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S2955>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2955>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S2956>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S2956>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S4525>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4525>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S4601>/BitwiseOperator1'
     */
    rtb_AND_bp_tmp = ((uint32)THMR_ac_DW.StatusByte_LostCommHB_CoolPmp) & 1U;
    rtb_AND_bp_tmp_0 = ((uint32)THMR_ac_DW.StatusByte_LostCommHB_CoolPmp) & 64U;
    if (((((((uint32)THMR_ac_DW.StatusByte_BattCoolPmpPerf) & 1U) != 0U) &&
            ((((uint32)THMR_ac_DW.StatusByte_BattCoolPmpPerf) & 64U) == 0U)) &&
            (KeTHMR_b_LTAPPerfFlt_EnblRA_LTCLflow)) || (((rtb_AND_bp_tmp != 0U) &&
          (rtb_AND_bp_tmp_0 == 0U)) && (KeTHMR_b_Enbl_LTAPLOC_EnblRA_LTCLflow)))
    {
        /* SignalConversion generated from: '<S3007>/Selector1' incorporates:
         *  Constant: '<S2959>/Calib'
         */
        rtb_TmpSignalConversionAtSelect[19] = KeTHMR_dV_LTCLflow4LTAPFaults;
    }
    else
    {
        /* SignalConversion generated from: '<S3007>/Selector1' incorporates:
         *  Constant: '<S2926>/Constant1'
         */
        rtb_TmpSignalConversionAtSelect[19] = 0.0F;
    }

    /* End of Switch: '<S2926>/Switch' */
    for (i = 0; i < 19; i++)
    {
        /* Product: '<S3007>/Product' incorporates:
         *  Constant: '<S3003>/Calib'
         *  Constant: '<S3004>/Calib'
         */
        rtb_Product_atp[i] = (uint16)(((uint32)KaTHMR_i_Branch1Map[(i)]) *
            ((uint32)CeTHMR_i_FlowReqBrnchSel[(i)]));
    }

    /* MinMax: '<S2945>/MinMax' incorporates:
     *  Selector: '<S3007>/Selector1'
     */
    rtb_Product_gg = rtb_TmpSignalConversionAtSelect[rtb_Product_atp[0]];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 18;
            rtb_DataTypeConversion2++)
    {
        rtb_Product_gg = fmaxf(rtb_Product_gg,
                               rtb_TmpSignalConversionAtSelect[rtb_Product_atp[rtb_DataTypeConversion2
                               + 1]]);
    }

    /* Logic: '<S2857>/Logical6' incorporates:
     *  Constant: '<S2963>/Constant'
     *  Constant: '<S2964>/Constant'
     *  Constant: '<S2984>/Calib'
     *  DataTypeConversion: '<S3621>/DataTypeConversion'
     *  Logic: '<S2928>/Logical Operator'
     *  RelationalOperator: '<S2928>/Relational Operator'
     *  RelationalOperator: '<S2928>/Relational Operator1'
     */
    rtb_Logical6_fk = (((((uint32)VeTHMR_e_HCP_LTP_FanAftRun_Rq_BD_SF) !=
                         CeTMIR_e_No_AftRunRequest) && (((uint32)
                          VeTHMR_e_HCP_LTP_FanAftRun_Rq_BD_SF) !=
                         CeTMIR_e_SNA_AftRunRequest)) &&
                       (KeTHMR_b_AftrRunPmpFlowOvrdEnbl));

    /* If: '<S2928>/If2' */
    if (rtb_Logical6_fk)
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct4' incorporates:
         *  ActionPort: '<S2978>/Action Port'
         */
        /* Switch: '<S2464>/Switch1' incorporates:
         *  Constant: '<S3000>/Calib'
         *  SignalConversion generated from: '<S2978>/Out1'
         */
        rtb_Switch1_i3 = KeTHMR_dV_FanAftrRun_Branch1Flow;

        /* End of Outputs for SubSystem: '<S2928>/IfAct4' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct5' incorporates:
         *  ActionPort: '<S2979>/Action Port'
         */
        THMR_ac_IfAct1(&rtb_Switch1_i3);

        /* End of Outputs for SubSystem: '<S2928>/IfAct5' */
    }

    /* End of If: '<S2928>/If2' */

    /* MinMax: '<S2928>/MinMax' incorporates:
     *  MinMax: '<S2945>/MinMax'
     */
    rtb_VariantMerge_For_Variant_So = fmaxf(fmaxf(fmaxf
        (rtb_TmpSignalConversionAtVeT_fy, rtb_Merge1_i), rtb_Product_gg),
        rtb_Switch1_i3);

    /* Logic: '<S2469>/Logical5' incorporates:
     *  Constant: '<S2488>/Calib'
     *  Logic: '<S2469>/Logical4'
     */
    tmpForInput_0[0] = (rtb_TmpSignalConversionAtVeTM_j &&
                        (KaTHMR_i_ERLv1_Branch2Select[0]));
    tmpForInput_0[1] = (rtb_TmpSignalConversionAtVeT_f5 &&
                        (KaTHMR_i_ERLv1_Branch2Select[1]));
    tmpForInput_0[2] = (rtb_Logical46_fu && (KaTHMR_i_ERLv1_Branch2Select[2]));
    tmpForInput_0[3] = (rtb_Logical46_j2 && (KaTHMR_i_ERLv1_Branch2Select[3]));
    tmpForInput_0[4] = (rtb_Logical46_ov && (KaTHMR_i_ERLv1_Branch2Select[4]));
    tmpForInput_0[5] = (rtb_Logical46_cr && (KaTHMR_i_ERLv1_Branch2Select[5]));
    tmpForInput_0[6] = (Switch9_a && (KaTHMR_i_ERLv1_Branch2Select[6]));
    tmpForInput_0[7] = (rtb_Logical46_hh && (KaTHMR_i_ERLv1_Branch2Select[7]));
    tmpForInput_0[8] = (rtb_Logical17_h && (KaTHMR_i_ERLv1_Branch2Select[8]));
    tmpForInput_0[9] = (rtb_Logical1_c0 && (KaTHMR_i_ERLv1_Branch2Select[9]));
    tmpForInput_0[10] = (rtb_Logical1_li && (KaTHMR_i_ERLv1_Branch2Select[10]));
    tmpForInput_0[11] = (rtb_Logical1_gx && (KaTHMR_i_ERLv1_Branch2Select[11]));
    tmpForInput_0[12] = (rtb_Logical2_oq && (KaTHMR_i_ERLv1_Branch2Select[12]));

    /* Logic: '<S2469>/Logical7' */
    rtb_AND_fe = tmpForInput_0[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 12;
            rtb_DataTypeConversion2++)
    {
        rtb_AND_fe = (rtb_AND_fe || (tmpForInput_0[rtb_DataTypeConversion2 + 1]));
    }

    /* If: '<S2928>/If3' incorporates:
     *  Logic: '<S2469>/Logical7'
     *  Logic: '<S2928>/Logical1'
     */
    if (rtb_NotEqual_pl && rtb_AND_fe)
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct6' incorporates:
         *  ActionPort: '<S2980>/Action Port'
         */
        /* Switch: '<S2859>/Switch1' incorporates:
         *  Constant: '<S3001>/Calib'
         *  SignalConversion generated from: '<S2980>/Out1'
         */
        rtb_Product_gg = KeTHMR_dV_Branch2_Emrgcy_LV1;

        /* End of Outputs for SubSystem: '<S2928>/IfAct6' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct7' incorporates:
         *  ActionPort: '<S2981>/Action Port'
         */
        THMR_ac_IfAct1(&rtb_Product_gg);

        /* End of Outputs for SubSystem: '<S2928>/IfAct7' */
    }

    /* End of If: '<S2928>/If3' */

    /* Logic: '<S2470>/Logical11' incorporates:
     *  Constant: '<S2572>/Calib'
     *  Logic: '<S2470>/Logical10'
     */
    tmpForInput[0] = (rtb_Logical12_dt && (KaTHMR_i_ERLv2_Branch2Select[0]));
    tmpForInput[1] = (rtb_Logical12_pv && (KaTHMR_i_ERLv2_Branch2Select[1]));
    tmpForInput[2] = (rtb_Logical1_bt && (KaTHMR_i_ERLv2_Branch2Select[2]));
    tmpForInput[3] = (rtb_Logical3_oz && (KaTHMR_i_ERLv2_Branch2Select[3]));
    tmpForInput[4] = (rtb_VariantMerge_For_Variant__n &&
                      (KaTHMR_i_ERLv2_Branch2Select[4]));
    tmpForInput[5] = (rtb_TmpSignalConversionAtVePD_p &&
                      (KaTHMR_i_ERLv2_Branch2Select[5]));
    tmpForInput[6] = (rtb_TmpSignalConversionAtVePD_i &&
                      (KaTHMR_i_ERLv2_Branch2Select[6]));
    tmpForInput[7] = (rtb_AND_c3 && (KaTHMR_i_ERLv2_Branch2Select[7]));
    tmpForInput[8] = (rtb_OR1_g4 && (KaTHMR_i_ERLv2_Branch2Select[8]));
    tmpForInput[9] = (rtb_Logical18_d && (KaTHMR_i_ERLv2_Branch2Select[9]));
    tmpForInput[10] = (rtb_Logical6_or && (KaTHMR_i_ERLv2_Branch2Select[10]));
    tmpForInput[11] = (rtb_Comparison3_bu && (KaTHMR_i_ERLv2_Branch2Select[11]));
    tmpForInput[12] = (Switch5_i && (KaTHMR_i_ERLv2_Branch2Select[12]));
    tmpForInput[13] = (rtb_AND_cn && (KaTHMR_i_ERLv2_Branch2Select[13]));
    tmpForInput[14] = (rtb_Comparison4_cx && (KaTHMR_i_ERLv2_Branch2Select[14]));
    tmpForInput[15] = (rtb_TmpSignalConversionAtOutAir &&
                       (KaTHMR_i_ERLv2_Branch2Select[15]));
    tmpForInput[16] = (rtb_Comparison6_n3 && (KaTHMR_i_ERLv2_Branch2Select[16]));
    tmpForInput[17] = (rtb_Logical15_o && (KaTHMR_i_ERLv2_Branch2Select[17]));
    tmpForInput[18] = (rtb_AND_ko5 && (KaTHMR_i_ERLv2_Branch2Select[18]));
    tmpForInput[19] = (rtb_Comparison5_c3m && (KaTHMR_i_ERLv2_Branch2Select[19]));
    tmpForInput[20] = (rtb_Logical5_bn && (KaTHMR_i_ERLv2_Branch2Select[20]));
    tmpForInput[21] = (rtb_TmpSignalConversionAtVeT_d5 &&
                       (KaTHMR_i_ERLv2_Branch2Select[21]));
    tmpForInput[22] = (rtb_TmpSignalConversionAtVeT_ib &&
                       (KaTHMR_i_ERLv2_Branch2Select[22]));
    tmpForInput[23] = (rtb_AND_jo && (KaTHMR_i_ERLv2_Branch2Select[23]));
    tmpForInput[24] = (rtb_AND_eb && (KaTHMR_i_ERLv2_Branch2Select[24]));
    tmpForInput[25] = (rtb_Logical4_of && (KaTHMR_i_ERLv2_Branch2Select[25]));
    tmpForInput[26] = (rtb_Logical3_at && (KaTHMR_i_ERLv2_Branch2Select[26]));
    tmpForInput[27] = (rtb_OR1_he && (KaTHMR_i_ERLv2_Branch2Select[27]));
    tmpForInput[28] = (rtb_AND_g2 && (KaTHMR_i_ERLv2_Branch2Select[28]));
    tmpForInput[29] = (rtb_Logical12_fs && (KaTHMR_i_ERLv2_Branch2Select[29]));
    tmpForInput[30] = (rtb_Logical12_hd && (KaTHMR_i_ERLv2_Branch2Select[30]));
    tmpForInput[31] = (rtb_Logical12_gu && (KaTHMR_i_ERLv2_Branch2Select[31]));
    tmpForInput[32] = (rtb_Logical12_c2 && (KaTHMR_i_ERLv2_Branch2Select[32]));
    tmpForInput[33] = (rtb_Logical12_gap && (KaTHMR_i_ERLv2_Branch2Select[33]));
    tmpForInput[34] = (rtb_Logical12_cpl && (KaTHMR_i_ERLv2_Branch2Select[34]));
    tmpForInput[35] = (rtb_Logical17_o && (KaTHMR_i_ERLv2_Branch2Select[35]));
    tmpForInput[36] = (rtb_Logical12_pb && (KaTHMR_i_ERLv2_Branch2Select[36]));
    tmpForInput[37] = (rtb_Logical12_e5 && (KaTHMR_i_ERLv2_Branch2Select[37]));
    tmpForInput[38] = (rtb_Logical12_dh && (KaTHMR_i_ERLv2_Branch2Select[38]));
    tmpForInput[39] = (rtb_Logical12_er && (KaTHMR_i_ERLv2_Branch2Select[39]));
    tmpForInput[40] = (rtb_Logical12_gz && (KaTHMR_i_ERLv2_Branch2Select[40]));
    tmpForInput[41] = (rtb_Logical12_k5 && (KaTHMR_i_ERLv2_Branch2Select[41]));
    tmpForInput[42] = (rtb_Logical12_hy && (KaTHMR_i_ERLv2_Branch2Select[42]));
    tmpForInput[43] = (rtb_TmpSignalConversionAtVeT_c0 &&
                       (KaTHMR_i_ERLv2_Branch2Select[43]));
    tmpForInput[44] = (rtb_Logical4_iq && (KaTHMR_i_ERLv2_Branch2Select[44]));

    /* Logic: '<S2470>/Logical7' */
    rtb_AND_fe = tmpForInput[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 44;
            rtb_DataTypeConversion2++)
    {
        rtb_AND_fe = (rtb_AND_fe || (tmpForInput[rtb_DataTypeConversion2 + 1]));
    }

    /* If: '<S2928>/If4' incorporates:
     *  Logic: '<S2470>/Logical7'
     *  Logic: '<S2928>/Logical2'
     */
    if (rtb_VariantMerge_For_Variant__l && rtb_AND_fe)
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct8' incorporates:
         *  ActionPort: '<S2982>/Action Port'
         */
        /* Switch: '<S2464>/Switch1' incorporates:
         *  Constant: '<S3002>/Calib'
         *  SignalConversion generated from: '<S2982>/Out1'
         */
        rtb_Switch1_i3 = KeTHMR_dV_Branch2_Emrgcy_LV2;

        /* End of Outputs for SubSystem: '<S2928>/IfAct8' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct9' incorporates:
         *  ActionPort: '<S2983>/Action Port'
         */
        THMR_ac_IfAct1(&rtb_Switch1_i3);

        /* End of Outputs for SubSystem: '<S2928>/IfAct9' */
    }

    /* End of If: '<S2928>/If4' */
    for (i = 0; i < 19; i++)
    {
        /* Product: '<S3008>/Product' incorporates:
         *  Constant: '<S3003>/Calib'
         *  Constant: '<S3005>/Calib'
         */
        rtb_Product_atp[i] = (uint16)(((uint32)KaTHMR_i_Branch2Map[(i)]) *
            ((uint32)CeTHMR_i_FlowReqBrnchSel[(i)]));
    }

    /* MinMax: '<S2945>/MinMax1' incorporates:
     *  Selector: '<S3008>/Selector1'
     */
    rtb_Switch1_ofq = rtb_TmpSignalConversionAtSelect[rtb_Product_atp[0]];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 18;
            rtb_DataTypeConversion2++)
    {
        rtb_Switch1_ofq = fmaxf(rtb_Switch1_ofq,
                                rtb_TmpSignalConversionAtSelect[rtb_Product_atp[rtb_DataTypeConversion2
                                + 1]]);
    }

    /* If: '<S2928>/If5' */
    if (rtb_Logical6_fk)
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct10' incorporates:
         *  ActionPort: '<S2968>/Action Port'
         */
        /* Merge: '<S2928>/Merge8' incorporates:
         *  Constant: '<S2995>/Calib'
         *  SignalConversion generated from: '<S2968>/Out1'
         */
        rtb_Merge8 = KeTHMR_dV_FanAftrRun_Branch2Flow;

        /* End of Outputs for SubSystem: '<S2928>/IfAct10' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct11' incorporates:
         *  ActionPort: '<S2969>/Action Port'
         */
        THMR_ac_IfAct1(&rtb_Merge8);

        /* End of Outputs for SubSystem: '<S2928>/IfAct11' */
    }

    /* End of If: '<S2928>/If5' */

    /* MinMax: '<S2928>/MinMax1' incorporates:
     *  MinMax: '<S2945>/MinMax1'
     */
    rtb_TmpSignalConversionAtVeT_fy = fmaxf(fmaxf(fmaxf(rtb_Product_gg,
        rtb_Switch1_i3), rtb_Switch1_ofq), rtb_Merge8);

    /* Logic: '<S2469>/Logical5' incorporates:
     *  Constant: '<S2489>/Calib'
     */
    tmpForInput_0[0] = (rtb_TmpSignalConversionAtVeTM_j &&
                        (KaTHMR_i_ERLv1_Branch3Select[0]));
    tmpForInput_0[1] = (rtb_TmpSignalConversionAtVeT_f5 &&
                        (KaTHMR_i_ERLv1_Branch3Select[1]));
    tmpForInput_0[2] = (rtb_Logical46_fu && (KaTHMR_i_ERLv1_Branch3Select[2]));
    tmpForInput_0[3] = (rtb_Logical46_j2 && (KaTHMR_i_ERLv1_Branch3Select[3]));
    tmpForInput_0[4] = (rtb_Logical46_ov && (KaTHMR_i_ERLv1_Branch3Select[4]));
    tmpForInput_0[5] = (rtb_Logical46_cr && (KaTHMR_i_ERLv1_Branch3Select[5]));
    tmpForInput_0[6] = (Switch9_a && (KaTHMR_i_ERLv1_Branch3Select[6]));
    tmpForInput_0[7] = (rtb_Logical46_hh && (KaTHMR_i_ERLv1_Branch3Select[7]));
    tmpForInput_0[8] = (rtb_Logical17_h && (KaTHMR_i_ERLv1_Branch3Select[8]));
    tmpForInput_0[9] = (rtb_Logical1_c0 && (KaTHMR_i_ERLv1_Branch3Select[9]));
    tmpForInput_0[10] = (rtb_Logical1_li && (KaTHMR_i_ERLv1_Branch3Select[10]));
    tmpForInput_0[11] = (rtb_Logical1_gx && (KaTHMR_i_ERLv1_Branch3Select[11]));
    tmpForInput_0[12] = (rtb_Logical2_oq && (KaTHMR_i_ERLv1_Branch3Select[12]));

    /* Logic: '<S2469>/Logical8' */
    rtb_AND_fe = tmpForInput_0[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 12;
            rtb_DataTypeConversion2++)
    {
        rtb_AND_fe = (rtb_AND_fe || (tmpForInput_0[rtb_DataTypeConversion2 + 1]));
    }

    /* If: '<S2928>/If6' incorporates:
     *  Logic: '<S2469>/Logical8'
     *  Logic: '<S2928>/Logical4'
     */
    if (rtb_NotEqual_pl && rtb_AND_fe)
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct12' incorporates:
         *  ActionPort: '<S2970>/Action Port'
         */
        /* Switch: '<S2859>/Switch1' incorporates:
         *  Constant: '<S2996>/Calib'
         *  SignalConversion generated from: '<S2970>/Out1'
         */
        rtb_Product_gg = KeTHMR_dV_Branch3_Emrgcy_LV1;

        /* End of Outputs for SubSystem: '<S2928>/IfAct12' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct13' incorporates:
         *  ActionPort: '<S2971>/Action Port'
         */
        THMR_ac_IfAct1(&rtb_Product_gg);

        /* End of Outputs for SubSystem: '<S2928>/IfAct13' */
    }

    /* End of If: '<S2928>/If6' */

    /* Logic: '<S2470>/Logical11' incorporates:
     *  Constant: '<S2573>/Calib'
     */
    tmpForInput[0] = (rtb_Logical12_dt && (KaTHMR_i_ERLv2_Branch3Select[0]));
    tmpForInput[1] = (rtb_Logical12_pv && (KaTHMR_i_ERLv2_Branch3Select[1]));
    tmpForInput[2] = (rtb_Logical1_bt && (KaTHMR_i_ERLv2_Branch3Select[2]));
    tmpForInput[3] = (rtb_Logical3_oz && (KaTHMR_i_ERLv2_Branch3Select[3]));
    tmpForInput[4] = (rtb_VariantMerge_For_Variant__n &&
                      (KaTHMR_i_ERLv2_Branch3Select[4]));
    tmpForInput[5] = (rtb_TmpSignalConversionAtVePD_p &&
                      (KaTHMR_i_ERLv2_Branch3Select[5]));
    tmpForInput[6] = (rtb_TmpSignalConversionAtVePD_i &&
                      (KaTHMR_i_ERLv2_Branch3Select[6]));
    tmpForInput[7] = (rtb_AND_c3 && (KaTHMR_i_ERLv2_Branch3Select[7]));
    tmpForInput[8] = (rtb_OR1_g4 && (KaTHMR_i_ERLv2_Branch3Select[8]));
    tmpForInput[9] = (rtb_Logical18_d && (KaTHMR_i_ERLv2_Branch3Select[9]));
    tmpForInput[10] = (rtb_Logical6_or && (KaTHMR_i_ERLv2_Branch3Select[10]));
    tmpForInput[11] = (rtb_Comparison3_bu && (KaTHMR_i_ERLv2_Branch3Select[11]));
    tmpForInput[12] = (Switch5_i && (KaTHMR_i_ERLv2_Branch3Select[12]));
    tmpForInput[13] = (rtb_AND_cn && (KaTHMR_i_ERLv2_Branch3Select[13]));
    tmpForInput[14] = (rtb_Comparison4_cx && (KaTHMR_i_ERLv2_Branch3Select[14]));
    tmpForInput[15] = (rtb_TmpSignalConversionAtOutAir &&
                       (KaTHMR_i_ERLv2_Branch3Select[15]));
    tmpForInput[16] = (rtb_Comparison6_n3 && (KaTHMR_i_ERLv2_Branch3Select[16]));
    tmpForInput[17] = (rtb_Logical15_o && (KaTHMR_i_ERLv2_Branch3Select[17]));
    tmpForInput[18] = (rtb_AND_ko5 && (KaTHMR_i_ERLv2_Branch3Select[18]));
    tmpForInput[19] = (rtb_Comparison5_c3m && (KaTHMR_i_ERLv2_Branch3Select[19]));
    tmpForInput[20] = (rtb_Logical5_bn && (KaTHMR_i_ERLv2_Branch3Select[20]));
    tmpForInput[21] = (rtb_TmpSignalConversionAtVeT_d5 &&
                       (KaTHMR_i_ERLv2_Branch3Select[21]));
    tmpForInput[22] = (rtb_TmpSignalConversionAtVeT_ib &&
                       (KaTHMR_i_ERLv2_Branch3Select[22]));
    tmpForInput[23] = (rtb_AND_jo && (KaTHMR_i_ERLv2_Branch3Select[23]));
    tmpForInput[24] = (rtb_AND_eb && (KaTHMR_i_ERLv2_Branch3Select[24]));
    tmpForInput[25] = (rtb_Logical4_of && (KaTHMR_i_ERLv2_Branch3Select[25]));
    tmpForInput[26] = (rtb_Logical3_at && (KaTHMR_i_ERLv2_Branch3Select[26]));
    tmpForInput[27] = (rtb_OR1_he && (KaTHMR_i_ERLv2_Branch3Select[27]));
    tmpForInput[28] = (rtb_AND_g2 && (KaTHMR_i_ERLv2_Branch3Select[28]));
    tmpForInput[29] = (rtb_Logical12_fs && (KaTHMR_i_ERLv2_Branch3Select[29]));
    tmpForInput[30] = (rtb_Logical12_hd && (KaTHMR_i_ERLv2_Branch3Select[30]));
    tmpForInput[31] = (rtb_Logical12_gu && (KaTHMR_i_ERLv2_Branch3Select[31]));
    tmpForInput[32] = (rtb_Logical12_c2 && (KaTHMR_i_ERLv2_Branch3Select[32]));
    tmpForInput[33] = (rtb_Logical12_gap && (KaTHMR_i_ERLv2_Branch3Select[33]));
    tmpForInput[34] = (rtb_Logical12_cpl && (KaTHMR_i_ERLv2_Branch3Select[34]));
    tmpForInput[35] = (rtb_Logical17_o && (KaTHMR_i_ERLv2_Branch3Select[35]));
    tmpForInput[36] = (rtb_Logical12_pb && (KaTHMR_i_ERLv2_Branch3Select[36]));
    tmpForInput[37] = (rtb_Logical12_e5 && (KaTHMR_i_ERLv2_Branch3Select[37]));
    tmpForInput[38] = (rtb_Logical12_dh && (KaTHMR_i_ERLv2_Branch3Select[38]));
    tmpForInput[39] = (rtb_Logical12_er && (KaTHMR_i_ERLv2_Branch3Select[39]));
    tmpForInput[40] = (rtb_Logical12_gz && (KaTHMR_i_ERLv2_Branch3Select[40]));
    tmpForInput[41] = (rtb_Logical12_k5 && (KaTHMR_i_ERLv2_Branch3Select[41]));
    tmpForInput[42] = (rtb_Logical12_hy && (KaTHMR_i_ERLv2_Branch3Select[42]));
    tmpForInput[43] = (rtb_TmpSignalConversionAtVeT_c0 &&
                       (KaTHMR_i_ERLv2_Branch3Select[43]));
    tmpForInput[44] = (rtb_Logical4_iq && (KaTHMR_i_ERLv2_Branch3Select[44]));

    /* Logic: '<S2470>/Logical8' */
    rtb_AND_fe = tmpForInput[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 44;
            rtb_DataTypeConversion2++)
    {
        rtb_AND_fe = (rtb_AND_fe || (tmpForInput[rtb_DataTypeConversion2 + 1]));
    }

    /* If: '<S2928>/If7' incorporates:
     *  Logic: '<S2470>/Logical8'
     *  Logic: '<S2928>/Logical6'
     */
    if (rtb_VariantMerge_For_Variant__l && rtb_AND_fe)
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct14' incorporates:
         *  ActionPort: '<S2972>/Action Port'
         */
        /* Switch: '<S2464>/Switch1' incorporates:
         *  Constant: '<S2997>/Calib'
         *  SignalConversion generated from: '<S2972>/Out1'
         */
        rtb_Switch1_i3 = KeTHMR_dV_Branch3_Emrgcy_LV2;

        /* End of Outputs for SubSystem: '<S2928>/IfAct14' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct15' incorporates:
         *  ActionPort: '<S2973>/Action Port'
         */
        THMR_ac_IfAct1(&rtb_Switch1_i3);

        /* End of Outputs for SubSystem: '<S2928>/IfAct15' */
    }

    /* End of If: '<S2928>/If7' */
    for (i = 0; i < 19; i++)
    {
        /* Product: '<S3009>/Product' incorporates:
         *  Constant: '<S3003>/Calib'
         *  Constant: '<S3006>/Calib'
         */
        rtb_Product_atp[i] = (uint16)(((uint32)KaTHMR_i_Branch3Map[(i)]) *
            ((uint32)CeTHMR_i_FlowReqBrnchSel[(i)]));
    }

    /* MinMax: '<S2945>/MinMax2' incorporates:
     *  Selector: '<S3009>/Selector1'
     */
    rtb_Switch1_ofq = rtb_TmpSignalConversionAtSelect[rtb_Product_atp[0]];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 18;
            rtb_DataTypeConversion2++)
    {
        rtb_Switch1_ofq = fmaxf(rtb_Switch1_ofq,
                                rtb_TmpSignalConversionAtSelect[rtb_Product_atp[rtb_DataTypeConversion2
                                + 1]]);
    }

    /* If: '<S2928>/If8' */
    if (rtb_Logical6_fk)
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct16' incorporates:
         *  ActionPort: '<S2974>/Action Port'
         */
        /* Merge: '<S2928>/Merge8' incorporates:
         *  Constant: '<S2998>/Calib'
         *  SignalConversion generated from: '<S2974>/Out1'
         */
        rtb_Merge8 = KeTHMR_dV_FanAftrRun_Branch3Flow;

        /* End of Outputs for SubSystem: '<S2928>/IfAct16' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2928>/IfAct17' incorporates:
         *  ActionPort: '<S2975>/Action Port'
         */
        THMR_ac_IfAct1(&rtb_Merge8);

        /* End of Outputs for SubSystem: '<S2928>/IfAct17' */
    }

    /* End of If: '<S2928>/If8' */

    /* MinMax: '<S2928>/MinMax2' incorporates:
     *  MinMax: '<S2945>/MinMax2'
     */
    rtb_TmpSignalConversionAtVeTM_n = fmaxf(fmaxf(fmaxf(rtb_Product_gg,
        rtb_Switch1_i3), rtb_Switch1_ofq), rtb_Merge8);

    /* SignalConversion generated from: '<S2285>/Selector1' */
    rtb_Selector4_n[0] = rtb_VariantMerge_For_Variant_So;
    rtb_Selector4_n[1] = rtb_TmpSignalConversionAtVeT_fy;
    rtb_Selector4_n[2] = rtb_TmpSignalConversionAtVeTM_n;

    /* Switch: '<S2859>/Switch1' incorporates:
     *  Constant: '<S2285>/Constant4'
     *  Lookup_n-D: '<S2427>/Vector'
     *  Product: '<S2285>/Divide'
     *  Sum: '<S2285>/Add9'
     */
    rtb_Product_gg = look1_iflf_binlcapw((rtb_TmpSignalConversionAtVeTM_f +
        rtb_TmpSignalConversionAtVeT_jp) / 2.0F, ((const float32 *)
        &(KxTHMR_Cf_ClntFlwsConv_EDMheatEstm[0])), ((const float32 *)
        &(KtTHMR_Cf_ClntFlwsConv_EDMheatEstm[0])), 7U);

    /* Product: '<S2285>/Product4' incorporates:
     *  Constant: '<S2417>/Calib'
     *  Selector: '<S2285>/Selector1'
     */
    rtb_Switch1_ofq = rtb_Selector4_n[KaTHMR_i_BrchFlwMap_EDMheatEstm[1]] *
        rtb_Product_gg;

    /* Switch: '<S2285>/Switch3' incorporates:
     *  Constant: '<S2424>/Calib'
     */
    if (KeTHMR_b_PumpOilFlwMap_EDMheatEstm)
    {
        rtb_Switch10 = THMR_ac_B.VariantMerge_For_Variant_Sou_ad;
    }
    else
    {
        rtb_Switch10 = THMR_ac_B.VariantMerge_For_Variant_Sour_a;
    }

    /* End of Switch: '<S2285>/Switch3' */

    /* Product: '<S2285>/Product5' incorporates:
     *  Lookup_n-D: '<S2428>/Vector'
     *  Switch: '<S2864>/Switch5'
     */
    rtb_Merge1_i = look1_iflf_binlcapw(rtb_TmpSignalConversionAtVeFSCR, ((const
        float32 *)&(KxTHMR_Cf_FEDM_OilFlwConv_EDMheatEstm[0])), ((const float32 *)
        &(KtTHMR_Cf_FEDM_OilFlwConv_EDMheatEstm[0])), 7U) * rtb_Switch10;

    /* Lookup_n-D: '<S2433>/Vector' incorporates:
     *  Product: '<S2285>/Product5'
     */
    rtb_Switch1_i3 = look1_iflf_binlcapw(rtb_Merge1_i, ((const float32 *)
        &(KxTHMR_k_FEDMheatEstm_Alpha1[0])), ((const float32 *)
        &(KtTHMR_k_FEDMheatEstm_Alpha1[0])), 1U);

    /* Lookup_n-D: '<S2434>/Vector' incorporates:
     *  Product: '<S2285>/Product5'
     */
    rtb_Merge8 = look1_iflf_binlcapw(rtb_Merge1_i, ((const float32 *)
        &(KxTHMR_k_FEDMheatEstm_Alpha2[0])), ((const float32 *)
        &(KtTHMR_k_FEDMheatEstm_Alpha2[0])), 1U);

    /* Lookup_n-D: '<S2435>/Vector' incorporates:
     *  Product: '<S2285>/Product5'
     */
    rtb_UnitDelay_nr = look1_iflf_binlcapw(rtb_Merge1_i, ((const float32 *)
        &(KxTHMR_k_FEDMheatEstm_Alpha3[0])), ((const float32 *)
        &(KtTHMR_k_FEDMheatEstm_Alpha3[0])), 1U);

    /* Lookup_n-D: '<S2436>/Vector' incorporates:
     *  Product: '<S2285>/Product5'
     */
    rtb_Switch15 = look1_iflf_binlcapw(rtb_Merge1_i, ((const float32 *)
        &(KxTHMR_k_FEDMheatEstm_Alpha4[0])), ((const float32 *)
        &(KtTHMR_k_FEDMheatEstm_Alpha4[0])), 1U);

    /* Lookup_n-D: '<S2437>/Vector' incorporates:
     *  Product: '<S2285>/Product5'
     */
    rtb_Switch10 = look1_iflf_binlcapw(rtb_Merge1_i, ((const float32 *)
        &(KxTHMR_k_FEDMheatEstm_Alpha5[0])), ((const float32 *)
        &(KtTHMR_k_FEDMheatEstm_Alpha5[0])), 1U);

    /* Lookup_n-D: '<S2431>/Vector' incorporates:
     *  Switch: '<S2864>/Switch1'
     */
    VeTHMR_dQ_FEDMHeatGen = look2_iflf_binlcapw(rtb_Add4_m1,
        rtb_TmpSignalConversionAtSele_h[0], ((const float32 *)
        &(KxTHMR_dQ_FrontEDM_HeatLoss[0])), ((const float32 *)
        &(KyTHMR_dQ_FrontEDM_HeatLoss[0])), ((const float32 *)
        &(KtTHMR_dQ_FrontEDM_HeatLoss[0])), THMR_ac_ConstP.pooled35, 11U);

    /* If: '<S2413>/If' incorporates:
     *  Constant: '<S2285>/Constant1'
     *  Constant: '<S2413>/Constant1'
     *  Constant: '<S2419>/Calib'
     *  Constant: '<S2422>/Calib'
     *  Logic: '<S2413>/LogicalOperator4'
     *  RelationalOperator: '<S2413>/Comparison1'
     *  RelationalOperator: '<S2413>/Comparison2'
     *  RelationalOperator: '<S2413>/Comparison3'
     *  RelationalOperator: '<S2413>/Comparison4'
     *  RelationalOperator: '<S2413>/Comparison5'
     *  RelationalOperator: '<S2413>/Comparison6'
     *  RelationalOperator: '<S2413>/Comparison7'
     *  RelationalOperator: '<S2413>/Comparison8'
     *  Sum: '<S2285>/Add1'
     *  Sum: '<S2285>/Add2'
     */
    if ((((((((!KeTHMR_b_EnblFEDMheatEstmCalc) || (rtb_Switch1_ofq <= 0.0F)) ||
             (rtb_Merge1_i <= 0.0F)) || (rtb_Switch1_i3 <= 0.0F)) || (rtb_Merge8
            <= 0.0F)) || (rtb_UnitDelay_nr <= 0.0F)) || (rtb_Switch15 <= 0.0F)) ||
        (rtb_Switch10 <= 0.0F))
    {
        /* Outputs for IfAction SubSystem: '<S2413>/Fault' incorporates:
         *  ActionPort: '<S2454>/ActionPort'
         */
        THMR_ac_Fault((&(VeTHMR_P_FEDMHeatAbsrbdByClnt_ThrmlEnrgyBalnce)),
                      &rtb_Logical6_fk);

        /* End of Outputs for SubSystem: '<S2413>/Fault' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2413>/EDM_Heat_Estimation' incorporates:
         *  ActionPort: '<S2453>/ActionPort'
         */
        THMR_ac_EDM_Heat_Estimation(KeTHMR_Cf_CtoK + rtb_Selector_c[1],
            KeTHMR_Cf_CtoK + rtb_TmpSignalConversionAtVeFSCR, rtb_Switch1_ofq,
            rtb_Merge1_i, rtb_Switch1_i3, rtb_Merge8, rtb_UnitDelay_nr,
            rtb_Switch15, rtb_Switch10, 0.1F, VeTHMR_dQ_FEDMHeatGen,
            (&(VeTHMR_P_FEDMHeatAbsrbdByClnt_ThrmlEnrgyBalnce)),
            &rtb_Logical6_fk, &THMR_ac_DW.EDM_Heat_Estimation);

        /* End of Outputs for SubSystem: '<S2413>/EDM_Heat_Estimation' */
    }

    /* End of If: '<S2413>/If' */

    /* Product: '<S2285>/Product3' incorporates:
     *  Constant: '<S2417>/Calib'
     *  Selector: '<S2285>/Selector1'
     */
    rtb_TmpSignalConversionAtVeFSCR = rtb_Product_gg *
        rtb_Selector4_n[KaTHMR_i_BrchFlwMap_EDMheatEstm[0]];

    /* Switch: '<S2285>/Switch2' incorporates:
     *  Constant: '<S2424>/Calib'
     */
    if (KeTHMR_b_PumpOilFlwMap_EDMheatEstm)
    {
        rtb_Switch10 = THMR_ac_B.VariantMerge_For_Variant_Sour_a;
    }
    else
    {
        rtb_Switch10 = THMR_ac_B.VariantMerge_For_Variant_Sou_ad;
    }

    /* End of Switch: '<S2285>/Switch2' */

    /* Product: '<S2285>/Product2' incorporates:
     *  Lookup_n-D: '<S2429>/Vector'
     *  Switch: '<S2864>/Switch4'
     */
    rtb_Switch1_ofq = look1_iflf_binlcapw(rtb_Switch1_muc, ((const float32 *)
        &(KxTHMR_Cf_REDM_OilFlwConv_EDMheatEstm[0])), ((const float32 *)
        &(KtTHMR_Cf_REDM_OilFlwConv_EDMheatEstm[0])), 7U) * rtb_Switch10;

    /* Lookup_n-D: '<S2438>/Vector' incorporates:
     *  Product: '<S2285>/Product2'
     */
    rtb_Add4_m1 = look1_iflf_binlcapw(rtb_Switch1_ofq, ((const float32 *)
        &(KxTHMR_k_REDMheatEstm_Alpha1[0])), ((const float32 *)
        &(KtTHMR_k_REDMheatEstm_Alpha1[0])), 1U);

    /* Lookup_n-D: '<S2439>/Vector' incorporates:
     *  Product: '<S2285>/Product2'
     */
    rtb_Merge1_i = look1_iflf_binlcapw(rtb_Switch1_ofq, ((const float32 *)
        &(KxTHMR_k_REDMheatEstm_Alpha2[0])), ((const float32 *)
        &(KtTHMR_k_REDMheatEstm_Alpha2[0])), 1U);

    /* Lookup_n-D: '<S2440>/Vector' incorporates:
     *  Product: '<S2285>/Product2'
     */
    rtb_Product_gg = look1_iflf_binlcapw(rtb_Switch1_ofq, ((const float32 *)
        &(KxTHMR_k_REDMheatEstm_Alpha3[0])), ((const float32 *)
        &(KtTHMR_k_REDMheatEstm_Alpha3[0])), 1U);

    /* Lookup_n-D: '<S2441>/Vector' incorporates:
     *  Product: '<S2285>/Product2'
     */
    rtb_Switch1_i3 = look1_iflf_binlcapw(rtb_Switch1_ofq, ((const float32 *)
        &(KxTHMR_k_REDMheatEstm_Alpha4[0])), ((const float32 *)
        &(KtTHMR_k_REDMheatEstm_Alpha4[0])), 1U);

    /* Lookup_n-D: '<S2442>/Vector' incorporates:
     *  Product: '<S2285>/Product2'
     */
    rtb_Merge8 = look1_iflf_binlcapw(rtb_Switch1_ofq, ((const float32 *)
        &(KxTHMR_k_REDMheatEstm_Alpha5[0])), ((const float32 *)
        &(KtTHMR_k_REDMheatEstm_Alpha5[0])), 1U);

    /* Lookup_n-D: '<S2432>/Vector' incorporates:
     *  Switch: '<S2864>/Switch2'
     */
    VeTHMR_dQ_REDMHeatGen = look2_iflf_binlcapw(rtb_TmpSignalConversionAtVeT_gg,
        rtb_TmpSignalConversionAtSele_h[1], ((const float32 *)
        &(KxTHMR_dQ_RearEDM_HeatLoss[0])), ((const float32 *)
        &(KyTHMR_dQ_RearEDM_HeatLoss[0])), ((const float32 *)
        &(KtTHMR_dQ_RearEDM_HeatLoss[0])), THMR_ac_ConstP.pooled35, 11U);

    /* If: '<S2443>/If' incorporates:
     *  Constant: '<S2285>/Constant2'
     *  Constant: '<S2419>/Calib'
     *  Constant: '<S2423>/Calib'
     *  Constant: '<S2443>/Constant1'
     *  Logic: '<S2443>/LogicalOperator4'
     *  RelationalOperator: '<S2443>/Comparison1'
     *  RelationalOperator: '<S2443>/Comparison2'
     *  RelationalOperator: '<S2443>/Comparison3'
     *  RelationalOperator: '<S2443>/Comparison4'
     *  RelationalOperator: '<S2443>/Comparison5'
     *  RelationalOperator: '<S2443>/Comparison6'
     *  RelationalOperator: '<S2443>/Comparison7'
     *  RelationalOperator: '<S2443>/Comparison8'
     *  Sum: '<S2285>/Add4'
     *  Sum: '<S2285>/Add5'
     */
    if ((((((((!KeTHMR_b_EnblREDMheatEstmCalc) ||
              (rtb_TmpSignalConversionAtVeFSCR <= 0.0F)) || (rtb_Switch1_ofq <=
              0.0F)) || (rtb_Add4_m1 <= 0.0F)) || (rtb_Merge1_i <= 0.0F)) ||
            (rtb_Product_gg <= 0.0F)) || (rtb_Switch1_i3 <= 0.0F)) ||
            (rtb_Merge8 <= 0.0F))
    {
        /* Outputs for IfAction SubSystem: '<S2443>/Fault' incorporates:
         *  ActionPort: '<S2466>/ActionPort'
         */
        THMR_ac_Fault((&(VeTHMR_P_REDMHeatAbsrbdByClnt_ThrmlEnrgyBalnce)),
                      &rtb_RelationalOperator_nw);

        /* End of Outputs for SubSystem: '<S2443>/Fault' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2443>/EDM_Heat_Estimation' incorporates:
         *  ActionPort: '<S2465>/ActionPort'
         */
        THMR_ac_EDM_Heat_Estimation(KeTHMR_Cf_CtoK + rtb_Selector_c[0],
            KeTHMR_Cf_CtoK + rtb_Switch1_muc, rtb_TmpSignalConversionAtVeFSCR,
            rtb_Switch1_ofq, rtb_Add4_m1, rtb_Merge1_i, rtb_Product_gg,
            rtb_Switch1_i3, rtb_Merge8, 0.1F, VeTHMR_dQ_REDMHeatGen,
            (&(VeTHMR_P_REDMHeatAbsrbdByClnt_ThrmlEnrgyBalnce)),
            &rtb_RelationalOperator_nw, &THMR_ac_DW.EDM_Heat_Estimation_n);

        /* End of Outputs for SubSystem: '<S2443>/EDM_Heat_Estimation' */
    }

    /* End of If: '<S2443>/If' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeTMIR_Pct_BSG_ECM_RadFanRq' */
    (void)Rte_Read_VeTMIR_Pct_BSG_ECM_RadFanRq_Value(&rtb_Switch1_pm);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Product: '<S2407>/Product' incorporates:
     *  Lookup_n-D: '<S2430>/Vector'
     *  SignalConversion generated from: '<S2>/VeTMIR_T_OnBrdChrg_ClntTmpIn'
     *  Sum: '<S2407>/Add3'
     */
    VeTHMR_P_EDUHeatAbsrbdByClnt_SpcfcHeatChng =
        ((rtb_TmpSignalConversionAtVeTM_f - rtb_TmpSignalConversionAtVeT_jp) *
         rtb_TmpSignalConversionAtVePM_d) * look1_iflf_binlcapw
        (rtb_TmpSignalConversionAtVeTM_f, ((const float32 *)
          &(KxTHMR_K_CoolantHeatCap[0])), ((const float32 *)
          &(KtTHMR_K_CoolantHeatCap[0])), 5U);

    /* Product: '<S2408>/Product5' incorporates:
     *  Lookup_n-D: '<S2446>/Vector'
     *  Sum: '<S2408>/Add7'
     *  Switch: '<S3944>/Switch'
     */
    VeTHMR_P_EDUHeatLosstoAmb = (rtb_TmpSignalConversionAtVeTM_f -
        TmpSignalConversionAtOutAirTemp) * look1_iflf_binlcapw(VeTHMR_v_Vehicle,
        ((const float32 *)&(KxTHMR_P_EDU_Heat_Loss[0])), ((const float32 *)
        &(KtTHMR_P_EDU_Heat_Loss[0])), 3U);

    /* Switch: '<S2859>/Switch1' incorporates:
     *  Constant: '<S2425>/Calib'
     *  Constant: '<S2426>/Calib'
     *  Product: '<S2285>/Product'
     *  Product: '<S2285>/Product1'
     *  Sum: '<S2285>/Add3'
     *  Sum: '<S2285>/Add6'
     *  Sum: '<S2285>/Add8'
     */
    rtb_Product_gg = ((VeTHMR_P_FEDMHeatAbsrbdByClnt_ThrmlEnrgyBalnce +
                       VeTHMR_P_REDMHeatAbsrbdByClnt_ThrmlEnrgyBalnce) *
                      KeTHMR_r_EDMHeatEstm_ThrmlEnrgyBalnce) +
        ((VeTHMR_P_EDUHeatAbsrbdByClnt_SpcfcHeatChng - VeTHMR_P_EDUHeatLosstoAmb)
         * KeTHMR_r_EDMHeatEstm_SpcfcHeatChng);

    /* Switch: '<S2416>/Switch1' incorporates:
     *  Constant: '<S2420>/Calib'
     *  Constant: '<S2421>/Calib'
     *  Logic: '<S2285>/LogicalOperator4'
     *  RelationalOperator: '<S2285>/Comparison1'
     *  Sum: '<S2285>/Add7'
     */
    if ((((VeTHMR_dQ_FEDMHeatGen + VeTHMR_dQ_REDMHeatGen) - rtb_Product_gg) >=
            KeTHMR_P_MinEDMHeatGen_FrClntHeatAbsrb) ||
            (KeTHMR_b_DsblMinEDMHeatGen_FrClntHeatAbsrb))
    {
        /* Switch: '<S2416>/Switch1' */
        VeTHMR_P_ClntHeatAbsrbFrmEDU_Arb = rtb_Product_gg;
    }
    else
    {
        /* Switch: '<S2416>/Switch1' incorporates:
         *  Constant: '<S2285>/Constant3'
         */
        VeTHMR_P_ClntHeatAbsrbFrmEDU_Arb = 0.0F;
    }

    /* End of Switch: '<S2416>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* Outputs for IfAction SubSystem: '<S1164>/HTR_nd_Vlv_fr_BattActvPsv_Heating' incorporates:
     *  ActionPort: '<S1981>/ActionPort'
     */
    /* If: '<S1164>/CabinHeat_Rqst_and_CPV3_Position' incorporates:
     *  Merge: '<S4575>/Merge1'
     *  RelationalOperator: '<S1158>/Comparison2'
     *  RelationalOperator: '<S1164>/Comparison2'
     *  RelationalOperator: '<S1981>/Comparison2'
     *  RelationalOperator: '<S2280>/Comparison1'
     *  RelationalOperator: '<S2284>/Comparison1'
     */
    tmp_d = THMR_ac_B.VeTHMR_e_LTCLThrmlMode;

    /* End of Outputs for SubSystem: '<S1164>/HTR_nd_Vlv_fr_BattActvPsv_Heating' */

    /* Switch: '<S2410>/Switch1' incorporates:
     *  Constant: '<S2301>/Constant'
     *  Constant: '<S2302>/Constant'
     *  Logic: '<S2280>/Logical2'
     *  RelationalOperator: '<S2280>/Comparison1'
     *  RelationalOperator: '<S2280>/Comparison2'
     *  Switch: '<S4586>/Switch1'
     */
    if ((((uint32)VeTHMR_e_BatThrmlSt_B4D) == CeTHMR_e_ActvPsvHeating) &&
            (((uint32)tmp_d) == CeTHMR_e_LTCLPassiveCooling))
    {
        /* Switch: '<S2410>/Switch1' */
        rtb_TmpSignalConversionAtVeFSCR = VeTHMR_P_ClntHeatAbsrbFrmEDU_Arb;
    }
    else
    {
        /* Switch: '<S2410>/Switch1' incorporates:
         *  Constant: '<S2410>/Constant1'
         */
        rtb_TmpSignalConversionAtVeFSCR = 0.0F;
    }

    /* End of Switch: '<S2410>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S2410>/Limiter4' */
    /* Switch: '<S2448>/Switch1' incorporates:
     *  Constant: '<S2447>/Calib'
     *  RelationalOperator: '<S2448>/RelationalOperator'
     */
    if (KeTHMR_P_EDUheat_Batt_Assist_Max < rtb_TmpSignalConversionAtVeFSCR)
    {
        /* Switch: '<S2859>/Switch1' */
        rtb_Product_gg = KeTHMR_P_EDUheat_Batt_Assist_Max;
    }
    else
    {
        /* Switch: '<S2859>/Switch1' */
        rtb_Product_gg = rtb_TmpSignalConversionAtVeFSCR;
    }

    /* End of Switch: '<S2448>/Switch1' */

    /* Switch: '<S2448>/Switch' incorporates:
     *  Constant: '<S2410>/Constant8'
     *  RelationalOperator: '<S2448>/RelationalOperator1'
     */
    if (rtb_Product_gg > 0.0F)
    {
        /* Switch: '<S2448>/Switch' */
        VeTHMR_P_EDU_Heat_Battery_Available_B4Grd = rtb_Product_gg;
    }
    else
    {
        /* Switch: '<S2448>/Switch' */
        VeTHMR_P_EDU_Heat_Battery_Available_B4Grd = 0.0F;
    }

    /* End of Switch: '<S2448>/Switch' */
    /* End of Outputs for SubSystem: '<S2410>/Limiter4' */

    /* Switch: '<S2411>/Switch2' incorporates:
     *  Constant: '<S2405>/Constant'
     *  Constant: '<S2406>/Constant'
     *  Logic: '<S2284>/Logical2'
     *  RelationalOperator: '<S2284>/Comparison1'
     *  RelationalOperator: '<S2284>/Comparison2'
     */
    if ((((uint32)rtb_Switch1_o0g) == CeTHMR_e_CabinActivePassiveHeating) &&
            (((uint32)tmp_d) == CeTHMR_e_LTCLPassiveCooling))
    {
        /* Switch: '<S2411>/Switch2' */
        rtb_TmpSignalConversionAtVeFSCR = VeTHMR_P_ClntHeatAbsrbFrmEDU_Arb;
    }
    else
    {
        /* Switch: '<S2411>/Switch2' incorporates:
         *  Constant: '<S2411>/Constant'
         */
        rtb_TmpSignalConversionAtVeFSCR = 0.0F;
    }

    /* End of Switch: '<S2411>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S2411>/Limiter3' */
    /* Switch: '<S2450>/Switch1' incorporates:
     *  Constant: '<S2449>/Calib'
     *  RelationalOperator: '<S2450>/RelationalOperator'
     */
    if (KeTHMR_P_EDUheat_Cabin_Assist_Max < rtb_TmpSignalConversionAtVeFSCR)
    {
        /* Switch: '<S2859>/Switch1' */
        rtb_Product_gg = KeTHMR_P_EDUheat_Cabin_Assist_Max;
    }
    else
    {
        /* Switch: '<S2859>/Switch1' */
        rtb_Product_gg = rtb_TmpSignalConversionAtVeFSCR;
    }

    /* End of Switch: '<S2450>/Switch1' */

    /* Switch: '<S2450>/Switch' incorporates:
     *  Constant: '<S2411>/Constant7'
     *  RelationalOperator: '<S2450>/RelationalOperator1'
     */
    if (rtb_Product_gg > 0.0F)
    {
        /* Switch: '<S2450>/Switch' */
        VeTHMR_P_EDU_Heat_Cabin_AvailableB4Grd = rtb_Product_gg;
    }
    else
    {
        /* Switch: '<S2450>/Switch' */
        VeTHMR_P_EDU_Heat_Cabin_AvailableB4Grd = 0.0F;
    }

    /* End of Switch: '<S2450>/Switch' */
    /* End of Outputs for SubSystem: '<S2411>/Limiter3' */

    /* Outputs for Atomic SubSystem: '<S2414>/GradientLimiter1' */
    /* Switch: '<S2859>/Switch1' incorporates:
     *  UnitDelay: '<S2457>/UnitDelay'
     */
    rtb_Product_gg = THMR_ac_DW.UnitDelay_DSTATE_pq;

    /* Sum: '<S2457>/Sum2' */
    rtb_TmpSignalConversionAtVeFSCR = VeTHMR_P_EDU_Heat_Battery_Available_B4Grd
        - rtb_Product_gg;

    /* Outputs for Atomic SubSystem: '<S2457>/Limiter' */
    /* Switch: '<S2460>/Switch1' incorporates:
     *  Constant: '<S2459>/Calib'
     *  RelationalOperator: '<S2460>/RelationalOperator'
     */
    if (KeTHMR_P_EDUheat_Batt_Assist_RtLimUp < rtb_TmpSignalConversionAtVeFSCR)
    {
        /* Switch: '<S2464>/Switch1' */
        rtb_Switch1_i3 = KeTHMR_P_EDUheat_Batt_Assist_RtLimUp;
    }
    else
    {
        /* Switch: '<S2464>/Switch1' */
        rtb_Switch1_i3 = rtb_TmpSignalConversionAtVeFSCR;
    }

    /* End of Switch: '<S2460>/Switch1' */

    /* Switch: '<S2460>/Switch' incorporates:
     *  Constant: '<S2458>/Calib'
     *  RelationalOperator: '<S2460>/RelationalOperator1'
     */
    if (rtb_Switch1_i3 <= KeTHMR_P_EDUheat_Batt_Assist_RtLimDown)
    {
        rtb_Switch1_i3 = KeTHMR_P_EDUheat_Batt_Assist_RtLimDown;
    }

    /* End of Switch: '<S2460>/Switch' */
    /* End of Outputs for SubSystem: '<S2457>/Limiter' */

    /* Sum: '<S2457>/Sum3' */
    rtb_TmpSignalConversionAtVeFSCR = rtb_Switch1_i3 + rtb_Product_gg;

    /* Update for UnitDelay: '<S2457>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_pq = rtb_TmpSignalConversionAtVeFSCR;

    /* End of Outputs for SubSystem: '<S2414>/GradientLimiter1' */

    /* Outputs for Atomic SubSystem: '<S2415>/GradientLimiter' */
    /* Switch: '<S2859>/Switch1' incorporates:
     *  UnitDelay: '<S2461>/UnitDelay'
     */
    rtb_Product_gg = THMR_ac_DW.UnitDelay_DSTATE_kta;

    /* Sum: '<S2461>/Sum2' */
    rtb_TmpSignalConversionAtVeT_gg = VeTHMR_P_EDU_Heat_Cabin_AvailableB4Grd -
        rtb_Product_gg;

    /* Outputs for Atomic SubSystem: '<S2461>/Limiter' */
    /* Switch: '<S2464>/Switch1' incorporates:
     *  Constant: '<S2463>/Calib'
     *  RelationalOperator: '<S2464>/RelationalOperator'
     */
    if (KeTHMR_P_EDUheat_Cabin_Assist_RtLimUp < rtb_TmpSignalConversionAtVeT_gg)
    {
        /* Switch: '<S2464>/Switch1' */
        rtb_Switch1_i3 = KeTHMR_P_EDUheat_Cabin_Assist_RtLimUp;
    }
    else
    {
        /* Switch: '<S2464>/Switch1' */
        rtb_Switch1_i3 = rtb_TmpSignalConversionAtVeT_gg;
    }

    /* End of Switch: '<S2464>/Switch1' */

    /* Switch: '<S2464>/Switch' incorporates:
     *  Constant: '<S2462>/Calib'
     *  RelationalOperator: '<S2464>/RelationalOperator1'
     */
    if (rtb_Switch1_i3 <= KeTHMR_P_EDUheat_Cabin_Assist_RtLimDown)
    {
        rtb_Switch1_i3 = KeTHMR_P_EDUheat_Cabin_Assist_RtLimDown;
    }

    /* End of Switch: '<S2464>/Switch' */
    /* End of Outputs for SubSystem: '<S2461>/Limiter' */

    /* Sum: '<S2461>/Sum3' */
    rtb_TmpSignalConversionAtVeT_gg = rtb_Switch1_i3 + rtb_Product_gg;

    /* Update for UnitDelay: '<S2461>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kta = rtb_TmpSignalConversionAtVeT_gg;

    /* End of Outputs for SubSystem: '<S2415>/GradientLimiter' */

    /* SignalConversion generated from: '<S2>/VeTHMR_b_FEDMHeatEstm_SNAflag' incorporates:
     *  Gain: '<S2444>/Gain'
     *  Outport: '<Root>/VeTHMR_b_FEDMHeatEstm_SNAflag'
     */
    (void)Rte_Write_VeTHMR_b_FEDMHeatEstm_SNAflag_Value(rtb_Logical6_fk);

    /* SignalConversion generated from: '<S2>/VeTHMR_b_REDMHeatEstm_SNAflag' incorporates:
     *  Gain: '<S2445>/Gain'
     *  Outport: '<Root>/VeTHMR_b_REDMHeatEstm_SNAflag'
     */
    (void)Rte_Write_VeTHMR_b_REDMHeatEstm_SNAflag_Value
        (rtb_RelationalOperator_nw);

    /* Logic: '<S2857>/Logical6' incorporates:
     *  Constant: '<S2860>/Calib'
     *  Constant: '<S2861>/Calib'
     *  Constant: '<S2862>/Calib'
     *  Constant: '<S2863>/Calib'
     *  Logic: '<S2857>/Logical7'
     *  RelationalOperator: '<S2857>/Comparison10'
     *  RelationalOperator: '<S2857>/Comparison11'
     *  RelationalOperator: '<S2857>/Comparison12'
     */
    rtb_Logical6_fk = (((VeTHMR_T_EngCoolantTemp >=
                         KeTHMR_T_ECT_hotDisFan_Thrsld) && (VeTHMR_v_Vehicle <=
                         KeTHMR_n_VhclSpdLo_DisFanThrsld)) && ((rtb_Switch1_pm <=
                         KeTHMR_Pct_RadFanOn_DsblFanThrsld) ||
                        (KeTHMR_b_ECT_HotDisFan_IgnorFanSts)));

    /* RelationalOperator: '<S62>/RelationalOperator' incorporates:
     *  Constant: '<S2916>/Constant'
     *  Constant: '<S2917>/Constant'
     *  Constant: '<S2920>/Calib'
     *  DataTypeConversion: '<S3621>/DataTypeConversion'
     *  Logic: '<S2915>/LogicalOperator'
     *  RelationalOperator: '<S2915>/RelationalOperator'
     *  RelationalOperator: '<S2915>/RelationalOperator1'
     *  RelationalOperator: '<S2928>/Relational Operator'
     */
    rtb_RelationalOperator_nw = (((((uint32)VeTHMR_e_HCP_LTP_FanAftRun_Rq_BD_SF)
        != CeTMIR_e_No_AftRunRequest) && (((uint32)
        VeTHMR_e_HCP_LTP_FanAftRun_Rq_BD_SF) != CeTMIR_e_SNA_AftRunRequest)) &&
        (KeTHMR_b_AftrRunPmpFlowOvrdEnbl));

    /* Switch: '<S2865>/Switch1' incorporates:
     *  Constant: '<S2892>/Calib'
     *  Constant: '<S2893>/Calib'
     *  Switch: '<S2865>/Switch3'
     */
    if (KeTHMR_b_CAC_Enbl_Branch1)
    {
        /* Switch: '<S2865>/Switch1' */
        rtb_Switch1_ofq = rtb_VariantMerge_For_Variant_So;
    }
    else if (KeTHMR_b_CAC_Enbl_Branch2)
    {
        /* Switch: '<S2865>/Switch3' incorporates:
         *  Switch: '<S2865>/Switch1'
         */
        rtb_Switch1_ofq = rtb_TmpSignalConversionAtVeT_fy;
    }
    else
    {
        /* Switch: '<S2865>/Switch1' incorporates:
         *  Switch: '<S2865>/Switch3'
         */
        rtb_Switch1_ofq = rtb_TmpSignalConversionAtVeTM_n;
    }

    /* End of Switch: '<S2865>/Switch1' */

    /* Switch: '<S2911>/Switch1' incorporates:
     *  Constant: '<S2894>/Calib'
     *  Constant: '<S2895>/Calib'
     *  Constant: '<S2904>/ConstantValue1'
     *  Constant: '<S2905>/ConstantValue1'
     *  Constant: '<S2908>/Calib'
     *  Constant: '<S2912>/Calib'
     *  RelationalOperator: '<S2904>/RelationalOperator3'
     *  RelationalOperator: '<S2905>/RelationalOperator3'
     *  Switch: '<S2865>/Switch2'
     *  Switch: '<S2865>/Switch4'
     *  Switch: '<S2907>/Switch1'
     */
    if (KeTHMR_k_alpha_prime == 0.0F)
    {
        /* Switch: '<S2911>/Switch1' */
        rtb_Switch1_pm = 0.0F;
    }
    else
    {
        if (KeTHMR_k_alpha == 0.0F)
        {
            /* Switch: '<S2907>/Switch1' incorporates:
             *  Constant: '<S2904>/ConstantValue1'
             */
            rtb_Switch1_pm = 0.0F;
        }
        else if (KeTHMR_b_HeadPress_Enbl_Branch1)
        {
            /* Switch: '<S2865>/Switch2' incorporates:
             *  Switch: '<S2907>/Switch1'
             */
            rtb_Switch1_pm = rtb_VariantMerge_For_Variant_So;
        }
        else if (KeTHMR_b_HeadPress_Enbl_Branch2)
        {
            /* Switch: '<S2865>/Switch4' incorporates:
             *  Switch: '<S2865>/Switch2'
             *  Switch: '<S2907>/Switch1'
             */
            rtb_Switch1_pm = rtb_TmpSignalConversionAtVeT_fy;
        }
        else
        {
            /* Switch: '<S2907>/Switch1' incorporates:
             *  Switch: '<S2865>/Switch2'
             *  Switch: '<S2865>/Switch4'
             */
            rtb_Switch1_pm = rtb_TmpSignalConversionAtVeTM_n;
        }

        /* Outputs for Atomic SubSystem: '<S2904>/ProtectedDivision1' */
        /* Switch: '<S2910>/Switch1' incorporates:
         *  Constant: '<S2894>/Calib'
         *  Constant: '<S2895>/Calib'
         *  Constant: '<S2904>/ConstantValue'
         *  Constant: '<S2908>/Calib'
         *  Constant: '<S2910>/ConstantValue'
         *  Constant: '<S2910>/ConstantValue1'
         *  Constant: '<S2910>/ConstantValue2'
         *  Constant: '<S2910>/ConstantValue3'
         *  Logic: '<S2910>/AND'
         *  RelationalOperator: '<S2910>/GreaterThanorEqual'
         *  RelationalOperator: '<S2910>/GreaterThanorEqual1'
         *  RelationalOperator: '<S2910>/NotEqual'
         *  RelationalOperator: '<S2910>/NotEqual1'
         *  Sum: '<S2904>/Subtraction'
         *  Switch: '<S2865>/Switch2'
         *  Switch: '<S2865>/Switch4'
         *  Switch: '<S2907>/Switch1'
         *  Switch: '<S2910>/Switch2'
         *  Switch: '<S2910>/Switch3'
         */
        if ((rtb_Switch1_ofq != 0.0F) && ((1.0F - KeTHMR_k_alpha) != 0.0F))
        {
            /* Switch: '<S2910>/Switch1' incorporates:
             *  Product: '<S2910>/Division'
             */
            rtb_Add4_m1 = rtb_Switch1_ofq / (1.0F - KeTHMR_k_alpha);
        }
        else if (rtb_Switch1_ofq > 0.0F)
        {
            /* Switch: '<S2910>/Switch2' incorporates:
             *  Constant: '<S2910>/MAXFLOAT'
             *  Switch: '<S2910>/Switch1'
             */
            rtb_Add4_m1 = 3.402823466E+38F;
        }
        else if (rtb_Switch1_ofq < 0.0F)
        {
            /* Switch: '<S2910>/Switch3' incorporates:
             *  Constant: '<S2910>/MINFLOAT'
             *  Switch: '<S2910>/Switch1'
             *  Switch: '<S2910>/Switch2'
             */
            rtb_Add4_m1 = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S2910>/Switch1' incorporates:
             *  Constant: '<S2910>/ConstantValue4'
             *  Switch: '<S2910>/Switch2'
             *  Switch: '<S2910>/Switch3'
             */
            rtb_Add4_m1 = 0.0F;
        }

        /* End of Switch: '<S2910>/Switch1' */
        /* End of Outputs for SubSystem: '<S2904>/ProtectedDivision1' */

        /* Outputs for Atomic SubSystem: '<S2904>/ProtectedDivision' */
        /* Switch: '<S2909>/Switch1' incorporates:
         *  Constant: '<S2908>/Calib'
         *  Constant: '<S2909>/ConstantValue'
         *  Constant: '<S2909>/ConstantValue1'
         *  Constant: '<S2909>/ConstantValue2'
         *  Constant: '<S2909>/ConstantValue3'
         *  Logic: '<S2909>/AND'
         *  RelationalOperator: '<S2909>/GreaterThanorEqual'
         *  RelationalOperator: '<S2909>/GreaterThanorEqual1'
         *  RelationalOperator: '<S2909>/NotEqual'
         *  RelationalOperator: '<S2909>/NotEqual1'
         *  Switch: '<S2909>/Switch2'
         *  Switch: '<S2909>/Switch3'
         */
        if ((rtb_Switch1_pm != 0.0F) && (KeTHMR_k_alpha != 0.0F))
        {
            /* Switch: '<S2909>/Switch1' incorporates:
             *  Product: '<S2909>/Division'
             */
            rtb_Switch1_pm /= KeTHMR_k_alpha;
        }
        else if (rtb_Switch1_pm > 0.0F)
        {
            /* Switch: '<S2909>/Switch2' incorporates:
             *  Constant: '<S2909>/MAXFLOAT'
             *  Switch: '<S2909>/Switch1'
             */
            rtb_Switch1_pm = 3.402823466E+38F;
        }
        else if (rtb_Switch1_pm < 0.0F)
        {
            /* Switch: '<S2909>/Switch3' incorporates:
             *  Constant: '<S2909>/MINFLOAT'
             *  Switch: '<S2909>/Switch1'
             *  Switch: '<S2909>/Switch2'
             */
            rtb_Switch1_pm = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S2909>/Switch1' incorporates:
             *  Constant: '<S2909>/ConstantValue4'
             *  Switch: '<S2909>/Switch2'
             *  Switch: '<S2909>/Switch3'
             */
            rtb_Switch1_pm = 0.0F;
        }

        /* End of Switch: '<S2909>/Switch1' */
        /* End of Outputs for SubSystem: '<S2904>/ProtectedDivision' */

        /* Switch: '<S2911>/Switch1' incorporates:
         *  MinMax: '<S2904>/MinMax2'
         */
        rtb_Switch1_pm = fmaxf(rtb_Switch1_pm, rtb_Add4_m1);
    }

    /* End of Switch: '<S2911>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S2905>/ProtectedDivision' */
    /* Switch: '<S2913>/Switch1' incorporates:
     *  Constant: '<S2912>/Calib'
     *  Constant: '<S2913>/ConstantValue'
     *  Constant: '<S2913>/ConstantValue1'
     *  Constant: '<S2913>/ConstantValue2'
     *  Constant: '<S2913>/ConstantValue3'
     *  Logic: '<S2913>/AND'
     *  RelationalOperator: '<S2913>/GreaterThanorEqual'
     *  RelationalOperator: '<S2913>/GreaterThanorEqual1'
     *  RelationalOperator: '<S2913>/NotEqual'
     *  RelationalOperator: '<S2913>/NotEqual1'
     *  Switch: '<S2913>/Switch2'
     *  Switch: '<S2913>/Switch3'
     */
    if ((rtb_Switch1_pm != 0.0F) && (KeTHMR_k_alpha_prime != 0.0F))
    {
        /* Switch: '<S2913>/Switch1' incorporates:
         *  Product: '<S2913>/Division'
         */
        rtb_Switch1_pm /= KeTHMR_k_alpha_prime;
    }
    else if (rtb_Switch1_pm > 0.0F)
    {
        /* Switch: '<S2913>/Switch2' incorporates:
         *  Constant: '<S2913>/MAXFLOAT'
         *  Switch: '<S2913>/Switch1'
         */
        rtb_Switch1_pm = 3.402823466E+38F;
    }
    else if (rtb_Switch1_pm < 0.0F)
    {
        /* Switch: '<S2913>/Switch3' incorporates:
         *  Constant: '<S2913>/MINFLOAT'
         *  Switch: '<S2913>/Switch1'
         *  Switch: '<S2913>/Switch2'
         */
        rtb_Switch1_pm = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2913>/Switch1' incorporates:
         *  Constant: '<S2913>/ConstantValue4'
         *  Switch: '<S2913>/Switch2'
         *  Switch: '<S2913>/Switch3'
         */
        rtb_Switch1_pm = 0.0F;
    }

    /* End of Switch: '<S2913>/Switch1' */
    /* End of Outputs for SubSystem: '<S2905>/ProtectedDivision' */

    /* Switch: '<S2865>/Switch5' incorporates:
     *  Constant: '<S2896>/Calib'
     *  Constant: '<S2897>/Calib'
     *  Switch: '<S2865>/Switch6'
     */
    if (KeTHMR_b_PIM_Enbl_Branch1)
    {
        /* Switch: '<S2865>/Switch5' */
        rtb_Switch1_muc = rtb_VariantMerge_For_Variant_So;
    }
    else if (KeTHMR_b_PIM_Enbl_Branch2)
    {
        /* Switch: '<S2865>/Switch6' incorporates:
         *  Switch: '<S2865>/Switch5'
         */
        rtb_Switch1_muc = rtb_TmpSignalConversionAtVeT_fy;
    }
    else
    {
        /* Switch: '<S2865>/Switch5' incorporates:
         *  Switch: '<S2865>/Switch6'
         */
        rtb_Switch1_muc = rtb_TmpSignalConversionAtVeTM_n;
    }

    /* End of Switch: '<S2865>/Switch5' */

    /* Outputs for Atomic SubSystem: '<S2905>/ProtectedDivision1' */
    /* Switch: '<S2914>/Switch1' incorporates:
     *  Constant: '<S2905>/ConstantValue'
     *  Constant: '<S2912>/Calib'
     *  Constant: '<S2914>/ConstantValue'
     *  Constant: '<S2914>/ConstantValue1'
     *  Constant: '<S2914>/ConstantValue2'
     *  Constant: '<S2914>/ConstantValue3'
     *  Logic: '<S2914>/AND'
     *  RelationalOperator: '<S2914>/GreaterThanorEqual'
     *  RelationalOperator: '<S2914>/GreaterThanorEqual1'
     *  RelationalOperator: '<S2914>/NotEqual'
     *  RelationalOperator: '<S2914>/NotEqual1'
     *  Sum: '<S2905>/Subtraction'
     *  Switch: '<S2914>/Switch2'
     *  Switch: '<S2914>/Switch3'
     */
    if ((rtb_Switch1_muc != 0.0F) && ((1.0F - KeTHMR_k_alpha_prime) != 0.0F))
    {
        /* Switch: '<S2914>/Switch1' incorporates:
         *  Product: '<S2914>/Division'
         */
        rtb_Add4_m1 = rtb_Switch1_muc / (1.0F - KeTHMR_k_alpha_prime);
    }
    else if (rtb_Switch1_muc > 0.0F)
    {
        /* Switch: '<S2914>/Switch2' incorporates:
         *  Constant: '<S2914>/MAXFLOAT'
         *  Switch: '<S2914>/Switch1'
         */
        rtb_Add4_m1 = 3.402823466E+38F;
    }
    else if (rtb_Switch1_muc < 0.0F)
    {
        /* Switch: '<S2914>/Switch3' incorporates:
         *  Constant: '<S2914>/MINFLOAT'
         *  Switch: '<S2914>/Switch1'
         *  Switch: '<S2914>/Switch2'
         */
        rtb_Add4_m1 = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2914>/Switch1' incorporates:
         *  Constant: '<S2914>/ConstantValue4'
         *  Switch: '<S2914>/Switch2'
         *  Switch: '<S2914>/Switch3'
         */
        rtb_Add4_m1 = 0.0F;
    }

    /* End of Switch: '<S2914>/Switch1' */
    /* End of Outputs for SubSystem: '<S2905>/ProtectedDivision1' */

    /* MinMax: '<S2905>/MinMax2' */
    rtb_Product_gg = fmaxf(rtb_Switch1_pm, rtb_Add4_m1);

    /* Switch: '<S2918>/Switch1' */
    if (rtb_RelationalOperator_nw)
    {
        /* Switch: '<S2918>/Switch1' incorporates:
         *  Constant: '<S2921>/Calib'
         */
        rtb_Switch1_pm = KeTHMR_dV_LTP_AftrRunPmp2FlowOvrrd;
    }
    else
    {
        /* Switch: '<S2918>/Switch1' */
        rtb_Switch1_pm = rtb_Product_gg;
    }

    /* End of Switch: '<S2918>/Switch1' */

    /* Sum: '<S2868>/Sum' */
    rtb_Add4_m1 = (rtb_VariantMerge_For_Variant_So +
                   rtb_TmpSignalConversionAtVeT_fy) +
        rtb_TmpSignalConversionAtVeTM_n;

    /* MinMax: '<S2906>/MinMax2' */
    VeTHMR_dV_ECM_LTPsvPmpFlw_Arb = fmaxf(rtb_Switch1_ofq, rtb_Switch1_muc);

    /* Switch: '<S2898>/Switch5' incorporates:
     *  Constant: '<S2900>/Calib'
     */
    if (KeTHMR_b_ECM_LTPsvPmpRq_Enbl)
    {
        /* Switch: '<S2898>/Switch5' */
        rtb_Switch1_ofq = VeTHMR_dV_ECM_LTPsvPmpFlw_Arb;
    }
    else
    {
        /* Switch: '<S2898>/Switch5' incorporates:
         *  Constant: '<S2905>/ConstantValue'
         *  Constant: '<S2912>/Calib'
         *  Product: '<S2905>/Product'
         *  Sum: '<S2905>/Subtraction'
         */
        rtb_Switch1_ofq = (1.0F - KeTHMR_k_alpha_prime) * rtb_Product_gg;
    }

    /* End of Switch: '<S2898>/Switch5' */

    /* SignalConversion generated from: '<S2898>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    /* UnitDelay: '<S2841>/UnitDelay' */
    rtb_UnitDelay_oqi = rtb_Switch1_ofq;

#else

    /* Outputs for Atomic SubSystem: '<S2898>/Limiter' */
    /* Switch: '<S2903>/Switch1' incorporates:
     *  Constant: '<S2901>/Calib'
     *  RelationalOperator: '<S2903>/RelationalOperator'
     */
    if (KeTHMR_dV_LT_PsvPmpFlw_Max < rtb_Switch1_ofq)
    {
        /* Switch: '<S2859>/Switch1' */
        rtb_Product_gg = KeTHMR_dV_LT_PsvPmpFlw_Max;
    }
    else
    {
        /* Switch: '<S2859>/Switch1' */
        rtb_Product_gg = rtb_Switch1_ofq;
    }

    /* End of Switch: '<S2903>/Switch1' */

    /* Switch: '<S2903>/Switch' incorporates:
     *  Constant: '<S2902>/Calib'
     *  RelationalOperator: '<S2903>/RelationalOperator1'
     */
    if (rtb_Product_gg > KeTHMR_dV_LT_PsvPmpFlw_Min)
    {
        /* UnitDelay: '<S2841>/UnitDelay' incorporates:
         *  SignalConversion generated from: '<S2898>/VariantSource'
         */
        rtb_UnitDelay_oqi = rtb_Product_gg;
    }
    else
    {
        /* UnitDelay: '<S2841>/UnitDelay' incorporates:
         *  SignalConversion generated from: '<S2898>/VariantSource'
         */
        rtb_UnitDelay_oqi = KeTHMR_dV_LT_PsvPmpFlw_Min;
    }

    /* End of Switch: '<S2903>/Switch' */
    /* End of Outputs for SubSystem: '<S2898>/Limiter' */
#endif

    /* End of SignalConversion generated from: '<S2898>/VariantSource' */

    /* Switch: '<S2919>/Switch1' */
    if (rtb_RelationalOperator_nw)
    {
        /* Switch: '<S2919>/Switch1' incorporates:
         *  Constant: '<S2922>/Calib'
         */
        rtb_Switch1_muc = KeTHMR_dV_LTP_AftrRunPmpFlowOvrrd;
    }
    else
    {
        /* Switch: '<S2919>/Switch1' */
        rtb_Switch1_muc = rtb_UnitDelay_oqi;
    }

    /* End of Switch: '<S2919>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeUBTR_T_EstUndrhoodTemp' */
    (void)Rte_Read_VeUBTR_T_EstUndrhoodTemp_Value(&rtb_Add2_m);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Switch: '<S2803>/Switch15' incorporates:
     *  Constant: '<S2808>/Calib'
     *  Constant: '<S2813>/Calib'
     *  Switch: '<S2803>/Switch2'
     */
    if (KeTHMR_b_UseActFlw4FanCntrol)
    {
        rtb_Switch10 = rtb_TmpSignalConversionAtVePM_d;
    }
    else if (KeTHMR_b_DualPmpsIn_LTCL)
    {
        /* Switch: '<S2803>/Switch2' */
        rtb_Switch10 = rtb_Add4_m1;
    }
    else
    {
        rtb_Switch10 = rtb_Switch1_muc;
    }

    /* End of Switch: '<S2803>/Switch15' */

    /* Product: '<S2803>/Product2' incorporates:
     *  Constant: '<S2806>/Calib'
     */
    VeTHMR_dV_ClntFlwRt_ThruLTR_B4Grd = KeTHMR_Cf_VlmtrcFlwAddtn_CrrctnFctr *
        rtb_Switch10;

    /* Outputs for Atomic SubSystem: '<S2803>/Limiter' */
    /* Switch: '<S2827>/Switch1' incorporates:
     *  Constant: '<S2816>/Calib'
     *  RelationalOperator: '<S2827>/RelationalOperator'
     */
    if (KeTHMR_dV_MaxAllwdFlw_ThruLTR < VeTHMR_dV_ClntFlwRt_ThruLTR_B4Grd)
    {
        /* UnitDelay: '<S2841>/UnitDelay' */
        rtb_UnitDelay_oqi = KeTHMR_dV_MaxAllwdFlw_ThruLTR;
    }
    else
    {
        /* UnitDelay: '<S2841>/UnitDelay' */
        rtb_UnitDelay_oqi = VeTHMR_dV_ClntFlwRt_ThruLTR_B4Grd;
    }

    /* End of Switch: '<S2827>/Switch1' */

    /* Switch: '<S2827>/Switch' incorporates:
     *  Constant: '<S2817>/Calib'
     *  RelationalOperator: '<S2827>/RelationalOperator1'
     */
    if (rtb_UnitDelay_oqi > KeTHMR_dV_MinAllwdFlw_ThruLTR)
    {
        /* Switch: '<S2827>/Switch' */
        VeTHMR_dV_ClntFlwRt_ThruLTR_AftLim = rtb_UnitDelay_oqi;
    }
    else
    {
        /* Switch: '<S2827>/Switch' */
        VeTHMR_dV_ClntFlwRt_ThruLTR_AftLim = KeTHMR_dV_MinAllwdFlw_ThruLTR;
    }

    /* End of Switch: '<S2827>/Switch' */
    /* End of Outputs for SubSystem: '<S2803>/Limiter' */

    /* Sum: '<S2803>/Subtraction' */
    rtb_Merge1_i = THMR_ac_B.VariantMerge_Fo_p - VeTHMR_T_PPCTISTgt_Fan;

    /* Switch: '<S2804>/Switch1' incorporates:
     *  Constant: '<S2846>/Calib'
     *  Constant: '<S2849>/Calib'
     *  Switch: '<S2804>/Switch8'
     */
    if (KeTHMR_b_MGU_AirInletTmp_UseIntakeTmp)
    {
        /* Switch: '<S2804>/Switch8' incorporates:
         *  Constant: '<S2846>/Calib'
         */
        if (KeTHMR_b_AirTempSourceSel)
        {
            /* Switch: '<S2804>/Switch1' */
            VeTHMR_T_MGU_AirInletTmp = rtb_Add2_m;
        }
        else
        {
            /* Switch: '<S2804>/Switch1' */
            VeTHMR_T_MGU_AirInletTmp = VeTHMR_T_InductionAirTemp_AD;
        }
    }
    else
    {
        if (!KeTHMR_b_AirTempSourceSel)
        {
            /* Switch: '<S2804>/Switch8' */
            rtb_Add2_m = VeTHMR_T_InductionAirTemp_AD;
        }

        /* Switch: '<S2804>/Switch1' incorporates:
         *  Lookup_n-D: '<S2854>/Vector'
         *  Sum: '<S2804>/Subtraction2'
         *  Switch: '<S3944>/Switch'
         */
        VeTHMR_T_MGU_AirInletTmp = rtb_Add2_m + look1_iflf_binlcapw
            (VeTHMR_v_Vehicle, ((const float32 *)
                                &(KxTHMR_T_MGU_AirInletTmp_Offset[0])), ((const
               float32 *)&(KtTHMR_T_MGU_AirInletTmp_Offset[0])), 11U);
    }

    /* End of Switch: '<S2804>/Switch1' */

    /* Switch: '<S2803>/Switch10' incorporates:
     *  Constant: '<S2809>/Calib'
     *  Switch: '<S2803>/Switch7'
     */
    if (rtb_Logical6_fk)
    {
        /* Switch: '<S2803>/Switch10' incorporates:
         *  Constant: '<S2815>/Calib'
         */
        VeTHMR_dV_LTR_AirFlowRaw = KeTHMR_dV_LTCL_DT_BSG_HeatRejectNo_Fan;
    }
    else
    {
        if (KeTHMR_b_LTCL_HeatRejctFcn_OfFlw)
        {
            /* Switch: '<S2803>/Switch1' incorporates:
             *  Constant: '<S2812>/Calib'
             *  Switch: '<S2803>/Switch7'
             */
            if (KeTHMR_b_PECP2_Enbl)
            {
                rtb_Switch10 = rtb_Switch1_pm;
            }
            else
            {
                rtb_Switch10 = VeTHMR_dV_ClntFlwRt_ThruLTR_AftLim;
            }

            /* End of Switch: '<S2803>/Switch1' */
        }
        else
        {
            /* Switch: '<S2803>/Switch7' incorporates:
             *  Constant: '<S2818>/Calib'
             */
            rtb_Switch10 = KeTHMR_dV_NoPmpFlw_AirCooled;
        }

        /* Switch: '<S2803>/Switch9' incorporates:
         *  Constant: '<S2810>/Calib'
         */
        if (KeTHMR_b_LTR_AirFlw_UseAmb)
        {
            rtb_Switch15 = TmpSignalConversionAtOutAirTemp;
        }
        else
        {
            rtb_Switch15 = VeTHMR_T_MGU_AirInletTmp;
        }

        /* End of Switch: '<S2803>/Switch9' */

        /* Switch: '<S2803>/Switch10' incorporates:
         *  Lookup_n-D: '<S2821>/Vector'
         *  Lookup_n-D: '<S2824>/Vector'
         *  Sum: '<S2803>/Subtraction'
         */
        VeTHMR_dV_LTR_AirFlowRaw = look2_iflf_binlcapw(look2_iflf_binlcapw
            (rtb_Switch10, rtb_Merge1_i, ((const float32 *)
            &(KxTHMR_P_LTCL_Heat_Reject[0])), ((const float32 *)
            &(KyTHMR_P_LTCL_Heat_Reject[0])), ((const float32 *)
            &(KtTHMR_P_LTCL_Heat_Reject[0])), THMR_ac_ConstP.pooled34, 7U),
            rtb_Switch15, ((const float32 *)&(KxTHMR_dV_LTR_AirFlowRaw[0])), ((
            const float32 *)&(KyTHMR_dV_LTR_AirFlowRaw[0])), ((const float32 *)
            &(KtTHMR_dV_LTR_AirFlowRaw[0])), THMR_ac_ConstP.pooled34, 7U);
    }

    /* End of Switch: '<S2803>/Switch10' */

    /* SignalConversion generated from: '<S62>/LTR_AirFlowRaw_MBC_HTL_LTCL' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    /* VariantMerge generated from: '<S62>/PECP1_MBC_HTL_LTCL' */
    rtb_VM_Conditional_Signal_PECP1 = THMR_ac_B.Gain_l;

#else

    /* VariantMerge generated from: '<S62>/PECP1_MBC_HTL_LTCL' incorporates:
     *  SignalConversion generated from: '<S62>/LTR_AirFlowRaw_MBC_HTL_LTCL'
     */
    rtb_VM_Conditional_Signal_PECP1 = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S62>/LTR_AirFlowRaw_MBC_HTL_LTCL' */

    /* Switch: '<S2290>/Switch1' incorporates:
     *  Switch: '<S2289>/Switch1'
     */
    if (rtb_VM_Conditional_Signal_Use_M)
    {
        /* Switch: '<S2290>/Switch1' */
        rtb_Switch1_ofq = rtb_VM_Conditional_Signal_PECP1;
    }
    else if (rtb_TmpSignalConversionAtVeT_pw)
    {
        /* S-Function (fcgen): '<S62>/Function-CallGenerator' incorporates:
         *  SubSystem: '<S62>/FunctionCall'
         */
        /* S-Function (fcgen): '<S2288>/Function-CallGenerator1' incorporates:
         *  SubSystem: '<S62>/MBC_LTCL'
         */
        /* Switch: '<S2289>/Switch1' incorporates:
         *  SignalConversion generated from: '<S2295>/FanairFlow'
         *  Switch: '<S2290>/Switch1'
         */
        rtb_Switch1_ofq = Switch3_h[1];

        /* End of Outputs for S-Function (fcgen): '<S2288>/Function-CallGenerator1' */
        /* End of Outputs for S-Function (fcgen): '<S62>/Function-CallGenerator' */
    }
    else
    {
        /* Switch: '<S2290>/Switch1' incorporates:
         *  Switch: '<S2289>/Switch1'
         */
        rtb_Switch1_ofq = VeTHMR_dV_LTR_AirFlowRaw;
    }

    /* End of Switch: '<S2290>/Switch1' */

    /* SignalConversion generated from: '<S62>/LTCL_Vlv_Pos_MBC_HTL_LTCL' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    /* VariantMerge generated from: '<S62>/LTCL_Vlv_Pos_MBC_HTL_LTCL' */
    rtb_VM_Conditional_Signal_LTCL_ = THMR_ac_B.Gain_p;

#else

    /* VariantMerge generated from: '<S62>/LTCL_Vlv_Pos_MBC_HTL_LTCL' incorporates:
     *  SignalConversion generated from: '<S62>/LTCL_Vlv_Pos_MBC_HTL_LTCL'
     */
    rtb_VM_Conditional_Signal_LTCL_ = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S62>/LTCL_Vlv_Pos_MBC_HTL_LTCL' */

    /* If: '<S2293>/LTCL_Valve_Pos_Dflt' incorporates:
     *  Constant: '<S2748>/Calib'
     */
    rtPrevAction = THMR_ac_DW.LTCL_Valve_Pos_Dflt_ActiveSubsy;
    rtAction = (sint8)((!KeTHMR_b_DsblLTRVlv_PropCntrl) ? 1 : 0);
    THMR_ac_DW.LTCL_Valve_Pos_Dflt_ActiveSubsy = rtAction;
    if (rtAction == 0)
    {
        /* Outputs for IfAction SubSystem: '<S2293>/LTCL_Cooling_Pos_Dflt' incorporates:
         *  ActionPort: '<S2751>/ActionPort'
         */
        /* Merge: '<S2293>/Merge2' incorporates:
         *  Constant: '<S2760>/Calib'
         *  SignalConversion generated from: '<S2751>/Clsd'
         */
        VeTHMR_Pct_LTRVlvDflt = KeTHMR_Pct_LTRVlv_CntThruRad;

        /* End of Outputs for SubSystem: '<S2293>/LTCL_Cooling_Pos_Dflt' */
    }
    else
    {
        if (1 != rtPrevAction)
        {
            /* InitializeConditions for IfAction SubSystem: '<S2293>/LTR_Vlv_Prop_Cntrlr' incorporates:
             *  ActionPort: '<S2755>/ActionPort'
             */
            /* InitializeConditions for If: '<S2293>/LTCL_Valve_Pos_Dflt' incorporates:
             *  UnitDelay: '<S2794>/UnitDelay'
             */
            THMR_ac_DW.UnitDelay_DSTATE_pe = 0.0F;

            /* End of InitializeConditions for SubSystem: '<S2293>/LTR_Vlv_Prop_Cntrlr' */

            /* SystemReset for IfAction SubSystem: '<S2293>/LTR_Vlv_Prop_Cntrlr' incorporates:
             *  ActionPort: '<S2755>/ActionPort'
             */
            /* SystemReset for Atomic SubSystem: '<S2755>/EdgeRising' */
            /* SystemReset for If: '<S2293>/LTCL_Valve_Pos_Dflt' incorporates:
             *  UnitDelay: '<S2767>/UnitDelay'
             *  UnitDelay: '<S2793>/UnitDelay'
             *  UnitDelay: '<S2793>/UnitDelay1'
             */
            THMR_ac_DW.UnitDelay_DSTATE_e01 = false;

            /* End of SystemReset for SubSystem: '<S2755>/EdgeRising' */

            /* SystemReset for Atomic SubSystem: '<S2755>/PIDControl' */
            THMR_ac_DW.UnitDelay1_DSTATE_be = 0.0F;
            THMR_ac_DW.UnitDelay_DSTATE_ka = 0.0F;

            /* End of SystemReset for SubSystem: '<S2755>/PIDControl' */
            /* End of SystemReset for SubSystem: '<S2293>/LTR_Vlv_Prop_Cntrlr' */
        }

        /* Outputs for IfAction SubSystem: '<S2293>/LTR_Vlv_Prop_Cntrlr' incorporates:
         *  ActionPort: '<S2755>/ActionPort'
         */
        /* Product: '<S2763>/Product1' incorporates:
         *  Constant: '<S2795>/Calib'
         */
        rtb_UnitDelay_oqi = rtb_TmpSignalConversionAtVePM_d *
            KeTHMR_K_LTRVlv_LTCLFlowActConvert;

        /* Sum: '<S2764>/Add1' incorporates:
         *  Constant: '<S2796>/Calib'
         */
        rtb_TmpSignalConversionAtVePM_d = TmpSignalConversionAtOutAirTemp +
            KeTHMR_Cf_LTRVlv_degCtoKTempConvert;

        /* Sum: '<S2765>/Add2' incorporates:
         *  Constant: '<S2797>/Calib'
         */
        rtb_Add2_m = THMR_ac_B.VariantMerge_Fo_p +
            KeTHMR_Cf_LTRVlv_degCtoKTempConvert;

        /* Sum: '<S2766>/Add1' incorporates:
         *  Constant: '<S2798>/Calib'
         */
        rtb_Product_gg = THMR_ac_B.Switch5_o +
            KeTHMR_Cf_LTRVlv_degCtoKTempConvert;

        /* Outputs for Atomic SubSystem: '<S2755>/EdgeRising' */
        /* Logic: '<S2767>/OR1' incorporates:
         *  UnitDelay: '<S2767>/UnitDelay'
         */
        rtb_RelationalOperator_nw = !THMR_ac_DW.UnitDelay_DSTATE_e01;

        /* Update for UnitDelay: '<S2767>/UnitDelay' incorporates:
         *  Constant: '<S2755>/TRUEConstant'
         */
        THMR_ac_DW.UnitDelay_DSTATE_e01 = true;

        /* End of Outputs for SubSystem: '<S2755>/EdgeRising' */

        /* Lookup_n-D: '<S2790>/Vector' incorporates:
         *  Switch: '<S3944>/Switch'
         */
        rtb_Switch1_i3 = look1_iflf_binlcapw(VeTHMR_v_Vehicle, ((const float32 *)
            &(KxTHMR_dV_LTRVlv_RadAirFlowRate_LookUp[0])), ((const float32 *)
            &(KtTHMR_dV_LTRVlv_RadAirFlowRate_LookUp[0])), 12U);

        /* Outputs for Atomic SubSystem: '<S2755>/PIDControl' */
        /* Outputs for Atomic SubSystem: '<S2755>/EdgeRising' */
        /* Switch: '<S2793>/Switch' incorporates:
         *  Logic: '<S2767>/AND'
         */
        if (rtb_RelationalOperator_nw)
        {
            /* Switch: '<S2793>/Switch' incorporates:
             *  Constant: '<S2775>/Calib'
             */
            rtb_Switch_ii = KeTHMR_Pct_LTRVlvInit;
        }
        else
        {
            /* Switch: '<S2793>/Switch' incorporates:
             *  Constant: '<S2755>/Constant1'
             *  Constant: '<S2771>/Calib'
             *  Product: '<S2793>/Multiplication1'
             *  Sum: '<S2793>/Sum//Sub'
             *  UnitDelay: '<S2793>/UnitDelay'
             */
            rtb_Switch_ii = ((THMR_ac_B.Add * KeTHMR_K_LTRVlvBalncing_Ki) * 0.1F)
                + THMR_ac_DW.UnitDelay_DSTATE_ka;
        }

        /* End of Switch: '<S2793>/Switch' */
        /* End of Outputs for SubSystem: '<S2755>/EdgeRising' */

        /* Outputs for Atomic SubSystem: '<S2793>/integral_term' */
        /* Switch: '<S2799>/Switch1' incorporates:
         *  Constant: '<S2776>/Calib'
         *  RelationalOperator: '<S2799>/RelationalOperator'
         */
        if (KeTHMR_Pct_LTRVlvPI_Max < rtb_Switch_ii)
        {
            /* Switch: '<S2802>/Switch1' */
            rtb_Merge8 = KeTHMR_Pct_LTRVlvPI_Max;
        }
        else
        {
            /* Switch: '<S2802>/Switch1' */
            rtb_Merge8 = rtb_Switch_ii;
        }

        /* End of Switch: '<S2799>/Switch1' */

        /* Switch: '<S2799>/Switch' incorporates:
         *  Constant: '<S2777>/Calib'
         *  RelationalOperator: '<S2799>/RelationalOperator1'
         */
        if (rtb_Merge8 > KeTHMR_Pct_LTRVlvPI_Min)
        {
            /* Switch: '<S2799>/Switch' */
            rtb_Switch_ii = rtb_Merge8;
        }
        else
        {
            /* Switch: '<S2799>/Switch' */
            rtb_Switch_ii = KeTHMR_Pct_LTRVlvPI_Min;
        }

        /* End of Switch: '<S2799>/Switch' */
        /* End of Outputs for SubSystem: '<S2793>/integral_term' */
        /* End of Outputs for SubSystem: '<S2755>/PIDControl' */

        /* MATLAB Function: '<S2755>/Mc_Rad_Solver' incorporates:
         *  Constant: '<S2768>/Calib'
         *  Constant: '<S2782>/Calib'
         *  Constant: '<S2783>/Calib'
         *  Constant: '<S2788>/Calib'
         *  Constant: '<S2789>/Calib'
         */
        /* MATLAB Function 'THMR_FUNC_RU_MedTEH/LTCL/LTCL_Vlv_Pct/LTR_Vlv_Prop_Cntrlr/Mc_Rad_Solver': '<S2792>:1' */
        /* '<S2792>:1:13' */
        rtb_Merge8 = KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[0];

        /* '<S2792>:1:14' */
        rtb_UnitDelay_nr = KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[1];

        /* '<S2792>:1:15' */
        rtb_Switch15 = KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[2];

        /* '<S2792>:1:16' */
        rtb_Switch10 = KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[3];

        /* '<S2792>:1:17' */
        rtb_Switch11 = KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[4];

        /* '<S2792>:1:18' */
        rtb_Switch1_he = KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[5];

        /* '<S2792>:1:19' */
        if ((rtb_Switch1_i3 >= 0.0F) && (rtb_UnitDelay_oqi > 0.0F))
        {
            /* '<S2792>:1:30' */
            if (KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[0] > 0.0F)
            {
                /* '<S2792>:1:30' */
                if (KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[2] > 0.0F)
                {
                    /* '<S2792>:1:30' */
                    if (KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[4] > 0.0F)
                    {
                        /* '<S2792>:1:30' */
                        /* '<S2792>:1:31' */
                        /* '<S2792>:1:157' */
                        /* '<S2792>:1:158' */
                        /* '<S2792>:1:159' */
                        rtb_UnitDelay_cui = powf(rtb_UnitDelay_oqi,
                            KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[1]);
                        rtb_Switch1_nmk = powf(rtb_Switch1_i3,
                                               KaTHMR_k_LTRVlv_LTRHeatRejCurvParams
                                               [3]);
                        rtb_UnitDelay_cui = 1.0F - expf(-(((rtb_Switch1_nmk *
                            rtb_UnitDelay_cui) /
                            ((KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[2] *
                              rtb_UnitDelay_cui) +
                             (KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[0] *
                              rtb_Switch1_nmk))) /
                            KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[4]));
                    }
                    else
                    {
                        /* '<S2792>:1:33' */
                        rtb_UnitDelay_cui = 0.0F;
                    }
                }
                else
                {
                    /* '<S2792>:1:33' */
                    rtb_UnitDelay_cui = 0.0F;
                }
            }
            else
            {
                /* '<S2792>:1:33' */
                rtb_UnitDelay_cui = 0.0F;
            }
        }
        else
        {
            /* '<S2792>:1:33' */
            rtb_UnitDelay_cui = 0.0F;
        }

        if (rtb_UnitDelay_oqi == 0.0F)
        {
            /* '<S2792>:1:36' */
            /* '<S2792>:1:39' */
            rtb_UnitDelay_oqi = 1.0F;
        }
        else if ((rtb_Switch1_i3 < 0.0F) || (rtb_UnitDelay_oqi < 0.0F))
        {
            /* '<S2792>:1:40' */
            /* '<S2792>:1:43' */
            rtb_UnitDelay_oqi = 1.0F;
        }
        else if (KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[0] <= 0.0F)
        {
            /* '<S2792>:1:40' */
            /* '<S2792>:1:43' */
            rtb_UnitDelay_oqi = 1.0F;
        }
        else if (KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[1] <= 0.0F)
        {
            /* '<S2792>:1:40' */
            /* '<S2792>:1:43' */
            rtb_UnitDelay_oqi = 1.0F;
        }
        else if (KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[2] <= 0.0F)
        {
            /* '<S2792>:1:40' */
            /* '<S2792>:1:43' */
            rtb_UnitDelay_oqi = 1.0F;
        }
        else if (KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[3] <= 0.0F)
        {
            /* '<S2792>:1:40' */
            /* '<S2792>:1:43' */
            rtb_UnitDelay_oqi = 1.0F;
        }
        else if (KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[4] <= 0.0F)
        {
            /* '<S2792>:1:40' */
            /* '<S2792>:1:43' */
            rtb_UnitDelay_oqi = 1.0F;
        }
        else if (KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[5] <= 0.0F)
        {
            /* '<S2792>:1:40' */
            /* '<S2792>:1:43' */
            rtb_UnitDelay_oqi = 1.0F;
        }
        else if (KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[6] <= 0.0F)
        {
            /* '<S2792>:1:40' */
            /* '<S2792>:1:43' */
            rtb_UnitDelay_oqi = 1.0F;
        }
        else if ((KeTHMR_b_LTRVlv_SlvForPositionVlvOpn) &&
                 (KeTHMR_dV_LTRVlv_McLTRIni <= 0.0F))
        {
            /* '<S2792>:1:40' */
            /* '<S2792>:1:43' */
            rtb_UnitDelay_oqi = 1.0F;
        }
        else if (rtb_Product_gg >= rtb_Add2_m)
        {
            /* '<S2792>:1:44' */
            /* '<S2792>:1:47' */
            rtb_UnitDelay_oqi = 0.0F;
        }
        else if (rtb_TmpSignalConversionAtVePM_d >= rtb_Add2_m)
        {
            /* '<S2792>:1:48' */
            /* '<S2792>:1:50' */
            rtb_UnitDelay_oqi = 1.0F;
        }
        else if (rtb_Product_gg <= rtb_TmpSignalConversionAtVePM_d)
        {
            /* '<S2792>:1:51' */
            /* '<S2792>:1:55' */
            rtb_UnitDelay_oqi = 1.0F;
        }
        else if (((rtb_Add2_m - rtb_Product_gg) * rtb_UnitDelay_oqi) >=
                 ((KaTHMR_k_LTRVlv_LTRHeatRejCurvParams[5] * rtb_UnitDelay_cui) *
                  (rtb_Add2_m - rtb_TmpSignalConversionAtVePM_d)))
        {
            /* '<S2792>:1:56' */
            /* '<S2792>:1:59' */
            rtb_UnitDelay_oqi = 1.0F;
        }
        else
        {
            if (KeTHMR_b_LTRVlv_SlvForPositionVlvOpn)
            {
                /* '<S2792>:1:61' */
                /* '<S2792>:1:62' */
                rtb_Switch1_pn[0] = KeTHMR_dV_LTRVlv_McLTRIni;

                /* '<S2792>:1:63' */
                rtb_UnitDelay_oqi = 1.0F;

                /* '<S2792>:1:64' */
            }
            else
            {
                /* '<S2792>:1:66' */
                rtb_Switch1_pn[0] = 0.5F;

                /* '<S2792>:1:67' */
                /* '<S2792>:1:68' */
            }

            /* '<S2792>:1:70' */
            /* '<S2792>:1:71' */
            /* '<S2792>:1:92' */
            rtb_Switch1_pn[1] = rtb_Product_gg;

            /* '<S2792>:1:93' */
            rtb_UnitDelay_cui = 2.0F * KeTHMR_k_LTRVlv_StepSzTooSmallThrshld;

            /* '<S2792>:1:97' */
            iteration_count = 0U;
            do
            {
                exitg1 = 0;

                /* '<S2792>:1:101' */
                /* '<S2792>:1:103' */
                /* '<S2792>:1:157' */
                /* '<S2792>:1:158' */
                rtb_Switch1_c5k = rtb_UnitDelay_oqi * rtb_Switch1_pn[0];
                rtb_Switch1_nmk = powf(rtb_Switch1_c5k, rtb_UnitDelay_nr);
                rtb_UnitDelay_od = ((powf(rtb_Switch1_i3, rtb_Switch10) *
                                     rtb_Switch1_nmk) / ((rtb_Switch15 *
                                      rtb_Switch1_nmk) + (rtb_Merge8 * powf
                                      (rtb_Switch1_i3, rtb_Switch10)))) /
                    rtb_Switch11;

                /* '<S2792>:1:159' */
                /* '<S2792>:1:105' */
                /* '<S2792>:1:165' */
                /* '<S2792>:1:166' */
                /* '<S2792>:1:168' */
                dy_dx_i_idx_0 = expf(-rtb_UnitDelay_od);
                rtb_Switch1_oje = rtb_Add2_m - rtb_Switch1_pn[1];
                rtb_UnitDelay_bv = rtb_Add2_m - rtb_TmpSignalConversionAtVePM_d;
                y[0] = (rtb_Switch1_c5k * rtb_Switch1_oje) - (((1.0F -
                    dy_dx_i_idx_0) * rtb_Switch1_he) * rtb_UnitDelay_bv);
                y[1] = (((1.0F - rtb_Switch1_pn[0]) * rtb_Add2_m) +
                        (rtb_Switch1_pn[0] * rtb_Switch1_pn[1])) -
                    rtb_Product_gg;

                /* '<S2792>:1:106' */
                /* '<S2792>:1:175' */
                /* '<S2792>:1:176' */
                /* '<S2792>:1:177' */
                rtb_Switch1_c5k = (powf(rtb_UnitDelay_oqi * rtb_Switch1_pn[0],
                                        rtb_UnitDelay_nr) * rtb_Switch15) +
                    (rtb_Merge8 * powf(rtb_Switch1_i3, rtb_Switch10));

                /* '<S2792>:1:178' */
                /* '<S2792>:1:179' */
                /* '<S2792>:1:180' */
                /* '<S2792>:1:181' */
                /* '<S2792>:1:182' */
                /* '<S2792>:1:183' */
                /* '<S2792>:1:186' */
                dy_dx_i_idx_0 = (rtb_Switch1_oje * rtb_UnitDelay_oqi) -
                    (((((((rtb_Merge8 * rtb_UnitDelay_nr) * powf(rtb_Switch1_i3,
                           2.0F * rtb_Switch10)) * rtb_Switch1_nmk) /
                        ((rtb_Switch1_c5k * rtb_Switch1_c5k) * rtb_Switch1_pn[0]))
                       * ((1.0F / rtb_Switch11) * dy_dx_i_idx_0)) *
                      rtb_Switch1_he) * rtb_UnitDelay_bv);
                rtb_UnitDelay_od = ((-rtb_UnitDelay_oqi) * rtb_Switch1_pn[0]) -
                    ((1.0F - expf(-rtb_UnitDelay_od)) * rtb_Switch1_he);
                rtb_Switch1_c5k = (-rtb_Add2_m) + rtb_Switch1_pn[1];

                /* '<S2792>:1:107' */
                /* '<S2792>:1:192' */
                rtb_Switch1_nmk = (dy_dx_i_idx_0 * rtb_Switch1_pn[0]) -
                    (rtb_UnitDelay_od * rtb_Switch1_c5k);

                /* '<S2792>:1:108' */
                /* '<S2792>:1:247' */
                for (i = 0; i < 2; i++)
                {
                    rtb_UnitDelay_bv = y[i];
                    x_i[i] = rtb_Switch1_pn[i];
                    z1[i] = rtb_UnitDelay_bv * rtb_UnitDelay_bv;
                }

                rtb_RelationalOperator_nw = (sqrtf(z1[0] + z1[1]) <
                    KeTHMR_k_LTRVlv_FcnRsdTooSmallThrshld);

                /* '<S2792>:1:109' */
                rtb_TmpSignalConversionAtVeT_f5 = (rtb_UnitDelay_cui <
                    KeTHMR_k_LTRVlv_StepSzTooSmallThrshld);
                if (rtb_TmpSignalConversionAtVeT_f5 && rtb_RelationalOperator_nw)
                {
                    /* '<S2792>:1:110' */
                    /* '<S2792>:1:112' */
                    flag_solver = CeTHMR_e_Cnvrgd_1stOrdOptimal;
                    exitg1 = 1;
                }
                else if (rtb_TmpSignalConversionAtVeT_f5 &&
                         (!rtb_RelationalOperator_nw))
                {
                    /* '<S2792>:1:114' */
                    /* '<S2792>:1:116' */
                    flag_solver = CeTHMR_e_Cnvrgd_DeltaXBlwTol;
                    exitg1 = 1;
                }
                else if ((!rtb_TmpSignalConversionAtVeT_f5) &&
                         rtb_RelationalOperator_nw)
                {
                    /* '<S2792>:1:118' */
                    /* '<S2792>:1:120' */
                    flag_solver = CeTHMR_e_Cnvrgd_FcnRsdBlwTol;
                    exitg1 = 1;
                }
                else if (fabsf(rtb_Switch1_nmk) <
                         KeTHMR_k_LTRVlv_DetJcbTooSmallThrshld)
                {
                    /* '<S2792>:1:122' */
                    /* '<S2792>:1:125' */
                    flag_solver = CeTHMR_e_Fail_DetJcbBlwTol;
                    exitg1 = 1;
                }
                else
                {
                    /* '<S2792>:1:129' */
                    /* '<S2792>:1:197' */
                    rtb_UnitDelay_cui = 1.0F / rtb_Switch1_nmk;

                    /* '<S2792>:1:198' */
                    /* '<S2792>:1:130' */
                    rtb_UnitDelay_buv[0] = rtb_UnitDelay_cui * rtb_Switch1_pn[0];
                    rtb_UnitDelay_buv[2] = rtb_UnitDelay_cui *
                        (-rtb_UnitDelay_od);
                    rtb_UnitDelay_buv[1] = rtb_UnitDelay_cui * (-rtb_Switch1_c5k);
                    rtb_UnitDelay_buv[3] = rtb_UnitDelay_cui * dy_dx_i_idx_0;

                    /* '<S2792>:1:131' */
                    /* '<S2792>:1:247' */
                    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 <
                            2; rtb_DataTypeConversion2++)
                    {
                        srch_dir[rtb_DataTypeConversion2] = 0.0F;
                        for (i = 0; i < 2; i++)
                        {
                            srch_dir[rtb_DataTypeConversion2] +=
                                rtb_UnitDelay_buv[(i * 2) +
                                rtb_DataTypeConversion2] * y[i];
                        }

                        z1[rtb_DataTypeConversion2] =
                            srch_dir[rtb_DataTypeConversion2] *
                            srch_dir[rtb_DataTypeConversion2];
                    }

                    if (sqrtf(z1[0] + z1[1]) < KeTHMR_k_LTRVlv_SrchDirThrshld)
                    {
                        /* '<S2792>:1:132' */
                        /* '<S2792>:1:134' */
                        flag_solver = CeTHMR_e_Cnvrgd_SrchDirMgBlwTol;
                        exitg1 = 1;
                    }
                    else if (((float32)iteration_count) >=
                             KeTHMR_Cnt_LTRVlv_SlvrMaxIter)
                    {
                        /* '<S2792>:1:136' */
                        /* '<S2792>:1:138' */
                        flag_solver = CeTHMR_e_Fail_MaxIterCntExcd;
                        exitg1 = 1;
                    }
                    else
                    {
                        /* '<S2792>:1:145' */
                        /* '<S2792>:1:203' */
                        /* '<S2792>:1:204' */
                        /* '<S2792>:1:205' */
                        rtb_UnitDelay_cui = 1.0F;
                        if (srch_dir[0] > 0.0F)
                        {
                            /* '<S2792>:1:206' */
                            if (rtb_Switch1_pn[0] >=
                                    KeTHMR_k_LTRVlv_McStepSizeThrshld)
                            {
                                /* '<S2792>:1:207' */
                                /* '<S2792>:1:208' */
                                rtb_UnitDelay_cui = (rtb_Switch1_pn[0] -
                                                     KeTHMR_k_LTRVlv_McStepSizeThrshld)
                                    / srch_dir[0];
                            }
                            else
                            {
                                /* '<S2792>:1:211' */
                                rtb_UnitDelay_cui = 0.0F;
                            }
                        }
                        else
                        {
                            if (srch_dir[0] < 0.0F)
                            {
                                /* '<S2792>:1:213' */
                                if (rtb_Switch1_pn[0] <= 1.0F)
                                {
                                    /* '<S2792>:1:214' */
                                    /* '<S2792>:1:215' */
                                    rtb_UnitDelay_cui = (1.0F - rtb_Switch1_pn[0])
                                        / (-srch_dir[0]);
                                }
                                else
                                {
                                    /* '<S2792>:1:218' */
                                    rtb_UnitDelay_cui = 0.0F;
                                }
                            }
                        }

                        /* '<S2792>:1:221' */
                        rtb_Switch1_nmk = 1.0F;
                        if (srch_dir[1] > 0.0F)
                        {
                            /* '<S2792>:1:222' */
                            if (rtb_Switch1_pn[1] >=
                                    rtb_TmpSignalConversionAtVePM_d)
                            {
                                /* '<S2792>:1:223' */
                                /* '<S2792>:1:224' */
                                rtb_Switch1_nmk = (rtb_Switch1_pn[1] -
                                                   rtb_TmpSignalConversionAtVePM_d)
                                    / srch_dir[1];
                            }
                            else
                            {
                                /* '<S2792>:1:227' */
                                rtb_Switch1_nmk = 0.0F;
                            }
                        }
                        else
                        {
                            if (srch_dir[1] < 0.0F)
                            {
                                /* '<S2792>:1:229' */
                                if (rtb_Add2_m >= rtb_Switch1_pn[1])
                                {
                                    /* '<S2792>:1:230' */
                                    /* '<S2792>:1:231' */
                                    rtb_Switch1_nmk = rtb_Switch1_oje /
                                        (-srch_dir[1]);
                                }
                                else
                                {
                                    /* '<S2792>:1:234' */
                                    rtb_Switch1_nmk = 0.0F;
                                }
                            }
                        }

                        /* '<S2792>:1:237' */
                        /* '<S2792>:1:238' */
                        if (rtb_UnitDelay_cui > rtb_Switch1_nmk)
                        {
                            rtb_UnitDelay_cui = rtb_Switch1_nmk;
                        }

                        rtb_UnitDelay_cui = fminf(1.0F, fmaxf(0.0F,
                            rtb_UnitDelay_cui));

                        /* '<S2792>:1:146' */
                        /* '<S2792>:1:147' */
                        /* '<S2792>:1:243' */
                        for (rtb_DataTypeConversion2 = 0;
                                rtb_DataTypeConversion2 < 2;
                                rtb_DataTypeConversion2++)
                        {
                            rtb_Switch1_nmk =
                                rtb_Switch1_pn[rtb_DataTypeConversion2] -
                                (rtb_UnitDelay_cui *
                                 srch_dir[rtb_DataTypeConversion2]);
                            rtb_UnitDelay_od = rtb_Switch1_nmk -
                                x_i[rtb_DataTypeConversion2];
                            z1[rtb_DataTypeConversion2] = rtb_UnitDelay_od *
                                rtb_UnitDelay_od;
                            rtb_Switch1_pn[rtb_DataTypeConversion2] =
                                rtb_Switch1_nmk;
                            x_i[rtb_DataTypeConversion2] = rtb_UnitDelay_od;
                        }

                        rtb_UnitDelay_cui = sqrtf(z1[0] + z1[1]);

                        /* '<S2792>:1:148' */
                        i = (sint32)((uint32)(((uint32)iteration_count) + 1U));
                        if ((((uint32)iteration_count) + 1U) > 255U)
                        {
                            i = 255;
                        }

                        iteration_count = (uint8)i;
                    }
                }
            }
            while (exitg1 == 0);

            /* '<S2792>:1:151' */
            if ((((uint32)flag_solver) == CeTHMR_e_Cnvrgd_1stOrdOptimal) ||
                    (((uint32)flag_solver) == CeTHMR_e_Cnvrgd_FcnRsdBlwTol))
            {
                /* '<S2792>:1:72' */
                if (rtb_Switch1_pn[0] >= 0.0F)
                {
                    /* '<S2792>:1:73' */
                    if (rtb_Switch1_pn[0] <= 1.0F)
                    {
                        /* '<S2792>:1:73' */
                        /* '<S2792>:1:75' */
                        rtb_UnitDelay_oqi = rtb_Switch1_pn[0];
                    }
                    else
                    {
                        /* '<S2792>:1:78' */
                        rtb_UnitDelay_oqi =
                            KeTHMR_r_LTRVlv_DfltPos4SlvrCnvrgdButOutRng;
                    }
                }
                else
                {
                    /* '<S2792>:1:78' */
                    rtb_UnitDelay_oqi =
                        KeTHMR_r_LTRVlv_DfltPos4SlvrCnvrgdButOutRng;
                }
            }
            else
            {
                /* '<S2792>:1:82' */
                rtb_UnitDelay_oqi = 1.0F;
            }
        }

        /* End of MATLAB Function: '<S2755>/Mc_Rad_Solver' */

        /* Switch: '<S2755>/Switch3' incorporates:
         *  Constant: '<S2781>/Calib'
         */
        if (KeTHMR_b_LTRVlv_SlctPIvPhysics)
        {
            /* Outputs for Atomic SubSystem: '<S2755>/PIDControl' */
            /* Switch: '<S2755>/Switch3' incorporates:
             *  Constant: '<S2755>/Constant1'
             *  Constant: '<S2770>/Calib'
             *  Constant: '<S2772>/Calib'
             *  Product: '<S2793>/Multiplication2'
             *  Product: '<S2793>/derivative_term'
             *  Product: '<S2793>/proportional_term'
             *  Sum: '<S2793>/Sum//Sub1'
             *  Sum: '<S2793>/Sum//Sub2'
             *  UnitDelay: '<S2793>/UnitDelay1'
             */
            rtb_UnitDelay_oqi = (((THMR_ac_B.Add -
                                   THMR_ac_DW.UnitDelay1_DSTATE_be) *
                                  KeTHMR_K_LTRVlvBalncing_Kd) / 0.1F) +
                ((THMR_ac_B.Add * KeTHMR_K_LTRVlvBalncing_Kp) + rtb_Switch_ii);

            /* End of Outputs for SubSystem: '<S2755>/PIDControl' */
        }
        else
        {
            /* Switch: '<S2755>/Switch3' incorporates:
             *  Constant: '<S2755>/Constant6'
             *  Product: '<S2755>/Product'
             */
            rtb_UnitDelay_oqi *= 100.0F;
        }

        /* End of Switch: '<S2755>/Switch3' */

        /* Outputs for Atomic SubSystem: '<S2755>/Limiter1' */
        /* Switch: '<S2791>/Switch1' incorporates:
         *  Constant: '<S2773>/Calib'
         *  RelationalOperator: '<S2791>/RelationalOperator'
         */
        if (KeTHMR_Pct_LTRVlvCmd_Max < rtb_UnitDelay_oqi)
        {
            /* Switch: '<S2802>/Switch1' */
            rtb_Merge8 = KeTHMR_Pct_LTRVlvCmd_Max;
        }
        else
        {
            /* Switch: '<S2802>/Switch1' */
            rtb_Merge8 = rtb_UnitDelay_oqi;
        }

        /* End of Switch: '<S2791>/Switch1' */

        /* Switch: '<S2791>/Switch' incorporates:
         *  Constant: '<S2774>/Calib'
         *  RelationalOperator: '<S2791>/RelationalOperator1'
         */
        if (rtb_Merge8 > KeTHMR_Pct_LTRVlvCmd_Min)
        {
            /* Switch: '<S2791>/Switch' */
            VeTHMR_Pct_LTRVlv_PICmd = rtb_Merge8;
        }
        else
        {
            /* Switch: '<S2791>/Switch' */
            VeTHMR_Pct_LTRVlv_PICmd = KeTHMR_Pct_LTRVlvCmd_Min;
        }

        /* End of Switch: '<S2791>/Switch' */
        /* End of Outputs for SubSystem: '<S2755>/Limiter1' */

        /* Sum: '<S2794>/Sum2' incorporates:
         *  UnitDelay: '<S2794>/UnitDelay'
         */
        rtb_UnitDelay_oqi = VeTHMR_Pct_LTRVlv_PICmd -
            THMR_ac_DW.UnitDelay_DSTATE_pe;

        /* Switch: '<S2800>/Switch1' incorporates:
         *  Constant: '<S2778>/Calib'
         *  RelationalOperator: '<S2794>/Comparison1'
         *  UnitDelay: '<S2794>/UnitDelay'
         */
        if (THMR_ac_DW.UnitDelay_DSTATE_pe < KeTHMR_Pct_LTRVlv_MinRampPct)
        {
            /* Switch: '<S2800>/Switch1' incorporates:
             *  Constant: '<S2780>/Calib'
             *  MinMax: '<S2794>/MinMax'
             *  MinMax: '<S2794>/MinMax1'
             *  Sum: '<S2794>/Sum1'
             */
            rtb_TmpSignalConversionAtVePM_d = fmaxf(fminf
                (KeTHMR_Pct_LTRVlv_MinRampPct - THMR_ac_DW.UnitDelay_DSTATE_pe,
                 rtb_UnitDelay_oqi), KeTHMR_Pct_LTRVlv_RmpRateLim_Up);
        }
        else
        {
            /* Switch: '<S2800>/Switch1' incorporates:
             *  Constant: '<S2780>/Calib'
             */
            rtb_TmpSignalConversionAtVePM_d = KeTHMR_Pct_LTRVlv_RmpRateLim_Up;
        }

        /* End of Switch: '<S2800>/Switch1' */

        /* Outputs for Atomic SubSystem: '<S2794>/integral_term' */
        /* Switch: '<S2802>/Switch1' incorporates:
         *  RelationalOperator: '<S2802>/RelationalOperator'
         */
        if (rtb_TmpSignalConversionAtVePM_d < rtb_UnitDelay_oqi)
        {
            /* Switch: '<S2802>/Switch1' */
            rtb_Merge8 = rtb_TmpSignalConversionAtVePM_d;
        }
        else
        {
            /* Switch: '<S2802>/Switch1' */
            rtb_Merge8 = rtb_UnitDelay_oqi;
        }

        /* End of Switch: '<S2802>/Switch1' */

        /* Switch: '<S2802>/Switch' incorporates:
         *  Constant: '<S2779>/Calib'
         *  RelationalOperator: '<S2802>/RelationalOperator1'
         */
        if (rtb_Merge8 <= KeTHMR_Pct_LTRVlv_RmpRateLim_Dwn)
        {
            rtb_Merge8 = KeTHMR_Pct_LTRVlv_RmpRateLim_Dwn;
        }

        /* End of Switch: '<S2802>/Switch' */
        /* End of Outputs for SubSystem: '<S2794>/integral_term' */

        /* Sum: '<S2794>/Sum3' incorporates:
         *  UnitDelay: '<S2794>/UnitDelay'
         */
        VeTHMR_Pct_LTRVlv_Balancing = rtb_Merge8 +
            THMR_ac_DW.UnitDelay_DSTATE_pe;

        /* Merge: '<S2293>/Merge2' incorporates:
         *  SignalConversion: '<S2755>/SignalConversion'
         */
        VeTHMR_Pct_LTRVlvDflt = VeTHMR_Pct_LTRVlv_Balancing;

        /* End of Outputs for SubSystem: '<S2293>/LTR_Vlv_Prop_Cntrlr' */
    }

    /* End of If: '<S2293>/LTCL_Valve_Pos_Dflt' */

    /* If: '<S2293>/LTCL_Valve_Pos' incorporates:
     *  Constant: '<S2743>/Constant'
     *  Constant: '<S2744>/Constant'
     *  Constant: '<S2745>/Constant'
     *  Constant: '<S2746>/Constant'
     *  Constant: '<S2747>/Constant'
     *  RelationalOperator: '<S2293>/Comparison1'
     *  RelationalOperator: '<S2293>/Comparison12'
     *  RelationalOperator: '<S2293>/Comparison2'
     *  RelationalOperator: '<S2293>/Comparison3'
     *  RelationalOperator: '<S2293>/Comparison4'
     */
    if (((uint32)rtb_Logical17_o_tmp) == CeTHMR_e_FCBoostCool)
    {
        /* Outputs for IfAction SubSystem: '<S2293>/LTCL_FCL_BoostCool' incorporates:
         *  ActionPort: '<S2753>/ActionPort'
         */
        /* Merge: '<S2293>/Merge1' incorporates:
         *  Constant: '<S2761>/Calib'
         *  SignalConversion generated from: '<S2753>/Opn'
         */
        THMR_ac_B.VeTHMR_Pct_LTL_Vlv_Cmd = KeTHMR_Pct_LTRVlv_FCBoostCool;

        /* End of Outputs for SubSystem: '<S2293>/LTCL_FCL_BoostCool' */
    }
    else
    {
        /* RelationalOperator: '<S2293>/Comparison1' incorporates:
         *  Merge: '<S4575>/Merge'
         *  RelationalOperator: '<S2293>/Comparison12'
         *  RelationalOperator: '<S2293>/Comparison2'
         *  RelationalOperator: '<S2293>/Comparison3'
         */
        rtb_Logical1_bnh_tmp = THMR_ac_B.VeTHMR_e_LTCLRadVlvState;
        if (((uint32)rtb_Logical1_bnh_tmp) == CeTHMR_e_PsvCooling_LTCLVlvSt)
        {
            /* Outputs for IfAction SubSystem: '<S2293>/LTCL_Cooling_Pos' incorporates:
             *  ActionPort: '<S2750>/ActionPort'
             */
            /* Switch: '<S2758>/Switch1' incorporates:
             *  Switch: '<S2757>/Switch1'
             */
            if (rtb_VM_Conditional_Signal_Use_M)
            {
                /* Merge: '<S2293>/Merge1' */
                THMR_ac_B.VeTHMR_Pct_LTL_Vlv_Cmd =
                    rtb_VM_Conditional_Signal_LTCL_;
            }
            else if (rtb_TmpSignalConversionAtVeT_pw)
            {
                /* Switch: '<S2757>/Switch1' incorporates:
                 *  Merge: '<S2293>/Merge1'
                 */
                THMR_ac_B.VeTHMR_Pct_LTL_Vlv_Cmd = Switch3_h[0];
            }
            else
            {
                /* Merge: '<S2293>/Merge1' incorporates:
                 *  Constant: '<S2759>/Calib'
                 *  Switch: '<S2757>/Switch1'
                 */
                THMR_ac_B.VeTHMR_Pct_LTL_Vlv_Cmd = KeTHMR_Pct_LTRVlv_CntThruRad;
            }

            /* End of Switch: '<S2758>/Switch1' */
            /* End of Outputs for SubSystem: '<S2293>/LTCL_Cooling_Pos' */
        }
        else if (((uint32)rtb_Logical1_bnh_tmp) == CeTHMR_e_Blocked_LTCLVlvSt)
        {
            /* Outputs for IfAction SubSystem: '<S2293>/LTCL_Blocked_Pos' incorporates:
             *  ActionPort: '<S2749>/ActionPort'
             */
            /* Merge: '<S2293>/Merge1' incorporates:
             *  Constant: '<S2756>/Calib'
             *  SignalConversion generated from: '<S2749>/Block'
             */
            THMR_ac_B.VeTHMR_Pct_LTL_Vlv_Cmd = KeTHMR_Pct_LTRVlv_BlockRad;

            /* End of Outputs for SubSystem: '<S2293>/LTCL_Blocked_Pos' */
        }
        else if (((uint32)rtb_Logical1_bnh_tmp) == CeTHMR_e_PsvHeating_LTCLVlvSt)
        {
            /* Outputs for IfAction SubSystem: '<S2293>/LTCL_Heating_Pos' incorporates:
             *  ActionPort: '<S2754>/ActionPort'
             */
            /* Merge: '<S2293>/Merge1' incorporates:
             *  Constant: '<S2762>/Calib'
             *  SignalConversion generated from: '<S2754>/Opn'
             */
            THMR_ac_B.VeTHMR_Pct_LTL_Vlv_Cmd = KeTHMR_Pct_LTRVlv_BypassRad;

            /* End of Outputs for SubSystem: '<S2293>/LTCL_Heating_Pos' */
        }
        else
        {
            if (((uint32)rtb_Logical1_bnh_tmp) == CeTHMR_e_Balancing_LTCLVlvSt)
            {
                /* Outputs for IfAction SubSystem: '<S2293>/LTCL_Default_Pos' incorporates:
                 *  ActionPort: '<S2752>/ActionPort'
                 */
                THMR_ac_LTCL_Default_Pos(VeTHMR_Pct_LTRVlvDflt,
                    &THMR_ac_B.VeTHMR_Pct_LTL_Vlv_Cmd);

                /* End of Outputs for SubSystem: '<S2293>/LTCL_Default_Pos' */
            }
        }
    }

    /* End of If: '<S2293>/LTCL_Valve_Pos' */

    /* Lookup_n-D: '<S2822>/Vector' incorporates:
     *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
     *  Switch: '<S302>/Switch1'
     */
    rtb_VM_Conditional_Signal_LTCL_ = look2_iflf_binlcapw
        (TmpSignalConversionAtOutAirTemp, VeTHMR_p_HghRfrgtPres_Arb, ((const
           float32 *)&(KxTHMR_dV_HeadPresAir_Flow[0])), ((const float32 *)
          &(KyTHMR_dV_HeadPresAir_Flow[0])), ((const float32 *)
          &(KtTHMR_dV_HeadPresAir_Flow[0])), THMR_ac_ConstP.pooled34, 7U);

    /* Lookup_n-D: '<S2826>/Vector' incorporates:
     *  Switch: '<S2804>/Switch1'
     *  Switch: '<S3911>/Switch'
     */
    VeTHMR_dV_P1Motor_AirFlowRaw = look2_iflf_binlcapw(VeTHMR_T_MGU_AirInletTmp,
        VeTHMR_T_MtrA_Temp, ((const float32 *)&(KxTHMR_dV_P1Motor_AirFlowRaw[0])),
        ((const float32 *)&(KyTHMR_dV_P1Motor_AirFlowRaw[0])), ((const float32 *)
        &(KtTHMR_dV_P1Motor_AirFlowRaw[0])), THMR_ac_ConstP.pooled34, 7U);

    /* Outputs for Atomic SubSystem: '<S2831>/Hysteresis4' */
    /* Switch: '<S2834>/Switch1' incorporates:
     *  Constant: '<S2836>/Calib'
     *  RelationalOperator: '<S2834>/GreaterThan'
     */
    if (VeTHMR_p_HghRfrgtPres_Arb > KeTHMR_p_HtPmpIncldHeadPress)
    {
        /* Switch: '<S2834>/Switch1' incorporates:
         *  Constant: '<S2834>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeT_f5 = true;
    }
    else
    {
        /* Switch: '<S2834>/Switch1' incorporates:
         *  Constant: '<S2835>/Calib'
         *  RelationalOperator: '<S2834>/GreaterThan1'
         *  UnitDelay: '<S2834>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeT_f5 = ((VeTHMR_p_HghRfrgtPres_Arb >=
            KeTHMR_p_HtPmpDsrgrdHeadPress) && (THMR_ac_DW.UnitDelay_DSTATE_a1u));
    }

    /* End of Switch: '<S2834>/Switch1' */

    /* Update for UnitDelay: '<S2834>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_a1u = rtb_TmpSignalConversionAtVeT_f5;

    /* End of Outputs for SubSystem: '<S2831>/Hysteresis4' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/ThermalAirflow_Arb'
     */
    /* RelationalOperator: '<S62>/RelationalOperator' incorporates:
     *  Merge: '<S4570>/Merge3'
     *  RelationalOperator: '<S1216>/RelationalOperator0'
     *  RelationalOperator: '<S5387>/RelationalOperator'
     *  RelationalOperator: '<S5387>/RelationalOperator1'
     *  RelationalOperator: '<S5389>/RelationalOperator'
     *  RelationalOperator: '<S84>/RelationalOperator1'
     */
    VeTHMR_b_CompressorReqOn_0_tmp = THMR_ac_B.VeTHMR_e_CabHeatThermalMode;

    /* If: '<S2832>/If1' incorporates:
     *  Constant: '<S2287>/Constant'
     *  Logic: '<S2831>/LogicalOperator1'
     *  Logic: '<S2832>/LogicalOperator'
     *  RelationalOperator: '<S62>/RelationalOperator'
     *  Switch: '<S2803>/Switch3'
     */
    if (((uint32)VeTHMR_b_CompressorReqOn_0_tmp) != CeTHMR_e_HeatPump)
    {
        /* Outputs for IfAction SubSystem: '<S2832>/CondAirflow' incorporates:
         *  ActionPort: '<S2837>/ActionPort'
         */
        THMR_ac_CondAirflow(rtb_VM_Conditional_Signal_LTCL_, &THMR_ac_B.Merge);

        /* End of Outputs for SubSystem: '<S2832>/CondAirflow' */
    }
    else if (rtb_TmpSignalConversionAtVeT_f5)
    {
        /* Switch: '<S2803>/Switch3' incorporates:
         *  Constant: '<S2803>/Constant1'
         *  Lookup_n-D: '<S2823>/Vector'
         *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
         *  Switch: '<S2161>/Switch'
         */
        if (VeTHMR_b_CabHeatPumpAllowOhx)
        {
            rtb_Switch10 = look2_iflf_binlcapw(TmpSignalConversionAtOutAirTemp,
                VeTHMR_p_eACSuctnPress, ((const float32 *)
                &(KxTHMR_dV_HeatPumpAir_Flow[0])), ((const float32 *)
                &(KyTHMR_dV_HeatPumpAir_Flow[0])), ((const float32 *)
                &(KtTHMR_dV_HeatPumpAir_Flow[0])), THMR_ac_ConstP.pooled34, 7U);
        }
        else
        {
            rtb_Switch10 = 0.0F;
        }

        /* Outputs for IfAction SubSystem: '<S2832>/oHX_Cond_Airflow' incorporates:
         *  ActionPort: '<S2839>/ActionPort'
         */
        /* Merge: '<S2832>/Merge' incorporates:
         *  MinMax: '<S2839>/MinMax'
         */
        THMR_ac_B.Merge = fmaxf(rtb_VM_Conditional_Signal_LTCL_, rtb_Switch10);

        /* End of Outputs for SubSystem: '<S2832>/oHX_Cond_Airflow' */
    }
    else
    {
        if (VeTHMR_b_CabHeatPumpAllowOhx)
        {
            /* Switch: '<S2803>/Switch3' incorporates:
             *  Lookup_n-D: '<S2823>/Vector'
             *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
             *  Switch: '<S2161>/Switch'
             */
            rtb_Switch10 = look2_iflf_binlcapw(TmpSignalConversionAtOutAirTemp,
                VeTHMR_p_eACSuctnPress, ((const float32 *)
                &(KxTHMR_dV_HeatPumpAir_Flow[0])), ((const float32 *)
                &(KyTHMR_dV_HeatPumpAir_Flow[0])), ((const float32 *)
                &(KtTHMR_dV_HeatPumpAir_Flow[0])), THMR_ac_ConstP.pooled34, 7U);
        }
        else
        {
            /* Switch: '<S2803>/Switch3' incorporates:
             *  Constant: '<S2803>/Constant1'
             */
            rtb_Switch10 = 0.0F;
        }

        /* Outputs for IfAction SubSystem: '<S2832>/oHXAirflow' incorporates:
         *  ActionPort: '<S2838>/ActionPort'
         */
        THMR_ac_CondAirflow(rtb_Switch10, &THMR_ac_B.Merge);

        /* End of Outputs for SubSystem: '<S2832>/oHXAirflow' */
    }

    /* End of If: '<S2832>/If1' */

    /* Switch: '<S2803>/Switch11' incorporates:
     *  Switch: '<S2803>/Switch12'
     */
    if (rtb_Logical6_fk)
    {
        /* Switch: '<S2803>/Switch11' incorporates:
         *  Constant: '<S2819>/Calib'
         */
        rtb_TmpSignalConversionAtVePM_d = KeTHMR_dV_P1MotorDsblECTHotVal;

        /* Switch: '<S2803>/Switch12' incorporates:
         *  Constant: '<S2814>/Calib'
         */
        rtb_Add2_m = KeTHMR_dV_HeadPresDsblECTHotVal;
    }
    else
    {
        /* Switch: '<S2803>/Switch11' */
        rtb_TmpSignalConversionAtVePM_d = VeTHMR_dV_P1Motor_AirFlowRaw;

        /* Switch: '<S2830>/Switch5' incorporates:
         *  Constant: '<S2830>/Constant'
         *  Constant: '<S2833>/Calib'
         */
        if (THMR_ac_B.AND_j)
        {
            rtb_Switch10 = KeTHMR_dV_DeIce_CondAirFlow;
        }
        else
        {
            rtb_Switch10 = 0.0F;
        }

        /* End of Switch: '<S2830>/Switch5' */

        /* Switch: '<S2803>/Switch12' incorporates:
         *  MinMax: '<S2829>/MinMax'
         */
        rtb_Add2_m = fmaxf(rtb_Switch10, THMR_ac_B.Merge);
    }

    /* End of Switch: '<S2803>/Switch11' */

    /* Outputs for Atomic SubSystem: '<S2803>/ProtectedDivision' */
    /* Switch: '<S2828>/Switch1' incorporates:
     *  Constant: '<S2828>/ConstantValue'
     *  RelationalOperator: '<S2828>/NotEqual'
     */
    if (rtb_TmpSignalConversionAtVeT_je != 0.0F)
    {
        /* Switch: '<S2828>/Switch1' incorporates:
         *  Constant: '<S2803>/ConstantValue'
         *  Product: '<S2828>/Division'
         */
        rtb_TmpSignalConversionAtVeT_je /= 100.0F;
    }
    else
    {
        /* Switch: '<S2828>/Switch1' incorporates:
         *  Constant: '<S2828>/ConstantValue4'
         *  Switch: '<S2828>/Switch2'
         *  Switch: '<S2828>/Switch3'
         */
        rtb_TmpSignalConversionAtVeT_je = 0.0F;
    }

    /* End of Switch: '<S2828>/Switch1' */
    /* End of Outputs for SubSystem: '<S2803>/ProtectedDivision' */

    /* Product: '<S2803>/Product1' incorporates:
     *  Constant: '<S2820>/Calib'
     */
    VeTHMR_n_BSG_LTR_PmpSpdAct = rtb_TmpSignalConversionAtVeT_je *
        KeTHMR_n_BSG_LTR_PmpSpdAct_Max;

    /* Lookup_n-D: '<S2825>/Vector' incorporates:
     *  Product: '<S2803>/Product1'
     *  Switch: '<S39>/Switch4'
     */
    VeTHMR_dV_MGU_ClntPumpFlw_B4D = look2_iflf_binlcapw
        (VeTHMR_n_BSG_LTR_PmpSpdAct, Switch4_d, ((const float32 *)
          &(KxTHMR_dV_MGU_ClntPumpFlw[0])), ((const float32 *)
          &(KyTHMR_dV_MGU_ClntPumpFlw[0])), ((const float32 *)
          &(KtTHMR_dV_MGU_ClntPumpFlw[0])), THMR_ac_ConstP.pooled34, 7U);

    /* Switch: '<S2804>/Switch5' incorporates:
     *  Constant: '<S2847>/Calib'
     *  Constant: '<S2848>/Calib'
     *  Switch: '<S2804>/Switch7'
     */
    if (KeTHMR_b_EngSpdInc_AppSel)
    {
        /* Switch: '<S2804>/Switch6' incorporates:
         *  Constant: '<S2850>/Calib'
         *  RelationalOperator: '<S2804>/Comparison4'
         *  Sum: '<S2804>/Subtraction'
         *  UnitDelay: '<S2804>/UnitDelay'
         */
        if (VeTHMR_T_MGU_InvrtTmpCond >= (THMR_ac_DW.UnitDelay_DSTATE_fr +
                KeTHMR_dT_InvrtTmpCond_Incrs))
        {
            /* Switch: '<S2804>/Switch5' incorporates:
             *  Lookup_n-D: '<S2855>/Vector'
             *  Switch: '<S2804>/Switch4'
             *  Switch: '<S2804>/Switch6'
             */
            rtb_TmpSignalConversionAtVeT_je = look1_iflf_binlcapw
                (VeTHMR_T_MGU_InvrtTmpCond, ((const float32 *)
                  &(KxTHMR_n_EngSpdInc_ReqHysUp[0])), ((const float32 *)
                  &(KtTHMR_n_EngSpdInc_ReqHysUp[0])), 7U);
        }
        else
        {
            /* Switch: '<S2804>/Switch5' incorporates:
             *  Constant: '<S2851>/Calib'
             *  Lookup_n-D: '<S2855>/Vector'
             *  Sum: '<S2804>/Subtraction1'
             *  Switch: '<S2804>/Switch4'
             *  Switch: '<S2804>/Switch6'
             */
            rtb_TmpSignalConversionAtVeT_je = look1_iflf_binlcapw
                (VeTHMR_T_MGU_InvrtTmpCond, ((const float32 *)
                  &(KxTHMR_n_EngSpdInc_ReqHysUp[0])), ((const float32 *)
                  &(KtTHMR_n_EngSpdInc_ReqHysUp[0])), 7U) +
                KeTHMR_n_EngIncrsHys_RPM;
        }

        /* End of Switch: '<S2804>/Switch6' */
    }
    else
    {
        if (KeTHMR_b_EngSpdInc_TempSel)
        {
            /* Switch: '<S2804>/Switch7' */
            rtb_Switch10 = VeTHMR_T_MtrA_Temp;
        }
        else
        {
            /* Switch: '<S2804>/Switch7' */
            rtb_Switch10 = VeTHMR_T_MGU_InvrtTmpCond;
        }

        /* Switch: '<S2804>/Switch5' incorporates:
         *  Lookup_n-D: '<S2856>/Vector'
         *  Switch: '<S2804>/Switch1'
         */
        rtb_TmpSignalConversionAtVeT_je = look2_iflf_binlcapw
            (VeTHMR_T_MGU_AirInletTmp, rtb_Switch10, ((const float32 *)
              &(KxTHMR_n_P1Motor_EngSpdInc[0])), ((const float32 *)
              &(KyTHMR_n_P1Motor_EngSpdInc[0])), ((const float32 *)
              &(KtTHMR_n_P1Motor_EngSpdInc[0])), THMR_ac_ConstP.pooled47, 7U);
    }

    /* End of Switch: '<S2804>/Switch5' */

    /* Outputs for Atomic SubSystem: '<S2804>/GradientLimiter1' */
    /* UnitDelay: '<S2841>/UnitDelay' */
    rtb_UnitDelay_oqi = THMR_ac_DW.UnitDelay_DSTATE_m2;

    /* Sum: '<S2841>/Sum2' */
    rtb_TmpSignalConversionAtVeT_je -= rtb_UnitDelay_oqi;

    /* Outputs for Atomic SubSystem: '<S2841>/Limiter' */
    /* Switch: '<S2859>/Switch1' incorporates:
     *  Constant: '<S2853>/Calib'
     *  RelationalOperator: '<S2859>/RelationalOperator'
     */
    if (KeTHMR_n_EngSpdInc_Req_Up < rtb_TmpSignalConversionAtVeT_je)
    {
        /* Switch: '<S2859>/Switch1' */
        rtb_Product_gg = KeTHMR_n_EngSpdInc_Req_Up;
    }
    else
    {
        /* Switch: '<S2859>/Switch1' */
        rtb_Product_gg = rtb_TmpSignalConversionAtVeT_je;
    }

    /* End of Switch: '<S2859>/Switch1' */

    /* Switch: '<S2859>/Switch' incorporates:
     *  Constant: '<S2852>/Calib'
     *  RelationalOperator: '<S2859>/RelationalOperator1'
     */
    if (rtb_Product_gg <= KeTHMR_n_EngSpdInc_Req_Dwn)
    {
        rtb_Product_gg = KeTHMR_n_EngSpdInc_Req_Dwn;
    }

    /* End of Switch: '<S2859>/Switch' */
    /* End of Outputs for SubSystem: '<S2841>/Limiter' */

    /* Sum: '<S2841>/Sum3' */
    VeTHMR_n_EngSpdInc_Req_BD = rtb_Product_gg + rtb_UnitDelay_oqi;

    /* Update for UnitDelay: '<S2841>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_m2 = VeTHMR_n_EngSpdInc_Req_BD;

    /* End of Outputs for SubSystem: '<S2804>/GradientLimiter1' */

    /* Switch: '<S2928>/Switch2' incorporates:
     *  Constant: '<S2987>/Calib'
     *  Constant: '<S2988>/Calib'
     *  Switch: '<S2928>/Switch4'
     */
    if (KeTHMR_b_LTPP_Enbl_Branch1)
    {
        /* Update for UnitDelay: '<S2928>/UnitDelay' incorporates:
         *  Switch: '<S2928>/Switch2'
         */
        THMR_ac_DW.UnitDelay_DSTATE_hr = rtb_VariantMerge_For_Variant_So;
    }
    else if (KeTHMR_b_LTPP_Enbl_Branch2)
    {
        /* Switch: '<S2928>/Switch4' incorporates:
         *  Switch: '<S2928>/Switch2'
         *  UnitDelay: '<S2928>/UnitDelay'
         */
        THMR_ac_DW.UnitDelay_DSTATE_hr = rtb_TmpSignalConversionAtVeT_fy;
    }
    else
    {
        /* Update for UnitDelay: '<S2928>/UnitDelay' incorporates:
         *  Switch: '<S2928>/Switch2'
         *  Switch: '<S2928>/Switch4'
         */
        THMR_ac_DW.UnitDelay_DSTATE_hr = rtb_TmpSignalConversionAtVeTM_n;
    }

    /* End of Switch: '<S2928>/Switch2' */

    /* Switch: '<S2928>/Switch5' incorporates:
     *  Constant: '<S2985>/Calib'
     *  Constant: '<S2986>/Calib'
     *  Switch: '<S2928>/Switch6'
     */
    if (KeTHMR_b_LTPP2_Enbl_Branch1)
    {
        /* Update for UnitDelay: '<S2928>/UnitDelay1' incorporates:
         *  Switch: '<S2928>/Switch5'
         */
        THMR_ac_DW.UnitDelay1_DSTATE_ly = rtb_VariantMerge_For_Variant_So;
    }
    else if (KeTHMR_b_LTPP2_Enbl_Branch2)
    {
        /* Switch: '<S2928>/Switch6' incorporates:
         *  Switch: '<S2928>/Switch5'
         *  UnitDelay: '<S2928>/UnitDelay1'
         */
        THMR_ac_DW.UnitDelay1_DSTATE_ly = rtb_TmpSignalConversionAtVeT_fy;
    }
    else
    {
        /* Update for UnitDelay: '<S2928>/UnitDelay1' incorporates:
         *  Switch: '<S2928>/Switch5'
         *  Switch: '<S2928>/Switch6'
         */
        THMR_ac_DW.UnitDelay1_DSTATE_ly = rtb_TmpSignalConversionAtVeTM_n;
    }

    /* End of Switch: '<S2928>/Switch5' */

    /* SignalConversion generated from: '<S62>/LINVlvCalibr_Req' incorporates:
     *  Constant: '<S2313>/Calib'
     */
    THMR_ac_B.OutportBufferForLINVlvCalibr_Re = KeTHMR_b_LINPrplVlv_CalibReqOvrd;

    /* SignalConversion generated from: '<S62>/PECP2_MBC_HTL_LTCL' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    /* VariantMerge generated from: '<S62>/PECP1_MBC_HTL_LTCL' */
    rtb_VM_Conditional_Signal_PECP1 = THMR_ac_B.Gain_o;

#else

    /* VariantMerge generated from: '<S62>/PECP1_MBC_HTL_LTCL' incorporates:
     *  SignalConversion generated from: '<S62>/PECP2_MBC_HTL_LTCL'
     */
    rtb_VM_Conditional_Signal_PECP1 = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S62>/PECP2_MBC_HTL_LTCL' */

    /* Switch: '<S62>/Switch1' */
    if (rtb_VM_Conditional_Signal_Use_M)
    {
        /* SignalConversion generated from: '<S2>/LTL_PECP2_MBC' incorporates:
         *  Outport: '<Root>/VeTHMR_n_LTLPECP2MBC'
         */
        (void)Rte_Write_VeTHMR_n_LTLPECP2MBC_Value
            (rtb_VM_Conditional_Signal_PECP1);
    }
    else
    {
        /* SignalConversion generated from: '<S2>/LTL_PECP2_MBC' incorporates:
         *  Outport: '<Root>/VeTHMR_n_LTLPECP2MBC'
         */
        (void)Rte_Write_VeTHMR_n_LTLPECP2MBC_Value(VeTHMR_n_LTLPECP2_MBC);
    }

    /* End of Switch: '<S62>/Switch1' */

    /* SignalConversion generated from: '<S62>/PECP1_MBC_HTL_LTCL' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    /* VariantMerge generated from: '<S62>/PECP1_MBC_HTL_LTCL' */
    rtb_VM_Conditional_Signal_PECP1 = THMR_ac_B.Gain_c;

#else

    /* VariantMerge generated from: '<S62>/PECP1_MBC_HTL_LTCL' incorporates:
     *  SignalConversion generated from: '<S62>/PECP1_MBC_HTL_LTCL'
     */
    rtb_VM_Conditional_Signal_PECP1 = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S62>/PECP1_MBC_HTL_LTCL' */

    /* Switch: '<S62>/Switch3' incorporates:
     *  Logic: '<S62>/Logical2'
     */
    if (rtb_TmpSignalConversionAtVeT_pw &&
            (THMR_ac_B.OutportBufferForLTCLFBLEnbl))
    {
        /* Switch: '<S62>/Switch' incorporates:
         *  Constant: '<S2291>/Calib'
         */
        if (!KeTHMR_b_LTLFBL_LegFlow)
        {
            /* Switch: '<S62>/Switch4' incorporates:
             *  Constant: '<S2292>/Calib'
             */
            if (KeTHMR_b_LTLFBL_MBCFlow)
            {
                /* Switch: '<S62>/Switch3' incorporates:
                 *  Switch: '<S62>/Switch4'
                 */
                rtb_Add4_m1 = VeTHMR_dV_FBLTLFLOW;
            }
            else
            {
                /* Switch: '<S62>/Switch3' incorporates:
                 *  MinMax: '<S62>/MinMax'
                 *  Switch: '<S62>/Switch4'
                 */
                rtb_Add4_m1 = fmaxf(VeTHMR_dV_FBLTLFLOW, rtb_Add4_m1);
            }

            /* End of Switch: '<S62>/Switch4' */
        }

        /* End of Switch: '<S62>/Switch' */
    }

    /* End of Switch: '<S62>/Switch3' */

    /* Update for UnitDelay: '<S2279>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_dp = VeTHMR_r_AHH_StressFactor;

    /* Update for UnitDelay: '<S2722>/UnitDelay' incorporates:
     *  Switch: '<S2471>/Switch'
     */
    THMR_ac_DW.UnitDelay_DSTATE_it = rtb_Switch1_ald;

    /* Update for UnitDelay: '<S2722>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_ez = THMR_ac_B.OutportBufferForOut1;

    /* Update for UnitDelay: '<S2281>/UnitDelay' incorporates:
     *  Merge: '<S4575>/Merge1'
     */
    THMR_ac_DW.UnitDelay_DSTATE_jx = THMR_ac_B.VeTHMR_e_LTCLThrmlMode;

    /* Update for If: '<S2293>/LTCL_Valve_Pos_Dflt' */
    if (THMR_ac_DW.LTCL_Valve_Pos_Dflt_ActiveSubsy == 1)
    {
        /* Update for IfAction SubSystem: '<S2293>/LTR_Vlv_Prop_Cntrlr' incorporates:
         *  ActionPort: '<S2755>/ActionPort'
         */
        /* Update for Atomic SubSystem: '<S2755>/PIDControl' */
        /* Update for UnitDelay: '<S2793>/UnitDelay1' */
        THMR_ac_DW.UnitDelay1_DSTATE_be = THMR_ac_B.Add;

        /* Update for UnitDelay: '<S2793>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_ka = rtb_Switch_ii;

        /* End of Update for SubSystem: '<S2755>/PIDControl' */

        /* Update for UnitDelay: '<S2794>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_pe = VeTHMR_Pct_LTRVlv_Balancing;

        /* End of Update for SubSystem: '<S2293>/LTR_Vlv_Prop_Cntrlr' */
    }

    /* End of Update for If: '<S2293>/LTCL_Valve_Pos_Dflt' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeFSCR_b_AGS_CalSuccess' */
    (void)Rte_Read_VeFSCR_b_AGS_CalSuccess_Value(&rtb_Logical2_ioz);

    /* Inport: '<Root>/VeTAIR_Pct_AGS_CurrPos' */
    (void)Rte_Read_VeTAIR_Pct_AGS_CurrPos_Value(&rtb_Vector_h00);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Update for UnitDelay: '<S2804>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_fr = VeTHMR_T_MGU_InvrtTmpCond;

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/ThermalAirflow_Arb'
     */
    /* Logic: '<S5361>/Logical2' incorporates:
     *  Constant: '<S5402>/Calib'
     *  Constant: '<S5404>/Constant1'
     *  Constant: '<S5404>/Constant2'
     *  Constant: '<S5406>/Constant1'
     *  Constant: '<S5406>/Constant2'
     *  Constant: '<S5408>/Calib'
     *  DataStoreRead: '<S5404>/StatusByte_AGS_A_Perf'
     *  DataStoreRead: '<S5406>/StatusByte_LostComm_AGS_A'
     *  Logic: '<S5397>/Logical3'
     *  Logic: '<S5404>/Logical Operator'
     *  Logic: '<S5406>/Logical Operator'
     *  RelationalOperator: '<S5361>/Comparison4'
     *  RelationalOperator: '<S5404>/Relational Operator1'
     *  RelationalOperator: '<S5404>/Relational Operator2'
     *  RelationalOperator: '<S5406>/Relational Operator1'
     *  RelationalOperator: '<S5406>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S5404>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S5404>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S5406>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S5406>/Bitwise Operator2'
     */
    rtb_Logical2_ioz = ((rtb_Vector_h00 >= KeTHMR_Pct_AGS_Rng2) &&
                        ((((((((uint32)THMR_ac_DW.StatusByte_AGS_A_Perf) & 1U)
        != 0U) && ((((uint32)THMR_ac_DW.StatusByte_AGS_A_Perf) & 64U) == 0U)) ||
                           (((((uint32)THMR_ac_DW.StatusByte_LostComm_AGS_A) &
        1U) != 0U) && ((((uint32)THMR_ac_DW.StatusByte_LostComm_AGS_A) & 64U) ==
                       0U))) || rtb_Logical2_ioz) || (KeTHMR_b_AGS_ChkOvrd)));

    /* Switch: '<S5398>/Switch1' incorporates:
     *  RelationalOperator: '<S5361>/RelationalOperator5'
     *  RelationalOperator: '<S5361>/RelationalOperator6'
     *  Switch: '<S5399>/Switch1'
     */
    if (((sint32)rtb_TmpSignalConversionAtVePRXR) == 0)
    {
        /* Switch: '<S5398>/Switch1' incorporates:
         *  Constant: '<S5403>/Calib'
         */
        rtb_Logical2_ioz = KeTHMR_b_AGSOpen;
    }
    else
    {
        if (((sint32)rtb_TmpSignalConversionAtVePRXR) != 1)
        {
            /* Switch: '<S5400>/Switch1' incorporates:
             *  Inport: '<Root>/VeFSCR_b_AGS2_CalSuccess'
             *  Inport: '<Root>/VeTAIR_Pct_AGS2_CurrPos'
             *  RelationalOperator: '<S5361>/RelationalOperator7'
             *  Switch: '<S5399>/Switch1'
             */
            if (((sint32)rtb_TmpSignalConversionAtVePRXR) == 2)
            {
                (void)Rte_Read_VeFSCR_b_AGS2_CalSuccess_Value(&rtb_OR1_jc2);
                (void)Rte_Read_VeTAIR_Pct_AGS2_CurrPos_Value(&rtb_Sum_e);

                /* Switch: '<S5398>/Switch1' incorporates:
                 *  Constant: '<S5401>/Calib'
                 *  Constant: '<S5405>/Constant1'
                 *  Constant: '<S5405>/Constant2'
                 *  Constant: '<S5407>/Constant1'
                 *  Constant: '<S5407>/Constant2'
                 *  Constant: '<S5408>/Calib'
                 *  DataStoreRead: '<S5405>/StatusByte_AGS_B_Perf'
                 *  DataStoreRead: '<S5407>/StatusByte_LostComm_AGS_B'
                 *  Inport: '<Root>/VeFSCR_b_AGS2_CalSuccess'
                 *  Inport: '<Root>/VeTAIR_Pct_AGS2_CurrPos'
                 *  Logic: '<S5361>/Logical1'
                 *  Logic: '<S5361>/Logical3'
                 *  Logic: '<S5397>/Logical1'
                 *  Logic: '<S5405>/Logical Operator'
                 *  Logic: '<S5407>/Logical Operator'
                 *  RelationalOperator: '<S5361>/Comparison1'
                 *  RelationalOperator: '<S5405>/Relational Operator1'
                 *  RelationalOperator: '<S5405>/Relational Operator2'
                 *  RelationalOperator: '<S5407>/Relational Operator1'
                 *  RelationalOperator: '<S5407>/Relational Operator2'
                 *  S-Function (sfix_bitop): '<S5405>/Bitwise Operator1'
                 *  S-Function (sfix_bitop): '<S5405>/Bitwise Operator2'
                 *  S-Function (sfix_bitop): '<S5407>/Bitwise Operator1'
                 *  S-Function (sfix_bitop): '<S5407>/Bitwise Operator2'
                 *  Switch: '<S5400>/Switch1'
                 */
                rtb_Logical2_ioz = (rtb_Logical2_ioz &&
                                    (((((KeTHMR_b_AGS_ChkOvrd) || (((((uint32)
                    THMR_ac_DW.StatusByte_AGS_B_Perf) & 1U) != 0U) && ((((uint32)
                    THMR_ac_DW.StatusByte_AGS_B_Perf) & 64U) == 0U))) ||
                                       (((((uint32)
                    THMR_ac_DW.StatusByte_LostComm_AGS_B) & 1U) != 0U) &&
                                        ((((uint32)
                    THMR_ac_DW.StatusByte_LostComm_AGS_B) & 64U) == 0U))) ||
                                      rtb_OR1_jc2) && (rtb_Sum_e >=
                                      KeTHMR_Pct_AGS2_Rng2)));
            }
            else
            {
                /* Switch: '<S5398>/Switch1' incorporates:
                 *  Constant: '<S5403>/Calib'
                 *  Switch: '<S5400>/Switch1'
                 */
                rtb_Logical2_ioz = KeTHMR_b_AGSOpen;
            }

            /* End of Switch: '<S5400>/Switch1' */
        }
    }

    /* End of Switch: '<S5398>/Switch1' */

    /* Switch: '<S5522>/Switch1' */
    if (THMR_ac_B.AND_j)
    {
        /* Switch: '<S5522>/Switch1' incorporates:
         *  Constant: '<S5523>/Calib'
         */
        rtb_Switch_ii = KeTHMR_dV_DeIce_CondAirFlow;
    }
    else
    {
        /* Switch: '<S5522>/Switch1' incorporates:
         *  Constant: '<S5387>/ConstantValue2'
         */
        rtb_Switch_ii = 0.0F;
    }

    /* End of Switch: '<S5522>/Switch1' */

    /* Sum: '<S5529>/Sum' incorporates:
     *  Lookup_n-D: '<S5576>/Vector'
     *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
     */
    rtb_Sum_e = look1_iflf_binlcapw(TmpSignalConversionAtOutAirTemp, ((const
        float32 *)&(KxTHMR_p_TgtPres[0])), ((const float32 *)&(KtTHMR_p_TgtPres
        [0])), 13U) - VeTHMR_p_HghRfrgtPres_Arb;

    /* Outputs for Atomic SubSystem: '<S5529>/EdgeRising' */
    /* Logic: '<S5567>/OR1' incorporates:
     *  UnitDelay: '<S5567>/UnitDelay'
     */
    rtb_OR1_jc2 = !THMR_ac_DW.UnitDelay_DSTATE_ku;

    /* Update for UnitDelay: '<S5567>/UnitDelay' incorporates:
     *  Constant: '<S5529>/TRUEConstant'
     */
    THMR_ac_DW.UnitDelay_DSTATE_ku = true;

    /* End of Outputs for SubSystem: '<S5529>/EdgeRising' */

    /* Lookup_n-D: '<S5526>/Vector' incorporates:
     *  Switch: '<S3944>/Switch'
     */
    rtb_Vector_h00 = look1_iflf_binlcapw(VeTHMR_v_Vehicle, ((const float32 *)
        &(KxTHMR_dV_MaxAirFlw_OHX[0])), ((const float32 *)
        &(KtTHMR_dV_MaxAirFlw_OHX[0])), 4U);

    /* Outputs for Atomic SubSystem: '<S5529>/PIDControl' */
    /* Outputs for Atomic SubSystem: '<S5529>/EdgeRising' */
    /* Switch: '<S5578>/Switch' incorporates:
     *  Constant: '<S5529>/ConstantValue3'
     *  Constant: '<S5568>/Calib'
     *  Logic: '<S5529>/LogicalOperator'
     *  Logic: '<S5567>/AND'
     *  RelationalOperator: '<S5529>/RelationalOperator'
     *  RelationalOperator: '<S5529>/RelationalOperator1'
     *  Switch: '<S5578>/Switch2'
     *  UnitDelay: '<S5529>/UnitDelay'
     */
    if (rtb_OR1_jc2)
    {
        /* Switch: '<S5578>/Switch' incorporates:
         *  Constant: '<S5529>/ConstantValue1'
         */
        rtb_UnitDelay_oqi = 0.0F;
    }
    else
    {
        if (((THMR_ac_DW.UnitDelay_DSTATE_ov > rtb_Vector_h00) && (rtb_Sum_e >
                0.0F)) && (KeTHMR_b_Hld_I_Term_PresErr))
        {
            /* Switch: '<S5578>/Switch2' incorporates:
             *  Constant: '<S5578>/ConstantValue1'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S5578>/Switch2' incorporates:
             *  Constant: '<S5529>/ConstantValue2'
             *  Lookup_n-D: '<S5574>/Vector'
             *  Product: '<S5578>/Multiplication1'
             *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
             */
            rtb_Switch10 = (rtb_Sum_e * look1_iflf_binlcapw
                            (TmpSignalConversionAtOutAirTemp, ((const float32 *)
                              &(KxTHMR_k_FanITerm_PressErr[0])), ((const float32
                               *)&(KtTHMR_k_FanITerm_PressErr[0])), 2U)) * 0.1F;
        }

        /* Switch: '<S5578>/Switch' incorporates:
         *  Sum: '<S5578>/Sum//Sub'
         *  UnitDelay: '<S5578>/UnitDelay'
         */
        rtb_UnitDelay_oqi = rtb_Switch10 + THMR_ac_DW.UnitDelay_DSTATE_dc;
    }

    /* End of Switch: '<S5578>/Switch' */
    /* End of Outputs for SubSystem: '<S5529>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S5578>/integral_term' */
    /* Switch: '<S5579>/Switch1' incorporates:
     *  Constant: '<S5571>/Calib'
     *  RelationalOperator: '<S5579>/RelationalOperator'
     */
    if (KeTHMR_k_MaxITerm_PresErr < rtb_UnitDelay_oqi)
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = KeTHMR_k_MaxITerm_PresErr;
    }
    else
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = rtb_UnitDelay_oqi;
    }

    /* End of Switch: '<S5579>/Switch1' */

    /* Switch: '<S5579>/Switch' incorporates:
     *  Constant: '<S5572>/Calib'
     *  RelationalOperator: '<S5579>/RelationalOperator1'
     */
    if (rtb_Switch1_he > KeTHMR_k_MinITerm_PresErr)
    {
        /* Switch: '<S5579>/Switch' */
        rtb_UnitDelay_oqi = rtb_Switch1_he;
    }
    else
    {
        /* Switch: '<S5579>/Switch' */
        rtb_UnitDelay_oqi = KeTHMR_k_MinITerm_PresErr;
    }

    /* End of Switch: '<S5579>/Switch' */
    /* End of Outputs for SubSystem: '<S5578>/integral_term' */

    /* Sum: '<S5578>/Sum//Sub1' incorporates:
     *  Constant: '<S5529>/ConstantValue2'
     *  Lookup_n-D: '<S5573>/Vector'
     *  Lookup_n-D: '<S5575>/Vector'
     *  Product: '<S5578>/Multiplication2'
     *  Product: '<S5578>/derivative_term'
     *  Product: '<S5578>/proportional_term'
     *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
     *  Sum: '<S5578>/Sum//Sub2'
     *  UnitDelay: '<S5578>/UnitDelay1'
     */
    Switch4_d = (((rtb_Sum_e - THMR_ac_DW.UnitDelay1_DSTATE_c) *
                  look1_iflf_binlcapw(TmpSignalConversionAtOutAirTemp, ((const
                     float32 *)&(KxTHMR_k_FanDTerm_PressErr[0])), ((const
                     float32 *)&(KtTHMR_k_FanDTerm_PressErr[0])), 2U)) / 0.1F) +
        ((rtb_Sum_e * look1_iflf_binlcapw(TmpSignalConversionAtOutAirTemp, ((
             const float32 *)&(KxTHMR_k_FanPTerm_PressErr[0])), ((const float32 *)
            &(KtTHMR_k_FanPTerm_PressErr[0])), 2U)) + rtb_UnitDelay_oqi);

    /* Update for UnitDelay: '<S5578>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_c = rtb_Sum_e;

    /* Update for UnitDelay: '<S5578>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_dc = rtb_UnitDelay_oqi;

    /* Outputs for Atomic SubSystem: '<S5529>/Limiter' */
    /* Switch: '<S5577>/Switch1' incorporates:
     *  Constant: '<S5569>/Calib'
     *  RelationalOperator: '<S5577>/RelationalOperator'
     *  Switch: '<S5578>/Switch1'
     */
    if (KeTHMR_dV_FanPID_PresErr_Max < Switch4_d)
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = KeTHMR_dV_FanPID_PresErr_Max;
    }
    else
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = Switch4_d;
    }

    /* End of Switch: '<S5577>/Switch1' */
    /* End of Outputs for SubSystem: '<S5529>/PIDControl' */

    /* Switch: '<S5577>/Switch' incorporates:
     *  Constant: '<S5570>/Calib'
     *  RelationalOperator: '<S5577>/RelationalOperator1'
     */
    if (rtb_Switch1_he > KeTHMR_dV_FanPID_PresErr_Min)
    {
        /* Switch: '<S5577>/Switch' */
        VeTHMR_dV_PresErr_PID = rtb_Switch1_he;
    }
    else
    {
        /* Switch: '<S5577>/Switch' */
        VeTHMR_dV_PresErr_PID = KeTHMR_dV_FanPID_PresErr_Min;
    }

    /* End of Switch: '<S5577>/Switch' */
    /* End of Outputs for SubSystem: '<S5529>/Limiter' */

    /* Switch: '<S5521>/Switch1' incorporates:
     *  Constant: '<S5518>/Constant'
     *  Logic: '<S5387>/LogicalOperator1'
     *  RelationalOperator: '<S5387>/RelationalOperator1'
     */
    if (((uint32)VeTHMR_b_CompressorReqOn_0_tmp) != CeTHMR_e_HeatPump)
    {
        /* Switch: '<S5521>/Switch1' incorporates:
         *  MinMax: '<S5387>/MinMax4'
         */
        Switch4_d = fminf(VeTHMR_dV_PresErr_PID, rtb_Vector_h00);
    }
    else
    {
        /* Switch: '<S5521>/Switch1' incorporates:
         *  Constant: '<S5387>/ConstantValue1'
         */
        Switch4_d = 0.0F;
    }

    /* End of Switch: '<S5521>/Switch1' */

    /* SignalConversion generated from: '<S84>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    /* MinMax: '<S5387>/MinMax3' */
    rtb_MinMax3_h = Switch4_d;

#else

    /* MinMax: '<S5387>/MinMax3' incorporates:
     *  Constant: '<S84>/ConstantValue6'
     *  SignalConversion generated from: '<S84>/VariantSource'
     */
    rtb_MinMax3_h = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S84>/VariantSource' */

    /* Sum: '<S5528>/Sum' incorporates:
     *  Lookup_n-D: '<S5563>/Vector'
     *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
     */
    rtb_Sum_e = look1_iflf_binlcapw(TmpSignalConversionAtOutAirTemp, ((const
        float32 *)&(KxTHMR_p_TgtPSuc[0])), ((const float32 *)&(KtTHMR_p_TgtPSuc
        [0])), 13U) - VeTHMR_p_eACSuctnPress;

    /* Outputs for Atomic SubSystem: '<S5528>/EdgeRising' */
    /* Logic: '<S5554>/OR1' incorporates:
     *  UnitDelay: '<S5554>/UnitDelay'
     */
    rtb_OR1_jc2 = !THMR_ac_DW.UnitDelay_DSTATE_jhv;

    /* Update for UnitDelay: '<S5554>/UnitDelay' incorporates:
     *  Constant: '<S5528>/TRUEConstant'
     */
    THMR_ac_DW.UnitDelay_DSTATE_jhv = true;

    /* Outputs for Atomic SubSystem: '<S5528>/PIDControl' */
    /* Switch: '<S5565>/Switch' incorporates:
     *  Constant: '<S5528>/ConstantValue3'
     *  Constant: '<S5555>/Calib'
     *  Logic: '<S5528>/LogicalOperator'
     *  Logic: '<S5554>/AND'
     *  RelationalOperator: '<S5528>/RelationalOperator'
     *  RelationalOperator: '<S5528>/RelationalOperator1'
     *  Switch: '<S5565>/Switch2'
     *  UnitDelay: '<S5528>/UnitDelay'
     */
    if (rtb_OR1_jc2)
    {
        /* Switch: '<S5565>/Switch' incorporates:
         *  Constant: '<S5528>/ConstantValue1'
         */
        rtb_UnitDelay_oqi = 0.0F;
    }
    else
    {
        if (((THMR_ac_DW.UnitDelay_DSTATE_lw > rtb_Vector_h00) && (rtb_Sum_e >
                0.0F)) && (KeTHMR_b_Hld_I_Term_PsucErr))
        {
            /* Switch: '<S5565>/Switch2' incorporates:
             *  Constant: '<S5565>/ConstantValue1'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S5565>/Switch2' incorporates:
             *  Constant: '<S5528>/ConstantValue2'
             *  Constant: '<S5561>/Calib'
             *  Product: '<S5565>/Multiplication1'
             */
            rtb_Switch10 = (rtb_Sum_e * KeTHMR_k_PsucIterm_PsucErr) * 0.1F;
        }

        /* Switch: '<S5565>/Switch' incorporates:
         *  Sum: '<S5565>/Sum//Sub'
         *  UnitDelay: '<S5565>/UnitDelay'
         */
        rtb_UnitDelay_oqi = rtb_Switch10 + THMR_ac_DW.UnitDelay_DSTATE_os;
    }

    /* End of Switch: '<S5565>/Switch' */
    /* End of Outputs for SubSystem: '<S5528>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S5565>/integral_term' */
    /* Switch: '<S5566>/Switch1' incorporates:
     *  Constant: '<S5558>/Calib'
     *  RelationalOperator: '<S5566>/RelationalOperator'
     */
    if (KeTHMR_k_MaxITerm_PsucErr < rtb_UnitDelay_oqi)
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = KeTHMR_k_MaxITerm_PsucErr;
    }
    else
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = rtb_UnitDelay_oqi;
    }

    /* End of Switch: '<S5566>/Switch1' */

    /* Switch: '<S5566>/Switch' incorporates:
     *  Constant: '<S5559>/Calib'
     *  RelationalOperator: '<S5566>/RelationalOperator1'
     */
    if (rtb_Switch1_he > KeTHMR_k_MinITerm_PsucErr)
    {
        /* Switch: '<S5566>/Switch' */
        rtb_UnitDelay_oqi = rtb_Switch1_he;
    }
    else
    {
        /* Switch: '<S5566>/Switch' */
        rtb_UnitDelay_oqi = KeTHMR_k_MinITerm_PsucErr;
    }

    /* End of Switch: '<S5566>/Switch' */
    /* End of Outputs for SubSystem: '<S5565>/integral_term' */

    /* Sum: '<S5565>/Sum//Sub1' incorporates:
     *  Constant: '<S5528>/ConstantValue2'
     *  Constant: '<S5560>/Calib'
     *  Constant: '<S5562>/Calib'
     *  Product: '<S5565>/Multiplication2'
     *  Product: '<S5565>/derivative_term'
     *  Product: '<S5565>/proportional_term'
     *  Sum: '<S5565>/Sum//Sub2'
     *  UnitDelay: '<S5565>/UnitDelay1'
     */
    rtb_Product_gg = (((rtb_Sum_e - THMR_ac_DW.UnitDelay1_DSTATE_of) *
                       KeTHMR_k_PsucDterm_PsucErr) / 0.1F) + ((rtb_Sum_e *
        KeTHMR_k_PsucPterm_PsucErr) + rtb_UnitDelay_oqi);

    /* Update for UnitDelay: '<S5565>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_of = rtb_Sum_e;

    /* Update for UnitDelay: '<S5565>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_os = rtb_UnitDelay_oqi;

    /* Outputs for Atomic SubSystem: '<S5528>/Limiter' */
    /* Switch: '<S5564>/Switch1' incorporates:
     *  Constant: '<S5556>/Calib'
     *  RelationalOperator: '<S5564>/RelationalOperator'
     *  Switch: '<S5565>/Switch1'
     */
    if (KeTHMR_dV_FanPID_PsucErr_Max < rtb_Product_gg)
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = KeTHMR_dV_FanPID_PsucErr_Max;
    }
    else
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = rtb_Product_gg;
    }

    /* End of Switch: '<S5564>/Switch1' */
    /* End of Outputs for SubSystem: '<S5528>/PIDControl' */

    /* Switch: '<S5564>/Switch' incorporates:
     *  Constant: '<S5557>/Calib'
     *  RelationalOperator: '<S5564>/RelationalOperator1'
     */
    if (rtb_Switch1_he > KeTHMR_dV_FanPID_PsucErr_Min)
    {
        /* Switch: '<S5564>/Switch' */
        VeTHMR_dV_PSucErr_PID = rtb_Switch1_he;
    }
    else
    {
        /* Switch: '<S5564>/Switch' */
        VeTHMR_dV_PSucErr_PID = KeTHMR_dV_FanPID_PsucErr_Min;
    }

    /* End of Switch: '<S5564>/Switch' */
    /* End of Outputs for SubSystem: '<S5528>/Limiter' */

    /* Switch: '<S5520>/Switch1' incorporates:
     *  Constant: '<S5517>/Constant'
     *  Logic: '<S5387>/LogicalOperator2'
     *  RelationalOperator: '<S5387>/RelationalOperator'
     */
    if ((((uint32)VeTHMR_b_CompressorReqOn_0_tmp) == CeTHMR_e_HeatPump) &&
            (VeTHMR_b_CabHeatPumpAllowOhx))
    {
        /* Switch: '<S5520>/Switch1' incorporates:
         *  MinMax: '<S5387>/MinMax6'
         */
        rtb_Merge8 = fminf(VeTHMR_dV_PSucErr_PID, rtb_Vector_h00);
    }
    else
    {
        /* Switch: '<S5520>/Switch1' incorporates:
         *  Constant: '<S5387>/ConstantValue3'
         */
        rtb_Merge8 = 0.0F;
    }

    /* End of Switch: '<S5520>/Switch1' */

    /* Switch: '<S5369>/Switch1' incorporates:
     *  Constant: '<S5379>/Calib'
     *  Constant: '<S84>/ConstantValue3'
     *  Constant: '<S84>/ConstantValue5'
     *  Switch: '<S5370>/Switch1'
     */
    if (KeTHMR_b_HeatPumpEquipped)
    {
        rtb_Switch10 = rtb_Switch_ii;
        rtb_Switch15 = rtb_Merge8;
    }
    else
    {
        rtb_Switch10 = 0.0F;
        rtb_Switch15 = 0.0F;
    }

    /* End of Switch: '<S5369>/Switch1' */

    /* MinMax: '<S5389>/MinMax' */
    rtb_Product_gg = fmaxf(fmaxf(rtb_Switch10, rtb_MinMax3_h), rtb_Switch15);

    /* Lookup_n-D: '<S5612>/Vector' incorporates:
     *  MinMax: '<S5389>/MinMax'
     *  Switch: '<S3944>/Switch'
     */
    rtb_UnitDelay_oqi = look2_iflf_binlcapw(VeTHMR_v_Vehicle, rtb_Product_gg, ((
        const float32 *)&(KxTHMR_Pct_OHX_AGSPos_Req[0])), ((const float32 *)
        &(KyTHMR_Pct_OHX_AGSPos_Req[0])), ((const float32 *)
        &(KtTHMR_Pct_OHX_AGSPos_Req[0])), THMR_ac_ConstP.pooled37, 11U);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Switch: '<S5510>/Switch1' incorporates:
     *  Constant: '<S5508>/Constant'
     *  Constant: '<S5509>/Constant'
     *  Inport: '<S2741>/In1'
     *  RelationalOperator: '<S2928>/Relational Operator6'
     *  RelationalOperator: '<S5365>/Comparison1'
     *  RelationalOperator: '<S5365>/Comparison4'
     *  Switch: '<S5510>/Switch2'
     */
    if (((uint32)VeTHMR_e_EmrgcyFanRq_Lvl_B4D) == CeTHMR_e_High_EmrgcyFanRq_Lv2)
    {
        /* Switch: '<S5510>/Switch1' incorporates:
         *  Constant: '<S5511>/Calib'
         */
        VeTHMR_Pct_Emrgcy_NrmlzdFanSpeed = KeTHMR_Pct_Emrgy_RadFanCmd_On;
    }
    else if (((uint32)VeTHMR_e_EmrgcyFanRq_Lvl_B4D) ==
             CeTHMR_e_Low_EmrgcyFanRq_Lv1)
    {
        /* Switch: '<S5510>/Switch2' incorporates:
         *  Constant: '<S5513>/Calib'
         *  Switch: '<S5510>/Switch1'
         */
        VeTHMR_Pct_Emrgcy_NrmlzdFanSpeed = KeTHMR_Pct_Emrgy_RadFanCmd_OnLo;
    }
    else
    {
        /* Switch: '<S5510>/Switch1' incorporates:
         *  Constant: '<S5512>/Calib'
         *  Switch: '<S5510>/Switch2'
         */
        VeTHMR_Pct_Emrgcy_NrmlzdFanSpeed = KeTHMR_Pct_Emrgy_RadFanCmd_OnDft;
    }

    /* Lookup_n-D: '<S5386>/Vector' incorporates:
     *  Merge: '<S2293>/Merge1'
     */
    VeTHMR_Pct_NrmlzdFanSpd_LTRVlvCmd = look1_iflf_binlcapw
        (THMR_ac_B.VeTHMR_Pct_LTL_Vlv_Cmd, ((const float32 *)
          &(KxTHMR_Pct_LTRVlvCmd_Airflow[0])), ((const float32 *)
          &(KtTHMR_Pct_LTRVlvCmd_Airflow[0])), 4U);

    /* Switch: '<S84>/Switch4' incorporates:
     *  Constant: '<S5366>/Constant'
     *  Logic: '<S84>/LogicalOperator'
     *  Logic: '<S84>/LogicalOperator1'
     *  RelationalOperator: '<S84>/RelationalOperator1'
     */
    if ((((uint32)VeTHMR_b_CompressorReqOn_0_tmp) == CeTHMR_e_HeatPump) &&
            (!VeTHMR_b_CabHeatPumpAllowOhx))
    {
        /* Switch: '<S84>/Switch4' incorporates:
         *  Constant: '<S5373>/Calib'
         *  MinMax: '<S84>/MinMax'
         */
        rtb_UnitDelay_cui = fminf(KeTHMR_Pct_AGSPsCmdLTRVlvPos_HPMode,
            VeTHMR_Pct_NrmlzdFanSpd_LTRVlvCmd);
    }
    else
    {
        /* Switch: '<S84>/Switch4' */
        rtb_UnitDelay_cui = VeTHMR_Pct_NrmlzdFanSpd_LTRVlvCmd;
    }

    /* End of Switch: '<S84>/Switch4' */

    /* Switch: '<S5423>/Switch' incorporates:
     *  Constant: '<S5424>/Constant'
     *  Constant: '<S5429>/Calib'
     *  RelationalOperator: '<S5363>/Comparison1'
     *  Switch: '<S3780>/Switch'
     *  Switch: '<S5425>/Switch1'
     */
    if (KeTHMR_b_AHH_NrlzdFanSpeed_SD)
    {
        /* Switch: '<S5423>/Switch' incorporates:
         *  Constant: '<S5428>/Calib'
         */
        rtb_Sum_e = KeTHMR_Pct_AHH_NrlzdFanSpeed_D;
    }
    else if (((uint32)VeTHMR_e_AHH_Ready_Status_AD) == CeBRKR_e_AHH_Active)
    {
        /* Switch: '<S5425>/Switch1' incorporates:
         *  Constant: '<S5426>/Calib'
         *  Switch: '<S5423>/Switch'
         */
        rtb_Sum_e = KeTHMR_Pct_AHH_NrmlzdMaxFan_Speed;
    }
    else
    {
        /* Switch: '<S5423>/Switch' incorporates:
         *  Lookup_n-D: '<S5427>/Vector'
         *  Switch: '<S3781>/Switch'
         *  Switch: '<S5425>/Switch1'
         */
        rtb_Sum_e = look1_iflf_binlcapw(VeTHMR_r_AHH_StressFactor, ((const
            float32 *)&(KxTHMR_Pct_AHH_Fan_Speed[0])), ((const float32 *)
            &(KtTHMR_Pct_AHH_Fan_Speed[0])), 8U);
    }

    /* End of Switch: '<S5423>/Switch' */

    /* Switch: '<S5368>/Switch1' incorporates:
     *  Constant: '<S5377>/Calib'
     *  Logic: '<S84>/Logical8'
     */
    if ((VeTHMR_b_AftrRunFanRq_SF) && (KeTHMR_b_AftrRunFanRqOvrdEnbl))
    {
        /* Switch: '<S5368>/Switch1' incorporates:
         *  Constant: '<S5375>/Calib'
         */
        VeTHMR_Pct_Normlzd_Aftrrun = KeTHMR_Pct_Ovrrd_AftrRunMaxFanSpeed;
    }
    else
    {
        /* Switch: '<S5368>/Switch1' incorporates:
         *  Constant: '<S84>/ConstantValue1'
         */
        VeTHMR_Pct_Normlzd_Aftrrun = 0.0F;
    }

    /* End of Switch: '<S5368>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S5527>/EdgeRising' */
    /* Logic: '<S5542>/OR1' incorporates:
     *  UnitDelay: '<S5542>/UnitDelay'
     */
    rtb_OR1_jc2 = !THMR_ac_DW.UnitDelay_DSTATE_nw2;

    /* Update for UnitDelay: '<S5542>/UnitDelay' incorporates:
     *  Constant: '<S5527>/TRUEConstant'
     */
    THMR_ac_DW.UnitDelay_DSTATE_nw2 = true;

    /* End of Outputs for SubSystem: '<S5527>/EdgeRising' */

    /* Lookup_n-D: '<S5525>/Vector' incorporates:
     *  Switch: '<S3944>/Switch'
     */
    rtb_Vector_h00 = look1_iflf_binlcapw(VeTHMR_v_Vehicle, ((const float32 *)
        &(KxTHMR_dV_MaxAirFlw_LoTempRad[0])), ((const float32 *)
        &(KtTHMR_dV_MaxAirFlw_LoTempRad[0])), 4U);

    /* Outputs for Atomic SubSystem: '<S5527>/PIDControl' */
    /* Outputs for Atomic SubSystem: '<S5527>/EdgeRising' */
    /* Switch: '<S5552>/Switch' incorporates:
     *  Constant: '<S5527>/ConstantValue3'
     *  Constant: '<S5543>/Calib'
     *  Logic: '<S5527>/LogicalOperator'
     *  Logic: '<S5542>/AND'
     *  RelationalOperator: '<S5527>/RelationalOperator'
     *  RelationalOperator: '<S5527>/RelationalOperator1'
     *  Switch: '<S5552>/Switch2'
     *  UnitDelay: '<S5527>/UnitDelay'
     */
    if (rtb_OR1_jc2)
    {
        /* Switch: '<S5552>/Switch' incorporates:
         *  Constant: '<S5527>/ConstantValue1'
         */
        rtb_MinMax3_h = 0.0F;
    }
    else
    {
        if (((THMR_ac_DW.UnitDelay_DSTATE_gf > rtb_Vector_h00) && (rtb_Merge1_i >
              0.0F)) && (KeTHMR_b_Hld_I_Term_ClntErr))
        {
            /* Switch: '<S5552>/Switch2' incorporates:
             *  Constant: '<S5552>/ConstantValue1'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S5552>/Switch2' incorporates:
             *  Constant: '<S5527>/ConstantValue2'
             *  Lookup_n-D: '<S5549>/Vector'
             *  Product: '<S5552>/Multiplication1'
             *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
             */
            rtb_Switch10 = (rtb_Merge1_i * look1_iflf_binlcapw
                            (TmpSignalConversionAtOutAirTemp, ((const float32 *)
                              &(KxTHMR_k_FanITerm_ClntErr[0])), ((const float32 *)
                              &(KtTHMR_k_FanITerm_ClntErr[0])), 2U)) * 0.1F;
        }

        /* Switch: '<S5552>/Switch' incorporates:
         *  Sum: '<S5552>/Sum//Sub'
         *  UnitDelay: '<S5552>/UnitDelay'
         */
        rtb_MinMax3_h = rtb_Switch10 + THMR_ac_DW.UnitDelay_DSTATE_mi4;
    }

    /* End of Switch: '<S5552>/Switch' */
    /* End of Outputs for SubSystem: '<S5527>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S5552>/integral_term' */
    /* Switch: '<S5553>/Switch1' incorporates:
     *  Constant: '<S5546>/Calib'
     *  RelationalOperator: '<S5553>/RelationalOperator'
     */
    if (KeTHMR_k_MaxITerm_ClntErr < rtb_MinMax3_h)
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = KeTHMR_k_MaxITerm_ClntErr;
    }
    else
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = rtb_MinMax3_h;
    }

    /* End of Switch: '<S5553>/Switch1' */

    /* Switch: '<S5553>/Switch' incorporates:
     *  Constant: '<S5547>/Calib'
     *  RelationalOperator: '<S5553>/RelationalOperator1'
     */
    if (rtb_Switch1_he > KeTHMR_k_MinITerm_ClntErr)
    {
        /* Switch: '<S5553>/Switch' */
        rtb_MinMax3_h = rtb_Switch1_he;
    }
    else
    {
        /* Switch: '<S5553>/Switch' */
        rtb_MinMax3_h = KeTHMR_k_MinITerm_ClntErr;
    }

    /* End of Switch: '<S5553>/Switch' */
    /* End of Outputs for SubSystem: '<S5552>/integral_term' */

    /* Sum: '<S5552>/Sum//Sub1' incorporates:
     *  Constant: '<S5527>/ConstantValue2'
     *  Lookup_n-D: '<S5548>/Vector'
     *  Lookup_n-D: '<S5550>/Vector'
     *  Product: '<S5552>/Multiplication2'
     *  Product: '<S5552>/derivative_term'
     *  Product: '<S5552>/proportional_term'
     *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
     *  Sum: '<S5552>/Sum//Sub2'
     *  UnitDelay: '<S5552>/UnitDelay1'
     */
    rtb_Switch1_i3 = (((rtb_Merge1_i - THMR_ac_DW.UnitDelay1_DSTATE_dj) *
                       look1_iflf_binlcapw(TmpSignalConversionAtOutAirTemp, ((
                          const float32 *)&(KxTHMR_k_FanDTerm_ClntErr[0])), ((
                          const float32 *)&(KtTHMR_k_FanDTerm_ClntErr[0])), 2U))
                      / 0.1F) + ((rtb_Merge1_i * look1_iflf_binlcapw
        (TmpSignalConversionAtOutAirTemp, ((const float32 *)
        &(KxTHMR_k_FanPTerm_ClntErr[0])), ((const float32 *)
        &(KtTHMR_k_FanPTerm_ClntErr[0])), 2U)) + rtb_MinMax3_h);

    /* Update for UnitDelay: '<S5552>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_dj = rtb_Merge1_i;

    /* Update for UnitDelay: '<S5552>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_mi4 = rtb_MinMax3_h;

    /* Outputs for Atomic SubSystem: '<S5527>/Limiter' */
    /* Switch: '<S5551>/Switch1' incorporates:
     *  Constant: '<S5544>/Calib'
     *  RelationalOperator: '<S5551>/RelationalOperator'
     *  Switch: '<S5552>/Switch1'
     */
    if (KeTHMR_dV_FanPID_ClntErr_Max < rtb_Switch1_i3)
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = KeTHMR_dV_FanPID_ClntErr_Max;
    }
    else
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = rtb_Switch1_i3;
    }

    /* End of Switch: '<S5551>/Switch1' */
    /* End of Outputs for SubSystem: '<S5527>/PIDControl' */

    /* Switch: '<S5551>/Switch' incorporates:
     *  Constant: '<S5545>/Calib'
     *  RelationalOperator: '<S5551>/RelationalOperator1'
     */
    if (rtb_Switch1_he > KeTHMR_dV_FanPID_ClntErr_Min)
    {
        /* Switch: '<S5551>/Switch' */
        VeTHMR_dV_ClntErr_PID = rtb_Switch1_he;
    }
    else
    {
        /* Switch: '<S5551>/Switch' */
        VeTHMR_dV_ClntErr_PID = KeTHMR_dV_FanPID_ClntErr_Min;
    }

    /* End of Switch: '<S5551>/Switch' */
    /* End of Outputs for SubSystem: '<S5527>/Limiter' */

    /* MinMax: '<S5387>/MinMax3' */
    rtb_MinMax3_h = fminf(VeTHMR_dV_ClntErr_PID, rtb_Vector_h00);

    /* Switch: '<S5389>/Switch4' incorporates:
     *  MinMax: '<S5389>/MinMax1'
     */
    rtb_Vector_h00 = fmaxf(fmaxf(fmaxf(fmaxf(VeTHMR_Pct_Emrgcy_NrmlzdFanSpeed,
        rtb_UnitDelay_cui), rtb_Sum_e), VeTHMR_Pct_Normlzd_Aftrrun),
                           rtb_MinMax3_h);

    /* Lookup_n-D: '<S5609>/Vector' incorporates:
     *  Switch: '<S3944>/Switch'
     *  Switch: '<S5389>/Switch4'
     */
    rtb_Merge1_i = look2_iflf_binlcapw(VeTHMR_v_Vehicle, rtb_Vector_h00, ((const
        float32 *)&(KxTHMR_Pct_LTR_AGSPos_Req[0])), ((const float32 *)
        &(KyTHMR_Pct_LTR_AGSPos_Req[0])), ((const float32 *)
        &(KtTHMR_Pct_LTR_AGSPos_Req[0])), THMR_ac_ConstP.pooled37, 11U);

    /* SignalConversion generated from: '<S84>/VariantSource1' incorporates:
     *  SignalConversion generated from: '<S84>/FC_Airflow'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

    /* Switch: '<S5389>/Switch2' incorporates:
     *  Constant: '<S84>/ConstantValue7'
     */
    rtb_Switch2_pg = 0.0F;

#elif !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent && Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* Switch: '<S5389>/Switch3' incorporates:
     *  SignalConversion generated from: '<S84>/FC_Airflow'
     */
    rtb_Switch3_cr = THMR_ac_B.Switch8_m;

#endif

    /* End of SignalConversion generated from: '<S84>/VariantSource1' */

    /* SignalConversion generated from: '<S84>/FC_Airflow' */
#if !(!Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent) || !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* Switch: '<S5389>/Switch3' */
    rtb_Switch3_cr = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S84>/FC_Airflow' */

    /* SignalConversion generated from: '<S84>/VariantSource1' */
#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

    /* Switch: '<S5389>/Switch2' */
    rtb_Switch2_pg = rtb_Switch3_cr;

#endif

    /* End of SignalConversion generated from: '<S84>/VariantSource1' */

    /* SignalConversion generated from: '<S84>/FC_Pct_Fan_Req' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* VariantMerge generated from: '<S84>/FC_Pct_Fan_Req' */
    rtb_VeTHMR_Pct_FCHTRRadFanCmd = THMR_ac_B.VeTHMR_Pct_FCHTRRadFanCmd;

#else

    /* VariantMerge generated from: '<S84>/FC_Pct_Fan_Req' incorporates:
     *  SignalConversion generated from: '<S84>/FC_Pct_Fan_Req'
     */
    rtb_VeTHMR_Pct_FCHTRRadFanCmd = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S84>/FC_Pct_Fan_Req' */

    /* If: '<S5389>/FC_Nucleus_Or_FCA_Cntrl' incorporates:
     *  Constant: '<S5598>/Calib'
     */
    if (KeTHMR_b_NucleusOrFCA_SD)
    {
        /* Outputs for IfAction SubSystem: '<S5389>/IfAct' incorporates:
         *  ActionPort: '<S5582>/ActionPort'
         */
        /* Merge: '<S5389>/Merge' incorporates:
         *  Lookup_n-D: '<S5614>/Vector'
         *  VariantMerge generated from: '<S84>/FC_Pct_Fan_Req'
         */
        rtb_Switch1_i3 = look1_iflf_binlcapw(rtb_VeTHMR_Pct_FCHTRRadFanCmd, ((
            const float32 *)&(KxTHMR_Pct_FCNucleus_AGSPos[0])), ((const float32 *)
            &(KtTHMR_Pct_FCNucleus_AGSPos[0])), 5U);

        /* Merge: '<S5389>/Merge1' incorporates:
         *  Lookup_n-D: '<S5615>/Vector'
         *  VariantMerge generated from: '<S84>/FC_Pct_Fan_Req'
         */
        rtb_VeTHMR_Pct_FCHTRRadFanCmd = look1_iflf_binlcapw
            (rtb_VeTHMR_Pct_FCHTRRadFanCmd, ((const float32 *)
              &(KxTHMR_Pct_FCNucleus_FanPWM[0])), ((const float32 *)
              &(KtTHMR_Pct_FCNucleus_FanPWM[0])), 5U);

        /* End of Outputs for SubSystem: '<S5389>/IfAct' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S5389>/IfAct1' incorporates:
         *  ActionPort: '<S5583>/ActionPort'
         */
        /* Merge: '<S5389>/Merge' incorporates:
         *  Inport: '<S5583>/AGS_Pos'
         *  Lookup_n-D: '<S5607>/Vector'
         *  Switch: '<S3944>/Switch'
         *  Switch: '<S5389>/Switch2'
         */
        rtb_Switch1_i3 = look2_iflf_binlcapw(VeTHMR_v_Vehicle, rtb_Switch2_pg,
            ((const float32 *)&(KxTHMR_Pct_FC_AGSPos_ReqFCA[0])), ((const
            float32 *)&(KyTHMR_Pct_FC_AGSPos_ReqFCA[0])), ((const float32 *)
            &(KtTHMR_Pct_FC_AGSPos_ReqFCA[0])), THMR_ac_ConstP.pooled37, 11U);

        /* Merge: '<S5389>/Merge1' incorporates:
         *  Inport: '<S5583>/Fan_PWM'
         *  Lookup_n-D: '<S5608>/Vector'
         *  Switch: '<S3944>/Switch'
         *  Switch: '<S5389>/Switch2'
         */
        rtb_VeTHMR_Pct_FCHTRRadFanCmd = look2_iflf_binlcapw(VeTHMR_v_Vehicle,
            rtb_Switch2_pg, ((const float32 *)&(KxTHMR_Pct_FanPWM_ReqFCA[0])),
            ((const float32 *)&(KyTHMR_Pct_FanPWM_ReqFCA[0])), ((const float32 *)
            &(KtTHMR_Pct_FanPWM_ReqFCA[0])), THMR_ac_ConstP.pooled37, 11U);

        /* End of Outputs for SubSystem: '<S5389>/IfAct1' */
    }

    /* End of If: '<S5389>/FC_Nucleus_Or_FCA_Cntrl' */

    /* SignalConversion generated from: '<S84>/VariantSource2' incorporates:
     *  Product: '<S84>/Product4'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

    /* Switch: '<S5389>/Switch2' incorporates:
     *  Constant: '<S84>/ConstantValue8'
     */
    rtb_Switch2_pg = 0.0F;

#else

    /* Switch: '<S5389>/Switch2' incorporates:
     *  Constant: '<S5383>/Calib'
     *  Product: '<S84>/Product4'
     */
    rtb_Switch2_pg = rtb_TmpSignalConversionAtVeT_jm * KeTHMR_dV_MaxAirflowECM;

#endif

    /* End of SignalConversion generated from: '<S84>/VariantSource2' */

    /* Lookup_n-D: '<S5605>/Vector' incorporates:
     *  Switch: '<S3944>/Switch'
     *  Switch: '<S5389>/Switch2'
     */
    rtb_UnitDelay_nr = look2_iflf_binlcapw(VeTHMR_v_Vehicle, rtb_Switch2_pg, ((
        const float32 *)&(KxTHMR_Pct_EngRad_AGSPos_Req[0])), ((const float32 *)
        &(KyTHMR_Pct_EngRad_AGSPos_Req[0])), ((const float32 *)
        &(KtTHMR_Pct_EngRad_AGSPos_Req[0])), THMR_ac_ConstP.pooled37, 11U);

    /* Lookup_n-D: '<S5601>/Vector' incorporates:
     *  Switch: '<S3944>/Switch'
     *  VariantMerge generated from: '<S63>/VariantSource'
     */
    rtb_Switch15 = look2_iflf_binlcapw(VeTHMR_v_Vehicle,
        THMR_ac_B.VariantMerge_Fo_om, ((const float32 *)
        &(KxTHMR_Pct_BattRad_AGSPos_Req[0])), ((const float32 *)
        &(KyTHMR_Pct_BattRad_AGSPos_Req[0])), ((const float32 *)
        &(KtTHMR_Pct_BattRad_AGSPos_Req[0])), THMR_ac_ConstP.pooled37, 11U);

    /* SignalConversion generated from: '<S84>/VariantSource3' incorporates:
     *  Product: '<S84>/Product1'
     *  Switch: '<S5371>/Switch1'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    /* MinMax: '<S5389>/MinMax8' incorporates:
     *  Constant: '<S84>/ConstantValue9'
     */
    rtb_MinMax8 = 0.0F;

#else

    /* Outputs for Atomic SubSystem: '<S84>/ProtectedDivision1' */
    /* Switch: '<S5388>/Switch1' incorporates:
     *  Constant: '<S5388>/ConstantValue'
     *  RelationalOperator: '<S5388>/NotEqual'
     */
    if (rtb_TmpSignalConversionAtVeTMIR != 0.0F)
    {
        /* Switch: '<S5388>/Switch1' incorporates:
         *  Constant: '<S84>/ConstantValue'
         *  Product: '<S5388>/Division'
         */
        rtb_MinMax8 = rtb_TmpSignalConversionAtVeTMIR / 100.0F;
    }
    else
    {
        /* Switch: '<S5388>/Switch1' incorporates:
         *  Constant: '<S5388>/ConstantValue4'
         *  Switch: '<S5388>/Switch2'
         *  Switch: '<S5388>/Switch3'
         */
        rtb_MinMax8 = 0.0F;
    }

    /* End of Switch: '<S5388>/Switch1' */

    /* Product: '<S84>/Product1' incorporates:
     *  Constant: '<S5384>/Calib'
     */
    rtb_Product1_nd = rtb_MinMax8 * KeTHMR_dV_PPU_AirFlw_Max;

    /* Switch: '<S5371>/Switch1' incorporates:
     *  Constant: '<S5380>/Calib'
     */
    if (KeTHMR_b_PPU_AirFlw_Enbl)
    {
        /* Switch: '<S84>/Switch3' incorporates:
         *  Constant: '<S5381>/Calib'
         */
        if (KeTHMR_b_PPU_Airflow_TypeSlct)
        {
            /* MinMax: '<S5389>/MinMax8' */
            rtb_MinMax8 = rtb_TmpSignalConversionAtVeTMIR;
        }
        else
        {
            /* MinMax: '<S5389>/MinMax8' */
            rtb_MinMax8 = rtb_Product1_nd;
        }

        /* End of Switch: '<S84>/Switch3' */
    }
    else
    {
        /* MinMax: '<S5389>/MinMax8' incorporates:
         *  Constant: '<S84>/ConstantValue2'
         */
        rtb_MinMax8 = 0.0F;
    }

#endif

    /* End of SignalConversion generated from: '<S84>/VariantSource3' */

    /* SignalConversion generated from: '<S84>/VariantSource4' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_P1MotorReqDsbl

    /* MinMax: '<S5389>/MinMax7' */
    rtb_MinMax7 = rtb_TmpSignalConversionAtVePM_d;

#else

    /* MinMax: '<S5389>/MinMax7' incorporates:
     *  Constant: '<S84>/ConstantValue10'
     *  SignalConversion generated from: '<S84>/VariantSource4'
     */
    rtb_MinMax7 = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S84>/VariantSource4' */

    /* Switch: '<S5372>/Switch1' incorporates:
     *  Constant: '<S5374>/Calib'
     *  Constant: '<S5378>/Calib'
     *  Constant: '<S84>/ConstantValue4'
     */
    if (KeTHMR_b_AllWheelBreakTmpEnbl)
    {
        rtb_Switch10 = KeTHMR_Pct_AllWheelBreakTmp;
    }
    else
    {
        rtb_Switch10 = 0.0F;
    }

    /* End of Switch: '<S5372>/Switch1' */

    /* MinMax: '<S5389>/MinMax8' incorporates:
     *  MinMax: '<S5389>/MinMax5'
     */
    rtb_MinMax8 = fmaxf(fmaxf(rtb_MinMax8, rtb_MinMax7), rtb_Switch10);

    /* Lookup_n-D: '<S5603>/Vector' incorporates:
     *  MinMax: '<S5389>/MinMax8'
     *  Switch: '<S3944>/Switch'
     */
    rtb_Switch10 = look2_iflf_binlcapw(VeTHMR_v_Vehicle, rtb_MinMax8, ((const
        float32 *)&(KxTHMR_Pct_DirectAirFlw_AGSPos_Req[0])), ((const float32 *)
        &(KyTHMR_Pct_DirectAirFlw_AGSPos_Req[0])), ((const float32 *)
        &(KtTHMR_Pct_DirectAirFlw_AGSPos_Req[0])), THMR_ac_ConstP.pooled37, 11U);

    /* Outputs for Atomic SubSystem: '<S5389>/Hysteresis' */
    /* Switch: '<S5581>/Switch1' incorporates:
     *  Constant: '<S5600>/Calib'
     *  RelationalOperator: '<S5581>/Greater  Than'
     */
    if (VeTHMR_v_Vehicle > KeTHMR_n_MaskCmprNoiseLim_Lo)
    {
        /* Switch: '<S5581>/Switch1' incorporates:
         *  Constant: '<S5581>/Constant Value'
         */
        rtb_OR1_jc2 = true;
    }
    else
    {
        /* Switch: '<S5581>/Switch1' incorporates:
         *  Constant: '<S5599>/Calib'
         *  RelationalOperator: '<S5581>/Greater  Than1'
         *  UnitDelay: '<S5581>/Unit Delay'
         */
        rtb_OR1_jc2 = ((VeTHMR_v_Vehicle >= KeTHMR_n_MaskCmprNoiseLim_Hi) &&
                       (THMR_ac_DW.UnitDelay_DSTATE_eh3));
    }

    /* End of Switch: '<S5581>/Switch1' */

    /* Update for UnitDelay: '<S5581>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_eh3 = rtb_OR1_jc2;

    /* End of Outputs for SubSystem: '<S5389>/Hysteresis' */

    /* Switch: '<S5584>/Switch1' incorporates:
     *  Constant: '<S5580>/Constant'
     *  Constant: '<S5596>/Calib'
     *  Constant: '<S5597>/Calib'
     *  Logic: '<S5389>/LogicalOperator'
     *  Logic: '<S5389>/LogicalOperator1'
     *  Logic: '<S5389>/LogicalOperator2'
     *  Logic: '<S5389>/LogicalOperator3'
     *  Logic: '<S5389>/LogicalOperator4'
     *  Logic: '<S5389>/LogicalOperator5'
     *  RelationalOperator: '<S5389>/RelationalOperator'
     */
    if (((!rtb_OR1_jc2) && (((((uint32)VeTHMR_b_CompressorReqOn_0_tmp) !=
                              CeTHMR_e_HeatPump) ||
                             (VeTHMR_b_CabHeatPumpAllowOhx)) ||
                            (KeTHMR_b_CabHeatPumpAllowEnbl))) &&
            (KeTHMR_b_MaskCmprNoiseEnbl))
    {
        /* Switch: '<S5584>/Switch1' incorporates:
         *  Lookup_n-D: '<S5611>/Vector'
         *  SignalConversion generated from: '<S2>/VeTAIR_n_CompSpdFdb'
         */
        rtb_TmpSignalConversionAtVeTA_n = look1_iflf_binlcapw
            (rtb_TmpSignalConversionAtVeTA_n, ((const float32 *)
              &(KxTHMR_Pct_MaskCmprNoiseFanCmd[0])), ((const float32 *)
              &(KtTHMR_Pct_MaskCmprNoiseFanCmd[0])), 4U);
    }
    else
    {
        /* Switch: '<S5584>/Switch1' incorporates:
         *  Constant: '<S5595>/Calib'
         */
        rtb_TmpSignalConversionAtVeTA_n = KeTHMR_Pct_MaskCmprNoiseFanCmdDefault;
    }

    /* End of Switch: '<S5584>/Switch1' */

    /* Switch: '<S5585>/Switch1' incorporates:
     *  Constant: '<S5389>/ConstantValue1'
     *  RelationalOperator: '<S5389>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTA_n > 0.0F)
    {
        /* Switch: '<S5585>/Switch1' incorporates:
         *  Constant: '<S5594>/Calib'
         */
        rtb_Switch11 = KeTHMR_Pct_FanSpeed_Default;
    }
    else
    {
        /* Switch: '<S5585>/Switch1' incorporates:
         *  Constant: '<S5389>/ConstantValue2'
         */
        rtb_Switch11 = 0.0F;
    }

    /* End of Switch: '<S5585>/Switch1' */

    /* Rounding: '<S5438>/Rounding2' incorporates:
     *  Lookup_n-D: '<S5483>/Vector'
     *  Switch: '<S2290>/Switch1'
     *  Switch: '<S3944>/Switch'
     */
    VeTHMR_e_LTR_Aiflow_Idx_AGS = ceilf(look2_iflf_binlcapw(VeTHMR_v_Vehicle,
        rtb_Switch1_ofq, ((const float32 *)&(KxTHMR_Pct_LTR_Airflow_Idx_AGS[0])),
        ((const float32 *)&(KyTHMR_Pct_LTR_Airflow_Idx_AGS[0])), ((const float32
        *)&(KtTHMR_Pct_LTR_Airflow_Idx_AGS[0])), THMR_ac_ConstP.pooled38, 11U));

    /* Selector: '<S5438>/Selector1' incorporates:
     *  Constant: '<S5479>/Calib'
     */
    VeTHMR_Pct_LTR_Aiflow_AGS = KaTHMR_Pct_LTR_Airflow_AGS[((sint32)
        VeTHMR_e_LTR_Aiflow_Idx_AGS) - 1];

    /* Rounding: '<S5438>/Rounding1' incorporates:
     *  Lookup_n-D: '<S5484>/Vector'
     *  Switch: '<S2290>/Switch1'
     *  Switch: '<S3944>/Switch'
     */
    VeTHMR_e_LTR_Aiflow_Idx_AGSOpen = ceilf(look2_iflf_binlcapw(VeTHMR_v_Vehicle,
        rtb_Switch1_ofq, ((const float32 *)&(KxTHMR_Pct_LTR_Airflow_Idx_AGSOpen
        [0])), ((const float32 *)&(KyTHMR_Pct_LTR_Airflow_Idx_AGSOpen[0])), ((
        const float32 *)&(KtTHMR_Pct_LTR_Airflow_Idx_AGSOpen[0])),
        THMR_ac_ConstP.pooled37, 11U));

    /* Switch: '<S5478>/Switch1' incorporates:
     *  Constant: '<S5481>/Calib'
     *  Constant: '<S5486>/Constant'
     *  Constant: '<S5487>/Constant'
     *  Constant: '<S5488>/Constant'
     *  Constant: '<S5489>/Calib'
     *  Constant: '<S5490>/Calib'
     *  Constant: '<S5491>/Calib'
     *  Constant: '<S5492>/Calib'
     *  Constant: '<S5493>/Calib'
     *  Logic: '<S5438>/Logical'
     *  Logic: '<S5485>/LogicalOperator1'
     *  Logic: '<S5485>/LogicalOperator2'
     *  Logic: '<S5485>/LogicalOperator3'
     *  Logic: '<S5485>/LogicalOperator4'
     *  Logic: '<S5485>/LogicalOperator5'
     *  Logic: '<S5485>/LogicalOperator6'
     *  RelationalOperator: '<S5438>/Comparison2'
     *  RelationalOperator: '<S5485>/Comparison1'
     *  RelationalOperator: '<S5485>/Comparison2'
     *  RelationalOperator: '<S5485>/Comparison3'
     *  RelationalOperator: '<S5485>/Comparison4'
     *  RelationalOperator: '<S5485>/RelationalOperator1'
     */
    if ((rtb_Logical2_ioz && (VeTHMR_Pct_LTR_Aiflow_AGS >= KeTHMR_Pct_AGSOpen)) &&
        (((rtb_TmpSignalConversionAtVeTAIR >= KeTHMR_Pct_LTRVlvCls_FanOn_Min) &&
          (rtb_TmpSignalConversionAtVeTAIR <= KeTHMR_Pct_LTRVlvCls_FanOn_Max)) &&
         ((((!KeTHMR_b_LTRVlvStuckSNA_DisblFan4LTR) || (CeRCVR_e_SNA != ((uint32)
              rtb_TmpSignalConversionAtVeRCVR))) && ((((uint32)
              rtb_TmpSignalConversionAtVeRCVR) != CeRCVR_e_Faulty_Open) ||
            (!KeTHMR_b_LTRVlvStuckOpen_DisblFan4LTR))) && ((((uint32)
             rtb_TmpSignalConversionAtVeRCVR) != CeRCVR_e_Faulty_Open_Bypass) ||
           (!KeTHMR_b_LTRVlvStuckOpenBypass_DisblFan4LTR)))))
    {
        /* MinMax: '<S5389>/MinMax10' incorporates:
         *  Constant: '<S5480>/Calib'
         *  Selector: '<S5438>/Selector4'
         */
        rtb_Switch1_he = KaTHMR_Pct_LTR_Airflow_AGSOpen[((sint32)
            VeTHMR_e_LTR_Aiflow_Idx_AGSOpen) - 1];
    }
    else
    {
        /* MinMax: '<S5389>/MinMax10' incorporates:
         *  Constant: '<S5482>/Calib'
         */
        rtb_Switch1_he = KeTHMR_Pct_FanSpeed_Default;
    }

    /* End of Switch: '<S5478>/Switch1' */

    /* MinMax: '<S5438>/MinMax1' */
    VeTHMR_Pct_LTR_MaxFanSpeed_App2 = fmaxf(VeTHMR_Pct_LTR_Aiflow_AGS,
        rtb_Switch1_he);

    /* Lookup_n-D: '<S5462>/Vector' incorporates:
     *  Chart: '<S5430>/Pct_Fan_Req_SF'
     *  Constant: '<S5442>/Calib'
     *  Constant: '<S5443>/Calib'
     *  Constant: '<S5444>/Calib'
     *  Constant: '<S5445>/Calib'
     *  Constant: '<S5446>/Calib'
     *  Constant: '<S5447>/Calib'
     *  Constant: '<S5448>/Calib'
     *  Constant: '<S5460>/Calib'
     *  Logic: '<S5432>/Logical'
     *  Logic: '<S5440>/Logical'
     *  Lookup_n-D: '<S5463>/Vector'
     *  Lookup_n-D: '<S5506>/Vector'
     *  Lookup_n-D: '<S5507>/Vector'
     *  MinMax: '<S5432>/MinMax2'
     *  MinMax: '<S5440>/MinMax2'
     *  RelationalOperator: '<S5430>/Comparison4'
     *  RelationalOperator: '<S5432>/Comparison2'
     *  RelationalOperator: '<S5440>/Comparison2'
     *  Rounding: '<S5432>/Rounding1'
     *  Rounding: '<S5432>/Rounding2'
     *  Rounding: '<S5440>/Rounding1'
     *  Rounding: '<S5440>/Rounding2'
     *  Selector: '<S5432>/Selector1'
     *  Selector: '<S5440>/Selector1'
     *  Switch: '<S5364>/Switch3'
     *  Switch: '<S5430>/Switch1'
     *  Switch: '<S5430>/Switch5'
     *  Switch: '<S5457>/Switch1'
     *  Switch: '<S5501>/Switch1'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    /* Rounding: '<S5432>/Rounding2' incorporates:
     *  Switch: '<S2803>/Switch12'
     *  Switch: '<S3944>/Switch'
     */
    VeTHMR_e_HeadPres_Aiflow_Idx_AGS = ceilf(look2_iflf_binlcapw
        (VeTHMR_v_Vehicle, rtb_Add2_m, ((const float32 *)
        &(KxTHMR_Pct_HeadPres_Airflow_Idx_AGS[0])), ((const float32 *)
        &(KyTHMR_Pct_HeadPres_Airflow_Idx_AGS[0])), ((const float32 *)
        &(KtTHMR_Pct_HeadPres_Airflow_Idx_AGS[0])), THMR_ac_ConstP.pooled37, 11U));

    /* Selector: '<S5432>/Selector1' incorporates:
     *  Constant: '<S5458>/Calib'
     */
    VeTHMR_Pct_HeadPres_Aiflow_AGS = KaTHMR_Pct_HeadPres_Airflow_AGS[((sint32)
        VeTHMR_e_HeadPres_Aiflow_Idx_AGS) - 1];

    /* Rounding: '<S5432>/Rounding1' incorporates:
     *  Switch: '<S2803>/Switch12'
     *  Switch: '<S3944>/Switch'
     */
    VeTHMR_e_HeadPres_Aiflow_Idx_AGSOpen = ceilf(look2_iflf_binlcapw
        (VeTHMR_v_Vehicle, rtb_Add2_m, ((const float32 *)
        &(KxTHMR_Pct_HeadPres_Airflow_Idx_AGSOpen[0])), ((const float32 *)
        &(KyTHMR_Pct_HeadPres_Airflow_Idx_AGSOpen[0])), ((const float32 *)
        &(KtTHMR_Pct_HeadPres_Airflow_Idx_AGSOpen[0])), THMR_ac_ConstP.pooled37,
         11U));
    if (rtb_Logical2_ioz && (VeTHMR_Pct_HeadPres_Aiflow_AGS >=
                             KeTHMR_Pct_AGSOpen))
    {
        /* MinMax: '<S5389>/MinMax10' incorporates:
         *  Constant: '<S5459>/Calib'
         *  Selector: '<S5432>/Selector6'
         */
        rtb_Switch1_he = KaTHMR_Pct_HeadPres_Airflow_AGSOpen[((sint32)
            VeTHMR_e_HeadPres_Aiflow_Idx_AGSOpen) - 1];
    }
    else
    {
        /* MinMax: '<S5389>/MinMax10' incorporates:
         *  Constant: '<S5461>/Calib'
         */
        rtb_Switch1_he = KeTHMR_Pct_FanSpeed_Default;
    }

    /* MinMax: '<S5432>/MinMax2' incorporates:
     *  Constant: '<S5460>/Calib'
     */
    VeTHMR_Pct_HeadPres_MaxFanSpeed_App2 = fmaxf(VeTHMR_Pct_HeadPres_Aiflow_AGS,
        rtb_Switch1_he);

    /* RelationalOperator: '<S5430>/Comparison4' incorporates:
     *  Constant: '<S5441>/Calib'
     */
    VeTHMR_b_Fan_ACP_pct_OrgnlOrNew = (VeTHMR_Pct_HeadPres_MaxFanSpeed_App2 >
        KeTHMR_Pct_FanOnPct_SFvsRaw);

    /* Gateway: THMR_FUNC_RU_MedTEH/ThermalAirflow_Arb/AirFlow_Calculation_2DTable_Approach/Anti_Toggle/Pct_Fan_Req_SF */
    /* During: THMR_FUNC_RU_MedTEH/ThermalAirflow_Arb/AirFlow_Calculation_2DTable_Approach/Anti_Toggle/Pct_Fan_Req_SF */
    if (((uint32)THMR_ac_DW.is_active_c9_THMR_ac) == 0U)
    {
        /* Entry: THMR_FUNC_RU_MedTEH/ThermalAirflow_Arb/AirFlow_Calculation_2DTable_Approach/Anti_Toggle/Pct_Fan_Req_SF */
        THMR_ac_DW.is_active_c9_THMR_ac = 1U;

        /* Entry Internal: THMR_FUNC_RU_MedTEH/ThermalAirflow_Arb/AirFlow_Calculation_2DTable_Approach/Anti_Toggle/Pct_Fan_Req_SF */
        /* Transition: '<S5449>:3' */
        THMR_ac_DW.is_c9_THMR_ac = THMR_ac_IN_Fan_Off;

        /* Entry 'Fan_Off': '<S5449>:7' */
        THMR_ac_DW.count = 0.0F;
        VeTHMR_Pct_Fan_ACP_SF = KeTHMR_Pct_min_Fan_off_pct;
    }
    else
    {
        switch (THMR_ac_DW.is_c9_THMR_ac)
        {
          case THMR_ac_IN_Fan_Off:
            /* During 'Fan_Off': '<S5449>:7' */
            if (VeTHMR_Pct_HeadPres_MaxFanSpeed_App2 >=
                    KeTHMR_Pct_Fan_off_to_on_pct)
            {
                /* Transition: '<S5449>:6' */
                THMR_ac_DW.is_c9_THMR_ac = THMR_ac_IN_Fan_On_Timer;

                /* Entry 'Fan_On_Timer': '<S5449>:9' */
                THMR_ac_DW.count++;
            }
            else
            {
                VeTHMR_Pct_Fan_ACP_SF = KeTHMR_Pct_min_Fan_off_pct;
            }
            break;

          case THMR_ac_IN_Fan_On:
            /* During 'Fan_On': '<S5449>:1' */
            if (((THMR_ac_DW.count * 0.1F) > KeTHMR_t_Fan_min_FanRunTime) &&
                    (VeTHMR_Pct_HeadPres_MaxFanSpeed_App2 <
                     KeTHMR_Pct_min_Fan_on_pct))
            {
                /* Transition: '<S5449>:10' */
                THMR_ac_DW.is_c9_THMR_ac = THMR_ac_IN_Fan_Off;

                /* Entry 'Fan_Off': '<S5449>:7' */
                THMR_ac_DW.count = 0.0F;
                VeTHMR_Pct_Fan_ACP_SF = KeTHMR_Pct_min_Fan_off_pct;
            }
            else
            {
                VeTHMR_Pct_Fan_ACP_SF = KeTHMR_Pct_min_Fan_on_pct;
                THMR_ac_DW.count++;
            }
            break;

          default:
            /* During 'Fan_On_Timer': '<S5449>:9' */
            if (VeTHMR_Pct_HeadPres_MaxFanSpeed_App2 <
                    KeTHMR_Pct_Fan_on_to_off_pct)
            {
                /* Transition: '<S5449>:11' */
                THMR_ac_DW.is_c9_THMR_ac = THMR_ac_IN_Fan_Off;

                /* Entry 'Fan_Off': '<S5449>:7' */
                THMR_ac_DW.count = 0.0F;
                VeTHMR_Pct_Fan_ACP_SF = KeTHMR_Pct_min_Fan_off_pct;
            }
            else if ((THMR_ac_DW.count * 0.1F) > KeTHMR_t_Fan_Off_to_On_Timer)
            {
                /* Transition: '<S5449>:8' */
                THMR_ac_DW.is_c9_THMR_ac = THMR_ac_IN_Fan_On;

                /* Entry 'Fan_On': '<S5449>:1' */
                THMR_ac_DW.count = 0.0F;
            }
            else
            {
                VeTHMR_Pct_Fan_ACP_SF = KeTHMR_Pct_min_Fan_off_pct;
                THMR_ac_DW.count++;
            }
            break;
        }
    }

    if (VeTHMR_b_Fan_ACP_pct_OrgnlOrNew)
    {
        /* Switch: '<S5430>/Switch5' */
        VeTHMR_Pct_Fan_ACP_SForThrshldOrgnl =
            VeTHMR_Pct_HeadPres_MaxFanSpeed_App2;
    }
    else
    {
        /* Switch: '<S5430>/Switch5' */
        VeTHMR_Pct_Fan_ACP_SForThrshldOrgnl = VeTHMR_Pct_Fan_ACP_SF;
    }

    if (KeTHMR_b_RefPressFabPct_SF_dsbl)
    {
        /* MinMax: '<S5389>/MinMax7' */
        rtb_MinMax7 = VeTHMR_Pct_HeadPres_MaxFanSpeed_App2;
    }
    else
    {
        /* MinMax: '<S5389>/MinMax7' */
        rtb_MinMax7 = VeTHMR_Pct_Fan_ACP_SForThrshldOrgnl;
    }

#else

    /* Rounding: '<S5440>/Rounding2' incorporates:
     *  Lookup_n-D: '<S5506>/Vector'
     *  Product: '<S84>/Product1'
     *  Switch: '<S3944>/Switch'
     */
    VeTHMR_y_PPU_Aiflow_Idx_AGS = ceilf(look2_iflf_binlcapw(VeTHMR_v_Vehicle,
        rtb_Product1_nd, ((const float32 *)&(KxTHMR_Pct_PPU_Airflow_Idx_AGS[0])),
        ((const float32 *)&(KyTHMR_Pct_PPU_Airflow_Idx_AGS[0])), ((const float32
        *)&(KtTHMR_Pct_PPU_Airflow_Idx_AGS[0])), THMR_ac_ConstP.pooled37, 11U));

    /* Selector: '<S5440>/Selector1' incorporates:
     *  Constant: '<S5502>/Calib'
     */
    VeTHMR_Pct_PPU_Aiflow_AGS = KaTHMR_Pct_PPU_Airflow_AGS[((sint32)
        VeTHMR_y_PPU_Aiflow_Idx_AGS) - 1];

    /* Rounding: '<S5440>/Rounding1' incorporates:
     *  Lookup_n-D: '<S5507>/Vector'
     *  Product: '<S84>/Product1'
     *  Switch: '<S3944>/Switch'
     */
    VeTHMR_y_PPU_Aiflow_Idx_AGSOpen = ceilf(look2_iflf_binlcapw(VeTHMR_v_Vehicle,
        rtb_Product1_nd, ((const float32 *)&(KxTHMR_Pct_PPU_Airflow_Idx_AGSOpen
        [0])), ((const float32 *)&(KyTHMR_Pct_PPU_Airflow_Idx_AGSOpen[0])), ((
        const float32 *)&(KtTHMR_Pct_PPU_Airflow_Idx_AGSOpen[0])),
        THMR_ac_ConstP.pooled37, 11U));

    /* Switch: '<S5501>/Switch1' incorporates:
     *  Constant: '<S5504>/Calib'
     *  Logic: '<S5440>/Logical'
     *  RelationalOperator: '<S5440>/Comparison2'
     */
    if (rtb_Logical2_ioz && (VeTHMR_Pct_PPU_Aiflow_AGS >= KeTHMR_Pct_AGSOpen))
    {
        /* MinMax: '<S5389>/MinMax10' incorporates:
         *  Constant: '<S5503>/Calib'
         *  Selector: '<S5440>/Selector6'
         */
        rtb_Switch1_he = KaTHMR_Pct_PPU_Airflow_AGSOpen[((sint32)
            VeTHMR_y_PPU_Aiflow_Idx_AGSOpen) - 1];
    }
    else
    {
        /* MinMax: '<S5389>/MinMax10' incorporates:
         *  Constant: '<S5505>/Calib'
         */
        rtb_Switch1_he = KeTHMR_Pct_FanSpeed_Default;
    }

    /* MinMax: '<S5440>/MinMax2' */
    VeTHMR_Pct_PPU_MaxFanSpeed_App2 = fmaxf(VeTHMR_Pct_PPU_Aiflow_AGS,
        rtb_Switch1_he);

    /* Switch: '<S5364>/Switch3' incorporates:
     *  Constant: '<S5381>/Calib'
     */
    if (KeTHMR_b_PPU_Airflow_TypeSlct)
    {
        /* MinMax: '<S5389>/MinMax7' incorporates:
         *  Constant: '<S5437>/Calib'
         */
        rtb_MinMax7 = KeTHMR_Pct_PPU_Airflow_MinDummy;
    }
    else
    {
        /* MinMax: '<S5389>/MinMax7' */
        rtb_MinMax7 = VeTHMR_Pct_PPU_MaxFanSpeed_App2;
    }

#endif

    /* End of Lookup_n-D: '<S5462>/Vector' */

    /* SignalConversion generated from: '<S5364>/VariantSource2' */
    VeTHMR_Pct_CndnsrPPU_AirFlwReq = rtb_MinMax7;

    /* Lookup_n-D: '<S5499>/Vector' incorporates:
     *  Constant: '<S5497>/Calib'
     *  Logic: '<S5439>/Logical'
     *  Lookup_n-D: '<S5500>/Vector'
     *  MinMax: '<S5439>/MinMax2'
     *  RelationalOperator: '<S5439>/Comparison2'
     *  Rounding: '<S5439>/Rounding1'
     *  Rounding: '<S5439>/Rounding2'
     *  Selector: '<S5439>/Selector1'
     *  SignalConversion generated from: '<S5364>/VariantSource'
     *  Switch: '<S5494>/Switch1'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_P1MotorReqDsbl

    /* Rounding: '<S5439>/Rounding2' incorporates:
     *  Switch: '<S2803>/Switch11'
     *  Switch: '<S3944>/Switch'
     */
    VeTHMR_y_P1Motor_Aiflow_Idx_AGS = ceilf(look2_iflf_binlcapw(VeTHMR_v_Vehicle,
        rtb_TmpSignalConversionAtVePM_d, ((const float32 *)
        &(KxTHMR_Pct_P1Motor_Airflow_Idx_AGS[0])), ((const float32 *)
        &(KyTHMR_Pct_P1Motor_Airflow_Idx_AGS[0])), ((const float32 *)
        &(KtTHMR_Pct_P1Motor_Airflow_Idx_AGS[0])), THMR_ac_ConstP.pooled38, 11U));

    /* Selector: '<S5439>/Selector1' incorporates:
     *  Constant: '<S5495>/Calib'
     */
    VeTHMR_Pct_P1Motor_Aiflow_AGS = KaTHMR_Pct_P1Motor_Airflow_AGS[((sint32)
        VeTHMR_y_P1Motor_Aiflow_Idx_AGS) - 1];

    /* Rounding: '<S5439>/Rounding1' incorporates:
     *  Switch: '<S2803>/Switch11'
     *  Switch: '<S3944>/Switch'
     */
    VeTHMR_y_P1Motor_Aiflow_Idx_AGSOpen = ceilf(look2_iflf_binlcapw
        (VeTHMR_v_Vehicle, rtb_TmpSignalConversionAtVePM_d, ((const float32 *)
        &(KxTHMR_Pct_P1Motor_Airflow_Idx_AGSOpen[0])), ((const float32 *)
        &(KyTHMR_Pct_P1Motor_Airflow_Idx_AGSOpen[0])), ((const float32 *)
        &(KtTHMR_Pct_P1Motor_Airflow_Idx_AGSOpen[0])), THMR_ac_ConstP.pooled37,
         11U));
    if (rtb_Logical2_ioz && (VeTHMR_Pct_P1Motor_Aiflow_AGS >= KeTHMR_Pct_AGSOpen))
    {
        /* MinMax: '<S5389>/MinMax10' incorporates:
         *  Constant: '<S5496>/Calib'
         *  Selector: '<S5439>/Selector6'
         */
        rtb_Switch1_he = KaTHMR_Pct_P1Motor_Airflow_AGSOpen[((sint32)
            VeTHMR_y_P1Motor_Aiflow_Idx_AGSOpen) - 1];
    }
    else
    {
        /* MinMax: '<S5389>/MinMax10' incorporates:
         *  Constant: '<S5498>/Calib'
         */
        rtb_Switch1_he = KeTHMR_Pct_FanSpeed_Default;
    }

    /* MinMax: '<S5389>/MinMax7' incorporates:
     *  Constant: '<S5497>/Calib'
     */
    rtb_MinMax7 = fmaxf(VeTHMR_Pct_P1Motor_Aiflow_AGS, rtb_Switch1_he);

#else

    /* MinMax: '<S5389>/MinMax7' incorporates:
     *  Constant: '<S5436>/Calib'
     *  SignalConversion generated from: '<S5364>/VariantSource'
     */
    rtb_MinMax7 = KeTHMR_Pct_NoP1MotorReq;

#endif

    /* End of Lookup_n-D: '<S5499>/Vector' */

    /* SignalConversion generated from: '<S5364>/VariantSource' */
    VeTHMR_Pct_P1Motor_MaxFanSpeed_App2 = rtb_MinMax7;

    /* SignalConversion generated from: '<S5364>/VariantSource4' incorporates:
     *  Logic: '<S5433>/Logical'
     *  Lookup_n-D: '<S5469>/Vector'
     *  Lookup_n-D: '<S5470>/Vector'
     *  MinMax: '<S5433>/MinMax2'
     *  RelationalOperator: '<S5433>/Comparison2'
     *  Rounding: '<S5433>/Rounding1'
     *  Rounding: '<S5433>/Rounding2'
     *  Selector: '<S5433>/Selector1'
     *  Switch: '<S5464>/Switch1'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

    /* MinMax: '<S5389>/MinMax7' incorporates:
     *  Constant: '<S5435>/Calib'
     */
    rtb_MinMax7 = KeTHMR_Pct_NoECMReq;

#else

    /* Rounding: '<S5433>/Rounding2' incorporates:
     *  Lookup_n-D: '<S5469>/Vector'
     *  SignalConversion generated from: '<S2>/VeTAIR_Pct_ECM_AirflowRequest'
     *  Switch: '<S3944>/Switch'
     */
    VeTHMR_y_ECM_Aiflow_Idx_AGS = ceilf(look2_iflf_binlcapw(VeTHMR_v_Vehicle,
        rtb_TmpSignalConversionAtVeT_jm, ((const float32 *)
        &(KxTHMR_Pct_ECM_Airflow_Idx_AGS[0])), ((const float32 *)
        &(KyTHMR_Pct_ECM_Airflow_Idx_AGS[0])), ((const float32 *)
        &(KtTHMR_Pct_ECM_Airflow_Idx_AGS[0])), THMR_ac_ConstP.pooled38, 11U));

    /* Selector: '<S5433>/Selector1' incorporates:
     *  Constant: '<S5465>/Calib'
     */
    VeTHMR_Pct_ECM_Aiflow_AGS = KaTHMR_Pct_ECM_Airflow_AGS[((sint32)
        VeTHMR_y_ECM_Aiflow_Idx_AGS) - 1];

    /* Rounding: '<S5433>/Rounding1' incorporates:
     *  Lookup_n-D: '<S5470>/Vector'
     *  SignalConversion generated from: '<S2>/VeTAIR_Pct_ECM_AirflowRequest'
     *  Switch: '<S3944>/Switch'
     */
    VeTHMR_y_ECM_Aiflow_Idx_AGSOpen = ceilf(look2_iflf_binlcapw(VeTHMR_v_Vehicle,
        rtb_TmpSignalConversionAtVeT_jm, ((const float32 *)
        &(KxTHMR_Pct_ECM_Airflow_Idx_AGSOpen[0])), ((const float32 *)
        &(KyTHMR_Pct_ECM_Airflow_Idx_AGSOpen[0])), ((const float32 *)
        &(KtTHMR_Pct_ECM_Airflow_Idx_AGSOpen[0])), THMR_ac_ConstP.pooled37, 11U));

    /* Switch: '<S5464>/Switch1' incorporates:
     *  Constant: '<S5467>/Calib'
     *  Logic: '<S5433>/Logical'
     *  RelationalOperator: '<S5433>/Comparison2'
     */
    if (rtb_Logical2_ioz && (VeTHMR_Pct_ECM_Aiflow_AGS >= KeTHMR_Pct_AGSOpen))
    {
        /* MinMax: '<S5389>/MinMax10' incorporates:
         *  Constant: '<S5466>/Calib'
         *  Selector: '<S5433>/Selector6'
         */
        rtb_Switch1_he = KaTHMR_Pct_ECM_Airflow_AGSOpen[((sint32)
            VeTHMR_y_ECM_Aiflow_Idx_AGSOpen) - 1];
    }
    else
    {
        /* MinMax: '<S5389>/MinMax10' incorporates:
         *  Constant: '<S5468>/Calib'
         */
        rtb_Switch1_he = KeTHMR_Pct_FanSpeed_Default;
    }

    /* MinMax: '<S5389>/MinMax7' incorporates:
     *  MinMax: '<S5433>/MinMax2'
     */
    rtb_MinMax7 = fmaxf(VeTHMR_Pct_ECM_Aiflow_AGS, rtb_Switch1_he);

#endif

    /* End of SignalConversion generated from: '<S5364>/VariantSource4' */

    /* SignalConversion generated from: '<S5364>/VariantSource4' */
    VeTHMR_Pct_ECM_MaxFanSpeed_App = rtb_MinMax7;

    /* SignalConversion generated from: '<S5364>/VariantSource1' incorporates:
     *  Logic: '<S5434>/Logical'
     *  Lookup_n-D: '<S5476>/Vector'
     *  Lookup_n-D: '<S5477>/Vector'
     *  MinMax: '<S5434>/MinMax2'
     *  RelationalOperator: '<S5434>/Comparison2'
     *  Rounding: '<S5434>/Rounding1'
     *  Rounding: '<S5434>/Rounding2'
     *  Selector: '<S5434>/Selector1'
     *  Switch: '<S5471>/Switch1'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

    /* MinMax: '<S5389>/MinMax7' incorporates:
     *  Constant: '<S5364>/Constant'
     */
    rtb_MinMax7 = 0.0F;

#else

    /* Rounding: '<S5434>/Rounding2' incorporates:
     *  Lookup_n-D: '<S5476>/Vector'
     *  Switch: '<S3944>/Switch'
     *  Switch: '<S5389>/Switch3'
     */
    VeTHMR_y_FC_HTR_Aiflow_Idx_AGS = ceilf(look2_iflf_binlcapw(VeTHMR_v_Vehicle,
        rtb_Switch3_cr, ((const float32 *)&(KxTHMR_Pct_FC_HTR_Airflow_Idx_AGS[0])),
        ((const float32 *)&(KyTHMR_Pct_FC_HTR_Airflow_Idx_AGS[0])), ((const
        float32 *)&(KtTHMR_Pct_FC_HTR_Airflow_Idx_AGS[0])),
        THMR_ac_ConstP.pooled38, 11U));

    /* Selector: '<S5434>/Selector1' incorporates:
     *  Constant: '<S5472>/Calib'
     */
    VeTHMR_Pct_FC_HTR_Aiflow_AGS = KaTHMR_Pct_FC_HTR_Airflow_AGS[((sint32)
        VeTHMR_y_FC_HTR_Aiflow_Idx_AGS) - 1];

    /* Switch: '<S5389>/Switch3' incorporates:
     *  Lookup_n-D: '<S5477>/Vector'
     *  Switch: '<S3944>/Switch'
     */
    rtb_Switch3_cr = look2_iflf_binlcapw(VeTHMR_v_Vehicle, rtb_Switch3_cr, ((
        const float32 *)&(KxTHMR_Pct_FC_HTR_Airflow_Idx_AGSOpen[0])), ((const
        float32 *)&(KyTHMR_Pct_FC_HTR_Airflow_Idx_AGSOpen[0])), ((const float32 *)
        &(KtTHMR_Pct_FC_HTR_Airflow_Idx_AGSOpen[0])), THMR_ac_ConstP.pooled37,
        11U);

    /* Rounding: '<S5434>/Rounding1' */
    VeTHMR_y_FC_HTR_Aiflow_Idx_AGSOpen = ceilf(rtb_Switch3_cr);

    /* Switch: '<S5471>/Switch1' incorporates:
     *  Constant: '<S5474>/Calib'
     *  Logic: '<S5434>/Logical'
     *  RelationalOperator: '<S5434>/Comparison2'
     */
    if (rtb_Logical2_ioz && (VeTHMR_Pct_FC_HTR_Aiflow_AGS >= KeTHMR_Pct_AGSOpen))
    {
        /* MinMax: '<S5389>/MinMax10' incorporates:
         *  Constant: '<S5473>/Calib'
         *  Selector: '<S5434>/Selector6'
         */
        rtb_Switch1_he = KaTHMR_Pct_FC_HTR_Airflow_AGSOpen[((sint32)
            VeTHMR_y_FC_HTR_Aiflow_Idx_AGSOpen) - 1];
    }
    else
    {
        /* MinMax: '<S5389>/MinMax10' incorporates:
         *  Constant: '<S5475>/Calib'
         */
        rtb_Switch1_he = KeTHMR_Pct_FanSpeed_Default;
    }

    /* MinMax: '<S5389>/MinMax7' incorporates:
     *  MinMax: '<S5434>/MinMax2'
     */
    rtb_MinMax7 = fmaxf(VeTHMR_Pct_FC_HTR_Aiflow_AGS, rtb_Switch1_he);

#endif

    /* End of SignalConversion generated from: '<S5364>/VariantSource1' */

    /* SignalConversion generated from: '<S5364>/VariantSource1' */
    VeTHMR_Pct_FC_HTR_MaxFanSpeed_App = rtb_MinMax7;

    /* Lookup_n-D: '<S5455>/Vector' incorporates:
     *  Constant: '<S5453>/Calib'
     *  Logic: '<S5431>/Logical'
     *  Lookup_n-D: '<S5456>/Vector'
     *  MinMax: '<S5431>/MinMax2'
     *  RelationalOperator: '<S5431>/Comparison2'
     *  Rounding: '<S5431>/Rounding1'
     *  Rounding: '<S5431>/Rounding2'
     *  Selector: '<S5431>/Selector1'
     *  SignalConversion generated from: '<S5364>/VariantSource3'
     *  Switch: '<S5450>/Switch1'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

    /* Rounding: '<S5431>/Rounding2' incorporates:
     *  Switch: '<S3944>/Switch'
     *  VariantMerge generated from: '<S63>/VariantSource'
     */
    VeTHMR_e_BattRad_Aiflow_Idx_AGS = ceilf(look2_iflf_binlcapw(VeTHMR_v_Vehicle,
        THMR_ac_B.VariantMerge_Fo_om, ((const float32 *)
        &(KxTHMR_Pct_BattRad_Airflow_Idx_AGS[0])), ((const float32 *)
        &(KyTHMR_Pct_BattRad_Airflow_Idx_AGS[0])), ((const float32 *)
        &(KtTHMR_Pct_BattRad_Airflow_Idx_AGS[0])), THMR_ac_ConstP.pooled38, 11U));

    /* Selector: '<S5431>/Selector1' incorporates:
     *  Constant: '<S5451>/Calib'
     */
    VeTHMR_Pct_BattRad_Aiflow_AGS = KaTHMR_Pct_BattRad_Airflow_AGS[((sint32)
        VeTHMR_e_BattRad_Aiflow_Idx_AGS) - 1];

    /* Rounding: '<S5431>/Rounding1' incorporates:
     *  Switch: '<S3944>/Switch'
     *  VariantMerge generated from: '<S63>/VariantSource'
     */
    VeTHMR_e_BattRad_Aiflow_Idx_AGSOpen = ceilf(look2_iflf_binlcapw
        (VeTHMR_v_Vehicle, THMR_ac_B.VariantMerge_Fo_om, ((const float32 *)
        &(KxTHMR_Pct_BattRad_Airflow_Idx_AGSOpen[0])), ((const float32 *)
        &(KyTHMR_Pct_BattRad_Airflow_Idx_AGSOpen[0])), ((const float32 *)
        &(KtTHMR_Pct_BattRad_Airflow_Idx_AGSOpen[0])), THMR_ac_ConstP.pooled37,
         11U));
    if (rtb_Logical2_ioz && (VeTHMR_Pct_BattRad_Aiflow_AGS >= KeTHMR_Pct_AGSOpen))
    {
        /* MinMax: '<S5389>/MinMax10' incorporates:
         *  Constant: '<S5452>/Calib'
         *  Selector: '<S5431>/Selector6'
         */
        rtb_Switch1_he = KaTHMR_Pct_BattRad_Airflow_AGSOpen[((sint32)
            VeTHMR_e_BattRad_Aiflow_Idx_AGSOpen) - 1];
    }
    else
    {
        /* MinMax: '<S5389>/MinMax10' incorporates:
         *  Constant: '<S5454>/Calib'
         */
        rtb_Switch1_he = KeTHMR_Pct_FanSpeed_Default;
    }

    /* MinMax: '<S5389>/MinMax7' incorporates:
     *  Constant: '<S5453>/Calib'
     */
    rtb_MinMax7 = fmaxf(VeTHMR_Pct_BattRad_Aiflow_AGS, rtb_Switch1_he);

#else

    /* MinMax: '<S5389>/MinMax7' incorporates:
     *  Constant: '<S5364>/Constant1'
     *  SignalConversion generated from: '<S5364>/VariantSource3'
     */
    rtb_MinMax7 = 0.0F;

#endif

    /* End of Lookup_n-D: '<S5455>/Vector' */

    /* SignalConversion generated from: '<S5364>/VariantSource3' */
    VeTHMR_Pct_BattRad_MaxFanSpeed_App = rtb_MinMax7;

    /* MinMax: '<S5364>/MinMax1' */
    VeTHMR_Pct_MaxFanSpeed_App2 = fmaxf(fmaxf(fmaxf(fmaxf(fmaxf
        (VeTHMR_Pct_LTR_MaxFanSpeed_App2, VeTHMR_Pct_CndnsrPPU_AirFlwReq),
        VeTHMR_Pct_P1Motor_MaxFanSpeed_App2), VeTHMR_Pct_ECM_MaxFanSpeed_App),
        VeTHMR_Pct_FC_HTR_MaxFanSpeed_App), VeTHMR_Pct_BattRad_MaxFanSpeed_App);

    /* Switch: '<S84>/Switch1' incorporates:
     *  Constant: '<S5376>/Calib'
     *  Constant: '<S5381>/Calib'
     */
    if (!KeTHMR_b_PPU_Airflow_TypeSlct)
    {
        rtb_TmpSignalConversionAtVeTMIR = KeTHMR_Pct_PPU_Airflow_MinDummy;
    }

    /* End of Switch: '<S84>/Switch1' */

    /* MinMax: '<S84>/MinMax2' */
    VeTHMR_Pct_Normlzd_MaxFanSpeed_AftMax = fmaxf(fmaxf(fmaxf(fmaxf(fmaxf
        (VeTHMR_Pct_Emrgcy_NrmlzdFanSpeed, VeTHMR_Pct_MaxFanSpeed_App2),
        rtb_UnitDelay_cui), rtb_Sum_e), rtb_TmpSignalConversionAtVeTMIR),
        VeTHMR_Pct_Normlzd_Aftrrun);

    /* Gain: '<S5396>/Gain' */
    VeTHMR_Pct_Normlzd_MaxFanSpeed_B4D = VeTHMR_Pct_Normlzd_MaxFanSpeed_AftMax;

    /* Switch: '<S84>/Switch5' incorporates:
     *  Constant: '<S5382>/Calib'
     */
    if (KeTHMR_b_RadFan_AGS_Enbl)
    {
        /* Product: '<S5389>/Product' incorporates:
         *  Constant: '<S5592>/Calib'
         */
        rtb_Product_o0[0] = KaTHMR_b_SolitaryOrCndnsr_AGS[0] ? rtb_UnitDelay_oqi
            : 0.0F;
        rtb_Product_o0[1] = KaTHMR_b_SolitaryOrCndnsr_AGS[1] ? rtb_Merge1_i :
            0.0F;
        rtb_Product_o0[2] = KaTHMR_b_SolitaryOrCndnsr_AGS[2] ? rtb_Switch1_i3 :
            0.0F;
        rtb_Product_o0[3] = KaTHMR_b_SolitaryOrCndnsr_AGS[3] ? rtb_UnitDelay_nr :
            0.0F;
        rtb_Product_o0[4] = KaTHMR_b_SolitaryOrCndnsr_AGS[4] ? rtb_Switch15 :
            0.0F;
        rtb_Product_o0[5] = KaTHMR_b_SolitaryOrCndnsr_AGS[5] ? rtb_Switch10 :
            0.0F;
        rtb_Product_o0[6] = KaTHMR_b_SolitaryOrCndnsr_AGS[6] ? rtb_Switch11 :
            0.0F;

        /* MinMax: '<S5389>/MinMax6' */
        rtb_Switch3_cr = rtb_Product_o0[0];
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 6;
                rtb_DataTypeConversion2++)
        {
            rtb_Switch3_cr = fmaxf(rtb_Switch3_cr,
                                   rtb_Product_o0[rtb_DataTypeConversion2 + 1]);
        }

        /* End of MinMax: '<S5389>/MinMax6' */
    }
    else
    {
        /* Switch: '<S84>/Switch5' incorporates:
         *  Gain: '<S5396>/Gain'
         *  Lookup_n-D: '<S5385>/Vector'
         */
        rtb_Switch3_cr = look1_iflf_binlcapw(VeTHMR_Pct_Normlzd_MaxFanSpeed_B4D,
            ((const float32 *)&(KxTHMR_Pct_AGS_PosReqLUT[0])), ((const float32 *)
            &(KtTHMR_Pct_AGS_PosReqLUT[0])), 9U);
    }

    /* End of Switch: '<S84>/Switch5' */

    /* Switch: '<S5409>/Switch1' incorporates:
     *  RelationalOperator: '<S5362>/RelationalOperator1'
     */
    if (((sint32)rtb_TmpSignalConversionAtVePRXR) == 0)
    {
        /* Switch: '<S5409>/Switch1' incorporates:
         *  Constant: '<S5415>/Calib'
         */
        rtb_TmpSignalConversionAtVeTMIR = KeTHMR_Pct_AGS1_Dsbl;

        /* Switch: '<S5412>/Switch1' incorporates:
         *  Constant: '<S5417>/Calib'
         */
        rtb_TmpSignalConversionAtVeT_jm = KeTHMR_Pct_AGS2_Dsbl;
    }
    else
    {
        /* Switch: '<S5410>/Switch1' incorporates:
         *  RelationalOperator: '<S5362>/RelationalOperator2'
         */
        if (((sint32)rtb_TmpSignalConversionAtVePRXR) == 1)
        {
            /* Switch: '<S5409>/Switch1' incorporates:
             *  Lookup_n-D: '<S5420>/Vector'
             *  Switch: '<S5410>/Switch1'
             *  Switch: '<S84>/Switch5'
             */
            rtb_TmpSignalConversionAtVeTMIR = look1_iflf_binlcapw(rtb_Switch3_cr,
                ((const float32 *)&(KxTHMR_Pct_AGS1_PosReqLUT[0])), ((const
                float32 *)&(KtTHMR_Pct_AGS1_PosReqLUT[0])), 9U);
        }
        else if (((sint32)rtb_TmpSignalConversionAtVePRXR) == 2)
        {
            /* Switch: '<S5409>/Switch1' incorporates:
             *  Lookup_n-D: '<S5421>/Vector'
             *  Switch: '<S5411>/Switch1'
             *  Switch: '<S84>/Switch5'
             */
            rtb_TmpSignalConversionAtVeTMIR = look1_iflf_binlcapw(rtb_Switch3_cr,
                ((const float32 *)&(KxTHMR_Pct_AGS1_PosReqLUT1[0])), ((const
                float32 *)&(KtTHMR_Pct_AGS1_PosReqLUT1[0])), 9U);
        }
        else
        {
            /* Switch: '<S5409>/Switch1' incorporates:
             *  Constant: '<S5416>/Calib'
             *  Switch: '<S5411>/Switch1'
             */
            rtb_TmpSignalConversionAtVeTMIR = KeTHMR_Pct_AGS1_Dsbl;
        }

        /* End of Switch: '<S5410>/Switch1' */

        /* Switch: '<S5413>/Switch1' incorporates:
         *  RelationalOperator: '<S5362>/RelationalOperator5'
         *  RelationalOperator: '<S5362>/RelationalOperator6'
         *  Switch: '<S5412>/Switch1'
         *  Switch: '<S5414>/Switch1'
         */
        if (((sint32)rtb_TmpSignalConversionAtVePRXR) == 1)
        {
            /* Switch: '<S5412>/Switch1' incorporates:
             *  Constant: '<S5418>/Calib'
             *  Switch: '<S5413>/Switch1'
             */
            rtb_TmpSignalConversionAtVeT_jm = KeTHMR_Pct_AGS2_Dsbl;
        }
        else if (((sint32)rtb_TmpSignalConversionAtVePRXR) == 2)
        {
            /* Switch: '<S5414>/Switch1' incorporates:
             *  Lookup_n-D: '<S5422>/Vector'
             *  Switch: '<S5412>/Switch1'
             *  Switch: '<S84>/Switch5'
             */
            rtb_TmpSignalConversionAtVeT_jm = look1_iflf_binlcapw(rtb_Switch3_cr,
                ((const float32 *)&(KxTHMR_Pct_AGS2_PosReqLUT[0])), ((const
                float32 *)&(KtTHMR_Pct_AGS2_PosReqLUT[0])), 9U);
        }
        else
        {
            /* Switch: '<S5412>/Switch1' incorporates:
             *  Constant: '<S5419>/Calib'
             *  Switch: '<S5414>/Switch1'
             */
            rtb_TmpSignalConversionAtVeT_jm = KeTHMR_Pct_AGS2_Dsbl;
        }

        /* End of Switch: '<S5413>/Switch1' */
    }

    /* End of Switch: '<S5409>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeFSCR_Pct_AGS2_MinAchvblPos' */
    (void)Rte_Read_VeFSCR_Pct_AGS2_MinAchvblPos_Value(&rtb_SumSub1_ni);

    /* Inport: '<Root>/VeFSCR_Pct_AGS1_MinAchvblPos' */
    (void)Rte_Read_VeFSCR_Pct_AGS1_MinAchvblPos_Value(&Switch1_e);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/ThermalAirflow_Arb'
     */
    /* Lookup_n-D: '<S5516>/Vector' incorporates:
     *  Inport: '<Root>/VeFSCR_Pct_AGS1_MinAchvblPos'
     *  Inport: '<Root>/VeFSCR_Pct_AGS2_MinAchvblPos'
     *  Lookup_n-D: '<S5514>/Vector'
     *  Switch: '<S3944>/Switch'
     */
    VeTHMR_dV_MinAchvblArflwEst_Ohx = look2_iflf_binlcapw(VeTHMR_v_Vehicle,
        look2_iflf_binlcapw(Switch1_e, rtb_SumSub1_ni, ((const float32 *)
        &(KxTHMR_Pct_EffctvAGSCombPos[0])), ((const float32 *)
        &(KyTHMR_Pct_EffctvAGSCombPos[0])), ((const float32 *)
        &(KtTHMR_Pct_EffctvAGSCombPos[0])), THMR_ac_ConstP.pooled47, 7U), ((
        const float32 *)&(KxTHMR_dV_MinAchvblArflwEst_Ohx[0])), ((const float32 *)
        &(KyTHMR_dV_MinAchvblArflwEst_Ohx[0])), ((const float32 *)
        &(KtTHMR_dV_MinAchvblArflwEst_Ohx[0])), THMR_ac_ConstP.Vector_maxIndex_a,
        6U);

    /* Switch: '<S5367>/Switch1' */
    if (rtb_Logical2_ioz)
    {
        /* Switch: '<S5367>/Switch1' incorporates:
         *  Lookup_n-D: '<S5515>/Vector'
         *  Switch: '<S3944>/Switch'
         *  Switch: '<S4016>/Switch'
         */
        Switch1_e = look2_iflf_binlcapw(VeTHMR_Pct_RadFanSts_AftDial,
            VeTHMR_v_Vehicle, ((const float32 *)&(KxTHMR_dV_EstAirflow_Max[0])),
            ((const float32 *)&(KyTHMR_dV_EstAirflow_Max[0])), ((const float32 *)
            &(KtTHMR_dV_EstAirflow_Max[0])), THMR_ac_ConstP.Vector_maxIndex_b,
            5U);
    }
    else
    {
        /* Switch: '<S5367>/Switch1' */
        Switch1_e = VeTHMR_dV_MinAchvblArflwEst_Ohx;
    }

    /* End of Switch: '<S5367>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S5519>/EdgeRising' */
    /* Logic: '<S5530>/OR1' incorporates:
     *  UnitDelay: '<S5530>/UnitDelay'
     */
    rtb_OR1_jc2 = !THMR_ac_DW.UnitDelay_DSTATE_nh;

    /* Update for UnitDelay: '<S5530>/UnitDelay' incorporates:
     *  Constant: '<S5519>/TRUEConstant'
     */
    THMR_ac_DW.UnitDelay_DSTATE_nh = true;

    /* Outputs for Atomic SubSystem: '<S5519>/PIDControl' */
    /* Switch: '<S5540>/Switch' incorporates:
     *  Logic: '<S5530>/AND'
     */
    if (rtb_OR1_jc2)
    {
        /* Switch: '<S5540>/Switch' incorporates:
         *  Constant: '<S5519>/ConstantValue1'
         */
        rtb_Switch1_ofq = 0.0F;
    }
    else
    {
        /* Switch: '<S5540>/Switch' incorporates:
         *  UnitDelay: '<S5540>/UnitDelay'
         */
        rtb_Switch1_ofq = THMR_ac_DW.UnitDelay_DSTATE_jb;
    }

    /* End of Switch: '<S5540>/Switch' */
    /* End of Outputs for SubSystem: '<S5519>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S5540>/integral_term' */
    /* Switch: '<S5541>/Switch1' incorporates:
     *  Constant: '<S5537>/Calib'
     *  RelationalOperator: '<S5541>/RelationalOperator'
     */
    if (KeTHMR_k_MaxITerm_HtrAirFlw < rtb_Switch1_ofq)
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = KeTHMR_k_MaxITerm_HtrAirFlw;
    }
    else
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = rtb_Switch1_ofq;
    }

    /* End of Switch: '<S5541>/Switch1' */

    /* Switch: '<S5541>/Switch' incorporates:
     *  Constant: '<S5538>/Calib'
     *  RelationalOperator: '<S5541>/RelationalOperator1'
     */
    if (rtb_Switch1_he > KeTHMR_k_MinITerm_HtrAirFlw)
    {
        /* Switch: '<S5541>/Switch' */
        rtb_Switch1_ofq = rtb_Switch1_he;
    }
    else
    {
        /* Switch: '<S5541>/Switch' */
        rtb_Switch1_ofq = KeTHMR_k_MinITerm_HtrAirFlw;
    }

    /* End of Switch: '<S5541>/Switch' */
    /* End of Outputs for SubSystem: '<S5540>/integral_term' */

    /* Sum: '<S5540>/Sum//Sub1' incorporates:
     *  Constant: '<S5519>/ConstantValue2'
     *  Constant: '<S5534>/Calib'
     *  Product: '<S5540>/Multiplication2'
     *  Product: '<S5540>/derivative_term'
     *  Sum: '<S5540>/Sum//Sub2'
     *  UnitDelay: '<S5540>/UnitDelay1'
     */
    rtb_SumSub1_ni = (((0.0F - THMR_ac_DW.UnitDelay1_DSTATE_h5) *
                       KeTHMR_k_HtrDterm_HtrAirFlw) / 0.1F) + rtb_Switch1_ofq;

    /* Update for UnitDelay: '<S5540>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_h5 = 0.0F;

    /* Update for UnitDelay: '<S5540>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_jb = rtb_Switch1_ofq;

    /* Outputs for Atomic SubSystem: '<S5519>/Limiter' */
    /* Switch: '<S5539>/Switch1' incorporates:
     *  Constant: '<S5532>/Calib'
     *  RelationalOperator: '<S5539>/RelationalOperator'
     *  Switch: '<S5540>/Switch1'
     */
    if (KeTHMR_dV_FanPID_HtrAirFlw_Max < rtb_SumSub1_ni)
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = KeTHMR_dV_FanPID_HtrAirFlw_Max;
    }
    else
    {
        /* MinMax: '<S5389>/MinMax10' */
        rtb_Switch1_he = rtb_SumSub1_ni;
    }

    /* End of Switch: '<S5539>/Switch1' */
    /* End of Outputs for SubSystem: '<S5519>/PIDControl' */

    /* Switch: '<S5539>/Switch' incorporates:
     *  Constant: '<S5533>/Calib'
     *  RelationalOperator: '<S5539>/RelationalOperator1'
     */
    if (rtb_Switch1_he > KeTHMR_dV_FanPID_HtrAirFlw_Min)
    {
        /* Switch: '<S5539>/Switch' */
        VeTHMR_dV_HtrAirFlow_PID = rtb_Switch1_he;
    }
    else
    {
        /* Switch: '<S5539>/Switch' */
        VeTHMR_dV_HtrAirFlow_PID = KeTHMR_dV_FanPID_HtrAirFlw_Min;
    }

    /* End of Switch: '<S5539>/Switch' */
    /* End of Outputs for SubSystem: '<S5519>/Limiter' */

    /* MinMax: '<S5387>/MinMax1' incorporates:
     *  Lookup_n-D: '<S5524>/Vector'
     *  MinMax: '<S5387>/MinMax5'
     *  Switch: '<S3944>/Switch'
     */
    VeTHMR_dV_FanPID_AirFlwDsrd = fmaxf(fmaxf(fmaxf(fmaxf(rtb_Switch_ii,
        rtb_MinMax3_h), Switch4_d), fminf(VeTHMR_dV_HtrAirFlow_PID,
        look1_iflf_binlcapw(VeTHMR_v_Vehicle, ((const float32 *)
        &(KxTHMR_dV_MaxAirFlw_HiTempRad[0])), ((const float32 *)
        &(KtTHMR_dV_MaxAirFlw_HiTempRad[0])), 4U))), rtb_Merge8);

    /* Lookup_n-D: '<S5602>/Vector' incorporates:
     *  Switch: '<S3944>/Switch'
     *  VariantMerge generated from: '<S63>/VariantSource'
     */
    rtb_SumSub1_ni = look2_iflf_binlcapw(VeTHMR_v_Vehicle,
        THMR_ac_B.VariantMerge_Fo_om, ((const float32 *)
        &(KxTHMR_Pct_BattRad_FanPWM_Req[0])), ((const float32 *)
        &(KyTHMR_Pct_BattRad_FanPWM_Req[0])), ((const float32 *)
        &(KtTHMR_Pct_BattRad_FanPWM_Req[0])), THMR_ac_ConstP.pooled37, 11U);

    /* Lookup_n-D: '<S5604>/Vector' incorporates:
     *  MinMax: '<S5389>/MinMax8'
     *  Switch: '<S3944>/Switch'
     */
    rtb_MinMax7 = look2_iflf_binlcapw(VeTHMR_v_Vehicle, rtb_MinMax8, ((const
        float32 *)&(KxTHMR_Pct_DirectAirFlw_FanPWM_Req[0])), ((const float32 *)
        &(KyTHMR_Pct_DirectAirFlw_FanPWM_Req[0])), ((const float32 *)
        &(KtTHMR_Pct_DirectAirFlw_FanPWM_Req[0])), THMR_ac_ConstP.pooled37, 11U);

    /* Lookup_n-D: '<S5606>/Vector' incorporates:
     *  Switch: '<S3944>/Switch'
     *  Switch: '<S5389>/Switch2'
     */
    rtb_Product1_nd = look2_iflf_binlcapw(VeTHMR_v_Vehicle, rtb_Switch2_pg, ((
        const float32 *)&(KxTHMR_Pct_EngRad_FanPWM_Req[0])), ((const float32 *)
        &(KyTHMR_Pct_EngRad_FanPWM_Req[0])), ((const float32 *)
        &(KtTHMR_Pct_EngRad_FanPWM_Req[0])), THMR_ac_ConstP.pooled37, 11U);

    /* Lookup_n-D: '<S5610>/Vector' incorporates:
     *  Switch: '<S3944>/Switch'
     *  Switch: '<S5389>/Switch4'
     */
    rtb_Switch_ii = look2_iflf_binlcapw(VeTHMR_v_Vehicle, rtb_Vector_h00, ((
        const float32 *)&(KxTHMR_Pct_LTR_FanPWM_Req[0])), ((const float32 *)
        &(KyTHMR_Pct_LTR_FanPWM_Req[0])), ((const float32 *)
        &(KtTHMR_Pct_LTR_FanPWM_Req[0])), THMR_ac_ConstP.pooled37, 11U);

    /* Lookup_n-D: '<S5613>/Vector' incorporates:
     *  MinMax: '<S5389>/MinMax'
     *  Switch: '<S3944>/Switch'
     */
    rtb_TmpSignalConversionAtVePM_d = look2_iflf_binlcapw(VeTHMR_v_Vehicle,
        rtb_Product_gg, ((const float32 *)&(KxTHMR_Pct_OHX_FanPWM_Req[0])), ((
        const float32 *)&(KyTHMR_Pct_OHX_FanPWM_Req[0])), ((const float32 *)
        &(KtTHMR_Pct_OHX_FanPWM_Req[0])), THMR_ac_ConstP.pooled37, 11U);

    /* Product: '<S5389>/Product2' incorporates:
     *  Constant: '<S5586>/Calib'
     *  Product: '<S5389>/Product4'
     */
    rtb_Product_o0[0] = KaTHMR_b_BattRad_AGS[0] ? rtb_UnitDelay_oqi : 0.0F;
    rtb_Product_o0[1] = KaTHMR_b_BattRad_AGS[1] ? rtb_Merge1_i : 0.0F;
    rtb_Product_o0[2] = KaTHMR_b_BattRad_AGS[2] ? rtb_Switch1_i3 : 0.0F;
    rtb_Product_o0[3] = KaTHMR_b_BattRad_AGS[3] ? rtb_UnitDelay_nr : 0.0F;
    rtb_Product_o0[4] = KaTHMR_b_BattRad_AGS[4] ? rtb_Switch15 : 0.0F;
    rtb_Product_o0[5] = KaTHMR_b_BattRad_AGS[5] ? rtb_Switch10 : 0.0F;
    rtb_Product_o0[6] = KaTHMR_b_BattRad_AGS[6] ? rtb_Switch11 : 0.0F;

    /* MinMax: '<S5389>/MinMax10' */
    rtb_Switch1_ofq = rtb_Product_o0[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 6;
            rtb_DataTypeConversion2++)
    {
        rtb_Switch1_ofq = fmaxf(rtb_Switch1_ofq,
                                rtb_Product_o0[rtb_DataTypeConversion2 + 1]);
    }

    /* Product: '<S5389>/Product2' incorporates:
     *  Constant: '<S5590>/Calib'
     *  Product: '<S5389>/Product1'
     */
    rtb_Product_o0[0] = KaTHMR_b_LTR_AGS[0] ? rtb_UnitDelay_oqi : 0.0F;
    rtb_Product_o0[1] = KaTHMR_b_LTR_AGS[1] ? rtb_Merge1_i : 0.0F;
    rtb_Product_o0[2] = KaTHMR_b_LTR_AGS[2] ? rtb_Switch1_i3 : 0.0F;
    rtb_Product_o0[3] = KaTHMR_b_LTR_AGS[3] ? rtb_UnitDelay_nr : 0.0F;
    rtb_Product_o0[4] = KaTHMR_b_LTR_AGS[4] ? rtb_Switch15 : 0.0F;
    rtb_Product_o0[5] = KaTHMR_b_LTR_AGS[5] ? rtb_Switch10 : 0.0F;
    rtb_Product_o0[6] = KaTHMR_b_LTR_AGS[6] ? rtb_Switch11 : 0.0F;

    /* MinMax: '<S5389>/MinMax7' */
    rtb_MinMax8 = rtb_Product_o0[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 6;
            rtb_DataTypeConversion2++)
    {
        rtb_MinMax8 = fmaxf(rtb_MinMax8, rtb_Product_o0[rtb_DataTypeConversion2
                            + 1]);
    }

    /* Product: '<S5389>/Product2' incorporates:
     *  Constant: '<S5588>/Calib'
     */
    rtb_Product_o0[0] = KaTHMR_b_HTR_AGS[0] ? rtb_UnitDelay_oqi : 0.0F;
    rtb_Product_o0[1] = KaTHMR_b_HTR_AGS[1] ? rtb_Merge1_i : 0.0F;
    rtb_Product_o0[2] = KaTHMR_b_HTR_AGS[2] ? rtb_Switch1_i3 : 0.0F;
    rtb_Product_o0[3] = KaTHMR_b_HTR_AGS[3] ? rtb_UnitDelay_nr : 0.0F;
    rtb_Product_o0[4] = KaTHMR_b_HTR_AGS[4] ? rtb_Switch15 : 0.0F;
    rtb_Product_o0[5] = KaTHMR_b_HTR_AGS[5] ? rtb_Switch10 : 0.0F;
    rtb_Product_o0[6] = KaTHMR_b_HTR_AGS[6] ? rtb_Switch11 : 0.0F;

    /* MinMax: '<S5389>/MinMax8' */
    rtb_MinMax3_h = rtb_Product_o0[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 6;
            rtb_DataTypeConversion2++)
    {
        rtb_MinMax3_h = fmaxf(rtb_MinMax3_h,
                              rtb_Product_o0[rtb_DataTypeConversion2 + 1]);
    }

    /* Switch: '<S5389>/Switch2' incorporates:
     *  Switch: '<S5389>/Switch3'
     *  Switch: '<S5389>/Switch4'
     */
    if (rtb_Logical2_ioz)
    {
        /* Product: '<S5389>/Product6' incorporates:
         *  Constant: '<S5591>/Calib'
         */
        rtb_Product_o0[0] = KaTHMR_b_LTR_FanPWM[0] ?
            rtb_TmpSignalConversionAtVePM_d : 0.0F;
        rtb_Product_o0[1] = KaTHMR_b_LTR_FanPWM[1] ? rtb_Switch_ii : 0.0F;
        rtb_Product_o0[2] = KaTHMR_b_LTR_FanPWM[2] ?
            rtb_VeTHMR_Pct_FCHTRRadFanCmd : 0.0F;
        rtb_Product_o0[3] = KaTHMR_b_LTR_FanPWM[3] ? rtb_Product1_nd : 0.0F;
        rtb_Product_o0[4] = KaTHMR_b_LTR_FanPWM[4] ? rtb_SumSub1_ni : 0.0F;
        rtb_Product_o0[5] = KaTHMR_b_LTR_FanPWM[5] ? rtb_MinMax7 : 0.0F;
        rtb_Product_o0[6] = KaTHMR_b_LTR_FanPWM[6] ?
            rtb_TmpSignalConversionAtVeTA_n : 0.0F;

        /* MinMax: '<S5389>/MinMax13' */
        rtb_Switch2_pg = rtb_Product_o0[0];
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 6;
                rtb_DataTypeConversion2++)
        {
            rtb_Switch2_pg = fmaxf(rtb_Switch2_pg,
                                   rtb_Product_o0[rtb_DataTypeConversion2 + 1]);
        }

        /* End of MinMax: '<S5389>/MinMax13' */

        /* Product: '<S5389>/Product7' incorporates:
         *  Constant: '<S5589>/Calib'
         */
        rtb_Product_o0[0] = KaTHMR_b_HTR_FanPWM[0] ?
            rtb_TmpSignalConversionAtVePM_d : 0.0F;
        rtb_Product_o0[1] = KaTHMR_b_HTR_FanPWM[1] ? rtb_Switch_ii : 0.0F;
        rtb_Product_o0[2] = KaTHMR_b_HTR_FanPWM[2] ?
            rtb_VeTHMR_Pct_FCHTRRadFanCmd : 0.0F;
        rtb_Product_o0[3] = KaTHMR_b_HTR_FanPWM[3] ? rtb_Product1_nd : 0.0F;
        rtb_Product_o0[4] = KaTHMR_b_HTR_FanPWM[4] ? rtb_SumSub1_ni : 0.0F;
        rtb_Product_o0[5] = KaTHMR_b_HTR_FanPWM[5] ? rtb_MinMax7 : 0.0F;
        rtb_Product_o0[6] = KaTHMR_b_HTR_FanPWM[6] ?
            rtb_TmpSignalConversionAtVeTA_n : 0.0F;

        /* MinMax: '<S5389>/MinMax14' */
        rtb_Switch3_cr = rtb_Product_o0[0];
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 6;
                rtb_DataTypeConversion2++)
        {
            rtb_Switch3_cr = fmaxf(rtb_Switch3_cr,
                                   rtb_Product_o0[rtb_DataTypeConversion2 + 1]);
        }

        /* End of MinMax: '<S5389>/MinMax14' */

        /* Product: '<S5389>/Product9' incorporates:
         *  Constant: '<S5587>/Calib'
         */
        rtb_Product_o0[0] = KaTHMR_b_BattRad_FanPWM[0] ?
            rtb_TmpSignalConversionAtVePM_d : 0.0F;
        rtb_Product_o0[1] = KaTHMR_b_BattRad_FanPWM[1] ? rtb_Switch_ii : 0.0F;
        rtb_Product_o0[2] = KaTHMR_b_BattRad_FanPWM[2] ?
            rtb_VeTHMR_Pct_FCHTRRadFanCmd : 0.0F;
        rtb_Product_o0[3] = KaTHMR_b_BattRad_FanPWM[3] ? rtb_Product1_nd : 0.0F;
        rtb_Product_o0[4] = KaTHMR_b_BattRad_FanPWM[4] ? rtb_SumSub1_ni : 0.0F;
        rtb_Product_o0[5] = KaTHMR_b_BattRad_FanPWM[5] ? rtb_MinMax7 : 0.0F;
        rtb_Product_o0[6] = KaTHMR_b_BattRad_FanPWM[6] ?
            rtb_TmpSignalConversionAtVeTA_n : 0.0F;

        /* MinMax: '<S5389>/MinMax11' */
        rtb_Vector_h00 = rtb_Product_o0[0];
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 6;
                rtb_DataTypeConversion2++)
        {
            rtb_Vector_h00 = fmaxf(rtb_Vector_h00,
                                   rtb_Product_o0[rtb_DataTypeConversion2 + 1]);
        }

        /* End of MinMax: '<S5389>/MinMax11' */
    }
    else
    {
        /* Switch: '<S5389>/Switch2' incorporates:
         *  Constant: '<S5594>/Calib'
         */
        rtb_Switch2_pg = KeTHMR_Pct_FanSpeed_Default;

        /* Switch: '<S5389>/Switch3' incorporates:
         *  Constant: '<S5594>/Calib'
         */
        rtb_Switch3_cr = KeTHMR_Pct_FanSpeed_Default;

        /* Switch: '<S5389>/Switch4' incorporates:
         *  Constant: '<S5594>/Calib'
         */
        rtb_Vector_h00 = KeTHMR_Pct_FanSpeed_Default;
    }

    /* End of Switch: '<S5389>/Switch2' */

    /* Switch: '<S84>/Switch6' incorporates:
     *  Constant: '<S5382>/Calib'
     */
    if (KeTHMR_b_RadFan_AGS_Enbl)
    {
        /* Switch: '<S5389>/Switch1' */
        if (rtb_Logical2_ioz)
        {
            /* Product: '<S5389>/Product5' incorporates:
             *  Constant: '<S5593>/Calib'
             */
            rtb_Product_o0[0] = KaTHMR_b_SolitaryOrCndnsr_FanPWM[0] ?
                rtb_TmpSignalConversionAtVePM_d : 0.0F;
            rtb_Product_o0[1] = KaTHMR_b_SolitaryOrCndnsr_FanPWM[1] ?
                rtb_Switch_ii : 0.0F;
            rtb_Product_o0[2] = KaTHMR_b_SolitaryOrCndnsr_FanPWM[2] ?
                rtb_VeTHMR_Pct_FCHTRRadFanCmd : 0.0F;
            rtb_Product_o0[3] = KaTHMR_b_SolitaryOrCndnsr_FanPWM[3] ?
                rtb_Product1_nd : 0.0F;
            rtb_Product_o0[4] = KaTHMR_b_SolitaryOrCndnsr_FanPWM[4] ?
                rtb_SumSub1_ni : 0.0F;
            rtb_Product_o0[5] = KaTHMR_b_SolitaryOrCndnsr_FanPWM[5] ?
                rtb_MinMax7 : 0.0F;
            rtb_Product_o0[6] = KaTHMR_b_SolitaryOrCndnsr_FanPWM[6] ?
                rtb_TmpSignalConversionAtVeTA_n : 0.0F;

            /* MinMax: '<S5389>/MinMax12' */
            rtb_SumSub1_ni = rtb_Product_o0[0];
            for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 6;
                    rtb_DataTypeConversion2++)
            {
                rtb_SumSub1_ni = fmaxf(rtb_SumSub1_ni,
                                       rtb_Product_o0[rtb_DataTypeConversion2 +
                                       1]);
            }

            /* End of MinMax: '<S5389>/MinMax12' */
        }
        else
        {
            /* Switch: '<S84>/Switch6' incorporates:
             *  Constant: '<S5594>/Calib'
             *  Switch: '<S5389>/Switch1'
             */
            rtb_SumSub1_ni = KeTHMR_Pct_FanSpeed_Default;
        }

        /* End of Switch: '<S5389>/Switch1' */
    }
    else
    {
        /* Switch: '<S84>/Switch6' */
        rtb_SumSub1_ni = VeTHMR_Pct_Normlzd_MaxFanSpeed_B4D;
    }

    /* End of Switch: '<S84>/Switch6' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeTMIR_b_ECM_FanAftRunRq_FA' */
    (void)Rte_Read_VeTMIR_b_ECM_FanAftRunRq_FA_Value(&Gain_cm);

    /* Inport: '<Root>/VeTMIR_e_ECM_LTP_FanAftRunRq' */
    (void)Rte_Read_VeTMIR_e_ECM_LTP_FanAftRunRq_Value(&Switch1_ed);

    /* Inport: '<Root>/VePMPR_e_LTPsvPump2_PstRnSt' */
    (void)Rte_Read_VePMPR_e_LTPsvPump2_PstRnSt_Value(&tmpRead_15);

    /* Inport: '<Root>/VePMPR_e_LTPsvPump_PstRnSt' */
    (void)Rte_Read_VePMPR_e_LTPsvPump_PstRnSt_Value(&tmpRead_13);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/ThermalAirflow_Arb'
     */
    /* Update for UnitDelay: '<S5529>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ov = VeTHMR_dV_PresErr_PID;

    /* Update for UnitDelay: '<S5528>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_lw = VeTHMR_dV_PSucErr_PID;

    /* Update for UnitDelay: '<S5527>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_gf = VeTHMR_dV_ClntErr_PID;

    /* Update for UnitDelay: '<S5519>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ana = VeTHMR_dV_HtrAirFlow_PID;

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/ProcessAftrRunRq'
     */
    /* UnitDelay: '<S71>/Unit Delay1' */
    VeTHMR_b_RstKeyLtch_AftrRun = THMR_ac_DW.UnitDelay1_DSTATE_eg;

    /* RelationalOperator: '<S71>/Comparison1' incorporates:
     *  Chart: '<S71>/AfterRun'
     *  RelationalOperator: '<S71>/Comparison2'
     *  SignalConversion generated from: '<S2>/VePMDR_e_KeyStatus'
     */
    VeTHMR_b_KeyXstnOffThisCycle_tm = THMR_ac_B.TmpSignalConversionAtVePMDR_e_K;

    /* Outputs for Atomic SubSystem: '<S71>/Signal Latch On With Reset' */
    /* Logic: '<S3646>/OR1' incorporates:
     *  Constant: '<S3624>/Constant'
     *  Constant: '<S3625>/Constant'
     *  Constant: '<S3626>/Constant'
     *  Logic: '<S3646>/NOT'
     *  Logic: '<S3646>/OR'
     *  Logic: '<S71>/Logical1'
     *  Logic: '<S71>/Logical3'
     *  RelationalOperator: '<S71>/Comparison1'
     *  RelationalOperator: '<S71>/Comparison2'
     *  RelationalOperator: '<S71>/Comparison8'
     *  UnitDelay: '<S3646>/Unit Delay'
     *  UnitDelay: '<S71>/Unit Delay'
     */
    VeTHMR_b_KeyXstnOffThisCycle = (((((uint32)VeTHMR_b_KeyXstnOffThisCycle_tm) ==
        CePMDR_e_KeySt_Off) && (((uint32)THMR_ac_DW.UnitDelay_DSTATE_fw) !=
        CePMDR_e_KeySt_Off)) || (((((uint32)VeTHMR_b_KeyXstnOffThisCycle_tm) ==
        CePMDR_e_KeySt_Off) && (!VeTHMR_b_RstKeyLtch_AftrRun)) &&
        (THMR_ac_DW.UnitDelay_DSTATE_ihx)));

    /* Update for UnitDelay: '<S3646>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_ihx = VeTHMR_b_KeyXstnOffThisCycle;

    /* End of Outputs for SubSystem: '<S71>/Signal Latch On With Reset' */

    /* Logic: '<S71>/Logical4' incorporates:
     *  Constant: '<S3631>/Calib'
     */
    rtb_OR1_jc2 = ((VeTHMR_b_LearningOk) || (KeTHMR_b_DisableLearningFrAftrrun));

    /* Switch: '<S3629>/Switch1' incorporates:
     *  Logic: '<S71>/Logical2'
     */
    if (!Gain_cm)
    {
    }
    else
    {
        /* Switch: '<S3629>/Switch1' incorporates:
         *  Constant: '<S3635>/Calib'
         */
        Switch1_ed = KeTHMR_e_ECM_LTP_FanAftRunRqDflt;
    }

    /* End of Switch: '<S3629>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Switch: '<S3630>/Switch1' incorporates:
     *  Constant: '<S3627>/Constant'
     *  Inport: '<S2741>/In1'
     *  Logic: '<S71>/Logical14'
     *  RelationalOperator: '<S2928>/Relational Operator6'
     *  RelationalOperator: '<S71>/Comparison4'
     */
    if (((uint32)VeTHMR_e_EmrgcyFanRq_Lvl_B4D) != CeTHMR_e_SNA_EmrgcyFanRq)
    {
        /* Switch: '<S3630>/Switch1' */
        rtb_Switch1_ald = VeTHMR_e_EmrgcyFanRq_Lvl_B4D;
    }
    else
    {
        /* Switch: '<S3630>/Switch1' incorporates:
         *  Constant: '<S3636>/Calib'
         */
        rtb_Switch1_ald = KeTHMR_e_HCP_LTP_FanAftRunRqDflt;
    }

    /* Switch: '<S3653>/Switch1' incorporates:
     *  Constant: '<S3647>/FALSE Constant1'
     *  Constant: '<S3647>/FALSE Constant10'
     *  Constant: '<S3647>/FALSE Constant2'
     *  Constant: '<S3647>/FALSE Constant3'
     *  Constant: '<S3647>/FALSE Constant4'
     *  Constant: '<S3647>/FALSE Constant5'
     *  Constant: '<S3647>/FALSE Constant6'
     *  Constant: '<S3647>/FALSE Constant7'
     *  Constant: '<S3647>/FALSE Constant8'
     *  Constant: '<S3647>/FALSE Constant9'
     *  Logic: '<S3647>/Logical1'
     *  Logic: '<S3647>/Logical2'
     *  Logic: '<S3647>/Logical3'
     *  Logic: '<S3647>/Logical4'
     *  RelationalOperator: '<S3647>/Comparison1'
     *  RelationalOperator: '<S3647>/Comparison10'
     *  RelationalOperator: '<S3647>/Comparison2'
     *  RelationalOperator: '<S3647>/Comparison3'
     *  RelationalOperator: '<S3647>/Comparison4'
     *  RelationalOperator: '<S3647>/Comparison5'
     *  RelationalOperator: '<S3647>/Comparison6'
     *  RelationalOperator: '<S3647>/Comparison7'
     *  RelationalOperator: '<S3647>/Comparison8'
     *  RelationalOperator: '<S3647>/Comparison9'
     *  Switch: '<S3654>/Switch1'
     *  Switch: '<S3655>/Switch1'
     *  Switch: '<S3656>/Switch1'
     */
    if (rtb_TmpSignalConversionAtVeTFTR <= 100.0F)
    {
        /* Switch: '<S3653>/Switch1' incorporates:
         *  Constant: '<S3651>/Constant'
         */
        THMR_ac_B.Switch1_ex = CeTMIR_e_No_AftRunRequest;
    }
    else if (((rtb_TmpSignalConversionAtVeTFTR > 100.0F) &&
              (rtb_TmpSignalConversionAtVeTFTR <= 110.0F)) &&
             (THMR_ac_B.Switch1_j > 50.0F))
    {
        /* Switch: '<S3654>/Switch1' incorporates:
         *  Constant: '<S3649>/Constant'
         *  Switch: '<S3653>/Switch1'
         */
        THMR_ac_B.Switch1_ex = CeTMIR_e_ECM_AftRunRequest_2;
    }
    else if ((((rtb_TmpSignalConversionAtVeTFTR > 110.0F) &&
               (rtb_TmpSignalConversionAtVeTFTR <= 120.0F)) &&
              (THMR_ac_B.Switch1_j > 40.0F)) ||
             ((rtb_TmpSignalConversionAtVeTFTR > 120.0F) &&
              (rtb_TmpSignalConversionAtVeTFTR <= 130.0F)))
    {
        /* Switch: '<S3655>/Switch1' incorporates:
         *  Constant: '<S3650>/Constant'
         *  Switch: '<S3653>/Switch1'
         *  Switch: '<S3654>/Switch1'
         */
        THMR_ac_B.Switch1_ex = CeTMIR_e_ECM_AftRunRequest_3;
    }
    else if (rtb_TmpSignalConversionAtVeTFTR > 130.0F)
    {
        /* Switch: '<S3656>/Switch1' incorporates:
         *  Constant: '<S3652>/Constant'
         *  Switch: '<S3653>/Switch1'
         *  Switch: '<S3654>/Switch1'
         *  Switch: '<S3655>/Switch1'
         */
        THMR_ac_B.Switch1_ex = CeTMIR_e_ECM_AftRunRequest_4;
    }
    else
    {
        /* Switch: '<S3653>/Switch1' incorporates:
         *  Constant: '<S3648>/Constant'
         *  Switch: '<S3654>/Switch1'
         *  Switch: '<S3655>/Switch1'
         *  Switch: '<S3656>/Switch1'
         */
        THMR_ac_B.Switch1_ex = CeTMIR_e_No_AftRunRequest;
    }

    /* End of Switch: '<S3653>/Switch1' */

    /* Chart: '<S71>/AfterRun' incorporates:
     *  Constant: '<S3632>/Calib'
     *  Constant: '<S3633>/Calib'
     *  Constant: '<S3634>/Calib'
     *  Gain: '<S3637>/Gain'
     *  Inport: '<Root>/VePLTR_t_RTC_CurrentTime'
     *  Switch: '<S3628>/Switch1'
     *  Switch: '<S3629>/Switch1'
     *  Switch: '<S3630>/Switch1'
     *  Switch: '<S3653>/Switch1'
     */
    /* Gateway: ProcessAftrRunRq/AfterRun */
    /* During: ProcessAftrRunRq/AfterRun */
    if (((uint32)THMR_ac_DW.is_active_c8_THMC_ProcessAftrRu) == 0U)
    {
        /* Entry: ProcessAftrRunRq/AfterRun */
        THMR_ac_DW.is_active_c8_THMC_ProcessAftrRu = 1U;

        /* Entry Internal: ProcessAftrRunRq/AfterRun */
        /* Transition: '<S3614>:2' */
        THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_SM_Entry;

        /* Entry 'SM_Entry': '<S3614>:60' */
        THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_ChartEntry;
        THMR_ac_B.VeTHMR_t_RTC_InitDelay = 0.0F;
        THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B = KeTHMR_e_AfterRunDefault;
    }
    else
    {
        (void)Rte_Read_VePLTR_t_RTC_CurrentTime_Value(&tmpRead_1b);
        switch (THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq)
        {
          case THMR_ac_IN_AfterRunComplt:
            THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_AftrRunComplete;

            /* During 'AfterRunComplt': '<S3614>:53' */
            /* Transition: '<S3614>:200' */
            /* Transition: '<S3614>:198' */
            /* Transition: '<S3614>:199' */
            /* Transition: '<S3614>:201' */
            /* Transition: '<S3614>:204' */
            if ((((uint32)Switch2_i) == CeCITR_e_FOTANow) || (((uint32)Switch2_i)
                 == CeCITR_e_FOTASchedule))
            {
                /* Transition: '<S3614>:186' */
                /* Exit 'AfterRunComplt': '<S3614>:53' */
                THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead_1b;
                THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                    THMR_ac_IN_FOTARequested;

                /* Entry 'FOTARequested': '<S3614>:180' */
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M =
                    CeTMIR_e_No_AftRunRequest;
                THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
                    THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
                THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_FOTARequested;
                THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
                THMR_ac_B.VeTHMR_b_AftrRunFanRq = false;
                THMR_ac_B.VeTHMR_b_thermalActivityCmplt = true;
            }
            else
            {
                /* Transition: '<S3614>:71' */
                /* Transition: '<S3614>:74' */
                /* Transition: '<S3614>:76' */
                /* Transition: '<S3614>:78' */
                if (((((uint32)VeTHMR_b_KeyXstnOffThisCycle_tm) !=
                        CePMDR_e_KeySt_Off) && (((uint32)
                        VeTHMR_b_KeyXstnOffThisCycle_tm) != CePMDR_e_KeySt_Acc))
                    || Switch2_e)
                {
                    /* Transition: '<S3614>:82' */
                    /* Transition: '<S3614>:84' */
                    /* Transition: '<S3614>:85' */
                    /* Exit 'AfterRunComplt': '<S3614>:53' */
                    THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead_1b;
                    THMR_ac_B.RstKeyLtch = true;
                    THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                        THMR_ac_IN_AfterRunInit;
                    THMR__enter_atomic_AfterRunInit();
                }
                else if (((THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i) &&
                          (!rtb_TmpSignalConversionAtBattCn)) && ((((uint32)
                            VeTHMR_b_KeyXstnOffThisCycle_tm) ==
                           CePMDR_e_KeySt_Off) || (((uint32)
                            VeTHMR_b_KeyXstnOffThisCycle_tm) ==
                           CePMDR_e_KeySt_Acc)))
                {
                    /* Transition: '<S3614>:140' */
                    /* Transition: '<S3614>:143' */
                    /* Exit 'AfterRunComplt': '<S3614>:53' */
                    THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead_1b;
                    THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                        IN_PlugInCharging_CmndOutOfAftr;

                    /* Entry 'PlugInCharging_CmndOutOfAftrRun': '<S3614>:10' */
                    THMR_ac_DW.VeTHMR_b_isChargingTemp =
                        THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i;
                    THMR_ac_B.VeTHMR_t_AfterRunTimeForRq = (uint32)
                        KaTHMR_t_AfterRunTimeForRq
                        [(THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq)];
                    THMR_ac_DW.NeTHMR_t_PumpRunTmr =
                        (THMR_ac_DW.NeTHMR_t_PumpRunTmr + tmpRead_1b) -
                        THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1;
                    THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B =
                        THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq;
                    THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
                    THMR_ac_B.VeTHMR_b_AftrRunFanRq = false;
                    THMR_ac_B.VeTHMR_e_AftrRunStateMachine =
                        CeTHMR_e_PlugInCharging_CmndOutOfAftrRun;
                    THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu = tmpRead_1b;
                }
                else
                {
                    /* Transition: '<S3614>:149' */
                    if (THMR_ac_DW.NeTHMR_t_PumpRunTmr >
                            THMR_ac_B.VeTHMR_t_AfterRunTimeForRq)
                    {
                        /* Transition: '<S3614>:150' */
                        /* Transition: '<S3614>:152' */
                        /* Transition: '<S3614>:153' */
                        /* Exit 'AfterRunComplt': '<S3614>:53' */
                        THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead_1b;
                        THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
                            CeTMIR_e_No_AftRunRequest;
                        THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                            THMR_ac_IN_SM_Entry;

                        /* Entry 'SM_Entry': '<S3614>:60' */
                        THMR_ac_B.VeTHMR_e_AftrRunStateMachine =
                            CeTHMR_e_ChartEntry;
                        THMR_ac_B.VeTHMR_t_RTC_InitDelay = 0.0F;
                        THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B =
                            KeTHMR_e_AfterRunDefault;
                    }
                    else
                    {
                        THMR_ac_DW.NeTHMR_t_PumpRunTmr += tmpRead_1b -
                            THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu;
                        THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu = tmpRead_1b;
                    }
                }
            }
            break;

          case THMR_ac_IN_AfterRunInit:
            THMR_ac_B.VeTHMR_b_thermalActivityCmplt = false;
            THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_AfterRunInit;

            /* During 'AfterRunInit': '<S3614>:1' */
            /* Transition: '<S3614>:187' */
            if ((((uint32)Switch2_i) == CeCITR_e_FOTANow) || (((uint32)Switch2_i)
                 == CeCITR_e_FOTASchedule))
            {
                /* Transition: '<S3614>:186' */
                /* Exit 'AfterRunInit': '<S3614>:1' */
                THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead_1b;
                THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                    THMR_ac_IN_FOTARequested;

                /* Entry 'FOTARequested': '<S3614>:180' */
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M =
                    CeTMIR_e_No_AftRunRequest;
                THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
                    THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
                THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_FOTARequested;
                THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
                THMR_ac_B.VeTHMR_b_AftrRunFanRq = false;
                THMR_ac_B.VeTHMR_b_thermalActivityCmplt = true;
            }
            else
            {
                if (VeTHMR_b_KeyXstnOffThisCycle)
                {
                    /* Transition: '<S3614>:5' */
                    /* Exit 'AfterRunInit': '<S3614>:1' */
                    THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead_1b;
                    THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                        THMR_ac_IN_DeterminAftrRunRq;

                    /* Entry 'DeterminAftrRunRq': '<S3614>:3' */
                    THMR_ac_B.VeTHMR_e_ECM_LTPFanAftRunRq_cf =
                        KaTHMR_Cf_ECM_LTP_FanAftRunRq[(Switch1_ed)];
                    THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_c =
                        KaTHMR_Cf_HCP_LTP_FanAftrRunRq[(rtb_Switch1_ald)];
                    THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M =
                        KaTHMR_Cf_ECM_LTP_FanAftRunRq[(sint32)fmax((float64)
                        ((sint32)((THMR_ac_B.VeTHMR_e_ECM_LTPFanAftRunRq_cf >
                                   THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_c) ?
                                  ((sint32)
                                   THMR_ac_B.VeTHMR_e_ECM_LTPFanAftRunRq_cf) :
                                  ((sint32)
                                   THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_c))),
                        (float64)KaTHMR_Cf_PIM_LTP_FanAftrRunRq
                        [(THMR_ac_B.Switch1_ex)])];
                    THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
                        THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
                    THMR_ac_DW.VeTHMR_e_HCP_LTP_FanAftRun_Rq_A =
                        THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
                    THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B =
                        KeTHMR_b_HoldContactrsOnKeyOFF;
                    THMR_ac_B.VeTHMR_e_AftrRunStateMachine =
                        CeTHMR_e_DtermineAfterRunRequest;
                    THMR_ac_B.RstKeyLtch = false;
                }
            }
            break;

          case THMR_ac_IN_AlternatorMode:
            THMR_ac_AlternatorMode(&rtb_OR1_jc2,
                                   &rtb_TmpSignalConversionAtBattCn, &Switch2_e,
                                   &Switch2_i, &Switch1_ed, &rtb_Switch1_ald);
            break;

          case THMR_ac_IN_CalNewAfterRunRq:
            THMR_ac_CalNewAfterRunRq(&rtb_OR1_jc2,
                &rtb_TmpSignalConversionAtBattCn, &Switch2_e, &Switch2_i,
                &Switch1_ed, &rtb_Switch1_ald);
            break;

          case THMR_ac_IN_CommandContactorOpen:
            THMR_ac_B.VeTHMR_b_thermalActivityCmplt =
                KeTHMR_b_ThrmlRdyShtDwn_AftRun;

            /* During 'CommandContactorOpen': '<S3614>:8' */
            /* Transition: '<S3614>:197' */
            /* Transition: '<S3614>:198' */
            /* Transition: '<S3614>:199' */
            /* Transition: '<S3614>:201' */
            /* Transition: '<S3614>:204' */
            if ((((uint32)Switch2_i) == CeCITR_e_FOTANow) || (((uint32)Switch2_i)
                 == CeCITR_e_FOTASchedule))
            {
                /* Transition: '<S3614>:186' */
                THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                    THMR_ac_IN_FOTARequested;

                /* Entry 'FOTARequested': '<S3614>:180' */
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M =
                    CeTMIR_e_No_AftRunRequest;
                THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
                    THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
                THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_FOTARequested;
                THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
                THMR_ac_B.VeTHMR_b_AftrRunFanRq = false;
                THMR_ac_B.VeTHMR_b_thermalActivityCmplt = true;
            }
            else
            {
                /* Transition: '<S3614>:56' */
                THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                    THMR_ac_IN_AfterRunComplt;

                /* Entry 'AfterRunComplt': '<S3614>:53' */
                THMR_ac_B.VeTHMR_e_AftrRunStateMachine =
                    CeTHMR_e_AftrRunComplete;
                THMR_ac_DW.NeTHMR_t_PumpRunTmr = (THMR_ac_DW.NeTHMR_t_PumpRunTmr
                    + tmpRead_1b) - THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1;
                THMR_ac_B.VeTHMR_t_AfterRunTimeForRq = (uint32)
                    KaTHMR_t_AfterRunTimeForRq
                    [(THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq)];
                THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu = tmpRead_1b;
            }
            break;

          case THMR_ac_IN_DeterminAftrRunRq:
            THMR_ac_DeterminAftrRunRq(&rtb_OR1_jc2, &Switch2_e, &Switch2_i,
                &Switch1_ed, &rtb_Switch1_ald);
            break;

          case THMR_ac_IN_FOTARequested:
            THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_FOTARequested;
            THMR_ac_B.VeTHMR_b_thermalActivityCmplt = true;

            /* During 'FOTARequested': '<S3614>:180' */
            if ((((uint32)Switch2_i) != CeCITR_e_FOTANow) && (((uint32)Switch2_i)
                 != CeCITR_e_FOTASchedule))
            {
                /* Transition: '<S3614>:183' */
                /* Exit 'FOTARequested': '<S3614>:180' */
                THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1 = tmpRead_1b;
                THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_SM_Entry;

                /* Entry 'SM_Entry': '<S3614>:60' */
                THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_ChartEntry;
                THMR_ac_B.VeTHMR_t_RTC_InitDelay = 0.0F;
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B =
                    KeTHMR_e_AfterRunDefault;
            }
            break;

          case IN_PlugInCharging_CmndOutOfAftr:
            PlugInCharging_CmndOutOfAftrRun(&rtb_TmpSignalConversionAtBattCn,
                &Switch2_e, &Switch2_i);
            break;

          case THMR_ac_IN_RadFanAndPumpCmmnd:
            THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_CmmndRadFanAndPump;

            /* During 'RadFanAndPumpCmmnd': '<S3614>:6' */
            /* Transition: '<S3614>:205' */
            /* Transition: '<S3614>:199' */
            /* Transition: '<S3614>:201' */
            /* Transition: '<S3614>:204' */
            if ((((uint32)Switch2_i) == CeCITR_e_FOTANow) || (((uint32)Switch2_i)
                 == CeCITR_e_FOTASchedule))
            {
                /* Transition: '<S3614>:186' */
                THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                    THMR_ac_IN_FOTARequested;

                /* Entry 'FOTARequested': '<S3614>:180' */
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M =
                    CeTMIR_e_No_AftRunRequest;
                THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
                    THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
                THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_FOTARequested;
                THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
                THMR_ac_B.VeTHMR_b_AftrRunFanRq = false;
                THMR_ac_B.VeTHMR_b_thermalActivityCmplt = true;
            }
            else
            {
                /* Transition: '<S3614>:79' */
                if (((((uint32)VeTHMR_b_KeyXstnOffThisCycle_tm) !=
                        CePMDR_e_KeySt_Off) && (((uint32)
                        VeTHMR_b_KeyXstnOffThisCycle_tm) != CePMDR_e_KeySt_Acc))
                    || Switch2_e)
                {
                    /* Transition: '<S3614>:82' */
                    /* Transition: '<S3614>:84' */
                    /* Transition: '<S3614>:85' */
                    THMR_ac_B.RstKeyLtch = true;
                    THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                        THMR_ac_IN_AfterRunInit;
                    THMR__enter_atomic_AfterRunInit();
                }
                else if ((((THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i) &&
                           (!rtb_TmpSignalConversionAtBattCn)) && (((uint32)
                            VeTHMR_b_KeyXstnOffThisCycle_tm) ==
                           CePMDR_e_KeySt_Off)) &&
                         ((!THMR_ac_B.VeTHMR_b_AftrRunFanRq) ||
                          (THMR_ac_B.VeTHMR_t_RadFanTurnONTimr >=
                           KeTHMR_t_FanAftrRunOnTmr)))
                {
                    /* Transition: '<S3614>:86' */
                    THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                        IN_PlugInCharging_CmndOutOfAftr;

                    /* Entry 'PlugInCharging_CmndOutOfAftrRun': '<S3614>:10' */
                    THMR_ac_DW.VeTHMR_b_isChargingTemp =
                        THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i;
                    THMR_ac_B.VeTHMR_t_AfterRunTimeForRq = (uint32)
                        KaTHMR_t_AfterRunTimeForRq
                        [(THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq)];
                    THMR_ac_DW.NeTHMR_t_PumpRunTmr =
                        (THMR_ac_DW.NeTHMR_t_PumpRunTmr + tmpRead_1b) -
                        THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1;
                    THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B =
                        THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq;
                    THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
                    THMR_ac_B.VeTHMR_b_AftrRunFanRq = false;
                    THMR_ac_B.VeTHMR_e_AftrRunStateMachine =
                        CeTHMR_e_PlugInCharging_CmndOutOfAftrRun;
                    THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu = tmpRead_1b;
                }
                else
                {
                    if (KeTHMR_b_PECP2_Enbl)
                    {
                        /* Switch: '<S3628>/Switch1' incorporates:
                         *  Inport: '<Root>/VePMPR_e_LTPsvPump2_PstRnSt'
                         */
                        rtb_RelationalOperator_kg_tmp = tmpRead_15;
                    }
                    else
                    {
                        /* Switch: '<S3628>/Switch1' incorporates:
                         *  Inport: '<Root>/VePMPR_e_LTPsvPump_PstRnSt'
                         */
                        rtb_RelationalOperator_kg_tmp = tmpRead_13;
                    }

                    if (((((!THMR_ac_B.VeTHMR_b_AftrRunFanRq) ||
                            (THMR_ac_B.VeTHMR_t_RadFanTurnONTimr >=
                             KeTHMR_t_FanAftrRunOnTmr)) &&
                            ((rtb_RelationalOperator_kg_tmp ==
                              THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B) ||
                             (KeTHMR_b_OvrrdPmpStsCheck))) &&
                            (!THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i)) &&
                            ((((uint32)VeTHMR_b_KeyXstnOffThisCycle_tm) ==
                              CePMDR_e_KeySt_Off) || (((uint32)
                            VeTHMR_b_KeyXstnOffThisCycle_tm) ==
                            CePMDR_e_KeySt_Acc)))
                    {
                        /* Transition: '<S3614>:9' */
                        THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                            THMR_ac_IN_CommandContactorOpen;

                        /* Entry 'CommandContactorOpen': '<S3614>:8' */
                        THMR_ac_B.VeTHMR_b_AftrRunFanRq = false;
                        THMR_ac_B.VeTHMR_b_thermalActivityCmplt =
                            KeTHMR_b_ThrmlRdyShtDwn_AftRun;
                        THMR_ac_B.VeTHMR_e_AftrRunStateMachine =
                            CeTHMR_e_CmmndContactorOpen;
                        THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
                    }
                    else
                    {
                        THMR_ac_B.VeTHMR_t_RadFanTurnONTimr +=
                            KeTHMR_t_THMRTaskRt;
                        THMR_ac_B.VeTHMR_t_WaitTimeFrAftrRun +=
                            KeTHMR_t_THMRTaskRt;
                    }
                }
            }
            break;

          default:
            THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_ChartEntry;

            /* During 'SM_Entry': '<S3614>:60' */
            if ((((uint32)Switch2_i) == CeCITR_e_FOTANow) || (((uint32)Switch2_i)
                 == CeCITR_e_FOTASchedule))
            {
                /* Transition: '<S3614>:182' */
                THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                    THMR_ac_IN_FOTARequested;

                /* Entry 'FOTARequested': '<S3614>:180' */
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M =
                    CeTMIR_e_No_AftRunRequest;
                THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq =
                    THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;
                THMR_ac_B.VeTHMR_e_AftrRunStateMachine = CeTHMR_e_FOTARequested;
                THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
                THMR_ac_B.VeTHMR_b_AftrRunFanRq = false;
                THMR_ac_B.VeTHMR_b_thermalActivityCmplt = true;
            }
            else if (((((uint32)VeTHMR_b_KeyXstnOffThisCycle_tm) !=
                       CePMDR_e_KeySt_Off) && (((uint32)
                        VeTHMR_b_KeyXstnOffThisCycle_tm) != CePMDR_e_KeySt_Acc))
                     || Switch2_e)
            {
                /* Transition: '<S3614>:65' */
                THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq = THMR_ac_IN_AfterRunInit;
                THMR__enter_atomic_AfterRunInit();
            }
            else if ((((((((uint32)VeTHMR_b_KeyXstnOffThisCycle_tm) ==
                          CePMDR_e_KeySt_Off) || (((uint32)
                           VeTHMR_b_KeyXstnOffThisCycle_tm) ==
                          CePMDR_e_KeySt_Acc)) && (!VeTHMR_b_KeyXstnOffThisCycle))
                       && (THMR_ac_B.VeTHMR_t_RTC_InitDelay >
                           KeTHMR_t_RTC_CalDelay)) && (((uint32)
                        rtb_RelationalOperator_kg_tmp) !=
                       CeTMIR_e_No_AftRunRequest)) && (((uint32)
                       rtb_RelationalOperator_kg_tmp) !=
                      CeTMIR_e_SNA_AftRunRequest))
            {
                /* Transition: '<S3614>:66' */
                THMR_ac_DW.is_c8_THMC_ProcessAftrRunRq =
                    IN_PlugInCharging_CmndOutOfAftr;

                /* Entry 'PlugInCharging_CmndOutOfAftrRun': '<S3614>:10' */
                THMR_ac_DW.VeTHMR_b_isChargingTemp =
                    THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i;
                THMR_ac_B.VeTHMR_t_AfterRunTimeForRq = (uint32)
                    KaTHMR_t_AfterRunTimeForRq
                    [(THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq)];
                THMR_ac_DW.NeTHMR_t_PumpRunTmr = (THMR_ac_DW.NeTHMR_t_PumpRunTmr
                    + tmpRead_1b) - THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1;
                THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B =
                    THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq;
                THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B = false;
                THMR_ac_B.VeTHMR_b_AftrRunFanRq = false;
                THMR_ac_B.VeTHMR_e_AftrRunStateMachine =
                    CeTHMR_e_PlugInCharging_CmndOutOfAftrRun;
                THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu = tmpRead_1b;
            }
            else
            {
                THMR_ac_B.VeTHMR_t_RTC_InitDelay += KeTHMR_t_THMRTaskRt;
            }
            break;
        }
    }

    /* Logic: '<S3615>/AND' */
    VeTHMR_b_AftrRunFanRq_SF = THMR_ac_B.VeTHMR_b_AftrRunFanRq;

    /* Logic: '<S3616>/AND' */
    VeTHMR_b_HCP_LTP_FanAftRun_Rq_BD_SF =
        THMR_ac_B.VeTHMR_b_HCP_LTP_FanAftRun_Rq_B;

    /* Logic: '<S3617>/AND' */
    VeTHMR_b_thermalActivityCmplt_SF = THMR_ac_B.VeTHMR_b_thermalActivityCmplt;

    /* DataTypeConversion: '<S3618>/DataTypeConversion' */
    VeTHMR_e_AftrRunStateMachine_SF = THMR_ac_B.VeTHMR_e_AftrRunStateMachine;

    /* DataTypeConversion: '<S3619>/DataTypeConversion' */
    VeTHMR_e_HCP_LTP_FanAftRun_Rq_Max_SF =
        THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_M;

    /* DataTypeConversion: '<S3620>/DataTypeConversion' */
    VeTHMR_e_AfterRunRqNew_SF = THMR_ac_B.VeTHMR_e_AfterRunRqNew;

    /* DataTypeConversion: '<S3621>/DataTypeConversion' */
    VeTHMR_e_HCP_LTP_FanAftRun_Rq_BD_SF =
        THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_B;

    /* DataTypeConversion: '<S3622>/DataTypeConversion' */
    VeTHMR_e_ECM_LTPFanAftRunRq_cf_SF = THMR_ac_B.VeTHMR_e_ECM_LTPFanAftRunRq_cf;

    /* DataTypeConversion: '<S3623>/DataTypeConversion' */
    VeTHMR_e_HCP_LTP_FanAftRun_Rq_cf_SF =
        THMR_ac_B.VeTHMR_e_HCP_LTP_FanAftRun_Rq_c;

    /* Gain: '<S3639>/Gain' */
    VeTHMR_t_RTC_InitDelay_SF = THMR_ac_B.VeTHMR_t_RTC_InitDelay;

    /* Gain: '<S3640>/Gain' */
    VeTHMR_t_RealTimeClock_LastValue_SF =
        THMR_ac_B.VeTHMR_t_RealTimeClock_LastValu;

    /* Gain: '<S3642>/Gain' */
    VeTHMR_t_AfterRunTimeForRq_SF = THMR_ac_B.VeTHMR_t_AfterRunTimeForRq;

    /* Gain: '<S3643>/Gain' */
    VeTHMR_t_RadFanTurnONTimr_SF = THMR_ac_B.VeTHMR_t_RadFanTurnONTimr;

    /* Gain: '<S3644>/Gain' */
    VeTHMR_t_WaitTimeFrAftrRun_SF = THMR_ac_B.VeTHMR_t_WaitTimeFrAftrRun;

    /* Gain: '<S3645>/Gain' */
    VeTHMR_t_TimeRemainForAftrrun_SF = THMR_ac_B.VeTHMR_t_TimeRemainForAftrrun;

    /* Update for UnitDelay: '<S71>/Unit Delay' incorporates:
     *  SignalConversion generated from: '<S2>/VePMDR_e_KeyStatus'
     */
    THMR_ac_DW.UnitDelay_DSTATE_fw = THMR_ac_B.TmpSignalConversionAtVePMDR_e_K;

    /* Update for UnitDelay: '<S71>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_eg = THMR_ac_B.RstKeyLtch;

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LT_Batt_Loop'
     */
    /* Logic: '<S3107>/Logical2' */
    rtb_AND_cn = !rtb_TmpSignalConversionAtVeBT_f;

    /* RelationalOperator: '<S3158>/Comparison2' incorporates:
     *  Constant: '<S3104>/Calib'
     *  Constant: '<S3213>/Constant'
     *  Constant: '<S3214>/Constant'
     *  Constant: '<S3215>/Constant'
     *  Constant: '<S3216>/Constant'
     *  Constant: '<S3217>/Constant'
     *  Constant: '<S3218>/Constant'
     *  Constant: '<S3219>/Calib'
     *  Logic: '<S3107>/Logical1'
     *  Logic: '<S3107>/Logical2'
     *  Logic: '<S3107>/LogicalOperator'
     *  Logic: '<S3107>/LogicalOperator1'
     *  Logic: '<S3107>/LogicalOperator2'
     *  Logic: '<S3107>/LogicalOperator3'
     *  Logic: '<S63>/And1'
     *  RelationalOperator: '<S3107>/Comparison1'
     *  RelationalOperator: '<S3107>/Comparison2'
     *  RelationalOperator: '<S3107>/Comparison3'
     *  RelationalOperator: '<S3107>/Comparison4'
     *  RelationalOperator: '<S3107>/Comparison5'
     *  RelationalOperator: '<S3107>/Comparison6'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     *  Switch: '<S4586>/Switch1'
     */
    Gain_cm = ((KeTHMR_b_BTLMBCLegcySel) && ((((CeTHMR_e_Heating == ((uint32)
                    VeTHMR_e_BatThrmlSt_B4D)) && ((((((((uint32)
                         rtb_TmpSignalConversionAtVePD_l) !=
                        CePDTR_e_Dischrg_BatTempCriticl) && (((uint32)
                         rtb_TmpSignalConversionAtVePD_l) !=
                        CePDTR_e_Dischrg_BatTempNotOpt)) && (((uint32)
                        rtb_TmpSignalConversionAtVePD_l) !=
                       CePDTR_e_Dischrg_BatAndCab_Cndtn)) && (((uint32)
                       rtb_TmpSignalConversionAtVePD_l) !=
                      CePDTR_e_Dischrg_ForcBatHeat_Hys)) && (((uint32)
                      rtb_TmpSignalConversionAtVePD_l) != CePDTR_e_NoValidReq)) ||
                   (KeTHMR_b_UseBTLMBCforOV))) && rtb_AND_cn) &&
                (!THMR_ac_B.Logical7_l)));

    /* Switch: '<S3102>/Switch3' incorporates:
     *  DataStoreRead: '<S63>/DataStoreRead2'
     *  DataStoreWrite: '<S63>/DataStoreWrite2'
     *  S-Function (sfix_bitop): '<S3125>/FixPt Bitwise Operator3'
     *  S-Function (sfix_bitop): '<S3125>/FixPt Bitwise Operator4'
     *  S-Function (sfix_bitop): '<S3125>/FixPt Bitwise Operator5'
     *  S-Function (sfix_bitop): '<S3126>/FixPt Bitwise Operator1'
     */
    if (Gain_cm)
    {
        VeTHMR_y_PumpEnbl_DS = (uint8)(VeTHMR_y_PumpEnbl_DS | ((uint8)8));
    }
    else
    {
        VeTHMR_y_PumpEnbl_DS = (uint8)(~((uint8)(((uint8)(~VeTHMR_y_PumpEnbl_DS))
            | ((uint8)8))));
    }

    /* End of Switch: '<S3102>/Switch3' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

    /* Outputs for Atomic SubSystem: '<S63>/BTR_Airflow' */
    /* Sum: '<S3101>/Sum2' incorporates:
     *  Sum: '<S3101>/Sum'
     */
    rtb_Sum2_aq = rtb_TmpSignalConversionAtVeTRIR - VeTHMR_T_BattClntMaxTgt;

    /* Outputs for Atomic SubSystem: '<S3115>/EdgeRising' */
    /* Logic: '<S3116>/OR1' incorporates:
     *  UnitDelay: '<S3116>/UnitDelay'
     */
    rtb_OR1_bn = !THMR_ac_DW.UnitDelay_DSTATE_c41;

    /* Update for UnitDelay: '<S3116>/UnitDelay' incorporates:
     *  Constant: '<S3115>/TRUEConstant'
     */
    THMR_ac_DW.UnitDelay_DSTATE_c41 = true;

    /* Outputs for Atomic SubSystem: '<S3115>/PIDControl' */
    /* Switch: '<S3123>/Switch' incorporates:
     *  Constant: '<S3115>/ConstantValue1'
     *  Delay: '<S3101>/IntegerDelay'
     *  Logic: '<S3115>/LogicalOperator1'
     *  Logic: '<S3116>/AND'
     *  RelationalOperator: '<S3115>/RelationalOperator1'
     *  Sum: '<S3101>/Sum2'
     *  Switch: '<S3123>/Switch2'
     */
    if (rtb_OR1_bn)
    {
        /* Switch: '<S3123>/Switch' incorporates:
         *  Constant: '<S3117>/Calib'
         */
        rtb_TmpSignalConversionAtVeTFTR = KeTHMR_dV_BattRadAirflow_PID_Init;
    }
    else
    {
        if ((THMR_ac_DW.IntegerDelay_DSTATE) && (rtb_Sum2_aq > 0.0F))
        {
            /* Switch: '<S3123>/Switch2' incorporates:
             *  Constant: '<S3123>/ConstantValue'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S3123>/Switch2' incorporates:
             *  Constant: '<S3115>/ConstantValue'
             *  Lookup_n-D: '<S3121>/Vector'
             *  Product: '<S3123>/Multiplication1'
             *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
             *  Sum: '<S3101>/Sum2'
             */
            rtb_Switch10 = (rtb_Sum2_aq * look1_iflf_binlcapw
                            (TmpSignalConversionAtOutAirTemp, ((const float32 *)
                              &(KxTHMR_k_BattRadAirflw_Ki[0])), ((const float32 *)
                              &(KtTHMR_k_BattRadAirflw_Ki[0])), 5U)) * 0.1F;
        }

        /* Switch: '<S3123>/Switch' incorporates:
         *  Sum: '<S3123>/Sum//Sub'
         *  UnitDelay: '<S3123>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeTFTR = rtb_Switch10 +
            THMR_ac_DW.UnitDelay_DSTATE_ms;
    }

    /* End of Switch: '<S3123>/Switch' */
    /* End of Outputs for SubSystem: '<S3115>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S3123>/integral_term' */
    /* Switch: '<S3124>/Switch1' incorporates:
     *  Constant: '<S3118>/Calib'
     *  RelationalOperator: '<S3124>/RelationalOperator'
     */
    if (KeTHMR_dV_MaxBattRadAirflow < rtb_TmpSignalConversionAtVeTFTR)
    {
        /* Lookup_n-D: '<S3170>/Vector' */
        rtb_TmpSignalConversionAtVeTFTR = KeTHMR_dV_MaxBattRadAirflow;
    }

    /* End of Switch: '<S3124>/Switch1' */

    /* Switch: '<S3124>/Switch' incorporates:
     *  Constant: '<S3119>/Calib'
     *  RelationalOperator: '<S3124>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTFTR <= KeTHMR_dV_MinBattRadAirflow_PID)
    {
        /* Switch: '<S3124>/Switch' */
        rtb_TmpSignalConversionAtVeTFTR = KeTHMR_dV_MinBattRadAirflow_PID;
    }

    /* End of Switch: '<S3124>/Switch' */
    /* End of Outputs for SubSystem: '<S3123>/integral_term' */

    /* Switch: '<S3123>/Switch1' incorporates:
     *  Constant: '<S3115>/ConstantValue'
     *  Constant: '<S3120>/Calib'
     *  Lookup_n-D: '<S3122>/Vector'
     *  Product: '<S3123>/Multiplication2'
     *  Product: '<S3123>/derivative_term'
     *  Product: '<S3123>/proportional_term'
     *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
     *  Sum: '<S3101>/Sum2'
     *  Sum: '<S3123>/Sum//Sub1'
     *  Sum: '<S3123>/Sum//Sub2'
     *  UnitDelay: '<S3123>/UnitDelay1'
     */
    VeTHMR_dV_BattRadAirflw_ClsLp_PID = (((rtb_Sum2_aq -
        THMR_ac_DW.UnitDelay1_DSTATE_dh) * KeTHMR_k_BattRadAirflw_Kd) / 0.1F) +
        ((rtb_Sum2_aq * look1_iflf_binlcapw(TmpSignalConversionAtOutAirTemp, ((
             const float32 *)&(KxTHMR_k_BattRadAirflw_Kp[0])), ((const float32 *)
            &(KtTHMR_k_BattRadAirflw_Kp[0])), 5U)) +
         rtb_TmpSignalConversionAtVeTFTR);

    /* Update for UnitDelay: '<S3123>/UnitDelay1' incorporates:
     *  Sum: '<S3101>/Sum2'
     */
    THMR_ac_DW.UnitDelay1_DSTATE_dh = rtb_Sum2_aq;

    /* Update for UnitDelay: '<S3123>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ms = rtb_TmpSignalConversionAtVeTFTR;

    /* End of Outputs for SubSystem: '<S3115>/PIDControl' */

    /* Sum: '<S3101>/Sum1' incorporates:
     *  Lookup_n-D: '<S3111>/Vector'
     *  Lookup_n-D: '<S3112>/Vector'
     *  Product: '<S3101>/Product'
     *  Product: '<S3101>/Product1'
     *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
     *  SignalConversion generated from: '<S2>/VeBTRR_T_BTISBTIS2_Max'
     */
    rtb_Sum2_aq = look2_iflf_binlcapw((look1_iflf_binlcapw
        (rtb_TmpSignalConversionAtVeBT_k, ((const float32 *)
        &(KxTHMR_K_CoolantHeatCap[0])), ((const float32 *)
        &(KtTHMR_K_CoolantHeatCap[0])), 5U) * VeTHMR_dV_LTAPFlwReq_Mod_1) *
        rtb_Sum2_aq, TmpSignalConversionAtOutAirTemp, ((const float32 *)
        &(KxTHMR_dV_BattRad_AirFlowRaw[0])), ((const float32 *)
        &(KyTHMR_dV_BattRad_AirFlowRaw[0])), ((const float32 *)
        &(KtTHMR_dV_BattRad_AirFlowRaw[0])), THMR_ac_ConstP.pooled34, 7U) +
        VeTHMR_dV_BattRadAirflw_ClsLp_PID;

    /* Switch: '<S3101>/Switch' incorporates:
     *  Constant: '<S3108>/Constant'
     *  Constant: '<S3109>/Calib'
     *  Logic: '<S3101>/Logical Operator'
     *  RelationalOperator: '<S3101>/Relational Operator'
     *  Switch: '<S4586>/Switch1'
     */
    if ((((uint32)VeTHMR_e_BatThrmlSt_B4D) == CeTHMR_e_PassiveCooling) ||
            (KeTHMR_b_BattRad_Airflow_Ovrrd))
    {
        /* Outputs for Atomic SubSystem: '<S3101>/Limiter' */
        /* Switch: '<S3113>/Switch1' incorporates:
         *  Constant: '<S3110>/Calib'
         *  RelationalOperator: '<S3113>/RelationalOperator'
         */
        if (KeTHMR_dV_MaxBattRadAirflow < rtb_Sum2_aq)
        {
            /* Switch: '<S3113>/Switch1' */
            rtb_TmpSignalConversionAtVeTFTR = KeTHMR_dV_MaxBattRadAirflow;
        }
        else
        {
            /* Switch: '<S3113>/Switch1' */
            rtb_TmpSignalConversionAtVeTFTR = rtb_Sum2_aq;
        }

        /* End of Switch: '<S3113>/Switch1' */

        /* Switch: '<S3113>/Switch' incorporates:
         *  Constant: '<S3101>/ConstantValue'
         *  RelationalOperator: '<S3113>/RelationalOperator1'
         */
        if (rtb_TmpSignalConversionAtVeTFTR <= 0.0F)
        {
            /* Switch: '<S3163>/Switch1' */
            rtb_TmpSignalConversionAtVeTFTR = 0.0F;
        }

        /* End of Switch: '<S3113>/Switch' */
        /* End of Outputs for SubSystem: '<S3101>/Limiter' */
    }
    else
    {
        /* Switch: '<S3163>/Switch1' incorporates:
         *  Constant: '<S3101>/ConstantValue1'
         */
        rtb_TmpSignalConversionAtVeTFTR = 0.0F;
    }

    /* End of Switch: '<S3101>/Switch' */

    /* Logic: '<S3101>/LogicalOperator1' incorporates:
     *  RelationalOperator: '<S3101>/RelationalOperator1'
     *  RelationalOperator: '<S3101>/RelationalOperator5'
     */
    rtb_OR1_bn = ((rtb_Sum2_aq >= rtb_TmpSignalConversionAtVeTFTR) ||
                  (rtb_Sum2_aq <= rtb_TmpSignalConversionAtVeTFTR));

    /* Gain: '<S3114>/Gain' */
    rtb_Sum2_aq = rtb_TmpSignalConversionAtVeTFTR;

    /* End of Outputs for SubSystem: '<S63>/BTR_Airflow' */
#endif

    /* S-Function (fcgen): '<S63>/Function-CallGenerator' incorporates:
     *  SubSystem: '<S63>/FcnCallFcnGen'
     */
    /* S-Function (fcgen): '<S3103>/Function-CallGenerator' incorporates:
     *  SubSystem: '<S63>/MBC_BTL'
     */
    /* SignalConversion generated from: '<S3156>/Product' incorporates:
     *  UnitDelay: '<S3129>/UnitDelay'
     *  UnitDelay: '<S3148>/UnitDelay'
     */
    for (i = 0; i < 3; i++)
    {
        rtb_UnitDelay_buv[i] = THMR_ac_DW.UnitDelay_DSTATE_an[i];
    }

    rtb_UnitDelay_buv[3] = THMR_ac_DW.UnitDelay_DSTATE_ec;

    /* End of SignalConversion generated from: '<S3156>/Product' */

    /* Product: '<S3156>/Product' incorporates:
     *  Constant: '<S3150>/Calib'
     *  Gain: '<S3140>/Gain1'
     */
    rtb_Switch10 = 0.0F;
    for (i = 0; i < 4; i++)
    {
        rtb_Switch10 += (-KaTHMR_k_KLQGBTLHtrMBC[(i)]) * rtb_UnitDelay_buv[i];
    }

    /* Product: '<S3156>/Product' */
    VeTHMR_P_BTLHtrMBC_BfGrdLim = rtb_Switch10;

    /* Outputs for Atomic SubSystem: '<S3127>/Limiter1' */
    /* Switch: '<S3144>/Switch1' incorporates:
     *  Constant: '<S3133>/Calib'
     *  RelationalOperator: '<S3144>/RelationalOperator'
     */
    if (KeTHMR_P_MaxBTLHtrMBC < VeTHMR_P_BTLHtrMBC_BfGrdLim)
    {
        /* Switch: '<S3149>/Switch1' */
        rtb_TmpSignalConversionAtVeTFTR = KeTHMR_P_MaxBTLHtrMBC;
    }
    else
    {
        /* Switch: '<S3149>/Switch1' */
        rtb_TmpSignalConversionAtVeTFTR = VeTHMR_P_BTLHtrMBC_BfGrdLim;
    }

    /* End of Switch: '<S3144>/Switch1' */
    /* End of Outputs for SubSystem: '<S3127>/Limiter1' */

    /* Outputs for Atomic SubSystem: '<S3127>/GradientLimiter1' */
    /* Switch: '<S3147>/Switch1' incorporates:
     *  UnitDelay: '<S3142>/UnitDelay'
     */
    rtb_MinMax7 = THMR_ac_DW.UnitDelay_DSTATE_f1;

    /* End of Outputs for SubSystem: '<S3127>/GradientLimiter1' */

    /* Outputs for Atomic SubSystem: '<S3127>/Limiter1' */
    /* Switch: '<S3144>/Switch' incorporates:
     *  Constant: '<S3134>/Calib'
     *  RelationalOperator: '<S3144>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTFTR <= KeTHMR_P_MinBTLHtrMBC)
    {
        rtb_TmpSignalConversionAtVeTFTR = KeTHMR_P_MinBTLHtrMBC;
    }

    /* End of Switch: '<S3144>/Switch' */
    /* End of Outputs for SubSystem: '<S3127>/Limiter1' */

    /* Outputs for Atomic SubSystem: '<S3127>/GradientLimiter1' */
    /* Sum: '<S3142>/Sum2' */
    rtb_TmpSignalConversionAtVeTFTR -= rtb_MinMax7;

    /* Outputs for Atomic SubSystem: '<S3142>/Limiter' */
    /* Switch: '<S3146>/Switch1' incorporates:
     *  Constant: '<S3135>/Calib'
     *  RelationalOperator: '<S3146>/RelationalOperator'
     */
    if (KeTHMR_P_UGrdLimitBTLHtrMBC < rtb_TmpSignalConversionAtVeTFTR)
    {
        /* Switch: '<S3149>/Switch1' */
        rtb_TmpSignalConversionAtVeTFTR = KeTHMR_P_UGrdLimitBTLHtrMBC;
    }

    /* End of Switch: '<S3146>/Switch1' */

    /* Switch: '<S3146>/Switch' incorporates:
     *  Constant: '<S3132>/Calib'
     *  RelationalOperator: '<S3146>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTFTR <= KeTHMR_P_DGrdLimitBTLHtrMBC)
    {
        rtb_TmpSignalConversionAtVeTFTR = KeTHMR_P_DGrdLimitBTLHtrMBC;
    }

    /* End of Switch: '<S3146>/Switch' */
    /* End of Outputs for SubSystem: '<S3142>/Limiter' */

    /* Sum: '<S3142>/Sum3' */
    VeTHMR_P_BTLHtrMBC = rtb_TmpSignalConversionAtVeTFTR + rtb_MinMax7;

    /* Update for UnitDelay: '<S3142>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_f1 = VeTHMR_P_BTLHtrMBC;

    /* End of Outputs for SubSystem: '<S3127>/GradientLimiter1' */

    /* SignalConversion generated from: '<S3157>/Product' incorporates:
     *  UnitDelay: '<S3129>/UnitDelay'
     *  UnitDelay: '<S3149>/UnitDelay'
     */
    for (i = 0; i < 3; i++)
    {
        rtb_UnitDelay_buv[i] = THMR_ac_DW.UnitDelay_DSTATE_an[i];
    }

    rtb_UnitDelay_buv[3] = THMR_ac_DW.UnitDelay_DSTATE_g5;

    /* End of SignalConversion generated from: '<S3157>/Product' */

    /* Product: '<S3157>/Product' incorporates:
     *  Constant: '<S3151>/Calib'
     *  Gain: '<S3140>/Gain'
     */
    rtb_Switch10 = 0.0F;
    for (i = 0; i < 4; i++)
    {
        rtb_Switch10 += (-KaTHMR_k_KLQGBTLPumpMBC[(i)]) * rtb_UnitDelay_buv[i];
    }

    /* Product: '<S3157>/Product' */
    VeTHMR_n_BTLPumpMBC_BfGrdLim = rtb_Switch10;

    /* Outputs for Atomic SubSystem: '<S3127>/Limiter2' */
    /* Switch: '<S3145>/Switch1' incorporates:
     *  Constant: '<S3137>/Calib'
     *  RelationalOperator: '<S3145>/RelationalOperator'
     */
    if (KeTHMR_n_MaxBTLPumpMBC < VeTHMR_n_BTLPumpMBC_BfGrdLim)
    {
        /* Switch: '<S3149>/Switch1' */
        rtb_TmpSignalConversionAtVeTFTR = KeTHMR_n_MaxBTLPumpMBC;
    }
    else
    {
        /* Switch: '<S3149>/Switch1' */
        rtb_TmpSignalConversionAtVeTFTR = VeTHMR_n_BTLPumpMBC_BfGrdLim;
    }

    /* End of Switch: '<S3145>/Switch1' */

    /* Switch: '<S3145>/Switch' incorporates:
     *  Constant: '<S3138>/Calib'
     *  RelationalOperator: '<S3145>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTFTR > KeTHMR_n_MinBTLPumpMBC)
    {
        /* Switch: '<S3145>/Switch' */
        rtb_MinMax7 = rtb_TmpSignalConversionAtVeTFTR;
    }
    else
    {
        /* Switch: '<S3145>/Switch' */
        rtb_MinMax7 = KeTHMR_n_MinBTLPumpMBC;
    }

    /* End of Switch: '<S3145>/Switch' */
    /* End of Outputs for SubSystem: '<S3127>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S3127>/GradientLimiter2' */
    /* Switch: '<S3149>/Switch1' incorporates:
     *  UnitDelay: '<S3143>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeTFTR = THMR_ac_DW.UnitDelay_DSTATE_i5;

    /* Sum: '<S3143>/Sum2' */
    rtb_MinMax7 -= rtb_TmpSignalConversionAtVeTFTR;

    /* Outputs for Atomic SubSystem: '<S3143>/Limiter' */
    /* Switch: '<S3147>/Switch1' incorporates:
     *  Constant: '<S3139>/Calib'
     *  RelationalOperator: '<S3147>/RelationalOperator'
     */
    if (KeTHMR_n_UGrdLimitBTLPumpMBC < rtb_MinMax7)
    {
        /* Switch: '<S3147>/Switch1' */
        rtb_MinMax7 = KeTHMR_n_UGrdLimitBTLPumpMBC;
    }

    /* End of Switch: '<S3147>/Switch1' */

    /* Switch: '<S3147>/Switch' incorporates:
     *  Constant: '<S3136>/Calib'
     *  RelationalOperator: '<S3147>/RelationalOperator1'
     */
    if (rtb_MinMax7 <= KeTHMR_n_DGrdLimitBTLPumpMBC)
    {
        rtb_MinMax7 = KeTHMR_n_DGrdLimitBTLPumpMBC;
    }

    /* End of Switch: '<S3147>/Switch' */
    /* End of Outputs for SubSystem: '<S3143>/Limiter' */

    /* Sum: '<S3143>/Sum3' */
    VeTHMR_n_BTLPumpMBC = rtb_MinMax7 + rtb_TmpSignalConversionAtVeTFTR;

    /* Update for UnitDelay: '<S3143>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_i5 = VeTHMR_n_BTLPumpMBC;

    /* End of Outputs for SubSystem: '<S3127>/GradientLimiter2' */

    /* Switch: '<S3148>/Switch1' incorporates:
     *  Constant: '<S3148>/ConstantValue'
     *  Constant: '<S3148>/ConstantValue1'
     *  Constant: '<S3148>/ConstantValue2'
     *  Constant: '<S3148>/ConstantValue3'
     *  Constant: '<S3152>/Calib'
     *  Constant: '<S3153>/Calib'
     *  Logic: '<S3148>/Logical'
     *  Logic: '<S3148>/Logical1'
     *  Logic: '<S3148>/Logical2'
     *  Product: '<S3148>/Product1'
     *  RelationalOperator: '<S3148>/Comparison'
     *  RelationalOperator: '<S3148>/Comparison1'
     *  RelationalOperator: '<S3148>/Comparison2'
     *  RelationalOperator: '<S3148>/Comparison3'
     *  UnitDelay: '<S3140>/UnitDelay2'
     */
    if (((rtb_TmpSignalConversionAtVeB_nb > 0.0F) &&
            (THMR_ac_DW.UnitDelay2_DSTATE_oi >= KeTHMR_P_MaxAntWdBTLHtrMBC)) ||
            ((rtb_TmpSignalConversionAtVeB_nb < 0.0F) &&
             (THMR_ac_DW.UnitDelay2_DSTATE_oi <= KeTHMR_P_MinAntWdBTLHtrMBC)))
    {
        rtb_TmpSignalConversionAtVeTFTR = 0.0F;
    }
    else
    {
        rtb_TmpSignalConversionAtVeTFTR = 0.1F * rtb_TmpSignalConversionAtVeB_nb;
    }

    /* End of Switch: '<S3148>/Switch1' */

    /* Update for UnitDelay: '<S3148>/UnitDelay' incorporates:
     *  Sum: '<S3148>/Sum'
     */
    THMR_ac_DW.UnitDelay_DSTATE_ec += rtb_TmpSignalConversionAtVeTFTR;

    /* End of Outputs for S-Function (fcgen): '<S3103>/Function-CallGenerator' */
    /* End of Outputs for S-Function (fcgen): '<S63>/Function-CallGenerator' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeTPDR_P_BattHeater_PwrBdgt_Avail' */
    (void)Rte_Read_VeTPDR_P_BattHeater_PwrBdgt_Avail_Value(&rtb_MinMax1_c);

    /* Inport: '<Root>/VeBTRR_P_BatHeatPwr_NeedLimtd' */
    (void)Rte_Read_VeBTRR_P_BatHeatPwr_NeedLimtd_Value(&Switch_o);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LT_Batt_Loop'
     */
    /* S-Function (fcgen): '<S63>/Function-CallGenerator' incorporates:
     *  SubSystem: '<S63>/FcnCallFcnGen'
     */
    /* S-Function (fcgen): '<S3103>/Function-CallGenerator' incorporates:
     *  SubSystem: '<S63>/MBC_BTL'
     */
    /* SignalConversion generated from: '<S3129>/Gain1' incorporates:
     *  Constant: '<S3131>/Calib'
     *  Product: '<S3105>/Product1'
     */
    rtb_UnitDelay_buv[0] = VeTHMR_P_BTLHtrMBC_BfGrdLim;
    rtb_UnitDelay_buv[1] = VeTHMR_n_BTLPumpMBC_BfGrdLim;
    rtb_UnitDelay_buv[2] = KeTHMR_Cf_VehSpdMBCCnvsn * VeTHMR_v_Vehicle;
    rtb_UnitDelay_buv[3] = rtb_TmpSignalConversionAtVeTRIR;
    for (i = 0; i < 3; i++)
    {
        /* Sum: '<S3129>/Add1' incorporates:
         *  Constant: '<S3128>/Calib'
         *  Constant: '<S3129>/Constant'
         *  Gain: '<S3129>/Gain2'
         */
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 3;
                rtb_DataTypeConversion2++)
        {
            i_0 = (3 * i) + rtb_DataTypeConversion2;
            tmp_3[i_0] = KaTHMR_k_AkalmanBTLMBC[(i_0)] -
                (KaTHMR_k_LkalmanBTLMBC[(rtb_DataTypeConversion2)] *
                 KaTHMR_k_CkalmanBTLMBC[(i)]);
        }

        /* End of Sum: '<S3129>/Add1' */

        /* Sum: '<S3129>/Add' incorporates:
         *  Constant: '<S3128>/Calib'
         *  Gain: '<S3129>/Gain1'
         *  Product: '<S3129>/Product'
         */
        rtb_Switch10 = 0.0F;
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 4;
                rtb_DataTypeConversion2++)
        {
            rtb_Switch10 += KaTHMR_k_BkalmanBTLMBC[(3 * rtb_DataTypeConversion2)
                + i] * rtb_UnitDelay_buv[rtb_DataTypeConversion2];
        }

        tmp[i] = (KaTHMR_k_LkalmanBTLMBC[(i)] * rtb_TmpSignalConversionAtVeBT_o)
            + rtb_Switch10;
    }

    /* Product: '<S3129>/Product1' incorporates:
     *  UnitDelay: '<S3129>/UnitDelay'
     */
    for (i = 0; i < 3; i++)
    {
        tmp_0[i] = 0.0F;
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 3;
                rtb_DataTypeConversion2++)
        {
            tmp_0[i] += tmp_3[(3 * rtb_DataTypeConversion2) + i] *
                THMR_ac_DW.UnitDelay_DSTATE_an[rtb_DataTypeConversion2];
        }
    }

    /* End of Product: '<S3129>/Product1' */

    /* Update for UnitDelay: '<S3129>/UnitDelay' incorporates:
     *  Sum: '<S3129>/Add'
     */
    for (i = 0; i < 3; i++)
    {
        THMR_ac_DW.UnitDelay_DSTATE_an[i] = tmp[i] + tmp_0[i];
    }

    /* End of Update for UnitDelay: '<S3129>/UnitDelay' */

    /* Switch: '<S3149>/Switch1' incorporates:
     *  Constant: '<S3149>/ConstantValue'
     *  Constant: '<S3149>/ConstantValue1'
     *  Constant: '<S3149>/ConstantValue2'
     *  Constant: '<S3149>/ConstantValue3'
     *  Constant: '<S3154>/Calib'
     *  Constant: '<S3155>/Calib'
     *  Logic: '<S3149>/Logical'
     *  Logic: '<S3149>/Logical1'
     *  Logic: '<S3149>/Logical2'
     *  Product: '<S3149>/Product1'
     *  RelationalOperator: '<S3149>/Comparison'
     *  RelationalOperator: '<S3149>/Comparison1'
     *  RelationalOperator: '<S3149>/Comparison2'
     *  RelationalOperator: '<S3149>/Comparison3'
     *  UnitDelay: '<S3140>/UnitDelay1'
     */
    if (((rtb_TmpSignalConversionAtVeB_nb < 0.0F) &&
            (THMR_ac_DW.UnitDelay1_DSTATE_lv >= KeTHMR_n_MaxAntWdBTLPumpMBC)) ||
        ((rtb_TmpSignalConversionAtVeB_nb > 0.0F) &&
            (THMR_ac_DW.UnitDelay1_DSTATE_lv <= KeTHMR_n_MinAntWdBTLPumpMBC)))
    {
        rtb_TmpSignalConversionAtVeTFTR = 0.0F;
    }
    else
    {
        rtb_TmpSignalConversionAtVeTFTR = 0.1F * rtb_TmpSignalConversionAtVeB_nb;
    }

    /* End of Switch: '<S3149>/Switch1' */

    /* Update for UnitDelay: '<S3149>/UnitDelay' incorporates:
     *  Sum: '<S3149>/Sum'
     */
    THMR_ac_DW.UnitDelay_DSTATE_g5 += rtb_TmpSignalConversionAtVeTFTR;

    /* Update for UnitDelay: '<S3140>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_oi = VeTHMR_P_BTLHtrMBC_BfGrdLim;

    /* Update for UnitDelay: '<S3140>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_lv = VeTHMR_n_BTLPumpMBC_BfGrdLim;

    /* End of Outputs for S-Function (fcgen): '<S3103>/Function-CallGenerator' */
    /* End of Outputs for S-Function (fcgen): '<S63>/Function-CallGenerator' */

    /* Switch: '<S3175>/Switch6' incorporates:
     *  Constant: '<S3196>/Calib'
     */
    if (!KeTHMR_b_BattPwrDstrbt_Slct)
    {
        rtb_MinMax1_c = VeTHMR_P_PwrBdgt_PwrLimitAvail_BD;
    }

    /* End of Switch: '<S3175>/Switch6' */

    /* MinMax: '<S3175>/MinMax1' incorporates:
     *  Constant: '<S3195>/Calib'
     */
    rtb_MinMax1_c = fminf(rtb_MinMax1_c, KeTHMR_P_AdjWshd_BattHtrPwr);

    /* Switch: '<S63>/Switch' */
    if (Gain_cm)
    {
        /* S-Function (fcgen): '<S63>/Function-CallGenerator' incorporates:
         *  SubSystem: '<S63>/FcnCallFcnGen'
         */
        /* S-Function (fcgen): '<S3103>/Function-CallGenerator' incorporates:
         *  SubSystem: '<S63>/MBC_BTL'
         */
        /* Switch: '<S63>/Switch' incorporates:
         *  Constant: '<S3130>/Calib'
         *  Product: '<S3105>/Product'
         */
        Switch_o = KeTHMR_Cf_HtrPwrMBCCnvsn * VeTHMR_P_BTLHtrMBC;

        /* End of Outputs for S-Function (fcgen): '<S3103>/Function-CallGenerator' */
        /* End of Outputs for S-Function (fcgen): '<S63>/Function-CallGenerator' */
    }

    /* End of Switch: '<S63>/Switch' */

    /* Sum: '<S3158>/Sum1' */
    rtb_TmpSignalConversionAtVeTFTR = Switch_o - rtb_TmpSignalConversionAtVeFSCR;

    /* Outputs for Atomic SubSystem: '<S3158>/Limiter' */
    /* Switch: '<S3171>/Switch1' incorporates:
     *  RelationalOperator: '<S3171>/RelationalOperator'
     */
    if (rtb_MinMax1_c < rtb_TmpSignalConversionAtVeTFTR)
    {
        /* Switch: '<S3163>/Switch1' */
        rtb_TmpSignalConversionAtVeTFTR = rtb_MinMax1_c;
    }

    /* End of Switch: '<S3171>/Switch1' */

    /* Switch: '<S3171>/Switch' incorporates:
     *  Constant: '<S3168>/Calib'
     *  RelationalOperator: '<S3171>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTFTR > KeTHMR_P_BattHtr_PwrMin)
    {
        /* Switch: '<S3171>/Switch' */
        VeTHMR_P_BattHtrPwrTgt_Lmtd = rtb_TmpSignalConversionAtVeTFTR;
    }
    else
    {
        /* Switch: '<S3171>/Switch' */
        VeTHMR_P_BattHtrPwrTgt_Lmtd = KeTHMR_P_BattHtr_PwrMin;
    }

    /* End of Switch: '<S3171>/Switch' */
    /* End of Outputs for SubSystem: '<S3158>/Limiter' */

    /* Switch: '<S3190>/Switch1' incorporates:
     *  Constant: '<S3192>/Calib'
     *  Logic: '<S3173>/Logical3'
     */
    if ((THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0) &&
            (KeTHMR_b_BattHtr_PwrWup_Ovrd))
    {
        /* Switch: '<S3190>/Switch1' incorporates:
         *  Constant: '<S3191>/Calib'
         */
        VeTHMR_P_Batt_HeatPwr_Raw = KeTHMR_P_BattHtrPwr_PerwUP_D;
    }
    else
    {
        /* Switch: '<S3190>/Switch1' */
        VeTHMR_P_Batt_HeatPwr_Raw = VeTHMR_P_BattHtrPwrTgt_Lmtd;
    }

    /* End of Switch: '<S3190>/Switch1' */

    /* Switch: '<S3163>/Switch1' incorporates:
     *  Constant: '<S3193>/Constant'
     *  Constant: '<S3194>/Constant'
     *  Logic: '<S3174>/Logical1'
     *  RelationalOperator: '<S3174>/Comparison1'
     *  RelationalOperator: '<S3174>/Comparison5'
     *  Switch: '<S4586>/Switch1'
     */
    if ((CeTHMR_e_Heating == ((uint32)VeTHMR_e_BatThrmlSt_B4D)) || (((uint32)
            VeTHMR_e_BatThrmlSt_B4D) == CeTHMR_e_ActvPsvHeating))
    {
        /* Switch: '<S3164>/Switch1' */
        if (VeTHMR_b_BattAllowed_SeprtHtr)
        {
            /* Outputs for Atomic SubSystem: '<S3172>/Limiter1' */
            /* Switch: '<S3189>/Switch1' incorporates:
             *  Constant: '<S3187>/Calib'
             *  RelationalOperator: '<S3189>/RelationalOperator'
             */
            if (KeTHMR_P_BattHeatPwrTgt_Max < VeTHMR_P_Batt_HeatPwr_Raw)
            {
                /* Switch: '<S3189>/Switch1' */
                rtb_TmpSignalConversionAtVeTFTR = KeTHMR_P_BattHeatPwrTgt_Max;
            }
            else
            {
                /* Switch: '<S3189>/Switch1' */
                rtb_TmpSignalConversionAtVeTFTR = VeTHMR_P_Batt_HeatPwr_Raw;
            }

            /* End of Switch: '<S3189>/Switch1' */

            /* Switch: '<S3189>/Switch' incorporates:
             *  Constant: '<S3188>/Calib'
             *  RelationalOperator: '<S3189>/RelationalOperator1'
             */
            if (rtb_TmpSignalConversionAtVeTFTR <= KeTHMR_P_BattHeatPwrTgt_Min)
            {
                /* Switch: '<S3163>/Switch1' incorporates:
                 *  Switch: '<S3164>/Switch1'
                 */
                rtb_TmpSignalConversionAtVeTFTR = KeTHMR_P_BattHeatPwrTgt_Min;
            }

            /* End of Switch: '<S3189>/Switch' */
            /* End of Outputs for SubSystem: '<S3172>/Limiter1' */
        }
        else
        {
            /* Switch: '<S3163>/Switch1' incorporates:
             *  Constant: '<S3167>/Calib'
             *  Switch: '<S3164>/Switch1'
             */
            rtb_TmpSignalConversionAtVeTFTR = KeTHMR_P_BattHeatPwr_TgtZero;
        }

        /* End of Switch: '<S3164>/Switch1' */
    }
    else
    {
        /* Switch: '<S3163>/Switch1' incorporates:
         *  Constant: '<S3167>/Calib'
         */
        rtb_TmpSignalConversionAtVeTFTR = KeTHMR_P_BattHeatPwr_TgtZero;
    }

    /* End of Switch: '<S3163>/Switch1' */

    /* MinMax: '<S3158>/MinMax' incorporates:
     *  Lookup_n-D: '<S3170>/Vector'
     *  SignalConversion generated from: '<S2>/VePMPR_dV_BattFlw'
     */
    VeTHMR_P_BCHHtrPwrReq = fminf(look1_iflf_binlcapw
        (rtb_TmpSignalConversionAtVePMPR, ((const float32 *)
        &(KxTHMR_P_MaxBCHPwrHtrClntFlow[0])), ((const float32 *)
        &(KtTHMR_P_MaxBCHPwrHtrClntFlow[0])), 7U),
        rtb_TmpSignalConversionAtVeTFTR);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* S-Function (sfix_bitop): '<S3202>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S3202>/StatusByte_LIN1_BusOff'
     *  S-Function (sfix_bitop): '<S1508>/Bitwise Operator2'
     */
    VeTHMR_b_BCH_U1008_DTCSet_tmp = ((uint32)THMR_ac_DW.StatusByte_LIN1_BusOff)
        & 1U;

    /* S-Function (sfix_bitop): '<S3202>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S3202>/StatusByte_LIN1_BusOff'
     *  S-Function (sfix_bitop): '<S1508>/Bitwise Operator1'
     */
    VeTHMR_b_BCH_U1008_DTCSet_tmp_0 = ((uint32)THMR_ac_DW.StatusByte_LIN1_BusOff)
        & 64U;

    /* Logic: '<S3202>/Logical Operator' incorporates:
     *  Constant: '<S3202>/Constant1'
     *  Constant: '<S3202>/Constant2'
     *  RelationalOperator: '<S3202>/Relational Operator1'
     *  RelationalOperator: '<S3202>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S3202>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S3202>/Bitwise Operator2'
     */
    VeTHMR_b_BCH_U1008_DTCSet = ((VeTHMR_b_BCH_U1008_DTCSet_tmp != 0U) &&
        (VeTHMR_b_BCH_U1008_DTCSet_tmp_0 == 0U));

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* S-Function (sfix_bitop): '<S3203>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S3203>/StatusByte_LIN2_BusOff'
     *  S-Function (sfix_bitop): '<S1509>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S4306>/Bitwise Operator2'
     */
    tmpRead_1b = ((uint32)THMR_ac_DW.StatusByte_LIN2_BusOff) & 1U;

    /* S-Function (sfix_bitop): '<S3203>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S3203>/StatusByte_LIN2_BusOff'
     *  S-Function (sfix_bitop): '<S1509>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4306>/Bitwise Operator1'
     */
    VeTHMR_b_BCH_U1009_DTCSet_tmp = ((uint32)THMR_ac_DW.StatusByte_LIN2_BusOff)
        & 64U;

    /* Logic: '<S3203>/Logical Operator' incorporates:
     *  Constant: '<S3203>/Constant1'
     *  Constant: '<S3203>/Constant2'
     *  RelationalOperator: '<S3203>/Relational Operator1'
     *  RelationalOperator: '<S3203>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S3203>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S3203>/Bitwise Operator2'
     */
    VeTHMR_b_BCH_U1009_DTCSet = ((tmpRead_1b != 0U) &&
        (VeTHMR_b_BCH_U1009_DTCSet_tmp == 0U));

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* S-Function (sfix_bitop): '<S3204>/BitwiseOperator2' incorporates:
     *  DataStoreRead: '<S3204>/StatusByte_LostCommHB_CooltHtr4'
     *  S-Function (sfix_bitop): '<S4602>/BitwiseOperator2'
     */
    rtb_Logical3_ks_tmp = ((sint32)THMR_ac_DW.StatusByte_LostCommHB_CooltHtr4) &
        1;

    /* S-Function (sfix_bitop): '<S3204>/BitwiseOperator1' incorporates:
     *  DataStoreRead: '<S3204>/StatusByte_LostCommHB_CooltHtr4'
     *  S-Function (sfix_bitop): '<S4602>/BitwiseOperator1'
     */
    VeTHMR_b_BCH_U04B8_DTCSet_tmp = ((uint32)
        THMR_ac_DW.StatusByte_LostCommHB_CooltHtr4) & 64U;

    /* Logic: '<S3204>/LogicalOperator' incorporates:
     *  Constant: '<S3204>/Constant1'
     *  Constant: '<S3204>/Constant2'
     *  RelationalOperator: '<S3204>/RelationalOperator1'
     *  RelationalOperator: '<S3204>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S3204>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S3204>/BitwiseOperator2'
     */
    VeTHMR_b_BCH_U04B8_DTCSet = ((rtb_Logical3_ks_tmp > 0) &&
        (VeTHMR_b_BCH_U04B8_DTCSet_tmp == 0U));

    /* Logic: '<S3200>/Logical Operator' incorporates:
     *  Constant: '<S3200>/Constant1'
     *  Constant: '<S3200>/Constant2'
     *  DataStoreRead: '<S3200>/StatusByte_BattCoolPmpHtrBTempSnsrPerf'
     *  RelationalOperator: '<S3200>/Relational Operator1'
     *  RelationalOperator: '<S3200>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S3200>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S3200>/Bitwise Operator2'
     */
    VeTHMR_b_BCH_P1DE0_DTCSet = (((((uint32)
        THMR_ac_DW.StatusByte_BattCoolPmpHtrBTempS) & 1U) != 0U) && ((((uint32)
        THMR_ac_DW.StatusByte_BattCoolPmpHtrBTempS) & 64U) == 0U));

    /* Logic: '<S3201>/LogicalOperator' incorporates:
     *  Constant: '<S3201>/Constant1'
     *  Constant: '<S3201>/Constant2'
     *  DataStoreRead: '<S3201>/StatusByte_CoolantHeaterBPerf'
     *  RelationalOperator: '<S3201>/RelationalOperator1'
     *  RelationalOperator: '<S3201>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S3201>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S3201>/BitwiseOperator2'
     */
    VeTHMR_b_BCH_P0E19_DTCSet = (((((sint32)
        THMR_ac_DW.StatusByte_CoolantHeaterBPerf) & 1) > 0) && ((((uint32)
        THMR_ac_DW.StatusByte_CoolantHeaterBPerf) & 64U) == 0U));

    /* Logic: '<S3176>/LogicalOperator1' incorporates:
     *  Constant: '<S3197>/Constant'
     *  Constant: '<S3198>/Constant'
     *  Constant: '<S3199>/Constant'
     *  Constant: '<S3205>/Calib'
     *  Constant: '<S3206>/Calib'
     *  Constant: '<S3207>/Calib'
     *  Constant: '<S3208>/Calib'
     *  Constant: '<S3209>/Calib'
     *  Constant: '<S3210>/Calib'
     *  Logic: '<S3176>/LogicalOperator'
     *  Logic: '<S3176>/LogicalOperator4'
     *  Logic: '<S3176>/LogicalOperator5'
     *  Logic: '<S3176>/LogicalOperator6'
     *  Logic: '<S3176>/LogicalOperator7'
     *  Logic: '<S3176>/LogicalOperator8'
     *  RelationalOperator: '<S3176>/RelationalOperator'
     *  RelationalOperator: '<S3176>/RelationalOperator1'
     *  RelationalOperator: '<S3176>/RelationalOperator2'
     */
    VeTHMR_b_BCH_HtrFlty = ((KeTHMR_b_BCHStsHtrFaulty) && (((((((((((uint32)
        rtb_TmpSignalConversionAtVeHT_i) == CeHTIR_e_HtrSts_LockedUntilNextStart)
        || (((uint32)rtb_TmpSignalConversionAtVeHT_i) ==
            CeHTIR_e_HtrSts_LockedUntilService)) || (((uint32)
        rtb_TmpSignalConversionAtVeHT_i) == CeHTIR_e_HtrSts_LockedPermanent)) ||
        (THMR_ac_B.TmpSignalConversionAtVeHCDR__os)) ||
        ((KeTHMR_b_BCH_LIN1BusOff_HtrFlty_RA) && (VeTHMR_b_BCH_U1008_DTCSet))) ||
        ((KeTHMR_b_BCH_LIN2BusOff_HtrFlty_RA) && (VeTHMR_b_BCH_U1009_DTCSet))) ||
        ((KeTHMR_b_BCH_LOC_HtrFlty_RA) && (VeTHMR_b_BCH_U04B8_DTCSet))) ||
        ((KeTHMR_b_BCH_TempSensPerfIssue_HtrFlty_RA) &&
         (VeTHMR_b_BCH_P1DE0_DTCSet))) ||
        ((KeTHMR_b_BCH_CntrlPerfIssue_HtrFlty_RA) && (VeTHMR_b_BCH_P0E19_DTCSet))));

    /* Logic: '<S3160>/Logical1' incorporates:
     *  Constant: '<S3177>/Constant'
     *  Constant: '<S3178>/Constant'
     *  Constant: '<S3180>/Calib'
     *  Constant: '<S3182>/Calib'
     *  Constant: '<S3183>/Calib'
     *  Logic: '<S3160>/Logical2'
     *  RelationalOperator: '<S3160>/Comparison10'
     *  RelationalOperator: '<S3160>/Comparison4'
     *  RelationalOperator: '<S3160>/Comparison6'
     *  RelationalOperator: '<S3160>/Comparison7'
     *  RelationalOperator: '<S3160>/Comparison8'
     *  RelationalOperator: '<S3160>/Comparison9'
     *  Switch: '<S3956>/Switch'
     */
    Gain_cm = ((((((VeTHMR_P_BCHHtrPwrReq >= KeTHMR_P_BCHPwr_HtrReqMin) &&
                   (rtb_MinMax1_c >= KeTHMR_P_PwrBdgt_BattHtrReqMin)) &&
                  (((uint32)rtb_TmpSignalConversionAtVeHT_i) ==
                   CeHTIR_e_HtrSts_Operation)) && (!VeTHMR_b_BCH_HtrFlty)) &&
                (rtb_TmpSignalConversionAtVeHT_k > KeTHMR_P_BCH_ActWhsdPwr_Min))
               && ((((uint32)VeTHMR_e_BatCntctrStat) == CeHVTR_e_Closed) ||
                   (VeTHMR_b_AlternatorMode_Actv)));

    /* Outputs for Atomic SubSystem: '<S3160>/TurnOnDelayTime' */
    /* Outputs for Atomic SubSystem: '<S3185>/EdgeRising' */
    /* Logic: '<S3186>/AND' incorporates:
     *  Logic: '<S3186>/OR1'
     *  UnitDelay: '<S3186>/UnitDelay'
     */
    rtb_OR1_jc2 = (Gain_cm && (!THMR_ac_DW.UnitDelay_DSTATE_no4));

    /* Update for UnitDelay: '<S3186>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_no4 = Gain_cm;

    /* End of Outputs for SubSystem: '<S3185>/EdgeRising' */

    /* Switch: '<S3185>/Switch1' incorporates:
     *  Logic: '<S3185>/OR'
     *  Logic: '<S3185>/OR1'
     */
    if ((!Gain_cm) || rtb_OR1_jc2)
    {
        /* Switch: '<S3185>/Switch1' incorporates:
         *  Constant: '<S3185>/ConstantValue1'
         */
        rtb_MinMax1_c = 0.0F;
    }
    else
    {
        /* Switch: '<S3185>/Switch1' incorporates:
         *  Constant: '<S3160>/ConstantValue1'
         *  Constant: '<S3184>/Calib'
         *  MinMax: '<S3185>/Minimum'
         *  Sum: '<S3185>/Summation'
         *  UnitDelay: '<S3185>/UnitDelay'
         */
        rtb_MinMax1_c = fminf(KeTHMR_t_BCH_WshdPwrNot_AvalTim,
                              THMR_ac_DW.UnitDelay_DSTATE_kz + 0.1F);
    }

    /* End of Switch: '<S3185>/Switch1' */

    /* Logic: '<S3185>/AND' incorporates:
     *  Constant: '<S3184>/Calib'
     *  RelationalOperator: '<S3185>/GreaterThan'
     */
    VeTHMR_b_BCHWshdPwrInitlzd = (Gain_cm && (rtb_MinMax1_c >=
        KeTHMR_t_BCH_WshdPwrNot_AvalTim));

    /* Update for UnitDelay: '<S3185>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kz = rtb_MinMax1_c;

    /* End of Outputs for SubSystem: '<S3160>/TurnOnDelayTime' */

    /* Switch: '<S3179>/Switch1' */
    if (VeTHMR_b_BCHWshdPwrInitlzd)
    {
        /* Switch: '<S3179>/Switch1' */
        VeTHMR_P_BCHWishedPowerLim = rtb_TmpSignalConversionAtVeHT_k;
    }
    else
    {
        /* Switch: '<S3179>/Switch1' incorporates:
         *  Constant: '<S3181>/Calib'
         */
        VeTHMR_P_BCHWishedPowerLim = KeTHMR_P_BCH_ActWhsdPwr_Max;
    }

    /* End of Switch: '<S3179>/Switch1' */

    /* MinMax: '<S3158>/MinMax1' */
    VeTHMR_P_BCHHtrPwrReq_BCHWishedPwrLim = fminf(VeTHMR_P_BCHWishedPowerLim,
        VeTHMR_P_BCHHtrPwrReq);

    /* Switch: '<S3158>/Switch1' incorporates:
     *  Constant: '<S3169>/Calib'
     */
    if (KeTHMR_b_BCHWishedPower_Enb)
    {
        /* Switch: '<S3158>/Switch1' */
        VeTHMR_P_BCHWishedPower = VeTHMR_P_BCHHtrPwrReq_BCHWishedPwrLim;
    }
    else
    {
        /* Switch: '<S3158>/Switch1' */
        VeTHMR_P_BCHWishedPower = VeTHMR_P_BCHHtrPwrReq;
    }

    /* End of Switch: '<S3158>/Switch1' */

    /* RelationalOperator: '<S3158>/Comparison2' incorporates:
     *  Constant: '<S3166>/Calib'
     */
    Gain_cm = (VeTHMR_P_BCHWishedPower > KeTHMR_P_BattHeatPwrTgt_MinOn);

    /* RelationalOperator: '<S3158>/Comparison4' */
    rtb_TmpSignalConversionAtOutAir = !rtb_TmpSignalConversionAtBattCn;

    /* Switch: '<S3165>/Switch1' incorporates:
     *  Constant: '<S3161>/Constant'
     *  Constant: '<S3162>/Constant'
     *  Logic: '<S3158>/Logical2'
     *  Logic: '<S3158>/Logical4'
     *  Logic: '<S3158>/Logical5'
     *  RelationalOperator: '<S3158>/Comparison3'
     *  RelationalOperator: '<S3158>/Comparison5'
     *  RelationalOperator: '<S3160>/Comparison10'
     *  Switch: '<S3956>/Switch'
     */
    VeTHMR_b_HVC_BattHtrReqstd_StaFlow_Raw = ((((((uint32)VeTHMR_e_BatCntctrStat)
        == CeHVTR_e_Closed) && rtb_TmpSignalConversionAtOutAir) && Gain_cm) ||
        ((Gain_cm && (((uint32)VeTHMR_e_BatCntctrStat) == CeHVTR_e_Open)) &&
         (VeTHMR_b_AlternatorMode_Actv)));

    /* SignalConversion generated from: '<S3159>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_BattHtr_Pwr_RA_En

    /* VariantMerge generated from: '<S3159>/VariantSource' */
    rtb_VariantMerge_For_Variant_da = THMR_ac_B.Logical7_l;

#else

    /* VariantMerge generated from: '<S3159>/VariantSource' incorporates:
     *  Constant: '<S3159>/Constant'
     *  SignalConversion generated from: '<S3159>/VariantSource'
     */
    rtb_VariantMerge_For_Variant_da = false;

#endif

    /* End of SignalConversion generated from: '<S3159>/VariantSource' */

    /* Switch: '<S3159>/Switch1' */
    if (rtb_VariantMerge_For_Variant_da)
    {
        /* Switch: '<S3159>/Switch1' incorporates:
         *  Constant: '<S3212>/Calib'
         */
        VeTHMR_P_HVC_BattHtrPwr_AD = KeTHMR_P_BattHtr_Pwr_RA;

        /* Switch: '<S3159>/Switch6' incorporates:
         *  Constant: '<S3211>/Calib'
         */
        VeTHMR_b_HVC_BattHtrReqstd_StaFlow_AD = HeTHMR_b_BattHtrReq_RA;
    }
    else
    {
        /* Switch: '<S3159>/Switch1' */
        VeTHMR_P_HVC_BattHtrPwr_AD = VeTHMR_P_BCHWishedPower;

        /* Switch: '<S3159>/Switch6' */
        VeTHMR_b_HVC_BattHtrReqstd_StaFlow_AD =
            VeTHMR_b_HVC_BattHtrReqstd_StaFlow_Raw;
    }

    /* End of Switch: '<S3159>/Switch1' */

    /* SignalConversion generated from: '<S63>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_BattRadiator_Equip

    /* Update for Atomic SubSystem: '<S63>/BTR_Airflow' */
    /* VariantMerge generated from: '<S63>/VariantSource' */
    THMR_ac_B.VariantMerge_Fo_om = rtb_Sum2_aq;

    /* Update for Delay: '<S3101>/IntegerDelay' */
    THMR_ac_DW.IntegerDelay_DSTATE = rtb_OR1_bn;

    /* End of Update for SubSystem: '<S63>/BTR_Airflow' */
#else

    /* VariantMerge generated from: '<S63>/VariantSource' incorporates:
     *  Constant: '<S63>/Constant1'
     *  SignalConversion generated from: '<S63>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_om = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S63>/VariantSource' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* SignalConversion generated from: '<S57>/Use_MBC_HTL_LTCL' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    /* VariantMerge generated from: '<S57>/Use_MBC_HTL_LTCL' */
    rtb_VM_Conditional_Signal_Use_c = THMR_ac_B.Logical1;

#else

    /* VariantMerge generated from: '<S57>/Use_MBC_HTL_LTCL' incorporates:
     *  SignalConversion generated from: '<S57>/Use_MBC_HTL_LTCL'
     */
    rtb_VM_Conditional_Signal_Use_c = false;

#endif

    /* End of SignalConversion generated from: '<S57>/Use_MBC_HTL_LTCL' */

    /* Switch: '<S1149>/Switch3' incorporates:
     *  Constant: '<S1168>/Calib'
     *  Constant: '<S1169>/Calib'
     *  Constant: '<S2097>/Constant'
     *  Constant: '<S2098>/Constant'
     *  Constant: '<S2099>/Constant'
     *  Constant: '<S2100>/Constant'
     *  Constant: '<S2101>/Constant'
     *  Constant: '<S2102>/Constant'
     *  Constant: '<S2103>/Calib'
     *  DataStoreRead: '<S57>/DataStoreRead1'
     *  DataStoreWrite: '<S57>/DataStoreWrite1'
     *  Logic: '<S1173>/LogicalOperator'
     *  Logic: '<S1173>/LogicalOperator1'
     *  Logic: '<S1173>/LogicalOperator2'
     *  Logic: '<S1173>/LogicalOperator3'
     *  Logic: '<S57>/And'
     *  Logic: '<S57>/Not'
     *  Logic: '<S57>/Or'
     *  RelationalOperator: '<S1173>/Comparison1'
     *  RelationalOperator: '<S1173>/Comparison2'
     *  RelationalOperator: '<S1173>/Comparison3'
     *  RelationalOperator: '<S1173>/Comparison4'
     *  RelationalOperator: '<S1173>/Comparison5'
     *  RelationalOperator: '<S1173>/Comparison6'
     *  S-Function (sfix_bitop): '<S1207>/FixPt Bitwise Operator3'
     *  S-Function (sfix_bitop): '<S1207>/FixPt Bitwise Operator4'
     *  S-Function (sfix_bitop): '<S1207>/FixPt Bitwise Operator5'
     *  S-Function (sfix_bitop): '<S1208>/FixPt Bitwise Operator1'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     */
    if (rtb_VM_Conditional_Signal_Use_c || (((KeTHMR_b_HTLMBCLegcySel) &&
            (!KeTHMR_b_HTLMBCSelect)) && ((CeTHMR_e_CabinActiveHeating ==
            ((uint32)rtb_Switch1_o0g)) && ((((((((uint32)
                 rtb_TmpSignalConversionAtVePD_l) != CePDTR_e_Dischrg_CabReqInOV)
               && (((uint32)rtb_TmpSignalConversionAtVePD_l) !=
                   CePDTR_e_Dischrg_AmbTempLow)) && (((uint32)
                rtb_TmpSignalConversionAtVePD_l) != CePDTR_e_Dischrg_CabReqPrsnt))
             && (((uint32)rtb_TmpSignalConversionAtVePD_l) !=
                 CePDTR_e_Dischrg_BatAndCab_Cndtn)) && (((uint32)
              rtb_TmpSignalConversionAtVePD_l) != CePDTR_e_NoValidReq)) ||
            (KeTHMR_b_UseHLTMBCforOV)))))
    {
        VeTHMR_y_PumpEnbl_DS = (uint8)(VeTHMR_y_PumpEnbl_DS | ((uint8)1));
    }
    else
    {
        VeTHMR_y_PumpEnbl_DS = (uint8)(~((uint8)(((uint8)(~VeTHMR_y_PumpEnbl_DS))
            | ((uint8)1))));
    }

    /* End of Switch: '<S1149>/Switch3' */

    /* If: '<S1175>/If' incorporates:
     *  Gain: '<S1189>/Gain'
     *  Logic: '<S1175>/Logical'
     *  Logic: '<S1175>/Logical1'
     *  Logic: '<S1175>/Logical7'
     *  Logic: '<S1178>/Logical3'
     *  Logic: '<S1178>/Logical4'
     *  Logic: '<S1178>/Logical5'
     *  Logic: '<S1178>/Logical6'
     *  Logic: '<S1178>/Logical7'
     *  Logic: '<S1178>/Logical8'
     *  Logic: '<S1181>/Logical10'
     *  Logic: '<S1181>/Logical16'
     *  Logic: '<S1181>/Logical3'
     *  Logic: '<S1181>/Logical4'
     *  Logic: '<S1181>/Logical5'
     *  Logic: '<S1181>/Logical6'
     *  Logic: '<S1181>/Logical7'
     *  Logic: '<S1181>/Logical8'
     *  Logic: '<S1183>/Logical10'
     *  Logic: '<S1183>/Logical3'
     *  Logic: '<S1183>/Logical4'
     *  Logic: '<S1183>/Logical7'
     *  Logic: '<S1184>/Logical3'
     *  Logic: '<S1184>/Logical4'
     *  Logic: '<S1184>/Logical5'
     *  Logic: '<S1184>/Logical7'
     *  RelationalOperator: '<S1178>/Comparison'
     *  RelationalOperator: '<S1178>/Comparison1'
     *  RelationalOperator: '<S1181>/Comparison'
     *  RelationalOperator: '<S1181>/Comparison1'
     *  RelationalOperator: '<S1181>/Comparison2'
     *  RelationalOperator: '<S1181>/Comparison3'
     *  RelationalOperator: '<S1183>/Comparison4'
     *  RelationalOperator: '<S1184>/Comparison'
     *  SignalConversion generated from: '<S1148>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblBattCabPriority

    /* Logic: '<S1175>/Logical' */
    VeTHMR_b_FullBatt = ((THMR_ac_B.VeTHMR_b_CabReq_NotAllow_BS) &&
                         (THMR_ac_B.Switch1_h));
    rtb_AND_fe = !THMR_ac_B.VeTHMR_b_CabReq_NotAllow_BS;
    Gain_cm = !VeTHMR_b_Defrost;

    /* Logic: '<S1183>/Logical3' incorporates:
     *  Constant: '<S1198>/Constant'
     *  SignalConversion generated from: '<S2>/VeBTRR_e_HV_BatTempCrit_CondState_New'
     */
    VeTHMR_b_MoreToBatt = (((((((uint32)rtb_TmpSignalConversionAtVeB_kc) ==
        CeBTRR_e_BatMarginal) || rtb_TmpSignalConversionAtVeBT_m) &&
        (THMR_ac_B.Switch1_h)) && rtb_AND_fe) && Gain_cm);

    /* RelationalOperator: '<S1559>/Comparison5' incorporates:
     *  Constant: '<S1181>/ConstantValue1'
     *  Constant: '<S1181>/ConstantValue2'
     *  Constant: '<S1181>/ConstantValue3'
     *  Constant: '<S1181>/ConstantValue4'
     */
    rtb_VariantMerge_For_Variant_da = ((((rtb_TmpSignalConversionAtVeB_cl > 0.0F)
        || (rtb_TmpSignalConversionAtVeB_nb < 0.0F)) ||
        rtb_TmpSignalConversionAtVeBT_m) || ((rtb_TmpSignalConversionAtVeB_nb ==
        0.0F) && (rtb_TmpSignalConversionAtVeB_cl == 0.0F)));
    rtb_OR1_bn = !THMR_ac_B.Switch1_h;

    /* Logic: '<S1181>/Logical8' */
    VeTHMR_b_FullToCabin = (((rtb_VariantMerge_For_Variant_da && rtb_OR1_bn) &&
        rtb_AND_fe) || ((rtb_VariantMerge_For_Variant_da && (VeTHMR_b_Defrost)) &&
                        rtb_AND_fe));

    /* Logic: '<S1184>/Logical3' incorporates:
     *  Constant: '<S1184>/ConstantValue1'
     */
    VeTHMR_b_MoreToCabin = (((((rtb_TmpSignalConversionAtVeB_cl > 0.0F) &&
        (!rtb_TmpSignalConversionAtVeBT_m)) && (THMR_ac_B.Switch1_h)) &&
        rtb_AND_fe) && Gain_cm);

    /* Logic: '<S1178>/Logical3' incorporates:
     *  Constant: '<S1178>/ConstantValue1'
     *  Constant: '<S1178>/ConstantValue2'
     *  Constant: '<S1193>/Calib'
     *  Constant: '<S1194>/Calib'
     */
    VeTHMR_b_BattOpt_MoreTocab = (((((rtb_TmpSignalConversionAtVeB_nb == 0.0F) &&
        (rtb_TmpSignalConversionAtVeB_cl == 0.0F)) && ((THMR_ac_B.Switch1_h) ||
        (KeTHMR_b_DsblBattAllwChk_OptPriority))) && (rtb_AND_fe ||
        (KeTHMR_b_DsblNoCabChk_OptPriority))) && Gain_cm);

    /* Logic: '<S1175>/Logical1' */
    VeTHMR_b_NoPriority = ((THMR_ac_B.VeTHMR_b_CabReq_NotAllow_BS) && rtb_OR1_bn);
    if (VeTHMR_b_FullBatt)
    {
        /* Outputs for IfAction SubSystem: '<S1175>/FullBattery' incorporates:
         *  ActionPort: '<S1180>/ActionPort'
         */
        /* Merge: '<S1175>/Merge' incorporates:
         *  Constant: '<S1196>/Calib'
         *  SignalConversion generated from: '<S1180>/BattPriority'
         */
        VeTHMR_r_BattCabRatioAftrMrg = KeTHMR_r_FullBatt;

        /* End of Outputs for SubSystem: '<S1175>/FullBattery' */
    }
    else if (VeTHMR_b_MoreToBatt)
    {
        /* Outputs for IfAction SubSystem: '<S1175>/MoreToBattery' incorporates:
         *  ActionPort: '<S1185>/ActionPort'
         */
        /* Switch: '<S1185>/Switch' incorporates:
         *  Constant: '<S1199>/Calib'
         */
        if (KeTHMR_b_SelSOCCal_MoreToBatt)
        {
            /* Merge: '<S1175>/Merge' incorporates:
             *  Lookup_n-D: '<S1201>/Vector'
             *  Switch: '<S244>/Switch'
             */
            VeTHMR_r_BattCabRatioAftrMrg = look1_iflf_binlcapw
                (VeTHMR_Pct_HV_BatSOC, ((const float32 *)
                  &(KxTHMR_r_MoreToBatt_SOC[0])), ((const float32 *)
                  &(KtTHMR_r_MoreToBatt_SOC[0])), 7U);
        }
        else
        {
            /* Merge: '<S1175>/Merge' incorporates:
             *  Constant: '<S1200>/Calib'
             */
            VeTHMR_r_BattCabRatioAftrMrg = KeTHMR_r_MoreToBatt;
        }

        /* End of Switch: '<S1185>/Switch' */
        /* End of Outputs for SubSystem: '<S1175>/MoreToBattery' */
    }
    else if (VeTHMR_b_FullToCabin)
    {
        /* Outputs for IfAction SubSystem: '<S1175>/FullToCabin' incorporates:
         *  ActionPort: '<S1182>/ActionPort'
         */
        /* Merge: '<S1175>/Merge' incorporates:
         *  Constant: '<S1197>/Calib'
         *  SignalConversion generated from: '<S1182>/FullToCabin'
         */
        VeTHMR_r_BattCabRatioAftrMrg = KeTHMR_r_FullToCab;

        /* End of Outputs for SubSystem: '<S1175>/FullToCabin' */
    }
    else if (VeTHMR_b_MoreToCabin)
    {
        /* Outputs for IfAction SubSystem: '<S1175>/MoreToCabin' incorporates:
         *  ActionPort: '<S1186>/ActionPort'
         */
        /* Switch: '<S1186>/Switch' incorporates:
         *  Constant: '<S1202>/Calib'
         */
        if (KeTHMR_b_SelSOCCal_MoreToCab)
        {
            /* Merge: '<S1175>/Merge' incorporates:
             *  Lookup_n-D: '<S1204>/Vector'
             *  Switch: '<S244>/Switch'
             */
            VeTHMR_r_BattCabRatioAftrMrg = look1_iflf_binlcapw
                (VeTHMR_Pct_HV_BatSOC, ((const float32 *)
                  &(KxTHMR_r_MoreToCab_SOC[0])), ((const float32 *)
                  &(KtTHMR_r_MoreToCab_SOC[0])), 7U);
        }
        else
        {
            /* Merge: '<S1175>/Merge' incorporates:
             *  Constant: '<S1203>/Calib'
             */
            VeTHMR_r_BattCabRatioAftrMrg = KeTHMR_r_MoreToCab;
        }

        /* End of Switch: '<S1186>/Switch' */
        /* End of Outputs for SubSystem: '<S1175>/MoreToCabin' */
    }
    else if (VeTHMR_b_BattOpt_MoreTocab)
    {
        /* Outputs for IfAction SubSystem: '<S1175>/BattOptimal' incorporates:
         *  ActionPort: '<S1177>/ActionPort'
         */
        /* Switch: '<S1177>/Switch' incorporates:
         *  Constant: '<S1190>/Calib'
         */
        if (KeTHMR_b_SelSOCCal_MoreToCab_Opt)
        {
            /* Merge: '<S1175>/Merge' incorporates:
             *  Lookup_n-D: '<S1192>/Vector'
             *  Switch: '<S244>/Switch'
             */
            VeTHMR_r_BattCabRatioAftrMrg = look1_iflf_binlcapw
                (VeTHMR_Pct_HV_BatSOC, ((const float32 *)
                  &(KxTHMR_r_MoreToCab_SOC_Opt[0])), ((const float32 *)
                  &(KtTHMR_r_MoreToCab_SOC_Opt[0])), 7U);
        }
        else
        {
            /* Merge: '<S1175>/Merge' incorporates:
             *  Constant: '<S1191>/Calib'
             */
            VeTHMR_r_BattCabRatioAftrMrg = KeTHMR_r_MoreToCab_Opt;
        }

        /* End of Switch: '<S1177>/Switch' */
        /* End of Outputs for SubSystem: '<S1175>/BattOptimal' */
    }
    else if (VeTHMR_b_NoPriority)
    {
        /* Outputs for IfAction SubSystem: '<S1175>/NoPriority' incorporates:
         *  ActionPort: '<S1187>/ActionPort'
         */
        /* Merge: '<S1175>/Merge' incorporates:
         *  Constant: '<S1205>/Calib'
         *  SignalConversion generated from: '<S1187>/NoPriority'
         */
        VeTHMR_r_BattCabRatioAftrMrg = KeTHMR_r_NoPriority;

        /* End of Outputs for SubSystem: '<S1175>/NoPriority' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1175>/DfltPriority' incorporates:
         *  ActionPort: '<S1179>/ActionPort'
         */
        /* Merge: '<S1175>/Merge' incorporates:
         *  Constant: '<S1195>/Calib'
         *  SignalConversion generated from: '<S1179>/DfltPriority'
         */
        VeTHMR_r_BattCabRatioAftrMrg = KeTHMR_r_Dflt_Priority;

        /* End of Outputs for SubSystem: '<S1175>/DfltPriority' */
    }

    /* Merge: '<S1214>/Merge2' */
    rtb_Merge2_l = VeTHMR_r_BattCabRatioAftrMrg;

#else

    /* Merge: '<S1214>/Merge2' incorporates:
     *  Constant: '<S1206>/Calib'
     *  SignalConversion generated from: '<S1148>/VariantSource'
     */
    rtb_Merge2_l = KeTHMR_r_Dflt_NoPrioritySelected;

#endif

    /* End of If: '<S1175>/If' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeCTRR_b_MinFlowCabHeatReq' */
    (void)Rte_Read_VeCTRR_b_MinFlowCabHeatReq_Value(&rtb_UnitDelay3_ff);

    /* Inport: '<Root>/VeTRIR_b_AirHtrPwrTgt_FA' */
    (void)Rte_Read_VeTRIR_b_AirHtrPwrTgt_FA_Value(&rtb_NotEqual_fo);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* SignalConversion generated from: '<S1148>/VariantSource' */
    VeTHMR_r_BattCabPriorityRatio_Fin = rtb_Merge2_l;

    /* RelationalOperator: '<S1559>/Comparison5' incorporates:
     *  Logic: '<S1209>/Logical'
     */
    rtb_VariantMerge_For_Variant_da = (((THMR_ac_B.Logical2) &&
        (THMR_ac_B.Switch1_h)) && (THMR_ac_B.VariantMerge_Fo_at));

    /* Switch: '<S1835>/Switch1' incorporates:
     *  Constant: '<S1843>/Calib'
     */
    if (KeTHMR_b_HTCL_Heat_Distrib_SelD)
    {
        /* DataTypeConversion: '<S1842>/DataTypeConversion' incorporates:
         *  Constant: '<S1844>/Calib'
         */
        THMR_ac_B.DataTypeConversion_i = KeTHMR_e_HTCL_Heat_Distrib_Dial;
    }
    else
    {
        /* DataTypeConversion: '<S1842>/DataTypeConversion' incorporates:
         *  UnitDelay: '<S1158>/UnitDelay'
         */
        THMR_ac_B.DataTypeConversion_i = THMR_ac_DW.UnitDelay_DSTATE_c1;
    }

    /* End of Switch: '<S1835>/Switch1' */

    /* Logic: '<S1212>/Logical7' incorporates:
     *  Constant: '<S1341>/Calib'
     *  Logic: '<S1212>/Logical8'
     */
    VeTHMR_b_EnblPctPwrBasdCntrl = ((KeTHMR_b_PctPwrBasdCntrl) &&
        (!rtb_NotEqual_fo));

    /* SignalConversion generated from: '<S1218>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

    /* Logic: '<S1162>/LogicalOperator1' incorporates:
     *  Constant: '<S1218>/Constant'
     */
    rtb_LogicalOperator1_fo = true;

#endif

    /* End of SignalConversion generated from: '<S1218>/VariantSource' */

    /* SignalConversion generated from: '<S57>/FCCoolOutTgt' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* VariantMerge generated from: '<S57>/FCCoolOutTgt' */
    rtb_VM_Conditional_Signal_FCCoo = THMR_ac_B.Switch10;

#else

    /* VariantMerge generated from: '<S57>/FCCoolOutTgt' incorporates:
     *  SignalConversion generated from: '<S57>/FCCoolOutTgt'
     */
    rtb_VM_Conditional_Signal_FCCoo = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S57>/FCCoolOutTgt' */

    /* Outputs for Atomic SubSystem: '<S1215>/Hysteresis1' */
    /* Switch: '<S1329>/Switch1' incorporates:
     *  Constant: '<S1330>/Calib'
     *  Constant: '<S2>/Const'
     *  RelationalOperator: '<S1329>/GreaterThan'
     *  Sum: '<S1215>/Add'
     */
    if (-40.0F > (rtb_VM_Conditional_Signal_FCCoo +
                  KeTHMR_dT_FCStblz_HtrAllwdDsbl))
    {
        /* Switch: '<S1329>/Switch1' incorporates:
         *  Constant: '<S1329>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeBT_m = true;
    }
    else
    {
        /* Switch: '<S1329>/Switch1' incorporates:
         *  Constant: '<S1331>/Calib'
         *  RelationalOperator: '<S1329>/GreaterThan1'
         *  Sum: '<S1215>/Add1'
         *  UnitDelay: '<S1329>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeBT_m = ((-40.0F >=
            (KeTHMR_dT_FCStblz_HtrAllwdEnbl + rtb_VM_Conditional_Signal_FCCoo)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_hml));
    }

    /* End of Switch: '<S1329>/Switch1' */

    /* Update for UnitDelay: '<S1329>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_hml = rtb_TmpSignalConversionAtVeBT_m;

    /* End of Outputs for SubSystem: '<S1215>/Hysteresis1' */

    /* Logic: '<S1215>/LogicalOperator1' incorporates:
     *  Constant: '<S1328>/Constant'
     *  Logic: '<S1215>/LogicalOperator2'
     *  RelationalOperator: '<S1215>/RelationalOperator1'
     */
    rtb_TmpSignalConversionAtVeBT_m = ((!rtb_TmpSignalConversionAtVeBT_m) &&
        (CeTHMR_e_FCStabilize == ((uint32)rtb_Logical17_o_tmp)));

    /* Outputs for Atomic SubSystem: '<S1326>/EdgeBi' */
    /* RelationalOperator: '<S1332>/Not Equal' incorporates:
     *  UnitDelay: '<S1332>/Unit Delay'
     */
    rtb_NotEqual_fo = (rtb_TmpSignalConversionAtVeBT_m !=
                       THMR_ac_DW.UnitDelay_DSTATE_b0);

    /* Update for UnitDelay: '<S1332>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_b0 = rtb_TmpSignalConversionAtVeBT_m;

    /* End of Outputs for SubSystem: '<S1326>/EdgeBi' */

    /* Outputs for Atomic SubSystem: '<S1326>/Turn On Delay Sample Resetable Delay' */
    /* Outputs for Atomic SubSystem: '<S1335>/EdgeRising with resetable delay' */
    /* Logic: '<S1336>/AND' incorporates:
     *  Logic: '<S1336>/OR1'
     *  UnitDelay: '<S1336>/Unit Delay'
     */
    rtb_OR1_bn = (rtb_TmpSignalConversionAtVeBT_m &&
                  (!THMR_ac_DW.UnitDelay_DSTATE_jk));

    /* Switch: '<S1338>/Switch1' */
    if (rtb_NotEqual_fo)
    {
        /* Update for UnitDelay: '<S1336>/Unit Delay' incorporates:
         *  Constant: '<S1336>/Constant1'
         *  Switch: '<S1338>/Switch1'
         */
        THMR_ac_DW.UnitDelay_DSTATE_jk = false;
    }
    else
    {
        /* Update for UnitDelay: '<S1336>/Unit Delay' incorporates:
         *  Switch: '<S1338>/Switch1'
         *  UnitDelay: '<S1338>/Unit Delay'
         */
        THMR_ac_DW.UnitDelay_DSTATE_jk = THMR_ac_DW.UnitDelay_DSTATE_mv;
    }

    /* End of Switch: '<S1338>/Switch1' */

    /* Update for UnitDelay: '<S1338>/Unit Delay' incorporates:
     *  Switch: '<S1338>/Switch3'
     */
    THMR_ac_DW.UnitDelay_DSTATE_mv = ((!rtb_NotEqual_fo) &&
        rtb_TmpSignalConversionAtVeBT_m);

    /* End of Outputs for SubSystem: '<S1335>/EdgeRising with resetable delay' */

    /* Switch: '<S1335>/Switch1' incorporates:
     *  Logic: '<S1335>/OR'
     *  Logic: '<S1335>/OR1'
     *  Switch: '<S1337>/Switch1'
     */
    if ((!rtb_TmpSignalConversionAtVeBT_m) || rtb_OR1_bn)
    {
        /* Switch: '<S1335>/Switch1' incorporates:
         *  Constant: '<S1335>/Constant Value1'
         */
        rtb_Switch_i3 = 0U;
    }
    else
    {
        if (rtb_NotEqual_fo)
        {
            /* Switch: '<S1337>/Switch1' incorporates:
             *  Constant: '<S1335>/Constant Value'
             *  Constant: '<S1335>/Constant1'
             *  Sum: '<S1335>/Summation'
             */
            rtb_Switch_i3 = 1U;
        }
        else
        {
            /* Sum: '<S1335>/Summation' incorporates:
             *  Constant: '<S1335>/Constant Value'
             *  Switch: '<S1337>/Switch1'
             *  UnitDelay: '<S1337>/Unit Delay'
             */
            rtb_Switch_i3 = (uint16)(((uint32)THMR_ac_DW.UnitDelay_DSTATE_m1) +
                1U);
        }

        /* MinMax: '<S1335>/Minimum' incorporates:
         *  Constant: '<S1333>/Calib'
         */
        if (KeTHMR_Cnt_FCHeatStblzDbnc < rtb_Switch_i3)
        {
            /* Switch: '<S1335>/Switch1' */
            rtb_Switch_i3 = KeTHMR_Cnt_FCHeatStblzDbnc;
        }

        /* End of MinMax: '<S1335>/Minimum' */
    }

    /* End of Switch: '<S1335>/Switch1' */

    /* Switch: '<S1337>/Switch3' */
    if (rtb_NotEqual_fo)
    {
        /* Update for UnitDelay: '<S1337>/Unit Delay' incorporates:
         *  Constant: '<S1335>/Constant1'
         */
        THMR_ac_DW.UnitDelay_DSTATE_m1 = 0U;
    }
    else
    {
        /* Update for UnitDelay: '<S1337>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_m1 = rtb_Switch_i3;
    }

    /* End of Switch: '<S1337>/Switch3' */

    /* Logic: '<S1215>/LogicalOperator' incorporates:
     *  Constant: '<S1327>/Constant'
     *  Constant: '<S1333>/Calib'
     *  Constant: '<S1334>/Calib'
     *  Logic: '<S1326>/LogicalOperator1'
     *  Logic: '<S1335>/AND'
     *  RelationalOperator: '<S1215>/RelationalOperator0'
     *  RelationalOperator: '<S1335>/Greater  Than'
     */
    THMR_ac_B.VeTHMR_b_FCHeatAllwd = (((KeTHMR_b_FCStblz_HtrAllwd) &&
        (rtb_TmpSignalConversionAtVeBT_m && (rtb_Switch_i3 >=
        KeTHMR_Cnt_FCHeatStblzDbnc))) || (((uint32)rtb_Logical17_o_tmp) ==
        CeTHMR_e_FCActvPsvHeat));

    /* End of Outputs for SubSystem: '<S1326>/Turn On Delay Sample Resetable Delay' */

    /* Logic: '<S1218>/Logical2' */
#if !Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

    /* Logic: '<S1162>/LogicalOperator1' */
    rtb_LogicalOperator1_fo = !THMR_ac_B.VeTHMR_b_FCHeatAllwd;

#endif

    /* End of Logic: '<S1218>/Logical2' */

    /* Logic: '<S1218>/Logical10' incorporates:
     *  Constant: '<S1341>/Calib'
     *  Logic: '<S1212>/Logical12'
     */
    rtb_TmpSignalConversionAtVeBT_m = !KeTHMR_b_PctPwrBasdCntrl;

    /* Logic: '<S1218>/Logical1' incorporates:
     *  Logic: '<S1210>/Logical2'
     */
    rtb_AND_fe = !THMR_ac_B.VariantMerge_Fo_at;

    /* Logic: '<S1218>/Logical' incorporates:
     *  Logic: '<S1218>/Logical1'
     *  Logic: '<S1218>/Logical10'
     *  Logic: '<S1218>/Logical9'
     */
    VeTHMR_b_EnblMinPwrFlow = (((rtb_TmpSignalConversionAtVeBT_m &&
        rtb_UnitDelay3_ff) && ((!rtb_VariantMerge_For_Variant_da) || rtb_AND_fe))
        && rtb_LogicalOperator1_fo);

    /* Logic: '<S1214>/Logical1' incorporates:
     *  Logic: '<S1161>/Logical4'
     *  Logic: '<S1351>/Logical1'
     *  Logic: '<S1879>/Logical4'
     *  Switch: '<S1879>/Switch2'
     */
    rtb_TmpSignalConversionAtVeT_d5 = !THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0;

    /* Logic: '<S1213>/Logical17' incorporates:
     *  Logic: '<S1158>/Logical15'
     *  Logic: '<S1158>/Logical17'
     *  Truth Table: '<S1158>/TruthTable1'
     */
    rtb_TmpSignalConversionAtVeT_ib = !THMR_ac_B.VeTHMR_b_CabReq_NotAllow_BS;

    /* Logic: '<S1213>/Logical16' incorporates:
     *  Logic: '<S1162>/LogicalOperator1'
     *  Logic: '<S1213>/Logical17'
     */
    Switch5_i = ((THMR_ac_B.Switch1_az) && rtb_TmpSignalConversionAtVeT_ib);

    /* Logic: '<S1162>/LogicalOperator1' incorporates:
     *  Logic: '<S1213>/Logical16'
     *  Logic: '<S1214>/Logical1'
     *  Logic: '<S1214>/Logical2'
     */
    rtb_LogicalOperator1_fo = ((Switch5_i && (VeTHMR_b_CabActvHeat)) &&
        rtb_TmpSignalConversionAtVeT_d5);

    /* Switch: '<S1800>/Switch1' incorporates:
     *  Constant: '<S1795>/Constant'
     *  Constant: '<S1796>/Constant'
     *  Constant: '<S1797>/Constant1'
     *  Constant: '<S1797>/Constant2'
     *  Constant: '<S1798>/Constant1'
     *  Constant: '<S1798>/Constant2'
     *  Constant: '<S1799>/Constant1'
     *  Constant: '<S1799>/Constant2'
     *  Constant: '<S1801>/Calib'
     *  Constant: '<S1802>/Calib'
     *  Constant: '<S1803>/Calib'
     *  Constant: '<S1804>/Calib'
     *  Constant: '<S1805>/Calib'
     *  DataStoreRead: '<S1797>/StatusByte_CT3_SnsrCktHi'
     *  DataStoreRead: '<S1798>/StatusByte_CT3_SnsrCktLo'
     *  DataStoreRead: '<S1799>/StatusByte_CT3_SnsrPerf'
     *  Logic: '<S1156>/Logical1'
     *  Logic: '<S1156>/Logical16'
     *  Logic: '<S1156>/Logical2'
     *  Logic: '<S1156>/Logical3'
     *  Logic: '<S1156>/LogicalOperator2'
     *  Logic: '<S1156>/LogicalOperator3'
     *  Logic: '<S1797>/Logical Operator'
     *  Logic: '<S1798>/Logical Operator'
     *  Logic: '<S1799>/Logical Operator'
     *  RelationalOperator: '<S1156>/Comparison1'
     *  RelationalOperator: '<S1156>/Comparison2'
     *  RelationalOperator: '<S1797>/Relational Operator1'
     *  RelationalOperator: '<S1797>/Relational Operator2'
     *  RelationalOperator: '<S1798>/Relational Operator1'
     *  RelationalOperator: '<S1798>/Relational Operator2'
     *  RelationalOperator: '<S1799>/Relational Operator1'
     *  RelationalOperator: '<S1799>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S1797>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1797>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1798>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1798>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1799>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1799>/Bitwise Operator2'
     */
    if ((((((((((uint32)THMR_ac_DW.StatusByte_CT3_SnsrCktLo) & 1U) != 0U) &&
             ((((uint32)THMR_ac_DW.StatusByte_CT3_SnsrCktLo) & 64U) == 0U)) &&
            (KeTHMR_b_Enbl_HCCTIS_CrctLow_flt)) || ((((((uint32)
                THMR_ac_DW.StatusByte_CT3_SnsrCktHi) & 1U) != 0U) && ((((uint32)
                THMR_ac_DW.StatusByte_CT3_SnsrCktHi) & 64U) == 0U)) &&
            (KeTHMR_b_Enbl_HCCTIS_CrctHigh_flt))) || ((((((uint32)
               THMR_ac_DW.StatusByte_CT3_SnsrPerf) & 1U) != 0U) && ((((uint32)
               THMR_ac_DW.StatusByte_CT3_SnsrPerf) & 64U) == 0U)) &&
            (KeTHMR_b_Enbl_HCCTIS_Rtnlty_flt))) ||
            ((KeTHMR_b_HCBVStuckSNA_SwtchHCCTISwECHoutTemp) && (CeRCVR_e_SNA ==
            ((uint32)rtb_TmpSignalConversionAtVeRC_c)))) || ((((uint32)
            rtb_TmpSignalConversionAtVeRC_c) == CeRCVR_e_Faulty_Open) &&
            (KeTHMR_b_HCBVStuckOpen_SwtchHCCTISwECHoutTemp)))
    {
        /* Switch: '<S1800>/Switch1' */
        VeTHMR_T_HCCTISArb = rtb_TmpSignalConversionAtVeHT_h;
    }
    else
    {
        /* Switch: '<S1800>/Switch1' incorporates:
         *  Inport: '<S57>/CTRR_T_HtrCorClnt_Tmp_In'
         */
        VeTHMR_T_HCCTISArb = VeTHMR_T_HtrCorClnt_Tmp_In_AD;
    }

    /* End of Switch: '<S1800>/Switch1' */

    /* If: '<S1214>/If1' */
    if (rtb_LogicalOperator1_fo)
    {
        /* Outputs for IfAction SubSystem: '<S1214>/HtrCor_Err' incorporates:
         *  ActionPort: '<S1317>/ActionPort'
         */
        THMR_ac_HtrCor_Err(rtb_TmpSignalConversionAtVeCTRR, VeTHMR_T_HCCTISArb,
                           &rtb_Merge2_l);

        /* End of Outputs for SubSystem: '<S1214>/HtrCor_Err' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1214>/NoHeat_HtrCore' incorporates:
         *  ActionPort: '<S1320>/ActionPort'
         */
        THMR_ac_NoHeat_HtrCore(&rtb_Merge2_l);

        /* End of Outputs for SubSystem: '<S1214>/NoHeat_HtrCore' */
    }

    /* End of If: '<S1214>/If1' */

    /* If: '<S1214>/If3' */
    if (rtb_VariantMerge_For_Variant_da)
    {
        /* Outputs for IfAction SubSystem: '<S1214>/Batt_ClntErr' incorporates:
         *  ActionPort: '<S1315>/ActionPort'
         */
        /* Switch: '<S1315>/Switch2' incorporates:
         *  Constant: '<S1322>/Calib'
         */
        if (KeTHMR_b_ShrdHtrHEXEnbl)
        {
            /* Switch: '<S1427>/Switch2' incorporates:
             *  Constant: '<S1321>/Calib'
             *  Sum: '<S1315>/Subtraction2'
             *  Sum: '<S1315>/Subtraction3'
             */
            rtb_MinMax1_c = (KeTHMR_T_ILHEX_DeltaTemp + THMR_ac_B.Vector_h) -
                VeTHMR_T_HCCTISArb;
        }
        else
        {
            /* Switch: '<S1427>/Switch2' incorporates:
             *  Sum: '<S1315>/Subtraction1'
             */
            rtb_MinMax1_c = THMR_ac_B.Vector_h - rtb_TmpSignalConversionAtVeBT_k;
        }

        /* End of Switch: '<S1315>/Switch2' */
        /* End of Outputs for SubSystem: '<S1214>/Batt_ClntErr' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1214>/NoHeat_Batt' incorporates:
         *  ActionPort: '<S1318>/ActionPort'
         */
        THMR_ac_NoHeat_HtrCore(&rtb_MinMax1_c);

        /* End of Outputs for SubSystem: '<S1214>/NoHeat_Batt' */
    }

    /* End of If: '<S1214>/If3' */

    /* SignalConversion generated from: '<S1214>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

    /* Logic: '<S1497>/LogicalOperator' incorporates:
     *  Constant: '<S1214>/Constant'
     */
    rtb_LogicalOperator_lw = false;

#else

    /* Logic: '<S1497>/LogicalOperator' incorporates:
     *  SignalConversion generated from: '<S1214>/VariantSource'
     */
    rtb_LogicalOperator_lw = THMR_ac_B.VeTHMR_b_FCHeatAllwd;

#endif

    /* End of SignalConversion generated from: '<S1214>/VariantSource' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* S-Function (sfix_bitop): '<S1807>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S1807>/StatusByte_ECT_Snsr4CktLo'
     *  S-Function (sfix_bitop): '<S4406>/Bitwise Operator2'
     */
    tmp_e = ((uint32)THMR_ac_DW.StatusByte_ECT_Snsr4CktLo) & 1U;

    /* S-Function (sfix_bitop): '<S1807>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S1807>/StatusByte_ECT_Snsr4CktLo'
     *  S-Function (sfix_bitop): '<S4406>/Bitwise Operator1'
     */
    tmp_f = ((uint32)THMR_ac_DW.StatusByte_ECT_Snsr4CktLo) & 64U;

    /* S-Function (sfix_bitop): '<S1806>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S1806>/StatusByte_ECT_Snsr4CktHi'
     *  S-Function (sfix_bitop): '<S4405>/Bitwise Operator2'
     */
    tmp_g = ((uint32)THMR_ac_DW.StatusByte_ECT_Snsr4CktHi) & 1U;

    /* S-Function (sfix_bitop): '<S1806>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S1806>/StatusByte_ECT_Snsr4CktHi'
     *  S-Function (sfix_bitop): '<S4405>/Bitwise Operator1'
     */
    tmp_h = ((uint32)THMR_ac_DW.StatusByte_ECT_Snsr4CktHi) & 64U;

    /* S-Function (sfix_bitop): '<S1808>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S1808>/StatusByte_ECT_Snsr4CktPerf'
     *  S-Function (sfix_bitop): '<S4407>/Bitwise Operator2'
     */
    tmp_i = ((uint32)THMR_ac_DW.StatusByte_ECT_Snsr4CktPerf) & 1U;

    /* S-Function (sfix_bitop): '<S1808>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S1808>/StatusByte_ECT_Snsr4CktPerf'
     *  S-Function (sfix_bitop): '<S4407>/Bitwise Operator1'
     */
    tmp_j = ((uint32)THMR_ac_DW.StatusByte_ECT_Snsr4CktPerf) & 64U;

    /* Switch: '<S1809>/Switch1' incorporates:
     *  Constant: '<S1806>/Constant1'
     *  Constant: '<S1806>/Constant2'
     *  Constant: '<S1807>/Constant1'
     *  Constant: '<S1807>/Constant2'
     *  Constant: '<S1808>/Constant1'
     *  Constant: '<S1808>/Constant2'
     *  Constant: '<S1810>/Calib'
     *  Constant: '<S1811>/Calib'
     *  Constant: '<S1812>/Calib'
     *  Logic: '<S1157>/Logical1'
     *  Logic: '<S1157>/Logical16'
     *  Logic: '<S1157>/Logical2'
     *  Logic: '<S1157>/Logical3'
     *  Logic: '<S1806>/Logical Operator'
     *  Logic: '<S1807>/Logical Operator'
     *  Logic: '<S1808>/Logical Operator'
     *  RelationalOperator: '<S1806>/Relational Operator1'
     *  RelationalOperator: '<S1806>/Relational Operator2'
     *  RelationalOperator: '<S1807>/Relational Operator1'
     *  RelationalOperator: '<S1807>/Relational Operator2'
     *  RelationalOperator: '<S1808>/Relational Operator1'
     *  RelationalOperator: '<S1808>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S1806>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1806>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1807>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1807>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1808>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1808>/Bitwise Operator2'
     */
    if (((((tmp_e != 0U) && (tmp_f == 0U)) && (KeTHMR_b_Enbl_HCCTOS_CrctLow_flt))
         || (((tmp_g != 0U) && (tmp_h == 0U)) &&
             (KeTHMR_b_Enbl_HCCTOS_CrctHigh_flt))) || (((tmp_i != 0U) && (tmp_j ==
           0U)) && (KeTHMR_b_Enbl_HCCTOS_Rtnlty_flt)))
    {
        /* Switch: '<S1809>/Switch1' */
        VeTHMR_T_HCCTOSArb = rtb_TmpSignalConversionAtVeHT_o;
    }
    else
    {
        /* Switch: '<S1809>/Switch1' */
        VeTHMR_T_HCCTOSArb = rtb_TmpSignalConversionAtVeTR_h;
    }

    /* End of Switch: '<S1809>/Switch1' */

    /* If: '<S1214>/If4' */
    if (rtb_LogicalOperator_lw)
    {
        /* Outputs for IfAction SubSystem: '<S1214>/FC_Err' incorporates:
         *  ActionPort: '<S1316>/ActionPort'
         */
        THMR_ac_FC_Err(rtb_VM_Conditional_Signal_FCCoo, VeTHMR_T_HCCTOSArb,
                       &rtb_TmpSignalConversionAtVeHT_k);

        /* End of Outputs for SubSystem: '<S1214>/FC_Err' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1214>/NoHeat_FC' incorporates:
         *  ActionPort: '<S1319>/ActionPort'
         */
        THMR_ac_NoHeat_HtrCore(&rtb_TmpSignalConversionAtVeHT_k);

        /* End of Outputs for SubSystem: '<S1214>/NoHeat_FC' */
    }

    /* End of If: '<S1214>/If4' */

    /* MinMax: '<S1214>/MinMax' */
    VeTHMR_dT_ECHClntCntrlTempTerr = fmaxf(fmaxf(rtb_Merge2_l, rtb_MinMax1_c),
        rtb_TmpSignalConversionAtVeHT_k);

    /* Logic: '<S1212>/Logical11' incorporates:
     *  Constant: '<S1212>/ConstantValue2'
     *  Logic: '<S1212>/Logical13'
     *  Logic: '<S1212>/Logical3'
     *  RelationalOperator: '<S1212>/Comparison1'
     */
    VeTHMR_b_EnblNormPwrFlow = (((!VeTHMR_b_EnblMinPwrFlow) ||
        (VeTHMR_dT_ECHClntCntrlTempTerr >= 0.0F)) &&
        rtb_TmpSignalConversionAtVeBT_m);

    /* Logic: '<S1214>/LogicalOperator1' */
    VeTHMR_b_ECHHeatReq = ((rtb_LogicalOperator1_fo ||
                            rtb_VariantMerge_For_Variant_da) ||
                           rtb_LogicalOperator_lw);

    /* RelationalOperator: '<S1216>/RelationalOperator0' incorporates:
     *  Constant: '<S1339>/Constant'
     */
    rtb_LogicalOperator1_fo = (((uint32)VeTHMR_b_CompressorReqOn_0_tmp) ==
        CeTHMR_e_HeatPump);

    /* RelationalOperator: '<S1217>/RelationalOperator1' incorporates:
     *  Constant: '<S1340>/Constant'
     *  Switch: '<S3942>/Switch1'
     */
    rtb_LogicalOperator_lw = (((uint32)VeTHMR_e_HVACECOModeSts) ==
        CeTRIR_e_HVAC_ECO_ON);

    /* If: '<S1212>/If' incorporates:
     *  Inport: '<Root>/VeTRIR_Pct_AirHtrPwrTgt'
     *  Logic: '<S1212>/Logical1'
     */
    if (VeTHMR_b_EnblPctPwrBasdCntrl)
    {
        (void)Rte_Read_VeTRIR_Pct_AirHtrPwrTgt_Value(&rtb_Switch2_i1);
        THMR_ac_DW.If_ActiveSubsystem = 0;

        /* Outputs for IfAction SubSystem: '<S1212>/CalcPctBasedPwr' incorporates:
         *  ActionPort: '<S1242>/ActionPort'
         */
        /* Merge: '<S1212>/Merge' incorporates:
         *  Gain: '<S1262>/Gain'
         *  Inport: '<Root>/VeTRIR_Pct_AirHtrPwrTgt'
         *  Lookup_n-D: '<S1261>/Vector'
         */
        VeTHMR_P_CabPwrNeed_Raw_0 = look1_iflf_binlcapw(rtb_Switch2_i1, ((const
            float32 *)&(KxTHMR_P_CabAirHtrPwrTgt[0])), ((const float32 *)
            &(KtTHMR_P_CabAirHtrPwrTgt[0])), 8U);

        /* End of Outputs for SubSystem: '<S1212>/CalcPctBasedPwr' */
    }
    else if (VeTHMR_b_EnblMinPwrFlow)
    {
        THMR_ac_DW.If_ActiveSubsystem = 1;

        /* Outputs for IfAction SubSystem: '<S1212>/CalcMinFlow' incorporates:
         *  ActionPort: '<S1241>/ActionPort'
         */
        /* Outputs for Atomic SubSystem: '<S1241>/EdgeBi1' */
        /* RelationalOperator: '<S1245>/NotEqual' incorporates:
         *  UnitDelay: '<S1245>/UnitDelay'
         */
        rtb_UnitDelay3_ff = (VeTHMR_b_ECHHeatReq !=
                             THMR_ac_DW.UnitDelay_DSTATE_d4u);

        /* Update for UnitDelay: '<S1245>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_d4u = VeTHMR_b_ECHHeatReq;

        /* End of Outputs for SubSystem: '<S1241>/EdgeBi1' */

        /* Outputs for Atomic SubSystem: '<S1241>/EdgeRising1' */
        /* Logic: '<S1246>/AND' incorporates:
         *  Logic: '<S1246>/OR1'
         *  UnitDelay: '<S1246>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeBT_m = !THMR_ac_DW.UnitDelay_DSTATE_h1c;

        /* Update for UnitDelay: '<S1246>/UnitDelay' incorporates:
         *  Constant: '<S1241>/TRUEConstant'
         */
        THMR_ac_DW.UnitDelay_DSTATE_h1c = true;

        /* End of Outputs for SubSystem: '<S1241>/EdgeRising1' */

        /* Lookup_n-D: '<S1255>/Vector' incorporates:
         *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
         *  SignalConversion generated from: '<S2>/VeTAIR_Pct_FrtBlwrCmd'
         */
        rtb_TmpSignalConversionAtVeTA_b = look2_iflf_binlcapw
            (rtb_TmpSignalConversionAtVeTA_b, TmpSignalConversionAtOutAirTemp,
             ((const float32 *)&(KxTHMR_P_Min_HCCTIS_MaxPwr[0])), ((const
               float32 *)&(KyTHMR_P_Min_HCCTIS_MaxPwr[0])), ((const float32 *)
              &(KtTHMR_P_Min_HCCTIS_MaxPwr[0])), THMR_ac_ConstP.pooled44, 6U);

        /* Outputs for Atomic SubSystem: '<S1241>/PIControl1' */
        /* Switch: '<S1257>/Switch2' incorporates:
         *  Constant: '<S1257>/ConstantValue'
         *  Logic: '<S1241>/Logical1'
         *  Logic: '<S1257>/Logical'
         *  Logic: '<S1257>/Logical2'
         *  Logic: '<S1257>/Logical3'
         *  RelationalOperator: '<S1257>/Comparison1'
         *  RelationalOperator: '<S1257>/Comparison2'
         *  Switch: '<S1257>/Switch4'
         *  UnitDelay: '<S1257>/UnitDelay2'
         *  UnitDelay: '<S1257>/UnitDelay4'
         */
        if (rtb_TmpSignalConversionAtVeBT_m || rtb_UnitDelay3_ff)
        {
            /* Switch: '<S1257>/Switch2' incorporates:
             *  Constant: '<S1250>/Calib'
             */
            rtb_Merge2_l = KeTHMR_P_MinFlw_HCCTISErr_IV;
        }
        else if (((THMR_ac_DW.UnitDelay2_DSTATE_hu <= 0.0F) ||
                  (THMR_ac_DW.UnitDelay4_DSTATE_f <
                   rtb_TmpSignalConversionAtVeTA_b)) && (VeTHMR_b_ECHHeatReq))
        {
            /* Switch: '<S1257>/Switch4' incorporates:
             *  Constant: '<S1241>/Constant'
             *  Lookup_n-D: '<S1252>/Vector'
             *  MinMax: '<S1214>/MinMax'
             *  Product: '<S1257>/Multiplication2'
             *  Product: '<S1257>/Multiplication3'
             *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
             *  Sum: '<S1257>/Sum//Sub2'
             *  Switch: '<S1257>/Switch2'
             *  UnitDelay: '<S1257>/UnitDelay2'
             */
            rtb_Merge2_l = ((VeTHMR_dT_ECHClntCntrlTempTerr * 0.1F) *
                            look2_iflf_binlcapw(VeTHMR_dT_ECHClntCntrlTempTerr,
                             TmpSignalConversionAtOutAirTemp, ((const float32 *)
                              &(KxTHMR_K_Min_HtrPwr_Ki[0])), ((const float32 *)
                              &(KyTHMR_K_Min_HtrPwr_Ki[0])), ((const float32 *)
                              &(KtTHMR_K_Min_HtrPwr_Ki[0])),
                             THMR_ac_ConstP.pooled44, 6U)) +
                THMR_ac_DW.UnitDelay2_DSTATE_hu;
        }
        else
        {
            /* Switch: '<S1257>/Switch2' incorporates:
             *  Switch: '<S1257>/Switch4'
             *  UnitDelay: '<S1257>/UnitDelay2'
             */
            rtb_Merge2_l = THMR_ac_DW.UnitDelay2_DSTATE_hu;
        }

        /* End of Switch: '<S1257>/Switch2' */

        /* Outputs for Atomic SubSystem: '<S1257>/integral_term1' */
        /* Switch: '<S1260>/Switch1' incorporates:
         *  RelationalOperator: '<S1260>/RelationalOperator'
         */
        if (rtb_TmpSignalConversionAtVeTA_b >= rtb_Merge2_l)
        {
            /* Switch: '<S1256>/Switch1' */
            rtb_TmpSignalConversionAtVeTA_b = rtb_Merge2_l;
        }

        /* End of Switch: '<S1260>/Switch1' */

        /* Switch: '<S1260>/Switch' incorporates:
         *  Constant: '<S1247>/Calib'
         *  RelationalOperator: '<S1260>/RelationalOperator1'
         */
        if (rtb_TmpSignalConversionAtVeTA_b <= KeTHMR_P_HCCTIS_MinPwr)
        {
            /* Switch: '<S1260>/Switch' */
            rtb_TmpSignalConversionAtVeTA_b = KeTHMR_P_HCCTIS_MinPwr;
        }

        /* End of Switch: '<S1260>/Switch' */
        /* End of Outputs for SubSystem: '<S1257>/integral_term1' */

        /* Sum: '<S1257>/Sum//Sub3' incorporates:
         *  Lookup_n-D: '<S1253>/Vector'
         *  MinMax: '<S1214>/MinMax'
         *  Product: '<S1257>/proportional_term1'
         *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
         */
        rtb_Merge2_l = (VeTHMR_dT_ECHClntCntrlTempTerr * look2_iflf_binlcapw
                        (VeTHMR_dT_ECHClntCntrlTempTerr,
                         TmpSignalConversionAtOutAirTemp, ((const float32 *)
                          &(KxTHMR_K_Min_HtrPwr_Kp[0])), ((const float32 *)
                          &(KyTHMR_K_Min_HtrPwr_Kp[0])), ((const float32 *)
                          &(KtTHMR_K_Min_HtrPwr_Kp[0])), THMR_ac_ConstP.pooled44,
                         6U)) + rtb_TmpSignalConversionAtVeTA_b;

        /* Switch: '<S1257>/Switch3' incorporates:
         *  UnitDelay: '<S1257>/UnitDelay5'
         */
        if (THMR_ac_DW.UnitDelay5_DSTATE_ct)
        {
            /* Switch: '<S1257>/Switch3' */
            VeTHMR_P_MinCabinPwrNeed_BG = rtb_Merge2_l;
        }
        else
        {
            /* Switch: '<S1257>/Switch3' incorporates:
             *  UnitDelay: '<S1257>/UnitDelay3'
             */
            VeTHMR_P_MinCabinPwrNeed_BG = THMR_ac_DW.UnitDelay3_DSTATE_f;
        }

        /* End of Switch: '<S1257>/Switch3' */

        /* Update for UnitDelay: '<S1257>/UnitDelay2' */
        THMR_ac_DW.UnitDelay2_DSTATE_hu = rtb_TmpSignalConversionAtVeTA_b;

        /* Update for UnitDelay: '<S1257>/UnitDelay4' */
        THMR_ac_DW.UnitDelay4_DSTATE_f = rtb_Merge2_l;

        /* Update for UnitDelay: '<S1257>/UnitDelay5' */
        THMR_ac_DW.UnitDelay5_DSTATE_ct = VeTHMR_b_ECHHeatReq;

        /* Update for UnitDelay: '<S1257>/UnitDelay3' */
        THMR_ac_DW.UnitDelay3_DSTATE_f = VeTHMR_P_MinCabinPwrNeed_BG;

        /* End of Outputs for SubSystem: '<S1241>/PIControl1' */

        /* Outputs for Atomic SubSystem: '<S1241>/Limiter' */
        /* Switch: '<S1256>/Switch1' incorporates:
         *  Constant: '<S1248>/Calib'
         *  RelationalOperator: '<S1256>/RelationalOperator'
         */
        if (KeTHMR_P_MinFlw_CabHtrPwr_Max < VeTHMR_P_MinCabinPwrNeed_BG)
        {
            /* Switch: '<S1256>/Switch1' */
            rtb_TmpSignalConversionAtVeTA_b = KeTHMR_P_MinFlw_CabHtrPwr_Max;
        }
        else
        {
            /* Switch: '<S1256>/Switch1' */
            rtb_TmpSignalConversionAtVeTA_b = VeTHMR_P_MinCabinPwrNeed_BG;
        }

        /* End of Switch: '<S1256>/Switch1' */

        /* Switch: '<S1256>/Switch' incorporates:
         *  Constant: '<S1249>/Calib'
         *  RelationalOperator: '<S1256>/RelationalOperator1'
         */
        if (rtb_TmpSignalConversionAtVeTA_b > KeTHMR_P_MinFlw_CabHtrPwr_Min)
        {
            /* Switch: '<S1256>/Switch' */
            VeTHMR_P_MinCabPwrNeed_NormlRaw_PI = rtb_TmpSignalConversionAtVeTA_b;
        }
        else
        {
            /* Switch: '<S1256>/Switch' */
            VeTHMR_P_MinCabPwrNeed_NormlRaw_PI = KeTHMR_P_MinFlw_CabHtrPwr_Min;
        }

        /* End of Switch: '<S1256>/Switch' */
        /* End of Outputs for SubSystem: '<S1241>/Limiter' */

        /* Switch: '<S1241>/Switch1' incorporates:
         *  Constant: '<S1251>/Calib'
         *  Logic: '<S1241>/Logical2'
         */
        if ((rtb_LogicalOperator1_fo || rtb_LogicalOperator_lw) ||
                (KeTHMR_b_CabinPwrNeed_PIEnbl))
        {
            /* Switch: '<S1241>/Switch1' */
            VeTHMR_P_CabinPwrNeed_BlwrFlowMin =
                VeTHMR_P_MinCabPwrNeed_NormlRaw_PI;
        }
        else
        {
            /* Switch: '<S1241>/Switch1' incorporates:
             *  Lookup_n-D: '<S1254>/Vector'
             *  MinMax: '<S1214>/MinMax'
             */
            VeTHMR_P_CabinPwrNeed_BlwrFlowMin = look1_iflf_binlcapw
                (VeTHMR_dT_ECHClntCntrlTempTerr, ((const float32 *)
                  &(KxTHMR_P_CabinPwrNeed_BlwrFlowMin[0])), ((const float32 *)
                  &(KtTHMR_P_CabinPwrNeed_BlwrFlowMin[0])), 8U);
        }

        /* End of Switch: '<S1241>/Switch1' */

        /* Merge: '<S1212>/Merge' incorporates:
         *  Gain: '<S1258>/Gain'
         */
        VeTHMR_P_CabPwrNeed_Raw_0 = VeTHMR_P_CabinPwrNeed_BlwrFlowMin;

        /* End of Outputs for SubSystem: '<S1212>/CalcMinFlow' */
    }
    else if (rtb_VariantMerge_For_Variant_da || (VeTHMR_b_EnblNormPwrFlow))
    {
        THMR_ac_DW.If_ActiveSubsystem = 2;

        /* Outputs for IfAction SubSystem: '<S1212>/CalcRegularFlow' incorporates:
         *  ActionPort: '<S1243>/ActionPort'
         */
        /* UnitDelay: '<S1310>/UnitDelay3' incorporates:
         *  Logic: '<S1271>/Logical7'
         */
        rtb_UnitDelay3_ff = !THMR_ac_B.VeTHMR_b_FCHeatAllwd;

        /* Logic: '<S1271>/Logical2' incorporates:
         *  Constant: '<S1282>/Calib'
         *  Logic: '<S1271>/Logical3'
         *  Logic: '<S1271>/Logical5'
         */
        rtb_NotEqual_fo = ((!rtb_TmpSignalConversionAtVePDTR) ||
                           (KeTHMR_k_OVOverideCabHtrPIGain));

        /* Logic: '<S1271>/Logical1' incorporates:
         *  Constant: '<S1280>/Calib'
         *  Logic: '<S1271>/Logical2'
         */
        rtb_TmpSignalConversionAtVeBT_m = ((((KeTHMR_b_Enbl_HVACECOModeGainSel) &&
            rtb_LogicalOperator_lw) && rtb_NotEqual_fo) && rtb_UnitDelay3_ff);

        /* UnitDelay: '<S1310>/UnitDelay3' incorporates:
         *  Constant: '<S1281>/Calib'
         *  Logic: '<S1271>/Logical4'
         */
        rtb_UnitDelay3_ff = ((((KeTHMR_b_Enbl_HeatPmpModeGainSel) &&
                               rtb_LogicalOperator1_fo) && rtb_NotEqual_fo) &&
                             rtb_UnitDelay3_ff);

        /* Switch: '<S1271>/Switch1' incorporates:
         *  Switch: '<S1271>/Switch2'
         *  Switch: '<S1271>/Switch3'
         *  Switch: '<S1271>/Switch5'
         */
        if (rtb_UnitDelay3_ff)
        {
            /* Switch: '<S1271>/Switch4' incorporates:
             *  Switch: '<S1271>/Switch6'
             */
            if (rtb_TmpSignalConversionAtVeBT_m)
            {
                /* Switch: '<S1271>/Switch1' incorporates:
                 *  Lookup_n-D: '<S1289>/Vector'
                 *  MinMax: '<S1214>/MinMax'
                 *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
                 *  Switch: '<S1271>/Switch4'
                 */
                rtb_Merge2_l = look2_iflf_binlcapw
                    (VeTHMR_dT_ECHClntCntrlTempTerr,
                     TmpSignalConversionAtOutAirTemp, ((const float32 *)
                      &(KxTHMR_K_Reg_HtrPwr_Kp_HPM_ECO[0])), ((const float32 *)
                      &(KyTHMR_K_Reg_HtrPwr_Kp_HPM_ECO[0])), ((const float32 *)
                      &(KtTHMR_K_Reg_HtrPwr_Kp_HPM_ECO[0])),
                     THMR_ac_ConstP.pooled44, 6U);

                /* Switch: '<S1271>/Switch2' incorporates:
                 *  Lookup_n-D: '<S1285>/Vector'
                 *  MinMax: '<S1214>/MinMax'
                 *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
                 *  Switch: '<S1271>/Switch6'
                 */
                rtb_Switch2_i1 = look2_iflf_binlcapw
                    (VeTHMR_dT_ECHClntCntrlTempTerr,
                     TmpSignalConversionAtOutAirTemp, ((const float32 *)
                      &(KxTHMR_K_Reg_HtrPwr_Ki_HPM_ECO[0])), ((const float32 *)
                      &(KyTHMR_K_Reg_HtrPwr_Ki_HPM_ECO[0])), ((const float32 *)
                      &(KtTHMR_K_Reg_HtrPwr_Ki_HPM_ECO[0])),
                     THMR_ac_ConstP.pooled44, 6U);
            }
            else
            {
                /* Switch: '<S1271>/Switch1' incorporates:
                 *  Lookup_n-D: '<S1288>/Vector'
                 *  MinMax: '<S1214>/MinMax'
                 *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
                 *  Switch: '<S1271>/Switch4'
                 */
                rtb_Merge2_l = look2_iflf_binlcapw
                    (VeTHMR_dT_ECHClntCntrlTempTerr,
                     TmpSignalConversionAtOutAirTemp, ((const float32 *)
                      &(KxTHMR_K_Reg_HtrPwr_Kp_HPM[0])), ((const float32 *)
                      &(KyTHMR_K_Reg_HtrPwr_Kp_HPM[0])), ((const float32 *)
                      &(KtTHMR_K_Reg_HtrPwr_Kp_HPM[0])), THMR_ac_ConstP.pooled44,
                     6U);

                /* Switch: '<S1271>/Switch2' incorporates:
                 *  Lookup_n-D: '<S1284>/Vector'
                 *  MinMax: '<S1214>/MinMax'
                 *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
                 *  Switch: '<S1271>/Switch6'
                 */
                rtb_Switch2_i1 = look2_iflf_binlcapw
                    (VeTHMR_dT_ECHClntCntrlTempTerr,
                     TmpSignalConversionAtOutAirTemp, ((const float32 *)
                      &(KxTHMR_K_Reg_HtrPwr_Ki_HPM[0])), ((const float32 *)
                      &(KyTHMR_K_Reg_HtrPwr_Ki_HPM[0])), ((const float32 *)
                      &(KtTHMR_K_Reg_HtrPwr_Ki_HPM[0])), THMR_ac_ConstP.pooled44,
                     6U);
            }

            /* End of Switch: '<S1271>/Switch4' */
        }
        else if (rtb_TmpSignalConversionAtVeBT_m)
        {
            /* Switch: '<S1271>/Switch1' incorporates:
             *  Lookup_n-D: '<S1287>/Vector'
             *  MinMax: '<S1214>/MinMax'
             *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
             *  Switch: '<S1271>/Switch3'
             */
            rtb_Merge2_l = look2_iflf_binlcapw(VeTHMR_dT_ECHClntCntrlTempTerr,
                TmpSignalConversionAtOutAirTemp, ((const float32 *)
                &(KxTHMR_K_Reg_HtrPwr_Kp_ECO[0])), ((const float32 *)
                &(KyTHMR_K_Reg_HtrPwr_Kp_ECO[0])), ((const float32 *)
                &(KtTHMR_K_Reg_HtrPwr_Kp_ECO[0])), THMR_ac_ConstP.pooled44, 6U);

            /* Switch: '<S1271>/Switch2' incorporates:
             *  Lookup_n-D: '<S1283>/Vector'
             *  MinMax: '<S1214>/MinMax'
             *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
             *  Switch: '<S1271>/Switch5'
             */
            rtb_Switch2_i1 = look2_iflf_binlcapw(VeTHMR_dT_ECHClntCntrlTempTerr,
                TmpSignalConversionAtOutAirTemp, ((const float32 *)
                &(KxTHMR_K_Reg_HtrPwr_Ki_ECO[0])), ((const float32 *)
                &(KyTHMR_K_Reg_HtrPwr_Ki_ECO[0])), ((const float32 *)
                &(KtTHMR_K_Reg_HtrPwr_Ki_ECO[0])), THMR_ac_ConstP.pooled44, 6U);
        }
        else
        {
            /* Switch: '<S1271>/Switch1' incorporates:
             *  Lookup_n-D: '<S1290>/Vector'
             *  MinMax: '<S1214>/MinMax'
             *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
             *  Switch: '<S1271>/Switch3'
             */
            rtb_Merge2_l = look2_iflf_binlcapw(VeTHMR_dT_ECHClntCntrlTempTerr,
                TmpSignalConversionAtOutAirTemp, ((const float32 *)
                &(KxTHMR_K_Reg_HtrPwr_Kp_NM[0])), ((const float32 *)
                &(KyTHMR_K_Reg_HtrPwr_Kp_NM[0])), ((const float32 *)
                &(KtTHMR_K_Reg_HtrPwr_Kp_NM[0])), THMR_ac_ConstP.pooled44, 6U);

            /* Switch: '<S1271>/Switch2' incorporates:
             *  Lookup_n-D: '<S1286>/Vector'
             *  MinMax: '<S1214>/MinMax'
             *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
             *  Switch: '<S1271>/Switch5'
             */
            rtb_Switch2_i1 = look2_iflf_binlcapw(VeTHMR_dT_ECHClntCntrlTempTerr,
                TmpSignalConversionAtOutAirTemp, ((const float32 *)
                &(KxTHMR_K_Reg_HtrPwr_Ki_NM[0])), ((const float32 *)
                &(KyTHMR_K_Reg_HtrPwr_Ki_NM[0])), ((const float32 *)
                &(KtTHMR_K_Reg_HtrPwr_Ki_NM[0])), THMR_ac_ConstP.pooled44, 6U);
        }

        /* End of Switch: '<S1271>/Switch1' */

        /* If: '<S1269>/If1' incorporates:
         *  Constant: '<S1269>/Constant1'
         *  Constant: '<S1269>/Constant2'
         *  Constant: '<S1269>/Constant3'
         *  Constant: '<S1269>/Constant5'
         *  Constant: '<S1269>/Constant6'
         *  Constant: '<S1269>/Constant8'
         *  Constant: '<S1273>/Calib'
         *  Logic: '<S1269>/LogicalOperator'
         *  Logic: '<S1269>/LogicalOperator1'
         *  Logic: '<S1269>/LogicalOperator2'
         *  Logic: '<S1269>/LogicalOperator3'
         *  Logic: '<S1269>/LogicalOperator4'
         *  Logic: '<S1269>/LogicalOperator5'
         *  RelationalOperator: '<S1269>/RelationalOperator1'
         *  RelationalOperator: '<S1269>/RelationalOperator2'
         *  RelationalOperator: '<S1269>/RelationalOperator3'
         *  RelationalOperator: '<S1269>/RelationalOperator4'
         *  RelationalOperator: '<S1269>/RelationalOperator7'
         *  RelationalOperator: '<S1269>/RelationalOperator8'
         */
        if ((THMR_ac_B.Switch1_m == 3.0F) && (KeTHMR_b_UseModeECHGains))
        {
            /* Outputs for IfAction SubSystem: '<S1269>/Mode3' incorporates:
             *  ActionPort: '<S1278>/ActionPort'
             */
            /* Merge: '<S1269>/Merge' incorporates:
             *  Constant: '<S1300>/Calib'
             *  SignalConversion generated from: '<S1278>/Kp'
             */
            VeTHMR_K_ECHCntrlKp = KeTHMR_K_Reg_HtrPwr_Kp_M3;

            /* Merge: '<S1269>/Merge1' incorporates:
             *  Constant: '<S1299>/Calib'
             *  SignalConversion generated from: '<S1278>/Ki'
             */
            VeTHMR_K_ECHCntrlKi = KeTHMR_K_Reg_HtrPwr_Ki_M3;

            /* End of Outputs for SubSystem: '<S1269>/Mode3' */
        }
        else if ((THMR_ac_B.Switch1_m == 7.0F) && (KeTHMR_b_UseModeECHGains))
        {
            /* Outputs for IfAction SubSystem: '<S1269>/Mode7' incorporates:
             *  ActionPort: '<S1279>/ActionPort'
             */
            /* Merge: '<S1269>/Merge' incorporates:
             *  Constant: '<S1302>/Calib'
             *  SignalConversion generated from: '<S1279>/Kp'
             */
            VeTHMR_K_ECHCntrlKp = KeTHMR_K_Reg_HtrPwr_Kp_M7;

            /* Merge: '<S1269>/Merge1' incorporates:
             *  Constant: '<S1301>/Calib'
             *  SignalConversion generated from: '<S1279>/Ki'
             */
            VeTHMR_K_ECHCntrlKi = KeTHMR_K_Reg_HtrPwr_Ki_M7;

            /* End of Outputs for SubSystem: '<S1269>/Mode7' */
        }
        else if ((THMR_ac_B.Switch1_m == 10.0F) && (KeTHMR_b_UseModeECHGains))
        {
            /* Outputs for IfAction SubSystem: '<S1269>/Mode10' incorporates:
             *  ActionPort: '<S1274>/ActionPort'
             */
            /* Merge: '<S1269>/Merge' incorporates:
             *  Constant: '<S1292>/Calib'
             *  SignalConversion generated from: '<S1274>/Kp'
             */
            VeTHMR_K_ECHCntrlKp = KeTHMR_K_Reg_HtrPwr_Kp_M10;

            /* Merge: '<S1269>/Merge1' incorporates:
             *  Constant: '<S1291>/Calib'
             *  SignalConversion generated from: '<S1274>/Ki'
             */
            VeTHMR_K_ECHCntrlKi = KeTHMR_K_Reg_HtrPwr_Ki_M10;

            /* End of Outputs for SubSystem: '<S1269>/Mode10' */
        }
        else if ((THMR_ac_B.Switch1_m == 11.0F) && (KeTHMR_b_UseModeECHGains))
        {
            /* Outputs for IfAction SubSystem: '<S1269>/Mode11' incorporates:
             *  ActionPort: '<S1275>/ActionPort'
             */
            /* Merge: '<S1269>/Merge' incorporates:
             *  Constant: '<S1294>/Calib'
             *  SignalConversion generated from: '<S1275>/Kp'
             */
            VeTHMR_K_ECHCntrlKp = KeTHMR_K_Reg_HtrPwr_Kp_M11;

            /* Merge: '<S1269>/Merge1' incorporates:
             *  Constant: '<S1293>/Calib'
             *  SignalConversion generated from: '<S1275>/Ki'
             */
            VeTHMR_K_ECHCntrlKi = KeTHMR_K_Reg_HtrPwr_Ki_M11;

            /* End of Outputs for SubSystem: '<S1269>/Mode11' */
        }
        else if ((THMR_ac_B.Switch1_m == 14.0F) && (KeTHMR_b_UseModeECHGains))
        {
            /* Outputs for IfAction SubSystem: '<S1269>/Mode14' incorporates:
             *  ActionPort: '<S1276>/ActionPort'
             */
            /* Merge: '<S1269>/Merge' incorporates:
             *  Constant: '<S1296>/Calib'
             *  SignalConversion generated from: '<S1276>/Kp'
             */
            VeTHMR_K_ECHCntrlKp = KeTHMR_K_Reg_HtrPwr_Kp_M14;

            /* Merge: '<S1269>/Merge1' incorporates:
             *  Constant: '<S1295>/Calib'
             *  SignalConversion generated from: '<S1276>/Ki'
             */
            VeTHMR_K_ECHCntrlKi = KeTHMR_K_Reg_HtrPwr_Ki_M14;

            /* End of Outputs for SubSystem: '<S1269>/Mode14' */
        }
        else if ((THMR_ac_B.Switch1_m == 15.0F) && (KeTHMR_b_UseModeECHGains))
        {
            /* Outputs for IfAction SubSystem: '<S1269>/Mode15' incorporates:
             *  ActionPort: '<S1277>/ActionPort'
             */
            /* Merge: '<S1269>/Merge' incorporates:
             *  Constant: '<S1298>/Calib'
             *  SignalConversion generated from: '<S1277>/Kp'
             */
            VeTHMR_K_ECHCntrlKp = KeTHMR_K_Reg_HtrPwr_Kp_M15;

            /* Merge: '<S1269>/Merge1' incorporates:
             *  Constant: '<S1297>/Calib'
             *  SignalConversion generated from: '<S1277>/Ki'
             */
            VeTHMR_K_ECHCntrlKi = KeTHMR_K_Reg_HtrPwr_Ki_M15;

            /* End of Outputs for SubSystem: '<S1269>/Mode15' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S1269>/Dflt' incorporates:
             *  ActionPort: '<S1272>/ActionPort'
             */
            /* Merge: '<S1269>/Merge' incorporates:
             *  Inport: '<S1272>/In1'
             */
            VeTHMR_K_ECHCntrlKp = rtb_Merge2_l;

            /* Merge: '<S1269>/Merge1' incorporates:
             *  Inport: '<S1272>/In2'
             */
            VeTHMR_K_ECHCntrlKi = rtb_Switch2_i1;

            /* End of Outputs for SubSystem: '<S1269>/Dflt' */
        }

        /* End of If: '<S1269>/If1' */

        /* Lookup_n-D: '<S1270>/Vector' incorporates:
         *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
         *  SignalConversion generated from: '<S2>/VeTAIR_Pct_FrtBlwrCmd'
         */
        VeTHMR_P_MaxPowerHCCTIS = look2_iflf_binlcapw
            (rtb_TmpSignalConversionAtVeTA_b, TmpSignalConversionAtOutAirTemp,
             ((const float32 *)&(KxTHMR_P_Reg_HCCTIS_MaxPwr[0])), ((const
               float32 *)&(KyTHMR_P_Reg_HCCTIS_MaxPwr[0])), ((const float32 *)
              &(KtTHMR_P_Reg_HCCTIS_MaxPwr[0])), THMR_ac_ConstP.pooled44, 6U);

        /* Lookup_n-D: '<S1265>/Vector' incorporates:
         *  MinMax: '<S1214>/MinMax'
         */
        VeTHMR_P_CabPwrNeed_NormlRaw_0 = look1_iflf_binlcapw
            (VeTHMR_dT_ECHClntCntrlTempTerr, ((const float32 *)
              &(KxTHMR_P_CabinPwrNeed_LookUp[0])), ((const float32 *)
              &(KtTHMR_P_CabinPwrNeed_LookUp[0])), 7U);

        /* Outputs for Atomic SubSystem: '<S1266>/EdgeBi' */
        /* RelationalOperator: '<S1303>/NotEqual' incorporates:
         *  UnitDelay: '<S1303>/UnitDelay'
         */
        rtb_UnitDelay3_ff = (VeTHMR_b_ECHHeatReq !=
                             THMR_ac_DW.UnitDelay_DSTATE_coj);

        /* Update for UnitDelay: '<S1303>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_coj = VeTHMR_b_ECHHeatReq;

        /* End of Outputs for SubSystem: '<S1266>/EdgeBi' */

        /* Outputs for Atomic SubSystem: '<S1266>/EdgeRising' */
        /* Logic: '<S1304>/AND' incorporates:
         *  Logic: '<S1304>/OR1'
         *  UnitDelay: '<S1304>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeBT_m = !THMR_ac_DW.UnitDelay_DSTATE_bic;

        /* Update for UnitDelay: '<S1304>/UnitDelay' incorporates:
         *  Constant: '<S1266>/TRUEConstant'
         */
        THMR_ac_DW.UnitDelay_DSTATE_bic = true;

        /* End of Outputs for SubSystem: '<S1266>/EdgeRising' */

        /* Outputs for Atomic SubSystem: '<S1266>/PIControl' */
        /* Switch: '<S1310>/Switch' incorporates:
         *  Constant: '<S1310>/ConstantValue'
         *  Constant: '<S1311>/Calib'
         *  Constant: '<S1312>/Calib'
         *  Logic: '<S1266>/Logical1'
         *  Logic: '<S1310>/Logical'
         *  Logic: '<S1310>/Logical1'
         *  Logic: '<S1310>/Logical2'
         *  Logic: '<S1310>/Logical3'
         *  Logic: '<S1310>/Logical4'
         *  RelationalOperator: '<S1310>/Comparison1'
         *  RelationalOperator: '<S1310>/Comparison2'
         *  RelationalOperator: '<S1310>/Comparison3'
         *  RelationalOperator: '<S1310>/Comparison4'
         *  Switch: '<S1310>/Switch2'
         *  UnitDelay: '<S1310>/UnitDelay'
         *  UnitDelay: '<S1310>/UnitDelay2'
         */
        if (rtb_TmpSignalConversionAtVeBT_m || rtb_UnitDelay3_ff)
        {
            /* Switch: '<S1310>/Switch' incorporates:
             *  Constant: '<S1307>/Calib'
             */
            rtb_TmpSignalConversionAtVeTA_b = KeTHMR_P_HCCTISErr_IV;
        }
        else if ((((THMR_ac_DW.UnitDelay_DSTATE_bn <= 0.0F) ||
                   (THMR_ac_DW.UnitDelay2_DSTATE_j2 < VeTHMR_P_MaxPowerHCCTIS)) &&
                  ((THMR_ac_DW.UnitDelay2_DSTATE_j2 <
                    KeTHMR_P_Reg_HtrNeed_MaxPwr_AntiWindup) &&
                   (THMR_ac_DW.UnitDelay2_DSTATE_j2 >
                    KeTHMR_P_Reg_HtrNeed_MinPwr_AntiWindup))) &&
                 (VeTHMR_b_ECHHeatReq))
        {
            /* Switch: '<S1310>/Switch2' incorporates:
             *  Constant: '<S1266>/Constant1'
             *  Product: '<S1310>/Multiplication2'
             *  Sum: '<S1310>/Sum//Sub'
             *  Switch: '<S1310>/Switch'
             *  UnitDelay: '<S1310>/UnitDelay'
             */
            rtb_TmpSignalConversionAtVeTA_b = ((VeTHMR_dT_ECHClntCntrlTempTerr *
                0.1F) * VeTHMR_K_ECHCntrlKi) + THMR_ac_DW.UnitDelay_DSTATE_bn;
        }
        else
        {
            /* Switch: '<S1310>/Switch' incorporates:
             *  Switch: '<S1310>/Switch2'
             *  UnitDelay: '<S1310>/UnitDelay'
             */
            rtb_TmpSignalConversionAtVeTA_b = THMR_ac_DW.UnitDelay_DSTATE_bn;
        }

        /* End of Switch: '<S1310>/Switch' */

        /* Outputs for Atomic SubSystem: '<S1310>/integral_term' */
        /* Switch: '<S1313>/Switch1' incorporates:
         *  RelationalOperator: '<S1313>/RelationalOperator'
         */
        if (VeTHMR_P_MaxPowerHCCTIS < rtb_TmpSignalConversionAtVeTA_b)
        {
            /* Switch: '<S1309>/Switch1' */
            rtb_TmpSignalConversionAtVeTA_b = VeTHMR_P_MaxPowerHCCTIS;
        }

        /* End of Switch: '<S1313>/Switch1' */

        /* Switch: '<S1313>/Switch' incorporates:
         *  Constant: '<S1308>/Calib'
         *  RelationalOperator: '<S1313>/RelationalOperator1'
         */
        if (rtb_TmpSignalConversionAtVeTA_b <= KeTHMR_P_Reg_HCCTIS_MinPwr)
        {
            /* Switch: '<S1313>/Switch' */
            rtb_TmpSignalConversionAtVeTA_b = KeTHMR_P_Reg_HCCTIS_MinPwr;
        }

        /* End of Switch: '<S1313>/Switch' */
        /* End of Outputs for SubSystem: '<S1310>/integral_term' */

        /* Sum: '<S1310>/Sum//Sub1' incorporates:
         *  Product: '<S1310>/proportional_term'
         */
        rtb_Merge2_l = (VeTHMR_dT_ECHClntCntrlTempTerr * VeTHMR_K_ECHCntrlKp) +
            rtb_TmpSignalConversionAtVeTA_b;

        /* Switch: '<S1310>/Switch1' incorporates:
         *  UnitDelay: '<S1310>/UnitDelay3'
         */
        if (THMR_ac_DW.UnitDelay3_DSTATE_lq)
        {
            /* Switch: '<S1310>/Switch1' */
            VeTHMR_P_CabinPwrNeed_BG = rtb_Merge2_l;
        }
        else
        {
            /* Switch: '<S1310>/Switch1' incorporates:
             *  UnitDelay: '<S1310>/UnitDelay1'
             */
            VeTHMR_P_CabinPwrNeed_BG = THMR_ac_DW.UnitDelay1_DSTATE_gj;
        }

        /* End of Switch: '<S1310>/Switch1' */

        /* Update for UnitDelay: '<S1310>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_bn = rtb_TmpSignalConversionAtVeTA_b;

        /* Update for UnitDelay: '<S1310>/UnitDelay2' */
        THMR_ac_DW.UnitDelay2_DSTATE_j2 = rtb_Merge2_l;

        /* Update for UnitDelay: '<S1310>/UnitDelay3' */
        THMR_ac_DW.UnitDelay3_DSTATE_lq = VeTHMR_b_ECHHeatReq;

        /* Update for UnitDelay: '<S1310>/UnitDelay1' */
        THMR_ac_DW.UnitDelay1_DSTATE_gj = VeTHMR_P_CabinPwrNeed_BG;

        /* End of Outputs for SubSystem: '<S1266>/PIControl' */

        /* Outputs for Atomic SubSystem: '<S1266>/Limiter' */
        /* Switch: '<S1309>/Switch1' incorporates:
         *  Constant: '<S1305>/Calib'
         *  RelationalOperator: '<S1309>/RelationalOperator'
         */
        if (KeTHMR_P_CabHtrPwrNeed_Max < VeTHMR_P_CabinPwrNeed_BG)
        {
            /* Switch: '<S1309>/Switch1' */
            rtb_TmpSignalConversionAtVeTA_b = KeTHMR_P_CabHtrPwrNeed_Max;
        }
        else
        {
            /* Switch: '<S1309>/Switch1' */
            rtb_TmpSignalConversionAtVeTA_b = VeTHMR_P_CabinPwrNeed_BG;
        }

        /* End of Switch: '<S1309>/Switch1' */

        /* Switch: '<S1309>/Switch' incorporates:
         *  Constant: '<S1306>/Calib'
         *  RelationalOperator: '<S1309>/RelationalOperator1'
         */
        if (rtb_TmpSignalConversionAtVeTA_b > KeTHMR_P_CabHtrPwrNeed_Min)
        {
            /* Switch: '<S1309>/Switch' */
            VeTHMR_P_CabPwrNeed_NormlRaw_PI = rtb_TmpSignalConversionAtVeTA_b;
        }
        else
        {
            /* Switch: '<S1309>/Switch' */
            VeTHMR_P_CabPwrNeed_NormlRaw_PI = KeTHMR_P_CabHtrPwrNeed_Min;
        }

        /* End of Switch: '<S1309>/Switch' */
        /* End of Outputs for SubSystem: '<S1266>/Limiter' */

        /* Switch: '<S1243>/Switch3' incorporates:
         *  Constant: '<S1264>/Calib'
         *  Logic: '<S1243>/Logical1'
         */
        if ((rtb_LogicalOperator_lw || rtb_LogicalOperator1_fo) ||
                (KeTHMR_b_CabinPwrNeed_PIEnbl))
        {
            /* Switch: '<S1243>/Switch3' */
            VeTHMR_P_CabinPwrNeed_RegFlow = VeTHMR_P_CabPwrNeed_NormlRaw_PI;
        }
        else
        {
            /* Switch: '<S1243>/Switch3' */
            VeTHMR_P_CabinPwrNeed_RegFlow = VeTHMR_P_CabPwrNeed_NormlRaw_0;
        }

        /* End of Switch: '<S1243>/Switch3' */

        /* Merge: '<S1212>/Merge' incorporates:
         *  Gain: '<S1268>/Gain'
         */
        VeTHMR_P_CabPwrNeed_Raw_0 = VeTHMR_P_CabinPwrNeed_RegFlow;

        /* End of Outputs for SubSystem: '<S1212>/CalcRegularFlow' */
    }
    else
    {
        THMR_ac_DW.If_ActiveSubsystem = 3;

        /* Outputs for IfAction SubSystem: '<S1212>/IfActionSubsystem' incorporates:
         *  ActionPort: '<S1244>/ActionPort'
         */
        /* Merge: '<S1212>/Merge' incorporates:
         *  Constant: '<S1314>/Calib'
         *  SignalConversion generated from: '<S1244>/CabinPwrNeed'
         */
        VeTHMR_P_CabPwrNeed_Raw_0 = KeTHMR_P_DfltAirHtrPwrTgt;

        /* End of Outputs for SubSystem: '<S1212>/IfActionSubsystem' */
    }

    /* End of If: '<S1212>/If' */

    /* Switch: '<S1211>/Switch3' incorporates:
     *  Constant: '<S1235>/Calib'
     *  Inport: '<Root>/VeCTRR_b_AmbientChillCond'
     */
    if (KeTHMR_b_OV_AmbChill_CabPwrSlct_OldApp)
    {
        /* Logic: '<S1497>/LogicalOperator' incorporates:
         *  Constant: '<S1227>/Constant'
         *  Constant: '<S1228>/Constant'
         *  Constant: '<S1233>/Calib'
         *  Constant: '<S1234>/Calib'
         *  Logic: '<S1211>/Logical2'
         *  Logic: '<S1211>/Logical4'
         *  Logic: '<S1211>/Logical5'
         *  Logic: '<S1211>/Logical6'
         *  RelationalOperator: '<S1211>/Comparison2'
         *  RelationalOperator: '<S1211>/Comparison20'
         *  RelationalOperator: '<S1211>/Comparison4'
         *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
         */
        rtb_LogicalOperator_lw = ((((((rtb_TmpSignalConversionAtVePDTR &&
            (!rtb_TmpSignalConversionAtVeB_jd)) && (((uint32)
            rtb_TmpSignalConversionAtVePD_l) == CePDTR_e_Dischrg_CabReqInOV)) &&
            (VeTHMR_P_CabPwrNeed_Raw_0 > KeTHMR_P_OV_CabinHeatPwr_Need)) &&
            (VeTHMR_b_ECHHeatReq)) || (((uint32)rtb_TmpSignalConversionAtVePD_l)
            == CePDTR_e_Dischrg_AmbTempLow)) && (KeTHMR_b_OV_AmbChill_CabPwrSlct));
    }
    else
    {
        (void)Rte_Read_VeCTRR_b_AmbientChillCond_Value(&rtb_AND_de);

        /* Logic: '<S1497>/LogicalOperator' incorporates:
         *  Constant: '<S1236>/Calib'
         *  Inport: '<Root>/VeCTRR_b_AmbientChillCond'
         *  Logic: '<S1211>/LogicalOperator2'
         */
        rtb_LogicalOperator_lw = ((KeTHMR_b_OV_EPD_CondAmbTemp) && rtb_AND_de);
    }

    /* End of Switch: '<S1211>/Switch3' */

    /* Switch: '<S1231>/Switch1' incorporates:
     *  Inport: '<Root>/VeHTIR_T_Htr2CoreTemp'
     */
    if (rtb_LogicalOperator_lw)
    {
        (void)Rte_Read_VeHTIR_T_Htr2CoreTemp_Value(&rtb_Switch1_dnd);

        /* Switch: '<S1211>/Switch' incorporates:
         *  Constant: '<S1237>/Calib'
         *  Delay: '<S1150>/Delay'
         *  Inport: '<Root>/VeHTIR_T_Htr2CoreTemp'
         */
        if (KeTHMR_b_OV_SelClntTmpECHPwr)
        {
            rtb_Switch1_dnd = THMR_ac_DW.Delay_DSTATE;
        }

        /* End of Switch: '<S1211>/Switch' */

        /* Switch: '<S1153>/Switch3' incorporates:
         *  Lookup_n-D: '<S1240>/Vector'
         *  MinMax: '<S1211>/MinMax1'
         */
        rtb_TmpSignalConversionAtVeHT_k = fmaxf(look1_iflf_binlcapw
            (rtb_Switch1_dnd, ((const float32 *)&(KxTHMR_P_OV_AmbChill_CabPwr[0])),
             ((const float32 *)&(KtTHMR_P_OV_AmbChill_CabPwr[0])), 8U),
            VeTHMR_P_CabPwrNeed_Raw_0);
    }
    else
    {
        /* Switch: '<S1153>/Switch3' */
        rtb_TmpSignalConversionAtVeHT_k = VeTHMR_P_CabPwrNeed_Raw_0;
    }

    /* End of Switch: '<S1231>/Switch1' */

    /* Switch: '<S1232>/Switch1' incorporates:
     *  Constant: '<S1211>/ConstantValue2'
     *  Constant: '<S1229>/Constant'
     *  Constant: '<S1230>/Constant'
     *  Constant: '<S1238>/Calib'
     *  Logic: '<S1211>/LogicalOperator1'
     *  Logic: '<S1211>/LogicalOperator3'
     *  Lookup_n-D: '<S1239>/Vector'
     *  RelationalOperator: '<S1211>/Comparison1'
     *  SignalConversion generated from: '<S2>/VeTPCR_dT_PerWpCond_EngTmpErr'
     */
    if ((((KeTHMR_b_UseCellUT4PerWupBattHeat) && (THMR_ac_B.VariantMerge_Fo_at))
         && (THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0)) && ((((uint32)
            rtb_TmpSignalConversionAtVeTP_k) == CeTPCR_e_BattOnly_Cond) ||
            (((uint32)rtb_TmpSignalConversionAtVeTP_k) ==
             CeTPCR_e_Both_Eng_N_Bat_Cond)))
    {
        rtb_Switch10 = look1_iflf_binlcapw(rtb_TmpSignalConversionAtVeTPCR, ((
            const float32 *)&(KxTHMR_P_BattHeatPwrNeed_PerWup[0])), ((const
            float32 *)&(KtTHMR_P_BattHeatPwrNeed_PerWup[0])), 7U);
    }
    else
    {
        rtb_Switch10 = 0.0F;
    }

    /* End of Switch: '<S1232>/Switch1' */

    /* MinMax: '<S1211>/MinMax2' */
    VeTHMR_P_CabinPwrNeed_Raw = fmaxf(rtb_TmpSignalConversionAtVeHT_k,
        rtb_Switch10);

    /* Outputs for Atomic SubSystem: '<S1210>/Limiter' */
    /* Switch: '<S1226>/Switch1' incorporates:
     *  Constant: '<S1223>/Calib'
     *  RelationalOperator: '<S1226>/RelationalOperator'
     */
    if (KeTHMR_P_CabHeatPwrNeed_Max < VeTHMR_P_CabinPwrNeed_Raw)
    {
        /* Switch: '<S1153>/Switch3' */
        rtb_TmpSignalConversionAtVeHT_k = KeTHMR_P_CabHeatPwrNeed_Max;
    }
    else
    {
        /* Switch: '<S1153>/Switch3' */
        rtb_TmpSignalConversionAtVeHT_k = VeTHMR_P_CabinPwrNeed_Raw;
    }

    /* End of Switch: '<S1226>/Switch1' */

    /* Switch: '<S1226>/Switch' incorporates:
     *  Constant: '<S1224>/Calib'
     *  RelationalOperator: '<S1226>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeHT_k > KeTHMR_P_CabHeatPwrNeed_Min)
    {
        /* Switch: '<S1226>/Switch' */
        VeTHMR_P_CabinPwrNeed_RawLmtd0 = rtb_TmpSignalConversionAtVeHT_k;
    }
    else
    {
        /* Switch: '<S1226>/Switch' */
        VeTHMR_P_CabinPwrNeed_RawLmtd0 = KeTHMR_P_CabHeatPwrNeed_Min;
    }

    /* End of Switch: '<S1226>/Switch' */
    /* End of Outputs for SubSystem: '<S1210>/Limiter' */

    /* Outputs for Enabled SubSystem: '<S1160>/HTCV_Flt_RA_Cntrls' incorporates:
     *  EnablePort: '<S1852>/Enable'
     */
    /* RelationalOperator: '<S1210>/Comparison6' incorporates:
     *  Chart: '<S1852>/THMR_HTCVFlt_RA'
     *  DataTypeConversion: '<S1842>/DataTypeConversion'
     *  RelationalOperator: '<S1163>/Comparison3'
     *  RelationalOperator: '<S1163>/Comparison5'
     *  RelationalOperator: '<S1164>/Comparison4'
     *  RelationalOperator: '<S1210>/Comparison5'
     *  RelationalOperator: '<S1349>/Comparison1'
     *  RelationalOperator: '<S1350>/Comparison1'
     *  RelationalOperator: '<S1350>/Comparison4'
     *  RelationalOperator: '<S1351>/Comparison1'
     *  RelationalOperator: '<S1351>/Comparison4'
     *  RelationalOperator: '<S1497>/RelationalOperator'
     *  RelationalOperator: '<S1497>/RelationalOperator2'
     *  RelationalOperator: '<S1497>/RelationalOperator5'
     *  RelationalOperator: '<S1497>/RelationalOperator6'
     *  RelationalOperator: '<S1497>/RelationalOperator7'
     *  RelationalOperator: '<S1497>/RelationalOperator8'
     *  RelationalOperator: '<S1879>/Comparison1'
     *  RelationalOperator: '<S1879>/Comparison2'
     *  RelationalOperator: '<S1879>/Comparison3'
     *  Switch: '<S1350>/Switch2'
     *  Switch: '<S1879>/Switch2'
     */
    tmp_c = THMR_ac_B.DataTypeConversion_i;

    /* End of Outputs for SubSystem: '<S1160>/HTCV_Flt_RA_Cntrls' */

    /* Switch: '<S1222>/Switch1' incorporates:
     *  Constant: '<S1220>/Constant'
     *  Constant: '<S1221>/Constant'
     *  Logic: '<S1210>/Logical1'
     *  Logic: '<S1210>/Logical3'
     *  RelationalOperator: '<S1210>/Comparison5'
     *  RelationalOperator: '<S1210>/Comparison6'
     */
    if ((CeTHMR_e_NoHeating == ((uint32)tmp_c)) || ((((uint32)tmp_c) ==
            CeTHMR_e_BatteryHeating) && rtb_AND_fe))
    {
        /* Switch: '<S1222>/Switch1' incorporates:
         *  Constant: '<S1225>/Calib'
         */
        VeTHMR_P_CabinHeatPwrNeed_BD = KeTHMR_P_CabPwrNeed_NoFlow;
    }
    else
    {
        /* Switch: '<S1222>/Switch1' */
        VeTHMR_P_CabinHeatPwrNeed_BD = VeTHMR_P_CabinPwrNeed_RawLmtd0;
    }

    /* End of Switch: '<S1222>/Switch1' */

    /* UnitDelay: '<S1347>/UnitDelay' */
    rtb_LogicalOperator_lw = THMR_ac_DW.UnitDelay_DSTATE_ew;

    /* Outputs for Atomic SubSystem: '<S1347>/EdgeFalling' */
    /* Logic: '<S1353>/AND' incorporates:
     *  Logic: '<S1353>/OR1'
     *  UnitDelay: '<S1353>/UnitDelay'
     */
    rtb_LogicalOperator1_fo = ((!rtb_LogicalOperator_lw) &&
        (THMR_ac_DW.UnitDelay_DSTATE_kx));

    /* Update for UnitDelay: '<S1353>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kx = rtb_LogicalOperator_lw;

    /* End of Outputs for SubSystem: '<S1347>/EdgeFalling' */

    /* Outputs for Atomic SubSystem: '<S1347>/EdgeRising' */
    /* Logic: '<S1354>/OR1' incorporates:
     *  UnitDelay: '<S1354>/UnitDelay'
     */
    rtb_LogicalOperator_lw = !THMR_ac_DW.UnitDelay_DSTATE_ow;

    /* Update for UnitDelay: '<S1354>/UnitDelay' incorporates:
     *  Constant: '<S1347>/TRUEConstant'
     */
    THMR_ac_DW.UnitDelay_DSTATE_ow = true;

    /* Outputs for Atomic SubSystem: '<S1347>/SignalLatchOnWithReset1' */
    /* Logic: '<S1356>/OR1' incorporates:
     *  Logic: '<S1354>/AND'
     *  Logic: '<S1356>/NOT'
     *  Logic: '<S1356>/OR'
     *  UnitDelay: '<S1356>/UnitDelay'
     */
    rtb_LogicalOperator1_fo = (rtb_LogicalOperator_lw ||
        ((!rtb_LogicalOperator1_fo) && (THMR_ac_DW.UnitDelay_DSTATE_c3)));

    /* End of Outputs for SubSystem: '<S1347>/EdgeRising' */

    /* Update for UnitDelay: '<S1356>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_c3 = rtb_LogicalOperator1_fo;

    /* End of Outputs for SubSystem: '<S1347>/SignalLatchOnWithReset1' */

    /* Outputs for Atomic SubSystem: '<S1347>/EdgeRising1' */
    /* Logic: '<S1355>/OR1' incorporates:
     *  UnitDelay: '<S1355>/UnitDelay'
     */
    rtb_LogicalOperator_lw = !THMR_ac_DW.UnitDelay_DSTATE_ile;

    /* Update for UnitDelay: '<S1355>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ile = rtb_LogicalOperator1_fo;

    /* Outputs for Atomic SubSystem: '<S1347>/TimerRetriggerResetEnabled' */
    /* Switch: '<S1357>/Switch1' incorporates:
     *  Logic: '<S1355>/AND'
     *  Switch: '<S1357>/Switch2'
     */
    if (rtb_LogicalOperator1_fo && rtb_LogicalOperator_lw)
    {
        /* Switch: '<S1357>/Switch1' incorporates:
         *  Constant: '<S1346>/Calib'
         */
        rtb_Switch1_dnd = KeTHMR_t_INITValuesWaittime_CabVlv;
    }
    else if (rtb_LogicalOperator1_fo)
    {
        /* Switch: '<S1357>/Switch2' incorporates:
         *  Constant: '<S1347>/ConstantValue4'
         *  Constant: '<S1357>/ConstantValue4'
         *  MinMax: '<S1357>/Maximum'
         *  Sum: '<S1357>/Subtraction'
         *  Switch: '<S1357>/Switch1'
         *  UnitDelay: '<S1357>/UnitDelay'
         */
        rtb_Switch1_dnd = fmaxf(THMR_ac_DW.UnitDelay_DSTATE_ia - 0.1F, 0.0F);
    }
    else
    {
        /* Switch: '<S1357>/Switch1' incorporates:
         *  Switch: '<S1357>/Switch2'
         *  UnitDelay: '<S1357>/UnitDelay'
         */
        rtb_Switch1_dnd = THMR_ac_DW.UnitDelay_DSTATE_ia;
    }

    /* End of Switch: '<S1357>/Switch1' */
    /* End of Outputs for SubSystem: '<S1347>/EdgeRising1' */

    /* RelationalOperator: '<S1357>/GreaterThan1' incorporates:
     *  Constant: '<S1357>/ConstantValue2'
     */
    VeTHMR_b_Switch2ActValue_Vlv_Init0 = (rtb_Switch1_dnd > 0.0F);

    /* Update for UnitDelay: '<S1357>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ia = rtb_Switch1_dnd;

    /* End of Outputs for SubSystem: '<S1347>/TimerRetriggerResetEnabled' */

    /* SignalConversion generated from: '<S57>/HtrPwrTgt_MBC_HTL_LTCL' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    /* Switch: '<S1425>/Switch1' */
    rtb_Switch1_giu = THMR_ac_B.Product;

#else

    /* Switch: '<S1425>/Switch1' incorporates:
     *  SignalConversion generated from: '<S57>/HtrPwrTgt_MBC_HTL_LTCL'
     */
    rtb_Switch1_giu = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S57>/HtrPwrTgt_MBC_HTL_LTCL' */

    /* S-Function (fcgen): '<S57>/Function-CallGenerator' incorporates:
     *  SubSystem: '<S57>/FunctionCall'
     */
    /* S-Function (fcgen): '<S1155>/Function-CallGenerator1' incorporates:
     *  SubSystem: '<S57>/MBC_HTL'
     */
    /* RelationalOperator: '<S2084>/Comparison4' incorporates:
     *  Constant: '<S2073>/Constant'
     *  RelationalOperator: '<S1217>/RelationalOperator1'
     *  RelationalOperator: '<S2055>/Comparison4'
     *  Switch: '<S3942>/Switch1'
     */
    rtb_LogicalOperator1_fo = (((uint32)VeTHMR_e_HVACECOModeSts) ==
        CeTRIR_e_HVAC_ECO_ON);
    for (i = 0; i < 6; i++)
    {
        /* UnitDelay: '<S2034>/UnitDelay' */
        VaTHMR_k_LQGHTLStates[(i)] = THMR_ac_DW.UnitDelay_DSTATE_dl[i];
    }

    /* UnitDelay: '<S2075>/UnitDelay' */
    VeTHMR_T_HTLPumpLQGIntgrDlyd = THMR_ac_DW.UnitDelay_DSTATE_lb;

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/MBC_HTL_LTCL'
     */
    /* Sum: '<S1170>/Sum1' incorporates:
     *  Sum: '<S64>/Add4'
     */
    rtb_TmpSignalConversionAtVeT_je = rtb_TmpSignalConversionAtVeCTRR -
        VeTHMR_T_HCCTISArb;

    /* Sum: '<S1170>/Sum1' */
    VeTHMR_T_HTLLQG_TrckError = rtb_TmpSignalConversionAtVeT_je;

    /* UnitDelay: '<S2055>/UnitDelay' */
    VeTHMR_n_HTLPumpMBCReq_BfGrdLimDlyd = THMR_ac_DW.UnitDelay_DSTATE_ae;

    /* Logic: '<S2075>/Logical1' incorporates:
     *  Constant: '<S2075>/ConstantValue1'
     *  Constant: '<S2075>/ConstantValue2'
     *  Constant: '<S2080>/Calib'
     *  Constant: '<S2081>/Calib'
     *  Logic: '<S2075>/Logical'
     *  Logic: '<S2075>/Logical2'
     *  RelationalOperator: '<S2075>/Comparison'
     *  RelationalOperator: '<S2075>/Comparison1'
     *  RelationalOperator: '<S2075>/Comparison2'
     *  RelationalOperator: '<S2075>/Comparison3'
     */
    VeTHMR_b_HTLPumpLQGIntgr_Enbl = (((VeTHMR_T_HTLLQG_TrckError < 0.0F) &&
        (VeTHMR_n_HTLPumpMBCReq_BfGrdLimDlyd >= KeTHMR_n_MaxAntWdPumpMBC1)) ||
        ((VeTHMR_T_HTLLQG_TrckError > 0.0F) &&
         (VeTHMR_n_HTLPumpMBCReq_BfGrdLimDlyd <= KeTHMR_n_MinAntWdPumpMBC1)));

    /* Switch: '<S2075>/Switch1' */
    if (VeTHMR_b_HTLPumpLQGIntgr_Enbl)
    {
        /* Switch: '<S2075>/Switch1' incorporates:
         *  Constant: '<S2075>/ConstantValue3'
         */
        VeTHMR_T_HTLPumpLQGIntgr_Incr = 0.0F;
    }
    else
    {
        /* Switch: '<S2075>/Switch1' incorporates:
         *  Constant: '<S2075>/ConstantValue'
         *  Product: '<S2075>/Product1'
         */
        VeTHMR_T_HTLPumpLQGIntgr_Incr = 0.1F * VeTHMR_T_HTLLQG_TrckError;
    }

    /* End of Switch: '<S2075>/Switch1' */

    /* Sum: '<S2075>/Sum' */
    VeTHMR_T_HTLPumpLQGIntgr = VeTHMR_T_HTLPumpLQGIntgrDlyd +
        VeTHMR_T_HTLPumpLQGIntgr_Incr;

    /* SignalConversion generated from: '<S2083>/Product' */
    for (i = 0; i < 6; i++)
    {
        tmp_4[i] = VaTHMR_k_LQGHTLStates[(i)];
    }

    tmp_4[6] = VeTHMR_T_HTLPumpLQGIntgr;

    /* End of SignalConversion generated from: '<S2083>/Product' */

    /* Product: '<S2083>/Product' incorporates:
     *  Constant: '<S2079>/Calib'
     *  Gain: '<S2055>/Gain'
     *  Switch: '<S2055>/Switch3'
     */
    rtb_Switch10 = 0.0F;
    for (i = 0; i < 7; i++)
    {
        /* Switch: '<S2055>/Switch3' incorporates:
         *  Constant: '<S2076>/Calib'
         *  Constant: '<S2079>/Calib'
         */
        if (rtb_LogicalOperator1_fo)
        {
            rtb_TmpSignalConversionAtVeTA_b = KaTHMR_k_KLQGPumpMBCECO[(i)];
        }
        else
        {
            rtb_TmpSignalConversionAtVeTA_b = KaTHMR_k_KLGGPumpMBC1[(i)];
        }

        rtb_Switch10 += (-rtb_TmpSignalConversionAtVeTA_b) * tmp_4[i];
    }

    /* Product: '<S2083>/Product' */
    VeTHMR_n_HTLPumpMBCReq_BfGrdLim = rtb_Switch10;

    /* Outputs for Atomic SubSystem: '<S2031>/Limiter1' */
    /* Switch: '<S2063>/Switch1' incorporates:
     *  Constant: '<S2052>/Calib'
     *  RelationalOperator: '<S2063>/RelationalOperator'
     */
    if (KeTHMR_n_MaxHTLPumpMBC1 < VeTHMR_n_HTLPumpMBCReq_BfGrdLim)
    {
        /* Switch: '<S2072>/Switch1' */
        rtb_Switch1_dnd = KeTHMR_n_MaxHTLPumpMBC1;
    }
    else
    {
        /* Switch: '<S2072>/Switch1' */
        rtb_Switch1_dnd = VeTHMR_n_HTLPumpMBCReq_BfGrdLim;
    }

    /* End of Switch: '<S2063>/Switch1' */

    /* Switch: '<S2063>/Switch' incorporates:
     *  Constant: '<S2053>/Calib'
     *  RelationalOperator: '<S2063>/RelationalOperator1'
     */
    if (rtb_Switch1_dnd > KeTHMR_n_MinHTLPumpMBC1)
    {
        /* Switch: '<S2063>/Switch' */
        rtb_TmpSignalConversionAtVeTA_b = rtb_Switch1_dnd;
    }
    else
    {
        /* Switch: '<S2063>/Switch' */
        rtb_TmpSignalConversionAtVeTA_b = KeTHMR_n_MinHTLPumpMBC1;
    }

    /* End of Switch: '<S2063>/Switch' */
    /* End of Outputs for SubSystem: '<S2031>/Limiter1' */

    /* Outputs for Atomic SubSystem: '<S2031>/GradientLimiter1' */
    /* Switch: '<S2072>/Switch1' incorporates:
     *  UnitDelay: '<S2061>/UnitDelay'
     */
    rtb_Switch1_dnd = THMR_ac_DW.UnitDelay_DSTATE_il;

    /* Sum: '<S2061>/Sum2' */
    rtb_TmpSignalConversionAtVeTA_b -= rtb_Switch1_dnd;

    /* Outputs for Atomic SubSystem: '<S2061>/Limiter' */
    /* Switch: '<S2065>/Switch1' incorporates:
     *  Constant: '<S2054>/Calib'
     *  RelationalOperator: '<S2065>/RelationalOperator'
     */
    if (KeTHMR_n_UGrdLimitHTLPumpMBC1 < rtb_TmpSignalConversionAtVeTA_b)
    {
        /* Switch: '<S2085>/Switch1' */
        rtb_TmpSignalConversionAtVeTA_b = KeTHMR_n_UGrdLimitHTLPumpMBC1;
    }

    /* End of Switch: '<S2065>/Switch1' */

    /* Switch: '<S2065>/Switch' incorporates:
     *  Constant: '<S2051>/Calib'
     *  RelationalOperator: '<S2065>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTA_b <= KeTHMR_n_DGrdLimitHTLPumpMBC1)
    {
        rtb_TmpSignalConversionAtVeTA_b = KeTHMR_n_DGrdLimitHTLPumpMBC1;
    }

    /* End of Switch: '<S2065>/Switch' */
    /* End of Outputs for SubSystem: '<S2061>/Limiter' */

    /* Sum: '<S2061>/Sum3' */
    VeTHMR_n_HTLPumpMBCReq_B4Set = rtb_TmpSignalConversionAtVeTA_b +
        rtb_Switch1_dnd;

    /* Update for UnitDelay: '<S2061>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_il = VeTHMR_n_HTLPumpMBCReq_B4Set;

    /* End of Outputs for SubSystem: '<S2031>/GradientLimiter1' */

    /* UnitDelay: '<S2074>/UnitDelay' */
    VeTHMR_T_HTLHeaterLQGIntgrDlyd = THMR_ac_DW.UnitDelay_DSTATE_b1;

    /* UnitDelay: '<S2055>/UnitDelay1' */
    VeTHMR_P_HTLHeaterLQGReq_BfGrdLimDlyd = THMR_ac_DW.UnitDelay1_DSTATE_m;

    /* Logic: '<S2074>/Logical1' incorporates:
     *  Constant: '<S2038>/Calib'
     *  Constant: '<S2041>/Calib'
     *  Constant: '<S2074>/ConstantValue1'
     *  Constant: '<S2074>/ConstantValue2'
     *  Logic: '<S2074>/Logical'
     *  Logic: '<S2074>/Logical2'
     *  RelationalOperator: '<S2074>/Comparison'
     *  RelationalOperator: '<S2074>/Comparison1'
     *  RelationalOperator: '<S2074>/Comparison2'
     *  RelationalOperator: '<S2074>/Comparison3'
     */
    VeTHMR_b_HTLHeaterLQGIntgr_Enbl = (((VeTHMR_T_HTLLQG_TrckError > 0.0F) &&
        (VeTHMR_P_HTLHeaterLQGReq_BfGrdLimDlyd >= KeTHMR_P_MaxAntWdHtrMBC1)) ||
        ((VeTHMR_T_HTLLQG_TrckError < 0.0F) &&
         (VeTHMR_P_HTLHeaterLQGReq_BfGrdLimDlyd <= KeTHMR_P_MinAntWdHtrMBC1)));

    /* Switch: '<S2074>/Switch1' */
    if (VeTHMR_b_HTLHeaterLQGIntgr_Enbl)
    {
        /* Switch: '<S2074>/Switch1' incorporates:
         *  Constant: '<S2074>/ConstantValue3'
         */
        VeTHMR_T_HTLHeaterLQGIntgr_Incr = 0.0F;
    }
    else
    {
        /* Switch: '<S2074>/Switch1' incorporates:
         *  Constant: '<S2074>/ConstantValue'
         *  Product: '<S2074>/Product1'
         */
        VeTHMR_T_HTLHeaterLQGIntgr_Incr = 0.1F * VeTHMR_T_HTLLQG_TrckError;
    }

    /* End of Switch: '<S2074>/Switch1' */

    /* Sum: '<S2074>/Sum' */
    VeTHMR_T_HTLHeaterLQGIntgr = VeTHMR_T_HTLHeaterLQGIntgrDlyd +
        VeTHMR_T_HTLHeaterLQGIntgr_Incr;

    /* SignalConversion generated from: '<S2082>/Product' */
    for (i = 0; i < 6; i++)
    {
        tmp_4[i] = VaTHMR_k_LQGHTLStates[(i)];
    }

    tmp_4[6] = VeTHMR_T_HTLHeaterLQGIntgr;

    /* End of SignalConversion generated from: '<S2082>/Product' */

    /* Product: '<S2082>/Product' incorporates:
     *  Constant: '<S2078>/Calib'
     *  Gain: '<S2055>/Gain1'
     *  Switch: '<S2055>/Switch1'
     */
    rtb_Switch10 = 0.0F;
    for (i = 0; i < 7; i++)
    {
        /* Switch: '<S2055>/Switch1' incorporates:
         *  Constant: '<S2077>/Calib'
         *  Constant: '<S2078>/Calib'
         */
        if (rtb_LogicalOperator1_fo)
        {
            rtb_TmpSignalConversionAtVeTA_b = KaTHMR_k_KLQGHtrMBCECO[(i)];
        }
        else
        {
            rtb_TmpSignalConversionAtVeTA_b = KaTHMR_k_KLGGPumpMBC2[(i)];
        }

        rtb_Switch10 += (-rtb_TmpSignalConversionAtVeTA_b) * tmp_4[i];
    }

    /* Product: '<S2082>/Product' */
    VeTHMR_P_HTLHeaterLQGReq_BfGrdLim = rtb_Switch10;

    /* Outputs for Atomic SubSystem: '<S2031>/Limiter2' */
    /* Switch: '<S2064>/Switch1' incorporates:
     *  Constant: '<S2039>/Calib'
     *  RelationalOperator: '<S2064>/RelationalOperator'
     */
    if (KeTHMR_P_MaxHTLHtrMBC1 < VeTHMR_P_HTLHeaterLQGReq_BfGrdLim)
    {
        /* Switch: '<S2072>/Switch1' */
        rtb_Switch1_dnd = KeTHMR_P_MaxHTLHtrMBC1;
    }
    else
    {
        /* Switch: '<S2072>/Switch1' */
        rtb_Switch1_dnd = VeTHMR_P_HTLHeaterLQGReq_BfGrdLim;
    }

    /* End of Switch: '<S2064>/Switch1' */

    /* Switch: '<S2064>/Switch' incorporates:
     *  Constant: '<S2042>/Calib'
     *  RelationalOperator: '<S2064>/RelationalOperator1'
     */
    if (rtb_Switch1_dnd > KeTHMR_P_MinHTLHtrMBC1)
    {
        /* Switch: '<S2064>/Switch' */
        rtb_TmpSignalConversionAtVeTA_b = rtb_Switch1_dnd;
    }
    else
    {
        /* Switch: '<S2064>/Switch' */
        rtb_TmpSignalConversionAtVeTA_b = KeTHMR_P_MinHTLHtrMBC1;
    }

    /* End of Switch: '<S2064>/Switch' */
    /* End of Outputs for SubSystem: '<S2031>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S2031>/GradientLimiter2' */
    /* Switch: '<S2072>/Switch1' incorporates:
     *  UnitDelay: '<S2062>/UnitDelay'
     */
    rtb_Switch1_dnd = THMR_ac_DW.UnitDelay_DSTATE_ic;

    /* Sum: '<S2062>/Sum2' */
    rtb_TmpSignalConversionAtVeTA_b -= rtb_Switch1_dnd;

    /* Outputs for Atomic SubSystem: '<S2062>/Limiter' */
    /* Switch: '<S2066>/Switch1' incorporates:
     *  Constant: '<S2044>/Calib'
     *  RelationalOperator: '<S2066>/RelationalOperator'
     */
    if (KeTHMR_P_UGrdLimitHTLHtrMBC1 < rtb_TmpSignalConversionAtVeTA_b)
    {
        /* Switch: '<S2085>/Switch1' */
        rtb_TmpSignalConversionAtVeTA_b = KeTHMR_P_UGrdLimitHTLHtrMBC1;
    }

    /* End of Switch: '<S2066>/Switch1' */

    /* Switch: '<S2066>/Switch' incorporates:
     *  Constant: '<S2036>/Calib'
     *  RelationalOperator: '<S2066>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTA_b <= KeTHMR_P_DGrdLimitHTLHtrMBC1)
    {
        rtb_TmpSignalConversionAtVeTA_b = KeTHMR_P_DGrdLimitHTLHtrMBC1;
    }

    /* End of Switch: '<S2066>/Switch' */
    /* End of Outputs for SubSystem: '<S2062>/Limiter' */

    /* Sum: '<S2062>/Sum3' */
    VeTHMR_P_HTLHeaterLQGReq_B4Set = rtb_TmpSignalConversionAtVeTA_b +
        rtb_Switch1_dnd;

    /* Update for UnitDelay: '<S2062>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ic = VeTHMR_P_HTLHeaterLQGReq_B4Set;

    /* End of Outputs for SubSystem: '<S2031>/GradientLimiter2' */

    /* UnitDelay: '<S2085>/UnitDelay' */
    VeTHMR_k_Errorsum_MBC = THMR_ac_DW.UnitDelay_DSTATE_lk;
    for (i = 0; i < 2; i++)
    {
        /* UnitDelay: '<S2060>/UnitDelay' */
        Switch3_h[i] = THMR_ac_DW.UnitDelay_DSTATE_ie[i];
    }

    /* Switch: '<S2084>/Switch2' incorporates:
     *  Constant: '<S2086>/Constant'
     *  Constant: '<S2091>/Calib'
     *  Constant: '<S2092>/Calib'
     *  Constant: '<S2093>/Calib'
     *  Constant: '<S2094>/Calib'
     *  RelationalOperator: '<S1217>/RelationalOperator1'
     *  RelationalOperator: '<S2084>/Comparison4'
     *  Switch: '<S2084>/Switch3'
     *  Switch: '<S3942>/Switch1'
     */
    /* MATLAB Function 'THMR_FUNC_RU_MedTEH/HTCL/MBC_HTL/feedback_linearization/FeedbackLinearization/FBLinearizationFunction': '<S2087>:1' */
    /* '<S2087>:1:7' */
    if (((uint32)VeTHMR_e_HVACECOModeSts) == CeTRIR_e_HVAC_ECO_ON)
    {
        rtb_TmpSignalConversionAtVeTA_b = KeTHMR_k_KpFBLMBCECO;
        rtb_Merge2_l = KeTHMR_k_KiFBLMBCECO;
    }
    else
    {
        rtb_TmpSignalConversionAtVeTA_b = KeTHMR_k_KpFBLMBC2;
        rtb_Merge2_l = KeTHMR_k_KiFBLMBC2;
    }

    /* End of Switch: '<S2084>/Switch2' */

    /* MATLAB Function: '<S2084>/FBLinearizationFunction' incorporates:
     *  Constant: '<S2088>/Calib'
     *  Constant: '<S2089>/Calib'
     *  Constant: '<S2090>/Calib'
     */
    rtb_Merge1_i = (rtb_TmpSignalConversionAtVeTA_b * VeTHMR_T_HTLLQG_TrckError)
        + (rtb_Merge2_l * VeTHMR_k_Errorsum_MBC);

    /* '<S2087>:1:9' */
    /* '<S2087>:1:10' */
    rtb_Switch10 = Switch3_h[1] - Switch3_h[0];
    if (fabsf(rtb_Switch10) <= KeTHMR_T_MinFBLMBC2)
    {
        /* '<S2087>:1:11' */
        if (Switch3_h[1] <= Switch3_h[0])
        {
            /* '<S2087>:1:12' */
            /* '<S2087>:1:13' */
            rtb_Switch1_dnd = KeTHMR_dV_MinHTLPumpMBC2;
        }
        else
        {
            /* '<S2087>:1:15' */
            rtb_Switch1_dnd = KeTHMR_dV_MaxHTLPumpMBC2;
        }
    }
    else
    {
        /* '<S2087>:1:19' */
        rtb_Switch1_dnd = (0.5F * rtb_Merge1_i) / rtb_Switch10;
    }

    /* Gain: '<S2095>/Gain' incorporates:
     *  Constant: '<S2089>/Calib'
     *  Constant: '<S2090>/Calib'
     *  MATLAB Function: '<S2084>/FBLinearizationFunction'
     */
    /* '<S2087>:1:25' */
    /* '<S2087>:1:26' */
    VeTHMR_dV_MBC_FBL_Flow = fmaxf(fminf(KeTHMR_dV_MaxHTLPumpMBC2,
        rtb_Switch1_dnd), KeTHMR_dV_MinHTLPumpMBC2);

    /* Outputs for Atomic SubSystem: '<S2032>/Limiter1' */
    /* Switch: '<S2069>/Switch1' incorporates:
     *  Constant: '<S2048>/Calib'
     *  RelationalOperator: '<S2069>/RelationalOperator'
     */
    if (KeTHMR_dV_MaxHTLFlowMBC2 < VeTHMR_dV_MBC_FBL_Flow)
    {
        /* Switch: '<S2085>/Switch1' */
        rtb_TmpSignalConversionAtVeTA_b = KeTHMR_dV_MaxHTLFlowMBC2;
    }
    else
    {
        /* Switch: '<S2085>/Switch1' */
        rtb_TmpSignalConversionAtVeTA_b = VeTHMR_dV_MBC_FBL_Flow;
    }

    /* End of Switch: '<S2069>/Switch1' */
    /* End of Outputs for SubSystem: '<S2032>/Limiter1' */

    /* Outputs for Atomic SubSystem: '<S2032>/GradientLimiter1' */
    /* Switch: '<S2072>/Switch1' incorporates:
     *  UnitDelay: '<S2067>/UnitDelay'
     */
    rtb_Switch1_dnd = THMR_ac_DW.UnitDelay_DSTATE_cp;

    /* End of Outputs for SubSystem: '<S2032>/GradientLimiter1' */

    /* Outputs for Atomic SubSystem: '<S2032>/Limiter1' */
    /* Switch: '<S2069>/Switch' incorporates:
     *  Constant: '<S2049>/Calib'
     *  RelationalOperator: '<S2069>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTA_b <= KeTHMR_dV_MinHTLFlowMBC2)
    {
        rtb_TmpSignalConversionAtVeTA_b = KeTHMR_dV_MinHTLFlowMBC2;
    }

    /* End of Switch: '<S2069>/Switch' */
    /* End of Outputs for SubSystem: '<S2032>/Limiter1' */

    /* Outputs for Atomic SubSystem: '<S2032>/GradientLimiter1' */
    /* Sum: '<S2067>/Sum2' */
    rtb_TmpSignalConversionAtVeTA_b -= rtb_Switch1_dnd;

    /* Outputs for Atomic SubSystem: '<S2067>/Limiter' */
    /* Switch: '<S2071>/Switch1' incorporates:
     *  Constant: '<S2050>/Calib'
     *  RelationalOperator: '<S2071>/RelationalOperator'
     */
    if (KeTHMR_dV_UGrdLimitHTLFlowMBC2 < rtb_TmpSignalConversionAtVeTA_b)
    {
        /* Switch: '<S2085>/Switch1' */
        rtb_TmpSignalConversionAtVeTA_b = KeTHMR_dV_UGrdLimitHTLFlowMBC2;
    }

    /* End of Switch: '<S2071>/Switch1' */

    /* Switch: '<S2071>/Switch' incorporates:
     *  Constant: '<S2047>/Calib'
     *  RelationalOperator: '<S2071>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTA_b <= KeTHMR_dV_DGrdLimitHTLFlowMBC2)
    {
        rtb_TmpSignalConversionAtVeTA_b = KeTHMR_dV_DGrdLimitHTLFlowMBC2;
    }

    /* End of Switch: '<S2071>/Switch' */
    /* End of Outputs for SubSystem: '<S2067>/Limiter' */

    /* Sum: '<S2067>/Sum3' */
    VeTHMR_dV_HTLFlowMBCReq_B4Set = rtb_TmpSignalConversionAtVeTA_b +
        rtb_Switch1_dnd;

    /* Update for UnitDelay: '<S2067>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_cp = VeTHMR_dV_HTLFlowMBCReq_B4Set;

    /* End of Outputs for SubSystem: '<S2032>/GradientLimiter1' */

    /* Gain: '<S2096>/Gain' incorporates:
     *  MATLAB Function: '<S2084>/FBLinearizationFunction'
     */
    VeTHMR_P_MBC_FBL_HtrPwr = 0.5F * rtb_Merge1_i;

    /* Outputs for Atomic SubSystem: '<S2032>/Limiter2' */
    /* Switch: '<S2070>/Switch1' incorporates:
     *  Constant: '<S2040>/Calib'
     *  RelationalOperator: '<S2070>/RelationalOperator'
     */
    if (KeTHMR_P_MaxHTLHtrMBC2 < VeTHMR_P_MBC_FBL_HtrPwr)
    {
        /* Switch: '<S2085>/Switch1' */
        rtb_TmpSignalConversionAtVeTA_b = KeTHMR_P_MaxHTLHtrMBC2;
    }
    else
    {
        /* Switch: '<S2085>/Switch1' */
        rtb_TmpSignalConversionAtVeTA_b = VeTHMR_P_MBC_FBL_HtrPwr;
    }

    /* End of Switch: '<S2070>/Switch1' */

    /* Switch: '<S2070>/Switch' incorporates:
     *  Constant: '<S2043>/Calib'
     *  RelationalOperator: '<S2070>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTA_b > KeTHMR_P_MinHTLHtrMBC2)
    {
        /* Switch: '<S2070>/Switch' */
        rtb_Switch1_dnd = rtb_TmpSignalConversionAtVeTA_b;
    }
    else
    {
        /* Switch: '<S2070>/Switch' */
        rtb_Switch1_dnd = KeTHMR_P_MinHTLHtrMBC2;
    }

    /* End of Switch: '<S2070>/Switch' */
    /* End of Outputs for SubSystem: '<S2032>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S2032>/GradientLimiter2' */
    /* Switch: '<S2085>/Switch1' incorporates:
     *  UnitDelay: '<S2068>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeTA_b = THMR_ac_DW.UnitDelay_DSTATE_jd;

    /* Sum: '<S2068>/Sum2' */
    rtb_Switch1_dnd -= rtb_TmpSignalConversionAtVeTA_b;

    /* Outputs for Atomic SubSystem: '<S2068>/Limiter' */
    /* Switch: '<S2072>/Switch1' incorporates:
     *  Constant: '<S2045>/Calib'
     *  RelationalOperator: '<S2072>/RelationalOperator'
     */
    if (KeTHMR_P_UGrdLimitHTLHtrMBC2 < rtb_Switch1_dnd)
    {
        /* Switch: '<S2072>/Switch1' */
        rtb_Switch1_dnd = KeTHMR_P_UGrdLimitHTLHtrMBC2;
    }

    /* End of Switch: '<S2072>/Switch1' */

    /* Switch: '<S2072>/Switch' incorporates:
     *  Constant: '<S2037>/Calib'
     *  RelationalOperator: '<S2072>/RelationalOperator1'
     */
    if (rtb_Switch1_dnd <= KeTHMR_P_DGrdLimitHTLHtrMBC2)
    {
        rtb_Switch1_dnd = KeTHMR_P_DGrdLimitHTLHtrMBC2;
    }

    /* End of Switch: '<S2072>/Switch' */
    /* End of Outputs for SubSystem: '<S2068>/Limiter' */

    /* Sum: '<S2068>/Sum3' */
    VeTHMR_P_HTLHeaterFLCReq_B4Set = rtb_Switch1_dnd +
        rtb_TmpSignalConversionAtVeTA_b;

    /* Update for UnitDelay: '<S2068>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_jd = VeTHMR_P_HTLHeaterFLCReq_B4Set;

    /* End of Outputs for SubSystem: '<S2032>/GradientLimiter2' */

    /* Gain: '<S2058>/Gain' */
    VeTHMR_P_HTLHeaterFLCReq = VeTHMR_P_HTLHeaterFLCReq_B4Set;

    /* Gain: '<S2057>/Gain' */
    VeTHMR_P_HTLHeaterLQGReq = VeTHMR_P_HTLHeaterLQGReq_B4Set;

    /* Gain: '<S2056>/Gain' */
    VeTHMR_n_HTLPump_MBCReq = VeTHMR_n_HTLPumpMBCReq_B4Set;

    /* Gain: '<S2059>/Gain' */
    VeTHMR_dV_HTLFlowMBCReq = VeTHMR_dV_HTLFlowMBCReq_B4Set;

    /* UnitDelay: '<S2060>/UnitDelay1' */
    rtb_Switch1_dnd = THMR_ac_DW.UnitDelay1_DSTATE_mj;

    /* Switch: '<S2085>/Switch1' incorporates:
     *  Constant: '<S2038>/Calib'
     *  Constant: '<S2041>/Calib'
     *  Constant: '<S2085>/ConstantValue1'
     *  Constant: '<S2085>/ConstantValue2'
     *  Logic: '<S2085>/Logical'
     *  Logic: '<S2085>/Logical1'
     *  Logic: '<S2085>/Logical2'
     *  RelationalOperator: '<S2085>/Comparison'
     *  RelationalOperator: '<S2085>/Comparison1'
     *  RelationalOperator: '<S2085>/Comparison2'
     *  RelationalOperator: '<S2085>/Comparison3'
     */
    if (((VeTHMR_T_HTLLQG_TrckError > 0.0F) && (rtb_Switch1_dnd >=
            KeTHMR_P_MaxAntWdHtrMBC1)) || ((VeTHMR_T_HTLLQG_TrckError < 0.0F) &&
         (rtb_Switch1_dnd <= KeTHMR_P_MinAntWdHtrMBC1)))
    {
        /* Switch: '<S2085>/Switch1' incorporates:
         *  Constant: '<S2085>/ConstantValue3'
         */
        rtb_TmpSignalConversionAtVeTA_b = 0.0F;
    }
    else
    {
        /* Switch: '<S2085>/Switch1' incorporates:
         *  Constant: '<S2085>/ConstantValue'
         *  Product: '<S2085>/Product1'
         */
        rtb_TmpSignalConversionAtVeTA_b = 0.1F * VeTHMR_T_HTLLQG_TrckError;
    }

    /* End of Switch: '<S2085>/Switch1' */

    /* SignalConversion generated from: '<S2034>/Gain1' incorporates:
     *  Constant: '<S1170>/ConstantValue1'
     */
    rtb_UnitDelay_buv[0] = VeTHMR_n_HTLPumpMBCReq_BfGrdLim;
    rtb_UnitDelay_buv[1] = VeTHMR_P_HTLHeaterLQGReq_BfGrdLim;
    rtb_UnitDelay_buv[2] = VeTHMR_T_HCCTOSArb;
    rtb_UnitDelay_buv[3] = 0.0F;
    for (i = 0; i < 6; i++)
    {
        /* Sum: '<S2034>/Add1' incorporates:
         *  Constant: '<S2033>/Calib'
         *  Constant: '<S2034>/Constant'
         *  Gain: '<S2034>/Gain2'
         */
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 6;
                rtb_DataTypeConversion2++)
        {
            i_0 = (6 * i) + rtb_DataTypeConversion2;
            tmp_5[i_0] = KaTHMR_k_AkalmanMBC1[(i_0)] - (KaTHMR_k_LkalmanMBC1
                [(rtb_DataTypeConversion2)] * KaTHMR_k_CkalmanMBC1[(i)]);
        }

        /* End of Sum: '<S2034>/Add1' */

        /* Sum: '<S2034>/Add' incorporates:
         *  Constant: '<S2033>/Calib'
         *  Gain: '<S2034>/Gain1'
         *  Product: '<S2034>/Product'
         */
        rtb_Switch10 = 0.0F;
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 4;
                rtb_DataTypeConversion2++)
        {
            rtb_Switch10 += KaTHMR_k_BkalmanMBC1[(6 * rtb_DataTypeConversion2) +
                i] * rtb_UnitDelay_buv[rtb_DataTypeConversion2];
        }

        tmp_6[i] = (KaTHMR_k_LkalmanMBC1[(i)] * VeTHMR_T_HCCTISArb) +
            rtb_Switch10;
    }

    for (i = 0; i < 6; i++)
    {
        /* Product: '<S2034>/Product1' */
        tmp_7[i] = 0.0F;
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 6;
                rtb_DataTypeConversion2++)
        {
            tmp_7[i] += tmp_5[(6 * rtb_DataTypeConversion2) + i] *
                VaTHMR_k_LQGHTLStates[(rtb_DataTypeConversion2)];
        }

        /* End of Product: '<S2034>/Product1' */

        /* Update for UnitDelay: '<S2034>/UnitDelay' incorporates:
         *  Sum: '<S2034>/Add'
         */
        THMR_ac_DW.UnitDelay_DSTATE_dl[i] = tmp_6[i] + tmp_7[i];
    }

    /* Update for UnitDelay: '<S2075>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_lb = VeTHMR_T_HTLPumpLQGIntgr;

    /* Update for UnitDelay: '<S2055>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ae = VeTHMR_n_HTLPumpMBCReq_BfGrdLim;

    /* Update for UnitDelay: '<S2074>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_b1 = VeTHMR_T_HTLHeaterLQGIntgr;

    /* Update for UnitDelay: '<S2055>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_m = VeTHMR_P_HTLHeaterLQGReq_BfGrdLim;

    /* Update for UnitDelay: '<S2085>/UnitDelay' incorporates:
     *  Sum: '<S2085>/Sum'
     */
    THMR_ac_DW.UnitDelay_DSTATE_lk = VeTHMR_k_Errorsum_MBC +
        rtb_TmpSignalConversionAtVeTA_b;

    /* Update for UnitDelay: '<S2060>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ie[0] = VeTHMR_T_HCCTISArb;
    THMR_ac_DW.UnitDelay_DSTATE_ie[1] = VeTHMR_T_HCCTOSArb;

    /* Update for UnitDelay: '<S2060>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_mj = VeTHMR_P_MBC_FBL_HtrPwr;

    /* End of Outputs for S-Function (fcgen): '<S1155>/Function-CallGenerator1' */
    /* End of Outputs for S-Function (fcgen): '<S57>/Function-CallGenerator' */

    /* Switch: '<S1166>/Switch1' incorporates:
     *  Constant: '<S1398>/Calib'
     *  Constant: '<S1400>/Constant'
     *  Constant: '<S1401>/Constant'
     *  Constant: '<S1402>/Constant'
     *  Constant: '<S1403>/Constant'
     *  Constant: '<S1404>/Constant'
     *  Constant: '<S1405>/Constant'
     *  Constant: '<S1406>/Calib'
     *  Logic: '<S1152>/LogicalOperator'
     *  Logic: '<S1399>/LogicalOperator'
     *  Logic: '<S1399>/LogicalOperator1'
     *  Logic: '<S1399>/LogicalOperator2'
     *  Logic: '<S1399>/LogicalOperator3'
     *  RelationalOperator: '<S1399>/Comparison1'
     *  RelationalOperator: '<S1399>/Comparison2'
     *  RelationalOperator: '<S1399>/Comparison3'
     *  RelationalOperator: '<S1399>/Comparison4'
     *  RelationalOperator: '<S1399>/Comparison5'
     *  RelationalOperator: '<S1399>/Comparison6'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     *  Switch: '<S1165>/Switch1'
     */
    if (rtb_VM_Conditional_Signal_Use_c)
    {
        /* Switch: '<S1166>/Switch1' */
        rtb_Switch1_dnd = rtb_Switch1_giu;
    }
    else if (((CeTHMR_e_CabinActiveHeating == ((uint32)rtb_Switch1_o0g)) &&
              ((((((((uint32)rtb_TmpSignalConversionAtVePD_l) !=
                    CePDTR_e_Dischrg_CabReqInOV) && (((uint32)
                     rtb_TmpSignalConversionAtVePD_l) !=
                    CePDTR_e_Dischrg_AmbTempLow)) && (((uint32)
                    rtb_TmpSignalConversionAtVePD_l) !=
                   CePDTR_e_Dischrg_CabReqPrsnt)) && (((uint32)
                   rtb_TmpSignalConversionAtVePD_l) !=
                  CePDTR_e_Dischrg_BatAndCab_Cndtn)) && (((uint32)
                  rtb_TmpSignalConversionAtVePD_l) != CePDTR_e_NoValidReq)) ||
               (KeTHMR_b_UseHLTMBCforOV))) && (KeTHMR_b_HTLMBCLegcySel))
    {
        /* S-Function (fcgen): '<S57>/Function-CallGenerator' incorporates:
         *  SubSystem: '<S57>/FunctionCall'
         */
        /* S-Function (fcgen): '<S1155>/Function-CallGenerator1' incorporates:
         *  SubSystem: '<S57>/MBC_HTL'
         */
        /* Switch: '<S1170>/Switch' incorporates:
         *  Constant: '<S2046>/Calib'
         */
        if (KeTHMR_b_HTLMBCSelect)
        {
            rtb_Switch10 = VeTHMR_P_HTLHeaterFLCReq;
        }
        else
        {
            rtb_Switch10 = VeTHMR_P_HTLHeaterLQGReq;
        }

        /* End of Switch: '<S1170>/Switch' */

        /* Switch: '<S1165>/Switch1' incorporates:
         *  Constant: '<S2035>/Calib'
         *  Product: '<S1170>/Product'
         *  Switch: '<S1166>/Switch1'
         */
        rtb_Switch1_dnd = KeTHMR_Cf_HtrPwrMBCCnvsn * rtb_Switch10;

        /* End of Outputs for S-Function (fcgen): '<S1155>/Function-CallGenerator1' */
        /* End of Outputs for S-Function (fcgen): '<S57>/Function-CallGenerator' */
    }
    else
    {
        /* Switch: '<S1166>/Switch1' incorporates:
         *  Switch: '<S1165>/Switch1'
         */
        rtb_Switch1_dnd = VeTHMR_P_CabinHeatPwrNeed_BD;
    }

    /* Sum: '<S1348>/Subtraction1' */
    rtb_Switch1_giu = rtb_Switch1_dnd + Switch_o;

    /* Outputs for Atomic SubSystem: '<S1348>/ProtectedDivision' */
    /* Switch: '<S1363>/Switch1' incorporates:
     *  Constant: '<S1363>/ConstantValue'
     *  Constant: '<S1363>/ConstantValue1'
     *  Constant: '<S1363>/ConstantValue2'
     *  Constant: '<S1363>/ConstantValue3'
     *  Logic: '<S1363>/AND'
     *  RelationalOperator: '<S1363>/GreaterThanorEqual'
     *  RelationalOperator: '<S1363>/GreaterThanorEqual1'
     *  RelationalOperator: '<S1363>/NotEqual'
     *  RelationalOperator: '<S1363>/NotEqual1'
     *  Switch: '<S1363>/Switch2'
     *  Switch: '<S1363>/Switch3'
     */
    if ((rtb_Switch1_dnd != 0.0F) && (rtb_Switch1_giu != 0.0F))
    {
        /* Switch: '<S1363>/Switch1' incorporates:
         *  Product: '<S1363>/Division'
         */
        rtb_Switch1_giu = rtb_Switch1_dnd / rtb_Switch1_giu;
    }
    else if (rtb_Switch1_dnd > 0.0F)
    {
        /* Switch: '<S1363>/Switch2' incorporates:
         *  Constant: '<S1363>/MAXFLOAT'
         *  Switch: '<S1363>/Switch1'
         */
        rtb_Switch1_giu = 3.402823466E+38F;
    }
    else if (rtb_Switch1_dnd < 0.0F)
    {
        /* Switch: '<S1363>/Switch3' incorporates:
         *  Constant: '<S1363>/MINFLOAT'
         *  Switch: '<S1363>/Switch1'
         *  Switch: '<S1363>/Switch2'
         */
        rtb_Switch1_giu = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1363>/Switch1' incorporates:
         *  Constant: '<S1363>/ConstantValue4'
         *  Switch: '<S1363>/Switch2'
         *  Switch: '<S1363>/Switch3'
         */
        rtb_Switch1_giu = 0.0F;
    }

    /* End of Switch: '<S1363>/Switch1' */
    /* End of Outputs for SubSystem: '<S1348>/ProtectedDivision' */

    /* Product: '<S1348>/Product' incorporates:
     *  Constant: '<S1348>/ConstantValue1'
     */
    VeTHMR_Pct_CabVlvOpeng_CmdRaw = rtb_Switch1_giu * 100.0F;

    /* Lookup_n-D: '<S1361>/Vector' incorporates:
     *  Product: '<S1348>/Product'
     */
    VeTHMR_Pct_CabVlvOpeng_Cmd = look1_iflf_binlcapw
        (VeTHMR_Pct_CabVlvOpeng_CmdRaw, ((const float32 *)
          &(KxTHMR_Pct_CabVlvOpeng_CmdLookUp[0])), ((const float32 *)
          &(KtTHMR_Pct_CabVlvOpeng_CmdLookUp[0])), 5U);

    /* Switch: '<S1350>/Switch2' incorporates:
     *  Constant: '<S1382>/Calib'
     */
    if (KeTHMR_b_ShrdHtrHEXEnbl)
    {
        /* Switch: '<S1350>/Switch2' incorporates:
         *  Constant: '<S1380>/Constant'
         *  Constant: '<S1381>/Constant'
         *  Logic: '<S1350>/Logical3'
         *  RelationalOperator: '<S1350>/Comparison1'
         *  RelationalOperator: '<S1350>/Comparison4'
         */
        rtb_LogicalOperator1_fo = ((CeTHMR_e_BatteryHeating == ((uint32)tmp_c)) ||
            (((uint32)tmp_c) == CeTHMR_e_BatteryNCabinHeating));
    }
    else
    {
        /* Switch: '<S1350>/Switch2' incorporates:
         *  Constant: '<S1380>/Constant'
         *  Logic: '<S1350>/Logical1'
         *  RelationalOperator: '<S1350>/Comparison4'
         */
        rtb_LogicalOperator1_fo = ((((uint32)tmp_c) ==
            CeTHMR_e_BatteryNCabinHeating) && rtb_TmpSignalConversionAtVeT_d5);
    }

    /* Outputs for Atomic SubSystem: '<S1362>/EdgeBi' */
    /* RelationalOperator: '<S1364>/NotEqual' incorporates:
     *  UnitDelay: '<S1364>/UnitDelay'
     */
    rtb_LogicalOperator_lw = (rtb_LogicalOperator1_fo !=
        THMR_ac_DW.UnitDelay_DSTATE_ief);

    /* Update for UnitDelay: '<S1364>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ief = rtb_LogicalOperator1_fo;

    /* End of Outputs for SubSystem: '<S1362>/EdgeBi' */

    /* Outputs for Atomic SubSystem: '<S1362>/EdgeRising' */
    /* Logic: '<S1365>/AND' incorporates:
     *  Logic: '<S1365>/OR1'
     *  UnitDelay: '<S1365>/UnitDelay'
     */
    rtb_AND_de = !THMR_ac_DW.UnitDelay_DSTATE_chw;

    /* Update for UnitDelay: '<S1365>/UnitDelay' incorporates:
     *  Constant: '<S1362>/TRUEConstant'
     */
    THMR_ac_DW.UnitDelay_DSTATE_chw = true;

    /* End of Outputs for SubSystem: '<S1362>/EdgeRising' */

    /* Lookup_n-D: '<S1395>/Vector' incorporates:
     *  SignalConversion generated from: '<S1148>/VariantSource'
     */
    rtb_Switch1_giu = look1_iflf_binlcapw(VeTHMR_r_BattCabPriorityRatio_Fin, ((
        const float32 *)&(KxTHMR_r_BattCabPrioRatioFrHTCV[0])), ((const float32 *)
        &(KtTHMR_r_BattCabPrioRatioFrHTCV[0])), 4U);

    /* If: '<S1352>/TempErr_HTLPosition' incorporates:
     *  Constant: '<S1393>/Constant'
     *  Constant: '<S1394>/Constant'
     *  Logic: '<S1352>/Logical1'
     *  RelationalOperator: '<S1352>/Comparison7'
     *  RelationalOperator: '<S1352>/Comparison8'
     */
    if ((CeTHMR_e_CabinActiveHeating == ((uint32)rtb_Switch1_o0g)) || (((uint32)
            rtb_Switch1_o0g) == CeTHMR_e_CabinActivePassiveHeating))
    {
        /* Outputs for IfAction SubSystem: '<S1352>/TempErr_CabBattHeating' incorporates:
         *  ActionPort: '<S1396>/ActionPort'
         */
        /* Merge: '<S1352>/Merge2' incorporates:
         *  Constant: '<S1396>/ConstantValue'
         *  Inport: '<S57>/CTRR_T_HtrCorClnt_Tmp_In'
         *  Product: '<S1396>/Product'
         *  Product: '<S1396>/Product1'
         *  Sum: '<S1396>/Add1'
         *  Sum: '<S1396>/Add2'
         *  Sum: '<S1396>/Add3'
         *  Sum: '<S1396>/Sum1'
         */
        rtb_TmpSignalConversionAtVeTA_b = ((THMR_ac_B.Vector_h -
            rtb_TmpSignalConversionAtVeBT_k) * rtb_Switch1_giu) - ((1.0F -
            rtb_Switch1_giu) * (rtb_TmpSignalConversionAtVeCTRR -
                                VeTHMR_T_HtrCorClnt_Tmp_In_AD));

        /* End of Outputs for SubSystem: '<S1352>/TempErr_CabBattHeating' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1352>/TempError_BattHeating' incorporates:
         *  ActionPort: '<S1397>/ActionPort'
         */
        THMR_ac_TempError_BattHeating(THMR_ac_B.Vector_h,
            rtb_TmpSignalConversionAtVeBT_k, &rtb_TmpSignalConversionAtVeTA_b);

        /* End of Outputs for SubSystem: '<S1352>/TempError_BattHeating' */
    }

    /* End of If: '<S1352>/TempErr_HTLPosition' */

    /* Outputs for Atomic SubSystem: '<S1362>/PIControl' */
    /* Switch: '<S1375>/Switch' incorporates:
     *  Constant: '<S1370>/Calib'
     *  Constant: '<S1375>/Constant'
     *  Constant: '<S1375>/Constant1'
     *  Constant: '<S1375>/ConstantValue'
     *  Logic: '<S1362>/Logical1'
     *  Logic: '<S1375>/Logical'
     *  Logic: '<S1375>/Logical1'
     *  Logic: '<S1375>/Logical2'
     *  Logic: '<S1375>/Logical3'
     *  Logic: '<S1375>/Logical4'
     *  RelationalOperator: '<S1375>/Comparison1'
     *  RelationalOperator: '<S1375>/Comparison2'
     *  RelationalOperator: '<S1375>/Comparison3'
     *  RelationalOperator: '<S1375>/Comparison4'
     *  Switch: '<S1375>/Switch2'
     *  UnitDelay: '<S1375>/UnitDelay'
     *  UnitDelay: '<S1375>/UnitDelay2'
     */
    if (rtb_AND_de || rtb_LogicalOperator_lw)
    {
        /* Switch: '<S1375>/Switch' incorporates:
         *  Constant: '<S1369>/Calib'
         */
        rtb_Switch1_giu = KeTHMR_Pct_HTCVPI_IV;
    }
    else if ((((THMR_ac_DW.UnitDelay_DSTATE_dwz <= 0.0F) ||
               (THMR_ac_DW.UnitDelay2_DSTATE_c1 < KeTHMR_Pct_HTCVPI_Max)) &&
              ((THMR_ac_DW.UnitDelay2_DSTATE_c1 < 100.0F) &&
               (THMR_ac_DW.UnitDelay2_DSTATE_c1 > -1.0F))) &&
             rtb_LogicalOperator1_fo)
    {
        /* Switch: '<S1375>/Switch2' incorporates:
         *  Constant: '<S1358>/Calib'
         *  Constant: '<S1362>/Constant2'
         *  Product: '<S1375>/Multiplication2'
         *  Sum: '<S1375>/Sum//Sub'
         *  Switch: '<S1375>/Switch'
         *  UnitDelay: '<S1375>/UnitDelay'
         */
        rtb_Switch1_giu = ((rtb_TmpSignalConversionAtVeTA_b * 0.1F) *
                           KeTHMR_K_HTCVPICont_Ki) +
            THMR_ac_DW.UnitDelay_DSTATE_dwz;
    }
    else
    {
        /* Switch: '<S1375>/Switch' incorporates:
         *  Switch: '<S1375>/Switch2'
         *  UnitDelay: '<S1375>/UnitDelay'
         */
        rtb_Switch1_giu = THMR_ac_DW.UnitDelay_DSTATE_dwz;
    }

    /* End of Switch: '<S1375>/Switch' */

    /* Outputs for Atomic SubSystem: '<S1375>/integral_term' */
    /* Switch: '<S1377>/Switch1' incorporates:
     *  Constant: '<S1370>/Calib'
     *  RelationalOperator: '<S1377>/RelationalOperator'
     */
    if (KeTHMR_Pct_HTCVPI_Max < rtb_Switch1_giu)
    {
        /* Switch: '<S1425>/Switch1' */
        rtb_Switch1_giu = KeTHMR_Pct_HTCVPI_Max;
    }

    /* End of Switch: '<S1377>/Switch1' */

    /* Switch: '<S1377>/Switch' incorporates:
     *  Constant: '<S1371>/Calib'
     *  RelationalOperator: '<S1377>/RelationalOperator1'
     */
    if (rtb_Switch1_giu <= KeTHMR_Pct_HTCVPI_Min)
    {
        /* Switch: '<S1377>/Switch' */
        rtb_Switch1_giu = KeTHMR_Pct_HTCVPI_Min;
    }

    /* End of Switch: '<S1377>/Switch' */
    /* End of Outputs for SubSystem: '<S1375>/integral_term' */

    /* Sum: '<S1375>/Sum//Sub1' incorporates:
     *  Constant: '<S1359>/Calib'
     *  Product: '<S1375>/proportional_term'
     */
    rtb_TmpSignalConversionAtVeTA_b = (rtb_TmpSignalConversionAtVeTA_b *
        KeTHMR_K_HTCVPICont_Kp) + rtb_Switch1_giu;

    /* Switch: '<S1375>/Switch1' incorporates:
     *  UnitDelay: '<S1375>/UnitDelay3'
     */
    if (THMR_ac_DW.UnitDelay3_DSTATE_jm)
    {
        /* Switch: '<S1375>/Switch1' */
        rtb_Merge2_l = rtb_TmpSignalConversionAtVeTA_b;
    }
    else
    {
        /* Switch: '<S1375>/Switch1' incorporates:
         *  UnitDelay: '<S1375>/UnitDelay1'
         */
        rtb_Merge2_l = THMR_ac_DW.UnitDelay1_DSTATE_o1;
    }

    /* End of Switch: '<S1375>/Switch1' */

    /* Update for UnitDelay: '<S1375>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_dwz = rtb_Switch1_giu;

    /* Update for UnitDelay: '<S1375>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_c1 = rtb_TmpSignalConversionAtVeTA_b;

    /* Update for UnitDelay: '<S1375>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_jm = rtb_LogicalOperator1_fo;

    /* Update for UnitDelay: '<S1375>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_o1 = rtb_Merge2_l;

    /* End of Outputs for SubSystem: '<S1362>/PIControl' */

    /* Outputs for Atomic SubSystem: '<S1362>/GradientLimiter' */
    /* Sum: '<S1366>/Sum2' incorporates:
     *  UnitDelay: '<S1366>/UnitDelay'
     */
    rtb_Switch1_giu = rtb_Merge2_l - THMR_ac_DW.UnitDelay_DSTATE_dv;

    /* Outputs for Atomic SubSystem: '<S1366>/Limiter' */
    /* Switch: '<S1376>/Switch1' incorporates:
     *  Constant: '<S1373>/Calib'
     *  RelationalOperator: '<S1376>/RelationalOperator'
     */
    if (KeTHMR_dPct_HTCVCntrl_LU < rtb_Switch1_giu)
    {
        /* Switch: '<S1153>/Switch3' */
        rtb_TmpSignalConversionAtVeHT_k = KeTHMR_dPct_HTCVCntrl_LU;
    }
    else
    {
        /* Switch: '<S1153>/Switch3' */
        rtb_TmpSignalConversionAtVeHT_k = rtb_Switch1_giu;
    }

    /* End of Switch: '<S1376>/Switch1' */

    /* Switch: '<S1376>/Switch' incorporates:
     *  Constant: '<S1372>/Calib'
     *  RelationalOperator: '<S1376>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeHT_k <= KeTHMR_dPct_HTCVCntrl_LD)
    {
        rtb_TmpSignalConversionAtVeHT_k = KeTHMR_dPct_HTCVCntrl_LD;
    }

    /* End of Switch: '<S1376>/Switch' */
    /* End of Outputs for SubSystem: '<S1366>/Limiter' */

    /* Sum: '<S1366>/Sum3' incorporates:
     *  UnitDelay: '<S1366>/UnitDelay'
     */
    rtb_Switch1_giu = rtb_TmpSignalConversionAtVeHT_k +
        THMR_ac_DW.UnitDelay_DSTATE_dv;

    /* Update for UnitDelay: '<S1366>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_dv = rtb_Switch1_giu;

    /* End of Outputs for SubSystem: '<S1362>/GradientLimiter' */

    /* Switch: '<S1342>/Switch1' incorporates:
     *  Constant: '<S1379>/Calib'
     *  Constant: '<S1383>/Constant'
     *  Constant: '<S1384>/Constant'
     *  Constant: '<S1385>/Constant'
     *  Constant: '<S1386>/Constant'
     *  Constant: '<S1387>/Constant'
     *  Constant: '<S1388>/Constant'
     *  Constant: '<S1389>/Constant'
     *  Constant: '<S1390>/Calib'
     *  Constant: '<S1391>/Calib'
     *  Constant: '<S1392>/Calib'
     *  Logic: '<S1351>/Logical2'
     *  Logic: '<S1351>/Logical3'
     *  Logic: '<S1351>/Logical4'
     *  Logic: '<S1351>/Logical5'
     *  Logic: '<S1351>/Logical6'
     *  Logic: '<S1351>/Logical7'
     *  Logic: '<S1351>/Logical8'
     *  RelationalOperator: '<S1351>/Comparison1'
     *  RelationalOperator: '<S1351>/Comparison3'
     *  RelationalOperator: '<S1351>/Comparison4'
     *  RelationalOperator: '<S1351>/Comparison5'
     *  RelationalOperator: '<S1351>/Comparison6'
     *  RelationalOperator: '<S1351>/Comparison7'
     *  RelationalOperator: '<S1351>/Comparison8'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     *  Switch: '<S1349>/Switch2'
     */
    if (((((((KeTHMR_b_OV_HTCV_FulOpn_StatThreeEnb) &&
             (CePDTR_e_Dischrg_AmbTempLow == ((uint32)
               rtb_TmpSignalConversionAtVePD_l))) || ((((uint32)
               rtb_TmpSignalConversionAtVePD_l) ==
              CePDTR_e_Dischrg_ForcBatCool_Hys) &&
             (KeTHMR_b_OV_HTCV_FulOpn_StatFourEnb))) ||
            (((KeTHMR_b_OV_HTCV_FulOpn_StatFivEnb) && (((((uint32)
                 rtb_TmpSignalConversionAtVePD_l) ==
                CePDTR_e_Dischrg_BatAndCab_Cndtn) || (((uint32)
                 rtb_TmpSignalConversionAtVePD_l) ==
                CePDTR_e_Dischrg_CabReqPrsnt)) || (((uint32)
                rtb_TmpSignalConversionAtVePD_l) == CePDTR_e_Dischrg_CabReqInOV)))
             && rtb_TmpSignalConversionAtVeCT_o)) || ((CeTHMR_e_BatteryHeating
            != ((uint32)tmp_c)) && (((uint32)tmp_c) !=
            CeTHMR_e_BatteryNCabinHeating))) ||
            (VeTHMR_b_Switch2ActValue_Vlv_Init0)) &&
            rtb_TmpSignalConversionAtVeT_d5)
    {
        /* Switch: '<S1342>/Switch1' incorporates:
         *  Constant: '<S1344>/Calib'
         */
        VeTHMR_Pct_ClntProp3WyVlv_Cmd_Raw = KeTHMR_Pct_HTCV_HTLNotThrmCpldBTL;
    }
    else
    {
        if (KeTHMR_b_ShrdHtrHEXEnbl)
        {
            /* Switch: '<S1349>/Switch2' incorporates:
             *  Constant: '<S1378>/Constant'
             *  Logic: '<S1349>/Logical1'
             *  RelationalOperator: '<S1349>/Comparison1'
             */
            rtb_AND_fe = ((((uint32)tmp_c) == CeTHMR_e_BatteryHeating) &&
                          (THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0));
        }
        else
        {
            /* Switch: '<S1349>/Switch2' incorporates:
             *  Constant: '<S1378>/Constant'
             *  Logic: '<S1349>/Logical2'
             *  RelationalOperator: '<S1349>/Comparison1'
             */
            rtb_AND_fe = ((((uint32)tmp_c) == CeTHMR_e_BatteryHeating) ||
                          (THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0));
        }

        /* Switch: '<S1342>/Switch2' incorporates:
         *  Switch: '<S1342>/Switch3'
         */
        if (rtb_AND_fe)
        {
            /* Switch: '<S1342>/Switch1' incorporates:
             *  Constant: '<S1343>/Calib'
             *  Switch: '<S1342>/Switch2'
             */
            VeTHMR_Pct_ClntProp3WyVlv_Cmd_Raw =
                KeTHMR_Pct_HTCV_HTLFullThrmCpldBTL;
        }
        else if (rtb_LogicalOperator1_fo)
        {
            /* Switch: '<S1348>/Switch2' incorporates:
             *  Constant: '<S1360>/Calib'
             *  Switch: '<S1342>/Switch3'
             */
            if (KeTHMR_b_ShrdHtrHEXEnbl)
            {
                /* Outputs for Atomic SubSystem: '<S1362>/Limiter' */
                /* Switch: '<S1374>/Switch1' incorporates:
                 *  Constant: '<S1367>/Calib'
                 *  RelationalOperator: '<S1374>/RelationalOperator'
                 */
                if (KeTHMR_Pct_HTCVCntrl_Max < rtb_Switch1_giu)
                {
                    /* Switch: '<S1374>/Switch1' */
                    rtb_Switch1_giu = KeTHMR_Pct_HTCVCntrl_Max;
                }

                /* End of Switch: '<S1374>/Switch1' */

                /* Switch: '<S1374>/Switch' incorporates:
                 *  Constant: '<S1368>/Calib'
                 *  RelationalOperator: '<S1374>/RelationalOperator1'
                 */
                if (rtb_Switch1_giu > KeTHMR_Pct_HTCVCntrl_Min)
                {
                    /* Switch: '<S1342>/Switch1' incorporates:
                     *  Switch: '<S1342>/Switch3'
                     *  Switch: '<S1348>/Switch2'
                     */
                    VeTHMR_Pct_ClntProp3WyVlv_Cmd_Raw = rtb_Switch1_giu;
                }
                else
                {
                    /* Switch: '<S1342>/Switch1' incorporates:
                     *  Switch: '<S1342>/Switch3'
                     *  Switch: '<S1348>/Switch2'
                     */
                    VeTHMR_Pct_ClntProp3WyVlv_Cmd_Raw = KeTHMR_Pct_HTCVCntrl_Min;
                }

                /* End of Switch: '<S1374>/Switch' */
                /* End of Outputs for SubSystem: '<S1362>/Limiter' */
            }
            else
            {
                /* Switch: '<S1342>/Switch1' incorporates:
                 *  Switch: '<S1342>/Switch3'
                 *  Switch: '<S1348>/Switch2'
                 */
                VeTHMR_Pct_ClntProp3WyVlv_Cmd_Raw = VeTHMR_Pct_CabVlvOpeng_Cmd;
            }

            /* End of Switch: '<S1348>/Switch2' */
        }
        else
        {
            /* Switch: '<S1342>/Switch1' incorporates:
             *  Constant: '<S1344>/Calib'
             *  Switch: '<S1342>/Switch3'
             */
            VeTHMR_Pct_ClntProp3WyVlv_Cmd_Raw =
                KeTHMR_Pct_HTCV_HTLNotThrmCpldBTL;
        }

        /* End of Switch: '<S1342>/Switch2' */
    }

    /* End of Switch: '<S1342>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VePMTR_b_ThrmlSystRly_EnblCmnd' */
    (void)Rte_Read_VePMTR_b_ThrmlSystRly_EnblCmnd_Value(&rtb_LogicalOperator_aa);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* Logic: '<S1342>/Logical3' incorporates:
     *  Constant: '<S1345>/Calib'
     */
    VeTHMR_b_ThreeW_Prop_Valve1_Enb = (rtb_LogicalOperator_aa &&
        (KeTHMR_b_ThreeW_Prop_Valve1_Dial));

    /* RelationalOperator: '<S1412>/Comparison6' incorporates:
     *  SignalConversion generated from: '<S1412>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_ShrdBattCab_Heater

    /* VariantMerge generated from: '<S1412>/VariantSource' incorporates:
     *  Constant: '<S1437>/Constant'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     */
    rtb_VariantMerge_For_Variant_p3 = (CePDTR_e_Dischrg_ForcBatHeat_Hys ==
        ((uint32)rtb_TmpSignalConversionAtVePD_l));

#else

    /* VariantMerge generated from: '<S1412>/VariantSource' incorporates:
     *  Constant: '<S1412>/Constant'
     *  SignalConversion generated from: '<S1412>/VariantSource'
     */
    rtb_VariantMerge_For_Variant_p3 = false;

#endif

    /* End of RelationalOperator: '<S1412>/Comparison6' */

    /* Logic: '<S1497>/LogicalOperator' incorporates:
     *  Constant: '<S1966>/Constant'
     *  Constant: '<S1970>/Constant'
     *  Constant: '<S1985>/Calib'
     *  Logic: '<S1164>/Logical5'
     *  Logic: '<S1164>/Logical6'
     *  RelationalOperator: '<S1164>/Comparison2'
     *  RelationalOperator: '<S1164>/Comparison9'
     *  Switch: '<S4586>/Switch1'
     */
    rtb_LogicalOperator_lw = ((((uint32)tmp_d) == CeTHMR_e_LTCLActvPsvHeating) ||
        ((((uint32)VeTHMR_e_BatThrmlSt_B4D) == CeTHMR_e_ActvPsvHeating) &&
         (KeTHMR_b_EnblBatActvPsvHeatChck4HTCLVlv)));

    /* Logic: '<S1164>/Logical1' */
    rtb_UnitDelay3_ff = ((THMR_ac_B.Switch_i) || rtb_LogicalOperator_lw);

    /* SignalConversion generated from: '<S1164>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_ShrdBattCab_Heater

    /* RelationalOperator: '<S1497>/RelationalOperator7' incorporates:
     *  Constant: '<S1164>/TRUE Constant1'
     */
    rtb_RelationalOperator7_p = true;

#else

    /* RelationalOperator: '<S1497>/RelationalOperator7' incorporates:
     *  Constant: '<S1164>/TRUE Constant3'
     *  SignalConversion generated from: '<S1164>/VariantSource'
     */
    rtb_RelationalOperator7_p = false;

#endif

    /* End of SignalConversion generated from: '<S1164>/VariantSource' */

    /* Logic: '<S1164>/LogicalOperator' incorporates:
     *  Constant: '<S1968>/Constant'
     *  Constant: '<S1972>/Constant'
     *  Constant: '<S1973>/Constant'
     *  Constant: '<S1974>/Constant'
     *  Constant: '<S1975>/Constant'
     *  Constant: '<S1983>/Calib'
     *  Constant: '<S1984>/Calib'
     *  Logic: '<S1164>/Logical Operator4'
     *  Logic: '<S1164>/LogicalOperator1'
     *  Logic: '<S1164>/LogicalOperator2'
     *  RelationalOperator: '<S1164>/Comparison12'
     *  RelationalOperator: '<S1164>/Comparison4'
     *  RelationalOperator: '<S1164>/Comparison6'
     *  Switch: '<S4586>/Switch1'
     */
    rtb_LogicalOperator_aa = (((((uint32)VeTHMR_e_BatThrmlSt_B4D) ==
        CeTHMR_e_Heating) || (((uint32)rtb_Switch1_o0g) ==
        CeTHMR_e_CabinActiveHeating)) || ((((((((uint32)tmp_c) ==
        CeTHMR_e_BatteryHeating) || (((uint32)tmp_c) ==
        CeTHMR_e_BatteryNCabinHeating)) || (((uint32)tmp_c) ==
        CeTHMR_e_CabinHeating)) && rtb_RelationalOperator7_p) &&
        (KeTHMR_b_BTLHTLDrctConnct)) && (!KeTHMR_b_BTLHTL_ILHEX)));

    /* Logic: '<S1164>/Logical Operator3' incorporates:
     *  Constant: '<S1967>/Constant'
     *  Constant: '<S1969>/Constant'
     *  RelationalOperator: '<S1164>/Comparison1'
     *  RelationalOperator: '<S1164>/Comparison5'
     *  Switch: '<S4586>/Switch1'
     */
    rtb_AND_de = ((((uint32)rtb_Switch1_o0g) ==
                   CeTHMR_e_CabinActivePassiveHeating) || (((uint32)
                    VeTHMR_e_BatThrmlSt_B4D) == CeTHMR_e_ActvPsvHeating));

    /* RelationalOperator: '<S1497>/RelationalOperator7' incorporates:
     *  Constant: '<S1950>/Calib'
     *  Logic: '<S1162>/Logical4'
     *  Logic: '<S1162>/LogicalOperator4'
     */
    rtb_RelationalOperator7_p = (((KeTHMR_b_OvrrdBattHeatReq4Pwr) &&
        rtb_TmpSignalConversionAtVeB_ba) && (THMR_ac_B.VariantMerge_Fo_at));

    /* Switch: '<S1946>/Switch1' incorporates:
     *  Constant: '<S1951>/Calib'
     *  Logic: '<S1162>/LogicalOperator3'
     *  Logic: '<S1162>/LogicalOperator6'
     *  Logic: '<S1162>/LogicalOperator7'
     */
    if (((KeTHMR_b_UseShrdHtrPI4Battheat) && rtb_RelationalOperator7_p) ||
            ((THMR_ac_B.VeTHMR_b_FCHeatAllwd) && Switch5_i))
    {
        /* Switch: '<S1946>/Switch1' */
        VeTHMR_P_Cab_HeatPwr_Raw = rtb_Switch1_dnd;
    }
    else
    {
        /* Switch: '<S1946>/Switch1' incorporates:
         *  Constant: '<S1162>/ConstantValue3'
         */
        VeTHMR_P_Cab_HeatPwr_Raw = 0.0F;
    }

    /* End of Switch: '<S1946>/Switch1' */

    /* Switch: '<S1944>/Switch1' incorporates:
     *  Constant: '<S1939>/Constant'
     *  Logic: '<S1162>/Logical3'
     *  RelationalOperator: '<S1162>/Comparison4'
     */
    if (rtb_RelationalOperator7_p || (((uint32)rtb_TmpSignalConversionAtVeAVTR) ==
         CeAVTR_e_EVA_Heat))
    {
        /* Switch: '<S1944>/Switch1' */
        VeTHMR_P_SharedBatt_HeatPwr_Raw = Switch_o;
    }
    else
    {
        /* Switch: '<S1944>/Switch1' incorporates:
         *  Constant: '<S1162>/ConstantValue2'
         */
        VeTHMR_P_SharedBatt_HeatPwr_Raw = 0.0F;
    }

    /* End of Switch: '<S1944>/Switch1' */

    /* Lookup_n-D: '<S1952>/Vector' incorporates:
     *  SignalConversion generated from: '<S2>/VeTPCR_dT_PerWpCond_EngTmpErr'
     */
    VeTHMR_P_PerWpCond_EngHeatPwr_Need = look1_iflf_binlcapw
        (rtb_TmpSignalConversionAtVeTPCR, ((const float32 *)
          &(KxTHMR_P_PerWpCond_EngHeatPwr_Need[0])), ((const float32 *)
          &(KtTHMR_P_PerWpCond_EngHeatPwr_Need[0])), 7U);

    /* RelationalOperator: '<S1162>/Comparison1' incorporates:
     *  Logic: '<S1162>/Logical1'
     *  Logic: '<S1162>/Logical2'
     *  RelationalOperator: '<S1162>/Comparison3'
     *  SignalConversion generated from: '<S1162>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_PerWup_EngToCond_En

    /* VariantMerge generated from: '<S1162>/VariantSource' incorporates:
     *  Constant: '<S1942>/Constant'
     *  Constant: '<S1943>/Constant'
     */
    THMR_ac_B.VariantMerge_Fo_jp = ((THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0) &&
        ((CeTPCR_e_EngOnly_Cond == ((uint32)rtb_TmpSignalConversionAtVeTP_k)) ||
         (((uint32)rtb_TmpSignalConversionAtVeTP_k) ==
          CeTPCR_e_Both_Eng_N_Bat_Cond)));

#else

    /* VariantMerge generated from: '<S1162>/VariantSource' incorporates:
     *  Constant: '<S1162>/Constant'
     *  SignalConversion generated from: '<S1162>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_jp = false;

#endif

    /* End of RelationalOperator: '<S1162>/Comparison1' */

    /* Switch: '<S1945>/Switch1' */
    if (THMR_ac_B.VariantMerge_Fo_jp)
    {
        /* Switch: '<S1945>/Switch1' */
        VeTHMR_P_EngHeatngPwr = VeTHMR_P_PerWpCond_EngHeatPwr_Need;
    }
    else
    {
        /* Switch: '<S1945>/Switch1' incorporates:
         *  Constant: '<S1162>/ConstantValue1'
         */
        VeTHMR_P_EngHeatngPwr = 0.0F;
    }

    /* End of Switch: '<S1945>/Switch1' */

    /* Sum: '<S1162>/Subtraction2' */
    VeTHMR_P_Cab_N_Bat_HeatPwrTot_Raw = (VeTHMR_P_Cab_HeatPwr_Raw +
        VeTHMR_P_SharedBatt_HeatPwr_Raw) + VeTHMR_P_EngHeatngPwr;

    /* Outputs for Atomic SubSystem: '<S1162>/Limiter' */
    /* Switch: '<S1953>/Switch1' incorporates:
     *  Constant: '<S1948>/Calib'
     *  RelationalOperator: '<S1953>/RelationalOperator'
     */
    if (KeTHMR_P_Cab_N_Bat_HeatPwrTot_Max < VeTHMR_P_Cab_N_Bat_HeatPwrTot_Raw)
    {
        /* Switch: '<S1425>/Switch1' */
        rtb_Switch1_giu = KeTHMR_P_Cab_N_Bat_HeatPwrTot_Max;
    }
    else
    {
        /* Switch: '<S1425>/Switch1' */
        rtb_Switch1_giu = VeTHMR_P_Cab_N_Bat_HeatPwrTot_Raw;
    }

    /* End of Switch: '<S1953>/Switch1' */

    /* Switch: '<S1953>/Switch' incorporates:
     *  Constant: '<S1949>/Calib'
     *  RelationalOperator: '<S1953>/RelationalOperator1'
     */
    if (rtb_Switch1_giu > KeTHMR_P_Cab_N_Bat_HeatPwrTot_Min)
    {
        /* Switch: '<S1953>/Switch' */
        VeTHMR_P_Cab_N_Bat_HeatPwrTot_Limtd = rtb_Switch1_giu;
    }
    else
    {
        /* Switch: '<S1953>/Switch' */
        VeTHMR_P_Cab_N_Bat_HeatPwrTot_Limtd = KeTHMR_P_Cab_N_Bat_HeatPwrTot_Min;
    }

    /* End of Switch: '<S1953>/Switch' */
    /* End of Outputs for SubSystem: '<S1162>/Limiter' */

    /* Outputs for IfAction SubSystem: '<S1161>/Subsystem2' incorporates:
     *  ActionPort: '<S1889>/ActionPort'
     */
    /* If: '<S1161>/If' incorporates:
     *  Logic: '<S1472>/Logical2'
     *  Logic: '<S1889>/Logical5'
     */
    rtb_AND_fe = !VeTHMR_b_ECT_Sgnl_Rcvd;

    /* End of Outputs for SubSystem: '<S1161>/Subsystem2' */

    /* Switch: '<S1472>/Switch2' incorporates:
     *  Logic: '<S1472>/Logical1'
     *  Logic: '<S1472>/Logical2'
     */
    if ((VeTHMR_b_EngCoolantTemp_FA) || rtb_AND_fe)
    {
        /* Switch: '<S1472>/Switch2' incorporates:
         *  Constant: '<S1703>/Calib'
         */
        rtb_Switch2_i1 = KeTHMR_T_EngClntTmp_EngCold;
    }
    else
    {
        /* Switch: '<S1472>/Switch2' */
        rtb_Switch2_i1 = VeTHMR_T_EngCoolantTemp;
    }

    /* End of Switch: '<S1472>/Switch2' */

    /* Lookup_n-D: '<S1714>/Vector' incorporates:
     *  Switch: '<S1472>/Switch2'
     */
    VeTHMR_P_EngPwrWaste_EngOn = look1_iflf_binlcapw(rtb_Switch2_i1, ((const
        float32 *)&(KxTHMR_P_EngPwrWasteHVACEcoModeHTSOV[0])), ((const float32 *)
        &(KtTHMR_P_EngPwrWasteHVACEcoModeHTSOV[0])), 7U);

    /* Lookup_n-D: '<S1715>/Vector' incorporates:
     *  Switch: '<S1472>/Switch2'
     */
    VeTHMR_P_EngPwrWaste_EngHot = look1_iflf_binlcapw(rtb_Switch2_i1, ((const
        float32 *)&(KxTHMR_P_EngPwrWaste_Availb[0])), ((const float32 *)
        &(KtTHMR_P_EngPwrWaste_Availb[0])), 7U);

    /* Switch: '<S1472>/Switch8' incorporates:
     *  Constant: '<S1690>/Constant'
     *  Constant: '<S1707>/Calib'
     *  Logic: '<S1472>/Logical7'
     *  RelationalOperator: '<S1472>/Comparison4'
     *  Switch: '<S3948>/Switch'
     */
    if ((((uint32)VeTHMR_e_EngStartStopSt_AD) == CeESSR_e_EngRunning) &&
            (KeTHMR_b_HVACEcoModHTSOVOpnEngRunVsHot))
    {
        /* Switch: '<S1472>/Switch8' */
        VeTHMR_P_EngPwrWaste_AvailbRaw_Unfltrd = VeTHMR_P_EngPwrWaste_EngOn;
    }
    else
    {
        /* Switch: '<S1472>/Switch8' */
        VeTHMR_P_EngPwrWaste_AvailbRaw_Unfltrd = VeTHMR_P_EngPwrWaste_EngHot;
    }

    /* End of Switch: '<S1472>/Switch8' */

    /* Outputs for Atomic SubSystem: '<S1472>/EdgeRising' */
    /* Logic: '<S1689>/OR1' incorporates:
     *  UnitDelay: '<S1689>/UnitDelay'
     */
    rtb_RelationalOperator7_p = !THMR_ac_DW.UnitDelay_DSTATE_pd;

    /* Update for UnitDelay: '<S1689>/UnitDelay' incorporates:
     *  Constant: '<S1472>/TRUEConstant'
     */
    THMR_ac_DW.UnitDelay_DSTATE_pd = true;

    /* End of Outputs for SubSystem: '<S1472>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S1472>/DigitalLowpassResetEnabled' */
    /* UnitDelay: '<S1688>/UnitDelay' */
    rtb_Switch1_giu = THMR_ac_DW.UnitDelay_DSTATE_o3;

    /* Outputs for Atomic SubSystem: '<S1472>/EdgeRising' */
    /* Switch: '<S1688>/Switch1' incorporates:
     *  Logic: '<S1689>/AND'
     */
    if (rtb_RelationalOperator7_p)
    {
        /* Switch: '<S1688>/Switch1' incorporates:
         *  Constant: '<S1472>/ConstantValue2'
         */
        VeTHMR_P_EngPwrWaste_AvailbRaw = 0.0F;
    }
    else
    {
        /* Switch: '<S1688>/Switch1' incorporates:
         *  Constant: '<S1713>/Calib'
         *  Product: '<S1688>/Multiplication'
         *  Sum: '<S1688>/Subtraction'
         *  Sum: '<S1688>/Summation'
         */
        VeTHMR_P_EngPwrWaste_AvailbRaw =
            ((VeTHMR_P_EngPwrWaste_AvailbRaw_Unfltrd - rtb_Switch1_giu) *
             KeTHMR_k_EngPwrWasteAvail_FltrCoeff) + rtb_Switch1_giu;
    }

    /* End of Switch: '<S1688>/Switch1' */
    /* End of Outputs for SubSystem: '<S1472>/EdgeRising' */

    /* Update for UnitDelay: '<S1688>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_o3 = VeTHMR_P_EngPwrWaste_AvailbRaw;

    /* End of Outputs for SubSystem: '<S1472>/DigitalLowpassResetEnabled' */

    /* Outputs for Atomic SubSystem: '<S1472>/Hysteresis2' */
    /* Switch: '<S1694>/Switch1' incorporates:
     *  Constant: '<S1701>/Calib'
     *  RelationalOperator: '<S1694>/GreaterThan'
     */
    if (rtb_Switch2_i1 > KeTHMR_T_ECT_EngPwrWaste_MinHi)
    {
        /* Switch: '<S1694>/Switch1' incorporates:
         *  Constant: '<S1694>/ConstantValue'
         */
        rtb_RelationalOperator7_p = true;
    }
    else
    {
        /* Switch: '<S1694>/Switch1' incorporates:
         *  Constant: '<S1702>/Calib'
         *  RelationalOperator: '<S1694>/GreaterThan1'
         *  UnitDelay: '<S1694>/UnitDelay'
         */
        rtb_RelationalOperator7_p = ((rtb_Switch2_i1 >=
            KeTHMR_T_ECT_EngPwrWaste_MinLo) && (THMR_ac_DW.UnitDelay_DSTATE_a2));
    }

    /* End of Switch: '<S1694>/Switch1' */

    /* Update for UnitDelay: '<S1694>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_a2 = rtb_RelationalOperator7_p;

    /* End of Outputs for SubSystem: '<S1472>/Hysteresis2' */

    /* Logic: '<S1472>/Logical3' incorporates:
     *  Constant: '<S1705>/Calib'
     *  Logic: '<S1472>/Logical4'
     */
    VeTHMR_b_EngPwrWaste_NonZero = (rtb_RelationalOperator7_p ||
        (rtb_TmpSignalConversionAtVeTR_i && (KeTHMR_b_EnblWasteCalc_WithAHPEnbl)));

    /* Switch: '<S1472>/Switch4' incorporates:
     *  Constant: '<S1691>/Constant'
     *  Constant: '<S1692>/Constant'
     *  Constant: '<S1708>/Calib'
     *  Constant: '<S1710>/Calib'
     *  Logic: '<S1472>/Logical10'
     *  Logic: '<S1472>/Logical11'
     *  Logic: '<S1472>/Logical12'
     *  Logic: '<S1472>/Logical8'
     *  Logic: '<S1472>/Logical9'
     *  RelationalOperator: '<S1472>/Comparison1'
     *  RelationalOperator: '<S1472>/Comparison2'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     */
    if (((((((uint32)rtb_TmpSignalConversionAtVeTR_f) != CeTRIR_e_MAX_AC) ||
            (!KeTHMR_b_MaxAC_EnblDcrs_EngPwrWaste)) ||
            rtb_TmpSignalConversionAtVeTR_k) && (VeTHMR_b_EngPwrWaste_NonZero)) &&
        ((((uint32)rtb_TmpSignalConversionAtVePD_l) == CePDTR_e_No_Dischrg) ||
            (KeTHMR_b_OvrrdDischrgChk_AvailEngPwr)))
    {
        /* Switch: '<S1472>/Switch4' */
        rtb_TmpSignalConversionAtVeTA_b = VeTHMR_P_EngPwrWaste_AvailbRaw;
    }
    else
    {
        /* Switch: '<S1472>/Switch4' incorporates:
         *  Constant: '<S1697>/Calib'
         */
        rtb_TmpSignalConversionAtVeTA_b = KeTHMR_P_EngPwrWaste_AvailMin;
    }

    /* End of Switch: '<S1472>/Switch4' */

    /* Switch: '<S1472>/Switch1' incorporates:
     *  Constant: '<S1472>/ConstantValue3'
     */
    if (THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0)
    {
        rtb_Switch10 = 0.0F;
    }
    else
    {
        rtb_Switch10 = rtb_TmpSignalConversionAtVeTA_b;
    }

    /* End of Switch: '<S1472>/Switch1' */

    /* Sum: '<S1472>/Subtraction1' */
    rtb_Switch1_giu = VeTHMR_P_Cab_N_Bat_HeatPwrTot_Limtd - rtb_Switch10;

    /* Outputs for Atomic SubSystem: '<S1472>/Limiter' */
    /* Switch: '<S1716>/Switch1' incorporates:
     *  Constant: '<S1695>/Calib'
     *  RelationalOperator: '<S1716>/RelationalOperator'
     */
    if (KeTHMR_P_ActvTotPwr_Max < rtb_Switch1_giu)
    {
        /* Switch: '<S1425>/Switch1' */
        rtb_Switch1_giu = KeTHMR_P_ActvTotPwr_Max;
    }

    /* End of Switch: '<S1716>/Switch1' */

    /* Switch: '<S1716>/Switch' incorporates:
     *  Constant: '<S1696>/Calib'
     *  RelationalOperator: '<S1716>/RelationalOperator1'
     */
    if (rtb_Switch1_giu > KeTHMR_P_ActvTotPwr_Min)
    {
        /* Switch: '<S1716>/Switch' */
        VeTHMR_P_ActvTotPwr = rtb_Switch1_giu;
    }
    else
    {
        /* Switch: '<S1716>/Switch' */
        VeTHMR_P_ActvTotPwr = KeTHMR_P_ActvTotPwr_Min;
    }

    /* End of Switch: '<S1716>/Switch' */
    /* End of Outputs for SubSystem: '<S1472>/Limiter' */

    /* Product: '<S2108>/Product' incorporates:
     *  Lookup_n-D: '<S2107>/Vector'
     *  SignalConversion generated from: '<S2>/VeTMIR_T_ElecClntHtr_TmpIn'
     *  Sum: '<S2108>/Add3'
     */
    VeTHMR_P_WCondWasteHeat_Net = ((rtb_TmpSignalConversionAtVeHT_o -
        rtb_TmpSignalConversionAtVeT_n0) * rtb_TmpSignalConversionAtVePM_n) *
        look1_iflf_binlcapw(rtb_TmpSignalConversionAtVeT_n0, ((const float32 *)
        &(KxTHMR_K_CoolantHeatCap[0])), ((const float32 *)
        &(KtTHMR_K_CoolantHeatCap[0])), 5U);

    /* Switch: '<S2104>/Switch2' incorporates:
     *  Constant: '<S2106>/Calib'
     */
    if (KeTHMR_b_EnblWCondHeat_CabAssist)
    {
        /* Switch: '<S2104>/Switch2' */
        rtb_Switch1_giu = VeTHMR_P_WCondWasteHeat_Net;
    }
    else
    {
        /* Switch: '<S2104>/Switch2' incorporates:
         *  Constant: '<S2104>/Constant'
         */
        rtb_Switch1_giu = 0.0F;
    }

    /* End of Switch: '<S2104>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S2104>/Limiter3' */
    /* Switch: '<S2110>/Switch1' incorporates:
     *  Constant: '<S2109>/Calib'
     *  RelationalOperator: '<S2110>/RelationalOperator'
     */
    if (KeTHMR_P_WCondHeat_Cabin_Assist_Max < rtb_Switch1_giu)
    {
        /* Switch: '<S1425>/Switch1' */
        rtb_Switch1_giu = KeTHMR_P_WCondHeat_Cabin_Assist_Max;
    }

    /* End of Switch: '<S2110>/Switch1' */

    /* Switch: '<S2110>/Switch' incorporates:
     *  Constant: '<S2104>/Constant7'
     *  RelationalOperator: '<S2110>/RelationalOperator1'
     */
    if (rtb_Switch1_giu > 0.0F)
    {
        /* Switch: '<S2110>/Switch' */
        VeTHMR_P_WCondWasteHeat_Avail_B4Grd = rtb_Switch1_giu;
    }
    else
    {
        /* Switch: '<S2110>/Switch' */
        VeTHMR_P_WCondWasteHeat_Avail_B4Grd = 0.0F;
    }

    /* End of Switch: '<S2110>/Switch' */
    /* End of Outputs for SubSystem: '<S2104>/Limiter3' */

    /* Outputs for Atomic SubSystem: '<S2105>/GradientLimiter' */
    /* Switch: '<S1425>/Switch1' incorporates:
     *  UnitDelay: '<S2111>/UnitDelay'
     */
    rtb_Switch1_giu = THMR_ac_DW.UnitDelay_DSTATE_o;

    /* Sum: '<S2111>/Sum2' */
    rtb_Merge2_l = VeTHMR_P_WCondWasteHeat_Avail_B4Grd - rtb_Switch1_giu;

    /* Outputs for Atomic SubSystem: '<S2111>/Limiter' */
    /* Switch: '<S2114>/Switch1' incorporates:
     *  Constant: '<S2113>/Calib'
     *  RelationalOperator: '<S2114>/RelationalOperator'
     */
    if (KeTHMR_P_WCondHeat_Cabin_Assist_RtLimUp < rtb_Merge2_l)
    {
        /* Switch: '<S1153>/Switch3' */
        rtb_TmpSignalConversionAtVeHT_k =
            KeTHMR_P_WCondHeat_Cabin_Assist_RtLimUp;
    }
    else
    {
        /* Switch: '<S1153>/Switch3' */
        rtb_TmpSignalConversionAtVeHT_k = rtb_Merge2_l;
    }

    /* End of Switch: '<S2114>/Switch1' */

    /* Switch: '<S2114>/Switch' incorporates:
     *  Constant: '<S2112>/Calib'
     *  RelationalOperator: '<S2114>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeHT_k <=
            KeTHMR_P_WCondHeat_Cabin_Assist_RtLimDown)
    {
        rtb_TmpSignalConversionAtVeHT_k =
            KeTHMR_P_WCondHeat_Cabin_Assist_RtLimDown;
    }

    /* End of Switch: '<S2114>/Switch' */
    /* End of Outputs for SubSystem: '<S2111>/Limiter' */

    /* Sum: '<S2111>/Sum3' */
    rtb_Merge2_l = rtb_TmpSignalConversionAtVeHT_k + rtb_Switch1_giu;

    /* Update for UnitDelay: '<S2111>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_o = rtb_Merge2_l;

    /* End of Outputs for SubSystem: '<S2105>/GradientLimiter' */

    /* Lookup_n-D: '<S1987>/Vector' incorporates:
     *  SignalConversion generated from: '<S1148>/VariantSource'
     */
    rtb_Switch1_giu = look1_iflf_binlcapw(VeTHMR_r_BattCabPriorityRatio_Fin, ((
        const float32 *)&(KxTHMR_r_BattCabPrioRatioFrHTLVlv[0])), ((const
        float32 *)&(KtTHMR_r_BattCabPrioRatioFrHTLVlv[0])), 4U);

    /* If: '<S1164>/TempErr_HTLPosition' incorporates:
     *  Constant: '<S1976>/Constant'
     *  Constant: '<S1977>/Constant'
     *  Logic: '<S1164>/Logical3'
     *  RelationalOperator: '<S1164>/Comparison7'
     *  RelationalOperator: '<S1164>/Comparison8'
     */
    if ((CeTHMR_e_CabinActiveHeating == ((uint32)rtb_Switch1_o0g)) || (((uint32)
            rtb_Switch1_o0g) == CeTHMR_e_CabinActivePassiveHeating))
    {
        /* Outputs for IfAction SubSystem: '<S1164>/TempErr_CabBattHeating' incorporates:
         *  ActionPort: '<S1989>/ActionPort'
         */
        /* Switch: '<S1425>/Switch1' incorporates:
         *  Constant: '<S1989>/ConstantValue'
         *  Inport: '<S57>/CTRR_T_HtrCorClnt_Tmp_In'
         *  Product: '<S1989>/Product'
         *  Product: '<S1989>/Product1'
         *  Sum: '<S1989>/Add1'
         *  Sum: '<S1989>/Add2'
         *  Sum: '<S1989>/Add3'
         *  Sum: '<S1989>/Sum1'
         */
        rtb_Switch1_giu = ((THMR_ac_B.Vector_h - THMR_ac_B.Switch1_j) *
                           rtb_Switch1_giu) - ((1.0F - rtb_Switch1_giu) *
            (rtb_TmpSignalConversionAtVeCTRR - VeTHMR_T_HtrCorClnt_Tmp_In_AD));

        /* End of Outputs for SubSystem: '<S1164>/TempErr_CabBattHeating' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1164>/TempError_BattHeating' incorporates:
         *  ActionPort: '<S1990>/ActionPort'
         */
        /* Switch: '<S1425>/Switch1' incorporates:
         *  Sum: '<S1990>/Add1'
         */
        rtb_Switch1_giu = THMR_ac_B.Vector_h - THMR_ac_B.Switch1_j;

        /* End of Outputs for SubSystem: '<S1164>/TempError_BattHeating' */
    }

    /* End of If: '<S1164>/TempErr_HTLPosition' */

    /* Switch: '<S1164>/Switch5' incorporates:
     *  Switch: '<S1164>/Switch1'
     */
    if (THMR_ac_B.Switch_i)
    {
        /* Switch: '<S1164>/Switch1' incorporates:
         *  Constant: '<S1164>/Constant2'
         */
        if (!rtb_LogicalOperator_lw)
        {
            rtb_Switch1_giu = 0.0F;
        }

        /* Switch: '<S1164>/Switch5' incorporates:
         *  Constant: '<S1986>/Calib'
         *  Constant: '<S1991>/ConstantValue'
         *  Product: '<S1991>/Product'
         *  Product: '<S1991>/Product1'
         *  Sum: '<S1164>/Add1'
         *  Sum: '<S1991>/Add2'
         *  Sum: '<S1991>/Sum1'
         */
        rtb_TmpSignalConversionAtVeHT_k = (rtb_Switch1_giu *
            KeTHMR_r_WCondPrioRatioFrHTLVlv) - ((1.0F -
            KeTHMR_r_WCondPrioRatioFrHTLVlv) * (THMR_ac_B.MinMax_j -
            rtb_TmpSignalConversionAtVeT_n0));
    }
    else if (rtb_LogicalOperator_lw)
    {
        /* Switch: '<S1164>/Switch1' incorporates:
         *  Switch: '<S1164>/Switch5'
         */
        rtb_TmpSignalConversionAtVeHT_k = rtb_Switch1_giu;
    }
    else
    {
        /* Switch: '<S1164>/Switch5' incorporates:
         *  Constant: '<S1164>/Constant2'
         *  Switch: '<S1164>/Switch1'
         */
        rtb_TmpSignalConversionAtVeHT_k = 0.0F;
    }

    /* End of Switch: '<S1164>/Switch5' */

    /* Logic: '<S1477>/Logical5' incorporates:
     *  Constant: '<S1481>/Calib'
     *  RelationalOperator: '<S1477>/Comparison5'
     */
    rtb_RelationalOperator_nw = ((TmpSignalConversionAtOutAirTemp <=
        KeTHMR_T_EngAllowd_EVMode_AmbTempMax) && (VeTHMR_b_Defrost));

    /* Logic: '<S1478>/Logical1' incorporates:
     *  Constant: '<S1482>/Calib'
     *  Constant: '<S1484>/Calib'
     *  RelationalOperator: '<S1478>/Comparison1'
     *  RelationalOperator: '<S1478>/Comparison3'
     */
    VeTHMR_b_AmbCabHeat_EngAllwd_AD = ((TmpSignalConversionAtOutAirTemp >=
        KeTHMR_T_EngAllowd_AmbTempMin) && (TmpSignalConversionAtOutAirTemp <=
        KeTHMR_T_EngAllowd_AmbTempMax1));

    /* Logic: '<S1478>/Logical3' incorporates:
     *  Constant: '<S1482>/Calib'
     *  Constant: '<S1483>/Calib'
     *  RelationalOperator: '<S1478>/Comparison2'
     *  RelationalOperator: '<S1478>/Comparison4'
     */
    VeTHMR_b_AmbHardCab_HeatEngAllwd_AD = (((KeTHMR_T_EngAllowd_AmbTempMax1 <
        TmpSignalConversionAtOutAirTemp) && (TmpSignalConversionAtOutAirTemp <=
        KeTHMR_T_EngAllowd_AmbTempMax2)) && rtb_TmpSignalConversionAtVeCT_c);

    /* Logic: '<S1478>/Logical4' incorporates:
     *  Constant: '<S1485>/Calib'
     */
    VeTHMR_b_HardCabHeatEng_Allwd_AD = (rtb_TmpSignalConversionAtVeCT_c &&
        (KeTHMR_b_HardCabHeatEng_AllwdEnb));

    /* Switch: '<S1462>/Switch' incorporates:
     *  Constant: '<S1475>/Calib'
     *  Constant: '<S1479>/Constant'
     *  Constant: '<S1480>/Calib'
     *  Logic: '<S1473>/LogicalOperator'
     *  RelationalOperator: '<S1473>/RelationalOperator'
     *  SignalConversion generated from: '<S2>/VeDMIR_e_DrvMdRaw'
     *  Switch: '<S1462>/Switch1'
     */
    if (KeTHMR_b_EngAllowd_AmbTemp_Slct)
    {
        /* Switch: '<S1462>/Switch' incorporates:
         *  Constant: '<S1476>/Calib'
         */
        VeTHMR_b_CabinHeatEng_Allwd_AD = KeTHMR_b_EngAllowd_AmbTemp_dial;
    }
    else if ((((uint32)rtb_TmpSignalConversionAtVeDMIR) == CeDMDR_e_EV) &&
             (KeTHMR_b_SupressThrmlEngOn_EVMode))
    {
        /* Switch: '<S1462>/Switch1' incorporates:
         *  Switch: '<S1462>/Switch'
         */
        VeTHMR_b_CabinHeatEng_Allwd_AD = rtb_RelationalOperator_nw;
    }
    else
    {
        /* Switch: '<S1462>/Switch' incorporates:
         *  Logic: '<S1478>/Logical2'
         *  Switch: '<S1462>/Switch1'
         */
        VeTHMR_b_CabinHeatEng_Allwd_AD = (((VeTHMR_b_AmbCabHeat_EngAllwd_AD) ||
            (VeTHMR_b_AmbHardCab_HeatEngAllwd_AD)) ||
            (VeTHMR_b_HardCabHeatEng_Allwd_AD));
    }

    /* End of Switch: '<S1462>/Switch' */

    /* RelationalOperator: '<S1497>/RelationalOperator7' incorporates:
     *  Constant: '<S1526>/Constant'
     */
    rtb_RelationalOperator7_p = (CeTHMR_e_BatteryHeating == ((uint32)tmp_c));

    /* RelationalOperator: '<S1497>/RelationalOperator' incorporates:
     *  Constant: '<S1528>/Constant'
     */
    rtb_OR1_bn = (((uint32)tmp_c) == CeTHMR_e_CabinHeating);

    /* Logic: '<S1497>/LogicalOperator' incorporates:
     *  Constant: '<S1530>/Constant'
     *  RelationalOperator: '<S1497>/RelationalOperator2'
     */
    rtb_LogicalOperator_lw = ((rtb_RelationalOperator7_p || rtb_OR1_bn) ||
        (((uint32)tmp_c) == CeTHMR_e_BatteryNCabinHeating));

    /* Logic: '<S1508>/Logical Operator' incorporates:
     *  Constant: '<S1508>/Constant1'
     *  Constant: '<S1508>/Constant2'
     *  RelationalOperator: '<S1508>/Relational Operator1'
     *  RelationalOperator: '<S1508>/Relational Operator2'
     */
    VeTHMR_b_U1008_DTCSet = ((VeTHMR_b_BCH_U1008_DTCSet_tmp != 0U) &&
        (VeTHMR_b_BCH_U1008_DTCSet_tmp_0 == 0U));

    /* RelationalOperator: '<S1559>/Comparison5' incorporates:
     *  Constant: '<S1518>/Calib'
     *  Logic: '<S1496>/LogicalOperator4'
     */
    rtb_VariantMerge_For_Variant_da = ((KeTHMR_b_LIN1BusOff_HtrFlty_RA) &&
        (VeTHMR_b_U1008_DTCSet));

    /* Logic: '<S1509>/Logical Operator' incorporates:
     *  Constant: '<S1509>/Constant1'
     *  Constant: '<S1509>/Constant2'
     *  RelationalOperator: '<S1509>/Relational Operator1'
     *  RelationalOperator: '<S1509>/Relational Operator2'
     */
    VeTHMR_b_U1009_DTCSet = ((tmpRead_1b != 0U) &&
        (VeTHMR_b_BCH_U1009_DTCSet_tmp == 0U));

    /* Logic: '<S1497>/LogicalOperator2' incorporates:
     *  Constant: '<S1519>/Calib'
     *  Logic: '<S1496>/LogicalOperator5'
     */
    Gain_cm = ((KeTHMR_b_LIN2BusOff_HtrFlty_RA) && (VeTHMR_b_U1009_DTCSet));

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* S-Function (sfix_bitop): '<S1510>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S1510>/StatusByte_LostCommCoolHtrA'
     *  S-Function (sfix_bitop): '<S4967>/Bitwise Operator2'
     */
    VeTHMR_b_BCH_U1008_DTCSet_tmp = ((uint32)
        THMR_ac_DW.StatusByte_LostCommCoolHtrA) & 1U;

    /* S-Function (sfix_bitop): '<S1510>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S1510>/StatusByte_LostCommCoolHtrA'
     *  S-Function (sfix_bitop): '<S4967>/Bitwise Operator1'
     */
    VeTHMR_b_BCH_U1008_DTCSet_tmp_0 = ((uint32)
        THMR_ac_DW.StatusByte_LostCommCoolHtrA) & 64U;

    /* Logic: '<S1510>/Logical Operator' incorporates:
     *  Constant: '<S1510>/Constant1'
     *  Constant: '<S1510>/Constant2'
     *  RelationalOperator: '<S1510>/Relational Operator1'
     *  RelationalOperator: '<S1510>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S1510>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1510>/Bitwise Operator2'
     */
    VeTHMR_b_U1124_DTCSet = ((VeTHMR_b_BCH_U1008_DTCSet_tmp != 0U) &&
        (VeTHMR_b_BCH_U1008_DTCSet_tmp_0 == 0U));

    /* Logic: '<S1496>/LogicalOperator3' incorporates:
     *  Constant: '<S1517>/Calib'
     *  Logic: '<S1496>/LogicalOperator6'
     */
    rtb_OR1_jc2 = ((KeTHMR_b_HtrLOC_HtrFlty_RA) && (VeTHMR_b_U1124_DTCSet));

    /* Logic: '<S1505>/Logical Operator' incorporates:
     *  Constant: '<S1505>/Constant1'
     *  Constant: '<S1505>/Constant2'
     *  DataStoreRead: '<S1505>/StatusByte_ECH_TempOut'
     *  RelationalOperator: '<S1505>/Relational Operator1'
     *  RelationalOperator: '<S1505>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S1505>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1505>/Bitwise Operator2'
     */
    VeTHMR_b_P1B72_DTCSet = (((((uint32)THMR_ac_DW.StatusByte_ECH_TempOut) & 1U)
        != 0U) && ((((uint32)THMR_ac_DW.StatusByte_ECH_TempOut) & 64U) == 0U));

    /* Logic: '<S1504>/Logical Operator' incorporates:
     *  Constant: '<S1504>/Constant1'
     *  Constant: '<S1504>/Constant2'
     *  DataStoreRead: '<S1504>/StatusByte_ECH_TempIn'
     *  RelationalOperator: '<S1504>/Relational Operator1'
     *  RelationalOperator: '<S1504>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S1504>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1504>/Bitwise Operator2'
     */
    VeTHMR_b_P1B73_DTCSet = (((((uint32)THMR_ac_DW.StatusByte_ECH_TempIn) & 1U)
        != 0U) && ((((uint32)THMR_ac_DW.StatusByte_ECH_TempIn) & 64U) == 0U));

    /* RelationalOperator: '<S1507>/RelationalOperator' incorporates:
     *  Constant: '<S1507>/Constant'
     *  DataStoreRead: '<S1507>/StatusByte_InvData_ECH'
     *  S-Function (sfix_bitop): '<S1507>/BitwiseOperator7'
     */
    VeTHMR_b_U0425_DTCSet = ((((sint32)THMR_ac_DW.StatusByte_InvData_ECH) & 1) >
        0);

    /* RelationalOperator: '<S1158>/Comparison2' incorporates:
     *  Constant: '<S1499>/Constant'
     *  Constant: '<S1500>/Constant'
     *  Constant: '<S1502>/Constant'
     *  Constant: '<S1512>/Calib'
     *  Constant: '<S1513>/Calib'
     *  Constant: '<S1514>/Calib'
     *  Constant: '<S1515>/Calib'
     *  Logic: '<S1496>/LogicalOperator'
     *  Logic: '<S1496>/LogicalOperator1'
     *  Logic: '<S1496>/LogicalOperator7'
     *  Logic: '<S1496>/LogicalOperator8'
     *  Logic: '<S1496>/LogicalOperator9'
     *  RelationalOperator: '<S1496>/RelationalOperator'
     *  RelationalOperator: '<S1496>/RelationalOperator1'
     *  RelationalOperator: '<S1496>/RelationalOperator2'
     *  SignalConversion generated from: '<S2>/VeHTIR_e_HV_ElecClntHtr_Sts'
     */
    rtb_NotEqual_fo = ((KeTHMR_b_EnblHtr1_HtrFlty_RA) && ((((((((((((uint32)
        rtb_TmpSignalConversionAtVeHT_b) == CeHTIR_e_HtrSts_LockedUntilNextStart)
        || (((uint32)rtb_TmpSignalConversionAtVeHT_b) ==
            CeHTIR_e_HtrSts_LockedUntilService)) || (((uint32)
        rtb_TmpSignalConversionAtVeHT_b) == CeHTIR_e_HtrSts_LockedPermanent)) ||
        (THMR_ac_B.TmpSignalConversionAtVeHCDR_b_H)) ||
        rtb_VariantMerge_For_Variant_da) || Gain_cm) || rtb_OR1_jc2) ||
                          ((KeTHMR_b_ECHTmpOut_HtrFlty_RA) &&
                           (VeTHMR_b_P1B72_DTCSet))) ||
                         ((KeTHMR_b_ECHTmpIn_HtrFlty_RA) &&
                          (VeTHMR_b_P1B73_DTCSet))) ||
                        ((KeTHMR_b_ECHInvData_HtrFlty_RA) &&
                         (VeTHMR_b_U0425_DTCSet))));

    /* RelationalOperator: '<S1506>/RelationalOperator' incorporates:
     *  Constant: '<S1506>/Constant'
     *  DataStoreRead: '<S1506>/StatusByte_InvData_EAH'
     *  S-Function (sfix_bitop): '<S1506>/BitwiseOperator7'
     */
    VeTHMR_b_U148E_DTCSet = ((((sint32)THMR_ac_DW.StatusByte_InvData_EAH) & 1) >
        0);

    /* Logic: '<S1496>/LogicalOperator3' incorporates:
     *  Constant: '<S1498>/Constant'
     *  Constant: '<S1501>/Constant'
     *  Constant: '<S1503>/Constant'
     *  Constant: '<S1511>/Calib'
     *  Constant: '<S1516>/Calib'
     *  Logic: '<S1496>/LogicalOperator10'
     *  Logic: '<S1496>/LogicalOperator2'
     *  RelationalOperator: '<S1496>/RelationalOperator3'
     *  RelationalOperator: '<S1496>/RelationalOperator4'
     *  RelationalOperator: '<S1496>/RelationalOperator5'
     */
    rtb_OR1_jc2 = ((KeTHMR_b_EnblHtr2_HtrFlty_RA) && ((((((((((uint32)
                            rtb_TmpSignalConversionAtVeHT_m) ==
                           CeHTIR_e_HtrSts_LockedUntilNextStart) || (((uint32)
                            rtb_TmpSignalConversionAtVeHT_m) ==
                           CeHTIR_e_HtrSts_LockedUntilService)) || (((uint32)
                           rtb_TmpSignalConversionAtVeHT_m) ==
                          CeHTIR_e_HtrSts_LockedPermanent)) ||
                        (THMR_ac_B.TmpSignalConversionAtVeHCDR_b_o)) ||
                       rtb_VariantMerge_For_Variant_da) || Gain_cm) ||
                     rtb_OR1_jc2) || ((KeTHMR_b_EAHInvData_HtrFlty_RA) &&
                     (VeTHMR_b_U148E_DTCSet))));

    /* Logic: '<S1497>/LogicalOperator2' */
    Gain_cm = (rtb_NotEqual_fo || rtb_OR1_jc2);

    /* Logic: '<S1497>/LogicalOperator1' */
    VeTHMR_b_EngAllow_HeatReq_HtrFlty_RA_B4_Sw = (rtb_LogicalOperator_lw &&
        Gain_cm);

    /* Switch: '<S1497>/Switch1' incorporates:
     *  Constant: '<S1536>/Calib'
     */
    if (KeTHMR_b_HtrFltyEngAllw_SD)
    {
        /* Switch: '<S1497>/Switch1' incorporates:
         *  Constant: '<S1535>/Calib'
         */
        VeTHMR_b_EngAllow_HeatReq_HtrFlty_RA = KeTHMR_b_HtrFltyEngAllw_D;
    }
    else
    {
        /* Switch: '<S1497>/Switch1' */
        VeTHMR_b_EngAllow_HeatReq_HtrFlty_RA =
            VeTHMR_b_EngAllow_HeatReq_HtrFlty_RA_B4_Sw;
    }

    /* End of Switch: '<S1497>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S1465>/Hysteresis' */
    /* Switch: '<S1491>/Switch1' incorporates:
     *  Constant: '<S1493>/Calib'
     *  RelationalOperator: '<S1491>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeCT_i > ((float32)
            KeTHMR_T_HtrCrErr_Htr1Flty_RSP))
    {
        /* Switch: '<S1491>/Switch1' incorporates:
         *  Constant: '<S1491>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeCT_c = true;
    }
    else
    {
        /* Switch: '<S1491>/Switch1' incorporates:
         *  Constant: '<S1492>/Calib'
         *  RelationalOperator: '<S1491>/GreaterThan1'
         *  UnitDelay: '<S1491>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeCT_c = ((rtb_TmpSignalConversionAtVeCT_i >=
            ((float32)KeTHMR_T_HtrCrErr_Htr1Flty_LSP)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_fu));
    }

    /* End of Switch: '<S1491>/Switch1' */
    /* End of Outputs for SubSystem: '<S1465>/Hysteresis' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeCTRR_b_TurnOffEng_CabComfAchvd' */
    (void)Rte_Read_VeCTRR_b_TurnOffEng_CabComfAchvd_Value(&rtb_Switch1_az);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* Outputs for Atomic SubSystem: '<S1465>/Hysteresis' */
    /* Update for UnitDelay: '<S1491>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_fu = rtb_TmpSignalConversionAtVeCT_c;

    /* End of Outputs for SubSystem: '<S1465>/Hysteresis' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* S-Function (sfix_bitop): '<S1490>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S1490>/StatusByte_LostCommCoolPmpA'
     *  S-Function (sfix_bitop): '<S4428>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S4524>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S4968>/Bitwise Operator2'
     */
    rtb_Logical2_lz_tmp = ((uint32)THMR_ac_DW.StatusByte_LostCommCoolPmpA) & 1U;

    /* S-Function (sfix_bitop): '<S1490>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S1490>/StatusByte_LostCommCoolPmpA'
     *  S-Function (sfix_bitop): '<S4428>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4524>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4968>/Bitwise Operator1'
     */
    rtb_Logical2_lz_tmp_0 = ((uint32)THMR_ac_DW.StatusByte_LostCommCoolPmpA) &
        64U;

    /* S-Function (sfix_bitop): '<S1489>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S1489>/StatusByte_CoolPmpACtrlCktPerf'
     *  S-Function (sfix_bitop): '<S4523>/Bitwise Operator2'
     */
    rtb_Logical2_lz_tmp_1 = ((uint32)THMR_ac_DW.StatusByte_CoolPmpACtrlCktPerf)
        & 1U;

    /* S-Function (sfix_bitop): '<S1489>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S1489>/StatusByte_CoolPmpACtrlCktPerf'
     *  S-Function (sfix_bitop): '<S4523>/Bitwise Operator1'
     */
    rtb_Logical2_lz_tmp_2 = ((uint32)THMR_ac_DW.StatusByte_CoolPmpACtrlCktPerf)
        & 64U;

    /* Logic: '<S1465>/LogicalOperator' incorporates:
     *  Constant: '<S1488>/Constant'
     *  Constant: '<S1489>/Constant1'
     *  Constant: '<S1489>/Constant2'
     *  Constant: '<S1490>/Constant1'
     *  Constant: '<S1490>/Constant2'
     *  Constant: '<S1494>/Calib'
     *  Logic: '<S1465>/LogicalOperator1'
     *  Logic: '<S1465>/LogicalOperator2'
     *  Logic: '<S1465>/LogicalOperator3'
     *  Logic: '<S1489>/Logical Operator'
     *  Logic: '<S1490>/Logical Operator'
     *  RelationalOperator: '<S1465>/Comparison1'
     *  RelationalOperator: '<S1489>/Relational Operator1'
     *  RelationalOperator: '<S1489>/Relational Operator2'
     *  RelationalOperator: '<S1490>/Relational Operator1'
     *  RelationalOperator: '<S1490>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S1489>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1489>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1490>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1490>/Bitwise Operator2'
     *  Switch: '<S3792>/Switch'
     */
    rtb_Logical2_ioz = ((KeTHMR_b_HTSOV_Hyst_Enbl) &&
                        ((rtb_TmpSignalConversionAtVeCT_c && (((rtb_NotEqual_fo ||
        ((rtb_Logical2_lz_tmp != 0U) && (rtb_Logical2_lz_tmp_0 == 0U))) ||
                            ((rtb_Logical2_lz_tmp_1 != 0U) &&
        (rtb_Logical2_lz_tmp_2 == 0U))) || (CePMPR_e_FTSNA_True == ((uint32)
        VeTHMR_e_HTAuxPumpDryRun_AD)))) || (VeTHMR_b_AlternatorMode_Actv)));

    /* Logic: '<S1462>/Logical Operator1' incorporates:
     *  Logic: '<S1462>/LogicalOperator'
     */
    rtb_TmpSignalConversionAtVeCT_c = ((((VeTHMR_b_CabinHeatEng_Allwd_AD) ||
        (VeTHMR_b_EngAllow_HeatReq_HtrFlty_RA)) || rtb_Logical2_ioz) &&
        rtb_TmpSignalConversionAtPropSy);

    /* UnitDelay: '<S57>/UnitDelay4' */
    rtb_TmpSignalConversionAtVeBT_m = THMR_ac_DW.UnitDelay4_DSTATE_k;

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Switch: '<S1154>/Switch7' incorporates:
     *  Constant: '<S1463>/Constant'
     *  Constant: '<S1467>/Calib'
     *  Constant: '<S1486>/Constant'
     *  Constant: '<S1487>/Calib'
     *  Logic: '<S1154>/Logical5'
     *  Logic: '<S1154>/Logical6'
     *  Logic: '<S1464>/LogicalOperator'
     *  RelationalOperator: '<S1154>/Comparison6'
     *  RelationalOperator: '<S1464>/RelationalOperator'
     *  RelationalOperator: '<S2869>/RelationalOperator'
     *  SignalConversion generated from: '<S2>/VeDMIR_e_DrvMdRaw'
     *  Switch: '<S1154>/Switch4'
     *  Switch: '<S3945>/Switch'
     */
    if (((rtb_Switch_hql && (((uint32)VeTHMR_e_SSDR_KeySts) !=
                             CeSSDR_e_KeyPostCrnk)) &&
            (!rtb_TmpSignalConversionAtPropSy)) && (KeTHMR_b_DsblEngBlwr_RS))
    {
        /* RelationalOperator: '<S1158>/Comparison2' incorporates:
         *  Constant: '<S1468>/Calib'
         */
        rtb_NotEqual_fo = KeTHMR_b_NoEngReqBlwr_InRS;
    }
    else if ((((uint32)rtb_TmpSignalConversionAtVeDMIR) == CeDMDR_e_EV) &&
             (KeTHMR_b_SupressThrmlEngOn_EVMode))
    {
        /* Switch: '<S1154>/Switch4' incorporates:
         *  Logic: '<S1154>/Logical1'
         *  Logic: '<S1154>/LogicalOperator'
         *  RelationalOperator: '<S1158>/Comparison2'
         */
        rtb_NotEqual_fo = ((rtb_Switch1_az && rtb_TmpSignalConversionAtPropSy) &&
                           rtb_RelationalOperator_nw);
    }
    else
    {
        /* RelationalOperator: '<S1158>/Comparison2' incorporates:
         *  Logic: '<S1154>/Logical1'
         *  Switch: '<S1154>/Switch4'
         */
        rtb_NotEqual_fo = (rtb_Switch1_az && rtb_TmpSignalConversionAtPropSy);
    }

    /* End of Switch: '<S1154>/Switch7' */

    /* RelationalOperator: '<S1559>/Comparison5' incorporates:
     *  Constant: '<S1561>/Calib'
     */
    rtb_VariantMerge_For_Variant_da = (rtb_TmpSignalConversionAtVeTA_b >
        KeTHMR_P_EngHotPwr_Min);

    /* Switch: '<S1559>/Switch4' incorporates:
     *  Constant: '<S1563>/Calib'
     *  Logic: '<S1559>/Logical41'
     *  Logic: '<S1559>/Logical42'
     */
    if ((VeTHMR_b_AlternatorMode_Actv) || (rtb_Logical2_ioz &&
            (KeTHMR_b_Enbl_StateE_HtrFlty)))
    {
        /* RelationalOperator: '<S1158>/Comparison6' incorporates:
         *  Constant: '<S1559>/FALSEConstant'
         */
        rtb_TmpSignalConversionAtVeT_pw = false;
    }
    else
    {
        /* RelationalOperator: '<S1158>/Comparison6' incorporates:
         *  Constant: '<S1562>/Calib'
         *  RelationalOperator: '<S1559>/Comparison2'
         */
        rtb_TmpSignalConversionAtVeT_pw = (VeTHMR_P_ActvTotPwr <
            KeTHMR_P_HtrOff_ActvPwrMax);
    }

    /* End of Switch: '<S1559>/Switch4' */

    /* Logic: '<S1559>/Logical6' incorporates:
     *  Logic: '<S1559>/Logical10'
     *  RelationalOperator: '<S1559>/Comparison1'
     */
    rtb_Switch1_az = !rtb_TmpSignalConversionAtVeCT_c;

    /* Logic: '<S1559>/Logical' incorporates:
     *  Logic: '<S1559>/Logical1'
     *  RelationalOperator: '<S1559>/Comparison1'
     */
    Switch2_e = (rtb_VariantMerge_For_Variant_da &&
                 rtb_TmpSignalConversionAtVeCT_c);

    /* Logic: '<S1559>/Logical5' incorporates:
     *  Logic: '<S1559>/Logical14'
     *  Logic: '<S1559>/Logical6'
     */
    rtb_RelationalOperator_nw = (rtb_VariantMerge_For_Variant_da &&
        rtb_Switch1_az);

    /* Logic: '<S1559>/Logical4' incorporates:
     *  Logic: '<S1559>/Logical'
     *  Logic: '<S1559>/Logical5'
     */
    VeTHMR_b_Enbl_Ua = ((Switch2_e && rtb_TmpSignalConversionAtVeT_pw) ||
                        (rtb_RelationalOperator_nw &&
                         rtb_TmpSignalConversionAtVeT_pw));

    /* Logic: '<S1559>/Logical11' incorporates:
     *  Logic: '<S1559>/Logical12'
     */
    rtb_LogicalOperator1_fo = !rtb_VariantMerge_For_Variant_da;

    /* Logic: '<S1559>/Logical7' incorporates:
     *  Logic: '<S1559>/Logical11'
     *  Logic: '<S1559>/Logical18'
     *  RelationalOperator: '<S1559>/Comparison1'
     */
    rtb_VariantMerge_For_Variant_da = (rtb_LogicalOperator1_fo &&
        rtb_TmpSignalConversionAtVeCT_c);

    /* Logic: '<S1559>/Logical9' incorporates:
     *  Logic: '<S1559>/Logical20'
     */
    rtb_LogicalOperator1_fo = (rtb_LogicalOperator1_fo && rtb_Switch1_az);

    /* Logic: '<S1559>/Logical8' incorporates:
     *  Logic: '<S1559>/Logical7'
     *  Logic: '<S1559>/Logical9'
     */
    VeTHMR_b_Enbl_Ub = ((rtb_VariantMerge_For_Variant_da &&
                         rtb_TmpSignalConversionAtVeT_pw) ||
                        (rtb_LogicalOperator1_fo &&
                         rtb_TmpSignalConversionAtVeT_pw));

    /* Switch: '<S1472>/Switch3' incorporates:
     *  Constant: '<S1712>/Calib'
     */
    if (KeTHMR_b_PwrDstrbt_Slct)
    {
        /* Switch: '<S1472>/Switch3' */
        rtb_Switch1_giu = rtb_TmpSignalConversionAtVeTPDR;
    }
    else
    {
        /* Switch: '<S1472>/Switch3' */
        rtb_Switch1_giu = VeTHMR_P_PwrBdgt_PwrLimitAvail_BD;
    }

    /* End of Switch: '<S1472>/Switch3' */

    /* Outputs for Atomic SubSystem: '<S1740>/Hysteresis2' */
    /* Switch: '<S1754>/Switch1' incorporates:
     *  Constant: '<S1759>/Calib'
     *  RelationalOperator: '<S1754>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeHT_o > KeTHMR_T_ECH_ClntTmpIn_DratOn)
    {
        /* Switch: '<S1754>/Switch1' incorporates:
         *  Constant: '<S1754>/ConstantValue'
         */
        rtb_Switch1_az = true;
    }
    else
    {
        /* Switch: '<S1754>/Switch1' incorporates:
         *  Constant: '<S1758>/Calib'
         *  RelationalOperator: '<S1754>/GreaterThan1'
         *  UnitDelay: '<S1754>/UnitDelay'
         */
        rtb_Switch1_az = ((rtb_TmpSignalConversionAtVeHT_o >=
                           KeTHMR_T_ECH_ClntTmpIn_DratOff) &&
                          (THMR_ac_DW.UnitDelay_DSTATE_lf));
    }

    /* End of Switch: '<S1754>/Switch1' */

    /* Update for UnitDelay: '<S1754>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_lf = rtb_Switch1_az;

    /* End of Outputs for SubSystem: '<S1740>/Hysteresis2' */

    /* Switch: '<S1740>/Switch1' incorporates:
     *  Constant: '<S1761>/Calib'
     */
    if (KeTHMR_b_ECH_WshdPwr_UseClntTmp)
    {
        /* Switch: '<S1740>/Switch1' incorporates:
         *  Logic: '<S1740>/Logical3'
         */
        VeTHMR_b_HtrWishdPwr_LwClntTmp = !rtb_Switch1_az;
    }
    else
    {
        /* Switch: '<S1740>/Switch1' incorporates:
         *  Constant: '<S1740>/TRUEConstant1'
         */
        VeTHMR_b_HtrWishdPwr_LwClntTmp = true;
    }

    /* End of Switch: '<S1740>/Switch1' */

    /* Switch: '<S1740>/Switch' incorporates:
     *  Constant: '<S1740>/TRUEConstant'
     *  Constant: '<S1753>/Constant'
     *  Constant: '<S1760>/Calib'
     *  RelationalOperator: '<S1740>/Comparison5'
     *  UnitDelay: '<S57>/UnitDelay'
     */
    if (KeTHMR_b_ECH_WshdPwr_SkipHtrState)
    {
        rtb_TmpSignalConversionAtVePD_i = true;
    }
    else
    {
        rtb_TmpSignalConversionAtVePD_i = (((uint32)
            THMR_ac_DW.UnitDelay_DSTATE_pwv) != CeTHMR_e_HtrOn);
    }

    /* End of Switch: '<S1740>/Switch' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LT_Batt_Loop'
     */
    /* Logic: '<S1740>/Logical1' incorporates:
     *  Constant: '<S1751>/Constant'
     *  Constant: '<S1752>/Constant'
     *  Constant: '<S1755>/Calib'
     *  Constant: '<S1756>/Calib'
     *  Constant: '<S1757>/Calib'
     *  Logic: '<S1740>/Logical2'
     *  RelationalOperator: '<S1496>/RelationalOperator'
     *  RelationalOperator: '<S1740>/Comparison1'
     *  RelationalOperator: '<S1740>/Comparison2'
     *  RelationalOperator: '<S1740>/Comparison3'
     *  RelationalOperator: '<S1740>/Comparison4'
     *  RelationalOperator: '<S1740>/Comparison6'
     *  RelationalOperator: '<S3160>/Comparison10'
     *  SignalConversion generated from: '<S2>/VeHTIR_e_HV_ElecClntHtr_Sts'
     *  Switch: '<S3956>/Switch'
     */
    VeTHMR_b_HtrWishdPwr_StillNotAval = ((((((VeTHMR_P_ActvTotPwr >=
        KeTHMR_P_ActvPwr_htrReqMin) && (rtb_Switch1_giu >=
        KeTHMR_P_PwrBdgt_htrReqMin)) && (((uint32)VeTHMR_e_BatCntctrStat) ==
        CeHVTR_e_Closed)) && (rtb_TmpSignalConversionAtVePD_i &&
        (rtb_TmpSignalConversionAtVeHT_p <= KeTHMR_P_ECH_ActWhsdPwr_Min))) &&
        (((uint32)rtb_TmpSignalConversionAtVeHT_b) == CeHTIR_e_HtrSts_Off)) &&
        (VeTHMR_b_HtrWishdPwr_LwClntTmp));

    /* RelationalOperator: '<S1741>/Comparison1' incorporates:
     *  Constant: '<S1764>/Calib'
     */
    rtb_Switch1_az = (rtb_TmpSignalConversionAtVeHT_p >=
                      KeTHMR_P_ECH_WishdPwr_Up);

    /* Outputs for Atomic SubSystem: '<S1741>/TurnOnDelayTime' */
    /* Outputs for Atomic SubSystem: '<S1771>/EdgeRising' */
    /* Logic: '<S1772>/AND' incorporates:
     *  Logic: '<S1772>/OR1'
     *  UnitDelay: '<S1772>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeT_f5 = (rtb_Switch1_az &&
        (!THMR_ac_DW.UnitDelay_DSTATE_gb));

    /* Update for UnitDelay: '<S1772>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_gb = rtb_Switch1_az;

    /* End of Outputs for SubSystem: '<S1771>/EdgeRising' */

    /* Logic: '<S1771>/OR1' incorporates:
     *  Logic: '<S1771>/AND'
     */
    rtb_TmpSignalConversionAtVePD_i = !rtb_Switch1_az;

    /* Switch: '<S1771>/Switch1' incorporates:
     *  Logic: '<S1771>/OR'
     *  Logic: '<S1771>/OR1'
     */
    if (rtb_TmpSignalConversionAtVePD_i || rtb_TmpSignalConversionAtVeT_f5)
    {
        /* Switch: '<S1771>/Switch1' incorporates:
         *  Constant: '<S1771>/ConstantValue1'
         */
        Switch_o = 0.0F;
    }
    else
    {
        /* Switch: '<S1771>/Switch1' incorporates:
         *  Constant: '<S1741>/ConstantValue1'
         *  Constant: '<S1767>/Calib'
         *  MinMax: '<S1771>/Minimum'
         *  Sum: '<S1771>/Summation'
         *  UnitDelay: '<S1771>/UnitDelay'
         */
        Switch_o = fminf(KeTHMR_t_ECH_WshdPwrDelay,
                         THMR_ac_DW.UnitDelay_DSTATE_hb + 0.1F);
    }

    /* End of Switch: '<S1771>/Switch1' */

    /* Update for UnitDelay: '<S1771>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_hb = Switch_o;

    /* End of Outputs for SubSystem: '<S1741>/TurnOnDelayTime' */

    /* Outputs for Atomic SubSystem: '<S1741>/EdgeFalling' */
    /* Logic: '<S1762>/AND' incorporates:
     *  Logic: '<S1762>/OR1'
     *  UnitDelay: '<S1741>/UnitDelay'
     *  UnitDelay: '<S1762>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeT_f5 = ((!THMR_ac_DW.UnitDelay_DSTATE_jq) &&
        (THMR_ac_DW.UnitDelay_DSTATE_as));

    /* Update for UnitDelay: '<S1762>/UnitDelay' incorporates:
     *  UnitDelay: '<S1741>/UnitDelay'
     */
    THMR_ac_DW.UnitDelay_DSTATE_as = THMR_ac_DW.UnitDelay_DSTATE_jq;

    /* End of Outputs for SubSystem: '<S1741>/EdgeFalling' */

    /* Outputs for Atomic SubSystem: '<S1741>/SignalLatchOnWithReset1' */
    /* Outputs for Atomic SubSystem: '<S1741>/TurnOnDelayTime' */
    /* Logic: '<S1769>/OR1' incorporates:
     *  Constant: '<S1765>/Calib'
     *  Constant: '<S1767>/Calib'
     *  Logic: '<S1741>/Logical1'
     *  Logic: '<S1741>/Logical2'
     *  Logic: '<S1769>/NOT'
     *  Logic: '<S1769>/OR'
     *  Logic: '<S1771>/AND'
     *  RelationalOperator: '<S1771>/GreaterThan'
     *  UnitDelay: '<S1769>/UnitDelay'
     */
    VeTHMR_b_WishPwrStil_NotAvalLatch = ((VeTHMR_b_HtrWishdPwr_StillNotAval) ||
        ((((rtb_TmpSignalConversionAtVePD_i || (Switch_o <
        KeTHMR_t_ECH_WshdPwrDelay)) || (!KeTHMR_b_CheckExpectdPwr_Enb)) &&
          (!rtb_TmpSignalConversionAtVeT_f5)) && (THMR_ac_DW.UnitDelay_DSTATE_mu)));

    /* End of Outputs for SubSystem: '<S1741>/TurnOnDelayTime' */

    /* Update for UnitDelay: '<S1769>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_mu = VeTHMR_b_WishPwrStil_NotAvalLatch;

    /* End of Outputs for SubSystem: '<S1741>/SignalLatchOnWithReset1' */

    /* Switch: '<S1741>/Switch' incorporates:
     *  Constant: '<S1766>/Calib'
     */
    if (KeTHMR_b_ECH_WshdPwr_SkipLatch)
    {
        /* Switch: '<S1741>/Switch' */
        rtb_Switch1_az = VeTHMR_b_HtrWishdPwr_StillNotAval;
    }
    else
    {
        /* Switch: '<S1741>/Switch' */
        rtb_Switch1_az = VeTHMR_b_WishPwrStil_NotAvalLatch;
    }

    /* End of Switch: '<S1741>/Switch' */

    /* Outputs for Atomic SubSystem: '<S1741>/EdgeRising1' */
    /* Logic: '<S1763>/OR1' incorporates:
     *  UnitDelay: '<S1763>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeT_f5 = !THMR_ac_DW.UnitDelay_DSTATE_etx;

    /* Update for UnitDelay: '<S1763>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_etx = rtb_Switch1_az;

    /* Outputs for Atomic SubSystem: '<S1741>/TimerRetriggerResetEnabled' */
    /* Switch: '<S1770>/Switch1' incorporates:
     *  Logic: '<S1763>/AND'
     *  Switch: '<S1770>/Switch2'
     */
    if (rtb_Switch1_az && rtb_TmpSignalConversionAtVeT_f5)
    {
        /* Switch: '<S1770>/Switch1' incorporates:
         *  Constant: '<S1738>/Calib'
         */
        Switch_o = KeTHMR_t_ECH_WshdPwrNot_AvalTim;
    }
    else if (rtb_Switch1_az)
    {
        /* Switch: '<S1770>/Switch2' incorporates:
         *  Constant: '<S1741>/ConstantValue4'
         *  Constant: '<S1770>/ConstantValue4'
         *  MinMax: '<S1770>/Maximum'
         *  Sum: '<S1770>/Subtraction'
         *  Switch: '<S1770>/Switch1'
         *  UnitDelay: '<S1770>/UnitDelay'
         */
        Switch_o = fmaxf(THMR_ac_DW.UnitDelay_DSTATE_hc - 0.1F, 0.0F);
    }
    else
    {
        /* Switch: '<S1770>/Switch1' incorporates:
         *  Switch: '<S1770>/Switch2'
         *  UnitDelay: '<S1770>/UnitDelay'
         */
        Switch_o = THMR_ac_DW.UnitDelay_DSTATE_hc;
    }

    /* End of Switch: '<S1770>/Switch1' */
    /* End of Outputs for SubSystem: '<S1741>/EdgeRising1' */

    /* RelationalOperator: '<S1770>/GreaterThan1' incorporates:
     *  Constant: '<S1770>/ConstantValue2'
     */
    rtb_Switch1_az = (Switch_o > 0.0F);

    /* Update for UnitDelay: '<S1770>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_hc = Switch_o;

    /* End of Outputs for SubSystem: '<S1741>/TimerRetriggerResetEnabled' */

    /* Gain: '<S1768>/Gain' */
    VeTHMR_b_InitWishdPwr_Enb = rtb_Switch1_az;

    /* Outputs for Atomic SubSystem: '<S1739>/CountDownResetTriggerEnabled1' */
    /* Outputs for Atomic SubSystem: '<S1748>/EdgeRising' */
    /* Logic: '<S1750>/OR1' incorporates:
     *  UnitDelay: '<S1750>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeT_f5 = !THMR_ac_DW.UnitDelay_DSTATE_j3;

    /* Update for UnitDelay: '<S1750>/UnitDelay' incorporates:
     *  Constant: '<S1739>/TRUEConstant5'
     */
    THMR_ac_DW.UnitDelay_DSTATE_j3 = true;

    /* Switch: '<S1748>/Switch1' incorporates:
     *  Constant: '<S1748>/ConstantValue'
     *  Logic: '<S1750>/AND'
     *  RelationalOperator: '<S1748>/GreaterThan'
     *  Switch: '<S1748>/Switch2'
     *  UnitDelay: '<S1748>/UnitDelay'
     */
    if (rtb_TmpSignalConversionAtVeT_f5)
    {
        /* Switch: '<S1748>/Switch1' incorporates:
         *  Constant: '<S1749>/Calib'
         */
        Switch_o = KeTHMR_t_InitWshdPwr_StartUpTim;
    }
    else if (THMR_ac_DW.UnitDelay_DSTATE_gn > 0.0F)
    {
        /* Switch: '<S1748>/Switch2' incorporates:
         *  Constant: '<S1748>/ConstantValue1'
         *  Sum: '<S1748>/Subtraction'
         *  Switch: '<S1748>/Switch1'
         *  UnitDelay: '<S1748>/UnitDelay'
         */
        Switch_o = THMR_ac_DW.UnitDelay_DSTATE_gn - 1.0F;
    }
    else
    {
        /* Switch: '<S1748>/Switch1' incorporates:
         *  Switch: '<S1748>/Switch2'
         *  UnitDelay: '<S1748>/UnitDelay'
         */
        Switch_o = THMR_ac_DW.UnitDelay_DSTATE_gn;
    }

    /* End of Switch: '<S1748>/Switch1' */
    /* End of Outputs for SubSystem: '<S1748>/EdgeRising' */

    /* RelationalOperator: '<S1748>/GreaterThan1' incorporates:
     *  Constant: '<S1748>/ConstantValue2'
     */
    VeTHMR_b_InitWishPwr_StartUpEnb = (Switch_o > 0.0F);

    /* Update for UnitDelay: '<S1748>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_gn = Switch_o;

    /* End of Outputs for SubSystem: '<S1739>/CountDownResetTriggerEnabled1' */

    /* Switch: '<S1728>/Switch' incorporates:
     *  Constant: '<S1737>/Calib'
     */
    if (KeTHMR_b_ECH_WshdPwr_SkipTimer)
    {
        rtb_TmpSignalConversionAtVePD_i = VeTHMR_b_HtrWishdPwr_StillNotAval;
    }
    else
    {
        rtb_TmpSignalConversionAtVePD_i = VeTHMR_b_InitWishdPwr_Enb;
    }

    /* End of Switch: '<S1728>/Switch' */

    /* If: '<S1728>/If' */
    if (rtb_TmpSignalConversionAtVePD_i)
    {
        /* Outputs for IfAction SubSystem: '<S1728>/Initial_Wished_Power' incorporates:
         *  ActionPort: '<S1736>/ActionPort'
         */
        /* Switch: '<S1743>/Switch1' incorporates:
         *  Constant: '<S1746>/Calib'
         *  Constant: '<S1747>/Calib'
         *  Logic: '<S1736>/Logical1'
         *  RelationalOperator: '<S1736>/Comparison1'
         *  Switch: '<S1736>/Switch'
         */
        if ((VeTHMR_b_InitWishPwr_StartUpEnb) || (rtb_Switch2_i1 >=
                KeTHMR_T_EngClntTmp_LowWshdPwr))
        {
            /* Switch: '<S1736>/Switch' incorporates:
             *  Constant: '<S1745>/Calib'
             *  Constant: '<S1747>/Calib'
             */
            if (KeTHMR_b_ECH_WshdPwr_UsePwrBdgt)
            {
                rtb_Switch10 = rtb_Switch1_giu;
            }
            else
            {
                rtb_Switch10 = KeTHMR_P_ECH_PwrMax;
            }

            /* Switch: '<S1743>/Switch1' incorporates:
             *  Constant: '<S1744>/Calib'
             *  MinMax: '<S1736>/MinMax2'
             */
            VeTHMR_P_HtrWishdPwr_Init = fminf(KeTHMR_P_ECH_PwrLow, rtb_Switch10);
        }
        else
        {
            if (KeTHMR_b_ECH_WshdPwr_UsePwrBdgt)
            {
                /* Switch: '<S1736>/Switch' */
                rtb_Switch10 = rtb_Switch1_giu;
            }
            else
            {
                /* Switch: '<S1736>/Switch' incorporates:
                 *  Constant: '<S1745>/Calib'
                 */
                rtb_Switch10 = KeTHMR_P_ECH_PwrMax;
            }

            /* Switch: '<S1743>/Switch1' incorporates:
             *  Constant: '<S1745>/Calib'
             *  MinMax: '<S1736>/MinMax1'
             */
            VeTHMR_P_HtrWishdPwr_Init = fminf(rtb_Switch10, KeTHMR_P_ECH_PwrMax);
        }

        /* End of Switch: '<S1743>/Switch1' */

        /* Merge: '<S1728>/Merge' incorporates:
         *  SignalConversion: '<S1736>/SignalConversion'
         */
        VeTHMR_P_AdjstdHtrWishd_Pwr_old = VeTHMR_P_HtrWishdPwr_Init;

        /* End of Outputs for SubSystem: '<S1728>/Initial_Wished_Power' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1728>/Actual_Wished_Power' incorporates:
         *  ActionPort: '<S1735>/ActionPort'
         */
        /* Gain: '<S1742>/Gain' */
        VeTHMR_P_HtrWishdPwr_Expctd = rtb_TmpSignalConversionAtVeHT_p;

        /* Merge: '<S1728>/Merge' incorporates:
         *  SignalConversion: '<S1735>/SignalConversion'
         */
        VeTHMR_P_AdjstdHtrWishd_Pwr_old = VeTHMR_P_HtrWishdPwr_Expctd;

        /* End of Outputs for SubSystem: '<S1728>/Actual_Wished_Power' */
    }

    /* End of If: '<S1728>/If' */

    /* Outputs for Atomic SubSystem: '<S1729>/Hysteresis1' */
    /* Switch: '<S1775>/Switch1' incorporates:
     *  Constant: '<S1782>/Calib'
     *  RelationalOperator: '<S1775>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeHT_o > KeTHMR_T_ECH_ClntTmpIn_DratOn)
    {
        /* Switch: '<S1775>/Switch1' incorporates:
         *  Constant: '<S1775>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeT_f5 = true;
    }
    else
    {
        /* Switch: '<S1775>/Switch1' incorporates:
         *  Constant: '<S1781>/Calib'
         *  RelationalOperator: '<S1775>/GreaterThan1'
         *  UnitDelay: '<S1775>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeT_f5 = ((rtb_TmpSignalConversionAtVeHT_o >=
            KeTHMR_T_ECH_ClntTmpIn_DratOff) && (THMR_ac_DW.UnitDelay_DSTATE_nug));
    }

    /* End of Switch: '<S1775>/Switch1' */

    /* Update for UnitDelay: '<S1775>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_nug = rtb_TmpSignalConversionAtVeT_f5;

    /* End of Outputs for SubSystem: '<S1729>/Hysteresis1' */

    /* Switch: '<S1729>/Switch2' incorporates:
     *  Constant: '<S1784>/Calib'
     */
    if (KeTHMR_b_ECH_WshdPwr_UseClntTmp)
    {
        /* RelationalOperator: '<S1158>/Comparison7' incorporates:
         *  Logic: '<S1729>/Logical4'
         */
        rtb_TmpSignalConversionAtVeT_f5 = !rtb_TmpSignalConversionAtVeT_f5;
    }
    else
    {
        /* RelationalOperator: '<S1158>/Comparison7' incorporates:
         *  Constant: '<S1729>/TRUEConstant1'
         */
        rtb_TmpSignalConversionAtVeT_f5 = true;
    }

    /* End of Switch: '<S1729>/Switch2' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LT_Batt_Loop'
     */
    /* Logic: '<S1729>/Logical1' incorporates:
     *  Constant: '<S1773>/Constant'
     *  Constant: '<S1774>/Constant'
     *  Constant: '<S1778>/Calib'
     *  Constant: '<S1779>/Calib'
     *  Constant: '<S1780>/Calib'
     *  Constant: '<S1792>/Constant'
     *  Constant: '<S1793>/Constant'
     *  Constant: '<S1794>/Constant'
     *  Logic: '<S1729>/Logical2'
     *  Logic: '<S1734>/LogicalOperator'
     *  RelationalOperator: '<S1496>/RelationalOperator'
     *  RelationalOperator: '<S1729>/Comparison10'
     *  RelationalOperator: '<S1729>/Comparison4'
     *  RelationalOperator: '<S1729>/Comparison6'
     *  RelationalOperator: '<S1729>/Comparison7'
     *  RelationalOperator: '<S1729>/Comparison9'
     *  RelationalOperator: '<S1734>/RelationalOperator'
     *  RelationalOperator: '<S1734>/RelationalOperator1'
     *  RelationalOperator: '<S1734>/RelationalOperator2'
     *  RelationalOperator: '<S3160>/Comparison10'
     *  SignalConversion generated from: '<S2>/VeHTIR_e_HV_ElecClntHtr_Sts'
     *  Switch: '<S3956>/Switch'
     */
    rtb_TmpSignalConversionAtVeT_f5 = (((((((VeTHMR_P_ActvTotPwr >=
        KeTHMR_P_ActvPwr_htrReqMin) && (rtb_Switch1_giu >=
        KeTHMR_P_PwrBdgt_htrReqMin)) && (((uint32)
        rtb_TmpSignalConversionAtVeHT_b) == CeHTIR_e_HtrSts_Operation)) &&
        (((((uint32)rtb_TmpSignalConversionAtVeHT_b) !=
           CeHTIR_e_HtrSts_LockedUntilNextStart) && (((uint32)
        rtb_TmpSignalConversionAtVeHT_b) != CeHTIR_e_HtrSts_LockedUntilService))
         && (((uint32)rtb_TmpSignalConversionAtVeHT_b) !=
             CeHTIR_e_HtrSts_LockedPermanent))) &&
        (rtb_TmpSignalConversionAtVeHT_p > KeTHMR_P_ECH_ActWhsdPwr_Min)) &&
        ((((uint32)VeTHMR_e_BatCntctrStat) == CeHVTR_e_Closed) ||
         (VeTHMR_b_AlternatorMode_Actv))) && rtb_TmpSignalConversionAtVeT_f5);

    /* Outputs for Atomic SubSystem: '<S1729>/TurnOnDelayTime' */
    /* Outputs for Atomic SubSystem: '<S1788>/EdgeRising' */
    /* Logic: '<S1790>/AND' incorporates:
     *  Logic: '<S1790>/OR1'
     *  UnitDelay: '<S1790>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeTM_j = (rtb_TmpSignalConversionAtVeT_f5 &&
        (!THMR_ac_DW.UnitDelay_DSTATE_k5));

    /* Update for UnitDelay: '<S1790>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_k5 = rtb_TmpSignalConversionAtVeT_f5;

    /* End of Outputs for SubSystem: '<S1788>/EdgeRising' */

    /* Switch: '<S1788>/Switch1' incorporates:
     *  Logic: '<S1788>/OR'
     *  Logic: '<S1788>/OR1'
     */
    if ((!rtb_TmpSignalConversionAtVeT_f5) || rtb_TmpSignalConversionAtVeTM_j)
    {
        /* Switch: '<S1788>/Switch1' incorporates:
         *  Constant: '<S1788>/ConstantValue1'
         */
        rtb_TmpSignalConversionAtVeHT_o = 0.0F;
    }
    else
    {
        /* Switch: '<S1788>/Switch1' incorporates:
         *  Constant: '<S1729>/ConstantValue2'
         *  Constant: '<S1786>/Calib'
         *  MinMax: '<S1788>/Minimum'
         *  Sum: '<S1788>/Summation'
         *  UnitDelay: '<S1788>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeHT_o = fminf(KeTHMR_t_ECH_WshdPwrNot_AvalTim,
            THMR_ac_DW.UnitDelay_DSTATE_c0 + 0.1F);
    }

    /* End of Switch: '<S1788>/Switch1' */

    /* Logic: '<S1788>/AND' incorporates:
     *  Constant: '<S1786>/Calib'
     *  RelationalOperator: '<S1788>/GreaterThan'
     */
    VeTHMR_b_ECHWshdPwrInitialized = (rtb_TmpSignalConversionAtVeT_f5 &&
        (rtb_TmpSignalConversionAtVeHT_o >= KeTHMR_t_ECH_WshdPwrNot_AvalTim));

    /* Update for UnitDelay: '<S1788>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_c0 = rtb_TmpSignalConversionAtVeHT_o;

    /* End of Outputs for SubSystem: '<S1729>/TurnOnDelayTime' */

    /* Lookup_n-D: '<S1787>/Vector' incorporates:
     *  Switch: '<S1472>/Switch2'
     */
    rtb_TmpSignalConversionAtVeHT_o = look1_iflf_binlcapw(rtb_Switch2_i1, ((
        const float32 *)&(KxTHMR_P_ECHWishdPowerLimInit_ECT[0])), ((const
        float32 *)&(KtTHMR_P_ECHWishdPowerLimInit_ECT[0])), 5U);

    /* Switch: '<S1777>/Switch1' */
    if (VeTHMR_b_ECHWshdPwrInitialized)
    {
        /* Switch: '<S1777>/Switch1' */
        VeTHMR_P_AdjstdHtrWishd_Pwr_New = rtb_TmpSignalConversionAtVeHT_p;
    }
    else
    {
        /* Switch: '<S1777>/Switch1' */
        VeTHMR_P_AdjstdHtrWishd_Pwr_New = rtb_TmpSignalConversionAtVeHT_o;
    }

    /* End of Switch: '<S1777>/Switch1' */

    /* RelationalOperator: '<S1729>/Comparison1' incorporates:
     *  Constant: '<S1783>/Calib'
     */
    rtb_TmpSignalConversionAtVeT_f5 = (rtb_TmpSignalConversionAtVeHT_h >
        KeTHMR_T_OutletTempTooHigh);

    /* Outputs for Atomic SubSystem: '<S1729>/TurnOnDelayTime1' */
    /* Outputs for Atomic SubSystem: '<S1789>/EdgeRising' */
    /* Logic: '<S1791>/AND' incorporates:
     *  Logic: '<S1791>/OR1'
     *  UnitDelay: '<S1791>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeTM_j = (rtb_TmpSignalConversionAtVeT_f5 &&
        (!THMR_ac_DW.UnitDelay_DSTATE_am));

    /* Update for UnitDelay: '<S1791>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_am = rtb_TmpSignalConversionAtVeT_f5;

    /* End of Outputs for SubSystem: '<S1789>/EdgeRising' */

    /* Switch: '<S1789>/Switch1' incorporates:
     *  Logic: '<S1789>/OR'
     *  Logic: '<S1789>/OR1'
     */
    if ((!rtb_TmpSignalConversionAtVeT_f5) || rtb_TmpSignalConversionAtVeTM_j)
    {
        /* Switch: '<S1789>/Switch1' incorporates:
         *  Constant: '<S1789>/ConstantValue1'
         */
        rtb_TmpSignalConversionAtVeHT_p = 0.0F;
    }
    else
    {
        /* Switch: '<S1789>/Switch1' incorporates:
         *  Constant: '<S1729>/ConstantValue1'
         *  Constant: '<S1785>/Calib'
         *  MinMax: '<S1789>/Minimum'
         *  Sum: '<S1789>/Summation'
         *  UnitDelay: '<S1789>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeHT_p = fminf(KeTHMR_t_DerationTime,
            THMR_ac_DW.UnitDelay_DSTATE_id + 0.1F);
    }

    /* End of Switch: '<S1789>/Switch1' */

    /* Update for UnitDelay: '<S1789>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_id = rtb_TmpSignalConversionAtVeHT_p;

    /* End of Outputs for SubSystem: '<S1729>/TurnOnDelayTime1' */

    /* Switch: '<S1730>/Switch1' incorporates:
     *  Constant: '<S1732>/Calib'
     *  Constant: '<S1733>/Calib'
     *  Constant: '<S1785>/Calib'
     *  Logic: '<S1789>/AND'
     *  RelationalOperator: '<S1789>/GreaterThan'
     *  Switch: '<S1717>/Switch1'
     *  Switch: '<S1776>/Switch1'
     */
    if (KeTHMR_b_OvrrdWishedHtrPwr)
    {
        /* Switch: '<S1730>/Switch1' incorporates:
         *  Constant: '<S1731>/Calib'
         */
        VeTHMR_P_AdjstdHtrWishd_Pwr = KeTHMR_P_OvrrdWishedHtrPwr;
    }
    else if (KeTHMR_b_ECHWishedPwr_OldApp)
    {
        /* Switch: '<S1717>/Switch1' incorporates:
         *  Switch: '<S1730>/Switch1'
         */
        VeTHMR_P_AdjstdHtrWishd_Pwr = VeTHMR_P_AdjstdHtrWishd_Pwr_old;
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S1729>/TurnOnDelayTime1' */
        if (rtb_TmpSignalConversionAtVeT_f5 && (rtb_TmpSignalConversionAtVeHT_p >=
             KeTHMR_t_DerationTime))
        {
            /* Switch: '<S1776>/Switch1' incorporates:
             *  Switch: '<S1717>/Switch1'
             *  Switch: '<S1730>/Switch1'
             */
            VeTHMR_P_AdjstdHtrWishd_Pwr = VeTHMR_P_AdjstdHtrWishd_Pwr_New;
        }
        else
        {
            /* Switch: '<S1730>/Switch1' incorporates:
             *  Switch: '<S1717>/Switch1'
             *  Switch: '<S1776>/Switch1'
             */
            VeTHMR_P_AdjstdHtrWishd_Pwr = rtb_TmpSignalConversionAtVeHT_o;
        }

        /* End of Outputs for SubSystem: '<S1729>/TurnOnDelayTime1' */
    }

    /* End of Switch: '<S1730>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeCTRR_P_ErrBasedHeatPwr' */
    (void)Rte_Read_VeCTRR_P_ErrBasedHeatPwr_Value(&rtb_Switch1_pi);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* Switch: '<S1472>/Switch6' incorporates:
     *  Constant: '<S1699>/Calib'
     *  Constant: '<S1706>/Calib'
     *  Logic: '<S1472>/LogicalOperator2'
     */
    if (rtb_OR1_jc2 && (KeTHMR_b_Enbl_Htr2Flty_ExpctdPwr))
    {
        rtb_TmpSignalConversionAtVeHT_p = KeTHMR_P_Htr2Flty_ExpctdPwr;
    }
    else
    {
        rtb_TmpSignalConversionAtVeHT_p = rtb_Switch1_giu;
    }

    /* End of Switch: '<S1472>/Switch6' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Switch: '<S1693>/Switch' incorporates:
     *  Constant: '<S1693>/Constant'
     *  Constant: '<S1718>/Constant'
     *  Constant: '<S1719>/Constant'
     *  Constant: '<S1720>/Constant'
     *  Constant: '<S1721>/Calib'
     *  Constant: '<S1722>/Calib'
     *  Constant: '<S1723>/Calib'
     *  Constant: '<S1724>/Calib'
     *  Constant: '<S1725>/Calib'
     *  Constant: '<S1726>/Calib'
     *  Logic: '<S1693>/LogicalOperator'
     *  Logic: '<S1693>/LogicalOperator1'
     *  Logic: '<S1693>/LogicalOperator2'
     *  Logic: '<S1693>/LogicalOperator3'
     *  Logic: '<S1693>/LogicalOperator4'
     *  Logic: '<S1693>/LogicalOperator5'
     *  Logic: '<S1693>/LogicalOperator6'
     *  Logic: '<S1693>/LogicalOperator7'
     *  Lookup_n-D: '<S1727>/Vector'
     *  RelationalOperator: '<S1693>/RelationalOperator'
     *  RelationalOperator: '<S1693>/RelationalOperator1'
     *  RelationalOperator: '<S1693>/RelationalOperator2'
     *  RelationalOperator: '<S1693>/RelationalOperator3'
     *  RelationalOperator: '<S2869>/RelationalOperator'
     *  SignalConversion generated from: '<S2>/VeBTRR_T_CellTempMinUsed'
     *  Switch: '<S244>/Switch'
     *  Switch: '<S3945>/Switch'
     */
    if (((((look2_iflf_binlcapw(rtb_TmpSignalConversionAtVeBT_o,
                                VeTHMR_Pct_HV_BatSOC, ((const float32 *)
              &(KxTHMR_n_HghSOC_LwTmp_BattRng[0])), ((const float32 *)
              &(KyTHMR_n_HghSOC_LwTmp_BattRng[0])), ((const float32 *)
              &(KtTHMR_n_HghSOC_LwTmp_BattRng[0])), THMR_ac_ConstP.pooled44, 6U)
            >= 10.0F) && rtb_TmpSignalConversionAtVeB_jd) &&
            ((!rtb_TmpSignalConversionAtPropSy) ||
             (KeTHMR_b_DsblPSA_HghSOC_LwTmp))) && ((((CeSSDR_e_KeyOff ==
             ((uint32)VeTHMR_e_SSDR_KeySts)) && (KeTHMR_b_KeyOff_HghSOC_LwTmp)) ||
           ((CeSSDR_e_KeyAccy == ((uint32)VeTHMR_e_SSDR_KeySts)) &&
            (KeTHMR_b_KeyAcc_HghSOC_LwTmp))) || ((((uint32)VeTHMR_e_SSDR_KeySts)
            == CeSSDR_e_KeyRun) && (KeTHMR_b_KeyRun_HghSOC_LwTmp)))) &&
            ((THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0) ||
             (KeTHMR_b_DsblPWup_HghSOC_LwTmp)))
    {
        rtb_Switch10 = KeTHMR_P_HghSOC_LwTmp_Pwr;
    }
    else
    {
        rtb_Switch10 = rtb_Switch1_giu;
    }

    /* End of Switch: '<S1693>/Switch' */

    /* Switch: '<S1425>/Switch1' incorporates:
     *  MinMax: '<S1472>/MinMax'
     */
    rtb_Switch1_giu = fminf(fminf(fminf(rtb_Switch1_giu,
        VeTHMR_P_AdjstdHtrWishd_Pwr), rtb_TmpSignalConversionAtVeHT_p),
                            rtb_Switch10);

    /* Sum: '<S1472>/Subtraction2' incorporates:
     *  Constant: '<S1700>/Calib'
     */
    VeTHMR_P_PwrAvaiConstraint = rtb_Switch1_giu - KeTHMR_P_PwrLimitMargin_Dial;

    /* RelationalOperator: '<S1472>/Comparison3' */
    VeTHMR_b_TotPwrLess_ThanLimit = (VeTHMR_P_ActvTotPwr <
        VeTHMR_P_PwrAvaiConstraint);

    /* Logic: '<S1472>/LogicalOperator' incorporates:
     *  Constant: '<S1469>/Calib'
     *  Constant: '<S1698>/Calib'
     *  RelationalOperator: '<S1472>/RelationalOperator'
     */
    VeTHMR_b_NoEngReqP1P4 = (((!KeTHMR_b_UseSepPwr_P1P4) ||
        (!rtb_TmpSignalConversionAtPropSy)) || (rtb_Switch1_pi <
        KeTHMR_P_ExtraHVACPwr));

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Switch: '<S1472>/Switch5' incorporates:
     *  Constant: '<S1687>/Constant'
     *  Constant: '<S1704>/Calib'
     *  Logic: '<S1472>/Logical5'
     *  Logic: '<S1472>/Logical6'
     *  RelationalOperator: '<S1472>/Comparison6'
     *  RelationalOperator: '<S2869>/RelationalOperator'
     *  Switch: '<S3945>/Switch'
     */
    if (((rtb_Switch_hql && (((uint32)VeTHMR_e_SSDR_KeySts) !=
                             CeSSDR_e_KeyPostCrnk)) &&
            (!rtb_TmpSignalConversionAtPropSy)) && (KeTHMR_b_DsblEngReq_RS))
    {
        /* Switch: '<S1472>/Switch5' incorporates:
         *  Constant: '<S1709>/Calib'
         */
        VeTHMR_b_TotPwrLess_ThanLimit_RS = KeTHMR_b_NoEngReq_InRS;
    }
    else
    {
        /* Switch: '<S1472>/Switch5' incorporates:
         *  Logic: '<S1472>/LogicalOperator1'
         *  Logic: '<S1472>/LogicalOperator3'
         */
        VeTHMR_b_TotPwrLess_ThanLimit_RS = (((VeTHMR_b_TotPwrLess_ThanLimit) &&
            (VeTHMR_b_NoEngReqP1P4)) && (!rtb_Logical2_ioz));
    }

    /* End of Switch: '<S1472>/Switch5' */

    /* Logic: '<S1559>/Logical13' incorporates:
     *  Logic: '<S1559>/Logical15'
     *  Logic: '<S1559>/Logical19'
     *  Logic: '<S1559>/Logical21'
     */
    rtb_TmpSignalConversionAtVeT_f5 = !rtb_TmpSignalConversionAtVeT_pw;

    /* Logic: '<S1559>/Logical1' incorporates:
     *  Logic: '<S1559>/Logical13'
     *  Logic: '<S1559>/Logical2'
     */
    rtb_TmpSignalConversionAtVeT_pw = (Switch2_e &&
        rtb_TmpSignalConversionAtVeT_f5);

    /* Logic: '<S1559>/Logical14' incorporates:
     *  Logic: '<S1559>/Logical31'
     */
    rtb_Logical2_ioz = (rtb_RelationalOperator_nw &&
                        rtb_TmpSignalConversionAtVeT_f5);

    /* Logic: '<S1559>/Logical16' incorporates:
     *  Logic: '<S1559>/Logical1'
     *  Logic: '<S1559>/Logical14'
     *  RelationalOperator: '<S1559>/Comparison4'
     */
    VeTHMR_b_Enbl_Uc = ((rtb_TmpSignalConversionAtVeT_pw &&
                         (VeTHMR_b_TotPwrLess_ThanLimit_RS)) ||
                        (rtb_Logical2_ioz && (VeTHMR_b_TotPwrLess_ThanLimit_RS)));

    /* Logic: '<S1559>/Logical18' incorporates:
     *  Logic: '<S1559>/Logical23'
     */
    rtb_VariantMerge_For_Variant_da = (rtb_VariantMerge_For_Variant_da &&
        rtb_TmpSignalConversionAtVeT_f5);

    /* Logic: '<S1559>/Logical20' incorporates:
     *  Logic: '<S1559>/Logical32'
     */
    rtb_TmpSignalConversionAtVeT_f5 = (rtb_LogicalOperator1_fo &&
        rtb_TmpSignalConversionAtVeT_f5);

    /* Logic: '<S1559>/Logical22' incorporates:
     *  Logic: '<S1559>/Logical18'
     *  Logic: '<S1559>/Logical20'
     *  RelationalOperator: '<S1559>/Comparison4'
     */
    VeTHMR_b_Enbl_Ud = ((rtb_VariantMerge_For_Variant_da &&
                         (VeTHMR_b_TotPwrLess_ThanLimit_RS)) ||
                        (rtb_TmpSignalConversionAtVeT_f5 &&
                         (VeTHMR_b_TotPwrLess_ThanLimit_RS)));

    /* Outputs for IfAction SubSystem: '<S1164>/HTR_nd_Vlv_fr_ActvPsv_Heating' incorporates:
     *  ActionPort: '<S1979>/ActionPort'
     */
    /* Outputs for IfAction SubSystem: '<S1164>/HTR_nd_Vlv_fr_Actv_Heating' incorporates:
     *  ActionPort: '<S1980>/ActionPort'
     */
    /* If: '<S1164>/CabinHeat_Rqst_and_CPV3_Position' incorporates:
     *  Logic: '<S1164>/Logical29'
     *  Logic: '<S1559>/Logical29'
     *  Logic: '<S1559>/Logical30'
     *  Logic: '<S1559>/Logical34'
     *  Logic: '<S1559>/Logical38'
     *  Logic: '<S1979>/Logical29'
     *  Logic: '<S1980>/Logical29'
     *  RelationalOperator: '<S1559>/Comparison4'
     */
    rtb_LogicalOperator1_fo = !VeTHMR_b_TotPwrLess_ThanLimit_RS;

    /* End of Outputs for SubSystem: '<S1164>/HTR_nd_Vlv_fr_Actv_Heating' */
    /* End of Outputs for SubSystem: '<S1164>/HTR_nd_Vlv_fr_ActvPsv_Heating' */

    /* Logic: '<S1559>/Logical27' incorporates:
     *  Logic: '<S1559>/Logical2'
     *  Logic: '<S1559>/Logical23'
     *  Logic: '<S1559>/Logical30'
     */
    VeTHMR_b_Enbl_Ue = ((rtb_TmpSignalConversionAtVeT_pw &&
                         rtb_LogicalOperator1_fo) ||
                        (rtb_VariantMerge_For_Variant_da &&
                         rtb_LogicalOperator1_fo));

    /* Logic: '<S1559>/Logical31' */
    VeTHMR_b_Enbl_Uf = (rtb_Logical2_ioz && rtb_LogicalOperator1_fo);

    /* Logic: '<S1559>/Logical32' */
    VeTHMR_b_Enbl_Ug = (rtb_TmpSignalConversionAtVeT_f5 &&
                        rtb_LogicalOperator1_fo);

    /* Switch: '<S1576>/Switch1' incorporates:
     *  Switch: '<S1572>/Switch1'
     *  Switch: '<S1573>/Switch1'
     *  Switch: '<S1574>/Switch1'
     *  Switch: '<S1575>/Switch1'
     *  Switch: '<S1577>/Switch1'
     *  Switch: '<S1578>/Switch1'
     */
    if (VeTHMR_b_Enbl_Ua)
    {
        /* Switch: '<S1576>/Switch1' incorporates:
         *  Constant: '<S1568>/Constant'
         */
        VeTHMR_e_EngHtr_HTSOV_State = CeTHMR_e_StateA;
    }
    else if (VeTHMR_b_Enbl_Ub)
    {
        /* Switch: '<S1572>/Switch1' incorporates:
         *  Constant: '<S1569>/Constant'
         *  Switch: '<S1576>/Switch1'
         */
        VeTHMR_e_EngHtr_HTSOV_State = CeTHMR_e_StateB;
    }
    else if (VeTHMR_b_Enbl_Uc)
    {
        /* Switch: '<S1573>/Switch1' incorporates:
         *  Constant: '<S1570>/Constant'
         *  Switch: '<S1572>/Switch1'
         *  Switch: '<S1576>/Switch1'
         */
        VeTHMR_e_EngHtr_HTSOV_State = CeTHMR_e_StateC;
    }
    else if (VeTHMR_b_Enbl_Ud)
    {
        /* Switch: '<S1574>/Switch1' incorporates:
         *  Constant: '<S1571>/Constant'
         *  Switch: '<S1572>/Switch1'
         *  Switch: '<S1573>/Switch1'
         *  Switch: '<S1576>/Switch1'
         */
        VeTHMR_e_EngHtr_HTSOV_State = CeTHMR_e_StateD;
    }
    else if (VeTHMR_b_Enbl_Ue)
    {
        /* Switch: '<S1575>/Switch1' incorporates:
         *  Constant: '<S1567>/Constant'
         *  Switch: '<S1572>/Switch1'
         *  Switch: '<S1573>/Switch1'
         *  Switch: '<S1574>/Switch1'
         *  Switch: '<S1576>/Switch1'
         */
        VeTHMR_e_EngHtr_HTSOV_State = CeTHMR_e_StateE;
    }
    else if (VeTHMR_b_Enbl_Uf)
    {
        /* Switch: '<S1577>/Switch1' incorporates:
         *  Constant: '<S1566>/Constant'
         *  Switch: '<S1572>/Switch1'
         *  Switch: '<S1573>/Switch1'
         *  Switch: '<S1574>/Switch1'
         *  Switch: '<S1575>/Switch1'
         *  Switch: '<S1576>/Switch1'
         */
        VeTHMR_e_EngHtr_HTSOV_State = CeTHMR_e_StateF;
    }
    else if (VeTHMR_b_Enbl_Ug)
    {
        /* Switch: '<S1578>/Switch1' incorporates:
         *  Constant: '<S1565>/Constant'
         *  Switch: '<S1572>/Switch1'
         *  Switch: '<S1573>/Switch1'
         *  Switch: '<S1574>/Switch1'
         *  Switch: '<S1575>/Switch1'
         *  Switch: '<S1576>/Switch1'
         *  Switch: '<S1577>/Switch1'
         */
        VeTHMR_e_EngHtr_HTSOV_State = CeTHMR_e_StateG;
    }
    else
    {
        /* Switch: '<S1576>/Switch1' incorporates:
         *  Constant: '<S1564>/Constant'
         *  Switch: '<S1572>/Switch1'
         *  Switch: '<S1573>/Switch1'
         *  Switch: '<S1574>/Switch1'
         *  Switch: '<S1575>/Switch1'
         *  Switch: '<S1577>/Switch1'
         *  Switch: '<S1578>/Switch1'
         */
        VeTHMR_e_EngHtr_HTSOV_State = CeTHMR_e_NoStateSlctd;
    }

    /* End of Switch: '<S1576>/Switch1' */

    /* RelationalOperator: '<S1466>/RelationalOperator' incorporates:
     *  Constant: '<S1495>/Constant'
     *  Switch: '<S1576>/Switch1'
     */
    rtb_OR1_jc2 = (((uint32)VeTHMR_e_EngHtr_HTSOV_State) == CeTHMR_e_StateE);

    /* Outputs for Atomic SubSystem: '<S1497>/EdgeFalling1' */
    /* Logic: '<S1521>/AND' incorporates:
     *  Logic: '<S1521>/OR1'
     *  UnitDelay: '<S1521>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant_da = ((!rtb_OR1_jc2) &&
        (THMR_ac_DW.UnitDelay_DSTATE_fd));

    /* Update for UnitDelay: '<S1521>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_fd = rtb_OR1_jc2;

    /* End of Outputs for SubSystem: '<S1497>/EdgeFalling1' */

    /* UnitDelay: '<S1497>/UnitDelay' */
    rtb_OR1_jc2 = THMR_ac_DW.UnitDelay_DSTATE_ecz;

    /* Outputs for Atomic SubSystem: '<S1497>/EdgeFalling' */
    /* Logic: '<S1520>/AND' incorporates:
     *  Logic: '<S1520>/OR1'
     *  UnitDelay: '<S1520>/UnitDelay'
     */
    rtb_Logical2_ioz = ((!rtb_OR1_jc2) && (THMR_ac_DW.UnitDelay_DSTATE_m55));

    /* Update for UnitDelay: '<S1520>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_m55 = rtb_OR1_jc2;

    /* End of Outputs for SubSystem: '<S1497>/EdgeFalling' */

    /* Outputs for Atomic SubSystem: '<S1497>/SignalLatchOnWithReset1' */
    /* Logic: '<S1541>/OR1' incorporates:
     *  Constant: '<S1537>/Calib'
     *  Logic: '<S1497>/LogicalOperator4'
     *  Logic: '<S1497>/LogicalOperator8'
     *  Logic: '<S1541>/NOT'
     *  Logic: '<S1541>/OR'
     *  UnitDelay: '<S1541>/UnitDelay'
     */
    VeTHMR_b_HeatReqTmrEnbld_HtrFlty_RA = (((rtb_VariantMerge_For_Variant_da &&
        Gain_cm) && (rtb_LogicalOperator_lw || (KeTHMR_b_ResetOnNewHeatReq))) ||
        ((!rtb_Logical2_ioz) && (THMR_ac_DW.UnitDelay_DSTATE_pce)));

    /* Update for UnitDelay: '<S1541>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_pce = VeTHMR_b_HeatReqTmrEnbld_HtrFlty_RA;

    /* End of Outputs for SubSystem: '<S1497>/SignalLatchOnWithReset1' */

    /* Outputs for Atomic SubSystem: '<S1497>/EdgeRising1' */
    /* UnitDelay: '<S1428>/UnitDelay' incorporates:
     *  UnitDelay: '<S1523>/UnitDelay'
     */
    rtb_LogicalOperator_lw = THMR_ac_DW.UnitDelay_DSTATE_bnb;

    /* Update for UnitDelay: '<S1523>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_bnb = VeTHMR_b_HeatReqTmrEnbld_HtrFlty_RA;

    /* End of Outputs for SubSystem: '<S1497>/EdgeRising1' */

    /* RelationalOperator: '<S1497>/RelationalOperator6' incorporates:
     *  Constant: '<S1527>/Constant'
     */
    Gain_cm = (((uint32)tmp_c) == CeTHMR_e_BatteryHeating);

    /* Outputs for Atomic SubSystem: '<S1497>/EdgeRising2' */
    /* Logic: '<S1524>/AND' incorporates:
     *  Logic: '<S1524>/OR1'
     *  UnitDelay: '<S1524>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant_da = (Gain_cm &&
        (!THMR_ac_DW.UnitDelay_DSTATE_d4));

    /* Update for UnitDelay: '<S1524>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_d4 = Gain_cm;

    /* End of Outputs for SubSystem: '<S1497>/EdgeRising2' */

    /* RelationalOperator: '<S1497>/RelationalOperator5' incorporates:
     *  Constant: '<S1529>/Constant'
     */
    rtb_OR1_jc2 = (((uint32)tmp_c) == CeTHMR_e_CabinHeating);

    /* Outputs for Atomic SubSystem: '<S1497>/EdgeRising' */
    /* Logic: '<S1522>/AND' incorporates:
     *  Logic: '<S1522>/OR1'
     *  UnitDelay: '<S1522>/UnitDelay'
     */
    Gain_cm = (rtb_OR1_jc2 && (!THMR_ac_DW.UnitDelay_DSTATE_cdz));

    /* Update for UnitDelay: '<S1522>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_cdz = rtb_OR1_jc2;

    /* End of Outputs for SubSystem: '<S1497>/EdgeRising' */

    /* RelationalOperator: '<S1497>/RelationalOperator8' incorporates:
     *  Constant: '<S1531>/Constant'
     */
    rtb_OR1_jc2 = (((uint32)tmp_c) == CeTHMR_e_BatteryNCabinHeating);

    /* Outputs for Atomic SubSystem: '<S1497>/EdgeRising3' */
    /* Logic: '<S1525>/AND' incorporates:
     *  Logic: '<S1525>/OR1'
     *  UnitDelay: '<S1525>/UnitDelay'
     */
    rtb_Logical2_ioz = (rtb_OR1_jc2 && (!THMR_ac_DW.UnitDelay_DSTATE_jh));

    /* Update for UnitDelay: '<S1525>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_jh = rtb_OR1_jc2;

    /* End of Outputs for SubSystem: '<S1497>/EdgeRising3' */

    /* Logic: '<S1497>/LogicalOperator5' incorporates:
     *  Logic: '<S1497>/LogicalOperator6'
     */
    VeTHMR_b_NewHeatReqReset_HtrFlty_RA = (((rtb_VariantMerge_For_Variant_da ||
        Gain_cm) || rtb_Logical2_ioz) && (VeTHMR_b_HeatReqTmrEnbld_HtrFlty_RA));

    /* Switch: '<S1532>/Switch1' incorporates:
     *  Switch: '<S1532>/Switch2'
     */
    if (rtb_RelationalOperator7_p)
    {
        /* Switch: '<S1532>/Switch1' incorporates:
         *  Constant: '<S1538>/Calib'
         */
        VeTHMR_t_TmrDuration_HtrFlty_RA = KeTHMR_t_BatHtTm_HtrFlty;
    }
    else if (rtb_OR1_bn)
    {
        /* Switch: '<S1532>/Switch2' incorporates:
         *  Constant: '<S1540>/Calib'
         *  Switch: '<S1532>/Switch1'
         */
        VeTHMR_t_TmrDuration_HtrFlty_RA = KeTHMR_t_CabHtTm_HtrFlty;
    }
    else
    {
        /* Switch: '<S1532>/Switch1' incorporates:
         *  Constant: '<S1539>/Calib'
         *  Switch: '<S1532>/Switch2'
         */
        VeTHMR_t_TmrDuration_HtrFlty_RA = KeTHMR_t_BothHtTm_HtrFlty;
    }

    /* End of Switch: '<S1532>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S1497>/TimerRetriggerResetEnabled' */
    /* Outputs for Atomic SubSystem: '<S1497>/EdgeRising1' */
    /* Switch: '<S1542>/Switch1' incorporates:
     *  Logic: '<S1497>/Logical1'
     *  Logic: '<S1523>/AND'
     *  Logic: '<S1523>/OR1'
     *  Switch: '<S1542>/Switch2'
     */
    if (((VeTHMR_b_HeatReqTmrEnbld_HtrFlty_RA) && (!rtb_LogicalOperator_lw)) ||
            (VeTHMR_b_NewHeatReqReset_HtrFlty_RA))
    {
        /* Switch: '<S1542>/Switch1' */
        rtb_Switch1_pi = VeTHMR_t_TmrDuration_HtrFlty_RA;
    }
    else if (VeTHMR_b_HeatReqTmrEnbld_HtrFlty_RA)
    {
        /* Switch: '<S1542>/Switch2' incorporates:
         *  Constant: '<S1497>/Constant5'
         *  Constant: '<S1542>/ConstantValue4'
         *  MinMax: '<S1542>/Maximum'
         *  Sum: '<S1542>/Subtraction'
         *  Switch: '<S1542>/Switch1'
         *  UnitDelay: '<S1542>/UnitDelay'
         */
        rtb_Switch1_pi = fmaxf(THMR_ac_DW.UnitDelay_DSTATE_js - 0.1F, 0.0F);
    }
    else
    {
        /* Switch: '<S1542>/Switch1' incorporates:
         *  Switch: '<S1542>/Switch2'
         *  UnitDelay: '<S1542>/UnitDelay'
         */
        rtb_Switch1_pi = THMR_ac_DW.UnitDelay_DSTATE_js;
    }

    /* End of Switch: '<S1542>/Switch1' */
    /* End of Outputs for SubSystem: '<S1497>/EdgeRising1' */

    /* RelationalOperator: '<S1542>/GreaterThan1' incorporates:
     *  Constant: '<S1542>/ConstantValue2'
     */
    VeTHMR_b_EngReq_HtrFlty_RA_B4D = (rtb_Switch1_pi > 0.0F);

    /* Update for UnitDelay: '<S1542>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_js = rtb_Switch1_pi;

    /* End of Outputs for SubSystem: '<S1497>/TimerRetriggerResetEnabled' */

    /* Switch: '<S1497>/Switch' incorporates:
     *  Constant: '<S1534>/Calib'
     */
    if (KeTHMR_b_EngReq_HtrFlty_RA_SD)
    {
        /* Switch: '<S1497>/Switch' incorporates:
         *  Constant: '<S1533>/Calib'
         */
        VeTHMR_b_EngReq_HtrFlty_RA = KeTHMR_b_EngReq_HtrFlty_RA_D;
    }
    else
    {
        /* Switch: '<S1497>/Switch' */
        VeTHMR_b_EngReq_HtrFlty_RA = VeTHMR_b_EngReq_HtrFlty_RA_B4D;
    }

    /* End of Switch: '<S1497>/Switch' */

    /* Logic: '<S1470>/LogicalOperator' */
    rtb_RelationalOperator7_p = (rtb_NotEqual_fo || (VeTHMR_b_EngReq_HtrFlty_RA));

    /* RelationalOperator: '<S1550>/Comparison3' incorporates:
     *  Constant: '<S1550>/ConstantValue4'
     */
    rtb_LogicalOperator_lw = (rtb_TmpSignalConversionAtVeCT_i < 0.0F);

    /* Outputs for Atomic SubSystem: '<S1550>/EdgeRising1' */
    /* Logic: '<S1581>/OR1' incorporates:
     *  UnitDelay: '<S1581>/UnitDelay'
     */
    rtb_NotEqual_fo = !THMR_ac_DW.UnitDelay_DSTATE_pc;

    /* Update for UnitDelay: '<S1581>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_pc = rtb_LogicalOperator_lw;

    /* End of Outputs for SubSystem: '<S1550>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S1550>/EdgeRising2' */
    /* Logic: '<S1582>/AND' incorporates:
     *  Logic: '<S1582>/OR1'
     *  UnitDelay: '<S1582>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant_da = !THMR_ac_DW.UnitDelay_DSTATE_e3;

    /* Update for UnitDelay: '<S1582>/UnitDelay' incorporates:
     *  Constant: '<S1550>/TRUEConstant4'
     */
    THMR_ac_DW.UnitDelay_DSTATE_e3 = true;

    /* End of Outputs for SubSystem: '<S1550>/EdgeRising2' */

    /* Outputs for Atomic SubSystem: '<S1550>/SignalLatchOnWithReset1' */
    /* Outputs for Atomic SubSystem: '<S1550>/EdgeRising1' */
    /* Logic: '<S1587>/OR1' incorporates:
     *  Logic: '<S1550>/Logical4'
     *  Logic: '<S1550>/Logical6'
     *  Logic: '<S1581>/AND'
     *  Logic: '<S1587>/NOT'
     *  Logic: '<S1587>/OR'
     *  UnitDelay: '<S1587>/UnitDelay'
     */
    rtb_LogicalOperator_lw = ((rtb_LogicalOperator_lw && rtb_NotEqual_fo) ||
        ((rtb_LogicalOperator_lw && (!rtb_VariantMerge_For_Variant_da)) &&
         (THMR_ac_DW.UnitDelay_DSTATE_ako)));

    /* End of Outputs for SubSystem: '<S1550>/EdgeRising1' */

    /* Update for UnitDelay: '<S1587>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ako = rtb_LogicalOperator_lw;

    /* End of Outputs for SubSystem: '<S1550>/SignalLatchOnWithReset1' */

    /* Logic: '<S1550>/Logical2' incorporates:
     *  Constant: '<S1583>/Calib'
     *  Constant: '<S1585>/Calib'
     *  Constant: '<S1586>/Calib'
     *  Gain: '<S1550>/Gain'
     *  Logic: '<S1550>/Logical1'
     *  Logic: '<S1550>/Logical3'
     *  RelationalOperator: '<S1550>/Comparison1'
     */
    VeTHMR_b_HCCT_ErrLargNegativ = (((KeTHMR_b_HtrCorTmp_NegErr_Dsbl) ||
        rtb_LogicalOperator_lw) && (((-rtb_TmpSignalConversionAtVeCT_i) >=
        KeTHMR_dT_HtrCorTmp_ErrCmfrtAchvd) ||
        (KeTHMR_b_HtrCorTmp_ErrCmfrtAchvd_Dsbl)));

    /* If: '<S1550>/If1' incorporates:
     *  Constant: '<S1584>/Calib'
     *  Logic: '<S1550>/Logical5'
     */
    if ((KeTHMR_b_HtrCorTmp_ErrLargNegativ) && (VeTHMR_b_HCCT_ErrLargNegativ))
    {
        /* Outputs for IfAction SubSystem: '<S1550>/Actual_Wished_Power' incorporates:
         *  ActionPort: '<S1579>/ActionPort'
         */
        /* Switch: '<S1579>/Switch1' incorporates:
         *  Constant: '<S1588>/Calib'
         */
        if (KeTHMR_b_EngTurnOff_AmbTmpSel)
        {
            rtb_TmpSignalConversionAtVeT_j5 = TmpSignalConversionAtOutAirTemp;
        }

        /* End of Switch: '<S1579>/Switch1' */

        /* Merge: '<S1550>/Merge3' incorporates:
         *  Lookup_n-D: '<S1589>/Vector'
         */
        VeTHMR_t_EngTurnOff_DelayTim = look1_iflf_binlcapw
            (rtb_TmpSignalConversionAtVeT_j5, ((const float32 *)
              &(KxTHMR_t_EngTurnOff_TimDely[0])), ((const float32 *)
              &(KtTHMR_t_EngTurnOff_TimDely[0])), 7U);

        /* End of Outputs for SubSystem: '<S1550>/Actual_Wished_Power' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1550>/Actual_Wished_Power1' incorporates:
         *  ActionPort: '<S1580>/ActionPort'
         */
        /* Merge: '<S1550>/Merge3' incorporates:
         *  Constant: '<S1590>/Calib'
         *  SignalConversion generated from: '<S1580>/EngTurnOff_TimDflt'
         */
        VeTHMR_t_EngTurnOff_DelayTim = KeTHMR_t_DelayEngTurn_Off;

        /* End of Outputs for SubSystem: '<S1550>/Actual_Wished_Power1' */
    }

    /* End of If: '<S1550>/If1' */

    /* If: '<S1164>/CabinHeat_Rqst_and_CPV3_Position' incorporates:
     *  Constant: '<S1971>/Constant'
     *  RelationalOperator: '<S1164>/Comparison3'
     */
    rtPrevAction = THMR_ac_DW.CabinHeat_Rqst_and_CPV3_Positio;
    if (rtb_UnitDelay3_ff)
    {
        rtAction = 0;
    }
    else if (((uint32)rtb_Logical17_o_tmp) == CeTHMR_e_FCBoostCool)
    {
        rtAction = 1;
    }
    else if (rtb_LogicalOperator_aa)
    {
        rtAction = 2;
    }
    else if (rtb_AND_de)
    {
        rtAction = 3;
    }
    else
    {
        rtAction = 4;
    }

    THMR_ac_DW.CabinHeat_Rqst_and_CPV3_Positio = rtAction;
    if (rtPrevAction != rtAction)
    {
        switch (rtPrevAction)
        {
          case 0:
          case 1:
          case 4:
            break;

          case 2:
            /* Disable for If: '<S2005>/If' */
            THMR_ac_DW.If_ActiveSubsystem_p = -1;
            break;

          case 3:
            /* Disable for If: '<S1997>/If' */
            THMR_ac_DW.If_ActiveSubsystem_d = -1;
            break;

          default:
            /* no actions */
            break;
        }
    }

    switch (rtAction)
    {
      case 0:
        if (rtAction != rtPrevAction)
        {
            /* SystemReset for IfAction SubSystem: '<S1164>/HTR_nd_Vlv_fr_BattActvPsv_Heating' incorporates:
             *  ActionPort: '<S1981>/ActionPort'
             */
            /* SystemReset for Atomic SubSystem: '<S2014>/EdgeBi' */
            /* SystemReset for If: '<S1164>/CabinHeat_Rqst_and_CPV3_Position' incorporates:
             *  UnitDelay: '<S2015>/UnitDelay'
             *  UnitDelay: '<S2016>/UnitDelay'
             *  UnitDelay: '<S2017>/UnitDelay'
             *  UnitDelay: '<S2026>/UnitDelay'
             *  UnitDelay: '<S2026>/UnitDelay1'
             *  UnitDelay: '<S2026>/UnitDelay2'
             *  UnitDelay: '<S2026>/UnitDelay3'
             */
            THMR_ac_DW.UnitDelay_DSTATE_al = false;

            /* End of SystemReset for SubSystem: '<S2014>/EdgeBi' */

            /* SystemReset for Atomic SubSystem: '<S2014>/EdgeRising' */
            THMR_ac_DW.UnitDelay_DSTATE_eo = false;

            /* End of SystemReset for SubSystem: '<S2014>/EdgeRising' */

            /* SystemReset for Atomic SubSystem: '<S2014>/PIControl' */
            THMR_ac_DW.UnitDelay_DSTATE_nn = 0.0F;
            THMR_ac_DW.UnitDelay2_DSTATE_jc = 0.0F;
            THMR_ac_DW.UnitDelay3_DSTATE_ht = false;
            THMR_ac_DW.UnitDelay1_DSTATE_lq = 0.0F;

            /* End of SystemReset for SubSystem: '<S2014>/PIControl' */

            /* SystemReset for Atomic SubSystem: '<S2014>/GradientLimiter' */
            THMR_ac_DW.UnitDelay_DSTATE_gv = 0.0F;

            /* End of SystemReset for SubSystem: '<S2014>/GradientLimiter' */
            /* End of SystemReset for SubSystem: '<S1164>/HTR_nd_Vlv_fr_BattActvPsv_Heating' */
        }

        /* Outputs for IfAction SubSystem: '<S1164>/HTR_nd_Vlv_fr_BattActvPsv_Heating' incorporates:
         *  ActionPort: '<S1981>/ActionPort'
         */
        /* Merge: '<S1164>/Merge' incorporates:
         *  Sum: '<S1981>/Sum'
         */
        VeTHMR_P_CabHtr_PwrRqst_HeatState = (VeTHMR_P_ActvTotPwr -
            rtb_TmpSignalConversionAtVeT_gg) - rtb_Merge2_l;

        /* Logic: '<S1981>/Logical1' incorporates:
         *  Constant: '<S2010>/Constant'
         *  RelationalOperator: '<S1981>/Comparison2'
         */
        rtb_NotEqual_fo = ((THMR_ac_B.Switch_i) || (((uint32)tmp_d) ==
                            CeTHMR_e_LTCLActvPsvHeating));

        /* Outputs for Atomic SubSystem: '<S2014>/EdgeBi' */
        /* RelationalOperator: '<S2015>/NotEqual' incorporates:
         *  UnitDelay: '<S2015>/UnitDelay'
         */
        rtb_LogicalOperator_lw = (rtb_NotEqual_fo !=
            THMR_ac_DW.UnitDelay_DSTATE_al);

        /* Update for UnitDelay: '<S2015>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_al = rtb_NotEqual_fo;

        /* End of Outputs for SubSystem: '<S2014>/EdgeBi' */

        /* Outputs for Atomic SubSystem: '<S2014>/EdgeRising' */
        /* Logic: '<S2016>/AND' incorporates:
         *  Logic: '<S2016>/OR1'
         *  UnitDelay: '<S2016>/UnitDelay'
         */
        rtb_UnitDelay3_ff = !THMR_ac_DW.UnitDelay_DSTATE_eo;

        /* Update for UnitDelay: '<S2016>/UnitDelay' incorporates:
         *  Constant: '<S2014>/TRUEConstant'
         */
        THMR_ac_DW.UnitDelay_DSTATE_eo = true;

        /* End of Outputs for SubSystem: '<S2014>/EdgeRising' */

        /* Outputs for Atomic SubSystem: '<S2014>/PIControl' */
        /* Switch: '<S2026>/Switch' incorporates:
         *  Constant: '<S2021>/Calib'
         *  Constant: '<S2026>/Constant'
         *  Constant: '<S2026>/Constant1'
         *  Constant: '<S2026>/ConstantValue'
         *  Logic: '<S2014>/Logical1'
         *  Logic: '<S2026>/Logical'
         *  Logic: '<S2026>/Logical1'
         *  Logic: '<S2026>/Logical2'
         *  Logic: '<S2026>/Logical3'
         *  Logic: '<S2026>/Logical4'
         *  RelationalOperator: '<S2026>/Comparison1'
         *  RelationalOperator: '<S2026>/Comparison2'
         *  RelationalOperator: '<S2026>/Comparison3'
         *  RelationalOperator: '<S2026>/Comparison4'
         *  Switch: '<S2026>/Switch2'
         *  UnitDelay: '<S2026>/UnitDelay'
         *  UnitDelay: '<S2026>/UnitDelay2'
         */
        if (rtb_UnitDelay3_ff || rtb_LogicalOperator_lw)
        {
            /* Switch: '<S2026>/Switch' incorporates:
             *  Constant: '<S2020>/Calib'
             */
            rtb_TmpSignalConversionAtVeT_j5 = KeTHMR_Pct_HTLVlvPI_IV;
        }
        else if ((((THMR_ac_DW.UnitDelay_DSTATE_nn <= 0.0F) ||
                   (THMR_ac_DW.UnitDelay2_DSTATE_jc < KeTHMR_Pct_HTLVlvPI_Max)) &&
                  ((THMR_ac_DW.UnitDelay2_DSTATE_jc < 100.0F) &&
                   (THMR_ac_DW.UnitDelay2_DSTATE_jc > -1.0F))) &&
                 rtb_NotEqual_fo)
        {
            /* Switch: '<S2026>/Switch2' incorporates:
             *  Constant: '<S2011>/Calib'
             *  Constant: '<S2014>/Constant2'
             *  Product: '<S2026>/Multiplication2'
             *  Sum: '<S2026>/Sum//Sub'
             *  Switch: '<S2026>/Switch'
             *  UnitDelay: '<S2026>/UnitDelay'
             */
            rtb_TmpSignalConversionAtVeT_j5 = ((rtb_TmpSignalConversionAtVeHT_k *
                0.1F) * KeTHMR_K_HTLVlvPICont_Ki) +
                THMR_ac_DW.UnitDelay_DSTATE_nn;
        }
        else
        {
            /* Switch: '<S2026>/Switch' incorporates:
             *  Switch: '<S2026>/Switch2'
             *  UnitDelay: '<S2026>/UnitDelay'
             */
            rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_nn;
        }

        /* End of Switch: '<S2026>/Switch' */

        /* Outputs for Atomic SubSystem: '<S2026>/integral_term' */
        /* Switch: '<S2028>/Switch1' incorporates:
         *  Constant: '<S2021>/Calib'
         *  RelationalOperator: '<S2028>/RelationalOperator'
         */
        if (KeTHMR_Pct_HTLVlvPI_Max < rtb_TmpSignalConversionAtVeT_j5)
        {
            /* Switch: '<S2025>/Switch1' */
            rtb_TmpSignalConversionAtVeT_j5 = KeTHMR_Pct_HTLVlvPI_Max;
        }

        /* End of Switch: '<S2028>/Switch1' */

        /* Switch: '<S2028>/Switch' incorporates:
         *  Constant: '<S2022>/Calib'
         *  RelationalOperator: '<S2028>/RelationalOperator1'
         */
        if (rtb_TmpSignalConversionAtVeT_j5 <= KeTHMR_Pct_HTLVlvPI_Min)
        {
            /* Switch: '<S2028>/Switch' */
            rtb_TmpSignalConversionAtVeT_j5 = KeTHMR_Pct_HTLVlvPI_Min;
        }

        /* End of Switch: '<S2028>/Switch' */
        /* End of Outputs for SubSystem: '<S2026>/integral_term' */

        /* Sum: '<S2026>/Sum//Sub1' incorporates:
         *  Constant: '<S2012>/Calib'
         *  Product: '<S2026>/proportional_term'
         */
        rtb_Switch1_pi = (rtb_TmpSignalConversionAtVeHT_k *
                          KeTHMR_K_HTLVlvPICont_Kp) +
            rtb_TmpSignalConversionAtVeT_j5;

        /* Switch: '<S2026>/Switch1' incorporates:
         *  UnitDelay: '<S2026>/UnitDelay3'
         */
        if (THMR_ac_DW.UnitDelay3_DSTATE_ht)
        {
            /* Switch: '<S2026>/Switch1' */
            rtb_TmpSignalConversionAtVeHT_p = rtb_Switch1_pi;
        }
        else
        {
            /* Switch: '<S2026>/Switch1' incorporates:
             *  UnitDelay: '<S2026>/UnitDelay1'
             */
            rtb_TmpSignalConversionAtVeHT_p = THMR_ac_DW.UnitDelay1_DSTATE_lq;
        }

        /* End of Switch: '<S2026>/Switch1' */

        /* Update for UnitDelay: '<S2026>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_nn = rtb_TmpSignalConversionAtVeT_j5;

        /* Update for UnitDelay: '<S2026>/UnitDelay2' */
        THMR_ac_DW.UnitDelay2_DSTATE_jc = rtb_Switch1_pi;

        /* Update for UnitDelay: '<S2026>/UnitDelay3' */
        THMR_ac_DW.UnitDelay3_DSTATE_ht = rtb_NotEqual_fo;

        /* Update for UnitDelay: '<S2026>/UnitDelay1' */
        THMR_ac_DW.UnitDelay1_DSTATE_lq = rtb_TmpSignalConversionAtVeHT_p;

        /* End of Outputs for SubSystem: '<S2014>/PIControl' */

        /* Outputs for Atomic SubSystem: '<S2014>/GradientLimiter' */
        /* Sum: '<S2017>/Sum2' incorporates:
         *  UnitDelay: '<S2017>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeT_j5 = rtb_TmpSignalConversionAtVeHT_p -
            THMR_ac_DW.UnitDelay_DSTATE_gv;

        /* Outputs for Atomic SubSystem: '<S2017>/Limiter' */
        /* Switch: '<S2027>/Switch1' incorporates:
         *  Constant: '<S2024>/Calib'
         *  RelationalOperator: '<S2027>/RelationalOperator'
         */
        if (KeTHMR_dPct_HTLVlvCntrl_LU < rtb_TmpSignalConversionAtVeT_j5)
        {
            /* Switch: '<S2027>/Switch1' */
            rtb_TmpSignalConversionAtVeT_j5 = KeTHMR_dPct_HTLVlvCntrl_LU;
        }

        /* End of Switch: '<S2027>/Switch1' */

        /* Switch: '<S2027>/Switch' incorporates:
         *  Constant: '<S2023>/Calib'
         *  RelationalOperator: '<S2027>/RelationalOperator1'
         */
        if (rtb_TmpSignalConversionAtVeT_j5 <= KeTHMR_dPct_HTLVlvCntrl_LD)
        {
            rtb_TmpSignalConversionAtVeT_j5 = KeTHMR_dPct_HTLVlvCntrl_LD;
        }

        /* End of Switch: '<S2027>/Switch' */
        /* End of Outputs for SubSystem: '<S2017>/Limiter' */

        /* Sum: '<S2017>/Sum3' incorporates:
         *  UnitDelay: '<S2017>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeT_j5 += THMR_ac_DW.UnitDelay_DSTATE_gv;

        /* Update for UnitDelay: '<S2017>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_gv = rtb_TmpSignalConversionAtVeT_j5;

        /* End of Outputs for SubSystem: '<S2014>/GradientLimiter' */

        /* Outputs for Atomic SubSystem: '<S2014>/Limiter' */
        /* Switch: '<S2025>/Switch1' incorporates:
         *  Constant: '<S2018>/Calib'
         *  RelationalOperator: '<S2025>/RelationalOperator'
         */
        if (KeTHMR_Pct_HTLVlvCntrl_Max < rtb_TmpSignalConversionAtVeT_j5)
        {
            /* Switch: '<S2025>/Switch1' */
            rtb_TmpSignalConversionAtVeT_j5 = KeTHMR_Pct_HTLVlvCntrl_Max;
        }

        /* End of Switch: '<S2025>/Switch1' */

        /* Switch: '<S2025>/Switch' incorporates:
         *  Constant: '<S2019>/Calib'
         *  RelationalOperator: '<S2025>/RelationalOperator1'
         */
        if (rtb_TmpSignalConversionAtVeT_j5 > KeTHMR_Pct_HTLVlvCntrl_Min)
        {
            /* Merge: '<S1164>/Merge1' */
            VeTHMR_Pct_HTLBypsVlv_Cmd = rtb_TmpSignalConversionAtVeT_j5;
        }
        else
        {
            /* Merge: '<S1164>/Merge1' */
            VeTHMR_Pct_HTLBypsVlv_Cmd = KeTHMR_Pct_HTLVlvCntrl_Min;
        }

        /* End of Switch: '<S2025>/Switch' */
        /* End of Outputs for SubSystem: '<S2014>/Limiter' */

        /* Merge: '<S1164>/Merge3' incorporates:
         *  Constant: '<S2013>/Calib'
         *  SignalConversion generated from: '<S1981>/HTSOV_LTCLActvPsvHeating'
         */
        VeTHMR_b_HTSOV_Cmd_HeatState = KeTHMR_b_HTSOV_LTCLActvPsvHeating;

        /* Merge: '<S1164>/Merge4' incorporates:
         *  Constant: '<S1981>/FALSE Constant1'
         *  SignalConversion generated from: '<S1981>/EngReq_LTCLActvPsvHeating'
         */
        rtb_NotEqual_fo = false;

        /* End of Outputs for SubSystem: '<S1164>/HTR_nd_Vlv_fr_BattActvPsv_Heating' */
        break;

      case 1:
        /* Outputs for IfAction SubSystem: '<S1164>/HTR_nd_Vlv_FC_BoostCooling' incorporates:
         *  ActionPort: '<S1978>/ActionPort'
         */
        /* Merge: '<S1164>/Merge' incorporates:
         *  Constant: '<S1978>/ConstantValue'
         *  SignalConversion generated from: '<S1978>/Out1'
         */
        VeTHMR_P_CabHtr_PwrRqst_HeatState = 0.0F;

        /* Merge: '<S1164>/Merge1' incorporates:
         *  Constant: '<S1992>/Calib'
         *  SignalConversion generated from: '<S1978>/Out2'
         */
        VeTHMR_Pct_HTLBypsVlv_Cmd = KeTHMR_Pct_HTCLVlv_FCBoostCool;

        /* Merge: '<S1164>/Merge3' incorporates:
         *  Constant: '<S1993>/Calib'
         *  SignalConversion generated from: '<S1978>/HTSOV_FCBoostCooling'
         */
        VeTHMR_b_HTSOV_Cmd_HeatState = KeTHMR_b_HTSOV_FCBoostCooling;

        /* Merge: '<S1164>/Merge4' incorporates:
         *  Constant: '<S1978>/FALSE Constant1'
         *  SignalConversion generated from: '<S1978>/EngReq_FCBoostCooling'
         */
        rtb_NotEqual_fo = false;

        /* End of Outputs for SubSystem: '<S1164>/HTR_nd_Vlv_FC_BoostCooling' */
        break;

      case 2:
        /* Outputs for IfAction SubSystem: '<S1164>/HTR_nd_Vlv_fr_Actv_Heating' incorporates:
         *  ActionPort: '<S1980>/ActionPort'
         */
        /* Merge: '<S1164>/Merge' incorporates:
         *  Sum: '<S1980>/Sum1'
         */
        VeTHMR_P_CabHtr_PwrRqst_HeatState = VeTHMR_P_ActvTotPwr - rtb_Merge2_l;

        /* Merge: '<S1164>/Merge1' incorporates:
         *  Constant: '<S2003>/Calib'
         *  SignalConversion generated from: '<S1980>/Out2'
         */
        VeTHMR_Pct_HTLBypsVlv_Cmd = KeTHMR_Pct_HTCL_Byps_Clsd;

        /* Merge: '<S1164>/Merge3' incorporates:
         *  Constant: '<S2004>/Calib'
         *  SignalConversion generated from: '<S1980>/HTSOV_ActvHeating'
         */
        VeTHMR_b_HTSOV_Cmd_HeatState = KeTHMR_b_HTSOV_Closed;

        /* If: '<S2005>/If' */
        rtPrevAction = THMR_ac_DW.If_ActiveSubsystem_p;
        rtAction = (sint8)((!rtb_TmpSignalConversionAtVeBT_m) ? 1 : 0);
        THMR_ac_DW.If_ActiveSubsystem_p = rtAction;
        if (rtAction == 0)
        {
            if (0 != rtPrevAction)
            {
                /* SystemReset for IfAction SubSystem: '<S2005>/eng_Req_Delyd' incorporates:
                 *  ActionPort: '<S2007>/g'
                 */
                /* SystemReset for Atomic SubSystem: '<S2007>/Count Down  Reset Trigger Enabled1' */
                /* SystemReset for If: '<S2005>/If' incorporates:
                 *  UnitDelay: '<S2008>/Unit Delay'
                 *  UnitDelay: '<S2009>/Unit Delay'
                 */
                THMR_ac_DW.UnitDelay_DSTATE_cf = 0.0F;

                /* SystemReset for Atomic SubSystem: '<S2008>/EdgeRising' */
                THMR_ac_DW.UnitDelay_DSTATE_h5j = false;

                /* End of SystemReset for SubSystem: '<S2008>/EdgeRising' */
                /* End of SystemReset for SubSystem: '<S2007>/Count Down  Reset Trigger Enabled1' */
                /* End of SystemReset for SubSystem: '<S2005>/eng_Req_Delyd' */
            }

            /* Outputs for IfAction SubSystem: '<S2005>/eng_Req_Delyd' incorporates:
             *  ActionPort: '<S2007>/g'
             */
            /* Outputs for Atomic SubSystem: '<S2007>/Count Down  Reset Trigger Enabled1' */
            /* Outputs for Atomic SubSystem: '<S2008>/EdgeRising' */
            /* Logic: '<S2009>/OR1' incorporates:
             *  UnitDelay: '<S2009>/Unit Delay'
             */
            rtb_NotEqual_fo = !THMR_ac_DW.UnitDelay_DSTATE_h5j;

            /* Update for UnitDelay: '<S2009>/Unit Delay' incorporates:
             *  Constant: '<S2007>/TRUE Constant5'
             */
            THMR_ac_DW.UnitDelay_DSTATE_h5j = true;

            /* Switch: '<S2008>/Switch1' incorporates:
             *  Constant: '<S2008>/Constant Value'
             *  Logic: '<S2009>/AND'
             *  RelationalOperator: '<S2008>/Greater  Than'
             *  Switch: '<S2008>/Switch2'
             *  UnitDelay: '<S2008>/Unit Delay'
             */
            if (rtb_NotEqual_fo)
            {
                /* Switch: '<S2008>/Switch1' */
                rtb_TmpSignalConversionAtVeT_j5 = VeTHMR_t_EngTurnOff_DelayTim;
            }
            else if (THMR_ac_DW.UnitDelay_DSTATE_cf > 0.0F)
            {
                /* Switch: '<S2008>/Switch2' incorporates:
                 *  Constant: '<S2008>/Constant Value1'
                 *  Sum: '<S2008>/Subtraction'
                 *  Switch: '<S2008>/Switch1'
                 *  UnitDelay: '<S2008>/Unit Delay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_cf
                    - 1.0F;
            }
            else
            {
                /* Switch: '<S2008>/Switch1' incorporates:
                 *  Switch: '<S2008>/Switch2'
                 *  UnitDelay: '<S2008>/Unit Delay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_cf;
            }

            /* End of Switch: '<S2008>/Switch1' */
            /* End of Outputs for SubSystem: '<S2008>/EdgeRising' */

            /* Merge: '<S2005>/Merge' incorporates:
             *  Constant: '<S2008>/Constant Value2'
             *  RelationalOperator: '<S2008>/Greater  Than1'
             */
            rtb_NotEqual_fo = (rtb_TmpSignalConversionAtVeT_j5 > 0.0F);

            /* Update for UnitDelay: '<S2008>/Unit Delay' */
            THMR_ac_DW.UnitDelay_DSTATE_cf = rtb_TmpSignalConversionAtVeT_j5;

            /* End of Outputs for SubSystem: '<S2007>/Count Down  Reset Trigger Enabled1' */
            /* End of Outputs for SubSystem: '<S2005>/eng_Req_Delyd' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S2005>/HTSOV_previous' incorporates:
             *  ActionPort: '<S2006>/g'
             */
            /* Merge: '<S2005>/Merge' incorporates:
             *  Constant: '<S2006>/FALSE Constant'
             *  SignalConversion generated from: '<S2006>/TurnOff_eng'
             */
            rtb_NotEqual_fo = false;

            /* End of Outputs for SubSystem: '<S2005>/HTSOV_previous' */
        }

        /* End of If: '<S2005>/If' */

        /* Switch: '<S2002>/Switch1' incorporates:
         *  Constant: '<S1547>/Calib'
         *  Constant: '<S2005>/Constant Value4'
         *  Logic: '<S1980>/Logical1'
         *  RelationalOperator: '<S2005>/Comparison3'
         *  Switch: '<S2005>/Switch3'
         */
        if (rtb_LogicalOperator1_fo && rtb_TmpSignalConversionAtVeCT_c)
        {
            /* Merge: '<S1164>/Merge4' incorporates:
             *  Constant: '<S1980>/TRUE Constant2'
             */
            rtb_NotEqual_fo = true;
        }
        else
        {
            if (KeTHMR_y_DelayEngTurn_OffSelAp != 1)
            {
                /* Switch: '<S2005>/Switch1' incorporates:
                 *  Constant: '<S1547>/Calib'
                 *  Constant: '<S2005>/Constant Value1'
                 *  RelationalOperator: '<S2005>/Comparison1'
                 *  Switch: '<S2005>/Switch3'
                 */
                if (KeTHMR_y_DelayEngTurn_OffSelAp == 2)
                {
                    /* Merge: '<S1164>/Merge4' incorporates:
                     *  Switch: '<S2005>/Switch1'
                     */
                    rtb_NotEqual_fo = rtb_RelationalOperator7_p;
                }
                else
                {
                    /* Merge: '<S1164>/Merge4' incorporates:
                     *  Constant: '<S2005>/Constant Value2'
                     *  RelationalOperator: '<S2005>/Comparison2'
                     *  Switch: '<S2005>/Switch1'
                     *  Switch: '<S2005>/Switch2'
                     */
                    rtb_NotEqual_fo = ((KeTHMR_y_DelayEngTurn_OffSelAp == 3) &&
                                       (VeTHMR_b_HCCT_ErrLargNegativ));
                }

                /* End of Switch: '<S2005>/Switch1' */
            }
        }

        /* End of Switch: '<S2002>/Switch1' */
        /* End of Outputs for SubSystem: '<S1164>/HTR_nd_Vlv_fr_Actv_Heating' */
        break;

      case 3:
        /* Outputs for IfAction SubSystem: '<S1164>/HTR_nd_Vlv_fr_ActvPsv_Heating' incorporates:
         *  ActionPort: '<S1979>/ActionPort'
         */
        /* Merge: '<S1164>/Merge' incorporates:
         *  Sum: '<S1979>/Sum'
         */
        VeTHMR_P_CabHtr_PwrRqst_HeatState = (VeTHMR_P_ActvTotPwr -
            rtb_TmpSignalConversionAtVeT_gg) - rtb_Merge2_l;

        /* Merge: '<S1164>/Merge1' incorporates:
         *  Constant: '<S1995>/Calib'
         *  SignalConversion generated from: '<S1979>/Out2'
         */
        VeTHMR_Pct_HTLBypsVlv_Cmd = KeTHMR_Pct_HTCL_Byps_Opn;

        /* Merge: '<S1164>/Merge3' incorporates:
         *  Constant: '<S1996>/Calib'
         *  SignalConversion generated from: '<S1979>/HTSOV_ActvPsvHeating'
         */
        VeTHMR_b_HTSOV_Cmd_HeatState = KeTHMR_b_HTSOV_Open;

        /* If: '<S1997>/If' */
        rtPrevAction = THMR_ac_DW.If_ActiveSubsystem_d;
        rtAction = (sint8)((!rtb_TmpSignalConversionAtVeBT_m) ? 1 : 0);
        THMR_ac_DW.If_ActiveSubsystem_d = rtAction;
        if (rtAction == 0)
        {
            if (0 != rtPrevAction)
            {
                /* SystemReset for IfAction SubSystem: '<S1997>/eng_Req_Delyd' incorporates:
                 *  ActionPort: '<S1999>/g'
                 */
                /* SystemReset for Atomic SubSystem: '<S1999>/Count Down  Reset Trigger Enabled1' */
                /* SystemReset for If: '<S1997>/If' incorporates:
                 *  UnitDelay: '<S2000>/Unit Delay'
                 *  UnitDelay: '<S2001>/Unit Delay'
                 */
                THMR_ac_DW.UnitDelay_DSTATE_dw = 0.0F;

                /* SystemReset for Atomic SubSystem: '<S2000>/EdgeRising' */
                THMR_ac_DW.UnitDelay_DSTATE_msh = false;

                /* End of SystemReset for SubSystem: '<S2000>/EdgeRising' */
                /* End of SystemReset for SubSystem: '<S1999>/Count Down  Reset Trigger Enabled1' */
                /* End of SystemReset for SubSystem: '<S1997>/eng_Req_Delyd' */
            }

            /* Outputs for IfAction SubSystem: '<S1997>/eng_Req_Delyd' incorporates:
             *  ActionPort: '<S1999>/g'
             */
            /* Outputs for Atomic SubSystem: '<S1999>/Count Down  Reset Trigger Enabled1' */
            /* Outputs for Atomic SubSystem: '<S2000>/EdgeRising' */
            /* Logic: '<S2001>/OR1' incorporates:
             *  UnitDelay: '<S2001>/Unit Delay'
             */
            rtb_NotEqual_fo = !THMR_ac_DW.UnitDelay_DSTATE_msh;

            /* Update for UnitDelay: '<S2001>/Unit Delay' incorporates:
             *  Constant: '<S1999>/TRUE Constant5'
             */
            THMR_ac_DW.UnitDelay_DSTATE_msh = true;

            /* Switch: '<S2000>/Switch1' incorporates:
             *  Constant: '<S2000>/Constant Value'
             *  Logic: '<S2001>/AND'
             *  RelationalOperator: '<S2000>/Greater  Than'
             *  Switch: '<S2000>/Switch2'
             *  UnitDelay: '<S2000>/Unit Delay'
             */
            if (rtb_NotEqual_fo)
            {
                /* Switch: '<S2000>/Switch1' */
                rtb_TmpSignalConversionAtVeT_j5 = VeTHMR_t_EngTurnOff_DelayTim;
            }
            else if (THMR_ac_DW.UnitDelay_DSTATE_dw > 0.0F)
            {
                /* Switch: '<S2000>/Switch2' incorporates:
                 *  Constant: '<S2000>/Constant Value1'
                 *  Sum: '<S2000>/Subtraction'
                 *  Switch: '<S2000>/Switch1'
                 *  UnitDelay: '<S2000>/Unit Delay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_dw
                    - 1.0F;
            }
            else
            {
                /* Switch: '<S2000>/Switch1' incorporates:
                 *  Switch: '<S2000>/Switch2'
                 *  UnitDelay: '<S2000>/Unit Delay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_dw;
            }

            /* End of Switch: '<S2000>/Switch1' */
            /* End of Outputs for SubSystem: '<S2000>/EdgeRising' */

            /* Merge: '<S1997>/Merge' incorporates:
             *  Constant: '<S2000>/Constant Value2'
             *  RelationalOperator: '<S2000>/Greater  Than1'
             */
            rtb_NotEqual_fo = (rtb_TmpSignalConversionAtVeT_j5 > 0.0F);

            /* Update for UnitDelay: '<S2000>/Unit Delay' */
            THMR_ac_DW.UnitDelay_DSTATE_dw = rtb_TmpSignalConversionAtVeT_j5;

            /* End of Outputs for SubSystem: '<S1999>/Count Down  Reset Trigger Enabled1' */
            /* End of Outputs for SubSystem: '<S1997>/eng_Req_Delyd' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S1997>/HTSOV_previous' incorporates:
             *  ActionPort: '<S1998>/g'
             */
            /* Merge: '<S1997>/Merge' incorporates:
             *  Constant: '<S1998>/FALSE Constant'
             *  SignalConversion generated from: '<S1998>/TurnOff_eng'
             */
            rtb_NotEqual_fo = false;

            /* End of Outputs for SubSystem: '<S1997>/HTSOV_previous' */
        }

        /* End of If: '<S1997>/If' */

        /* Switch: '<S1994>/Switch1' incorporates:
         *  Constant: '<S1547>/Calib'
         *  Constant: '<S1997>/Constant Value4'
         *  Logic: '<S1979>/Logical1'
         *  RelationalOperator: '<S1997>/Comparison3'
         *  Switch: '<S1997>/Switch3'
         */
        if (rtb_LogicalOperator1_fo && rtb_TmpSignalConversionAtVeCT_c)
        {
            /* Merge: '<S1164>/Merge4' incorporates:
             *  Constant: '<S1979>/TRUE Constant2'
             */
            rtb_NotEqual_fo = true;
        }
        else
        {
            if (KeTHMR_y_DelayEngTurn_OffSelAp != 1)
            {
                /* Switch: '<S1997>/Switch1' incorporates:
                 *  Constant: '<S1547>/Calib'
                 *  Constant: '<S1997>/Constant Value1'
                 *  RelationalOperator: '<S1997>/Comparison1'
                 *  Switch: '<S1997>/Switch3'
                 */
                if (KeTHMR_y_DelayEngTurn_OffSelAp == 2)
                {
                    /* Merge: '<S1164>/Merge4' incorporates:
                     *  Switch: '<S1997>/Switch1'
                     */
                    rtb_NotEqual_fo = rtb_RelationalOperator7_p;
                }
                else
                {
                    /* Merge: '<S1164>/Merge4' incorporates:
                     *  Constant: '<S1997>/Constant Value2'
                     *  RelationalOperator: '<S1997>/Comparison2'
                     *  Switch: '<S1997>/Switch1'
                     *  Switch: '<S1997>/Switch2'
                     */
                    rtb_NotEqual_fo = ((KeTHMR_y_DelayEngTurn_OffSelAp == 3) &&
                                       (VeTHMR_b_HCCT_ErrLargNegativ));
                }

                /* End of Switch: '<S1997>/Switch1' */
            }
        }

        /* End of Switch: '<S1994>/Switch1' */
        /* End of Outputs for SubSystem: '<S1164>/HTR_nd_Vlv_fr_ActvPsv_Heating' */
        break;

      default:
        /* Outputs for IfAction SubSystem: '<S1164>/HTR_nd_Vlv_fr_no_Heating' incorporates:
         *  ActionPort: '<S1982>/ActionPort'
         */
        /* Merge: '<S1164>/Merge' incorporates:
         *  Constant: '<S1982>/ConstantValue'
         *  SignalConversion generated from: '<S1982>/Out1'
         */
        VeTHMR_P_CabHtr_PwrRqst_HeatState = 0.0F;

        /* Merge: '<S1164>/Merge1' incorporates:
         *  Constant: '<S2029>/Calib'
         *  SignalConversion generated from: '<S1982>/Out2'
         */
        VeTHMR_Pct_HTLBypsVlv_Cmd = KeTHMR_Pct_HTCL_Byps_Clsd;

        /* Merge: '<S1164>/Merge3' incorporates:
         *  Constant: '<S2030>/Calib'
         *  SignalConversion generated from: '<S1982>/HTSOV_NoHeating'
         */
        VeTHMR_b_HTSOV_Cmd_HeatState = KeTHMR_b_HTSOV_NoHeating;

        /* Merge: '<S1164>/Merge4' incorporates:
         *  Constant: '<S1982>/FALSE Constant1'
         *  SignalConversion generated from: '<S1982>/EngReq_NoHeating'
         */
        rtb_NotEqual_fo = false;

        /* End of Outputs for SubSystem: '<S1164>/HTR_nd_Vlv_fr_no_Heating' */
        break;
    }

    /* Logic: '<S1678>/Logical4' incorporates:
     *  RelationalOperator: '<S1678>/Comparison6'
     *  RelationalOperator: '<S1678>/Comparison8'
     */
    VeTHMR_b_PerWpCntl_Case1 = ((THMR_ac_B.VariantMerge_Fo_jp) &&
        (VeTHMR_b_TotPwrLess_ThanLimit_RS));

    /* Logic: '<S1679>/Logical4' incorporates:
     *  RelationalOperator: '<S1679>/Comparison6'
     */
    VeTHMR_b_PerWpCntl_Case2 = ((THMR_ac_B.VariantMerge_Fo_jp) &&
        rtb_LogicalOperator1_fo);

    /* RelationalOperator: '<S1680>/Comparison6' */
    rtb_LogicalOperator_lw = !THMR_ac_B.VariantMerge_Fo_jp;

    /* Logic: '<S1680>/Logical4' incorporates:
     *  Logic: '<S1682>/Logical4'
     *  RelationalOperator: '<S1680>/Comparison8'
     */
    rtb_UnitDelay3_ff = (rtb_LogicalOperator_lw &&
                         (VeTHMR_b_TotPwrLess_ThanLimit_RS));

    /* Logic: '<S1680>/Logical4' incorporates:
     *  RelationalOperator: '<S1680>/Comparison1'
     */
    VeTHMR_b_PerWpCntl_Case3 = (rtb_UnitDelay3_ff &&
        rtb_TmpSignalConversionAtVeBT_f);

    /* Logic: '<S1681>/Logical4' incorporates:
     *  Logic: '<S1683>/Logical4'
     */
    rtb_LogicalOperator_lw = (rtb_LogicalOperator_lw && rtb_LogicalOperator1_fo);

    /* Logic: '<S1681>/Logical4' incorporates:
     *  RelationalOperator: '<S1681>/Comparison1'
     */
    VeTHMR_b_PerWpCntl_Case4 = (rtb_LogicalOperator_lw &&
        rtb_TmpSignalConversionAtVeBT_f);

    /* Logic: '<S1682>/Logical4' incorporates:
     *  Constant: '<S1684>/Calib'
     *  Logic: '<S1682>/Logical1'
     *  RelationalOperator: '<S1682>/Comparison2'
     */
    VeTHMR_b_PerWpCntl_Case5 = ((rtb_UnitDelay3_ff && rtb_AND_cn) &&
        ((THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0) ||
         (KeTHMR_b_PerWpSts_CaseFivEnb)));

    /* Logic: '<S1683>/Logical4' incorporates:
     *  Constant: '<S1685>/Calib'
     *  Constant: '<S1686>/Calib'
     *  Logic: '<S1683>/Logical1'
     *  RelationalOperator: '<S1683>/Comparison1'
     *  RelationalOperator: '<S1683>/Comparison2'
     */
    VeTHMR_b_PerWpCntl_Case6 = ((rtb_LogicalOperator_lw &&
        (KeTHMR_b_BatCndRq_ChkdCaseSix == rtb_TmpSignalConversionAtVeBT_f)) &&
        ((KeTHMR_b_PerWpEng_AllowCaseSix_Enb) || rtb_TmpSignalConversionAtVeCT_c));

    /* Switch: '<S1472>/Switch' incorporates:
     *  Constant: '<S1711>/Calib'
     */
    if (KeTHMR_b_PwrAvailConst_Select)
    {
        /* Switch: '<S1472>/Switch' */
        VeTHMR_P_PwrAvaiConstraint_1 = VeTHMR_P_PwrAvaiConstraint;
    }
    else
    {
        /* Switch: '<S1472>/Switch' */
        VeTHMR_P_PwrAvaiConstraint_1 = rtb_Switch1_giu;
    }

    /* End of Switch: '<S1472>/Switch' */

    /* If: '<S1471>/If' */
    if ((VeTHMR_b_PerWpCntl_Case1) || (VeTHMR_b_PerWpCntl_Case5))
    {
        /* Outputs for IfAction SubSystem: '<S1471>/Action_1' incorporates:
         *  ActionPort: '<S1667>/ActionPort'
         */
        /* Merge: '<S1471>/Merge' incorporates:
         *  Gain: '<S1673>/Gain'
         */
        VeTHMR_P_PerWp_HtrPwrTgt_Lim = VeTHMR_P_ActvTotPwr;

        /* Merge: '<S1471>/Merge1' incorporates:
         *  Constant: '<S1667>/FALSEConstant1'
         *  SignalConversion generated from: '<S1667>/Eng_Req'
         */
        VeTHMR_b_PerWp_SystEngReq = false;

        /* Merge: '<S1471>/Merge2' incorporates:
         *  Constant: '<S1667>/FALSEConstant2'
         *  SignalConversion generated from: '<S1667>/HT_SO_Vlv_Cmd'
         */
        VeTHMR_b_PerWp_HTSO_VlvCmd_B4D = false;

        /* End of Outputs for SubSystem: '<S1471>/Action_1' */
    }
    else if ((VeTHMR_b_PerWpCntl_Case2) || (VeTHMR_b_PerWpCntl_Case6))
    {
        /* Outputs for IfAction SubSystem: '<S1471>/Action_2' incorporates:
         *  ActionPort: '<S1668>/ActionPort'
         */
        /* Merge: '<S1471>/Merge' incorporates:
         *  Gain: '<S1674>/Gain'
         */
        VeTHMR_P_PerWp_HtrPwrTgt_Lim = VeTHMR_P_PwrAvaiConstraint_1;

        /* Merge: '<S1471>/Merge1' incorporates:
         *  Constant: '<S1668>/FALSEConstant1'
         *  SignalConversion generated from: '<S1668>/Eng_Req'
         */
        VeTHMR_b_PerWp_SystEngReq = false;

        /* Merge: '<S1471>/Merge2' incorporates:
         *  Constant: '<S1668>/FALSEConstant2'
         *  SignalConversion generated from: '<S1668>/HT_SO_Vlv_Cmd'
         */
        VeTHMR_b_PerWp_HTSO_VlvCmd_B4D = false;

        /* End of Outputs for SubSystem: '<S1471>/Action_2' */
    }
    else if (VeTHMR_b_PerWpCntl_Case3)
    {
        /* Outputs for IfAction SubSystem: '<S1471>/Action_3' incorporates:
         *  ActionPort: '<S1669>/ActionPort'
         */
        /* Merge: '<S1471>/Merge' incorporates:
         *  Gain: '<S1675>/Gain'
         */
        VeTHMR_P_PerWp_HtrPwrTgt_Lim = VeTHMR_P_ActvTotPwr;

        /* Merge: '<S1471>/Merge1' incorporates:
         *  Constant: '<S1669>/FALSEConstant1'
         *  SignalConversion generated from: '<S1669>/Eng_Req'
         */
        VeTHMR_b_PerWp_SystEngReq = false;

        /* Merge: '<S1471>/Merge2' incorporates:
         *  Constant: '<S1669>/TRUEConstant2'
         *  SignalConversion generated from: '<S1669>/HT_SO_Vlv_Cmd'
         */
        VeTHMR_b_PerWp_HTSO_VlvCmd_B4D = true;

        /* End of Outputs for SubSystem: '<S1471>/Action_3' */
    }
    else if (VeTHMR_b_PerWpCntl_Case4)
    {
        /* Outputs for IfAction SubSystem: '<S1471>/Action_4' incorporates:
         *  ActionPort: '<S1670>/ActionPort'
         */
        /* Merge: '<S1471>/Merge' incorporates:
         *  Gain: '<S1676>/Gain'
         */
        VeTHMR_P_PerWp_HtrPwrTgt_Lim = VeTHMR_P_PwrAvaiConstraint_1;

        /* Merge: '<S1471>/Merge1' incorporates:
         *  Constant: '<S1670>/FALSEConstant1'
         *  SignalConversion generated from: '<S1670>/Eng_Req'
         */
        VeTHMR_b_PerWp_SystEngReq = false;

        /* Merge: '<S1471>/Merge2' incorporates:
         *  Constant: '<S1670>/TRUEConstant2'
         *  SignalConversion generated from: '<S1670>/HT_SO_Vlv_Cmd'
         */
        VeTHMR_b_PerWp_HTSO_VlvCmd_B4D = true;

        /* End of Outputs for SubSystem: '<S1471>/Action_4' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1471>/Action_6' incorporates:
         *  ActionPort: '<S1671>/ActionPort'
         */
        /* Merge: '<S1471>/Merge' incorporates:
         *  Constant: '<S1671>/ConstantValue3'
         *  Gain: '<S1677>/Gain'
         */
        VeTHMR_P_PerWp_HtrPwrTgt_Lim = 0.0F;

        /* Merge: '<S1471>/Merge1' incorporates:
         *  Constant: '<S1671>/FALSEConstant2'
         *  SignalConversion generated from: '<S1671>/Eng_Req'
         */
        VeTHMR_b_PerWp_SystEngReq = false;

        /* Merge: '<S1471>/Merge2' incorporates:
         *  Constant: '<S1671>/FALSEConstant1'
         *  SignalConversion generated from: '<S1671>/HT_SO_Vlv_Cmd'
         */
        VeTHMR_b_PerWp_HTSO_VlvCmd_B4D = false;

        /* End of Outputs for SubSystem: '<S1471>/Action_6' */
    }

    /* End of If: '<S1471>/If' */

    /* If: '<S1470>/If' */
    rtPrevAction = THMR_ac_DW.If_ActiveSubsystem_c;
    if (VeTHMR_b_Enbl_Ua)
    {
        rtAction = 0;
    }
    else if (VeTHMR_b_Enbl_Ub)
    {
        rtAction = 1;
    }
    else if (VeTHMR_b_Enbl_Uc)
    {
        rtAction = 2;
    }
    else if (VeTHMR_b_Enbl_Ud)
    {
        rtAction = 3;
    }
    else if (VeTHMR_b_Enbl_Ue)
    {
        rtAction = 4;
    }
    else if (VeTHMR_b_Enbl_Uf)
    {
        rtAction = 5;
    }
    else if (VeTHMR_b_Enbl_Ug)
    {
        rtAction = 6;
    }
    else
    {
        rtAction = 7;
    }

    THMR_ac_DW.If_ActiveSubsystem_c = rtAction;
    if (rtPrevAction != rtAction)
    {
        switch (rtPrevAction)
        {
          case 0:
            /* Disable for If: '<S1593>/If' */
            THMR_ac_DW.If_ActiveSubsystem_pu = -1;
            break;

          case 1:
            /* Disable for If: '<S1600>/If' */
            THMR_ac_DW.If_ActiveSubsystem_cq = -1;
            break;

          case 2:
            /* Disable for If: '<S1607>/If' */
            THMR_ac_DW.If_ActiveSubsystem_a = -1;
            break;

          case 3:
            /* Disable for If: '<S1614>/If' */
            THMR_ac_DW.If_ActiveSubsystem_n = -1;
            break;

          case 4:
            break;

          case 5:
            /* Disable for If: '<S1647>/If' */
            THMR_ac_DW.If_ActiveSubsystem_o = -1;
            break;

          case 6:
            /* Disable for If: '<S1655>/If' */
            THMR_ac_DW.If_ActiveSubsystem_l = -1;
            break;

          case 7:
            /* Disable for If: '<S1662>/If' */
            THMR_ac_DW.If_ActiveSubsystem_i = -1;
            break;

          default:
            /* no actions */
            break;
        }
    }

    switch (rtAction)
    {
      case 0:
        /* Outputs for IfAction SubSystem: '<S1470>/a' incorporates:
         *  ActionPort: '<S1551>/a'
         */
        /* Merge: '<S1470>/Merge' incorporates:
         *  Constant: '<S1546>/Calib'
         *  SignalConversion: '<S1551>/SignalConversion'
         */
        VeTHMR_P_ECH_HtrPwrTgt_a = KeTHMR_P_PwrHtrOff;

        /* If: '<S1593>/If' */
        rtPrevAction = THMR_ac_DW.If_ActiveSubsystem_pu;
        rtAction = (sint8)((!rtb_TmpSignalConversionAtVeBT_m) ? 1 : 0);
        THMR_ac_DW.If_ActiveSubsystem_pu = rtAction;
        if (rtAction == 0)
        {
            if (0 != rtPrevAction)
            {
                /* SystemReset for IfAction SubSystem: '<S1593>/eng_Req_Delyd' incorporates:
                 *  ActionPort: '<S1595>/g'
                 */
                /* SystemReset for Atomic SubSystem: '<S1595>/CountDownResetTriggerEnabled1' */
                /* SystemReset for If: '<S1593>/If' incorporates:
                 *  UnitDelay: '<S1596>/UnitDelay'
                 *  UnitDelay: '<S1597>/UnitDelay'
                 */
                THMR_ac_DW.UnitDelay_DSTATE_hg = 0.0F;

                /* SystemReset for Atomic SubSystem: '<S1596>/EdgeRising' */
                THMR_ac_DW.UnitDelay_DSTATE_jr = false;

                /* End of SystemReset for SubSystem: '<S1596>/EdgeRising' */
                /* End of SystemReset for SubSystem: '<S1595>/CountDownResetTriggerEnabled1' */
                /* End of SystemReset for SubSystem: '<S1593>/eng_Req_Delyd' */
            }

            /* Outputs for IfAction SubSystem: '<S1593>/eng_Req_Delyd' incorporates:
             *  ActionPort: '<S1595>/g'
             */
            /* Outputs for Atomic SubSystem: '<S1595>/CountDownResetTriggerEnabled1' */
            /* Outputs for Atomic SubSystem: '<S1596>/EdgeRising' */
            /* Logic: '<S1597>/OR1' incorporates:
             *  UnitDelay: '<S1597>/UnitDelay'
             */
            rtb_TmpSignalConversionAtVeBT_f = !THMR_ac_DW.UnitDelay_DSTATE_jr;

            /* Update for UnitDelay: '<S1597>/UnitDelay' incorporates:
             *  Constant: '<S1595>/TRUEConstant5'
             */
            THMR_ac_DW.UnitDelay_DSTATE_jr = true;

            /* Switch: '<S1596>/Switch1' incorporates:
             *  Constant: '<S1596>/ConstantValue'
             *  Logic: '<S1597>/AND'
             *  RelationalOperator: '<S1596>/GreaterThan'
             *  Switch: '<S1596>/Switch2'
             *  UnitDelay: '<S1596>/UnitDelay'
             */
            if (rtb_TmpSignalConversionAtVeBT_f)
            {
                /* Switch: '<S1596>/Switch1' */
                rtb_TmpSignalConversionAtVeT_j5 = VeTHMR_t_EngTurnOff_DelayTim;
            }
            else if (THMR_ac_DW.UnitDelay_DSTATE_hg > 0.0F)
            {
                /* Switch: '<S1596>/Switch2' incorporates:
                 *  Constant: '<S1596>/ConstantValue1'
                 *  Sum: '<S1596>/Subtraction'
                 *  Switch: '<S1596>/Switch1'
                 *  UnitDelay: '<S1596>/UnitDelay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_hg
                    - 1.0F;
            }
            else
            {
                /* Switch: '<S1596>/Switch1' incorporates:
                 *  Switch: '<S1596>/Switch2'
                 *  UnitDelay: '<S1596>/UnitDelay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_hg;
            }

            /* End of Switch: '<S1596>/Switch1' */
            /* End of Outputs for SubSystem: '<S1596>/EdgeRising' */

            /* Merge: '<S1593>/Merge' incorporates:
             *  Constant: '<S1596>/ConstantValue2'
             *  RelationalOperator: '<S1596>/GreaterThan1'
             */
            rtb_TmpSignalConversionAtVeBT_m = (rtb_TmpSignalConversionAtVeT_j5 >
                0.0F);

            /* Update for UnitDelay: '<S1596>/UnitDelay' */
            THMR_ac_DW.UnitDelay_DSTATE_hg = rtb_TmpSignalConversionAtVeT_j5;

            /* End of Outputs for SubSystem: '<S1595>/CountDownResetTriggerEnabled1' */
            /* End of Outputs for SubSystem: '<S1593>/eng_Req_Delyd' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S1593>/HTSOV_previous' incorporates:
             *  ActionPort: '<S1594>/g'
             */
            /* Merge: '<S1593>/Merge' incorporates:
             *  Constant: '<S1594>/FALSEConstant'
             *  SignalConversion generated from: '<S1594>/TurnOff_eng'
             */
            rtb_TmpSignalConversionAtVeBT_m = false;

            /* End of Outputs for SubSystem: '<S1593>/HTSOV_previous' */
        }

        /* End of If: '<S1593>/If' */

        /* Switch: '<S1593>/Switch3' incorporates:
         *  Constant: '<S1547>/Calib'
         *  Constant: '<S1593>/ConstantValue1'
         *  Constant: '<S1593>/ConstantValue4'
         *  RelationalOperator: '<S1593>/Comparison1'
         *  RelationalOperator: '<S1593>/Comparison3'
         *  Switch: '<S1593>/Switch1'
         */
        if (KeTHMR_y_DelayEngTurn_OffSelAp == 1)
        {
            /* Merge: '<S1470>/Merge1' */
            VeTHMR_b_ThrmSysEng_Raw = rtb_TmpSignalConversionAtVeBT_m;
        }
        else if (KeTHMR_y_DelayEngTurn_OffSelAp == 2)
        {
            /* Switch: '<S1593>/Switch1' incorporates:
             *  Merge: '<S1470>/Merge1'
             */
            VeTHMR_b_ThrmSysEng_Raw = rtb_RelationalOperator7_p;
        }
        else
        {
            /* Merge: '<S1470>/Merge1' incorporates:
             *  Constant: '<S1593>/ConstantValue2'
             *  RelationalOperator: '<S1593>/Comparison2'
             *  Switch: '<S1593>/Switch1'
             *  Switch: '<S1593>/Switch2'
             */
            VeTHMR_b_ThrmSysEng_Raw = ((KeTHMR_y_DelayEngTurn_OffSelAp == 3) &&
                (VeTHMR_b_HCCT_ErrLargNegativ));
        }

        /* End of Switch: '<S1593>/Switch3' */

        /* Merge: '<S1470>/Merge2' incorporates:
         *  Constant: '<S1551>/FALSEConstant'
         *  Gain: '<S1592>/Gain'
         */
        VeTHMR_b_HT_Shtoff_VlvCmd_B4PWup = false;

        /* End of Outputs for SubSystem: '<S1470>/a' */
        break;

      case 1:
        /* Outputs for IfAction SubSystem: '<S1470>/b' incorporates:
         *  ActionPort: '<S1552>/b'
         */
        /* Gain: '<S1598>/Gain' incorporates:
         *  Constant: '<S1546>/Calib'
         */
        VeTHMR_P_ECH_HtrPwrTgt_b = KeTHMR_P_PwrHtrOff;

        /* Merge: '<S1470>/Merge' incorporates:
         *  SignalConversion: '<S1552>/SignalConversion'
         */
        VeTHMR_P_ECH_HtrPwrTgt_a = VeTHMR_P_ECH_HtrPwrTgt_b;

        /* If: '<S1600>/If' */
        rtPrevAction = THMR_ac_DW.If_ActiveSubsystem_cq;
        rtAction = (sint8)((!rtb_TmpSignalConversionAtVeBT_m) ? 1 : 0);
        THMR_ac_DW.If_ActiveSubsystem_cq = rtAction;
        if (rtAction == 0)
        {
            if (0 != rtPrevAction)
            {
                /* SystemReset for IfAction SubSystem: '<S1600>/eng_Req_Delyd' incorporates:
                 *  ActionPort: '<S1602>/b'
                 */
                /* SystemReset for Atomic SubSystem: '<S1602>/CountDownResetTriggerEnabled1' */
                /* SystemReset for If: '<S1600>/If' incorporates:
                 *  UnitDelay: '<S1603>/UnitDelay'
                 *  UnitDelay: '<S1604>/UnitDelay'
                 */
                THMR_ac_DW.UnitDelay_DSTATE_hem = 0.0F;

                /* SystemReset for Atomic SubSystem: '<S1603>/EdgeRising' */
                THMR_ac_DW.UnitDelay_DSTATE_pw = false;

                /* End of SystemReset for SubSystem: '<S1603>/EdgeRising' */
                /* End of SystemReset for SubSystem: '<S1602>/CountDownResetTriggerEnabled1' */
                /* End of SystemReset for SubSystem: '<S1600>/eng_Req_Delyd' */
            }

            /* Outputs for IfAction SubSystem: '<S1600>/eng_Req_Delyd' incorporates:
             *  ActionPort: '<S1602>/b'
             */
            /* Outputs for Atomic SubSystem: '<S1602>/CountDownResetTriggerEnabled1' */
            /* Outputs for Atomic SubSystem: '<S1603>/EdgeRising' */
            /* Logic: '<S1604>/OR1' incorporates:
             *  UnitDelay: '<S1604>/UnitDelay'
             */
            rtb_TmpSignalConversionAtVeBT_f = !THMR_ac_DW.UnitDelay_DSTATE_pw;

            /* Update for UnitDelay: '<S1604>/UnitDelay' incorporates:
             *  Constant: '<S1602>/TRUEConstant5'
             */
            THMR_ac_DW.UnitDelay_DSTATE_pw = true;

            /* Switch: '<S1603>/Switch1' incorporates:
             *  Constant: '<S1603>/ConstantValue'
             *  Logic: '<S1604>/AND'
             *  RelationalOperator: '<S1603>/GreaterThan'
             *  Switch: '<S1603>/Switch2'
             *  UnitDelay: '<S1603>/UnitDelay'
             */
            if (rtb_TmpSignalConversionAtVeBT_f)
            {
                /* Switch: '<S1603>/Switch1' */
                rtb_TmpSignalConversionAtVeT_j5 = VeTHMR_t_EngTurnOff_DelayTim;
            }
            else if (THMR_ac_DW.UnitDelay_DSTATE_hem > 0.0F)
            {
                /* Switch: '<S1603>/Switch2' incorporates:
                 *  Constant: '<S1603>/ConstantValue1'
                 *  Sum: '<S1603>/Subtraction'
                 *  Switch: '<S1603>/Switch1'
                 *  UnitDelay: '<S1603>/UnitDelay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 =
                    THMR_ac_DW.UnitDelay_DSTATE_hem - 1.0F;
            }
            else
            {
                /* Switch: '<S1603>/Switch1' incorporates:
                 *  Switch: '<S1603>/Switch2'
                 *  UnitDelay: '<S1603>/UnitDelay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 =
                    THMR_ac_DW.UnitDelay_DSTATE_hem;
            }

            /* End of Switch: '<S1603>/Switch1' */
            /* End of Outputs for SubSystem: '<S1603>/EdgeRising' */

            /* Merge: '<S1600>/Merge' incorporates:
             *  Constant: '<S1603>/ConstantValue2'
             *  RelationalOperator: '<S1603>/GreaterThan1'
             */
            rtb_TmpSignalConversionAtVeBT_m = (rtb_TmpSignalConversionAtVeT_j5 >
                0.0F);

            /* Update for UnitDelay: '<S1603>/UnitDelay' */
            THMR_ac_DW.UnitDelay_DSTATE_hem = rtb_TmpSignalConversionAtVeT_j5;

            /* End of Outputs for SubSystem: '<S1602>/CountDownResetTriggerEnabled1' */
            /* End of Outputs for SubSystem: '<S1600>/eng_Req_Delyd' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S1600>/HTSOV_previous' incorporates:
             *  ActionPort: '<S1601>/g'
             */
            /* Merge: '<S1600>/Merge' incorporates:
             *  Constant: '<S1601>/FALSEConstant'
             *  SignalConversion generated from: '<S1601>/TurnOff_eng'
             */
            rtb_TmpSignalConversionAtVeBT_m = false;

            /* End of Outputs for SubSystem: '<S1600>/HTSOV_previous' */
        }

        /* End of If: '<S1600>/If' */

        /* Switch: '<S1600>/Switch3' incorporates:
         *  Constant: '<S1547>/Calib'
         *  Constant: '<S1600>/ConstantValue1'
         *  Constant: '<S1600>/ConstantValue4'
         *  RelationalOperator: '<S1600>/Comparison1'
         *  RelationalOperator: '<S1600>/Comparison3'
         *  Switch: '<S1600>/Switch1'
         */
        if (KeTHMR_y_DelayEngTurn_OffSelAp == 1)
        {
            /* Merge: '<S1470>/Merge1' */
            VeTHMR_b_ThrmSysEng_Raw = rtb_TmpSignalConversionAtVeBT_m;
        }
        else if (KeTHMR_y_DelayEngTurn_OffSelAp == 2)
        {
            /* Switch: '<S1600>/Switch1' incorporates:
             *  Merge: '<S1470>/Merge1'
             */
            VeTHMR_b_ThrmSysEng_Raw = rtb_RelationalOperator7_p;
        }
        else
        {
            /* Merge: '<S1470>/Merge1' incorporates:
             *  Constant: '<S1600>/ConstantValue2'
             *  RelationalOperator: '<S1600>/Comparison2'
             *  Switch: '<S1600>/Switch1'
             *  Switch: '<S1600>/Switch2'
             */
            VeTHMR_b_ThrmSysEng_Raw = ((KeTHMR_y_DelayEngTurn_OffSelAp == 3) &&
                (VeTHMR_b_HCCT_ErrLargNegativ));
        }

        /* End of Switch: '<S1600>/Switch3' */

        /* Merge: '<S1470>/Merge2' incorporates:
         *  Constant: '<S1552>/TRUEConstant1'
         *  Gain: '<S1599>/Gain'
         */
        VeTHMR_b_HT_Shtoff_VlvCmd_B4PWup = true;

        /* End of Outputs for SubSystem: '<S1470>/b' */
        break;

      case 2:
        /* Outputs for IfAction SubSystem: '<S1470>/c' incorporates:
         *  ActionPort: '<S1553>/c'
         */
        /* Gain: '<S1605>/Gain' */
        VeTHMR_P_ECH_HtrPwrTgt_c = VeTHMR_P_ActvTotPwr;

        /* Merge: '<S1470>/Merge' incorporates:
         *  SignalConversion: '<S1553>/SignalConversion'
         */
        VeTHMR_P_ECH_HtrPwrTgt_a = VeTHMR_P_ECH_HtrPwrTgt_c;

        /* If: '<S1607>/If' */
        rtPrevAction = THMR_ac_DW.If_ActiveSubsystem_a;
        rtAction = (sint8)((!rtb_TmpSignalConversionAtVeBT_m) ? 1 : 0);
        THMR_ac_DW.If_ActiveSubsystem_a = rtAction;
        if (rtAction == 0)
        {
            if (0 != rtPrevAction)
            {
                /* SystemReset for IfAction SubSystem: '<S1607>/eng_Req_Delyd' incorporates:
                 *  ActionPort: '<S1609>/c'
                 */
                /* SystemReset for Atomic SubSystem: '<S1609>/CountDownResetTriggerEnabled1' */
                /* SystemReset for If: '<S1607>/If' incorporates:
                 *  UnitDelay: '<S1610>/UnitDelay'
                 *  UnitDelay: '<S1611>/UnitDelay'
                 */
                THMR_ac_DW.UnitDelay_DSTATE_av = 0.0F;

                /* SystemReset for Atomic SubSystem: '<S1610>/EdgeRising' */
                THMR_ac_DW.UnitDelay_DSTATE_e1 = false;

                /* End of SystemReset for SubSystem: '<S1610>/EdgeRising' */
                /* End of SystemReset for SubSystem: '<S1609>/CountDownResetTriggerEnabled1' */
                /* End of SystemReset for SubSystem: '<S1607>/eng_Req_Delyd' */
            }

            /* Outputs for IfAction SubSystem: '<S1607>/eng_Req_Delyd' incorporates:
             *  ActionPort: '<S1609>/c'
             */
            /* Outputs for Atomic SubSystem: '<S1609>/CountDownResetTriggerEnabled1' */
            /* Outputs for Atomic SubSystem: '<S1610>/EdgeRising' */
            /* Logic: '<S1611>/OR1' incorporates:
             *  UnitDelay: '<S1611>/UnitDelay'
             */
            rtb_TmpSignalConversionAtVeBT_f = !THMR_ac_DW.UnitDelay_DSTATE_e1;

            /* Update for UnitDelay: '<S1611>/UnitDelay' incorporates:
             *  Constant: '<S1609>/TRUEConstant5'
             */
            THMR_ac_DW.UnitDelay_DSTATE_e1 = true;

            /* Switch: '<S1610>/Switch1' incorporates:
             *  Constant: '<S1610>/ConstantValue'
             *  Logic: '<S1611>/AND'
             *  RelationalOperator: '<S1610>/GreaterThan'
             *  Switch: '<S1610>/Switch2'
             *  UnitDelay: '<S1610>/UnitDelay'
             */
            if (rtb_TmpSignalConversionAtVeBT_f)
            {
                /* Switch: '<S1610>/Switch1' */
                rtb_TmpSignalConversionAtVeT_j5 = VeTHMR_t_EngTurnOff_DelayTim;
            }
            else if (THMR_ac_DW.UnitDelay_DSTATE_av > 0.0F)
            {
                /* Switch: '<S1610>/Switch2' incorporates:
                 *  Constant: '<S1610>/ConstantValue1'
                 *  Sum: '<S1610>/Subtraction'
                 *  Switch: '<S1610>/Switch1'
                 *  UnitDelay: '<S1610>/UnitDelay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_av
                    - 1.0F;
            }
            else
            {
                /* Switch: '<S1610>/Switch1' incorporates:
                 *  Switch: '<S1610>/Switch2'
                 *  UnitDelay: '<S1610>/UnitDelay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_av;
            }

            /* End of Switch: '<S1610>/Switch1' */
            /* End of Outputs for SubSystem: '<S1610>/EdgeRising' */

            /* Merge: '<S1607>/Merge' incorporates:
             *  Constant: '<S1610>/ConstantValue2'
             *  RelationalOperator: '<S1610>/GreaterThan1'
             */
            rtb_TmpSignalConversionAtVeBT_m = (rtb_TmpSignalConversionAtVeT_j5 >
                0.0F);

            /* Update for UnitDelay: '<S1610>/UnitDelay' */
            THMR_ac_DW.UnitDelay_DSTATE_av = rtb_TmpSignalConversionAtVeT_j5;

            /* End of Outputs for SubSystem: '<S1609>/CountDownResetTriggerEnabled1' */
            /* End of Outputs for SubSystem: '<S1607>/eng_Req_Delyd' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S1607>/HTSOV_previous' incorporates:
             *  ActionPort: '<S1608>/g'
             */
            /* Merge: '<S1607>/Merge' incorporates:
             *  Constant: '<S1608>/FALSEConstant'
             *  SignalConversion generated from: '<S1608>/TurnOff_eng'
             */
            rtb_TmpSignalConversionAtVeBT_m = false;

            /* End of Outputs for SubSystem: '<S1607>/HTSOV_previous' */
        }

        /* End of If: '<S1607>/If' */

        /* Switch: '<S1607>/Switch3' incorporates:
         *  Constant: '<S1547>/Calib'
         *  Constant: '<S1607>/ConstantValue1'
         *  Constant: '<S1607>/ConstantValue4'
         *  RelationalOperator: '<S1607>/Comparison1'
         *  RelationalOperator: '<S1607>/Comparison3'
         *  Switch: '<S1607>/Switch1'
         */
        if (KeTHMR_y_DelayEngTurn_OffSelAp == 1)
        {
            /* Merge: '<S1470>/Merge1' */
            VeTHMR_b_ThrmSysEng_Raw = rtb_TmpSignalConversionAtVeBT_m;
        }
        else if (KeTHMR_y_DelayEngTurn_OffSelAp == 2)
        {
            /* Switch: '<S1607>/Switch1' incorporates:
             *  Merge: '<S1470>/Merge1'
             */
            VeTHMR_b_ThrmSysEng_Raw = rtb_RelationalOperator7_p;
        }
        else
        {
            /* Merge: '<S1470>/Merge1' incorporates:
             *  Constant: '<S1607>/ConstantValue2'
             *  RelationalOperator: '<S1607>/Comparison2'
             *  Switch: '<S1607>/Switch1'
             *  Switch: '<S1607>/Switch2'
             */
            VeTHMR_b_ThrmSysEng_Raw = ((KeTHMR_y_DelayEngTurn_OffSelAp == 3) &&
                (VeTHMR_b_HCCT_ErrLargNegativ));
        }

        /* End of Switch: '<S1607>/Switch3' */

        /* Merge: '<S1470>/Merge2' incorporates:
         *  Constant: '<S1553>/FALSEConstant2'
         *  Gain: '<S1606>/Gain'
         */
        VeTHMR_b_HT_Shtoff_VlvCmd_B4PWup = false;

        /* End of Outputs for SubSystem: '<S1470>/c' */
        break;

      case 3:
        /* Outputs for IfAction SubSystem: '<S1470>/d' incorporates:
         *  ActionPort: '<S1554>/d'
         */
        /* Gain: '<S1612>/Gain' */
        VeTHMR_P_ECH_HtrPwrTgt_d = VeTHMR_P_ActvTotPwr;

        /* Merge: '<S1470>/Merge' incorporates:
         *  SignalConversion: '<S1554>/SignalConversion'
         */
        VeTHMR_P_ECH_HtrPwrTgt_a = VeTHMR_P_ECH_HtrPwrTgt_d;

        /* If: '<S1614>/If' */
        rtPrevAction = THMR_ac_DW.If_ActiveSubsystem_n;
        rtAction = (sint8)((!rtb_TmpSignalConversionAtVeBT_m) ? 1 : 0);
        THMR_ac_DW.If_ActiveSubsystem_n = rtAction;
        if (rtAction == 0)
        {
            if (0 != rtPrevAction)
            {
                /* SystemReset for IfAction SubSystem: '<S1614>/eng_Req_Delyd' incorporates:
                 *  ActionPort: '<S1616>/d'
                 */
                /* SystemReset for Atomic SubSystem: '<S1616>/CountDownResetTriggerEnabled1' */
                /* SystemReset for If: '<S1614>/If' incorporates:
                 *  UnitDelay: '<S1617>/UnitDelay'
                 *  UnitDelay: '<S1618>/UnitDelay'
                 */
                THMR_ac_DW.UnitDelay_DSTATE_fl = 0.0F;

                /* SystemReset for Atomic SubSystem: '<S1617>/EdgeRising' */
                THMR_ac_DW.UnitDelay_DSTATE_cym = false;

                /* End of SystemReset for SubSystem: '<S1617>/EdgeRising' */
                /* End of SystemReset for SubSystem: '<S1616>/CountDownResetTriggerEnabled1' */
                /* End of SystemReset for SubSystem: '<S1614>/eng_Req_Delyd' */
            }

            /* Outputs for IfAction SubSystem: '<S1614>/eng_Req_Delyd' incorporates:
             *  ActionPort: '<S1616>/d'
             */
            /* Outputs for Atomic SubSystem: '<S1616>/CountDownResetTriggerEnabled1' */
            /* Outputs for Atomic SubSystem: '<S1617>/EdgeRising' */
            /* Logic: '<S1618>/OR1' incorporates:
             *  UnitDelay: '<S1618>/UnitDelay'
             */
            rtb_TmpSignalConversionAtVeBT_f = !THMR_ac_DW.UnitDelay_DSTATE_cym;

            /* Update for UnitDelay: '<S1618>/UnitDelay' incorporates:
             *  Constant: '<S1616>/TRUEConstant5'
             */
            THMR_ac_DW.UnitDelay_DSTATE_cym = true;

            /* Switch: '<S1617>/Switch1' incorporates:
             *  Constant: '<S1617>/ConstantValue'
             *  Logic: '<S1618>/AND'
             *  RelationalOperator: '<S1617>/GreaterThan'
             *  Switch: '<S1617>/Switch2'
             *  UnitDelay: '<S1617>/UnitDelay'
             */
            if (rtb_TmpSignalConversionAtVeBT_f)
            {
                /* Switch: '<S1617>/Switch1' */
                rtb_TmpSignalConversionAtVeT_j5 = VeTHMR_t_EngTurnOff_DelayTim;
            }
            else if (THMR_ac_DW.UnitDelay_DSTATE_fl > 0.0F)
            {
                /* Switch: '<S1617>/Switch2' incorporates:
                 *  Constant: '<S1617>/ConstantValue1'
                 *  Sum: '<S1617>/Subtraction'
                 *  Switch: '<S1617>/Switch1'
                 *  UnitDelay: '<S1617>/UnitDelay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_fl
                    - 1.0F;
            }
            else
            {
                /* Switch: '<S1617>/Switch1' incorporates:
                 *  Switch: '<S1617>/Switch2'
                 *  UnitDelay: '<S1617>/UnitDelay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_fl;
            }

            /* End of Switch: '<S1617>/Switch1' */
            /* End of Outputs for SubSystem: '<S1617>/EdgeRising' */

            /* Merge: '<S1614>/Merge' incorporates:
             *  Constant: '<S1617>/ConstantValue2'
             *  RelationalOperator: '<S1617>/GreaterThan1'
             */
            rtb_TmpSignalConversionAtVeBT_m = (rtb_TmpSignalConversionAtVeT_j5 >
                0.0F);

            /* Update for UnitDelay: '<S1617>/UnitDelay' */
            THMR_ac_DW.UnitDelay_DSTATE_fl = rtb_TmpSignalConversionAtVeT_j5;

            /* End of Outputs for SubSystem: '<S1616>/CountDownResetTriggerEnabled1' */
            /* End of Outputs for SubSystem: '<S1614>/eng_Req_Delyd' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S1614>/HTSOV_previous' incorporates:
             *  ActionPort: '<S1615>/g'
             */
            /* Merge: '<S1614>/Merge' incorporates:
             *  Constant: '<S1615>/FALSEConstant'
             *  SignalConversion generated from: '<S1615>/TurnOff_eng'
             */
            rtb_TmpSignalConversionAtVeBT_m = false;

            /* End of Outputs for SubSystem: '<S1614>/HTSOV_previous' */
        }

        /* End of If: '<S1614>/If' */

        /* Switch: '<S1614>/Switch3' incorporates:
         *  Constant: '<S1547>/Calib'
         *  Constant: '<S1614>/ConstantValue1'
         *  Constant: '<S1614>/ConstantValue4'
         *  RelationalOperator: '<S1614>/Comparison1'
         *  RelationalOperator: '<S1614>/Comparison3'
         *  Switch: '<S1614>/Switch1'
         */
        if (KeTHMR_y_DelayEngTurn_OffSelAp == 1)
        {
            /* Merge: '<S1470>/Merge1' */
            VeTHMR_b_ThrmSysEng_Raw = rtb_TmpSignalConversionAtVeBT_m;
        }
        else if (KeTHMR_y_DelayEngTurn_OffSelAp == 2)
        {
            /* Switch: '<S1614>/Switch1' incorporates:
             *  Merge: '<S1470>/Merge1'
             */
            VeTHMR_b_ThrmSysEng_Raw = rtb_RelationalOperator7_p;
        }
        else
        {
            /* Merge: '<S1470>/Merge1' incorporates:
             *  Constant: '<S1614>/ConstantValue2'
             *  RelationalOperator: '<S1614>/Comparison2'
             *  Switch: '<S1614>/Switch1'
             *  Switch: '<S1614>/Switch2'
             */
            VeTHMR_b_ThrmSysEng_Raw = ((KeTHMR_y_DelayEngTurn_OffSelAp == 3) &&
                (VeTHMR_b_HCCT_ErrLargNegativ));
        }

        /* End of Switch: '<S1614>/Switch3' */

        /* Merge: '<S1470>/Merge2' incorporates:
         *  Constant: '<S1554>/TRUEConstant1'
         *  Gain: '<S1613>/Gain'
         */
        VeTHMR_b_HT_Shtoff_VlvCmd_B4PWup = true;

        /* End of Outputs for SubSystem: '<S1470>/d' */
        break;

      case 4:
        /* Outputs for IfAction SubSystem: '<S1470>/e' incorporates:
         *  ActionPort: '<S1555>/e'
         */
        /* Switch: '<S1636>/Switch1' incorporates:
         *  Constant: '<S1469>/Calib'
         */
        if (KeTHMR_b_UseSepPwr_P1P4)
        {
            /* Switch: '<S1636>/Switch1' incorporates:
             *  MinMax: '<S1627>/MinMax'
             */
            rtb_TmpSignalConversionAtVeT_j5 = fminf(VeTHMR_P_ActvTotPwr,
                VeTHMR_P_PwrAvaiConstraint_1);
        }
        else
        {
            /* Switch: '<S1636>/Switch1' */
            rtb_TmpSignalConversionAtVeT_j5 = VeTHMR_P_PwrAvaiConstraint_1;
        }

        /* End of Switch: '<S1636>/Switch1' */

        /* Lookup_n-D: '<S1641>/Vector' incorporates:
         *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
         */
        VeTHMR_P_ECH_HtrPwrTgt_FuelEcnmy = look1_iflf_binlcapw
            (TmpSignalConversionAtOutAirTemp, ((const float32 *)
              &(KxTHMR_P_ECH_HtrPwrTgt_FuelEcnmy[0])), ((const float32 *)
              &(KtTHMR_P_ECH_HtrPwrTgt_FuelEcnmy[0])), 9U);

        /* Outputs for Function Call SubSystem: '<S2>/LTCL' */
        /* Switch: '<S1627>/Switch4' incorporates:
         *  Constant: '<S1634>/Constant'
         *  Constant: '<S1635>/Constant'
         *  Constant: '<S1639>/Calib'
         *  Constant: '<S1640>/Calib'
         *  Logic: '<S1627>/Logical1'
         *  Logic: '<S1627>/Logical2'
         *  Logic: '<S1627>/Logical5'
         *  RelationalOperator: '<S1627>/Comparison1'
         *  RelationalOperator: '<S1627>/Comparison6'
         *  RelationalOperator: '<S2869>/RelationalOperator'
         *  Switch: '<S3945>/Switch'
         */
        if ((((CeSSDR_e_KeyCrank == ((uint32)VeTHMR_e_SSDR_KeySts)) || (((uint32)
                VeTHMR_e_SSDR_KeySts) == CeSSDR_e_KeyPostCrnk)) &&
                (KeTHMR_b_ECH_HtrPwrTgt_FuelEcnmy_KeyEnb)) ||
                (KeTHMR_b_ECH_HtrPwrTgt_FuelEcnmy_e_SD))
        {
            /* Switch: '<S1627>/Switch4' */
            rtb_Switch1_pi = VeTHMR_P_ECH_HtrPwrTgt_FuelEcnmy;
        }
        else
        {
            /* Switch: '<S1627>/Switch4' incorporates:
             *  Constant: '<S1637>/Calib'
             */
            rtb_Switch1_pi = KeTHMR_P_ECH_HtrPwrTgt_Max_e;
        }

        /* End of Switch: '<S1627>/Switch4' */
        /* End of Outputs for SubSystem: '<S2>/LTCL' */

        /* Outputs for Atomic SubSystem: '<S1627>/Limiter1' */
        /* Switch: '<S1642>/Switch1' incorporates:
         *  RelationalOperator: '<S1642>/RelationalOperator'
         */
        if (rtb_Switch1_pi < rtb_TmpSignalConversionAtVeT_j5)
        {
            /* Switch: '<S1642>/Switch1' */
            rtb_TmpSignalConversionAtVeT_j5 = rtb_Switch1_pi;
        }

        /* End of Switch: '<S1642>/Switch1' */

        /* Switch: '<S1642>/Switch' incorporates:
         *  Constant: '<S1638>/Calib'
         *  RelationalOperator: '<S1642>/RelationalOperator1'
         */
        if (rtb_TmpSignalConversionAtVeT_j5 > KeTHMR_P_ECH_HtrPwrTgt_Min_e)
        {
            /* Switch: '<S1642>/Switch' */
            VeTHMR_P_ECH_HtrPwrTgt_e = rtb_TmpSignalConversionAtVeT_j5;
        }
        else
        {
            /* Switch: '<S1642>/Switch' */
            VeTHMR_P_ECH_HtrPwrTgt_e = KeTHMR_P_ECH_HtrPwrTgt_Min_e;
        }

        /* End of Switch: '<S1642>/Switch' */
        /* End of Outputs for SubSystem: '<S1627>/Limiter1' */

        /* Merge: '<S1470>/Merge' incorporates:
         *  SignalConversion: '<S1627>/SignalConversion'
         */
        VeTHMR_P_ECH_HtrPwrTgt_a = VeTHMR_P_ECH_HtrPwrTgt_e;

        /* Merge: '<S1470>/Merge1' incorporates:
         *  Constant: '<S1555>/TRUEConstant2'
         *  Gain: '<S1626>/Gain'
         */
        VeTHMR_b_ThrmSysEng_Raw = true;

        /* Outputs for Atomic SubSystem: '<S1620>/CountDownResetTriggerEnabled1' */
        /* Outputs for Atomic SubSystem: '<S1630>/EdgeRising' */
        /* Logic: '<S1632>/OR1' incorporates:
         *  UnitDelay: '<S1632>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeBT_f = !THMR_ac_DW.UnitDelay_DSTATE_k5s;

        /* Update for UnitDelay: '<S1632>/UnitDelay' incorporates:
         *  Constant: '<S1620>/TRUEConstant5'
         */
        THMR_ac_DW.UnitDelay_DSTATE_k5s = true;

        /* Switch: '<S1630>/Switch1' incorporates:
         *  Constant: '<S1630>/ConstantValue'
         *  Logic: '<S1632>/AND'
         *  RelationalOperator: '<S1630>/GreaterThan'
         *  Switch: '<S1630>/Switch2'
         *  UnitDelay: '<S1630>/UnitDelay'
         */
        if (rtb_TmpSignalConversionAtVeBT_f)
        {
            /* Switch: '<S1630>/Switch1' incorporates:
             *  Constant: '<S1631>/Calib'
             */
            rtb_TmpSignalConversionAtVeT_j5 = KeTHMR_t_HTSOV_OpnDelayTim;
        }
        else if (THMR_ac_DW.UnitDelay_DSTATE_cu > 0.0F)
        {
            /* Switch: '<S1630>/Switch2' incorporates:
             *  Constant: '<S1630>/ConstantValue1'
             *  Sum: '<S1630>/Subtraction'
             *  Switch: '<S1630>/Switch1'
             *  UnitDelay: '<S1630>/UnitDelay'
             */
            rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_cu -
                1.0F;
        }
        else
        {
            /* Switch: '<S1630>/Switch1' incorporates:
             *  Switch: '<S1630>/Switch2'
             *  UnitDelay: '<S1630>/UnitDelay'
             */
            rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_cu;
        }

        /* End of Switch: '<S1630>/Switch1' */
        /* End of Outputs for SubSystem: '<S1630>/EdgeRising' */

        /* Update for UnitDelay: '<S1630>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_cu = rtb_TmpSignalConversionAtVeT_j5;

        /* End of Outputs for SubSystem: '<S1620>/CountDownResetTriggerEnabled1' */

        /* Switch: '<S1628>/Switch2' incorporates:
         *  Constant: '<S1643>/Calib'
         */
        if (KeTHMR_b_HTSOV_DlydOpn_AbsVal_S)
        {
            /* Switch: '<S1628>/Switch2' incorporates:
             *  Abs: '<S1628>/Abs'
             *  Sum: '<S1628>/Subtraction'
             */
            rtb_Switch1_pi = fabsf(rtb_TmpSignalConversionAtVeT_n0 -
                                   VeTHMR_T_EngCoolantTemp);
        }
        else
        {
            /* Switch: '<S1628>/Switch2' incorporates:
             *  Sum: '<S1628>/Subtraction'
             */
            rtb_Switch1_pi = rtb_TmpSignalConversionAtVeT_n0 -
                VeTHMR_T_EngCoolantTemp;
        }

        /* End of Switch: '<S1628>/Switch2' */

        /* Outputs for Atomic SubSystem: '<S1555>/Hysteresis' */
        /* Switch: '<S1622>/Switch1' incorporates:
         *  Constant: '<S1625>/Calib'
         *  RelationalOperator: '<S1622>/GreaterThan'
         */
        if (rtb_Switch1_pi > KeTHMR_dT_MinDeltTmp_HTSOV_RSP)
        {
            /* Switch: '<S1622>/Switch1' incorporates:
             *  Constant: '<S1622>/ConstantValue'
             */
            VeTHMR_b_HTSOV_DelydOpn_1e = true;
        }
        else
        {
            /* Switch: '<S1622>/Switch1' incorporates:
             *  Constant: '<S1624>/Calib'
             *  RelationalOperator: '<S1622>/GreaterThan1'
             *  UnitDelay: '<S1622>/UnitDelay'
             */
            VeTHMR_b_HTSOV_DelydOpn_1e = ((rtb_Switch1_pi >=
                KeTHMR_dT_MinDeltTmp_HTSOV_LSP) &&
                (THMR_ac_DW.UnitDelay_DSTATE_lpt));
        }

        /* End of Switch: '<S1622>/Switch1' */

        /* Update for UnitDelay: '<S1622>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_lpt = VeTHMR_b_HTSOV_DelydOpn_1e;

        /* End of Outputs for SubSystem: '<S1555>/Hysteresis' */

        /* Switch: '<S1555>/Switch1' incorporates:
         *  Logic: '<S1555>/Logical21'
         *  UnitDelay: '<S1470>/UnitDelay'
         */
        VeTHMR_b_HTSOV_DelydOpn_2e = ((VeTHMR_b_HTSOV_DelydOpn_1e) &&
            (THMR_ac_DW.UnitDelay_DSTATE_di));

        /* Switch: '<S1555>/Switch3' incorporates:
         *  Constant: '<S1623>/Calib'
         */
        if (KeTHMR_b_HTSOV_DlydOpn_S)
        {
            /* Outputs for Atomic SubSystem: '<S1620>/CountDownResetTriggerEnabled1' */
            /* Merge: '<S1470>/Merge2' incorporates:
             *  Constant: '<S1630>/ConstantValue2'
             *  Logic: '<S1620>/Logical2'
             *  RelationalOperator: '<S1630>/GreaterThan1'
             *  UnitDelay: '<S1470>/UnitDelay'
             */
            VeTHMR_b_HT_Shtoff_VlvCmd_B4PWup = ((rtb_TmpSignalConversionAtVeT_j5
                > 0.0F) && (THMR_ac_DW.UnitDelay_DSTATE_di));

            /* End of Outputs for SubSystem: '<S1620>/CountDownResetTriggerEnabled1' */
        }
        else
        {
            /* Merge: '<S1470>/Merge2' */
            VeTHMR_b_HT_Shtoff_VlvCmd_B4PWup = VeTHMR_b_HTSOV_DelydOpn_2e;
        }

        /* End of Switch: '<S1555>/Switch3' */
        /* End of Outputs for SubSystem: '<S1470>/e' */
        break;

      case 5:
        /* Outputs for IfAction SubSystem: '<S1470>/f' incorporates:
         *  ActionPort: '<S1556>/f'
         */
        /* Switch: '<S1644>/Switch1' incorporates:
         *  Constant: '<S1469>/Calib'
         */
        if (KeTHMR_b_UseSepPwr_P1P4)
        {
            /* Switch: '<S1644>/Switch1' incorporates:
             *  MinMax: '<S1556>/MinMax'
             */
            VeTHMR_P_ECH_HtrPwrTgt_f = fminf(VeTHMR_P_ActvTotPwr,
                VeTHMR_P_PwrAvaiConstraint_1);
        }
        else
        {
            /* Switch: '<S1644>/Switch1' */
            VeTHMR_P_ECH_HtrPwrTgt_f = VeTHMR_P_PwrAvaiConstraint_1;
        }

        /* End of Switch: '<S1644>/Switch1' */

        /* Merge: '<S1470>/Merge' incorporates:
         *  SignalConversion: '<S1556>/SignalConversion'
         */
        VeTHMR_P_ECH_HtrPwrTgt_a = VeTHMR_P_ECH_HtrPwrTgt_f;

        /* If: '<S1647>/If' */
        rtPrevAction = THMR_ac_DW.If_ActiveSubsystem_o;
        rtAction = (sint8)((!rtb_TmpSignalConversionAtVeBT_m) ? 1 : 0);
        THMR_ac_DW.If_ActiveSubsystem_o = rtAction;
        if (rtAction == 0)
        {
            if (0 != rtPrevAction)
            {
                /* SystemReset for IfAction SubSystem: '<S1647>/eng_Req_Delyd' incorporates:
                 *  ActionPort: '<S1649>/g'
                 */
                /* SystemReset for Atomic SubSystem: '<S1649>/CountDownResetTriggerEnabled1' */
                /* SystemReset for If: '<S1647>/If' incorporates:
                 *  UnitDelay: '<S1650>/UnitDelay'
                 *  UnitDelay: '<S1651>/UnitDelay'
                 */
                THMR_ac_DW.UnitDelay_DSTATE_he = 0.0F;

                /* SystemReset for Atomic SubSystem: '<S1650>/EdgeRising' */
                THMR_ac_DW.UnitDelay_DSTATE_hr2 = false;

                /* End of SystemReset for SubSystem: '<S1650>/EdgeRising' */
                /* End of SystemReset for SubSystem: '<S1649>/CountDownResetTriggerEnabled1' */
                /* End of SystemReset for SubSystem: '<S1647>/eng_Req_Delyd' */
            }

            /* Outputs for IfAction SubSystem: '<S1647>/eng_Req_Delyd' incorporates:
             *  ActionPort: '<S1649>/g'
             */
            /* Outputs for Atomic SubSystem: '<S1649>/CountDownResetTriggerEnabled1' */
            /* Outputs for Atomic SubSystem: '<S1650>/EdgeRising' */
            /* Logic: '<S1651>/OR1' incorporates:
             *  UnitDelay: '<S1651>/UnitDelay'
             */
            rtb_TmpSignalConversionAtVeBT_f = !THMR_ac_DW.UnitDelay_DSTATE_hr2;

            /* Update for UnitDelay: '<S1651>/UnitDelay' incorporates:
             *  Constant: '<S1649>/TRUEConstant5'
             */
            THMR_ac_DW.UnitDelay_DSTATE_hr2 = true;

            /* Switch: '<S1650>/Switch1' incorporates:
             *  Constant: '<S1650>/ConstantValue'
             *  Logic: '<S1651>/AND'
             *  RelationalOperator: '<S1650>/GreaterThan'
             *  Switch: '<S1650>/Switch2'
             *  UnitDelay: '<S1650>/UnitDelay'
             */
            if (rtb_TmpSignalConversionAtVeBT_f)
            {
                /* Switch: '<S1650>/Switch1' */
                rtb_TmpSignalConversionAtVeT_j5 = VeTHMR_t_EngTurnOff_DelayTim;
            }
            else if (THMR_ac_DW.UnitDelay_DSTATE_he > 0.0F)
            {
                /* Switch: '<S1650>/Switch2' incorporates:
                 *  Constant: '<S1650>/ConstantValue1'
                 *  Sum: '<S1650>/Subtraction'
                 *  Switch: '<S1650>/Switch1'
                 *  UnitDelay: '<S1650>/UnitDelay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_he
                    - 1.0F;
            }
            else
            {
                /* Switch: '<S1650>/Switch1' incorporates:
                 *  Switch: '<S1650>/Switch2'
                 *  UnitDelay: '<S1650>/UnitDelay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_he;
            }

            /* End of Switch: '<S1650>/Switch1' */
            /* End of Outputs for SubSystem: '<S1650>/EdgeRising' */

            /* Merge: '<S1647>/Merge' incorporates:
             *  Constant: '<S1650>/ConstantValue2'
             *  RelationalOperator: '<S1650>/GreaterThan1'
             */
            rtb_TmpSignalConversionAtVeBT_m = (rtb_TmpSignalConversionAtVeT_j5 >
                0.0F);

            /* Update for UnitDelay: '<S1650>/UnitDelay' */
            THMR_ac_DW.UnitDelay_DSTATE_he = rtb_TmpSignalConversionAtVeT_j5;

            /* End of Outputs for SubSystem: '<S1649>/CountDownResetTriggerEnabled1' */
            /* End of Outputs for SubSystem: '<S1647>/eng_Req_Delyd' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S1647>/HTSOV_previous' incorporates:
             *  ActionPort: '<S1648>/g'
             */
            /* Merge: '<S1647>/Merge' incorporates:
             *  Constant: '<S1648>/FALSEConstant'
             *  SignalConversion generated from: '<S1648>/TurnOff_eng'
             */
            rtb_TmpSignalConversionAtVeBT_m = false;

            /* End of Outputs for SubSystem: '<S1647>/HTSOV_previous' */
        }

        /* End of If: '<S1647>/If' */

        /* Switch: '<S1647>/Switch3' incorporates:
         *  Constant: '<S1547>/Calib'
         *  Constant: '<S1647>/ConstantValue1'
         *  Constant: '<S1647>/ConstantValue4'
         *  RelationalOperator: '<S1647>/Comparison1'
         *  RelationalOperator: '<S1647>/Comparison3'
         *  Switch: '<S1647>/Switch1'
         */
        if (KeTHMR_y_DelayEngTurn_OffSelAp == 1)
        {
            /* Merge: '<S1470>/Merge1' */
            VeTHMR_b_ThrmSysEng_Raw = rtb_TmpSignalConversionAtVeBT_m;
        }
        else if (KeTHMR_y_DelayEngTurn_OffSelAp == 2)
        {
            /* Switch: '<S1647>/Switch1' incorporates:
             *  Merge: '<S1470>/Merge1'
             */
            VeTHMR_b_ThrmSysEng_Raw = rtb_RelationalOperator7_p;
        }
        else
        {
            /* Merge: '<S1470>/Merge1' incorporates:
             *  Constant: '<S1647>/ConstantValue2'
             *  RelationalOperator: '<S1647>/Comparison2'
             *  Switch: '<S1647>/Switch1'
             *  Switch: '<S1647>/Switch2'
             */
            VeTHMR_b_ThrmSysEng_Raw = ((KeTHMR_y_DelayEngTurn_OffSelAp == 3) &&
                (VeTHMR_b_HCCT_ErrLargNegativ));
        }

        /* End of Switch: '<S1647>/Switch3' */

        /* Merge: '<S1470>/Merge2' incorporates:
         *  Constant: '<S1556>/FALSEConstant1'
         *  Gain: '<S1646>/Gain'
         */
        VeTHMR_b_HT_Shtoff_VlvCmd_B4PWup = false;

        /* End of Outputs for SubSystem: '<S1470>/f' */
        break;

      case 6:
        /* Outputs for IfAction SubSystem: '<S1470>/g' incorporates:
         *  ActionPort: '<S1557>/g'
         */
        /* Switch: '<S1652>/Switch1' incorporates:
         *  Constant: '<S1469>/Calib'
         */
        if (KeTHMR_b_UseSepPwr_P1P4)
        {
            /* Switch: '<S1652>/Switch1' incorporates:
             *  MinMax: '<S1557>/MinMax'
             */
            VeTHMR_P_ECH_HtrPwrTgt_g = fminf(VeTHMR_P_ActvTotPwr,
                VeTHMR_P_PwrAvaiConstraint_1);
        }
        else
        {
            /* Switch: '<S1652>/Switch1' */
            VeTHMR_P_ECH_HtrPwrTgt_g = VeTHMR_P_PwrAvaiConstraint_1;
        }

        /* End of Switch: '<S1652>/Switch1' */

        /* Merge: '<S1470>/Merge' incorporates:
         *  SignalConversion: '<S1557>/SignalConversion'
         */
        VeTHMR_P_ECH_HtrPwrTgt_a = VeTHMR_P_ECH_HtrPwrTgt_g;

        /* If: '<S1655>/If' */
        rtPrevAction = THMR_ac_DW.If_ActiveSubsystem_l;
        rtAction = (sint8)((!rtb_TmpSignalConversionAtVeBT_m) ? 1 : 0);
        THMR_ac_DW.If_ActiveSubsystem_l = rtAction;
        if (rtAction == 0)
        {
            if (0 != rtPrevAction)
            {
                /* SystemReset for IfAction SubSystem: '<S1655>/eng_Req_Delyd' incorporates:
                 *  ActionPort: '<S1657>/g'
                 */
                /* SystemReset for Atomic SubSystem: '<S1657>/CountDownResetTriggerEnabled1' */
                /* SystemReset for If: '<S1655>/If' incorporates:
                 *  UnitDelay: '<S1658>/UnitDelay'
                 *  UnitDelay: '<S1659>/UnitDelay'
                 */
                THMR_ac_DW.UnitDelay_DSTATE_co = 0.0F;

                /* SystemReset for Atomic SubSystem: '<S1658>/EdgeRising' */
                THMR_ac_DW.UnitDelay_DSTATE_hi = false;

                /* End of SystemReset for SubSystem: '<S1658>/EdgeRising' */
                /* End of SystemReset for SubSystem: '<S1657>/CountDownResetTriggerEnabled1' */
                /* End of SystemReset for SubSystem: '<S1655>/eng_Req_Delyd' */
            }

            /* Outputs for IfAction SubSystem: '<S1655>/eng_Req_Delyd' incorporates:
             *  ActionPort: '<S1657>/g'
             */
            /* Outputs for Atomic SubSystem: '<S1657>/CountDownResetTriggerEnabled1' */
            /* Outputs for Atomic SubSystem: '<S1658>/EdgeRising' */
            /* Logic: '<S1659>/OR1' incorporates:
             *  UnitDelay: '<S1659>/UnitDelay'
             */
            rtb_TmpSignalConversionAtVeBT_f = !THMR_ac_DW.UnitDelay_DSTATE_hi;

            /* Update for UnitDelay: '<S1659>/UnitDelay' incorporates:
             *  Constant: '<S1657>/TRUEConstant5'
             */
            THMR_ac_DW.UnitDelay_DSTATE_hi = true;

            /* Switch: '<S1658>/Switch1' incorporates:
             *  Constant: '<S1658>/ConstantValue'
             *  Logic: '<S1659>/AND'
             *  RelationalOperator: '<S1658>/GreaterThan'
             *  Switch: '<S1658>/Switch2'
             *  UnitDelay: '<S1658>/UnitDelay'
             */
            if (rtb_TmpSignalConversionAtVeBT_f)
            {
                /* Switch: '<S1658>/Switch1' */
                rtb_TmpSignalConversionAtVeT_j5 = VeTHMR_t_EngTurnOff_DelayTim;
            }
            else if (THMR_ac_DW.UnitDelay_DSTATE_co > 0.0F)
            {
                /* Switch: '<S1658>/Switch2' incorporates:
                 *  Constant: '<S1658>/ConstantValue1'
                 *  Sum: '<S1658>/Subtraction'
                 *  Switch: '<S1658>/Switch1'
                 *  UnitDelay: '<S1658>/UnitDelay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_co
                    - 1.0F;
            }
            else
            {
                /* Switch: '<S1658>/Switch1' incorporates:
                 *  Switch: '<S1658>/Switch2'
                 *  UnitDelay: '<S1658>/UnitDelay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_co;
            }

            /* End of Switch: '<S1658>/Switch1' */
            /* End of Outputs for SubSystem: '<S1658>/EdgeRising' */

            /* Merge: '<S1655>/Merge' incorporates:
             *  Constant: '<S1658>/ConstantValue2'
             *  RelationalOperator: '<S1658>/GreaterThan1'
             */
            rtb_TmpSignalConversionAtVeBT_m = (rtb_TmpSignalConversionAtVeT_j5 >
                0.0F);

            /* Update for UnitDelay: '<S1658>/UnitDelay' */
            THMR_ac_DW.UnitDelay_DSTATE_co = rtb_TmpSignalConversionAtVeT_j5;

            /* End of Outputs for SubSystem: '<S1657>/CountDownResetTriggerEnabled1' */
            /* End of Outputs for SubSystem: '<S1655>/eng_Req_Delyd' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S1655>/HTSOV_previous' incorporates:
             *  ActionPort: '<S1656>/g'
             */
            /* Merge: '<S1655>/Merge' incorporates:
             *  Constant: '<S1656>/FALSEConstant'
             *  SignalConversion generated from: '<S1656>/TurnOff_eng'
             */
            rtb_TmpSignalConversionAtVeBT_m = false;

            /* End of Outputs for SubSystem: '<S1655>/HTSOV_previous' */
        }

        /* End of If: '<S1655>/If' */

        /* Switch: '<S1655>/Switch3' incorporates:
         *  Constant: '<S1547>/Calib'
         *  Constant: '<S1655>/ConstantValue1'
         *  Constant: '<S1655>/ConstantValue4'
         *  RelationalOperator: '<S1655>/Comparison1'
         *  RelationalOperator: '<S1655>/Comparison3'
         *  Switch: '<S1655>/Switch1'
         */
        if (KeTHMR_y_DelayEngTurn_OffSelAp == 1)
        {
            /* Merge: '<S1470>/Merge1' */
            VeTHMR_b_ThrmSysEng_Raw = rtb_TmpSignalConversionAtVeBT_m;
        }
        else if (KeTHMR_y_DelayEngTurn_OffSelAp == 2)
        {
            /* Switch: '<S1655>/Switch1' incorporates:
             *  Merge: '<S1470>/Merge1'
             */
            VeTHMR_b_ThrmSysEng_Raw = rtb_RelationalOperator7_p;
        }
        else
        {
            /* Merge: '<S1470>/Merge1' incorporates:
             *  Constant: '<S1655>/ConstantValue2'
             *  RelationalOperator: '<S1655>/Comparison2'
             *  Switch: '<S1655>/Switch1'
             *  Switch: '<S1655>/Switch2'
             */
            VeTHMR_b_ThrmSysEng_Raw = ((KeTHMR_y_DelayEngTurn_OffSelAp == 3) &&
                (VeTHMR_b_HCCT_ErrLargNegativ));
        }

        /* End of Switch: '<S1655>/Switch3' */

        /* Merge: '<S1470>/Merge2' incorporates:
         *  Constant: '<S1557>/TRUEConstant2'
         *  Gain: '<S1654>/Gain'
         */
        VeTHMR_b_HT_Shtoff_VlvCmd_B4PWup = true;

        /* End of Outputs for SubSystem: '<S1470>/g' */
        break;

      default:
        /* Outputs for IfAction SubSystem: '<S1470>/h' incorporates:
         *  ActionPort: '<S1558>/h'
         */
        /* Gain: '<S1660>/Gain' incorporates:
         *  Constant: '<S1546>/Calib'
         */
        VeTHMR_P_ECH_HtrPwrTgt_h = KeTHMR_P_PwrHtrOff;

        /* Merge: '<S1470>/Merge' incorporates:
         *  SignalConversion: '<S1558>/SignalConversion'
         */
        VeTHMR_P_ECH_HtrPwrTgt_a = VeTHMR_P_ECH_HtrPwrTgt_h;

        /* If: '<S1662>/If' */
        rtPrevAction = THMR_ac_DW.If_ActiveSubsystem_i;
        rtAction = (sint8)((!rtb_TmpSignalConversionAtVeBT_m) ? 1 : 0);
        THMR_ac_DW.If_ActiveSubsystem_i = rtAction;
        if (rtAction == 0)
        {
            if (0 != rtPrevAction)
            {
                /* SystemReset for IfAction SubSystem: '<S1662>/eng_Req_Delyd' incorporates:
                 *  ActionPort: '<S1664>/g'
                 */
                /* SystemReset for Atomic SubSystem: '<S1664>/CountDownResetTriggerEnabled1' */
                /* SystemReset for If: '<S1662>/If' incorporates:
                 *  UnitDelay: '<S1665>/UnitDelay'
                 *  UnitDelay: '<S1666>/UnitDelay'
                 */
                THMR_ac_DW.UnitDelay_DSTATE_ey = 0.0F;

                /* SystemReset for Atomic SubSystem: '<S1665>/EdgeRising' */
                THMR_ac_DW.UnitDelay_DSTATE_fgp = false;

                /* End of SystemReset for SubSystem: '<S1665>/EdgeRising' */
                /* End of SystemReset for SubSystem: '<S1664>/CountDownResetTriggerEnabled1' */
                /* End of SystemReset for SubSystem: '<S1662>/eng_Req_Delyd' */
            }

            /* Outputs for IfAction SubSystem: '<S1662>/eng_Req_Delyd' incorporates:
             *  ActionPort: '<S1664>/g'
             */
            /* Outputs for Atomic SubSystem: '<S1664>/CountDownResetTriggerEnabled1' */
            /* Outputs for Atomic SubSystem: '<S1665>/EdgeRising' */
            /* Logic: '<S1666>/OR1' incorporates:
             *  UnitDelay: '<S1666>/UnitDelay'
             */
            rtb_TmpSignalConversionAtVeBT_f = !THMR_ac_DW.UnitDelay_DSTATE_fgp;

            /* Update for UnitDelay: '<S1666>/UnitDelay' incorporates:
             *  Constant: '<S1664>/TRUEConstant5'
             */
            THMR_ac_DW.UnitDelay_DSTATE_fgp = true;

            /* Switch: '<S1665>/Switch1' incorporates:
             *  Constant: '<S1665>/ConstantValue'
             *  Logic: '<S1666>/AND'
             *  RelationalOperator: '<S1665>/GreaterThan'
             *  Switch: '<S1665>/Switch2'
             *  UnitDelay: '<S1665>/UnitDelay'
             */
            if (rtb_TmpSignalConversionAtVeBT_f)
            {
                /* Switch: '<S1665>/Switch1' */
                rtb_TmpSignalConversionAtVeT_j5 = VeTHMR_t_EngTurnOff_DelayTim;
            }
            else if (THMR_ac_DW.UnitDelay_DSTATE_ey > 0.0F)
            {
                /* Switch: '<S1665>/Switch2' incorporates:
                 *  Constant: '<S1665>/ConstantValue1'
                 *  Sum: '<S1665>/Subtraction'
                 *  Switch: '<S1665>/Switch1'
                 *  UnitDelay: '<S1665>/UnitDelay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_ey
                    - 1.0F;
            }
            else
            {
                /* Switch: '<S1665>/Switch1' incorporates:
                 *  Switch: '<S1665>/Switch2'
                 *  UnitDelay: '<S1665>/UnitDelay'
                 */
                rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay_DSTATE_ey;
            }

            /* End of Switch: '<S1665>/Switch1' */
            /* End of Outputs for SubSystem: '<S1665>/EdgeRising' */

            /* Merge: '<S1662>/Merge' incorporates:
             *  Constant: '<S1665>/ConstantValue2'
             *  RelationalOperator: '<S1665>/GreaterThan1'
             */
            rtb_TmpSignalConversionAtVeBT_m = (rtb_TmpSignalConversionAtVeT_j5 >
                0.0F);

            /* Update for UnitDelay: '<S1665>/UnitDelay' */
            THMR_ac_DW.UnitDelay_DSTATE_ey = rtb_TmpSignalConversionAtVeT_j5;

            /* End of Outputs for SubSystem: '<S1664>/CountDownResetTriggerEnabled1' */
            /* End of Outputs for SubSystem: '<S1662>/eng_Req_Delyd' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S1662>/HTSOV_previous' incorporates:
             *  ActionPort: '<S1663>/g'
             */
            /* Merge: '<S1662>/Merge' incorporates:
             *  Constant: '<S1663>/FALSEConstant'
             *  SignalConversion generated from: '<S1663>/TurnOff_eng'
             */
            rtb_TmpSignalConversionAtVeBT_m = false;

            /* End of Outputs for SubSystem: '<S1662>/HTSOV_previous' */
        }

        /* End of If: '<S1662>/If' */

        /* Switch: '<S1662>/Switch3' incorporates:
         *  Constant: '<S1547>/Calib'
         *  Constant: '<S1662>/ConstantValue1'
         *  Constant: '<S1662>/ConstantValue4'
         *  RelationalOperator: '<S1662>/Comparison1'
         *  RelationalOperator: '<S1662>/Comparison3'
         *  Switch: '<S1662>/Switch1'
         */
        if (KeTHMR_y_DelayEngTurn_OffSelAp == 1)
        {
            /* Merge: '<S1470>/Merge1' */
            VeTHMR_b_ThrmSysEng_Raw = rtb_TmpSignalConversionAtVeBT_m;
        }
        else if (KeTHMR_y_DelayEngTurn_OffSelAp == 2)
        {
            /* Switch: '<S1662>/Switch1' incorporates:
             *  Merge: '<S1470>/Merge1'
             */
            VeTHMR_b_ThrmSysEng_Raw = rtb_RelationalOperator7_p;
        }
        else
        {
            /* Merge: '<S1470>/Merge1' incorporates:
             *  Constant: '<S1662>/ConstantValue2'
             *  RelationalOperator: '<S1662>/Comparison2'
             *  Switch: '<S1662>/Switch1'
             *  Switch: '<S1662>/Switch2'
             */
            VeTHMR_b_ThrmSysEng_Raw = ((KeTHMR_y_DelayEngTurn_OffSelAp == 3) &&
                (VeTHMR_b_HCCT_ErrLargNegativ));
        }

        /* End of Switch: '<S1662>/Switch3' */

        /* Merge: '<S1470>/Merge2' incorporates:
         *  Constant: '<S1558>/FALSEConstant'
         *  Gain: '<S1661>/Gain'
         */
        VeTHMR_b_HT_Shtoff_VlvCmd_B4PWup = false;

        /* End of Outputs for SubSystem: '<S1470>/h' */
        break;
    }

    /* End of If: '<S1470>/If' */

    /* Switch: '<S1154>/Switch3' */
    if (THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0)
    {
        /* Switch: '<S1154>/Switch3' */
        VeTHMR_b_HTSO_VlvCmdAPerWp = VeTHMR_b_PerWp_HTSO_VlvCmd_B4D;
    }
    else
    {
        /* Switch: '<S1154>/Switch3' */
        VeTHMR_b_HTSO_VlvCmdAPerWp = VeTHMR_b_HT_Shtoff_VlvCmd_B4PWup;
    }

    /* End of Switch: '<S1154>/Switch3' */

    /* Logic: '<S1450>/Logical3' incorporates:
     *  Constant: '<S1452>/Calib'
     *  Constant: '<S1453>/Calib'
     *  Constant: '<S1454>/Calib'
     *  Logic: '<S1450>/Logical1'
     *  RelationalOperator: '<S1450>/Comparison4'
     *  RelationalOperator: '<S1450>/Comparison5'
     *  RelationalOperator: '<S1450>/Comparison6'
     */
    VeTHMR_b_MainPmpCav_CondMet = (((KeTHMR_T_ECT_CavitLo <
        VeTHMR_T_EngCoolantTemp) && (VeTHMR_T_EngCoolantTemp <=
        KeTHMR_T_ECT_CavitHi)) && (VeTHMR_n_InputSpeed >=
        KeTHMR_n_PumpCavEng_RPM));

    /* Switch: '<S1440>/Switch1' incorporates:
     *  Constant: '<S1422>/Calib'
     *  Constant: '<S1436>/Constant'
     *  Constant: '<S1438>/Constant'
     *  Constant: '<S1448>/Calib'
     *  Constant: '<S1455>/Constant'
     *  Constant: '<S1456>/Calib'
     *  Logic: '<S1412>/LogicalOperator4'
     *  Logic: '<S1426>/Logical2'
     *  Logic: '<S1426>/Logical4'
     *  Logic: '<S1451>/Logical3'
     *  Logic: '<S1451>/LogicalOperator'
     *  RelationalOperator: '<S1412>/Comparison2'
     *  RelationalOperator: '<S1426>/Comparison1'
     *  RelationalOperator: '<S1451>/Comparison1'
     *  RelationalOperator: '<S2869>/RelationalOperator'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     *  Switch: '<S1153>/Switch2'
     *  Switch: '<S1439>/Switch1'
     *  Switch: '<S1441>/Switch1'
     *  Switch: '<S1442>/Switch1'
     *  Switch: '<S1443>/Switch1'
     *  Switch: '<S3945>/Switch'
     */
    if (VeTHMR_b_Switch2ActValue_Vlv_Init0)
    {
        /* Switch: '<S1440>/Switch1' incorporates:
         *  Constant: '<S1447>/Calib'
         */
        VeTHMR_b_HT_Shtoff_VlvCmd_B4D = KeTHMR_b_HT_Shtoff_VlvCmd_TemporDial;
    }
    else if (rtb_VariantMerge_For_Variant_p3 || (((uint32)
               rtb_TmpSignalConversionAtVePD_l) == CePDTR_e_Dischrg_AmbTempLow))
    {
        /* Switch: '<S1441>/Switch1' incorporates:
         *  Constant: '<S1449>/Calib'
         *  Switch: '<S1440>/Switch1'
         */
        VeTHMR_b_HT_Shtoff_VlvCmd_B4D = KeTHMR_b_SO_VlvCmdOpn_OV_Dial;
    }
    else if (((!rtb_TmpSignalConversionAtVeTR_k) &&
              (KeTHMR_b_MaxAC_Enbl_HTSOV_VlvCmdCls)) && (((uint32)
               rtb_TmpSignalConversionAtVeTR_f) == CeTRIR_e_MAX_AC))
    {
        /* Switch: '<S1442>/Switch1' incorporates:
         *  Constant: '<S1445>/Calib'
         *  Switch: '<S1440>/Switch1'
         *  Switch: '<S1441>/Switch1'
         */
        VeTHMR_b_HT_Shtoff_VlvCmd_B4D = KeTHMR_b_HTSOV_VlvCmdCls_MaxAC;
    }
    else if (VeTHMR_b_MainPmpCav_CondMet)
    {
        /* Switch: '<S1443>/Switch1' incorporates:
         *  Constant: '<S1446>/Calib'
         *  Switch: '<S1440>/Switch1'
         *  Switch: '<S1441>/Switch1'
         *  Switch: '<S1442>/Switch1'
         */
        VeTHMR_b_HT_Shtoff_VlvCmd_B4D = KeTHMR_b_HTSO_VlvCmdCls_PmpCav;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S2>/LTCL' */
        if (((((((uint32)VeTHMR_e_SSDR_KeySts) == CeSSDR_e_KeyRun) &&
                (!rtb_TmpSignalConversionAtPropSy)) && (VeTHMR_b_PlugdIn_Or_Chrg))
             && (THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i)) &&
                (KeTHMR_b_HTSOV_Cls_KeyRun_Charging))
        {
            /* Switch: '<S1439>/Switch1' incorporates:
             *  Constant: '<S1444>/Calib'
             *  Switch: '<S1440>/Switch1'
             *  Switch: '<S1441>/Switch1'
             *  Switch: '<S1442>/Switch1'
             *  Switch: '<S1443>/Switch1'
             */
            VeTHMR_b_HT_Shtoff_VlvCmd_B4D = KeTHMR_b_HTSOV_Cmd_KeyRun;
        }
        else if (KeTHMR_b_HeatState_HTSOV_Enbl)
        {
            /* Switch: '<S1153>/Switch2' incorporates:
             *  Switch: '<S1439>/Switch1'
             *  Switch: '<S1440>/Switch1'
             *  Switch: '<S1441>/Switch1'
             *  Switch: '<S1442>/Switch1'
             *  Switch: '<S1443>/Switch1'
             */
            VeTHMR_b_HT_Shtoff_VlvCmd_B4D = VeTHMR_b_HTSOV_Cmd_HeatState;
        }
        else
        {
            /* Switch: '<S1440>/Switch1' incorporates:
             *  Switch: '<S1153>/Switch2'
             *  Switch: '<S1439>/Switch1'
             *  Switch: '<S1441>/Switch1'
             *  Switch: '<S1442>/Switch1'
             *  Switch: '<S1443>/Switch1'
             */
            VeTHMR_b_HT_Shtoff_VlvCmd_B4D = VeTHMR_b_HTSO_VlvCmdAPerWp;
        }

        /* End of Outputs for SubSystem: '<S2>/LTCL' */
    }

    /* End of Switch: '<S1440>/Switch1' */

    /* Logic: '<S1164>/Logical2' incorporates:
     *  Logic: '<S1164>/Logical4'
     */
    rtb_VariantMerge_For_Variant_p3 = ((rtb_TmpSignalConversionAtVeCT_c &&
        rtb_LogicalOperator1_fo) && (rtb_LogicalOperator_aa || rtb_AND_de));

    /* Outputs for Atomic SubSystem: '<S1164>/EdgeRising1' */
    /* Logic: '<S1964>/OR1' incorporates:
     *  UnitDelay: '<S1964>/Unit Delay'
     */
    rtb_TmpSignalConversionAtVeBT_f = !THMR_ac_DW.UnitDelay_DSTATE_nq;

    /* Update for UnitDelay: '<S1964>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_nq = rtb_VariantMerge_For_Variant_p3;

    /* End of Outputs for SubSystem: '<S1164>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S1164>/EdgeRising2' */
    /* Logic: '<S1965>/OR1' incorporates:
     *  UnitDelay: '<S1965>/Unit Delay'
     */
    rtb_TmpSignalConversionAtVeBT_m = !THMR_ac_DW.UnitDelay_DSTATE_eu;

    /* Update for UnitDelay: '<S1965>/Unit Delay' incorporates:
     *  Constant: '<S1164>/TRUE Constant2'
     */
    THMR_ac_DW.UnitDelay_DSTATE_eu = true;

    /* Outputs for Atomic SubSystem: '<S1164>/Signal Latch Off With Reset' */
    /* Outputs for Atomic SubSystem: '<S1164>/EdgeRising1' */
    /* Logic: '<S1988>/OR2' incorporates:
     *  Logic: '<S1164>/Logical23'
     *  Logic: '<S1964>/AND'
     *  Logic: '<S1965>/AND'
     *  Logic: '<S1988>/OR'
     *  UnitDelay: '<S1988>/Unit Delay'
     */
    VeTHMR_b_ThermSystEng_Req_HeatState = (rtb_NotEqual_fo &&
        (((rtb_VariantMerge_For_Variant_p3 && rtb_TmpSignalConversionAtVeBT_f) ||
          rtb_TmpSignalConversionAtVeBT_m) || (THMR_ac_DW.UnitDelay_DSTATE_n1)));

    /* End of Outputs for SubSystem: '<S1164>/EdgeRising1' */
    /* End of Outputs for SubSystem: '<S1164>/EdgeRising2' */

    /* Update for UnitDelay: '<S1988>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_n1 = VeTHMR_b_ThermSystEng_Req_HeatState;

    /* End of Outputs for SubSystem: '<S1164>/Signal Latch Off With Reset' */

    /* RelationalOperator: '<S1470>/Comparison3' incorporates:
     *  Constant: '<S1543>/Constant'
     *  Switch: '<S1576>/Switch1'
     */
    rtb_VariantMerge_For_Variant_p3 = (((uint32)VeTHMR_e_EngHtr_HTSOV_State) ==
        CeTHMR_e_StateE);

    /* Outputs for Atomic SubSystem: '<S1470>/EdgeRising1' */
    /* Logic: '<S1544>/OR1' incorporates:
     *  UnitDelay: '<S1544>/UnitDelay'
     */
    rtb_NotEqual_fo = !THMR_ac_DW.UnitDelay_DSTATE_hv;

    /* Update for UnitDelay: '<S1544>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_hv = rtb_VariantMerge_For_Variant_p3;

    /* End of Outputs for SubSystem: '<S1470>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S1470>/EdgeRising2' */
    /* Logic: '<S1545>/OR1' incorporates:
     *  UnitDelay: '<S1545>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeBT_f = !THMR_ac_DW.UnitDelay_DSTATE_hib;

    /* Update for UnitDelay: '<S1545>/UnitDelay' incorporates:
     *  Constant: '<S1470>/TRUEConstant2'
     */
    THMR_ac_DW.UnitDelay_DSTATE_hib = true;

    /* Outputs for Atomic SubSystem: '<S1470>/SignalLatchOffWithReset' */
    /* Outputs for Atomic SubSystem: '<S1470>/EdgeRising1' */
    /* Logic: '<S1548>/OR2' incorporates:
     *  Logic: '<S1470>/Logical23'
     *  Logic: '<S1544>/AND'
     *  Logic: '<S1545>/AND'
     *  Logic: '<S1548>/OR'
     *  UnitDelay: '<S1548>/UnitDelay'
     */
    VeTHMR_b_ThermSystEng_Req_B4PWup = ((VeTHMR_b_ThrmSysEng_Raw) &&
        (((rtb_VariantMerge_For_Variant_p3 && rtb_NotEqual_fo) ||
          rtb_TmpSignalConversionAtVeBT_f) || (THMR_ac_DW.UnitDelay_DSTATE_gv0)));

    /* End of Outputs for SubSystem: '<S1470>/EdgeRising1' */
    /* End of Outputs for SubSystem: '<S1470>/EdgeRising2' */

    /* Update for UnitDelay: '<S1548>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_gv0 = VeTHMR_b_ThermSystEng_Req_B4PWup;

    /* End of Outputs for SubSystem: '<S1470>/SignalLatchOffWithReset' */

    /* Logic: '<S1153>/LogicalOperator1' incorporates:
     *  Constant: '<S1409>/Constant'
     *  Constant: '<S1417>/Calib'
     *  RelationalOperator: '<S1153>/RelationalOperator'
     *  Switch: '<S4586>/Switch1'
     */
    VeTHMR_b_EngOnReq_BattLoopEmrgncyCool_mHEV = ((CeTHMR_e_EmergencyCooling ==
        ((uint32)VeTHMR_e_BatThrmlSt_B4D)) &&
        (KeTHMR_b_BattLoopEmrgncyCool_EnblEngOnReqmHEV));

    /* Logic: '<S1153>/LogicalOperator2' incorporates:
     *  Constant: '<S1416>/Calib'
     */
    VeTHMR_b_EngOnReq_BattCritical_mHEV = (rtb_TmpSignalConversionAtVeB_cu &&
        (KeTHMR_b_BattCritical_EnblEngOnReqmHEV));

    /* SignalConversion: '<S1470>/SignalConversion' */
    VeTHMR_P_ECH_HtrPwrTgt_Lim_B4PWup = VeTHMR_P_ECH_HtrPwrTgt_a;

    /* Switch: '<S1154>/Switch2' incorporates:
     *  Switch: '<S1154>/Switch1'
     */
    if (THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0)
    {
        /* Switch: '<S1154>/Switch2' */
        VeTHMR_b_ThrmSystEng_ReqAPerWp = VeTHMR_b_PerWp_SystEngReq;

        /* Switch: '<S1154>/Switch1' */
        VeTHMR_P_ECH_HtrPwrTgt_Lim_APerWp = VeTHMR_P_PerWp_HtrPwrTgt_Lim;
    }
    else
    {
        /* Switch: '<S1154>/Switch2' */
        VeTHMR_b_ThrmSystEng_ReqAPerWp = VeTHMR_b_ThermSystEng_Req_B4PWup;

        /* Switch: '<S1154>/Switch1' */
        VeTHMR_P_ECH_HtrPwrTgt_Lim_APerWp = VeTHMR_P_ECH_HtrPwrTgt_Lim_B4PWup;
    }

    /* End of Switch: '<S1154>/Switch2' */

    /* Switch: '<S1153>/Switch5' incorporates:
     *  Constant: '<S1419>/Calib'
     */
    if (!KeTHMR_b_ECHOutTemp_HCCTIS_Dial)
    {
        rtb_TmpSignalConversionAtVeHT_h = VeTHMR_T_HCCTISArb;
    }

    /* End of Switch: '<S1153>/Switch5' */

    /* Switch: '<S1427>/Switch2' incorporates:
     *  Constant: '<S1457>/Calib'
     *  Constant: '<S1458>/Calib'
     *  Constant: '<S1460>/Constant'
     *  Constant: '<S1461>/Constant'
     *  Logic: '<S1459>/LogicalOperator'
     *  RelationalOperator: '<S1459>/RelationalOperator1'
     *  RelationalOperator: '<S1459>/RelationalOperator2'
     */
    if ((CeRCVR_e_SNA == ((uint32)rtb_TmpSignalConversionAtVeRC_a)) || (((uint32)
            rtb_TmpSignalConversionAtVeRC_a) == CeRCVR_e_Faulty_Open))
    {
        rtb_Switch10 = KeTHMR_T_MaxHTCLTemp_HTLVlvOpenFlt;
    }
    else
    {
        rtb_Switch10 = KeTHMR_T_MaxHTCLTemp;
    }

    /* End of Switch: '<S1427>/Switch2' */

    /* Sum: '<S1410>/Sum1' */
    rtb_TmpSignalConversionAtVeHT_h -= rtb_Switch10;

    /* Outputs for Atomic SubSystem: '<S1410>/EdgeRising' */
    /* Logic: '<S1428>/OR1' incorporates:
     *  UnitDelay: '<S1428>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant_p3 = !THMR_ac_DW.UnitDelay_DSTATE_fi;

    /* Update for UnitDelay: '<S1428>/UnitDelay' incorporates:
     *  Constant: '<S1410>/TRUEConstant'
     */
    THMR_ac_DW.UnitDelay_DSTATE_fi = true;

    /* Outputs for Atomic SubSystem: '<S1410>/PIDControl' */
    /* Switch: '<S1434>/Switch' incorporates:
     *  Logic: '<S1428>/AND'
     */
    if (rtb_VariantMerge_For_Variant_p3)
    {
        /* Switch: '<S1434>/Switch' incorporates:
         *  Constant: '<S1410>/Constant'
         */
        rtb_TmpSignalConversionAtVeT_j5 = 0.0F;
    }
    else
    {
        /* Switch: '<S1434>/Switch' incorporates:
         *  Constant: '<S1410>/Constant1'
         *  Constant: '<S1430>/Calib'
         *  Product: '<S1434>/Multiplication1'
         *  Sum: '<S1434>/Sum//Sub'
         *  UnitDelay: '<S1434>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeT_j5 = ((rtb_TmpSignalConversionAtVeHT_h *
            KeTHMR_K_HTCLTempMitgatn_Ki) * 0.1F) +
            THMR_ac_DW.UnitDelay_DSTATE_o0;
    }

    /* End of Switch: '<S1434>/Switch' */
    /* End of Outputs for SubSystem: '<S1410>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S1434>/integral_term' */
    /* Switch: '<S1435>/Switch1' incorporates:
     *  Constant: '<S1432>/Calib'
     *  RelationalOperator: '<S1435>/RelationalOperator'
     */
    if (KeTHMR_P_HTCLTempMitgatn_MaxPwr < rtb_TmpSignalConversionAtVeT_j5)
    {
        /* Switch: '<S1153>/Switch3' */
        rtb_TmpSignalConversionAtVeHT_k = KeTHMR_P_HTCLTempMitgatn_MaxPwr;
    }
    else
    {
        /* Switch: '<S1153>/Switch3' */
        rtb_TmpSignalConversionAtVeHT_k = rtb_TmpSignalConversionAtVeT_j5;
    }

    /* End of Switch: '<S1435>/Switch1' */

    /* Switch: '<S1435>/Switch' incorporates:
     *  Constant: '<S1410>/Constant2'
     *  RelationalOperator: '<S1435>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeHT_k > 0.0F)
    {
        /* Switch: '<S1435>/Switch' */
        rtb_TmpSignalConversionAtVeT_j5 = rtb_TmpSignalConversionAtVeHT_k;
    }
    else
    {
        /* Switch: '<S1435>/Switch' */
        rtb_TmpSignalConversionAtVeT_j5 = 0.0F;
    }

    /* End of Switch: '<S1435>/Switch' */
    /* End of Outputs for SubSystem: '<S1434>/integral_term' */

    /* Sum: '<S1434>/Sum//Sub1' incorporates:
     *  Constant: '<S1410>/Constant1'
     *  Constant: '<S1429>/Calib'
     *  Constant: '<S1431>/Calib'
     *  Product: '<S1434>/Multiplication2'
     *  Product: '<S1434>/derivative_term'
     *  Product: '<S1434>/proportional_term'
     *  Sum: '<S1434>/Sum//Sub2'
     *  UnitDelay: '<S1434>/UnitDelay1'
     */
    rtb_Switch1_pi = (((rtb_TmpSignalConversionAtVeHT_h -
                        THMR_ac_DW.UnitDelay1_DSTATE_iq) *
                       KeTHMR_K_HTCLTempMitgatn_Kd) / 0.1F) +
        ((rtb_TmpSignalConversionAtVeHT_h * KeTHMR_K_HTCLTempMitgatn_Kp) +
         rtb_TmpSignalConversionAtVeT_j5);

    /* Update for UnitDelay: '<S1434>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_iq = rtb_TmpSignalConversionAtVeHT_h;

    /* Update for UnitDelay: '<S1434>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_o0 = rtb_TmpSignalConversionAtVeT_j5;

    /* Outputs for Atomic SubSystem: '<S1410>/Limiter1' */
    /* Switch: '<S1433>/Switch1' incorporates:
     *  Constant: '<S1432>/Calib'
     *  RelationalOperator: '<S1433>/RelationalOperator'
     *  Switch: '<S1434>/Switch1'
     */
    if (KeTHMR_P_HTCLTempMitgatn_MaxPwr < rtb_Switch1_pi)
    {
        /* Switch: '<S1153>/Switch3' */
        rtb_TmpSignalConversionAtVeHT_k = KeTHMR_P_HTCLTempMitgatn_MaxPwr;
    }
    else
    {
        /* Switch: '<S1153>/Switch3' */
        rtb_TmpSignalConversionAtVeHT_k = rtb_Switch1_pi;
    }

    /* End of Switch: '<S1433>/Switch1' */
    /* End of Outputs for SubSystem: '<S1410>/PIDControl' */

    /* Switch: '<S1433>/Switch' incorporates:
     *  Constant: '<S1410>/Constant3'
     *  RelationalOperator: '<S1433>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeHT_k > 0.0F)
    {
        /* Switch: '<S1433>/Switch' */
        VeTHMR_P_HTCLTempMitgatn_HtrDRtPwr = rtb_TmpSignalConversionAtVeHT_k;
    }
    else
    {
        /* Switch: '<S1433>/Switch' */
        VeTHMR_P_HTCLTempMitgatn_HtrDRtPwr = 0.0F;
    }

    /* End of Switch: '<S1433>/Switch' */
    /* End of Outputs for SubSystem: '<S1410>/Limiter1' */

    /* Switch: '<S1153>/Switch1' incorporates:
     *  Constant: '<S1418>/Calib'
     */
    if (KeTHMR_b_CabHeat_OldApp)
    {
        rtb_Switch10 = VeTHMR_P_ECH_HtrPwrTgt_Lim_APerWp;
    }
    else
    {
        rtb_Switch10 = VeTHMR_P_CabHtr_PwrRqst_HeatState;
    }

    /* End of Switch: '<S1153>/Switch1' */

    /* Sum: '<S1153>/Add' */
    rtb_TmpSignalConversionAtVeHT_h = rtb_Switch10 -
        VeTHMR_P_HTCLTempMitgatn_HtrDRtPwr;

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeCTRR_P_RearHeaterPwrReq' */
    (void)Rte_Read_VeCTRR_P_RearHeaterPwrReq_Value(&Switch);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* Switch: '<S1153>/Switch3' incorporates:
     *  Constant: '<S1420>/Calib'
     *  MinMax: '<S1153>/MinMax'
     */
    if (KeTHMR_b_EnblNewPwrDsrbtn)
    {
        rtb_Switch10 = fminf(rtb_TmpSignalConversionAtVeTPDR,
                             VeTHMR_P_AdjstdHtrWishd_Pwr);
    }
    else
    {
        rtb_Switch10 = VeTHMR_P_AdjstdHtrWishd_Pwr;
    }

    /* End of Switch: '<S1153>/Switch3' */

    /* MinMax: '<S1153>/MinMax1' incorporates:
     *  Lookup_n-D: '<S1423>/Vector'
     *  SignalConversion generated from: '<S2>/VePMPR_dV_HtrFlw'
     */
    rtb_TmpSignalConversionAtVeTPDR = fminf(look1_iflf_binlcapw
        (rtb_TmpSignalConversionAtVePM_n, ((const float32 *)
        &(KxTHMR_P_MaxCabHtrPwrVsClntFlow[0])), ((const float32 *)
        &(KtTHMR_P_MaxCabHtrPwrVsClntFlow[0])), 7U), rtb_Switch10);

    /* Outputs for Atomic SubSystem: '<S1153>/Limiter' */
    /* Switch: '<S1424>/Switch1' incorporates:
     *  RelationalOperator: '<S1424>/RelationalOperator'
     */
    if (rtb_TmpSignalConversionAtVeTPDR < rtb_TmpSignalConversionAtVeHT_h)
    {
        /* Switch: '<S1425>/Switch1' */
        rtb_Switch1_giu = rtb_TmpSignalConversionAtVeTPDR;
    }
    else
    {
        /* Switch: '<S1425>/Switch1' */
        rtb_Switch1_giu = rtb_TmpSignalConversionAtVeHT_h;
    }

    /* End of Switch: '<S1424>/Switch1' */

    /* Switch: '<S1424>/Switch' incorporates:
     *  Constant: '<S1413>/Calib'
     *  RelationalOperator: '<S1424>/RelationalOperator1'
     */
    if (rtb_Switch1_giu > KeTHMR_P_HeatPwrTgt_Min)
    {
        /* Switch: '<S1424>/Switch' */
        VeTHMR_P_ECH_HtrPwrTgt_B4D = rtb_Switch1_giu;
    }
    else
    {
        /* Switch: '<S1424>/Switch' */
        VeTHMR_P_ECH_HtrPwrTgt_B4D = KeTHMR_P_HeatPwrTgt_Min;
    }

    /* End of Switch: '<S1424>/Switch' */
    /* End of Outputs for SubSystem: '<S1153>/Limiter' */

    /* Switch: '<S1947>/Switch1' incorporates:
     *  Constant: '<S1940>/Constant'
     *  Constant: '<S1941>/Constant'
     *  Logic: '<S1162>/Logical5'
     *  Logic: '<S1162>/LogicalOperator2'
     *  RelationalOperator: '<S1162>/Comparison2'
     *  RelationalOperator: '<S1162>/Comparison5'
     */
    if ((((CeTHMR_e_CabinActiveHeating == ((uint32)rtb_Switch1_o0g)) ||
            (((uint32)rtb_Switch1_o0g) == CeTHMR_e_CabinActivePassiveHeating)) &&
         Switch5_i) && rtb_TmpSignalConversionAtVeCT_m)
    {
        /* Switch: '<S1947>/Switch1' */
        VeTHMR_P_Rear_HeatPwr = Switch;
    }
    else
    {
        /* Switch: '<S1947>/Switch1' incorporates:
         *  Constant: '<S1162>/ConstantValue4'
         */
        VeTHMR_P_Rear_HeatPwr = 0.0F;
    }

    /* End of Switch: '<S1947>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S1153>/Limiter1' */
    /* Switch: '<S1425>/Switch1' incorporates:
     *  RelationalOperator: '<S1425>/RelationalOperator'
     */
    if (rtb_TmpSignalConversionAtVeT_ms < VeTHMR_P_Rear_HeatPwr)
    {
        /* Switch: '<S1425>/Switch1' */
        rtb_Switch1_giu = rtb_TmpSignalConversionAtVeT_ms;
    }
    else
    {
        /* Switch: '<S1425>/Switch1' */
        rtb_Switch1_giu = VeTHMR_P_Rear_HeatPwr;
    }

    /* End of Switch: '<S1425>/Switch1' */

    /* Switch: '<S1425>/Switch' incorporates:
     *  Constant: '<S1153>/ConstantValue3'
     *  RelationalOperator: '<S1425>/RelationalOperator1'
     */
    if (rtb_Switch1_giu > 0.0F)
    {
        /* Switch: '<S1425>/Switch' */
        Switch = rtb_Switch1_giu;
    }
    else
    {
        /* Switch: '<S1425>/Switch' */
        Switch = 0.0F;
    }

    /* End of Switch: '<S1425>/Switch' */
    /* End of Outputs for SubSystem: '<S1153>/Limiter1' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LT_Batt_Loop'
     */
    /* RelationalOperator: '<S1158>/Comparison7' incorporates:
     *  Constant: '<S1407>/Constant'
     *  Constant: '<S1408>/Constant'
     *  Logic: '<S1153>/Logical1'
     *  Logic: '<S1153>/Logical3'
     *  Logic: '<S1153>/Logical4'
     *  RelationalOperator: '<S1153>/Comparison3'
     *  RelationalOperator: '<S1153>/Comparison5'
     *  RelationalOperator: '<S3160>/Comparison10'
     *  Switch: '<S3956>/Switch'
     */
    rtb_TmpSignalConversionAtVeT_f5 = (((((uint32)VeTHMR_e_BatCntctrStat) ==
        CeHVTR_e_Closed) && rtb_TmpSignalConversionAtOutAir) || ((((uint32)
        VeTHMR_e_BatCntctrStat) == CeHVTR_e_Open) &&
        (VeTHMR_b_AlternatorMode_Actv)));

    /* Switch: '<S1411>/Switch1' incorporates:
     *  Constant: '<S1414>/Calib'
     *  Logic: '<S1153>/Logical2'
     *  RelationalOperator: '<S1153>/Comparison1'
     */
    VeTHMR_b_HVC_HtrReqstd_StaFlow_Raw = (rtb_TmpSignalConversionAtVeT_f5 &&
        (VeTHMR_P_ECH_HtrPwrTgt_B4D > KeTHMR_P_HeatPwrTgt_MinOn));

    /* Logic: '<S1153>/Logical5' incorporates:
     *  Constant: '<S1415>/Calib'
     *  Logic: '<S1153>/Logical6'
     *  Logic: '<S1153>/Logical7'
     *  RelationalOperator: '<S1153>/Comparison2'
     */
    rtb_VariantMerge_For_Variant_p3 = (((rtb_TmpSignalConversionAtVeT_f5 &&
        (Switch > KeTHMR_P_RearHeatPwrTgt_MinOn)) && (!THMR_ac_B.OR1)) &&
        (!VeTHMR_b_ThrmlNotAllow_BattWallPwr_Limitd));

    /* RelationalOperator: '<S1158>/Comparison7' incorporates:
     *  Constant: '<S1824>/Constant'
     *  Switch: '<S4586>/Switch1'
     */
    rtb_TmpSignalConversionAtVeT_f5 = (CeTHMR_e_ActvPsvHeating == ((uint32)
        VeTHMR_e_BatThrmlSt_B4D));

    /* RelationalOperator: '<S1158>/Comparison6' incorporates:
     *  Constant: '<S1823>/Constant'
     *  Switch: '<S4586>/Switch1'
     */
    rtb_TmpSignalConversionAtVeT_pw = (((uint32)VeTHMR_e_BatThrmlSt_B4D) ==
        CeTHMR_e_Heating);

    /* Logic: '<S1158>/Logical23' incorporates:
     *  Logic: '<S1158>/Logical19'
     */
    rtb_TmpSignalConversionAtVeBT_f = !rtb_TmpSignalConversionAtVeT_pw;
    rtb_LogicalOperator1_fo = !rtb_TmpSignalConversionAtVeT_f5;

    /* Logic: '<S1158>/Logical23' */
    rtb_RelationalOperator_nw = (rtb_LogicalOperator1_fo &&
        rtb_TmpSignalConversionAtVeBT_f);

    /* RelationalOperator: '<S1158>/Comparison2' incorporates:
     *  Constant: '<S1822>/Constant'
     */
    rtb_NotEqual_fo = (((uint32)tmp_d) == CeTHMR_e_LTCLActvPsvHeating);

    /* SignalConversion generated from: '<S1158>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

    /* Logic: '<S1158>/Logical27' incorporates:
     *  Constant: '<S1158>/ConstantValue11'
     */
    rtb_Logical27 = true;

#else

    /* Logic: '<S1158>/Logical27' incorporates:
     *  Constant: '<S1158>/ConstantValue1'
     *  SignalConversion generated from: '<S1158>/VariantSource'
     */
    rtb_Logical27 = false;

#endif

    /* End of SignalConversion generated from: '<S1158>/VariantSource' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Logic: '<S1158>/Logical26' incorporates:
     *  Logic: '<S4087>/Logical2'
     *  Logic: '<S4117>/Logical7'
     *  Logic: '<S4117>/Logical9'
     *  Logic: '<S4254>/Logical4'
     *  Logic: '<S4254>/Logical6'
     *  Logic: '<S4259>/Logical11'
     *  Logic: '<S4263>/Logical8'
     *  Logic: '<S4264>/Logical8'
     *  Logic: '<S4335>/Logical7'
     *  Logic: '<S4337>/Logical5'
     *  Logic: '<S5073>/Logical14'
     *  Switch: '<S4259>/Switch1'
     *  Switch: '<S4284>/Switch1'
     *  Switch: '<S4285>/Switch1'
     *  Switch: '<S4286>/Switch1'
     *  Switch: '<S4287>/Switch1'
     *  Switch: '<S4289>/Switch1'
     *  Switch: '<S4290>/Switch1'
     *  Switch: '<S4549>/Switch1'
     *  Switch: '<S4550>/Switch1'
     *  Switch: '<S5286>/Switch1'
     *  Switch: '<S5287>/Switch1'
     */
    rtb_TmpSignalConversionAtVeCT_c = !VeTHMR_b_Defrost;

    /* Logic: '<S1158>/Logical12' incorporates:
     *  Logic: '<S1158>/Logical13'
     *  Logic: '<S1158>/Logical2'
     */
    rtb_TmpSignalConversionAtVePD_i = ((!rtb_TmpSignalConversionAtVeCT_o) ||
        (THMR_ac_B.VeTHMR_b_CabReq_NotAllow_BS));

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Logic: '<S1158>/Logical30' incorporates:
     *  Logic: '<S1158>/Logical31'
     *  Logic: '<S4679>/Logical1'
     *  Switch: '<S4679>/Switch'
     */
    rtb_TmpSignalConversionAtVePD_p = !THMR_ac_B.VeTHMR_b_FCHeatAllwd;

    /* If: '<S1158>/If' incorporates:
     *  Constant: '<S1167>/Calib'
     *  Constant: '<S1816>/Constant'
     *  Constant: '<S1817>/Constant'
     *  Constant: '<S1818>/Constant'
     *  Constant: '<S1819>/Constant'
     *  Constant: '<S1821>/Constant'
     *  Constant: '<S1825>/Constant'
     *  Constant: '<S1826>/Constant'
     *  Constant: '<S1831>/Calib'
     *  Constant: '<S1832>/Calib'
     *  Logic: '<S1158>/Logical1'
     *  Logic: '<S1158>/Logical10'
     *  Logic: '<S1158>/Logical16'
     *  Logic: '<S1158>/Logical18'
     *  Logic: '<S1158>/Logical19'
     *  Logic: '<S1158>/Logical20'
     *  Logic: '<S1158>/Logical21'
     *  Logic: '<S1158>/Logical22'
     *  Logic: '<S1158>/Logical24'
     *  Logic: '<S1158>/Logical25'
     *  Logic: '<S1158>/Logical3'
     *  Logic: '<S1158>/Logical30'
     *  Logic: '<S1158>/Logical32'
     *  Logic: '<S1158>/Logical33'
     *  Logic: '<S1158>/Logical34'
     *  Logic: '<S1158>/Logical35'
     *  Logic: '<S1158>/Logical36'
     *  Logic: '<S1158>/Logical37'
     *  Logic: '<S1158>/Logical38'
     *  Logic: '<S1158>/Logical5'
     *  Logic: '<S1158>/Logical7'
     *  Logic: '<S1158>/Logical8'
     *  Logic: '<S1158>/Logical9'
     *  RelationalOperator: '<S1158>/Comparison1'
     *  RelationalOperator: '<S1158>/Comparison14'
     *  RelationalOperator: '<S1158>/Comparison17'
     *  RelationalOperator: '<S1158>/Comparison23'
     *  RelationalOperator: '<S1158>/Comparison24'
     *  RelationalOperator: '<S1158>/Comparison4'
     *  RelationalOperator: '<S1158>/Comparison5'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     *  Switch: '<S4586>/Switch1'
     */
    if (((((rtb_TmpSignalConversionAtVePD_i && (((uint32)
              rtb_TmpSignalConversionAtVePD_l) != CePDTR_e_Dischrg_AmbTempLow)) &&
           (((uint32)rtb_TmpSignalConversionAtVePD_l) !=
            CePDTR_e_Dischrg_CabReqInOV)) && rtb_RelationalOperator_nw) &&
            rtb_TmpSignalConversionAtVePD_p) || (KeTHMR_b_HTCL_HeatDistr_NoFault))
    {
        /* Outputs for IfAction SubSystem: '<S1158>/No_heat_in_HCTL' incorporates:
         *  ActionPort: '<S1833>/ActionPort'
         */
        /* Merge: '<S1158>/Merge' incorporates:
         *  Constant: '<S1841>/Constant'
         *  SignalConversion generated from: '<S1833>/Out1'
         */
        VeTHMR_e_HTCL_Heat_Distrib_B4D_Old = CeTHMR_e_NoHeating;

        /* End of Outputs for SubSystem: '<S1158>/No_heat_in_HCTL' */
    }
    else
    {
        /* Logic: '<S1158>/Logical25' incorporates:
         *  Logic: '<S1158>/Logical4'
         */
        rtb_AND_de = ((rtb_TmpSignalConversionAtVeT_f5 ||
                       rtb_TmpSignalConversionAtVeT_pw) || rtb_NotEqual_fo);
        if ((((uint32)rtb_TmpSignalConversionAtVeB_kc) == CeBTRR_e_BatCrit) ||
                (((rtb_AND_de && rtb_TmpSignalConversionAtVePD_i) &&
                  rtb_TmpSignalConversionAtVePD_p) &&
                 ((rtb_TmpSignalConversionAtVeT_pw ||
                   rtb_TmpSignalConversionAtVeT_f5) || ((((uint32)
                 VeTHMR_e_BatThrmlSt_B4D) == CeTHMR_e_PassiveHeating) &&
                (!rtb_Logical27)))))
        {
            /* Outputs for IfAction SubSystem: '<S1158>/Batt_Only' incorporates:
             *  ActionPort: '<S1814>/ActionPort'
             */
            /* Merge: '<S1158>/Merge' incorporates:
             *  Constant: '<S1838>/Constant'
             *  SignalConversion generated from: '<S1814>/Out1'
             */
            VeTHMR_e_HTCL_Heat_Distrib_B4D_Old = CeTHMR_e_BatteryHeating;

            /* End of Outputs for SubSystem: '<S1158>/Batt_Only' */
        }
        else
        {
            /* Logic: '<S1158>/Logical24' incorporates:
             *  Constant: '<S1820>/Constant'
             *  Constant: '<S1830>/Calib'
             *  Logic: '<S1158>/Logical20'
             *  Logic: '<S1158>/Logical26'
             *  Logic: '<S1158>/Logical27'
             *  Logic: '<S1158>/Logical28'
             *  Logic: '<S1158>/Logical29'
             *  RelationalOperator: '<S1158>/Comparison3'
             */
            rtb_TmpSignalConversionAtVePD_i = (((((uint32)
                rtb_TmpSignalConversionAtVeTR_f) != CeTRIR_e_MAX_AC) ||
                rtb_TmpSignalConversionAtVeTR_k) || ((KeTHMR_b_MaxAC_DefrostEnbl)
                && (!rtb_TmpSignalConversionAtVeCT_c)));
            if ((rtb_TmpSignalConversionAtVeCT_d ||
                    ((rtb_TmpSignalConversionAtVeBT_f && rtb_LogicalOperator1_fo)
                     && (!rtb_NotEqual_fo))) && ((THMR_ac_B.VeTHMR_b_FCHeatAllwd)
                 || ((rtb_TmpSignalConversionAtVeT_ib &&
                      ((rtb_TmpSignalConversionAtVeCT_o ||
                        (CePDTR_e_Dischrg_AmbTempLow == ((uint32)
                       rtb_TmpSignalConversionAtVePD_l))) || (((uint32)
                      rtb_TmpSignalConversionAtVePD_l) ==
                     CePDTR_e_Dischrg_CabReqInOV))) &&
                     (rtb_TmpSignalConversionAtVePD_i ||
                      (!KeTHMR_b_MaxAC_Dsbl_CabOnly)))))
            {
                /* Outputs for IfAction SubSystem: '<S1158>/Cab_Only' incorporates:
                 *  ActionPort: '<S1815>/ActionPort'
                 */
                /* Merge: '<S1158>/Merge' incorporates:
                 *  Constant: '<S1839>/Constant'
                 *  SignalConversion generated from: '<S1815>/Out1'
                 */
                VeTHMR_e_HTCL_Heat_Distrib_B4D_Old = CeTHMR_e_CabinHeating;

                /* End of Outputs for SubSystem: '<S1158>/Cab_Only' */
            }
            else if (((((((!KeTHMR_b_MaxAC_Dsbl_BattAndCab) ||
                          rtb_TmpSignalConversionAtVePD_i) &&
                         rtb_TmpSignalConversionAtVeCT_o) &&
                        rtb_TmpSignalConversionAtVeT_ib) ||
                       (THMR_ac_B.VeTHMR_b_FCHeatAllwd)) && (((uint32)
                        rtb_TmpSignalConversionAtVeB_kc) != CeBTRR_e_BatCrit)) &&
                     rtb_AND_de)
            {
                /* Outputs for IfAction SubSystem: '<S1158>/BattAndCabin' incorporates:
                 *  ActionPort: '<S1813>/ActionPort'
                 */
                /* Merge: '<S1158>/Merge' incorporates:
                 *  Constant: '<S1837>/Constant'
                 *  SignalConversion generated from: '<S1813>/Out1'
                 */
                VeTHMR_e_HTCL_Heat_Distrib_B4D_Old =
                    CeTHMR_e_BatteryNCabinHeating;

                /* End of Outputs for SubSystem: '<S1158>/BattAndCabin' */
            }
            else
            {
                /* Outputs for IfAction SubSystem: '<S1158>/Fault' incorporates:
                 *  ActionPort: '<S1827>/ActionPort'
                 */
                /* Merge: '<S1158>/Merge' incorporates:
                 *  Constant: '<S1840>/Constant'
                 *  SignalConversion generated from: '<S1827>/Out1'
                 */
                VeTHMR_e_HTCL_Heat_Distrib_B4D_Old = CeTHMR_e_Faulted;

                /* End of Outputs for SubSystem: '<S1158>/Fault' */
            }
        }
    }

    /* End of If: '<S1158>/If' */

    /* Logic: '<S1158>/Logical14' */
    rtb_TmpSignalConversionAtVeTR_k = !rtb_RelationalOperator_nw;

    /* Truth Table: '<S1158>/TruthTable1' incorporates:
     *  Constant: '<S1167>/Calib'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     */
    /* Truth Table Function 'THMR_FUNC_RU_MedTEH/HTCL/HTCL_Heat_Distribution/TruthTable1': '<S1836>:1' */
    /*  Battery in critical condition */
    /* Condition '#1': '<S1836>:1:14' */
    /*  Battery over voltage */
    /* Condition '#2': '<S1836>:1:18' */
    rtb_NotEqual_fo = (((uint32)rtb_TmpSignalConversionAtVePD_l) ==
                       CePDTR_e_Dischrg_AmbTempLow);

    /*  Battery Heat request */
    /*  HVAC heat request */
    /*  Cabin Heating High Priority */
    /*  Cabin Heating Not Allowed */
    /*  Fault preventing Heat in HTCL */
    rtb_TmpSignalConversionAtVePD_i = !rtb_TmpSignalConversionAtVeCT_d;
    rtb_AND_de = !KeTHMR_b_HTCL_HeatDistr_NoFault;
    rtb_LogicalOperator_aa = !rtb_TmpSignalConversionAtVeTR_k;
    if (((((rtb_NotEqual_fo && rtb_LogicalOperator_aa) &&
            (!rtb_TmpSignalConversionAtVeCT_o)) &&
            rtb_TmpSignalConversionAtVePD_i) && rtb_TmpSignalConversionAtVeT_ib)
        && rtb_AND_de)
    {
        /* Gain: '<S1834>/Gain' */
        /* Decision 'D2': '<S1836>:1:42' */
        /*  Action based on Decision 2 */
        /* Action '2': '<S1836>:1:68' */
        VeTHMR_K_Index_T3_AS = THMR_ac_Two;
    }
    else
    {
        rtb_UnitDelay3_ff = !rtb_NotEqual_fo;
        if (((((rtb_UnitDelay3_ff && rtb_TmpSignalConversionAtVeTR_k) &&
                (!rtb_TmpSignalConversionAtVeCT_o)) &&
                rtb_TmpSignalConversionAtVePD_i) &&
                rtb_TmpSignalConversionAtVeT_ib) && rtb_AND_de)
        {
            /* Gain: '<S1834>/Gain' */
            /* Decision 'D3': '<S1836>:1:44' */
            /* Condition '#3': '<S1836>:1:22' */
            /*  Action based on Decision 3 */
            /* Action '3': '<S1836>:1:74' */
            VeTHMR_K_Index_T3_AS = THMR_ac_Three;
        }
        else
        {
            rtb_LogicalOperator_aa = (rtb_UnitDelay3_ff &&
                rtb_LogicalOperator_aa);
            if ((((rtb_LogicalOperator_aa && rtb_TmpSignalConversionAtVeCT_o) &&
                  rtb_TmpSignalConversionAtVePD_i) &&
                    rtb_TmpSignalConversionAtVeT_ib) && rtb_AND_de)
            {
                /* Gain: '<S1834>/Gain' */
                /* Decision 'D4': '<S1836>:1:46' */
                /* Condition '#4': '<S1836>:1:26' */
                /*  Action based on Decision 4 */
                /* Action '4': '<S1836>:1:80' */
                VeTHMR_K_Index_T3_AS = THMR_ac_Four;
            }
            else
            {
                rtb_LogicalOperator_aa = (rtb_LogicalOperator_aa &&
                    (!rtb_TmpSignalConversionAtVeCT_o));
                if (((rtb_LogicalOperator_aa && rtb_TmpSignalConversionAtVeCT_d)
                     && rtb_TmpSignalConversionAtVeT_ib) && rtb_AND_de)
                {
                    /* Gain: '<S1834>/Gain' */
                    /* Decision 'D5': '<S1836>:1:48' */
                    /* Condition '#5': '<S1836>:1:30' */
                    /*  Action based on Decision 5 */
                    /* Action '5': '<S1836>:1:86' */
                    VeTHMR_K_Index_T3_AS = THMR_ac_Five;
                }
                else
                {
                    rtb_TmpSignalConversionAtVePD_i = (rtb_LogicalOperator_aa &&
                        rtb_TmpSignalConversionAtVePD_i);
                    if ((rtb_TmpSignalConversionAtVePD_i &&
                            (THMR_ac_B.VeTHMR_b_CabReq_NotAllow_BS)) &&
                            rtb_AND_de)
                    {
                        /* Gain: '<S1834>/Gain' */
                        /* Decision 'D6': '<S1836>:1:50' */
                        /* Condition '#6': '<S1836>:1:34' */
                        /*  Action based on Decision 6 */
                        /* Action '6': '<S1836>:1:92' */
                        VeTHMR_K_Index_T3_AS = THMR_ac_Six;
                    }
                    else if ((rtb_TmpSignalConversionAtVePD_i &&
                              rtb_TmpSignalConversionAtVeT_ib) &&
                             (KeTHMR_b_HTCL_HeatDistr_NoFault))
                    {
                        /* Gain: '<S1834>/Gain' */
                        /* Decision 'D7': '<S1836>:1:52' */
                        /* Condition '#7': '<S1836>:1:38' */
                        /*  Action based on Decision 7 */
                        /* Action '7': '<S1836>:1:98' */
                        VeTHMR_K_Index_T3_AS = THMR_ac_Seven;
                    }
                    else
                    {
                        /* Gain: '<S1834>/Gain' */
                        /*  Default */
                        /*  Action based on Decision 8 */
                        /* Action '8': '<S1836>:1:104' */
                        VeTHMR_K_Index_T3_AS = THMR_ac_Eight;
                    }
                }
            }
        }
    }

    /* Selector: '<S1158>/Selector1' incorporates:
     *  Constant: '<S1828>/Calib'
     */
    VeTHMR_e_HTCL_Heat_Distrib_B4D_New = KaTHMR_e_HTCL_Heat_Distrib[((sint32)
        VeTHMR_K_Index_T3_AS) - 1];

    /* Switch: '<S1158>/Switch' incorporates:
     *  Constant: '<S1829>/Calib'
     */
    if (KeTHMR_b_HTCL_Heat_Distrib_SelectDial)
    {
        /* Switch: '<S1158>/Switch' incorporates:
         *  Merge: '<S1158>/Merge'
         */
        VeTHMR_e_HTCL_Heat_Distrib_B4D = VeTHMR_e_HTCL_Heat_Distrib_B4D_Old;
    }
    else
    {
        /* Switch: '<S1158>/Switch' incorporates:
         *  Selector: '<S1158>/Selector1'
         */
        VeTHMR_e_HTCL_Heat_Distrib_B4D = VeTHMR_e_HTCL_Heat_Distrib_B4D_New;
    }

    /* End of Switch: '<S1158>/Switch' */

    /* Logic: '<S1846>/Logical4' incorporates:
     *  Constant: '<S1859>/Calib'
     *  Constant: '<S1861>/Calib'
     *  Constant: '<S1862>/Calib'
     *  Logic: '<S1846>/Logical2'
     *  RelationalOperator: '<S1846>/Comparison1'
     *  RelationalOperator: '<S1846>/Comparison2'
     */
    rtb_TmpSignalConversionAtVeCT_d = (((rtb_TmpSignalConversionAtVeBT_k >
        KeTHMR_T_HV_BatClntTmp_Th) && (rtb_TmpSignalConversionAtVeBTRR >
        KeTHMR_T_CellTempMax_Th)) && (KeTHMR_b_Enbl_BattTmpChk));

    /* Logic: '<S1160>/Logical7' incorporates:
     *  Constant: '<S1847>/Constant1'
     *  Constant: '<S1847>/Constant2'
     *  Constant: '<S1848>/Constant1'
     *  Constant: '<S1848>/Constant2'
     *  Constant: '<S1849>/Constant1'
     *  Constant: '<S1849>/Constant2'
     *  Constant: '<S1850>/Constant1'
     *  Constant: '<S1850>/Constant2'
     *  Constant: '<S1851>/Constant1'
     *  Constant: '<S1851>/Constant2'
     *  Constant: '<S1853>/Calib'
     *  Constant: '<S1854>/Calib'
     *  Constant: '<S1855>/Calib'
     *  Constant: '<S1856>/Calib'
     *  Constant: '<S1857>/Calib'
     *  Constant: '<S1858>/Calib'
     *  Constant: '<S1860>/Calib'
     *  Constant: '<S1863>/Calib'
     *  DataStoreRead: '<S1847>/StatusByte_CoolantVlvA_CktHi'
     *  DataStoreRead: '<S1848>/StatusByte_CoolantVlvA_CktLo'
     *  DataStoreRead: '<S1849>/StatusByte_CoolantVlvA_Ckt'
     *  DataStoreRead: '<S1850>/StatusByte_CoolantVlvA_Perf'
     *  DataStoreRead: '<S1851>/StatusByte_CoolantVlvA_StkOpn'
     *  Logic: '<S1160>/Logical'
     *  Logic: '<S1160>/Logical1'
     *  Logic: '<S1160>/Logical2'
     *  Logic: '<S1160>/Logical3'
     *  Logic: '<S1160>/Logical4'
     *  Logic: '<S1160>/Logical5'
     *  Logic: '<S1160>/Logical6'
     *  Logic: '<S1846>/Logical1'
     *  Logic: '<S1846>/Logical3'
     *  Logic: '<S1847>/Logical Operator'
     *  Logic: '<S1848>/Logical Operator'
     *  Logic: '<S1849>/Logical Operator'
     *  Logic: '<S1850>/Logical Operator'
     *  Logic: '<S1851>/Logical Operator'
     *  RelationalOperator: '<S1846>/Comparison'
     *  RelationalOperator: '<S1847>/Relational Operator1'
     *  RelationalOperator: '<S1847>/Relational Operator2'
     *  RelationalOperator: '<S1848>/Relational Operator1'
     *  RelationalOperator: '<S1848>/Relational Operator2'
     *  RelationalOperator: '<S1849>/Relational Operator1'
     *  RelationalOperator: '<S1849>/Relational Operator2'
     *  RelationalOperator: '<S1850>/Relational Operator1'
     *  RelationalOperator: '<S1850>/Relational Operator2'
     *  RelationalOperator: '<S1851>/Relational Operator1'
     *  RelationalOperator: '<S1851>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S1847>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1847>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1848>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1848>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1849>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1849>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1850>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1850>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1851>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1851>/Bitwise Operator2'
     */
    THMR_ac_B.Logical7_l = ((((((((VeTHMR_b_HT_CabVlvSts_FA_AD) &&
        (KeTHMR_b_EnblHT_CabVlvSts_FA)) || ((((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_Perf) & 1U) != 0U) && ((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_Perf) & 64U) == 0U)) &&
        (KeTHMR_b_EnblHTCV_Stck_Flt))) || ((((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_StkOpn) & 1U) != 0U) && ((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_StkOpn) & 64U) == 0U)) &&
        (KeTHMR_b_EnblHTCV_Leak_Flt))) || ((((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_Ckt) & 1U) != 0U) && ((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_Ckt) & 64U) == 0U)) &&
        (KeTHMR_b_EnblHTCV_CktOpenFlt))) || ((((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_CktLo) & 1U) != 0U) && ((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_CktLo) & 64U) == 0U)) &&
        (KeTHMR_b_EnblHTCV_CktLoFlt))) || ((((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_CktHi) & 1U) != 0U) && ((((uint32)
        THMR_ac_DW.StatusByte_CoolantVlvA_CktHi) & 64U) == 0U)) &&
        (KeTHMR_b_EnblHTCV_CktHiFlt))) && (((rtb_TmpSignalConversionAtVeT_n0 >
        KeTHMR_T_ElecClntHtr_Th) && (KeTHMR_b_Enbl_ElecClntHtr_ThChk)) ||
        rtb_TmpSignalConversionAtVeCT_d));

    /* Outputs for Enabled SubSystem: '<S1160>/HTCV_Flt_RA_Cntrls' incorporates:
     *  EnablePort: '<S1852>/Enable'
     */
    /* Switch: '<S1159>/Switch' */
    if (THMR_ac_B.Logical7_l)
    {
        /* RelationalOperator: '<S1864>/Comparison3' incorporates:
         *  Constant: '<S1869>/Constant'
         *  Switch: '<S4586>/Switch1'
         */
        rtb_TmpSignalConversionAtVeTR_k = (((uint32)VeTHMR_e_BatThrmlSt_B4D) ==
            CeTHMR_e_ActiveCooling);

        /* Outputs for Atomic SubSystem: '<S1864>/EdgeRising1' */
        /* Logic: '<S1868>/AND' incorporates:
         *  Logic: '<S1868>/OR1'
         *  UnitDelay: '<S1868>/UnitDelay'
         */
        rtb_Logical27 = (rtb_TmpSignalConversionAtVeTR_k &&
                         (!THMR_ac_DW.UnitDelay_DSTATE_jp));

        /* Update for UnitDelay: '<S1868>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_jp = rtb_TmpSignalConversionAtVeTR_k;

        /* End of Outputs for SubSystem: '<S1864>/EdgeRising1' */

        /* Outputs for Atomic SubSystem: '<S1864>/TimerRetriggerResetEnabled' */
        /* Switch: '<S1873>/Switch1' incorporates:
         *  Logic: '<S1864>/Logical5'
         *  Logic: '<S1864>/Logical7'
         */
        if (rtb_Logical27 || (!rtb_TmpSignalConversionAtVeTR_k))
        {
            /* Switch: '<S1873>/Switch1' incorporates:
             *  Constant: '<S1864>/ConstantValue1'
             *  Constant: '<S1872>/Calib'
             *  Sum: '<S1864>/Sum1'
             */
            rtb_Switch1_d = KeTHMR_t_BattCool_TmOut - 0.1F;
        }
        else
        {
            /* Switch: '<S1873>/Switch1' incorporates:
             *  Constant: '<S1864>/ConstantValue4'
             *  Constant: '<S1873>/ConstantValue4'
             *  MinMax: '<S1873>/Maximum'
             *  Sum: '<S1873>/Subtraction'
             *  Switch: '<S1873>/Switch2'
             *  UnitDelay: '<S1873>/UnitDelay'
             */
            rtb_Switch1_d = fmaxf(THMR_ac_DW.UnitDelay_DSTATE_g2b - 0.1F, 0.0F);
        }

        /* End of Switch: '<S1873>/Switch1' */

        /* Update for UnitDelay: '<S1873>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_g2b = rtb_Switch1_d;

        /* Outputs for Atomic SubSystem: '<S1867>/SignalLatchOnWithReset' */
        /* Logic: '<S1864>/Logical4' incorporates:
         *  Constant: '<S1873>/ConstantValue2'
         *  Logic: '<S1864>/Logical6'
         *  Logic: '<S1874>/NOT'
         *  RelationalOperator: '<S1873>/GreaterThan1'
         */
        rtb_Logical27 = (rtb_Switch1_d > 0.0F);

        /* End of Outputs for SubSystem: '<S1864>/TimerRetriggerResetEnabled' */

        /* Logic: '<S1874>/OR1' incorporates:
         *  Logic: '<S1864>/Logical1'
         *  Logic: '<S1864>/Logical4'
         *  Logic: '<S1874>/OR'
         *  UnitDelay: '<S1874>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeTR_k = ((rtb_TmpSignalConversionAtVeTR_k &&
            rtb_Logical27) || (rtb_Logical27 && (THMR_ac_DW.UnitDelay_DSTATE_idq)));

        /* Update for UnitDelay: '<S1874>/UnitDelay' */
        THMR_ac_DW.UnitDelay_DSTATE_idq = rtb_TmpSignalConversionAtVeTR_k;

        /* End of Outputs for SubSystem: '<S1867>/SignalLatchOnWithReset' */

        /* Switch: '<S1867>/Switch1' */
        if (rtb_TmpSignalConversionAtVeTR_k)
        {
            /* Switch: '<S1867>/Switch1' incorporates:
             *  UnitDelay: '<S1867>/UnitDelay1'
             */
            rtb_Switch1_d = THMR_ac_DW.UnitDelay1_DSTATE_n;
        }
        else
        {
            /* Switch: '<S1867>/Switch1' */
            rtb_Switch1_d = rtb_TmpSignalConversionAtVeB_cl;
        }

        /* End of Switch: '<S1867>/Switch1' */

        /* Logic: '<S1864>/Logical2' incorporates:
         *  Abs: '<S1864>/Abs'
         *  Constant: '<S1870>/Constant'
         *  Constant: '<S1871>/Calib'
         *  Logic: '<S1864>/Logical3'
         *  RelationalOperator: '<S1864>/Comparison1'
         *  RelationalOperator: '<S1864>/Comparison5'
         *  Sum: '<S1864>/Sum'
         *  Switch: '<S4586>/Switch1'
         */
        THMR_ac_B.Logical2_o = (rtb_TmpSignalConversionAtVeCT_d && ((((uint32)
            VeTHMR_e_BatThrmlSt_B4D) != CeTHMR_e_ActiveCooling) || (fabsf
            (rtb_TmpSignalConversionAtVeB_cl - rtb_Switch1_d) <
            KeTHMR_T_BattOverTmp_DiffTh)));

        /* Chart: '<S1852>/THMR_HTCVFlt_RA' incorporates:
         *  Constant: '<S1875>/Constant'
         *  Constant: '<S1876>/Calib'
         *  Constant: '<S1877>/Calib'
         *  Constant: '<S1878>/Calib'
         *  Logic: '<S1865>/Logical1'
         *  Logic: '<S1865>/Logical3'
         *  Logic: '<S1865>/Logical4'
         *  RelationalOperator: '<S1472>/Comparison4'
         *  RelationalOperator: '<S1865>/Comparison3'
         *  RelationalOperator: '<S1865>/Comparison4'
         *  RelationalOperator: '<S1865>/Comparison5'
         *  Switch: '<S3948>/Switch'
         *  UnitDelay: '<S57>/UnitDelay1'
         *  UnitDelay: '<S57>/UnitDelay2'
         */
        /* Gateway: THMR_FUNC_RU_MedTEH/HTCL/HTCV_Flt_RA/HTCV_Flt_RA_Cntrls/THMR_HTCVFlt_RA */
        /* During: THMR_FUNC_RU_MedTEH/HTCL/HTCV_Flt_RA/HTCV_Flt_RA_Cntrls/THMR_HTCVFlt_RA */
        if (((uint32)THMR_ac_DW.is_active_c13_THMR_ac) == 0U)
        {
            /* Entry: THMR_FUNC_RU_MedTEH/HTCL/HTCV_Flt_RA/HTCV_Flt_RA_Cntrls/THMR_HTCVFlt_RA */
            THMR_ac_DW.is_active_c13_THMR_ac = 1U;

            /* Entry Internal: THMR_FUNC_RU_MedTEH/HTCL/HTCV_Flt_RA/HTCV_Flt_RA_Cntrls/THMR_HTCVFlt_RA */
            /* Transition: '<S1866>:45' */
        }
        else
        {
            /* During 'WaitState': '<S1866>:49' */
            if (((((uint32)tmp_c) == CeTHMR_e_NoHeating) || (((uint32)tmp_c) ==
                    CeTHMR_e_CabinHeating)) || (((uint32)tmp_c) ==
                    CeTHMR_e_BatteryHeating))
            {
                /* Transition: '<S1866>:54' */
                /* CabinHeat */
                /* Transition: '<S1866>:55' */
                /* BattHeat */
                /* Transition: '<S1866>:98' */
                THMR_ac_B.ECH_Req = false;
                THMR_ac_B.Eng_Req = false;
                THMR_ac_B.HTCV_Pos = KeTHMR_Pct_HTCVOpen;

                /* RA_ElecClntHtr_Batt_TmpHi */
                if ((((VeTHMR_n_InputSpeed >= KeTHMR_n_Eng_RPM_EngOn) &&
                        (((uint32)VeTHMR_e_EngStartStopSt_AD) ==
                         CeESSR_e_EngRunning)) ||
                        (rtb_TmpSignalConversionAtVeTA_b >
                         KeTHMR_P_EngPower_EngHot_Th)) ||
                        (KeTHMR_b_Enbl_EngHot_On))
                {
                    /* Transition: '<S1866>:83' */
                    THMR_ac_B.HT_Shtoff_VlvCmd = true;
                    THMR_ac_B.HT_AuxPmpFlow = KeTHMR_dv_HTAP_PumpOff;

                    /* RA_EngOn */
                }
                else
                {
                    /* Transition: '<S1866>:99' */
                    THMR_ac_B.HT_Shtoff_VlvCmd = false;
                    THMR_ac_B.HT_AuxPmpFlow = THMR_ac_DW.UnitDelay1_DSTATE_fj;

                    /* RA_EngOff */
                }

                if (!THMR_ac_B.Logical2_o)
                {
                    /* Transition: '<S1866>:69' */
                    THMR_ac_B.LT_ActPmpFlw = THMR_ac_DW.UnitDelay2_DSTATE_oa;

                    /* RA_BattTmp_Lo */
                }
                else
                {
                    /* Transition: '<S1866>:58' */
                    THMR_ac_B.LT_ActPmpFlw = KeTHMR_dv_LTAP_PumpOff;

                    /* RA_BattTmpHi */
                }

                /* Transition: '<S1866>:62' */
                /* Transition: '<S1866>:66' */
                /* Transition: '<S1866>:67' */
            }
            else
            {
                /* Transition: '<S1866>:102' */
            }
        }

        /* Switch: '<S1159>/Switch' */
        VeTHMR_b_HVC_HtrReqstd_StaFlow_AD = THMR_ac_B.ECH_Req;
    }
    else
    {
        /* Switch: '<S1159>/Switch' */
        VeTHMR_b_HVC_HtrReqstd_StaFlow_AD = VeTHMR_b_HVC_HtrReqstd_StaFlow_Raw;
    }

    /* End of Switch: '<S1159>/Switch' */
    /* End of Outputs for SubSystem: '<S1160>/HTCV_Flt_RA_Cntrls' */

    /* Logic: '<S1161>/Logical11' incorporates:
     *  Constant: '<S1886>/Calib'
     */
    rtb_TmpSignalConversionAtVeCT_d = ((KeTHMR_b_EnblAHPforActvCoolReq) &&
        (THMR_ac_B.LogicalOperator1));

    /* RelationalOperator: '<S1879>/Comparison1' incorporates:
     *  SignalConversion generated from: '<S1879>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_DsblPmpFrBatt

    /* VariantMerge generated from: '<S1879>/VariantSource' incorporates:
     *  Constant: '<S1893>/Constant'
     */
    rtb_VariantMerge_For_Variant__j = (CeTHMR_e_BatteryHeating == ((uint32)tmp_c));

#else

    /* VariantMerge generated from: '<S1879>/VariantSource' incorporates:
     *  Constant: '<S1879>/Constant1'
     *  SignalConversion generated from: '<S1879>/VariantSource'
     */
    rtb_VariantMerge_For_Variant__j = false;

#endif

    /* SignalConversion generated from: '<S1161>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_OvrdPmpReq

    /* VariantMerge generated from: '<S1161>/VariantSource' incorporates:
     *  Constant: '<S1161>/Constant'
     */
    rtb_VariantMerge_For_Variant_ik = true;

#else

    /* VariantMerge generated from: '<S1161>/VariantSource' incorporates:
     *  SignalConversion generated from: '<S1161>/VariantSource'
     */
    rtb_VariantMerge_For_Variant_ik = rtb_TmpSignalConversionAtVeTR_i;

#endif

    /* End of SignalConversion generated from: '<S1161>/VariantSource' */

    /* Switch: '<S1879>/Switch2' incorporates:
     *  Constant: '<S1885>/Calib'
     *  Logic: '<S1879>/Logical7'
     */
    if (!KeTHMR_b_AHPEnbl_mHEV)
    {
        /* Switch: '<S1879>/Switch2' incorporates:
         *  Constant: '<S1890>/Constant'
         *  Constant: '<S1891>/Constant'
         *  Constant: '<S1892>/Constant'
         *  Constant: '<S1894>/Constant'
         *  Constant: '<S1895>/Constant'
         *  Constant: '<S1898>/Calib'
         *  Constant: '<S1899>/Calib'
         *  Constant: '<S1900>/Calib'
         *  Logic: '<S1879>/Logical1'
         *  Logic: '<S1879>/Logical12'
         *  Logic: '<S1879>/Logical2'
         *  Logic: '<S1879>/Logical3'
         *  Logic: '<S1879>/Logical5'
         *  Logic: '<S1879>/Logical6'
         *  RelationalOperator: '<S1879>/Comparison2'
         *  RelationalOperator: '<S1879>/Comparison3'
         *  RelationalOperator: '<S1879>/Comparison4'
         *  RelationalOperator: '<S1879>/Comparison5'
         *  RelationalOperator: '<S1879>/Comparison6'
         *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
         */
        VeTHMR_b_HT_AuxPmp_NotPerWup = (((((((((KeTHMR_b_EnblAHPforDeicing) &&
            (THMR_ac_B.AND_j)) || rtb_TmpSignalConversionAtVeCT_d) ||
            rtb_VariantMerge_For_Variant__j) || (((uint32)tmp_c) ==
            CeTHMR_e_CabinHeating)) || (((uint32)tmp_c) ==
            CeTHMR_e_BatteryNCabinHeating)) || ((KeTHMR_b_OV_CabHeat_HTAP_Enb) &&
            (((((uint32)rtb_TmpSignalConversionAtVePD_l) ==
               CePDTR_e_Dischrg_CabReqPrsnt) || (((uint32)
            rtb_TmpSignalConversionAtVePD_l) == CePDTR_e_Dischrg_AmbTempLow)) ||
             (((uint32)rtb_TmpSignalConversionAtVePD_l) ==
              CePDTR_e_Dischrg_CabReqInOV)))) &&
            (rtb_TmpSignalConversionAtVeT_d5 || (KeTHMR_b_PerWupClntBsdAHPCntrl)))
            && rtb_VariantMerge_For_Variant_ik);
    }
    else
    {
        /* Switch: '<S1879>/Switch2' incorporates:
         *  Constant: '<S1879>/Constant'
         *  Constant: '<S1896>/Constant'
         *  Constant: '<S1897>/Constant'
         *  Constant: '<S1901>/Calib'
         *  Logic: '<S1879>/Logical10'
         *  Logic: '<S1879>/Logical8'
         *  Logic: '<S1879>/Logical9'
         *  RelationalOperator: '<S1472>/Comparison4'
         *  RelationalOperator: '<S1879>/RelationalOperator1'
         *  RelationalOperator: '<S1879>/RelationalOperator2'
         *  RelationalOperator: '<S1879>/RelationalOperator3'
         *  Switch: '<S3948>/Switch'
         */
        VeTHMR_b_HT_AuxPmp_NotPerWup = ((rtb_VariantMerge_For_Variant_ik &&
            (((uint32)VeTHMR_e_EngStartStopSt_AD) == CeESSR_e_EngOff)) ||
            ((((uint32)VeTHMR_e_EngStartStopSt_AD) == CeESSR_e_EngRunning) &&
             (KeTHMR_dV_HT_AuxPmpFlw_EngOn > 0.0F)));
    }

    /* SignalConversion generated from: '<S57>/HTCL_Vlv_Pos_MBC_HTL_LTCL' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    /* VariantMerge generated from: '<S57>/HTLPump_MBC_HTL_LTCL' */
    rtb_VM_Conditional_Signal_HTLPu = THMR_ac_B.Gain;

#else

    /* VariantMerge generated from: '<S57>/HTLPump_MBC_HTL_LTCL' incorporates:
     *  SignalConversion generated from: '<S57>/HTCL_Vlv_Pos_MBC_HTL_LTCL'
     */
    rtb_VM_Conditional_Signal_HTLPu = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S57>/HTCL_Vlv_Pos_MBC_HTL_LTCL' */

    /* Switch: '<S57>/Switch1' */
    if (rtb_VM_Conditional_Signal_Use_c)
    {
        /* Switch: '<S57>/Switch1' */
        THMR_ac_B.VeTHMR_Pct_HTL_BypsVlv_Cmd = rtb_VM_Conditional_Signal_HTLPu;
    }
    else
    {
        /* Switch: '<S57>/Switch1' */
        THMR_ac_B.VeTHMR_Pct_HTL_BypsVlv_Cmd = VeTHMR_Pct_HTLBypsVlv_Cmd;
    }

    /* End of Switch: '<S57>/Switch1' */

    /* RelationalOperator: '<S1881>/RelationalOperator' incorporates:
     *  Constant: '<S1905>/Calib'
     */
    rtb_TmpSignalConversionAtVeTR_i = (THMR_ac_B.VeTHMR_Pct_HTL_BypsVlv_Cmd <=
        KeTHMR_Pct_HTCL_Byps_MinClsd);

    /* Switch: '<S1881>/Switch2' incorporates:
     *  Constant: '<S1906>/Calib'
     *  Inport: '<Root>/VeTRIR_b_HtrCorClnt_TmpOut_FA'
     *  Switch: '<S1881>/Switch1'
     */
    if (KeTHMR_b_EnbAHPInletTempArb)
    {
        (void)Rte_Read_VeTRIR_b_HtrCorClnt_TmpOut_FA_Value(&rtb_OR1_k3);

        /* Switch: '<S1904>/Switch1' incorporates:
         *  Inport: '<Root>/VeTRIR_b_HtrCorClnt_TmpOut_FA'
         *  Switch: '<S1903>/Switch1'
         */
        if (rtb_TmpSignalConversionAtVeTR_i)
        {
            /* Switch: '<S1881>/Switch2' incorporates:
             *  Switch: '<S1904>/Switch1'
             */
            rtb_TmpSignalConversionAtVeT_ms = VeTHMR_T_HCCTOSArb;

            /* Switch: '<S1881>/Switch1' */
            VeTHMR_b_AHPInletTempArb_FA = rtb_OR1_k3;
        }
        else
        {
            /* Lookup_n-D: '<S1907>/Vector' incorporates:
             *  Switch: '<S57>/Switch1'
             */
            rtb_TmpSignalConversionAtVeT_ms = look1_iflf_binlcapw
                (THMR_ac_B.VeTHMR_Pct_HTL_BypsVlv_Cmd, ((const float32 *)
                  &(KxTHMR_Pct_HTCLPstnFlwpct[0])), ((const float32 *)
                  &(KtTHMR_Pct_HTCLPstnFlwpct[0])), 8U);

            /* Switch: '<S1881>/Switch2' incorporates:
             *  Abs: '<S1902>/Abs'
             *  Constant: '<S1902>/Constant'
             *  Product: '<S1902>/Product'
             *  Product: '<S1902>/Product1'
             *  Sum: '<S1902>/Add'
             *  Sum: '<S1902>/Add1'
             *  Switch: '<S1904>/Switch1'
             */
            rtb_TmpSignalConversionAtVeT_ms = (fabsf(1.0F -
                rtb_TmpSignalConversionAtVeT_ms) * VeTHMR_T_HCCTOSArb) +
                (rtb_TmpSignalConversionAtVeT_ms *
                 rtb_TmpSignalConversionAtVeTM_f);

            /* Switch: '<S1881>/Switch1' */
            VeTHMR_b_AHPInletTempArb_FA = rtb_TmpSignalConversionAtVeT_ej;
        }

        /* End of Switch: '<S1904>/Switch1' */
    }
    else
    {
        /* Switch: '<S1881>/Switch2' */
        rtb_TmpSignalConversionAtVeT_ms = rtb_TmpSignalConversionAtVeT_n0;

        /* Switch: '<S1881>/Switch1' incorporates:
         *  Inport: '<Root>/VeTMIR_b_ElecClntHtr_TmpIn_FA'
         */
        (void)Rte_Read_VeTMIR_b_ElecClntHtr_TmpIn_FA_Value
            ((&(VeTHMR_b_AHPInletTempArb_FA)));
    }

    /* End of Switch: '<S1881>/Switch2' */

    /* If: '<S1161>/If' incorporates:
     *  Constant: '<S1880>/Constant'
     *  Logic: '<S1161>/Logical2'
     *  Logic: '<S1161>/Logical3'
     *  Logic: '<S1161>/Logical6'
     *  Logic: '<S1161>/Logical8'
     *  Logic: '<S1161>/Logical9'
     *  RelationalOperator: '<S1161>/Comparison4'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     */
    if (VeTHMR_b_HT_AuxPmp_NotPerWup)
    {
        /* Outputs for IfAction SubSystem: '<S1161>/Subsystem2' incorporates:
         *  ActionPort: '<S1889>/ActionPort'
         */
        /* Logic: '<S1889>/Logical1' incorporates:
         *  Constant: '<S1920>/Constant'
         *  Constant: '<S1927>/Calib'
         *  RelationalOperator: '<S1889>/Comparison1'
         *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
         */
        VeTHMR_b_Use_ECHTIS_For_OV = ((KeTHMR_b_ClntTemp4Pmp_SD) && (((uint32)
            rtb_TmpSignalConversionAtVePD_l) == CePDTR_e_Dischrg_BatTempNotOpt));

        /* SignalConversion: '<S1889>/SignalConversion' incorporates:
         *  Logic: '<S1889>/Logical2'
         *  Logic: '<S1889>/Logical3'
         */
        VaTHMR_b_HTAP_TempSrc_FAMatrix[0] = ((rtb_AND_fe ||
            (VeTHMR_b_EngCoolantTemp_FA)) || (VeTHMR_b_Use_ECHTIS_For_OV));
        VaTHMR_b_HTAP_TempSrc_FAMatrix[1] = VeTHMR_b_AHPInletTempArb_FA;
        VaTHMR_b_HTAP_TempSrc_FAMatrix[2] = ((VeTHMR_b_HtrCorClnt_Tmp_In_FA_AD) ||
            (VeTHMR_b_Use_ECHTIS_For_OV));

        /* Chart: '<S1889>/SourcePrioritization' */
        /* Gateway: THMR_FUNC_RU_MedTEH/HTCL/HT_Aux_Pmp_Cmd/Subsystem2/SourcePrioritization */
        /* During: THMR_FUNC_RU_MedTEH/HTCL/HT_Aux_Pmp_Cmd/Subsystem2/SourcePrioritization */
        /* Entry Internal: THMR_FUNC_RU_MedTEH/HTCL/HT_Aux_Pmp_Cmd/Subsystem2/SourcePrioritization */
        /* Transition: '<S1932>:12' */
        /* Transition: '<S1932>:13' */
        s381_iter = 0;
        do
        {
            exitg1 = 0;
            if (s381_iter < 3)
            {
                /* Transition: '<S1932>:10' */
                /* Transition: '<S1932>:32' */
                if (((sint32)KaTHMR_y_HTAP_TempSrcPriority[(s381_iter)]) != 255)
                {
                    /* Transition: '<S1932>:15' */
                    /* Transition: '<S1932>:17' */
                    if (VaTHMR_b_HTAP_TempSrc_FAMatrix
                            [(KaTHMR_y_HTAP_TempSrcPriority[(s381_iter)])])
                    {
                        /* Transition: '<S1932>:19' */
                        /* Transition: '<S1932>:34' */
                        s381_iter++;

                        /* Transition: '<S1932>:37' */
                        /* Transition: '<S1932>:40' */
                        /* Transition: '<S1932>:41' */
                    }
                    else
                    {
                        /* Transition: '<S1932>:23' */
                        VeTHMR_e_HTAP_TempSrc_SF =
                            KaTHMR_y_HTAP_TempSrcPriority[(s381_iter)];

                        /* Transition: '<S1932>:45' */
                        /* Transition: '<S1932>:46' */
                        exitg1 = 1;
                    }
                }
                else
                {
                    /* Transition: '<S1932>:44' */
                    VeTHMR_e_HTAP_TempSrc_SF = 255;

                    /* Transition: '<S1932>:46' */
                    exitg1 = 1;
                }
            }
            else
            {
                /* Transition: '<S1932>:8' */
                VeTHMR_e_HTAP_TempSrc_SF = 255;
                exitg1 = 1;
            }
        }
        while (exitg1 == 0);

        /* SwitchCase: '<S1889>/Switch_Case' */
        switch (VeTHMR_e_HTAP_TempSrc_SF)
        {
          case 0:
            /* Outputs for IfAction SubSystem: '<S1889>/CalcFlowUsingECT' incorporates:
             *  ActionPort: '<S1916>/ActionPort'
             */
            THMR_ac_CondAirflow(VeTHMR_T_EngCoolantTemp, (&(VeTHMR_T_HTAP_TmpIn)));

            /* End of Outputs for SubSystem: '<S1889>/CalcFlowUsingECT' */
            break;

          case 1:
            /* Outputs for IfAction SubSystem: '<S1889>/CalcFlowUsing_ElecClntHtr_Tmp' incorporates:
             *  ActionPort: '<S1917>/ActionPort'
             */
            /* Merge: '<S1889>/Merge' incorporates:
             *  Inport: '<S1917>/AHP_InTemp'
             */
            VeTHMR_T_HTAP_TmpIn = rtb_TmpSignalConversionAtVeT_ms;

            /* End of Outputs for SubSystem: '<S1889>/CalcFlowUsing_ElecClntHtr_Tmp' */
            break;

          case 2:
            /* Outputs for IfAction SubSystem: '<S1889>/CalcFlowUsing_HtrCorClnt_Tmp' incorporates:
             *  ActionPort: '<S1918>/ActionPort'
             */
            THMR_ac_CondAirflow(VeTHMR_T_HCCTISArb, (&(VeTHMR_T_HTAP_TmpIn)));

            /* End of Outputs for SubSystem: '<S1889>/CalcFlowUsing_HtrCorClnt_Tmp' */
            break;

          default:
            /* Outputs for IfAction SubSystem: '<S1889>/Default' incorporates:
             *  ActionPort: '<S1919>/ActionPort'
             */
            THMR_ac_Default((&(VeTHMR_T_HTAP_TmpIn)));

            /* End of Outputs for SubSystem: '<S1889>/Default' */
            break;
        }

        /* End of SwitchCase: '<S1889>/Switch_Case' */

        /* If: '<S1889>/If1' incorporates:
         *  Constant: '<S1921>/Constant'
         *  Constant: '<S1922>/Constant'
         *  RelationalOperator: '<S1472>/Comparison4'
         *  RelationalOperator: '<S1889>/RelationalOperator'
         *  RelationalOperator: '<S1889>/RelationalOperator1'
         *  Switch: '<S3948>/Switch'
         */
        if (((uint32)VeTHMR_e_EngStartStopSt_AD) == CeESSR_e_EngOff)
        {
            /* Outputs for IfAction SubSystem: '<S1889>/IfActionSubsystem2' incorporates:
             *  ActionPort: '<S1924>/ActionPort'
             */
            /* Merge: '<S1889>/Merge1' incorporates:
             *  Constant: '<S1935>/Calib'
             *  SignalConversion generated from: '<S1924>/Out1'
             */
            THMR_ac_B.Merge1_go = KeTHMR_dV_HT_AuxPmpFlw_EngOff;

            /* End of Outputs for SubSystem: '<S1889>/IfActionSubsystem2' */
        }
        else
        {
            if (((uint32)VeTHMR_e_EngStartStopSt_AD) == CeESSR_e_EngRunning)
            {
                /* Outputs for IfAction SubSystem: '<S1889>/IfActionSubsystem1' incorporates:
                 *  ActionPort: '<S1923>/ActionPort'
                 */
                /* Merge: '<S1889>/Merge1' incorporates:
                 *  Constant: '<S1934>/Calib'
                 *  SignalConversion generated from: '<S1923>/Out1'
                 */
                THMR_ac_B.Merge1_go = KeTHMR_dV_HT_AuxPmpFlw_EngOn;

                /* End of Outputs for SubSystem: '<S1889>/IfActionSubsystem1' */
            }
        }

        /* End of If: '<S1889>/If1' */

        /* Switch: '<S1889>/Switch1' incorporates:
         *  Constant: '<S1926>/Calib'
         *  Logic: '<S1889>/Logical4'
         */
        if (!KeTHMR_b_AHPEnbl_mHEV)
        {
            /* Switch: '<S1889>/Switch' incorporates:
             *  Constant: '<S1936>/Constant'
             *  Constant: '<S1937>/Calib'
             *  Constant: '<S1938>/Calib'
             *  Logic: '<S1930>/Logical'
             *  RelationalOperator: '<S1930>/Comparison4'
             *  Switch: '<S1889>/Switch5'
             */
            if (((KeTHMR_b_HTLMBCSelect) && (KeTHMR_b_HTLMBCLegcySel)) &&
                    (((uint32)rtb_Switch1_o0g) == CeTHMR_e_CabinActiveHeating))
            {
                /* Merge: '<S1161>/Merge' incorporates:
                 *  Switch: '<S1889>/Switch'
                 */
                VeTHMR_dV_HT_AuxPmpFlw_B4D = VeTHMR_dV_HTLFlowMBCReq;
            }
            else if (rtb_TmpSignalConversionAtVeCT_d)
            {
                /* Switch: '<S1889>/Switch5' incorporates:
                 *  Lookup_n-D: '<S1928>/Vector'
                 *  Lookup_n-D: '<S1929>/Vector'
                 *  Merge: '<S1161>/Merge'
                 *  Merge: '<S1889>/Merge'
                 *  MinMax: '<S1889>/MinMax1'
                 *  Switch: '<S302>/Switch1'
                 */
                VeTHMR_dV_HT_AuxPmpFlw_B4D = fmaxf(look2_iflf_binlcapw
                    (VeTHMR_T_HTAP_TmpIn, VeTHMR_p_HghRfrgtPres_Arb, ((const
                    float32 *)&(KxTHMR_dV_HT_AuxPmpFlwForActvCool[0])), ((const
                    float32 *)&(KyTHMR_dV_HT_AuxPmpFlwForActvCool[0])), ((const
                    float32 *)&(KtTHMR_dV_HT_AuxPmpFlwForActvCool[0])),
                     THMR_ac_ConstP.Vector_maxIndex_p, 7U), look1_iflf_binlcapw
                    (VeTHMR_T_HTAP_TmpIn, ((const float32 *)
                    &(KxTHMR_dV_HT_AuxPmpFlw[0])), ((const float32 *)
                    &(KtTHMR_dV_HT_AuxPmpFlw[0])), 6U));
            }
            else
            {
                /* Merge: '<S1161>/Merge' incorporates:
                 *  Lookup_n-D: '<S1928>/Vector'
                 *  Merge: '<S1889>/Merge'
                 *  Switch: '<S1889>/Switch5'
                 */
                VeTHMR_dV_HT_AuxPmpFlw_B4D = look1_iflf_binlcapw
                    (VeTHMR_T_HTAP_TmpIn, ((const float32 *)
                      &(KxTHMR_dV_HT_AuxPmpFlw[0])), ((const float32 *)
                      &(KtTHMR_dV_HT_AuxPmpFlw[0])), 6U);
            }

            /* End of Switch: '<S1889>/Switch' */
        }
        else
        {
            /* Merge: '<S1161>/Merge' */
            VeTHMR_dV_HT_AuxPmpFlw_B4D = THMR_ac_B.Merge1_go;
        }

        /* End of Outputs for SubSystem: '<S1161>/Subsystem2' */
    }
    else
    {
        /* Logic: '<S1161>/Logical8' incorporates:
         *  Constant: '<S1885>/Calib'
         *  Logic: '<S1161>/Logical1'
         *  Logic: '<S1161>/Logical5'
         */
        rtb_AND_fe = !KeTHMR_b_AHPEnbl_mHEV;
        if ((THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0) && rtb_AND_fe)
        {
            /* Outputs for IfAction SubSystem: '<S1161>/Subsystem' incorporates:
             *  ActionPort: '<S1888>/ActionPort'
             */
            /* Switch: '<S1888>/Switch1' incorporates:
             *  Constant: '<S1910>/Calib'
             */
            if (KeTHMR_b_PerWp_TmpErr_SelApp)
            {
                /* Switch: '<S1888>/Switch1' incorporates:
                 *  MinMax: '<S1888>/MinMax1'
                 */
                rtb_TmpSignalConversionAtVeTPCR = fmaxf
                    (rtb_TmpSignalConversionAtVeTP_i,
                     rtb_TmpSignalConversionAtVeTPCR);
            }
            else
            {
                /* Sum: '<S1888>/Sum' incorporates:
                 *  Constant: '<S1911>/Calib'
                 *  Constant: '<S1912>/Calib'
                 *  Product: '<S1888>/Product'
                 *  Product: '<S1888>/Product1'
                 */
                rtb_TmpSignalConversionAtVeTPCR =
                    (rtb_TmpSignalConversionAtVeTP_i *
                     KeTHMR_r_PerWp_BatTmpErr_Wght) +
                    (rtb_TmpSignalConversionAtVeTPCR *
                     KeTHMR_r_PerWp_EngTmpErr_Wght);

                /* Product: '<S1888>/Product2' incorporates:
                 *  Constant: '<S1911>/Calib'
                 *  Constant: '<S1912>/Calib'
                 *  Constant: '<S1913>/Calib'
                 *  Sum: '<S1888>/Sum1'
                 */
                rtb_TmpSignalConversionAtVeTP_i = (KeTHMR_r_PerWp_BatTmpErr_Wght
                    + KeTHMR_r_PerWp_EngTmpErr_Wght) *
                    KeTHMR_r_PerWp_TmpErr_WghtCorrct;

                /* Outputs for Atomic SubSystem: '<S1888>/ProtectedDivision' */
                /* Switch: '<S1915>/Switch1' incorporates:
                 *  Constant: '<S1915>/ConstantValue'
                 *  Constant: '<S1915>/ConstantValue1'
                 *  Constant: '<S1915>/ConstantValue2'
                 *  Constant: '<S1915>/ConstantValue3'
                 *  Logic: '<S1915>/AND'
                 *  RelationalOperator: '<S1915>/GreaterThanorEqual'
                 *  RelationalOperator: '<S1915>/GreaterThanorEqual1'
                 *  RelationalOperator: '<S1915>/NotEqual'
                 *  RelationalOperator: '<S1915>/NotEqual1'
                 *  Switch: '<S1915>/Switch2'
                 *  Switch: '<S1915>/Switch3'
                 */
                if ((rtb_TmpSignalConversionAtVeTPCR != 0.0F) &&
                        (rtb_TmpSignalConversionAtVeTP_i != 0.0F))
                {
                    /* Switch: '<S1888>/Switch1' incorporates:
                     *  Product: '<S1915>/Division'
                     *  Switch: '<S1915>/Switch1'
                     */
                    rtb_TmpSignalConversionAtVeTPCR /=
                        rtb_TmpSignalConversionAtVeTP_i;
                }
                else if (rtb_TmpSignalConversionAtVeTPCR > 0.0F)
                {
                    /* Switch: '<S1915>/Switch2' incorporates:
                     *  Constant: '<S1915>/MAXFLOAT'
                     *  Switch: '<S1888>/Switch1'
                     */
                    rtb_TmpSignalConversionAtVeTPCR = 3.402823466E+38F;
                }
                else if (rtb_TmpSignalConversionAtVeTPCR < 0.0F)
                {
                    /* Switch: '<S1915>/Switch3' incorporates:
                     *  Constant: '<S1915>/MINFLOAT'
                     *  Switch: '<S1888>/Switch1'
                     *  Switch: '<S1915>/Switch2'
                     */
                    rtb_TmpSignalConversionAtVeTPCR = -3.402823466E+38F;
                }
                else
                {
                    /* Switch: '<S1888>/Switch1' incorporates:
                     *  Constant: '<S1915>/ConstantValue4'
                     *  Switch: '<S1915>/Switch2'
                     *  Switch: '<S1915>/Switch3'
                     */
                    rtb_TmpSignalConversionAtVeTPCR = 0.0F;
                }

                /* End of Switch: '<S1915>/Switch1' */
                /* End of Outputs for SubSystem: '<S1888>/ProtectedDivision' */
            }

            /* End of Switch: '<S1888>/Switch1' */

            /* Merge: '<S1161>/Merge' incorporates:
             *  Lookup_n-D: '<S1914>/Vector'
             *  Switch: '<S1888>/Switch1'
             */
            VeTHMR_dV_HT_AuxPmpFlw_B4D = look1_iflf_binlcapw
                (rtb_TmpSignalConversionAtVeTPCR, ((const float32 *)
                  &(KxTHMR_dV_PerWp_HT_AuxPmpFlow[0])), ((const float32 *)
                  &(KtTHMR_dV_PerWp_HT_AuxPmpFlow[0])), 6U);

            /* End of Outputs for SubSystem: '<S1161>/Subsystem' */
        }
        else if ((((uint32)rtb_TmpSignalConversionAtVePD_l) ==
                  CePDTR_e_Dischrg_AmbTempLow) && rtb_AND_fe)
        {
            /* Outputs for IfAction SubSystem: '<S1161>/IfActionSubsystem' incorporates:
             *  ActionPort: '<S1882>/ActionPort'
             */
            /* Merge: '<S1161>/Merge' incorporates:
             *  Constant: '<S1908>/Calib'
             *  SignalConversion generated from: '<S1882>/Out1'
             */
            VeTHMR_dV_HT_AuxPmpFlw_B4D = KeTHMR_dV_HT_AuxPmpFlw_CabHtg_OV_Dial;

            /* End of Outputs for SubSystem: '<S1161>/IfActionSubsystem' */
        }
        else if ((((rtb_AND_fe && (VeTHMR_b_HVC_HtrReqstd_StaFlow_Raw)) &&
                   (!VeTHMR_b_HT_AuxPmp_NotPerWup)) &&
                  rtb_TmpSignalConversionAtVeT_d5) &&
                 rtb_VariantMerge_For_Variant_ik)
        {
            /* Outputs for IfAction SubSystem: '<S1161>/IfActionSubsystem1' incorporates:
             *  ActionPort: '<S1883>/ActionPort'
             */
            THMR_ac_Default((&(VeTHMR_dV_HT_AuxPmpFlw_B4D)));

            /* End of Outputs for SubSystem: '<S1161>/IfActionSubsystem1' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S1161>/IfActionSubsystem2' incorporates:
             *  ActionPort: '<S1884>/ActionPort'
             */
            /* Merge: '<S1161>/Merge' incorporates:
             *  Constant: '<S1884>/ConstantValue4'
             *  SignalConversion generated from: '<S1884>/Out1'
             */
            VeTHMR_dV_HT_AuxPmpFlw_B4D = 0.0F;

            /* End of Outputs for SubSystem: '<S1161>/IfActionSubsystem2' */
        }
    }

    /* Switch: '<S1159>/Switch1' incorporates:
     *  Switch: '<S1159>/Switch3'
     *  Switch: '<S1159>/Switch4'
     *  Switch: '<S1159>/Switch5'
     */
    if (THMR_ac_B.Logical7_l)
    {
        /* Switch: '<S1159>/Switch1' */
        rtb_TmpSignalConversionAtVeTPCR = THMR_ac_B.HT_AuxPmpFlow;

        /* Switch: '<S1159>/Switch3' */
        rtb_VariantMerge_For_Variant_ik = THMR_ac_B.HT_Shtoff_VlvCmd;

        /* Switch: '<S1159>/Switch4' */
        rtb_TmpSignalConversionAtVeTPDR = THMR_ac_B.LT_ActPmpFlw;

        /* Switch: '<S1159>/Switch5' */
        rtb_TmpSignalConversionAtVeT_ej = THMR_ac_B.Eng_Req;
    }
    else
    {
        /* Switch: '<S1159>/Switch1' */
        rtb_TmpSignalConversionAtVeTPCR = VeTHMR_dV_HT_AuxPmpFlw_B4D;

        /* Switch: '<S1159>/Switch3' */
        rtb_VariantMerge_For_Variant_ik = VeTHMR_b_HT_Shtoff_VlvCmd_B4D;

        /* Switch: '<S1159>/Switch4' */
        rtb_TmpSignalConversionAtVeTPDR = VeTHMR_dV_LTAPFlwReq_Mod_1;

        /* Switch: '<S1153>/Switch4' incorporates:
         *  Constant: '<S1421>/Calib'
         */
        if (KeTHMR_b_HeatState_EngReq_Enbl)
        {
            rtb_AND_fe = VeTHMR_b_ThermSystEng_Req_HeatState;
        }
        else
        {
            rtb_AND_fe = VeTHMR_b_ThrmSystEng_ReqAPerWp;
        }

        /* End of Switch: '<S1153>/Switch4' */

        /* Switch: '<S1159>/Switch5' incorporates:
         *  Logic: '<S1153>/LogicalOperator'
         */
        rtb_TmpSignalConversionAtVeT_ej = ((rtb_AND_fe ||
            (VeTHMR_b_EngOnReq_BattLoopEmrgncyCool_mHEV)) ||
            (VeTHMR_b_EngOnReq_BattCritical_mHEV));
    }

    /* End of Switch: '<S1159>/Switch1' */

    /* If: '<S1163>/CabinHeat_Rqst_and_CPV3_Position' incorporates:
     *  Constant: '<S1955>/Constant'
     *  Constant: '<S1956>/Constant'
     *  RelationalOperator: '<S1163>/Comparison3'
     *  RelationalOperator: '<S1163>/Comparison5'
     */
    rtPrevAction = THMR_ac_DW.CabinHeat_Rqst_and_CPV3_Posit_p;
    if (((uint32)tmp_c) == CeTHMR_e_BatteryHeating)
    {
        rtAction = 0;
    }
    else if (((uint32)tmp_c) != CeTHMR_e_NoHeating)
    {
        rtAction = 1;
    }
    else
    {
        rtAction = 2;
    }

    THMR_ac_DW.CabinHeat_Rqst_and_CPV3_Posit_p = rtAction;
    switch (rtAction)
    {
      case 0:
        if (rtAction != rtPrevAction)
        {
            /* SystemReset for IfAction SubSystem: '<S1163>/HtrBypass_Delay' incorporates:
             *  ActionPort: '<S1957>/ActionPort'
             */
            /* SystemReset for Atomic SubSystem: '<S1957>/EdgeRising' */
            /* SystemReset for If: '<S1163>/CabinHeat_Rqst_and_CPV3_Position' incorporates:
             *  UnitDelay: '<S1960>/Unit Delay'
             *  UnitDelay: '<S1961>/Unit Delay'
             */
            THMR_ac_DW.UnitDelay_DSTATE_hw = false;

            /* End of SystemReset for SubSystem: '<S1957>/EdgeRising' */

            /* SystemReset for Atomic SubSystem: '<S1957>/Count Down Reset Enabled' */
            THMR_ac_DW.UnitDelay_DSTATE_f5 = 0U;

            /* End of SystemReset for SubSystem: '<S1957>/Count Down Reset Enabled' */
            /* End of SystemReset for SubSystem: '<S1163>/HtrBypass_Delay' */
        }

        /* Outputs for IfAction SubSystem: '<S1163>/HtrBypass_Delay' incorporates:
         *  ActionPort: '<S1957>/ActionPort'
         */
        /* Outputs for Atomic SubSystem: '<S1957>/EdgeRising' */
        /* Logic: '<S1961>/OR1' incorporates:
         *  UnitDelay: '<S1961>/Unit Delay'
         */
        rtb_OR1_k3 = !THMR_ac_DW.UnitDelay_DSTATE_hw;

        /* Update for UnitDelay: '<S1961>/Unit Delay' incorporates:
         *  Constant: '<S1957>/Constant1'
         */
        THMR_ac_DW.UnitDelay_DSTATE_hw = true;

        /* Outputs for Atomic SubSystem: '<S1957>/Count Down Reset Enabled' */
        /* Switch: '<S1960>/Switch1' incorporates:
         *  Constant: '<S1960>/Constant Value'
         *  Logic: '<S1961>/AND'
         *  RelationalOperator: '<S1960>/Greater  Than'
         *  Switch: '<S1960>/Switch2'
         *  UnitDelay: '<S1960>/Unit Delay'
         */
        if (rtb_OR1_k3)
        {
            /* Switch: '<S1960>/Switch1' incorporates:
             *  Constant: '<S1957>/Constant2'
             */
            rtb_Switch_i3 = 50U;
        }
        else if (((sint32)THMR_ac_DW.UnitDelay_DSTATE_f5) > 0)
        {
            /* Switch: '<S1960>/Switch2' incorporates:
             *  Constant: '<S1960>/Constant Value1'
             *  Sum: '<S1960>/Subtraction'
             *  Switch: '<S1960>/Switch1'
             *  UnitDelay: '<S1960>/Unit Delay'
             */
            rtb_Switch_i3 = (uint16)((sint32)(((sint32)
                THMR_ac_DW.UnitDelay_DSTATE_f5) - 1));
        }
        else
        {
            /* Switch: '<S1960>/Switch1' incorporates:
             *  Switch: '<S1960>/Switch2'
             *  UnitDelay: '<S1960>/Unit Delay'
             */
            rtb_Switch_i3 = THMR_ac_DW.UnitDelay_DSTATE_f5;
        }

        /* End of Switch: '<S1960>/Switch1' */
        /* End of Outputs for SubSystem: '<S1957>/EdgeRising' */

        /* Update for UnitDelay: '<S1960>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_f5 = rtb_Switch_i3;

        /* Switch: '<S1957>/Switch' incorporates:
         *  Constant: '<S1960>/Constant Value2'
         *  RelationalOperator: '<S1960>/Greater  Than1'
         */
        if (((sint32)rtb_Switch_i3) > 0)
        {
            /* Merge: '<S1163>/Merge1' incorporates:
             *  UnitDelay: '<S1163>/Unit Delay'
             */
            THMR_ac_B.Merge1_h = THMR_ac_DW.UnitDelay_DSTATE_cy;
        }
        else
        {
            /* Merge: '<S1163>/Merge1' incorporates:
             *  Constant: '<S1957>/Constant3'
             */
            THMR_ac_B.Merge1_h = 0.0F;
        }

        /* End of Switch: '<S1957>/Switch' */
        /* End of Outputs for SubSystem: '<S1957>/Count Down Reset Enabled' */
        /* End of Outputs for SubSystem: '<S1163>/HtrBypass_Delay' */
        break;

      case 1:
        /* Outputs for IfAction SubSystem: '<S1163>/HtrBypass_Open' incorporates:
         *  ActionPort: '<S1959>/ActionPort'
         */
        /* Merge: '<S1163>/Merge1' incorporates:
         *  Constant: '<S1963>/Calib'
         *  SignalConversion generated from: '<S1959>/Out'
         */
        THMR_ac_B.Merge1_h = KeTHMR_Pct_HtrByPassOpen;

        /* End of Outputs for SubSystem: '<S1163>/HtrBypass_Open' */
        break;

      default:
        /* Outputs for IfAction SubSystem: '<S1163>/HtrBypass_Dflt' incorporates:
         *  ActionPort: '<S1958>/ActionPort'
         */
        /* Merge: '<S1163>/Merge1' incorporates:
         *  Constant: '<S1962>/Calib'
         *  SignalConversion generated from: '<S1958>/Out'
         */
        THMR_ac_B.Merge1_h = KeTHMR_Pct_HtrByPassDflt;

        /* End of Outputs for SubSystem: '<S1163>/HtrBypass_Dflt' */
        break;
    }

    /* End of If: '<S1163>/CabinHeat_Rqst_and_CPV3_Position' */

    /* Gain: '<S1171>/Gain' */
    rtb_TmpSignalConversionAtVeTP_i = rtb_TmpSignalConversionAtVeTPDR;

    /* SignalConversion generated from: '<S57>/HTLPump_MBC_HTL_LTCL' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    /* VariantMerge generated from: '<S57>/HTLPump_MBC_HTL_LTCL' */
    rtb_VM_Conditional_Signal_HTLPu = THMR_ac_B.Gain_i;

#else

    /* VariantMerge generated from: '<S57>/HTLPump_MBC_HTL_LTCL' incorporates:
     *  SignalConversion generated from: '<S57>/HTLPump_MBC_HTL_LTCL'
     */
    rtb_VM_Conditional_Signal_HTLPu = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S57>/HTLPump_MBC_HTL_LTCL' */

    /* Update for UnitDelay: '<S1158>/UnitDelay' incorporates:
     *  Switch: '<S1158>/Switch'
     */
    THMR_ac_DW.UnitDelay_DSTATE_c1 = VeTHMR_e_HTCL_Heat_Distrib_B4D;

    /* Update for Delay: '<S1150>/Delay' */
    THMR_ac_DW.Delay_DSTATE = rtb_TmpSignalConversionAtVeT_ms;

    /* Update for UnitDelay: '<S1347>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ew = VeTHMR_b_Switch2ActValue_Vlv_Init0;

    /* Update for UnitDelay: '<S57>/UnitDelay4' */
    THMR_ac_DW.UnitDelay4_DSTATE_k = rtb_TmpSignalConversionAtVeT_ej;

    /* Update for UnitDelay: '<S57>/UnitDelay' incorporates:
     *  DataTypeConversion: '<S4042>/DataTypeConversion'
     */
    THMR_ac_DW.UnitDelay_DSTATE_pwv = VeTHMR_e_Htr1_State_B4SET;

    /* Update for UnitDelay: '<S1741>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_jq = rtb_Switch1_az;

    /* Update for UnitDelay: '<S1497>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ecz = VeTHMR_b_EngReq_HtrFlty_RA_B4D;

    /* Update for UnitDelay: '<S1470>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_di = VeTHMR_b_HT_Shtoff_VlvCmd_B4PWup;

    /* Update for UnitDelay: '<S57>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_fj = rtb_TmpSignalConversionAtVeTPCR;

    /* Update for UnitDelay: '<S57>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_oa = rtb_TmpSignalConversionAtVeTPDR;

    /* Update for Enabled SubSystem: '<S1160>/HTCV_Flt_RA_Cntrls' incorporates:
     *  EnablePort: '<S1852>/Enable'
     */
    if (THMR_ac_B.Logical7_l)
    {
        /* Update for UnitDelay: '<S1867>/UnitDelay1' */
        THMR_ac_DW.UnitDelay1_DSTATE_n = rtb_Switch1_d;
    }

    /* End of Update for SubSystem: '<S1160>/HTCV_Flt_RA_Cntrls' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Gain: '<S4036>/Gain' incorporates:
     *  Inport: '<Root>/VeRCVR_b_RSVCompTransition'
     */
    (void)Rte_Read_VeRCVR_b_RSVCompTransition_Value(&Gain_bl);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* Update for UnitDelay: '<S1163>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_cy = THMR_ac_B.Merge1_h;

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Gain: '<S4063>/Gain' */
    VeTHMR_T_CellTempMax = rtb_TmpSignalConversionAtVeBTRR;

    /* Gain: '<S4082>/Gain' */
    VeTHMR_T_CellTempMin = rtb_TmpSignalConversionAtVeBT_o;

    /* Switch: '<S5290>/Switch1' incorporates:
     *  Constant: '<S5291>/Calib'
     */
    if (KeTHMR_b_RU_TstSwitch1)
    {
        /* Switch: '<S5290>/Switch1' incorporates:
         *  Constant: '<S5292>/Calib'
         */
        THMR_ac_B.Switch1_b1 = KeTHMR_dT_ChillerDeficitTest;
    }
    else
    {
        /* Switch: '<S5290>/Switch1' */
        THMR_ac_B.Switch1_b1 = rtb_TmpSignalConversionAtVeB_cl;
    }

    /* End of Switch: '<S5290>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S4420>/CountDownResetTriggerEnabled1' */
    /* Outputs for Atomic SubSystem: '<S4423>/EdgeRising' */
    /* Logic: '<S4426>/OR1' incorporates:
     *  UnitDelay: '<S4426>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeCT_d = !THMR_ac_DW.UnitDelay_DSTATE_px;

    /* Update for UnitDelay: '<S4426>/UnitDelay' incorporates:
     *  Constant: '<S4420>/TRUEConstant5'
     */
    THMR_ac_DW.UnitDelay_DSTATE_px = true;

    /* Switch: '<S4423>/Switch1' incorporates:
     *  Constant: '<S4423>/ConstantValue'
     *  Logic: '<S4426>/AND'
     *  RelationalOperator: '<S4423>/GreaterThan'
     *  Switch: '<S4423>/Switch2'
     *  UnitDelay: '<S4423>/UnitDelay'
     */
    if (rtb_TmpSignalConversionAtVeCT_d)
    {
        /* Switch: '<S4423>/Switch1' incorporates:
         *  Constant: '<S4424>/Calib'
         */
        rtb_Switch_i3 = KeTHMR_t_HVBR_LocalUsgEnb;
    }
    else if (((sint32)THMR_ac_DW.UnitDelay_DSTATE_gk) > 0)
    {
        /* Switch: '<S4423>/Switch2' incorporates:
         *  Constant: '<S4423>/ConstantValue1'
         *  Sum: '<S4423>/Subtraction'
         *  Switch: '<S4423>/Switch1'
         *  UnitDelay: '<S4423>/UnitDelay'
         */
        rtb_Switch_i3 = (uint16)((sint32)(((sint32)
            THMR_ac_DW.UnitDelay_DSTATE_gk) - 1));
    }
    else
    {
        /* Switch: '<S4423>/Switch1' incorporates:
         *  Switch: '<S4423>/Switch2'
         *  UnitDelay: '<S4423>/UnitDelay'
         */
        rtb_Switch_i3 = THMR_ac_DW.UnitDelay_DSTATE_gk;
    }

    /* End of Switch: '<S4423>/Switch1' */
    /* End of Outputs for SubSystem: '<S4423>/EdgeRising' */

    /* Update for UnitDelay: '<S4423>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_gk = rtb_Switch_i3;

    /* Logic: '<S4420>/Logical4' incorporates:
     *  Constant: '<S4423>/ConstantValue2'
     *  RelationalOperator: '<S4423>/GreaterThan1'
     */
    rtb_TmpSignalConversionAtVeCT_d = (((sint32)rtb_Switch_i3) <= 0);

    /* End of Outputs for SubSystem: '<S4420>/CountDownResetTriggerEnabled1' */

    /* Outputs for Enabled SubSystem: '<S4106>/HV_BatRdy_Allow' incorporates:
     *  EnablePort: '<S4419>/Enable'
     */
    /* Gain: '<S4425>/Gain' */
    if (rtb_TmpSignalConversionAtVeCT_d)
    {
        /* Switch: '<S4419>/Switch' incorporates:
         *  Constant: '<S4422>/Calib'
         */
        if (KeTHMR_b_HV_BatRdy_True_Sel)
        {
            /* Switch: '<S4419>/Switch' incorporates:
             *  RelationalOperator: '<S4419>/Comparison2'
             */
            THMR_ac_B.VeTHMR_b_HV_BatRdyLocal_True_B4 = VeTHMR_b_HV_BatRdy_AD;
        }
        else
        {
            /* Switch: '<S4419>/Switch' incorporates:
             *  Constant: '<S4421>/Calib'
             */
            THMR_ac_B.VeTHMR_b_HV_BatRdyLocal_True_B4 = KeTHMR_b_HV_BatRdy_True;
        }

        /* End of Switch: '<S4419>/Switch' */
    }

    /* End of Gain: '<S4425>/Gain' */
    /* End of Outputs for SubSystem: '<S4106>/HV_BatRdy_Allow' */

    /* Truth Table: '<S4251>/Cab_Allowed' incorporates:
     *  RelationalOperator: '<S4336>/Comparison3'
     */
    rtb_LogicalOperator_lw = !rtb_TmpSignalConversionAtVeTP_c;

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Logic: '<S4336>/Logical2' incorporates:
     *  Constant: '<S4363>/Constant'
     *  Constant: '<S4364>/Constant'
     *  Constant: '<S4365>/Constant'
     *  Logic: '<S4336>/Logical1'
     *  Logic: '<S4336>/Logical3'
     *  RelationalOperator: '<S2869>/RelationalOperator'
     *  RelationalOperator: '<S4336>/Comparison1'
     *  RelationalOperator: '<S4336>/Comparison2'
     *  RelationalOperator: '<S4336>/Comparison4'
     *  RelationalOperator: '<S4336>/Comparison7'
     *  Switch: '<S3945>/Switch'
     */
    VeTHMR_b_CabReq_NotAllow_KeyOff_Acc = ((((rtb_LogicalOperator_lw ||
        (!THMR_ac_B.VeTHMR_b_HV_BatRdyLocal_True_B4)) && (CeSSDR_e_KeyOff ==
        ((uint32)VeTHMR_e_SSDR_KeySts))) || (((uint32)VeTHMR_e_SSDR_KeySts) ==
        CeSSDR_e_KeyAccy)) || (((uint32)VeTHMR_e_SSDR_KeySts) ==
        CeSSDR_e_KeyPostRunAccy));

    /* RelationalOperator: '<S4337>/Comparison1' incorporates:
     *  Constant: '<S4366>/Constant'
     *  RelationalOperator: '<S2869>/RelationalOperator'
     *  Switch: '<S3945>/Switch'
     */
    VeTHMR_b_KeyInRun = (((uint32)VeTHMR_e_SSDR_KeySts) == CeSSDR_e_KeyRun);

    /* Switch: '<S4113>/Switch' incorporates:
     *  Constant: '<S4491>/Calib'
     */
    if (KeTHMR_b_Charg_PlgdIn_Sel)
    {
        /* Switch: '<S4113>/Switch' */
        VeTHMR_b_PlugdIn_Or_Chrg = THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i;
    }
    else
    {
        /* Switch: '<S4113>/Switch' */
        VeTHMR_b_PlugdIn_Or_Chrg = rtb_TmpSignalConversionAtVeB_jd;
    }

    /* End of Switch: '<S4113>/Switch' */

    /* Outputs for Atomic SubSystem: '<S4369>/Hysteresis1' */
    /* Switch: '<S4374>/Switch1' incorporates:
     *  Constant: '<S4377>/Calib'
     *  RelationalOperator: '<S4374>/GreaterThan'
     */
    if (VeTHMR_Pct_HV_BatSOC > KeTHMR_Pct_CabCondEnbl_Run_NoPlugin)
    {
        /* Switch: '<S4374>/Switch1' incorporates:
         *  Constant: '<S4374>/ConstantValue'
         */
        rtb_LogicalOperator1_fo = true;
    }
    else
    {
        /* Switch: '<S4374>/Switch1' incorporates:
         *  Constant: '<S4376>/Calib'
         *  RelationalOperator: '<S4374>/GreaterThan1'
         *  UnitDelay: '<S4374>/UnitDelay'
         */
        rtb_LogicalOperator1_fo = ((VeTHMR_Pct_HV_BatSOC >=
            KeTHMR_Pct_CabCondDsbl_Run_NoPlugin) &&
            (THMR_ac_DW.UnitDelay_DSTATE_du));
    }

    /* End of Switch: '<S4374>/Switch1' */

    /* Update for UnitDelay: '<S4374>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_du = rtb_LogicalOperator1_fo;

    /* End of Outputs for SubSystem: '<S4369>/Hysteresis1' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* RelationalOperator: '<S4116>/RelationalOperator2' incorporates:
     *  Constant: '<S4539>/Constant'
     *  RelationalOperator: '<S2869>/RelationalOperator'
     *  RelationalOperator: '<S4117>/Comparison1'
     *  Switch: '<S3945>/Switch'
     */
    rtb_TmpSignalConversionAtVeB_jd = (CeSSDR_e_KeyOff == ((uint32)
        VeTHMR_e_SSDR_KeySts));

    /* Logic: '<S4117>/Logical1' incorporates:
     *  Constant: '<S4540>/Constant'
     *  Constant: '<S4541>/Constant'
     *  Constant: '<S4542>/Constant'
     *  RelationalOperator: '<S2869>/RelationalOperator'
     *  RelationalOperator: '<S4117>/Comparison2'
     *  RelationalOperator: '<S4117>/Comparison3'
     *  RelationalOperator: '<S4117>/Comparison4'
     *  Switch: '<S3945>/Switch'
     */
    rtb_NotEqual_fo = (((CeSSDR_e_KeyAccy == ((uint32)VeTHMR_e_SSDR_KeySts)) ||
                        (((uint32)VeTHMR_e_SSDR_KeySts) ==
                         CeSSDR_e_KeyPostRunAccy)) || (((uint32)
                         VeTHMR_e_SSDR_KeySts) == CeSSDR_e_KeyRun));

    /* Logic: '<S4117>/Logical2' incorporates:
     *  Constant: '<S4543>/Constant'
     *  Constant: '<S4544>/Constant'
     *  RelationalOperator: '<S2869>/RelationalOperator'
     *  RelationalOperator: '<S4117>/Comparison5'
     *  RelationalOperator: '<S4117>/Comparison6'
     *  Switch: '<S3945>/Switch'
     */
    rtb_TmpSignalConversionAtVeBT_f = ((CeSSDR_e_KeyCrank == ((uint32)
        VeTHMR_e_SSDR_KeySts)) || (((uint32)VeTHMR_e_SSDR_KeySts) ==
        CeSSDR_e_KeyPostCrnk));

    /* Switch: '<S4547>/Switch1' incorporates:
     *  Switch: '<S4546>/Switch1'
     *  Switch: '<S4548>/Switch1'
     */
    if (rtb_TmpSignalConversionAtVeB_jd)
    {
        /* Switch: '<S4547>/Switch1' */
        VeTHMR_P_PwrBdgt_PwrLimitAvail_BD = VeTHMR_P_AvalPwrForThmr;
    }
    else if (rtb_NotEqual_fo)
    {
        /* Switch: '<S4546>/Switch1' incorporates:
         *  Switch: '<S4547>/Switch1'
         */
        VeTHMR_P_PwrBdgt_PwrLimitAvail_BD = VeTHMR_P_AvalPwrForThmr;
    }
    else if (rtb_TmpSignalConversionAtVeBT_f)
    {
        /* Switch: '<S4548>/Switch1' incorporates:
         *  Switch: '<S4546>/Switch1'
         *  Switch: '<S4547>/Switch1'
         */
        VeTHMR_P_PwrBdgt_PwrLimitAvail_BD = VeTHMR_P_AvalPwrForThmr;
    }
    else
    {
        /* Switch: '<S4547>/Switch1' incorporates:
         *  Constant: '<S4552>/Calib'
         *  Switch: '<S4546>/Switch1'
         *  Switch: '<S4548>/Switch1'
         */
        VeTHMR_P_PwrBdgt_PwrLimitAvail_BD = KeTHMR_P_Deflt_PwrLimit;
    }

    /* End of Switch: '<S4547>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Logic: '<S4337>/Logical1' incorporates:
     *  Constant: '<S4367>/Constant'
     *  Constant: '<S4368>/Constant'
     *  Constant: '<S4372>/Calib'
     *  Constant: '<S4373>/Calib'
     *  Logic: '<S4335>/Logical2'
     *  Logic: '<S4337>/Logical6'
     *  Logic: '<S4337>/Logical7'
     *  Logic: '<S4337>/Logical8'
     *  RelationalOperator: '<S2869>/RelationalOperator'
     *  RelationalOperator: '<S4337>/Comparison2'
     *  RelationalOperator: '<S4337>/Comparison3'
     *  RelationalOperator: '<S4337>/Comparison4'
     *  Switch: '<S3945>/Switch'
     */
    rtb_Logical27 = (((((VeTHMR_b_KeyInRun) || ((((uint32)VeTHMR_e_SSDR_KeySts) ==
                          CeSSDR_e_KeyCrank) && (KeTHMR_b_EnblKeyCrnkCabNotAllw)))
                       || ((((uint32)VeTHMR_e_SSDR_KeySts) ==
                            CeSSDR_e_KeyPostCrnk) &&
                           (KeTHMR_b_EnblKeyPostCrnkCabNotAllw))) &&
                      (THMR_ac_B.VeTHMR_b_HV_BatRdyLocal_True_B4)) &&
                     (!rtb_TmpSignalConversionAtPropSy));

    /* Logic: '<S4337>/Logical3' incorporates:
     *  Logic: '<S4117>/Logical11'
     *  Logic: '<S4117>/Logical13'
     *  Logic: '<S4335>/Logical5'
     *  Switch: '<S4549>/Switch1'
     *  Switch: '<S4550>/Switch1'
     */
    rtb_RelationalOperator7_p = !rtb_Switch_hql;

    /* Truth Table: '<S4251>/Cab_Allowed' incorporates:
     *  RelationalOperator: '<S4337>/Comparison7'
     *  Truth Table: '<S4098>/Batt_Condition'
     */
    rtb_TmpSignalConversionAtVeTR_i = !VeTHMR_b_PlugdIn_Or_Chrg;

    /* Logic: '<S4337>/Logical1' incorporates:
     *  Constant: '<S4370>/Calib'
     *  Constant: '<S4371>/Calib'
     *  Constant: '<S4375>/Calib'
     *  Constant: '<S4378>/Calib'
     *  Logic: '<S4337>/Logical2'
     *  Logic: '<S4337>/Logical3'
     *  Logic: '<S4337>/Logical4'
     *  Logic: '<S4369>/Logical1'
     *  Logic: '<S4369>/Logical2'
     *  Logic: '<S4369>/Logical3'
     *  RelationalOperator: '<S4369>/Comparison1'
     */
    VeTHMR_b_CabReq_NotAllow_Key_RUN = ((((rtb_Logical27 &&
        rtb_TmpSignalConversionAtVeTR_i) && (rtb_RelationalOperator7_p ||
        (KeTHMR_b_Dsbl_CabPrecChk_CabNotAllw))) &&
        (rtb_TmpSignalConversionAtVeCT_c ||
         (KeTHMR_b_Dsbl_Dfrst_CabNotAllwKeyRun))) && (((!rtb_LogicalOperator1_fo)
        || (VeTHMR_P_PwrBdgt_PwrLimitAvail_BD <= KeTHMR_P_ThrmlPrwAvail_Low)) ||
        (KeTHMR_b_CabCondKeyRun_NoPlugIn)));

    /* Outputs for Atomic SubSystem: '<S4347>/Hysteresis1' */
    /* Switch: '<S4350>/Switch1' incorporates:
     *  Constant: '<S4356>/Calib'
     *  RelationalOperator: '<S4350>/GreaterThan'
     */
    if (VeTHMR_Pct_HV_BatSOC > KeTHMR_Pct_DisablingSOCMin)
    {
        /* Switch: '<S4350>/Switch1' incorporates:
         *  Constant: '<S4350>/ConstantValue'
         */
        rtb_LogicalOperator1_fo = true;
    }
    else
    {
        /* Switch: '<S4350>/Switch1' incorporates:
         *  Constant: '<S4359>/Calib'
         *  RelationalOperator: '<S4350>/GreaterThan1'
         *  UnitDelay: '<S4350>/UnitDelay'
         */
        rtb_LogicalOperator1_fo = ((VeTHMR_Pct_HV_BatSOC >=
            KeTHMR_Pct_RenblingSOCMin) && (THMR_ac_DW.UnitDelay_DSTATE_kj));
    }

    /* End of Switch: '<S4350>/Switch1' */

    /* Update for UnitDelay: '<S4350>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kj = rtb_LogicalOperator1_fo;

    /* End of Outputs for SubSystem: '<S4347>/Hysteresis1' */

    /* RelationalOperator: '<S4347>/Comparison2' incorporates:
     *  RelationalOperator: '<S4347>/Comparison3'
     *  UnitDelay: '<S4335>/UnitDelay1'
     */
    VeTHMR_b_LearningOk_tmp = THMR_ac_DW.UnitDelay1_DSTATE_ncb;

    /* Logic: '<S4347>/Logical8' incorporates:
     *  Constant: '<S4348>/Constant'
     *  Constant: '<S4349>/Constant'
     *  RelationalOperator: '<S4347>/Comparison2'
     *  RelationalOperator: '<S4347>/Comparison3'
     */
    VeTHMR_b_BattConditioning = ((((uint32)VeTHMR_b_LearningOk_tmp) ==
        CeTHMR_e_ActiveCooling) || (((uint32)VeTHMR_b_LearningOk_tmp) ==
        CeTHMR_e_Heating));

    /* Outputs for Atomic SubSystem: '<S4347>/Hysteresis2' */
    /* Switch: '<S4351>/Switch1' incorporates:
     *  Constant: '<S4357>/Calib'
     *  RelationalOperator: '<S4351>/GreaterThan'
     */
    if (VeTHMR_Pct_HV_BatSOC > KeTHMR_Pct_DisablingSOCMin_BattCond)
    {
        /* Switch: '<S4351>/Switch1' incorporates:
         *  Constant: '<S4351>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeBT_m = true;
    }
    else
    {
        /* Switch: '<S4351>/Switch1' incorporates:
         *  Constant: '<S4360>/Calib'
         *  RelationalOperator: '<S4351>/GreaterThan1'
         *  UnitDelay: '<S4351>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeBT_m = ((VeTHMR_Pct_HV_BatSOC >=
            KeTHMR_Pct_RenblingSOCMin_BattCond) &&
            (THMR_ac_DW.UnitDelay_DSTATE_fs));
    }

    /* End of Switch: '<S4351>/Switch1' */

    /* Update for UnitDelay: '<S4351>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_fs = rtb_TmpSignalConversionAtVeBT_m;

    /* End of Outputs for SubSystem: '<S4347>/Hysteresis2' */

    /* Logic: '<S4347>/Logical10' incorporates:
     *  Constant: '<S4354>/Calib'
     *  Logic: '<S4347>/Logical9'
     *  RelationalOperator: '<S4347>/Comparison6'
     */
    VeTHMR_b_NoCabLoSOCPwrBdgt_BattCond = ((!rtb_TmpSignalConversionAtVeBT_m) ||
        (VeTHMR_P_PwrBdgt_PwrLimitAvail_BD <= KeTHMR_P_ThrmlPrwAvail_LowBattCond));

    /* Outputs for Atomic SubSystem: '<S4347>/Hysteresis3' */
    /* Switch: '<S4352>/Switch1' incorporates:
     *  Constant: '<S4358>/Calib'
     *  RelationalOperator: '<S4352>/GreaterThan'
     */
    if (VeTHMR_Pct_HV_BatSOC > KeTHMR_Pct_DsblSOCMin_NoBattCond)
    {
        /* Switch: '<S4352>/Switch1' incorporates:
         *  Constant: '<S4352>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeBT_m = true;
    }
    else
    {
        /* Switch: '<S4352>/Switch1' incorporates:
         *  Constant: '<S4361>/Calib'
         *  RelationalOperator: '<S4352>/GreaterThan1'
         *  UnitDelay: '<S4352>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeBT_m = ((VeTHMR_Pct_HV_BatSOC >=
            KeTHMR_Pct_RenblingSOCMin_NoBattCond) &&
            (THMR_ac_DW.UnitDelay_DSTATE_dpy));
    }

    /* End of Switch: '<S4352>/Switch1' */

    /* Update for UnitDelay: '<S4352>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_dpy = rtb_TmpSignalConversionAtVeBT_m;

    /* End of Outputs for SubSystem: '<S4347>/Hysteresis3' */

    /* Logic: '<S4347>/Logical15' incorporates:
     *  Constant: '<S4355>/Calib'
     *  Logic: '<S4347>/Logical12'
     *  Logic: '<S4347>/Logical13'
     *  Logic: '<S4347>/Logical14'
     *  RelationalOperator: '<S4347>/Comparison7'
     */
    VeTHMR_b_NoCabLoSOCPwrBdgt_NoBattCond = ((!VeTHMR_b_BattConditioning) &&
        ((!rtb_TmpSignalConversionAtVeBT_m) ||
         (VeTHMR_P_PwrBdgt_PwrLimitAvail_BD <=
          KeTHMR_P_ThrmlPrwAvail_LowNoBattCond)));

    /* Logic: '<S4347>/Logical16' incorporates:
     *  Logic: '<S4347>/Logical11'
     */
    VeTHMR_b_NoCab_LowSOC_PwrBdgt = (((VeTHMR_b_BattConditioning) &&
        (VeTHMR_b_NoCabLoSOCPwrBdgt_BattCond)) ||
        (VeTHMR_b_NoCabLoSOCPwrBdgt_NoBattCond));

    /* Logic: '<S4335>/Logical2' incorporates:
     *  Constant: '<S4345>/Calib'
     *  Constant: '<S4346>/Calib'
     *  Constant: '<S4353>/Calib'
     *  Constant: '<S4362>/Calib'
     *  Logic: '<S4335>/Logical4'
     *  Logic: '<S4335>/Logical6'
     *  Logic: '<S4347>/Logical1'
     *  Logic: '<S4347>/Logical2'
     *  Logic: '<S4347>/Logical3'
     *  Logic: '<S4347>/Logical4'
     *  RelationalOperator: '<S4335>/Comparison5'
     *  RelationalOperator: '<S4347>/Comparison1'
     */
    VeTHMR_b_CabReq_NotAllow_SOC_Wall = ((((rtb_Logical27 &&
        (VeTHMR_b_PlugdIn_Or_Chrg)) && (((!rtb_LogicalOperator1_fo) ||
        (VeTHMR_P_PwrBdgt_PwrLimitAvail_BD <= KeTHMR_P_ThrmlPrwAvail_Low)) ||
        ((VeTHMR_b_NoCab_LowSOC_PwrBdgt) && (KeTHMR_b_EnblSOCTh_BattCond_NoCab))))
        && (rtb_RelationalOperator7_p || (KeTHMR_b_Dsbl_CabPrecChk_CabNotAllwSOC)))
        && (rtb_TmpSignalConversionAtVeCT_c ||
            (KeTHMR_b_Dsbl_Dfrst_CabNotAllwSOC)));

    /* Outputs for Atomic SubSystem: '<S4334>/Hysteresis2' */
    /* Switch: '<S4339>/Switch1' incorporates:
     *  Constant: '<S4340>/Calib'
     *  RelationalOperator: '<S4339>/GreaterThan'
     */
    if (VeTHMR_Pct_HV_BatSOC > KeTHMR_Pct_DesablingSOC_N_Fuel_Min)
    {
        /* Switch: '<S4339>/Switch1' incorporates:
         *  Constant: '<S4339>/ConstantValue'
         */
        rtb_LogicalOperator1_fo = true;
    }
    else
    {
        /* Switch: '<S4339>/Switch1' incorporates:
         *  Constant: '<S4341>/Calib'
         *  RelationalOperator: '<S4339>/GreaterThan1'
         *  UnitDelay: '<S4339>/UnitDelay'
         */
        rtb_LogicalOperator1_fo = ((VeTHMR_Pct_HV_BatSOC >=
            KeTHMR_Pct_RenblingSOC_N_Fuel_Min) &&
            (THMR_ac_DW.UnitDelay_DSTATE_mq));
    }

    /* End of Switch: '<S4339>/Switch1' */

    /* Update for UnitDelay: '<S4339>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_mq = rtb_LogicalOperator1_fo;

    /* End of Outputs for SubSystem: '<S4334>/Hysteresis2' */

    /* Switch: '<S4334>/Switch' incorporates:
     *  Constant: '<S4338>/Constant'
     *  Constant: '<S4343>/Calib'
     *  DataTypeConversion: '<S450>/DataTypeConversion'
     *  RelationalOperator: '<S4334>/Comparison2'
     */
    if (KeTHMR_b_SOC_FuelUs_VehMod)
    {
        rtb_AND_fe = (((uint32)rtb_Switch1_d1t) != CeTHMR_e_TempAllowDefrost);
    }
    else
    {
        rtb_AND_fe = rtb_TmpSignalConversionAtVeCT_c;
    }

    /* End of Switch: '<S4334>/Switch' */

    /* Logic: '<S4334>/Logical2' incorporates:
     *  Constant: '<S4342>/Calib'
     *  Constant: '<S4344>/Calib'
     *  Logic: '<S4334>/Logical3'
     *  Logic: '<S4334>/Logical4'
     *  RelationalOperator: '<S4334>/Comparison6'
     */
    VeTHMR_b_CabReq_NotAllow_SOC_OutOfFuel = ((((!rtb_LogicalOperator1_fo) &&
        (VeTHMR_b_EngSysLowFuel_AD)) && (rtb_AND_fe ||
        (KeTHMR_b_SOC_Fuel_Nodefrst))) && (KeTHMR_b_SOC_FuelDisbld));

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* RelationalOperator: '<S4545>/Comparison9' incorporates:
     *  Constant: '<S4563>/Constant'
     *  RelationalOperator: '<S1472>/Comparison4'
     *  Switch: '<S3948>/Switch'
     */
    VeTHMR_b_ESSR_EngOff = (((uint32)VeTHMR_e_EngStartStopSt_AD) ==
                            CeESSR_e_EngOff);

    /* RelationalOperator: '<S4545>/Comparison4' incorporates:
     *  UnitDelay: '<S4545>/UnitDelay'
     */
    rtb_Logical27 = (VeTHMR_b_ESSR_EngOff == THMR_ac_DW.UnitDelay_DSTATE_or);

    /* Outputs for Atomic SubSystem: '<S4545>/EdgeRising1' */
    /* Logic: '<S4561>/AND' incorporates:
     *  Logic: '<S4561>/OR1'
     *  UnitDelay: '<S4561>/UnitDelay'
     */
    rtb_LogicalOperator1_fo = (rtb_Logical27 &&
        (!THMR_ac_DW.UnitDelay_DSTATE_lpj));

    /* Update for UnitDelay: '<S4561>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_lpj = rtb_Logical27;

    /* End of Outputs for SubSystem: '<S4545>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S4545>/CountDownResetEnabled' */
    /* Switch: '<S4560>/Switch1' incorporates:
     *  Constant: '<S4560>/ConstantValue'
     *  Logic: '<S4545>/Logical2'
     *  Logic: '<S4545>/Logical3'
     *  RelationalOperator: '<S4560>/GreaterThan'
     *  Switch: '<S4560>/Switch2'
     *  UnitDelay: '<S4560>/UnitDelay'
     */
    if (rtb_LogicalOperator1_fo || (!rtb_Logical27))
    {
        /* Switch: '<S4560>/Switch1' incorporates:
         *  Constant: '<S4545>/ConstantValue3'
         *  Constant: '<S4564>/Calib'
         *  Sum: '<S4545>/Sum1'
         */
        rtb_Switch_i3 = (uint16)((sint32)(((sint32)KeTHMR_Cnt_EngOff_LH_Waittime)
            - 1));
    }
    else if (((sint32)THMR_ac_DW.UnitDelay_DSTATE_kd5) > 0)
    {
        /* Switch: '<S4560>/Switch2' incorporates:
         *  Constant: '<S4560>/ConstantValue1'
         *  Sum: '<S4560>/Subtraction'
         *  Switch: '<S4560>/Switch1'
         *  UnitDelay: '<S4560>/UnitDelay'
         */
        rtb_Switch_i3 = (uint16)((sint32)(((sint32)
            THMR_ac_DW.UnitDelay_DSTATE_kd5) - 1));
    }
    else
    {
        /* Switch: '<S4560>/Switch1' incorporates:
         *  Switch: '<S4560>/Switch2'
         *  UnitDelay: '<S4560>/UnitDelay'
         */
        rtb_Switch_i3 = THMR_ac_DW.UnitDelay_DSTATE_kd5;
    }

    /* End of Switch: '<S4560>/Switch1' */

    /* Update for UnitDelay: '<S4560>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kd5 = rtb_Switch_i3;

    /* Logic: '<S4545>/Logical1' incorporates:
     *  Constant: '<S4560>/ConstantValue2'
     *  RelationalOperator: '<S4560>/GreaterThan1'
     */
    rtb_Logical27 = (((sint32)rtb_Switch_i3) <= 0);

    /* End of Outputs for SubSystem: '<S4545>/CountDownResetEnabled' */

    /* Outputs for Atomic SubSystem: '<S4545>/EdgeRising2' */
    /* Logic: '<S4562>/OR1' incorporates:
     *  UnitDelay: '<S4562>/UnitDelay'
     */
    rtb_LogicalOperator1_fo = !THMR_ac_DW.UnitDelay_DSTATE_cp4;

    /* Update for UnitDelay: '<S4562>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_cp4 = rtb_Logical27;

    /* Outputs for Enabled SubSystem: '<S4545>/Subsystem' incorporates:
     *  EnablePort: '<S4566>/Enable'
     */
    /* Logic: '<S4562>/AND' incorporates:
     *  Inport: '<S4566>/EngStartStop_Raw'
     */
    if (rtb_Logical27 && rtb_LogicalOperator1_fo)
    {
        THMR_ac_B.EngStartStop_Raw = VeTHMR_b_ESSR_EngOff;
    }

    /* End of Logic: '<S4562>/AND' */
    /* End of Outputs for SubSystem: '<S4545>/Subsystem' */
    /* End of Outputs for SubSystem: '<S4545>/EdgeRising2' */

    /* Switch: '<S4545>/Switch' incorporates:
     *  Constant: '<S4565>/Calib'
     */
    if (KeTHMR_b_EngOff_LH_Sel)
    {
        /* Switch: '<S4545>/Switch' */
        VeTHMR_b_isEngOff_LH = VeTHMR_b_ESSR_EngOff;
    }
    else
    {
        /* Switch: '<S4545>/Switch' */
        VeTHMR_b_isEngOff_LH = THMR_ac_B.EngStartStop_Raw;
    }

    /* End of Switch: '<S4545>/Switch' */

    /* Switch: '<S4549>/Switch1' incorporates:
     *  Constant: '<S4553>/Calib'
     *  Constant: '<S4554>/Calib'
     *  Constant: '<S4557>/Calib'
     *  Constant: '<S4559>/Calib'
     *  Logic: '<S4117>/Logical12'
     *  Logic: '<S4117>/Logical3'
     *  Logic: '<S4117>/Logical5'
     *  Logic: '<S4117>/Logical6'
     *  RelationalOperator: '<S4117>/Comparison7'
     *  RelationalOperator: '<S4117>/Comparison8'
     *  Switch: '<S4550>/Switch1'
     */
    if (((VeTHMR_b_isEngOff_LH) && rtb_TmpSignalConversionAtVeB_jd) &&
            (VeTHMR_P_PwrBdgt_PwrLimitAvail_BD <= KeTHMR_P_ThrmlPwrBdgt_Min))
    {
        /* Switch: '<S4549>/Switch1' incorporates:
         *  Constant: '<S4117>/ConstantValue1'
         */
        VeTHMR_b_ThrmlNotAllow_BattWallPwr_Limitd = true;
    }
    else if (((((VeTHMR_b_isEngOff_LH) && rtb_NotEqual_fo) &&
               (VeTHMR_P_PwrBdgt_PwrLimitAvail_BD <=
                KeTHMR_P_ThrmlBattPwrLimit_Min)) &&
              (rtb_TmpSignalConversionAtVeCT_c ||
               (KeTHMR_b_Dsbl_Dfrst_NoCabPwrBdgtKeyPreStart))) &&
             (rtb_RelationalOperator7_p ||
              (KeTHMR_b_Dsbl_CabPrecChk_NoCabPwrBdgt_PreStart)))
    {
        /* Switch: '<S4550>/Switch1' incorporates:
         *  Constant: '<S4117>/ConstantValue4'
         *  Switch: '<S4549>/Switch1'
         */
        VeTHMR_b_ThrmlNotAllow_BattWallPwr_Limitd = true;
    }
    else
    {
        /* Switch: '<S4549>/Switch1' incorporates:
         *  Constant: '<S4555>/Calib'
         *  Constant: '<S4556>/Calib'
         *  Constant: '<S4558>/Calib'
         *  Logic: '<S4117>/Logical10'
         *  Logic: '<S4117>/Logical4'
         *  Logic: '<S4117>/Logical8'
         *  RelationalOperator: '<S4117>/Comparison9'
         *  Switch: '<S4550>/Switch1'
         */
        VeTHMR_b_ThrmlNotAllow_BattWallPwr_Limitd = (((((VeTHMR_b_isEngOff_LH) &&
            rtb_TmpSignalConversionAtVeBT_f) &&
            (VeTHMR_P_PwrBdgt_PwrLimitAvail_BD <= KeTHMR_P_TotBatBdgt_Limit_Min))
            && (rtb_TmpSignalConversionAtVeCT_c ||
                (KeTHMR_b_Dsbl_Dfrst_NoCabPwrBdgtKeyCrnkStart))) &&
            (rtb_RelationalOperator7_p ||
             (KeTHMR_b_Dsbl_CabPrecChk_NoCabPwrBdgtPstStart)));
    }

    /* Logic: '<S4257>/Logical5' incorporates:
     *  Constant: '<S4299>/Constant'
     *  Constant: '<S4300>/Constant'
     *  Constant: '<S4301>/Calib'
     *  Constant: '<S4302>/Calib'
     *  Logic: '<S4257>/Logical3'
     *  Logic: '<S4257>/Logical4'
     *  RelationalOperator: '<S4257>/Comparison6'
     *  RelationalOperator: '<S4257>/Comparison7'
     *  SignalConversion generated from: '<S2>/VeTPCR_e_ThrmPerWup_State'
     */
    THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0 = (((KeTHMR_b_NrmlPerWp_StateEnb) &&
        (((uint32)rtb_TmpSignalConversionAtVeTP_d) ==
         CeTPCR_e_WpWaitBatCond_PerWpTimr)) || ((((uint32)
        rtb_TmpSignalConversionAtVeTP_d) ==
        CeTPCR_e_Wup_WaitBatCond_ThrmlPerWup_Timer) &&
        (KeTHMR_b_RS_PerWp_StateEnb)));

    /* Logic: '<S4227>/Logical1' incorporates:
     *  Constant: '<S4233>/Constant'
     *  Constant: '<S4237>/Calib'
     *  RelationalOperator: '<S4227>/Comparison4'
     *  Switch: '<S3954>/Switch'
     */
    VeTHMR_b_AlternatorMode_Actv = ((((uint32)VeTHMR_e_HybSysSt) ==
        CeHPMR_e_OPERATIONAL_ALTERNATOR) && (KeTHMR_b_AlternatorMode_Enbl));

    /* SignalConversion generated from: '<S4264>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Enbl_TrtlMd

    /* Logic: '<S4921>/Logical2' incorporates:
     *  Constant: '<S4269>/Constant'
     *  Constant: '<S4270>/Constant'
     *  Constant: '<S4271>/Calib'
     *  Logic: '<S4264>/Logical1'
     *  Logic: '<S4264>/Logical2'
     *  Logic: '<S4264>/Logical3'
     *  RelationalOperator: '<S4264>/Comparison1'
     *  RelationalOperator: '<S4264>/Comparison4'
     *  Switch: '<S3952>/Switch'
     */
    rtb_Logical2_iq = (((((uint32)VeTHMR_b_TurtleMd) == CeDMDR_e_Turtle_Mode3) ||
                        (((uint32)VeTHMR_b_TurtleMd) == CeDMDR_e_Turtle_Mode4)) &&
                       (rtb_TmpSignalConversionAtVeCT_c ||
                        (KeTHMR_b_Dsbl_Dfrst_TurtlMd)));

#else

    /* Logic: '<S4921>/Logical2' incorporates:
     *  Constant: '<S4264>/Constant'
     *  SignalConversion generated from: '<S4264>/VariantSource'
     */
    rtb_Logical2_iq = false;

#endif

    /* End of SignalConversion generated from: '<S4264>/VariantSource' */

    /* Switch: '<S4259>/Switch1' incorporates:
     *  Constant: '<S4259>/FALSEConstant1'
     *  Constant: '<S4265>/Calib'
     */
    if (KeTHMR_b_Dsbl_Dfrst_HAM)
    {
        rtb_AND_fe = false;
    }
    else
    {
        rtb_AND_fe = rtb_TmpSignalConversionAtVeCT_c;
    }

    /* Logic: '<S4253>/Logical1' incorporates:
     *  Constant: '<S4260>/Calib'
     *  Constant: '<S4266>/Calib'
     *  Constant: '<S4267>/Calib'
     *  Constant: '<S4268>/Calib'
     *  Logic: '<S4259>/Logical10'
     *  Logic: '<S4263>/Logical1'
     *  Logic: '<S4263>/Logical2'
     *  Logic: '<S4263>/Logical3'
     *  Logic: '<S4263>/Logical7'
     *  RelationalOperator: '<S4253>/Comparison4'
     *  Switch: '<S4259>/Switch'
     */
    VeTHMR_b_CabHeatReq_NotAllow_0 =
        ((((((((((((VeTHMR_b_CabReq_NotAllow_KeyOff_Acc) ||
                   (VeTHMR_b_CabReq_NotAllow_Key_RUN)) ||
                  (VeTHMR_b_CabReq_NotAllow_SOC_Wall)) ||
                 (VeTHMR_b_CabReq_NotAllow_SOC_OutOfFuel)) ||
                (KeTHMR_b_CabHeatReq_NotAllow_CabActv)) ||
               (VeTHMR_b_ThrmlNotAllow_BattWallPwr_Limitd)) ||
              rtb_TmpSignalConversionAtVeB_cu) ||
             (THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0)) ||
            (VeTHMR_b_AlternatorMode_Actv)) || (((VeTHMR_b_ThrmLoad_Shed) &&
             (rtb_TmpSignalConversionAtVeCT_c || (KeTHMR_b_Dsbl_Dfrst_LoadShed)))
            && ((!rtb_TmpSignalConversionAtVePDTR) ||
                (KeTHMR_b_Dsbl_OV_LoadShed_CabinCond)))) ||
          (((!KeTHMR_b_Dsbl_HAM_NoCab) && rtb_TmpSignalConversionAtVeBT_e) &&
           rtb_AND_fe)) || rtb_Logical2_iq);

    /* Switch: '<S4253>/Switch' incorporates:
     *  Constant: '<S4262>/Calib'
     */
    if (KeTHMR_b_CabReq_NotAllow_SelDial)
    {
        /* Switch: '<S4253>/Switch' incorporates:
         *  Constant: '<S4261>/Calib'
         */
        THMR_ac_B.VeTHMR_b_CabReq_NotAllow_BS = KeTHMR_b_CabReq_NotAllow_Dial;
    }
    else
    {
        /* Switch: '<S4253>/Switch' */
        THMR_ac_B.VeTHMR_b_CabReq_NotAllow_BS = VeTHMR_b_CabHeatReq_NotAllow_0;
    }

    /* End of Switch: '<S4253>/Switch' */

    /* Logic: '<S4322>/Logical1' incorporates:
     *  Constant: '<S4324>/Constant'
     *  Constant: '<S4325>/Constant'
     *  Constant: '<S4326>/Constant'
     *  Constant: '<S4327>/Constant'
     *  Constant: '<S4328>/Calib'
     *  Constant: '<S4329>/Calib'
     *  Constant: '<S4330>/Calib'
     *  Constant: '<S4331>/Calib'
     *  Logic: '<S4322>/Logical2'
     *  Logic: '<S4322>/Logical3'
     *  Logic: '<S4322>/Logical4'
     *  Logic: '<S4322>/Logical5'
     *  RelationalOperator: '<S4322>/Comparison1'
     *  RelationalOperator: '<S4322>/Comparison2'
     *  RelationalOperator: '<S4322>/Comparison3'
     *  RelationalOperator: '<S4322>/Comparison4'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     */
    rtb_Logical2_iq = ((((((KeTHMR_b_CabAlwd_OVst2_Enbl) &&
                           (CePDTR_e_Dischrg_CabReqPrsnt == ((uint32)
        rtb_TmpSignalConversionAtVePD_l))) || ((((uint32)
        rtb_TmpSignalConversionAtVePD_l) == CePDTR_e_Dischrg_AmbTempLow) &&
                           (KeTHMR_b_CabAlwd_OVst1_Enbl))) || ((((uint32)
                            rtb_TmpSignalConversionAtVePD_l) ==
                           CePDTR_e_Dischrg_BatAndCab_Cndtn) &&
                          (KeTHMR_b_CabAlwd_OVst1_Enbl1))) || ((((uint32)
                           rtb_TmpSignalConversionAtVePD_l) ==
                          CePDTR_e_Dischrg_CabReqInOV) &&
                         (KeTHMR_b_CabAlwd_OVst1_Enbl2))) ||
                       rtb_TmpSignalConversionAtVePDTR);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Truth Table: '<S4251>/Cab_Allowed' incorporates:
     *  Constant: '<S4316>/Calib'
     *  Constant: '<S4319>/Calib'
     *  Constant: '<S4320>/Calib'
     *  Logic: '<S4251>/Logical1'
     *  RelationalOperator: '<S2869>/RelationalOperator'
     *  Switch: '<S3945>/Switch'
     */
    /* Truth Table Function 'THMR_FUNC_RU_MedTEH/Subsystem__Subsystem1/SelectMode/CabCond_Enablers/Check_Cab_Allowed/Cab_Allowed': '<S4313>:1' */
    /*  Key Status Off */
    /* Condition '#1': '<S4313>:1:17' */
    rtb_Logical27 = (((uint32)VeTHMR_e_SSDR_KeySts) == CeSSDR_e_KeyOff);

    /*  Key Status Acc */
    if ((((uint32)VeTHMR_e_SSDR_KeySts) == CeSSDR_e_KeyAccy) || (((uint32)
            VeTHMR_e_SSDR_KeySts) == CeSSDR_e_KeyPostRunAccy))
    {
        /* Condition '#2': '<S4313>:1:21' */
        rtb_TmpSignalConversionAtVeB_jd = true;
    }
    else
    {
        rtb_TmpSignalConversionAtVeB_jd = false;
    }

    /*  Key Status Prestate */
    /* Condition '#3': '<S4313>:1:25' */
    rtb_TmpSignalConversionAtVeBT_f = (((uint32)VeTHMR_e_SSDR_KeySts) ==
        CeSSDR_e_KeyRun);

    /*  Key Status Poststate */
    if ((((uint32)VeTHMR_e_SSDR_KeySts) == CeSSDR_e_KeyCrank) || (((uint32)
            VeTHMR_e_SSDR_KeySts) == CeSSDR_e_KeyPostCrnk))
    {
        /* Condition '#4': '<S4313>:1:29' */
        rtb_LogicalOperator1_fo = true;
    }
    else
    {
        rtb_LogicalOperator1_fo = false;
    }

    /*  Allow cabin condiioning in key off */
    /*  Over Voltage Battery Discharge State */
    /*  Defrost */
    /* Condition '#7': '<S4313>:1:41' */
    rtb_NotEqual_fo = ((VeTHMR_b_Defrost) && (KeTHMR_b_CabAllw_Defrost));

    /*  Pre-Cond Cabin */
    /* Condition '#8': '<S4313>:1:45' */
    rtb_TmpSignalConversionAtVeBT_m = (rtb_Switch_hql && (KeTHMR_b_CabAllw_RS));

    /*  Vehicle Plugged In */
    /*  Driver Not Present */
    /* Condition '#10': '<S4313>:1:53' */
    rtb_RelationalOperator7_p = ((!VeTHMR_b_AmznDrvDprt) &&
        (KeTHMR_b_AmznDrvDprt_Enbl));
    rtb_AND_fe = !rtb_TmpSignalConversionAtVeBT_f;
    rtb_TmpSignalConversionAtVePD_i = !rtb_LogicalOperator1_fo;
    rtb_AND_de = !rtb_TmpSignalConversionAtVeB_jd;
    rtb_LogicalOperator_aa = (((rtb_Logical27 && rtb_AND_de) && rtb_AND_fe) &&
        rtb_TmpSignalConversionAtVePD_i);
    rtb_UnitDelay3_ff = (rtb_LogicalOperator_aa &&
                         rtb_TmpSignalConversionAtVeTP_c);
    rtb_TmpSignalConversionAtVeTR_k = !rtb_RelationalOperator7_p;
    if (rtb_UnitDelay3_ff && rtb_TmpSignalConversionAtVeTR_k)
    {
        /* Gain: '<S4321>/Gain' */
        /* Decision 'D1': '<S4313>:1:55' */
        /* Condition '#5': '<S4313>:1:33' */
        /*  Action one */
        /* Action '1': '<S4313>:1:109' */
        VeTHMR_K_CabAllowed_Index = THMR_ac_One;
    }
    else if (rtb_UnitDelay3_ff && rtb_RelationalOperator7_p)
    {
        /* Gain: '<S4321>/Gain' */
        /* Decision 'D2': '<S4313>:1:57' */
        /* Condition '#5': '<S4313>:1:33' */
        /*  Action two */
        /* Action '2': '<S4313>:1:115' */
        VeTHMR_K_CabAllowed_Index = THMR_ac_Two_h;
    }
    else
    {
        rtb_UnitDelay3_ff = !rtb_Logical2_iq;
        rtb_LogicalOperator_aa = ((rtb_LogicalOperator_aa &&
            rtb_LogicalOperator_lw) && rtb_UnitDelay3_ff);
        rtb_VariantMerge_For_Variant__j = !rtb_NotEqual_fo;
        rtb_OR1_k3 = !rtb_TmpSignalConversionAtVeBT_m;
        rtb_Switch1_az = ((rtb_LogicalOperator_aa &&
                           rtb_VariantMerge_For_Variant__j) && rtb_OR1_k3);
        if (rtb_Switch1_az && rtb_TmpSignalConversionAtVeTR_i)
        {
            /* Gain: '<S4321>/Gain' */
            /* Decision 'D3': '<S4313>:1:59' */
            /*  Action three */
            /* Action '3': '<S4313>:1:121' */
            VeTHMR_K_CabAllowed_Index = THMR_ac_Three_o;
        }
        else if (rtb_LogicalOperator_aa && rtb_NotEqual_fo)
        {
            /* Gain: '<S4321>/Gain' */
            /* Decision 'D4': '<S4313>:1:61' */
            /*  Action four */
            /* Action '4': '<S4313>:1:127' */
            VeTHMR_K_CabAllowed_Index = THMR_ac_Four_m;
        }
        else if (rtb_LogicalOperator_aa && rtb_TmpSignalConversionAtVeBT_m)
        {
            /* Gain: '<S4321>/Gain' */
            /* Decision 'D5': '<S4313>:1:63' */
            /*  Action five */
            /* Action '5': '<S4313>:1:133' */
            VeTHMR_K_CabAllowed_Index = THMR_ac_Five_f;
        }
        else if (rtb_Switch1_az && (VeTHMR_b_PlugdIn_Or_Chrg))
        {
            /* Gain: '<S4321>/Gain' */
            /* Decision 'D6': '<S4313>:1:65' */
            /* Condition '#9': '<S4313>:1:49' */
            /*  Action six */
            /* Action '6': '<S4313>:1:139' */
            VeTHMR_K_CabAllowed_Index = THMR_ac_Six_p;
        }
        else
        {
            rtb_LogicalOperator_aa = !rtb_Logical27;
            rtb_Switch1_az = (((((rtb_LogicalOperator_aa &&
                                  rtb_TmpSignalConversionAtVeB_jd) && rtb_AND_fe)
                                && rtb_TmpSignalConversionAtVePD_i) &&
                               rtb_LogicalOperator_lw) && rtb_UnitDelay3_ff);
            rtb_Logical27 = ((rtb_Switch1_az && rtb_VariantMerge_For_Variant__j)
                             && rtb_OR1_k3);
            if (rtb_Logical27 && rtb_TmpSignalConversionAtVeTR_i)
            {
                /* Gain: '<S4321>/Gain' */
                /* Decision 'D7': '<S4313>:1:67' */
                /*  Action seven */
                /* Action '7': '<S4313>:1:145' */
                VeTHMR_K_CabAllowed_Index = THMR_ac_Seven_c;
            }
            else if (rtb_Switch1_az && rtb_NotEqual_fo)
            {
                /* Gain: '<S4321>/Gain' */
                /* Decision 'D8': '<S4313>:1:69' */
                /*  Action eight */
                /* Action '8': '<S4313>:1:151' */
                VeTHMR_K_CabAllowed_Index = THMR_ac_Eight_o;
            }
            else if (rtb_Switch1_az && rtb_TmpSignalConversionAtVeBT_m)
            {
                /* Gain: '<S4321>/Gain' */
                /* Decision 'D9': '<S4313>:1:71' */
                /*  Action nine */
                /* Action '9': '<S4313>:1:157' */
                VeTHMR_K_CabAllowed_Index = THMR_ac_Nine;
            }
            else if (rtb_Logical27 && (VeTHMR_b_PlugdIn_Or_Chrg))
            {
                /* Gain: '<S4321>/Gain' */
                /* Decision 'D10': '<S4313>:1:73' */
                /* Condition '#9': '<S4313>:1:49' */
                /*  Action ten */
                /* Action '10': '<S4313>:1:163' */
                VeTHMR_K_CabAllowed_Index = THMR_ac_Ten;
            }
            else
            {
                rtb_AND_de = (rtb_LogicalOperator_aa && rtb_AND_de);
                rtb_TmpSignalConversionAtVePD_i = (((rtb_AND_de &&
                    rtb_TmpSignalConversionAtVeBT_f) &&
                    rtb_TmpSignalConversionAtVePD_i) && rtb_LogicalOperator_lw);
                if (rtb_TmpSignalConversionAtVePD_i && rtb_Logical2_iq)
                {
                    /* Gain: '<S4321>/Gain' */
                    /* Decision 'D11': '<S4313>:1:75' */
                    /* Condition '#6': '<S4313>:1:37' */
                    /*  Action eleven */
                    /* Action '11': '<S4313>:1:169' */
                    VeTHMR_K_CabAllowed_Index = THMR_ac_Eleven;
                }
                else
                {
                    rtb_TmpSignalConversionAtVePD_i =
                        (rtb_TmpSignalConversionAtVePD_i && rtb_UnitDelay3_ff);
                    rtb_LogicalOperator_aa = (rtb_TmpSignalConversionAtVePD_i &&
                        rtb_NotEqual_fo);
                    if (rtb_LogicalOperator_aa && (VeTHMR_b_PlugdIn_Or_Chrg))
                    {
                        /* Gain: '<S4321>/Gain' */
                        /* Decision 'D12': '<S4313>:1:77' */
                        /* Condition '#9': '<S4313>:1:49' */
                        /*  Action twelve */
                        /* Action '12': '<S4313>:1:175' */
                        VeTHMR_K_CabAllowed_Index = THMR_ac_Twelve;
                    }
                    else if (rtb_LogicalOperator_aa &&
                             rtb_TmpSignalConversionAtVeTR_i)
                    {
                        /* Gain: '<S4321>/Gain' */
                        /* Decision 'D13': '<S4313>:1:79' */
                        /*  Action thirteen */
                        /* Action '13': '<S4313>:1:181' */
                        VeTHMR_K_CabAllowed_Index = THMR_ac_Thirteen;
                    }
                    else if (rtb_TmpSignalConversionAtVePD_i &&
                             rtb_TmpSignalConversionAtVeBT_m)
                    {
                        /* Gain: '<S4321>/Gain' */
                        /* Decision 'D14': '<S4313>:1:81' */
                        /*  Action fourteen */
                        /* Action '14': '<S4313>:1:187' */
                        VeTHMR_K_CabAllowed_Index = THMR_ac_Fourteen;
                    }
                    else
                    {
                        rtb_TmpSignalConversionAtVePD_i =
                            ((rtb_TmpSignalConversionAtVePD_i &&
                              rtb_VariantMerge_For_Variant__j) && rtb_OR1_k3);
                        if (rtb_TmpSignalConversionAtVePD_i &&
                                rtb_TmpSignalConversionAtVeTR_i)
                        {
                            /* Gain: '<S4321>/Gain' */
                            /* Decision 'D15': '<S4313>:1:83' */
                            /*  Action fifteen */
                            /* Action '15': '<S4313>:1:193' */
                            VeTHMR_K_CabAllowed_Index = THMR_ac_Fifteen;
                        }
                        else
                        {
                            rtb_TmpSignalConversionAtVePD_i =
                                (rtb_TmpSignalConversionAtVePD_i &&
                                 (VeTHMR_b_PlugdIn_Or_Chrg));
                            if (rtb_TmpSignalConversionAtVePD_i &&
                                    rtb_TmpSignalConversionAtVeTR_k)
                            {
                                /* Gain: '<S4321>/Gain' */
                                /* Decision 'D16': '<S4313>:1:85' */
                                /* Condition '#9': '<S4313>:1:49' */
                                /*  Action sixteen */
                                /* Action '16': '<S4313>:1:199' */
                                VeTHMR_K_CabAllowed_Index = THMR_ac_Sixteen;
                            }
                            else if (rtb_TmpSignalConversionAtVePD_i &&
                                     rtb_RelationalOperator7_p)
                            {
                                /* Gain: '<S4321>/Gain' */
                                /* Decision 'D17': '<S4313>:1:87' */
                                /* Condition '#9': '<S4313>:1:49' */
                                /*  Action seventeen */
                                /* Action '17': '<S4313>:1:205' */
                                VeTHMR_K_CabAllowed_Index = THMR_ac_Seventeen;
                            }
                            else
                            {
                                rtb_AND_fe = (((rtb_AND_de && rtb_AND_fe) &&
                                               rtb_LogicalOperator1_fo) &&
                                              rtb_LogicalOperator_lw);
                                rtb_TmpSignalConversionAtVePD_i = (rtb_AND_fe &&
                                    rtb_UnitDelay3_ff);
                                rtb_AND_de = ((rtb_TmpSignalConversionAtVePD_i &&
                                               rtb_VariantMerge_For_Variant__j) &&
                                              rtb_OR1_k3);
                                if ((rtb_AND_de &&
                                        rtb_TmpSignalConversionAtVeTR_i) &&
                                        rtb_TmpSignalConversionAtVeTR_k)
                                {
                                    /* Gain: '<S4321>/Gain' */
                                    /* Decision 'D18': '<S4313>:1:89' */
                                    /*  Action eighteen */
                                    /* Action '18': '<S4313>:1:211' */
                                    VeTHMR_K_CabAllowed_Index = THMR_ac_Eighteen;
                                }
                                else if (rtb_AND_fe && rtb_Logical2_iq)
                                {
                                    /* Gain: '<S4321>/Gain' */
                                    /* Decision 'D19': '<S4313>:1:91' */
                                    /* Condition '#6': '<S4313>:1:37' */
                                    /*  Action nineteen */
                                    /* Action '19': '<S4313>:1:217' */
                                    VeTHMR_K_CabAllowed_Index = THMR_ac_Nineteen;
                                }
                                else if (rtb_TmpSignalConversionAtVePD_i &&
                                         rtb_NotEqual_fo)
                                {
                                    /* Gain: '<S4321>/Gain' */
                                    /* Decision 'D20': '<S4313>:1:93' */
                                    /*  Action twenty */
                                    /* Action '20': '<S4313>:1:223' */
                                    VeTHMR_K_CabAllowed_Index = THMR_ac_Twenty;
                                }
                                else if (rtb_TmpSignalConversionAtVePD_i &&
                                         rtb_TmpSignalConversionAtVeBT_m)
                                {
                                    /* Gain: '<S4321>/Gain' */
                                    /* Decision 'D21': '<S4313>:1:95' */
                                    /*  Action twenty-one */
                                    /* Action '21': '<S4313>:1:229' */
                                    VeTHMR_K_CabAllowed_Index =
                                        THMR_ac_TwentyOne;
                                }
                                else if (rtb_AND_de && rtb_RelationalOperator7_p)
                                {
                                    /* Gain: '<S4321>/Gain' */
                                    /* Decision 'D22': '<S4313>:1:97' */
                                    /*  Action twenty-two */
                                    /* Action '22': '<S4313>:1:235' */
                                    VeTHMR_K_CabAllowed_Index =
                                        THMR_ac_TwentyTwo;
                                }
                                else if (rtb_AND_de &&
                                         rtb_TmpSignalConversionAtVeTR_k)
                                {
                                    /* Gain: '<S4321>/Gain' */
                                    /* Decision 'D23': '<S4313>:1:99' */
                                    /*  Action twenty-three */
                                    /* Action '23': '<S4313>:1:241' */
                                    VeTHMR_K_CabAllowed_Index =
                                        THMR_ac_TwentyThree;
                                }
                                else
                                {
                                    /* Gain: '<S4321>/Gain' */
                                    /* Decision 'D24': '<S4313>:1:101' */
                                    /*  Default */
                                    /*  Action twenty-four */
                                    /* Action '24': '<S4313>:1:247' */
                                    VeTHMR_K_CabAllowed_Index =
                                        THMR_ac_TwentyFour;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /* Selector: '<S4251>/Selector' incorporates:
     *  Constant: '<S4315>/Calib'
     */
    VeTHMR_b_CabAllowed_B4D = KaTHMR_b_CabAllowedArray[VeTHMR_K_CabAllowed_Index
        - 1];

    /* SignalConversion generated from: '<S4323>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_DsblPSAChk_BattAllwd_MHEV

    /* VariantMerge generated from: '<S4323>/VariantSource' incorporates:
     *  Constant: '<S4323>/Constant'
     */
    rtb_VariantMerge_For_Variant__b = true;

#else

    /* VariantMerge generated from: '<S4323>/VariantSource' incorporates:
     *  SignalConversion generated from: '<S4323>/VariantSource'
     */
    rtb_VariantMerge_For_Variant__b = rtb_TmpSignalConversionAtPropSy;

#endif

    /* End of SignalConversion generated from: '<S4323>/VariantSource' */

    /* SignalConversion generated from: '<S4323>/VariantSource1' incorporates:
     *  RelationalOperator: '<S4323>/Comparison9'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EngOnChk_BattAllwd_MHEV

    /* VariantMerge generated from: '<S4323>/VariantSource1' incorporates:
     *  Constant: '<S4323>/Constant1'
     */
    rtb_VariantMerge_For_Variant__m = true;

#else

    /* Outputs for Function Call SubSystem: '<S2>/HTCL' */
    /* VariantMerge generated from: '<S4323>/VariantSource1' incorporates:
     *  Constant: '<S4332>/Constant'
     *  RelationalOperator: '<S1472>/Comparison4'
     *  RelationalOperator: '<S4323>/Comparison9'
     *  Switch: '<S3948>/Switch'
     */
    rtb_VariantMerge_For_Variant__m = (((uint32)VeTHMR_e_EngStartStopSt_AD) ==
        CeESSR_e_EngRunning);

    /* End of Outputs for SubSystem: '<S2>/HTCL' */
#endif

    /* End of SignalConversion generated from: '<S4323>/VariantSource1' */

    /* Switch: '<S4251>/Switch' incorporates:
     *  Constant: '<S4318>/Calib'
     */
    if (KeTHMR_b_CabAllowed_SD)
    {
        /* Switch: '<S4251>/Switch' incorporates:
         *  Constant: '<S4317>/Calib'
         */
        VeTHMR_b_CabAllowed_BS = KeTHMR_b_CabAllowed_D;
    }
    else
    {
        /* Switch: '<S4251>/Switch' incorporates:
         *  Logic: '<S4251>/Logical5'
         *  Logic: '<S4323>/Logical5'
         */
        VeTHMR_b_CabAllowed_BS = ((VeTHMR_b_CabAllowed_B4D) &&
            (rtb_VariantMerge_For_Variant__b && rtb_VariantMerge_For_Variant__m));
    }

    /* End of Switch: '<S4251>/Switch' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Gain: '<S4081>/Gain' incorporates:
     *  Inport: '<Root>/VeACCR_b_OilMigOpnVlv'
     */
    (void)Rte_Read_VeACCR_b_OilMigOpnVlv_Value(&Gain_nh);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Switch: '<S4314>/Switch1' incorporates:
     *  Logic: '<S4251>/Logical2'
     */
    THMR_ac_B.Switch1_az = ((rtb_TmpSignalConversionAtVePMTR ||
        rtb_TmpSignalConversionAtVeP_el) && (VeTHMR_b_CabAllowed_BS));

    /* Logic: '<S4569>/LogicalOperator1' incorporates:
     *  RelationalOperator: '<S4091>/Comparison7'
     */
    rtb_TmpSignalConversionAtVeBT_f = !THMR_ac_B.VeTHMR_b_CabReq_NotAllow_BS;

    /* Logic: '<S4091>/Logical2' incorporates:
     *  RelationalOperator: '<S4091>/Comparison8'
     */
    VeTHMR_b_CabAllowCond_0 = (rtb_TmpSignalConversionAtVeBT_f &&
        (THMR_ac_B.Switch1_az));

    /* Logic: '<S4091>/Logical1' incorporates:
     *  Constant: '<S5297>/Calib'
     */
    VeTHMR_b_CabAllowCond = ((KeTHMR_b_CabAllowCond_Dsbl) ||
        (VeTHMR_b_CabAllowCond_0));

    /* Logic: '<S83>/Logical7' incorporates:
     *  Constant: '<S4051>/Calib'
     *  Logic: '<S83>/Logical1'
     *  Logic: '<S83>/Logical3'
     */
    rtb_RelationalOperator7_p = ((!VeTHMR_b_AC_CompReq) ||
        ((!VeTHMR_b_CabAllowCond) && (!KeTHMR_b_OvrrdCabAllw4FtEvpMngmnt)));

    /* Gain: '<S4058>/Gain' */
    VeTHMR_P_ChrgThermBdgt_AfterDial = VeTHMR_P_AvalPwrForThmr;

    /* Outputs for Atomic SubSystem: '<S4735>/Hysteresis1' */
    /* Switch: '<S4791>/Switch1' incorporates:
     *  Constant: '<S4795>/Calib'
     *  RelationalOperator: '<S4791>/GreaterThan'
     */
    if (VeTHMR_T_APM_Temp1 > KeTHMR_T_APMTmpTh_EmrgncyCoolRSP)
    {
        /* Switch: '<S4791>/Switch1' incorporates:
         *  Constant: '<S4791>/ConstantValue'
         */
        rtb_Logical2_iq = true;
    }
    else
    {
        /* Switch: '<S4791>/Switch1' incorporates:
         *  Constant: '<S4794>/Calib'
         *  RelationalOperator: '<S4791>/GreaterThan1'
         *  UnitDelay: '<S4791>/UnitDelay'
         */
        rtb_Logical2_iq = ((VeTHMR_T_APM_Temp1 >=
                            KeTHMR_T_APMTmpTh_EmrgncyCoolLSP) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_bxc));
    }

    /* End of Switch: '<S4791>/Switch1' */

    /* Update for UnitDelay: '<S4791>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_bxc = rtb_Logical2_iq;

    /* End of Outputs for SubSystem: '<S4735>/Hysteresis1' */

    /* Outputs for Atomic SubSystem: '<S4735>/Hysteresis2' */
    /* Switch: '<S4792>/Switch1' incorporates:
     *  Constant: '<S4795>/Calib'
     *  RelationalOperator: '<S4792>/GreaterThan'
     */
    if (VeTHMR_T_APM_Temp2 > KeTHMR_T_APMTmpTh_EmrgncyCoolRSP)
    {
        /* Switch: '<S4792>/Switch1' incorporates:
         *  Constant: '<S4792>/ConstantValue'
         */
        rtb_VariantMerge_For_Variant__b = true;
    }
    else
    {
        /* Switch: '<S4792>/Switch1' incorporates:
         *  Constant: '<S4794>/Calib'
         *  RelationalOperator: '<S4792>/GreaterThan1'
         *  UnitDelay: '<S4792>/UnitDelay'
         */
        rtb_VariantMerge_For_Variant__b = ((VeTHMR_T_APM_Temp2 >=
            KeTHMR_T_APMTmpTh_EmrgncyCoolLSP) &&
            (THMR_ac_DW.UnitDelay_DSTATE_h0u));
    }

    /* End of Switch: '<S4792>/Switch1' */

    /* Update for UnitDelay: '<S4792>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_h0u = rtb_VariantMerge_For_Variant__b;

    /* End of Outputs for SubSystem: '<S4735>/Hysteresis2' */

    /* Outputs for Atomic SubSystem: '<S4735>/Hysteresis3' */
    /* Switch: '<S4793>/Switch1' incorporates:
     *  Constant: '<S4797>/Calib'
     *  RelationalOperator: '<S4793>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeTRIR > KeTHMR_T_BTOSTh_EmrgncyCoolRSP)
    {
        /* Switch: '<S4793>/Switch1' incorporates:
         *  Constant: '<S4793>/ConstantValue'
         */
        rtb_VariantMerge_For_Variant__m = true;
    }
    else
    {
        /* Switch: '<S4793>/Switch1' incorporates:
         *  Constant: '<S4796>/Calib'
         *  RelationalOperator: '<S4793>/GreaterThan1'
         *  UnitDelay: '<S4793>/UnitDelay'
         */
        rtb_VariantMerge_For_Variant__m = ((rtb_TmpSignalConversionAtVeTRIR >=
            KeTHMR_T_BTOSTh_EmrgncyCoolLSP) && (THMR_ac_DW.UnitDelay_DSTATE_k1));
    }

    /* End of Switch: '<S4793>/Switch1' */

    /* Update for UnitDelay: '<S4793>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_k1 = rtb_VariantMerge_For_Variant__m;

    /* End of Outputs for SubSystem: '<S4735>/Hysteresis3' */

    /* Logic: '<S4735>/Logical6' */
    VeTHMR_b_EmergencyCool = ((rtb_Logical2_iq ||
        rtb_VariantMerge_For_Variant__b) || rtb_VariantMerge_For_Variant__m);

    /* Logic: '<S4748>/Logical Operator' incorporates:
     *  Constant: '<S4748>/Constant1'
     *  Constant: '<S4748>/Constant2'
     *  RelationalOperator: '<S4748>/Relational Operator1'
     *  RelationalOperator: '<S4748>/Relational Operator2'
     */
    VeTHMR_b_NoPresSnsrLoFlt = ((rtb_TmpSignalConversionAtVePD_0 != 0U) &&
        (rtb_TmpSignalConversionAtVePD_1 == 0U));

    /* Logic: '<S4753>/Logical Operator' incorporates:
     *  Constant: '<S4753>/Constant1'
     *  Constant: '<S4753>/Constant2'
     *  DataStoreRead: '<S4753>/StatusByte_LostCommEAC'
     *  RelationalOperator: '<S4753>/Relational Operator1'
     *  RelationalOperator: '<S4753>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S4753>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4753>/Bitwise Operator2'
     */
    VeTHMR_b_NoLOCEAC = (((((uint32)THMR_ac_DW.StatusByte_LostCommEAC) & 1U) !=
                          0U) && ((((uint32)THMR_ac_DW.StatusByte_LostCommEAC) &
                           64U) == 0U));

    /* Logic: '<S4751>/LogicalOperator' incorporates:
     *  Constant: '<S4751>/Constant1'
     *  Constant: '<S4751>/Constant2'
     *  DataStoreRead: '<S4751>/StatusByte_CoolCtrlVlv1CktHi'
     *  RelationalOperator: '<S4751>/RelationalOperator1'
     *  RelationalOperator: '<S4751>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S4751>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S4751>/BitwiseOperator2'
     */
    VeTHMR_b_ChillVlvCktHi = (((((sint32)THMR_ac_DW.StatusByte_CoolCtrlVlv1CktHi)
        & 1) > 0) && ((((uint32)THMR_ac_DW.StatusByte_CoolCtrlVlv1CktHi) & 64U) ==
                      0U));

    /* RelationalOperator: '<S4750>/RelationalOperator' incorporates:
     *  Constant: '<S4750>/Constant'
     *  DataStoreRead: '<S4750>/StatusByte_BattCool'
     *  S-Function (sfix_bitop): '<S4750>/BitwiseOperator7'
     */
    VeTHMR_b_NoBattCoolPerfFlt = ((((sint32)THMR_ac_DW.StatusByte_BattCool) & 1)
        > 0);

    /* Logic: '<S4747>/Logical Operator' incorporates:
     *  Constant: '<S4747>/Constant1'
     *  Constant: '<S4747>/Constant2'
     *  RelationalOperator: '<S4747>/Relational Operator1'
     *  RelationalOperator: '<S4747>/Relational Operator2'
     */
    VeTHMR_b_PresSnsrHiFlt = ((rtb_TmpSignalConversionAtVePD_2 != 0U) &&
        (rtb_TmpSignalConversionAtVePD_3 == 0U));

    /* Logic: '<S4749>/Logical Operator' incorporates:
     *  Constant: '<S4749>/Constant1'
     *  Constant: '<S4749>/Constant2'
     *  RelationalOperator: '<S4749>/Relational Operator1'
     *  RelationalOperator: '<S4749>/Relational Operator2'
     */
    VeTHMR_b_NoPresSnsrPerfFlt = ((rtb_TmpSignalConversionAtVePD_4 != 0U) &&
        (rtb_TmpSignalConversionAtVePD_5 == 0U));

    /* Logic: '<S4752>/Logical Operator' incorporates:
     *  Constant: '<S4752>/Constant1'
     *  Constant: '<S4752>/Constant2'
     *  DataStoreRead: '<S4752>/StatusByte_EACPerf'
     *  RelationalOperator: '<S4752>/Relational Operator1'
     *  RelationalOperator: '<S4752>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S4752>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4752>/Bitwise Operator2'
     */
    VeTHMR_b_NoEACPerfFlt = (((((uint32)THMR_ac_DW.StatusByte_EACPerf) & 1U) !=
        0U) && ((((uint32)THMR_ac_DW.StatusByte_EACPerf) & 64U) == 0U));

    /* Logic: '<S4738>/Logical9' incorporates:
     *  Constant: '<S4755>/Calib'
     *  Constant: '<S4756>/Calib'
     *  Constant: '<S4757>/Calib'
     *  Constant: '<S4758>/Calib'
     *  Constant: '<S4759>/Calib'
     *  Constant: '<S4760>/Calib'
     *  Constant: '<S4761>/Calib'
     *  Logic: '<S4738>/Logical10'
     *  Logic: '<S4738>/Logical11'
     *  Logic: '<S4738>/Logical12'
     *  Logic: '<S4738>/Logical13'
     *  Logic: '<S4738>/Logical20'
     *  Logic: '<S4738>/Logical22'
     *  Logic: '<S4738>/Logical7'
     */
    VeTHMR_b_CompressorFlts = ((((((((VeTHMR_b_NoPresSnsrLoFlt) &&
        (KeTHMR_b_Enbl_PresSnsrCktLo)) || ((VeTHMR_b_NoLOCEAC) &&
        (KeTHMR_b_Enbl_LOCEACFlt))) || ((VeTHMR_b_ChillVlvCktHi) &&
        (KeTHMR_b_Enbl_ChilVlvCktHi))) || ((VeTHMR_b_NoBattCoolPerfFlt) &&
        (KeTHMR_b_Enbl_CoolPerfFlt))) || ((VeTHMR_b_PresSnsrHiFlt) &&
        (KeTHMR_b_Enbl_PresSnsrCktHi))) || ((VeTHMR_b_NoPresSnsrPerfFlt) &&
        (KeTHMR_b_Enbl_PresSnsrCktPerf))) || ((VeTHMR_b_NoEACPerfFlt) &&
        (KeTHMR_b_Enbl_EACPerfFlt)));

    /* Logic: '<S4921>/Logical2' incorporates:
     *  Constant: '<S4754>/Calib'
     *  Logic: '<S4738>/Logical1'
     *  Logic: '<S4738>/Logical2'
     */
    rtb_Logical2_iq = ((!VeTHMR_b_CompressorFlts) ||
                       (KeTHMR_b_Dsbl_ActvCoolFltsChk));

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outputs for Atomic SubSystem: '<S4108>/SignalLatchOnWithReset1' */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Logic: '<S4437>/OR1' incorporates:
     *  Constant: '<S4433>/Constant'
     *  Constant: '<S4434>/Constant'
     *  Constant: '<S4435>/Constant'
     *  Constant: '<S4436>/Constant'
     *  Logic: '<S4108>/Logical1'
     *  Logic: '<S4108>/Logical2'
     *  Logic: '<S4437>/NOT'
     *  Logic: '<S4437>/OR'
     *  RelationalOperator: '<S2869>/RelationalOperator'
     *  RelationalOperator: '<S4108>/Comparison1'
     *  RelationalOperator: '<S4108>/Comparison2'
     *  RelationalOperator: '<S4108>/Comparison3'
     *  RelationalOperator: '<S4108>/Comparison4'
     *  Switch: '<S3945>/Switch'
     *  UnitDelay: '<S4108>/UnitDelay'
     *  UnitDelay: '<S4437>/UnitDelay'
     */
    THMR_ac_B.OR1 = ((VeTHMR_b_HighVoltageRapidShtdwnCmnd_AD) ||
                     (((((CeSSDR_e_KeyAccy != ((uint32)VeTHMR_e_SSDR_KeySts)) &&
                         (CeSSDR_e_KeyRun != ((uint32)VeTHMR_e_SSDR_KeySts))) &&
                        (CeSSDR_e_KeyPostCrnk != ((uint32)VeTHMR_e_SSDR_KeySts)))
                       || (((uint32)THMR_ac_DW.UnitDelay_DSTATE_hp4) !=
                           CeSSDR_e_KeyOff)) && (THMR_ac_DW.UnitDelay_DSTATE_ang)));

    /* Update for UnitDelay: '<S4437>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ang = THMR_ac_B.OR1;

    /* End of Outputs for SubSystem: '<S4108>/SignalLatchOnWithReset1' */

    /* Truth Table: '<S4098>/Batt_Condition_new' incorporates:
     *  Constant: '<S4209>/Constant'
     *  Constant: '<S4210>/Constant'
     *  Constant: '<S4220>/Calib'
     *  Constant: '<S4221>/Calib'
     *  Logic: '<S4098>/Logical3'
     *  Logic: '<S4098>/Logical4'
     *  Logic: '<S4098>/Logical6'
     *  Logic: '<S4098>/Logical7'
     *  RelationalOperator: '<S3160>/Comparison10'
     *  RelationalOperator: '<S4098>/Comparison12'
     *  RelationalOperator: '<S4098>/Comparison5'
     *  SignalConversion generated from: '<S2>/VeVTLR_e_DschrgSysSts'
     *  Switch: '<S3956>/Switch'
     */
    /* Truth Table Function 'THMR_FUNC_RU_MedTEH/Subsystem__Subsystem1/SelectMode/BattCond_Enablers/Batt_Condition_new': '<S4208>:1' */
    /*  Bettary Critical or Marginal */
    /*  Vehicle pluged In status */
    /*  PSA status */
    /*  Over voltage Battery Discharge State */
    /*  Alternator Mode status */
    /*  Post cabin conditioning (PCC) OR */
    /*  Schedule cabin conditioning (SCC) OR */
    /*  Remote start (RS) */
    /*  Offboard Power Panel (V2L) */
    /*  Periodic Wake Up Enbl */
    /*  FC AfterRun and Closed Contactors */
    if (rtb_TmpSignalConversionAtVeB_m4)
    {
        /* Gain: '<S4225>/Gain' */
        /* Condition '#1': '<S4208>:1:16' */
        /*  action 1 */
        /* Action '1': '<S4208>:1:78' */
        VeTHMR_K_BattAllowedIndex = THMR_ac_One;
    }
    else if (VeTHMR_b_PlugdIn_Or_Chrg)
    {
        /* Gain: '<S4225>/Gain' */
        /* Condition '#2': '<S4208>:1:20' */
        /*  action 2 */
        /* Action '2': '<S4208>:1:84' */
        VeTHMR_K_BattAllowedIndex = THMR_ac_Two_h;
    }
    else
    {
        rtb_AND_fe = !VeTHMR_b_AlternatorMode_Actv;
        if (rtb_TmpSignalConversionAtPropSy && rtb_AND_fe)
        {
            /* Gain: '<S4225>/Gain' */
            /* Condition '#3': '<S4208>:1:24' */
            /* Decision 'D3': '<S4208>:1:56' */
            /*  action 3 */
            /* Action '3': '<S4208>:1:90' */
            VeTHMR_K_BattAllowedIndex = THMR_ac_Three_o;
        }
        else if (rtb_TmpSignalConversionAtPropSy &&
                 (VeTHMR_b_AlternatorMode_Actv))
        {
            /* Gain: '<S4225>/Gain' */
            /* Decision 'D4': '<S4208>:1:58' */
            /* Condition '#3': '<S4208>:1:24' */
            /* Condition '#5': '<S4208>:1:32' */
            /*  action 4 */
            /* Action '4': '<S4208>:1:96' */
            VeTHMR_K_BattAllowedIndex = THMR_ac_Four_m;
        }
        else if (rtb_TmpSignalConversionAtVePDTR)
        {
            /* Gain: '<S4225>/Gain' */
            /* Condition '#4': '<S4208>:1:28' */
            /*  action 5 */
            /* Action '5': '<S4208>:1:102' */
            VeTHMR_K_BattAllowedIndex = THMR_ac_Five_f;
        }
        else if (rtb_AND_fe && ((rtb_TmpSignalConversionAtVeTP_c &&
                                 (KeTHMR_b_PCCreq_battallowedEnbl)) ||
                                (rtb_Switch_hql &&
                                 (KeTHMR_b_SCCNRSreq_battallowedEnbl))))
        {
            /* Gain: '<S4225>/Gain' */
            /* Decision 'D6': '<S4208>:1:62' */
            /* Condition '#6': '<S4208>:1:38' */
            /*  action 6 */
            /* Action '6': '<S4208>:1:108' */
            VeTHMR_K_BattAllowedIndex = THMR_ac_Six_p;
        }
        else if (((uint32)rtb_TmpSignalConversionAtVeVTLR) ==
                 CeVTLR_e_DschrgActv)
        {
            /* Gain: '<S4225>/Gain' */
            /* Condition '#7': '<S4208>:1:42' */
            /*  action 7 */
            /* Action '7': '<S4208>:1:114' */
            VeTHMR_K_BattAllowedIndex = THMR_ac_Seven_c;
        }
        else if (THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0)
        {
            /* Gain: '<S4225>/Gain' */
            /* Condition '#8': '<S4208>:1:46' */
            /*  action 8 */
            /* Action '8': '<S4208>:1:120' */
            VeTHMR_K_BattAllowedIndex = THMR_ac_Eight_o;
        }
        else
        {
            /* Outputs for Function Call SubSystem: '<S2>/LT_Batt_Loop' */
            if ((((uint32)VeTHMR_e_BatCntctrStat) == CeHVTR_e_Closed) &&
                    rtb_TmpSignalConversionAtVeF_hw)
            {
                /* Gain: '<S4225>/Gain' */
                /* Condition '#9': '<S4208>:1:50' */
                /*  action 9 */
                /* Action '9': '<S4208>:1:126' */
                VeTHMR_K_BattAllowedIndex = THMR_ac_Nine;
            }
            else
            {
                /* Gain: '<S4225>/Gain' */
                /*  Default */
                /*  action 10 */
                /* Action '10': '<S4208>:1:132' */
                VeTHMR_K_BattAllowedIndex = THMR_ac_Ten;
            }

            /* End of Outputs for SubSystem: '<S2>/LT_Batt_Loop' */
        }
    }

    /* End of Truth Table: '<S4098>/Batt_Condition_new' */

    /* Selector: '<S4098>/Selector2' incorporates:
     *  Constant: '<S4213>/Calib'
     */
    VeTHMR_b_BattAllowed_newtable =
        KaTHMR_b_BattConditioning[VeTHMR_K_BattAllowedIndex - 1];

    /* RelationalOperator: '<S4098>/Comparison1' */
    rtb_TmpSignalConversionAtVeTP_c = (rtb_TmpSignalConversionAtVeBT_o <
        VeTHMR_T_MinBattAllow);

    /* Outputs for Atomic SubSystem: '<S4098>/Hysteresis1' */
    /* Switch: '<S4211>/Switch1' incorporates:
     *  RelationalOperator: '<S4211>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeBTRR > rtb_Add_h)
    {
        /* Switch: '<S4211>/Switch1' incorporates:
         *  Constant: '<S4211>/ConstantValue'
         */
        VeTHMR_b_CellMaxAbvMaxAllw = true;
    }
    else
    {
        /* Switch: '<S4211>/Switch1' incorporates:
         *  Constant: '<S4222>/Calib'
         *  RelationalOperator: '<S4211>/GreaterThan1'
         *  Sum: '<S4098>/Subtract1'
         *  UnitDelay: '<S4211>/UnitDelay'
         */
        VeTHMR_b_CellMaxAbvMaxAllw = ((rtb_TmpSignalConversionAtVeBTRR >=
            (rtb_Add_h - KeTHMR_dT_MaxBatAlwLSPTh_BattAlw)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_d1));
    }

    /* End of Switch: '<S4211>/Switch1' */

    /* Update for UnitDelay: '<S4211>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_d1 = VeTHMR_b_CellMaxAbvMaxAllw;

    /* End of Outputs for SubSystem: '<S4098>/Hysteresis1' */

    /* Switch: '<S4098>/Switch1' incorporates:
     *  Constant: '<S4219>/Calib'
     */
    if (KeTHMR_b_NoHysCellMaxOldLogic_BattAlw)
    {
        /* Switch: '<S4098>/Switch1' incorporates:
         *  RelationalOperator: '<S4098>/Comparison'
         */
        rtb_VariantMerge_For_Variant__b = (rtb_TmpSignalConversionAtVeBTRR >
            rtb_Add_h);
    }
    else
    {
        /* Switch: '<S4098>/Switch1' */
        rtb_VariantMerge_For_Variant__b = VeTHMR_b_CellMaxAbvMaxAllw;
    }

    /* End of Switch: '<S4098>/Switch1' */

    /* Truth Table: '<S4098>/Batt_Condition' incorporates:
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     */
    /* Truth Table Function 'THMR_FUNC_RU_MedTEH/Subsystem__Subsystem1/SelectMode/BattCond_Enablers/Batt_Condition': '<S4207>:1' */
    /*  Bettary Critical or Marginal */
    /*  Vehicle pluged In status */
    /*  Batt Min Temp allowed */
    /*  Batt Max Temp allowed */
    /*  PSA status */
    /*  Over voltage Battery Discharge State */
    /* Condition '#6': '<S4207>:1:36' */
    rtb_VariantMerge_For_Variant__m = (((uint32)rtb_TmpSignalConversionAtVePD_l)
        == CePDTR_e_Dischrg_BatTempNotOpt);

    /*  Over voltage Battery Discharge State */
    /* Condition '#7': '<S4207>:1:40' */
    rtb_NotEqual_fo = (((uint32)rtb_TmpSignalConversionAtVePD_l) ==
                       CePDTR_e_Dischrg_ForcBatCool_Hys);

    /*  Over voltage Battery Discharge State */
    if ((((uint32)rtb_TmpSignalConversionAtVePD_l) ==
            CePDTR_e_Dischrg_BatAndCab_Cndtn) || (((uint32)
            rtb_TmpSignalConversionAtVePD_l) == CePDTR_e_Dischrg_ForcBatHeat_Hys))
    {
        /* Condition '#8': '<S4207>:1:44' */
        rtb_TmpSignalConversionAtVeB_jd = true;
    }
    else
    {
        rtb_TmpSignalConversionAtVeB_jd = false;
    }

    /*  Alternator Mode status */
    rtb_AND_fe = !rtb_VariantMerge_For_Variant__m;
    rtb_TmpSignalConversionAtVePD_i = !rtb_NotEqual_fo;
    rtb_AND_de = !rtb_TmpSignalConversionAtVeB_jd;
    rtb_LogicalOperator_aa = !rtb_VariantMerge_For_Variant__b;
    if (((((rtb_TmpSignalConversionAtVeB_m4 && rtb_TmpSignalConversionAtVeTP_c) &&
           rtb_LogicalOperator_aa) && rtb_AND_fe) &&
            rtb_TmpSignalConversionAtVePD_i) && rtb_AND_de)
    {
        /* Gain: '<S4223>/Gain' */
        /* Condition '#1': '<S4207>:1:16' */
        /* Condition '#3': '<S4207>:1:24' */
        /* Decision 'D1': '<S4207>:1:50' */
        /*  action 1 */
        /* Action '1': '<S4207>:1:86' */
        VeTHMR_K_BattCoolIndex = THMR_ac_One;

        /* Gain: '<S4224>/Gain' */
        /* Action '1': '<S4207>:1:87' */
        VeTHMR_K_BattHeatIndex = THMR_ac_One;
    }
    else
    {
        rtb_UnitDelay3_ff = !rtb_TmpSignalConversionAtVeTP_c;
        if (((((rtb_TmpSignalConversionAtVeB_m4 && rtb_UnitDelay3_ff) &&
                rtb_VariantMerge_For_Variant__b) && rtb_AND_fe) &&
                rtb_TmpSignalConversionAtVePD_i) && rtb_AND_de)
        {
            /* Gain: '<S4223>/Gain' */
            /* Condition '#1': '<S4207>:1:16' */
            /* Decision 'D2': '<S4207>:1:52' */
            /* Condition '#4': '<S4207>:1:28' */
            /*  action 2 */
            /* Action '2': '<S4207>:1:93' */
            VeTHMR_K_BattCoolIndex = THMR_ac_Two_h;

            /* Gain: '<S4224>/Gain' */
            /* Action '2': '<S4207>:1:94' */
            VeTHMR_K_BattHeatIndex = THMR_ac_Two_h;
        }
        else
        {
            rtb_TmpSignalConversionAtVeTR_k = !rtb_TmpSignalConversionAtVeB_m4;
            rtb_VariantMerge_For_Variant__j = (rtb_TmpSignalConversionAtVeTR_k &&
                (VeTHMR_b_PlugdIn_Or_Chrg));
            rtb_OR1_k3 = !VeTHMR_b_AlternatorMode_Actv;
            rtb_Switch1_az = ((rtb_VariantMerge_For_Variant__j &&
                               rtb_TmpSignalConversionAtVeTP_c) &&
                              rtb_LogicalOperator_aa);
            if ((((rtb_Switch1_az && rtb_AND_fe) &&
                    rtb_TmpSignalConversionAtVePD_i) && rtb_AND_de) &&
                    rtb_OR1_k3)
            {
                /* Gain: '<S4223>/Gain' */
                /* Decision 'D3': '<S4207>:1:54' */
                /* Condition '#2': '<S4207>:1:20' */
                /* Condition '#3': '<S4207>:1:24' */
                /*  action 3 */
                /* Action '3': '<S4207>:1:100' */
                VeTHMR_K_BattCoolIndex = THMR_ac_Three_o;

                /* Gain: '<S4224>/Gain' */
                /* Action '3': '<S4207>:1:101' */
                VeTHMR_K_BattHeatIndex = THMR_ac_Three_o;
            }
            else
            {
                rtb_Logical27 = ((rtb_VariantMerge_For_Variant__j &&
                                  rtb_UnitDelay3_ff) &&
                                 rtb_VariantMerge_For_Variant__b);
                if ((((rtb_Logical27 && rtb_AND_fe) &&
                        rtb_TmpSignalConversionAtVePD_i) && rtb_AND_de) &&
                        rtb_OR1_k3)
                {
                    /* Gain: '<S4223>/Gain' */
                    /* Decision 'D4': '<S4207>:1:56' */
                    /* Condition '#2': '<S4207>:1:20' */
                    /* Condition '#4': '<S4207>:1:28' */
                    /*  action 4 */
                    /* Action '4': '<S4207>:1:107' */
                    VeTHMR_K_BattCoolIndex = THMR_ac_Four_m;

                    /* Gain: '<S4224>/Gain' */
                    /* Action '4': '<S4207>:1:108' */
                    VeTHMR_K_BattHeatIndex = THMR_ac_Four_m;
                }
                else
                {
                    rtb_TmpSignalConversionAtVeB_m4 =
                        (rtb_TmpSignalConversionAtVeTR_k &&
                         rtb_TmpSignalConversionAtVeTR_i);
                    if (((((rtb_TmpSignalConversionAtVeB_m4 &&
                            (!rtb_TmpSignalConversionAtPropSy)) && rtb_AND_fe) &&
                          rtb_TmpSignalConversionAtVePD_i) && rtb_AND_de) &&
                            rtb_OR1_k3)
                    {
                        /* Gain: '<S4223>/Gain' */
                        /* Decision 'D5': '<S4207>:1:58' */
                        /*  action 5 */
                        /* Action '5': '<S4207>:1:114' */
                        VeTHMR_K_BattCoolIndex = THMR_ac_Five_f;

                        /* Gain: '<S4224>/Gain' */
                        /* Action '5': '<S4207>:1:115' */
                        VeTHMR_K_BattHeatIndex = THMR_ac_Five_f;
                    }
                    else
                    {
                        rtb_LogicalOperator_aa =
                            ((rtb_TmpSignalConversionAtVeB_m4 &&
                              rtb_TmpSignalConversionAtVeTP_c) &&
                             rtb_LogicalOperator_aa);
                        if (((((rtb_LogicalOperator_aa &&
                                rtb_TmpSignalConversionAtPropSy) && rtb_AND_fe) &&
                              rtb_TmpSignalConversionAtVePD_i) && rtb_AND_de) &&
                            rtb_OR1_k3)
                        {
                            /* Gain: '<S4223>/Gain' */
                            /* Decision 'D6': '<S4207>:1:60' */
                            /* Condition '#3': '<S4207>:1:24' */
                            /* Condition '#5': '<S4207>:1:32' */
                            /*  action 6 */
                            /* Action '6': '<S4207>:1:121' */
                            VeTHMR_K_BattCoolIndex = THMR_ac_Six_p;

                            /* Gain: '<S4224>/Gain' */
                            /* Action '6': '<S4207>:1:122' */
                            VeTHMR_K_BattHeatIndex = THMR_ac_Six_p;
                        }
                        else
                        {
                            rtb_UnitDelay3_ff =
                                ((rtb_TmpSignalConversionAtVeB_m4 &&
                                  rtb_UnitDelay3_ff) &&
                                 rtb_VariantMerge_For_Variant__b);
                            if (((((rtb_UnitDelay3_ff &&
                                    rtb_TmpSignalConversionAtPropSy) &&
                                    rtb_AND_fe) &&
                                    rtb_TmpSignalConversionAtVePD_i) &&
                                    rtb_AND_de) && rtb_OR1_k3)
                            {
                                /* Gain: '<S4223>/Gain' */
                                /* Decision 'D7': '<S4207>:1:62' */
                                /* Condition '#4': '<S4207>:1:28' */
                                /* Condition '#5': '<S4207>:1:32' */
                                /*  action 7 */
                                /* Action '7': '<S4207>:1:128' */
                                VeTHMR_K_BattCoolIndex = THMR_ac_Seven_c;

                                /* Gain: '<S4224>/Gain' */
                                /* Action '7': '<S4207>:1:129' */
                                VeTHMR_K_BattHeatIndex = THMR_ac_Seven_c;
                            }
                            else if ((((rtb_Switch1_az &&
                                        rtb_VariantMerge_For_Variant__m) &&
                                       rtb_TmpSignalConversionAtVePD_i) &&
                                      rtb_AND_de) && rtb_OR1_k3)
                            {
                                /* Gain: '<S4223>/Gain' */
                                /* Decision 'D8': '<S4207>:1:64' */
                                /* Condition '#2': '<S4207>:1:20' */
                                /* Condition '#3': '<S4207>:1:24' */
                                /*  action 8 */
                                /* Action '8': '<S4207>:1:135' */
                                VeTHMR_K_BattCoolIndex = THMR_ac_Eight_o;

                                /* Gain: '<S4224>/Gain' */
                                /* Action '8': '<S4207>:1:136' */
                                VeTHMR_K_BattHeatIndex = THMR_ac_Eight_o;
                            }
                            else if ((((rtb_LogicalOperator_aa &&
                                        rtb_VariantMerge_For_Variant__m) &&
                                       rtb_TmpSignalConversionAtVePD_i) &&
                                      rtb_AND_de) && rtb_OR1_k3)
                            {
                                /* Gain: '<S4223>/Gain' */
                                /* Decision 'D9': '<S4207>:1:66' */
                                /* Condition '#3': '<S4207>:1:24' */
                                /*  action 9 */
                                /* Action '9': '<S4207>:1:142' */
                                VeTHMR_K_BattCoolIndex = THMR_ac_Nine;

                                /* Gain: '<S4224>/Gain' */
                                /* Action '9': '<S4207>:1:143' */
                                VeTHMR_K_BattHeatIndex = THMR_ac_Nine;
                            }
                            else if ((((rtb_Logical27 &&
                                        rtb_VariantMerge_For_Variant__m) &&
                                       rtb_TmpSignalConversionAtVePD_i) &&
                                      rtb_AND_de) && rtb_OR1_k3)
                            {
                                /* Gain: '<S4223>/Gain' */
                                /* Decision 'D10': '<S4207>:1:68' */
                                /* Condition '#2': '<S4207>:1:20' */
                                /* Condition '#4': '<S4207>:1:28' */
                                /*  action 10 */
                                /* Action '10': '<S4207>:1:149' */
                                VeTHMR_K_BattCoolIndex = THMR_ac_Ten;

                                /* Gain: '<S4224>/Gain' */
                                /* Action '10': '<S4207>:1:150' */
                                VeTHMR_K_BattHeatIndex = THMR_ac_Ten;
                            }
                            else if ((((rtb_UnitDelay3_ff &&
                                        rtb_VariantMerge_For_Variant__m) &&
                                       rtb_TmpSignalConversionAtVePD_i) &&
                                      rtb_AND_de) && rtb_OR1_k3)
                            {
                                /* Gain: '<S4223>/Gain' */
                                /* Decision 'D11': '<S4207>:1:70' */
                                /* Condition '#4': '<S4207>:1:28' */
                                /*  action 11 */
                                /* Action '11': '<S4207>:1:156' */
                                VeTHMR_K_BattCoolIndex = THMR_ac_Eleven;

                                /* Gain: '<S4224>/Gain' */
                                /* Action '11': '<S4207>:1:157' */
                                VeTHMR_K_BattHeatIndex = THMR_ac_Eleven;
                            }
                            else if ((((rtb_VariantMerge_For_Variant__j &&
                                        rtb_AND_fe) && rtb_NotEqual_fo) &&
                                      rtb_AND_de) && rtb_OR1_k3)
                            {
                                /* Gain: '<S4223>/Gain' */
                                /* Decision 'D12': '<S4207>:1:72' */
                                /* Condition '#2': '<S4207>:1:20' */
                                /*  action 12 */
                                /* Action '12': '<S4207>:1:163' */
                                VeTHMR_K_BattCoolIndex = THMR_ac_Twelve;

                                /* Gain: '<S4224>/Gain' */
                                /* Action '12': '<S4207>:1:164' */
                                VeTHMR_K_BattHeatIndex = THMR_ac_Twelve;
                            }
                            else if ((((rtb_TmpSignalConversionAtVeB_m4 &&
                                        rtb_AND_fe) && rtb_NotEqual_fo) &&
                                      rtb_AND_de) && rtb_OR1_k3)
                            {
                                /* Gain: '<S4223>/Gain' */
                                /* Decision 'D13': '<S4207>:1:74' */
                                /*  action 13 */
                                /* Action '13': '<S4207>:1:170' */
                                VeTHMR_K_BattCoolIndex = THMR_ac_Thirteen;

                                /* Gain: '<S4224>/Gain' */
                                /* Action '13': '<S4207>:1:171' */
                                VeTHMR_K_BattHeatIndex = THMR_ac_Thirteen;
                            }
                            else if ((((rtb_TmpSignalConversionAtVeTR_k &&
                                        rtb_AND_fe) &&
                                       rtb_TmpSignalConversionAtVePD_i) &&
                                      rtb_TmpSignalConversionAtVeB_jd) &&
                                     rtb_OR1_k3)
                            {
                                /* Gain: '<S4223>/Gain' */
                                /* Decision 'D14': '<S4207>:1:76' */
                                /*  action 14 */
                                /* Action '14': '<S4207>:1:177' */
                                VeTHMR_K_BattCoolIndex = THMR_ac_Fourteen;

                                /* Gain: '<S4224>/Gain' */
                                /* Action '14': '<S4207>:1:178' */
                                VeTHMR_K_BattHeatIndex = THMR_ac_Fourteen;
                            }
                            else
                            {
                                /* Gain: '<S4223>/Gain' */
                                /* Decision 'D15': '<S4207>:1:78' */
                                /*  Default */
                                /*  action 15 */
                                /* Action '15': '<S4207>:1:184' */
                                VeTHMR_K_BattCoolIndex = THMR_ac_Fifteen;

                                /* Gain: '<S4224>/Gain' */
                                /* Action '15': '<S4207>:1:185' */
                                VeTHMR_K_BattHeatIndex = THMR_ac_Fifteen;
                            }
                        }
                    }
                }
            }
        }
    }

    /* Selector: '<S4098>/Selector' incorporates:
     *  Constant: '<S4214>/Calib'
     */
    VeTHMR_b_BattAllowed_Cool = KaTHMR_b_BattCoolArray[VeTHMR_K_BattCoolIndex -
        1];

    /* Selector: '<S4098>/Selector1' incorporates:
     *  Constant: '<S4215>/Calib'
     */
    VeTHMR_b_BattAllowed_Heat = KaTHMR_b_BattHeatArray[VeTHMR_K_BattHeatIndex -
        1];

    /* Switch: '<S4227>/Switch' incorporates:
     *  Constant: '<S4227>/FALSEConstant'
     *  Constant: '<S4234>/Calib'
     *  Constant: '<S4235>/Calib'
     *  Constant: '<S4236>/Calib'
     *  Constant: '<S4240>/Calib'
     *  Logic: '<S4227>/Logical6'
     *  Logic: '<S4227>/Logical7'
     *  RelationalOperator: '<S4227>/Comparison1'
     *  RelationalOperator: '<S4227>/Comparison2'
     *  RelationalOperator: '<S4227>/Comparison3'
     */
    if (KeTHMR_b_LdshedBattCondtn_Slct)
    {
        rtb_AND_fe = (((VeTHMR_Pct_HV_BatSOC > KeTHMR_Pct_BattSOC_LdShdCool_Lv1)
                       && (rtb_TmpSignalConversionAtVeBTRR >
                           KeTHMR_T_BattMaxTmp1_LdShed)) ||
                      (rtb_TmpSignalConversionAtVeBTRR >
                       KeTHMR_T_BattMaxTmp2_LdShed));
    }
    else
    {
        rtb_AND_fe = false;
    }

    /* End of Switch: '<S4227>/Switch' */

    /* Logic: '<S4227>/Logical2' */
    VeTHMR_b_ThrmLdshed_CoolRq = (rtb_AND_fe && (VeTHMR_b_ThrmLoad_Shed));

    /* SignalConversion generated from: '<S4228>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_DsblPSAChk_BattAllwd_MHEV

    /* RelationalOperator: '<S4116>/RelationalOperator3' incorporates:
     *  Constant: '<S4228>/Constant'
     */
    rtb_RelationalOperator3_aj = true;

#else

    /* RelationalOperator: '<S4116>/RelationalOperator3' incorporates:
     *  SignalConversion generated from: '<S4228>/VariantSource'
     */
    rtb_RelationalOperator3_aj = rtb_TmpSignalConversionAtPropSy;

#endif

    /* End of SignalConversion generated from: '<S4228>/VariantSource' */

    /* SignalConversion generated from: '<S4228>/VariantSource1' incorporates:
     *  RelationalOperator: '<S4228>/Comparison9'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EngOnChk_BattAllwd_MHEV

    /* RelationalOperator: '<S4116>/RelationalOperator9' incorporates:
     *  Constant: '<S4228>/Constant1'
     */
    rtb_RelationalOperator9_h = true;

#else

    /* Outputs for Function Call SubSystem: '<S2>/HTCL' */
    /* RelationalOperator: '<S4116>/RelationalOperator9' incorporates:
     *  Constant: '<S4241>/Constant'
     *  RelationalOperator: '<S1472>/Comparison4'
     *  RelationalOperator: '<S4228>/Comparison9'
     *  Switch: '<S3948>/Switch'
     */
    rtb_RelationalOperator9_h = (((uint32)VeTHMR_e_EngStartStopSt_AD) ==
        CeESSR_e_EngRunning);

    /* End of Outputs for SubSystem: '<S2>/HTCL' */
#endif

    /* End of SignalConversion generated from: '<S4228>/VariantSource1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeBTRR_b_BattCoolReq' */
    (void)Rte_Read_VeBTRR_b_BattCoolReq_Value(&aVarTruthTableCondition_4);

    /* Inport: '<Root>/VePMTR_b_REM_BattCoolAction' */
    (void)Rte_Read_VePMTR_b_REM_BattCoolAction_Value(&rtb_LogicalOperator1_nm);

    /* Inport: '<Root>/VePMTR_b_REM_BattHeatAction' */
    (void)Rte_Read_VePMTR_b_REM_BattHeatAction_Value(&rtb_LogicalOperator4_j);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Switch: '<S4098>/Switch2' incorporates:
     *  Constant: '<S4218>/Calib'
     *  Logic: '<S4098>/Logical1'
     */
    if (KeTHMR_b_BattAllowedtableNewLogic)
    {
        rtb_AND_fe = VeTHMR_b_BattAllowed_newtable;
    }
    else
    {
        rtb_AND_fe = ((VeTHMR_b_BattAllowed_Cool) || (VeTHMR_b_BattAllowed_Heat));
    }

    /* End of Switch: '<S4098>/Switch2' */

    /* Logic: '<S4098>/Logical5' incorporates:
     *  Constant: '<S4238>/Calib'
     *  Constant: '<S4239>/Calib'
     *  Logic: '<S4227>/Logical10'
     *  Logic: '<S4227>/Logical3'
     *  Logic: '<S4227>/Logical4'
     *  Logic: '<S4227>/Logical5'
     *  Logic: '<S4227>/Logical8'
     *  Logic: '<S4227>/Logical9'
     *  Logic: '<S4228>/Logical5'
     */
    VeTHMR_b_BattAllowed_B4D = ((rtb_AND_fe && (((VeTHMR_b_ThrmLdshed_CoolRq) ||
        ((!VeTHMR_b_ThrmLoad_Shed) || (KeTHMR_b_Ignore_LoadShd))) ||
        (rtb_TmpSignalConversionAtVePDTR &&
         (!KeTHMR_b_Dsbl_OV_LoadShed_BatteryCond)))) &&
        (rtb_RelationalOperator3_aj && rtb_RelationalOperator9_h));

    /* Switch: '<S4098>/Switch' incorporates:
     *  Constant: '<S4217>/Calib'
     */
    if (KeTHMR_b_BattAllowed_SD)
    {
        /* Switch: '<S4098>/Switch' incorporates:
         *  Constant: '<S4216>/Calib'
         */
        VeTHMR_b_BattAllowed_BS = KeTHMR_b_BattAllowed_D;
    }
    else
    {
        /* Switch: '<S4098>/Switch' */
        VeTHMR_b_BattAllowed_BS = VeTHMR_b_BattAllowed_B4D;
    }

    /* End of Switch: '<S4098>/Switch' */

    /* Switch: '<S4212>/Switch1' incorporates:
     *  Logic: '<S4098>/Logical2'
     */
    THMR_ac_B.Switch1_h = ((rtb_LogicalOperator4_j || rtb_LogicalOperator1_nm) &&
                           (VeTHMR_b_BattAllowed_BS));

    /* Logic: '<S4735>/Logical14' incorporates:
     *  Logic: '<S4099>/Logical7'
     *  Logic: '<S4107>/Logical2'
     *  Logic: '<S4733>/Logical14'
     *  Logic: '<S4736>/Logical16'
     *  Logic: '<S4918>/LogicalOperator1'
     *  Logic: '<S4919>/LogicalOperator1'
     *  Logic: '<S5091>/LogicalOperator3'
     */
    rtb_TmpSignalConversionAtVeTR_i = !THMR_ac_B.OR1;

    /* Logic: '<S4735>/Logical1' incorporates:
     *  Constant: '<S4798>/Calib'
     *  Constant: '<S4799>/Calib'
     *  Logic: '<S4735>/Logical14'
     *  Logic: '<S4735>/Logical2'
     *  Logic: '<S4735>/Logical3'
     */
    VeTHMR_b_BattCondEmergencyCool = ((((VeTHMR_b_EmergencyCool) &&
        rtb_Logical2_iq) && (rtb_TmpSignalConversionAtVeTR_i ||
        (KeTHMR_b_DsblImpct_EmrgncyCool))) && ((THMR_ac_B.Switch1_h) ||
        (KeTHMR_b_Enbl_BattAllwd_EmrgncyCool)));

    /* RelationalOperator: '<S4733>/Comparison5' incorporates:
     *  Constant: '<S4740>/Constant'
     */
    rtb_TmpSignalConversionAtVeB_m4 = (CeAVTR_e_EVA_MaxCool == ((uint32)
        rtb_TmpSignalConversionAtVeAVTR));

    /* Switch: '<S4733>/Switch' incorporates:
     *  Constant: '<S4741>/Constant'
     *  Inport: '<Root>/VeAVTR_b_SDS_CoolingReq'
     *  Logic: '<S4733>/Logical2'
     *  RelationalOperator: '<S4733>/Comparison4'
     */
    if (rtb_TmpSignalConversionAtVeB_m4 || (((uint32)
            rtb_TmpSignalConversionAtVeAVTR) == CeAVTR_e_EVA_Cool))
    {
        (void)Rte_Read_VeAVTR_b_SDS_CoolingReq_Value(&rtb_LogicalOperator_dv);

        /* Switch: '<S4733>/Switch' incorporates:
         *  Constant: '<S4742>/Calib'
         *  Constant: '<S4744>/Calib'
         *  Constant: '<S4745>/Calib'
         *  Inport: '<Root>/VeAVTR_b_SDS_CoolingReq'
         *  Logic: '<S4733>/Logical1'
         *  Logic: '<S4733>/Logical3'
         *  Logic: '<S4733>/Logical4'
         *  Logic: '<S4733>/Logical8'
         *  RelationalOperator: '<S4733>/Comparison7'
         */
        VeTHMR_b_CellMax_ActvCool = ((rtb_LogicalOperator_dv ||
            ((aVarTruthTableCondition_4 || (KeTHMR_b_DsblcoolreqChk_ActvCool)) &&
             ((TmpSignalConversionAtOutAirTemp > KeTHMR_T_ActvCoolAmbTemp) ||
              (KeTHMR_b_DsblAmbChk_ActvCool)))) ||
            rtb_TmpSignalConversionAtVeB_m4);
    }
    else
    {
        /* Switch: '<S4733>/Switch' incorporates:
         *  Constant: '<S4742>/Calib'
         *  Constant: '<S4744>/Calib'
         *  Constant: '<S4745>/Calib'
         *  Logic: '<S4733>/Logical3'
         *  Logic: '<S4733>/Logical4'
         *  Logic: '<S4733>/Logical8'
         *  RelationalOperator: '<S4733>/Comparison7'
         */
        VeTHMR_b_CellMax_ActvCool = ((aVarTruthTableCondition_4 ||
            (KeTHMR_b_DsblcoolreqChk_ActvCool)) &&
            ((TmpSignalConversionAtOutAirTemp > KeTHMR_T_ActvCoolAmbTemp) ||
             (KeTHMR_b_DsblAmbChk_ActvCool)));
    }

    /* End of Switch: '<S4733>/Switch' */

    /* SignalConversion generated from: '<S4103>/VariantSource1' incorporates:
     *  Inport: '<Root>/VeFCPR_e_ActualMode'
     *  Inport: '<Root>/VeHPMR_e_FuelCellMdCmd'
     *  Inport: '<Root>/VeSTRR_b_FCOnAllwd'
     *  Logic: '<S4103>/Logical1'
     *  Logic: '<S4103>/Logical2'
     *  Logic: '<S4103>/Logical3'
     *  Logic: '<S4103>/Logical4'
     *  Logic: '<S4103>/LogicalOperator1'
     *  Logic: '<S4103>/LogicalOperator2'
     *  Logic: '<S4103>/LogicalOperator3'
     *  RelationalOperator: '<S4053>/RelationalOperator1'
     *  RelationalOperator: '<S4103>/Comparison1'
     *  RelationalOperator: '<S4103>/Comparison4'
     *  RelationalOperator: '<S4103>/RelationalOperator'
     *  RelationalOperator: '<S4103>/RelationalOperator1'
     *  RelationalOperator: '<S4103>/RelationalOperator2'
     *  RelationalOperator: '<S4103>/RelationalOperator3'
     *  Selector: '<S4103>/Selector1'
     *  Selector: '<S4103>/Selector3'
     *  SignalConversion generated from: '<S4103>/VariantSource'
     *  Truth Table: '<S4103>/FC_AllwdTable'
     *  Truth Table: '<S4103>/FC_AllwdTable_New'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

    /* RelationalOperator: '<S4116>/RelationalOperator9' incorporates:
     *  Constant: '<S4103>/Constant1'
     */
    rtb_RelationalOperator9_h = false;

    /* RelationalOperator: '<S4116>/RelationalOperator3' incorporates:
     *  Constant: '<S4103>/Constant'
     */
    rtb_RelationalOperator3_aj = false;

#else

    /* Outputs for Atomic SubSystem: '<S4103>/Turn Off Delay Sample Modified' */
    (void)Rte_Read_VeFCPR_e_ActualMode_Value(&tmpRead_23);

    /* Logic: '<S4103>/LogicalOperator2' incorporates:
     *  Constant: '<S4388>/Constant'
     *  Constant: '<S4389>/Constant'
     *  Inport: '<Root>/VeFCPR_e_ActualMode'
     *  RelationalOperator: '<S4103>/RelationalOperator2'
     *  RelationalOperator: '<S4103>/RelationalOperator3'
     */
    rtb_RelationalOperator9_h = ((((uint32)rtb_TmpSignalConversionAtVeFC_o) ==
        CeFCPR_e_Pre_Heating) || (((uint32)tmpRead_23) ==
        CeFCPR_e_ActualMode_PreheatReqd));

    /* Outputs for Atomic SubSystem: '<S4402>/EdgeFalling' */
    /* Logic: '<S4403>/AND' incorporates:
     *  Logic: '<S4403>/OR1'
     *  UnitDelay: '<S4403>/Unit Delay'
     */
    rtb_TmpSignalConversionAtVeTM_j = ((!rtb_RelationalOperator9_h) &&
        (THMR_ac_DW.UnitDelay_DSTATE_ebr));

    /* Update for UnitDelay: '<S4403>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_ebr = rtb_RelationalOperator9_h;

    /* End of Outputs for SubSystem: '<S4402>/EdgeFalling' */

    /* Switch: '<S4402>/Switch' incorporates:
     *  MinMax: '<S4402>/Minimum1'
     *  UnitDelay: '<S4402>/Unit Delay'
     */
    if (rtb_TmpSignalConversionAtVeTM_j)
    {
        /* Switch: '<S4402>/Switch' incorporates:
         *  Constant: '<S4396>/Calib'
         */
        rtb_Switch_i3 = KeTHMR_Cnt_FCDeratePreHeatDebounce;
    }
    else
    {
        if (((sint32)THMR_ac_DW.UnitDelay_DSTATE_ob) > 1)
        {
            /* MinMax: '<S4402>/Minimum1' incorporates:
             *  UnitDelay: '<S4402>/Unit Delay'
             */
            u1 = THMR_ac_DW.UnitDelay_DSTATE_ob;
        }
        else
        {
            /* MinMax: '<S4402>/Minimum1' */
            u1 = 1U;
        }

        /* Switch: '<S4402>/Switch' incorporates:
         *  Constant: '<S4402>/Constant Value'
         *  Sum: '<S4402>/Summation'
         */
        rtb_Switch_i3 = (uint16)((sint32)(((sint32)u1) - 1));
    }

    /* End of Switch: '<S4402>/Switch' */

    /* Logic: '<S4402>/AND' incorporates:
     *  Constant: '<S4402>/Constant Value2'
     *  RelationalOperator: '<S4402>/Greater  Than'
     */
    rtb_RelationalOperator9_h = (rtb_RelationalOperator9_h || (((sint32)
        rtb_Switch_i3) > 0));

    /* Update for UnitDelay: '<S4402>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_ob = rtb_Switch_i3;

    /* Logic: '<S4103>/LogicalOperator1' incorporates:
     *  Constant: '<S4401>/Calib'
     */
    rtb_TmpSignalConversionAtVeTM_j = (rtb_Switch_hql &&
        (KeTHMR_b_SCCNRSreq_FCAllwdEnbl));

    /* RelationalOperator: '<S4103>/RelationalOperator1' incorporates:
     *  Constant: '<S4387>/Constant'
     *  SignalConversion generated from: '<S2>/VeFCRR_e_FcTempRange'
     */
    rtb_TmpSignalConversionAtVeT_f5 = (CeFCRR_e_ShutDown == ((uint32)
        rtb_TmpSignalConversionAtVeFC_i));

    /* Logic: '<S4103>/Logical2' incorporates:
     *  Constant: '<S4390>/Constant'
     *  Constant: '<S4399>/Calib'
     *  Logic: '<S4103>/Logical1'
     *  RelationalOperator: '<S4103>/Comparison4'
     */
    rtb_UnitDelay3_ff = (((((uint32)rtb_TmpSignalConversionAtVeFC_o) !=
                           CeFCPR_e_No_Request) && (KeTHMR_b_HTCoolReq_Enbl)) ||
                         rtb_TmpSignalConversionAtVeF_hw);

    /* Outputs for Function Call SubSystem: '<S2>/LT_Batt_Loop' */
    /* Truth Table: '<S4103>/FC_AllwdTable_New' incorporates:
     *  RelationalOperator: '<S3160>/Comparison10'
     *  Switch: '<S3956>/Switch'
     */
    /* Truth Table Function 'THMR_FUNC_RU_MedTEH/Subsystem__Subsystem1/SelectMode/FC_Cond_Enablers/FC_AllwdTable_New': '<S4393>:1' */
    /*  HV Bat Contactors */
    if ((((uint32)VeTHMR_e_BatCntctrStat) == CeHVTR_e_Closed) &&
            rtb_TmpSignalConversionAtBattCn)
    {
        /* Condition '#1': '<S4393>:1:15' */
        rtb_TmpSignalConversionAtVeB_jd = true;
    }
    else
    {
        rtb_TmpSignalConversionAtVeB_jd = false;
    }

    /* End of Outputs for SubSystem: '<S2>/LT_Batt_Loop' */
    /*  HTCoolReq == 1 and FCPS_FCSModeActual == PreHeat */
    /*  SCC */
    /*  FC Critical Hot */
    /*  HTCoolReq */
    /* Condition '#5': '<S4393>:1:31' */
    rtb_TmpSignalConversionAtVeF_hw = (((uint32)rtb_TmpSignalConversionAtVeFC_o)
        != CeFCPR_e_No_Request);

    /*  FC After Run */
    /*  FCPwrSink OR PDTR ~= No_Dschrg */
    /*  VeSTRR_b_FCOnAllwd */
    (void)Rte_Read_VeSTRR_b_FCOnAllwd_Value(&rtb_LogicalOperator3_jq);

    /* Truth Table: '<S4103>/FC_AllwdTable_New' incorporates:
     *  Constant: '<S4391>/Constant'
     *  Constant: '<S4400>/Calib'
     *  Inport: '<Root>/VeSTRR_b_FCOnAllwd'
     *  Logic: '<S4103>/Logical3'
     *  Logic: '<S4103>/Logical4'
     *  RelationalOperator: '<S4103>/Comparison1'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     */
    rtb_AND_fe = (rtb_TmpSignalConversionAtVeB_jd && rtb_RelationalOperator9_h);
    if (rtb_AND_fe && rtb_LogicalOperator3_jq)
    {
        /* Condition '#2': '<S4393>:1:19' */
        /* Condition '#8': '<S4393>:1:43' */
        /*  action 1 */
        /* Action '1': '<S4393>:1:71' */
        s381_iter = THMR_ac_One;
    }
    else
    {
        rtb_TmpSignalConversionAtVePD_i = !rtb_LogicalOperator3_jq;
        if ((rtb_AND_fe && (!rtb_TmpSignalConversionAtVeTM_j)) &&
                rtb_TmpSignalConversionAtVePD_i)
        {
            /* Condition '#2': '<S4393>:1:19' */
            /* Decision 'D2': '<S4393>:1:47' */
            /*  action 2 */
            /* Action '2': '<S4393>:1:77' */
            s381_iter = THMR_ac_Two_h;
        }
        else if ((rtb_AND_fe && rtb_TmpSignalConversionAtVeTM_j) &&
                 rtb_TmpSignalConversionAtVePD_i)
        {
            /* Condition '#2': '<S4393>:1:19' */
            /* Condition '#3': '<S4393>:1:23' */
            /* Decision 'D3': '<S4393>:1:49' */
            /*  action 3 */
            /* Action '3': '<S4393>:1:83' */
            s381_iter = THMR_ac_Three_o;
        }
        else
        {
            rtb_AND_fe = (rtb_TmpSignalConversionAtVeB_jd &&
                          rtb_TmpSignalConversionAtVeT_f5);
            if (rtb_AND_fe && rtb_LogicalOperator3_jq)
            {
                /* Condition '#4': '<S4393>:1:27' */
                /* Condition '#8': '<S4393>:1:43' */
                /*  action 4 */
                /* Action '4': '<S4393>:1:89' */
                s381_iter = THMR_ac_Four_m;
            }
            else if (rtb_AND_fe && rtb_TmpSignalConversionAtVePD_i)
            {
                /* Condition '#4': '<S4393>:1:27' */
                /* Decision 'D5': '<S4393>:1:53' */
                /*  action 5 */
                /* Action '5': '<S4393>:1:95' */
                s381_iter = THMR_ac_Five_f;
            }
            else if (rtb_TmpSignalConversionAtVeB_jd &&
                     rtb_TmpSignalConversionAtVeF_hw)
            {
                /* Decision 'D6': '<S4393>:1:55' */
                /*  action 6 */
                /* Action '6': '<S4393>:1:101' */
                s381_iter = THMR_ac_Six_p;
            }
            else if (rtb_TmpSignalConversionAtVeB_jd && rtb_UnitDelay3_ff)
            {
                /* Condition '#6': '<S4393>:1:35' */
                /*  action 7 */
                /* Action '7': '<S4393>:1:107' */
                s381_iter = THMR_ac_Seven_c;
            }
            else if (rtb_TmpSignalConversionAtVeB_jd &&
                     (rtb_TmpSignalConversionAtVeFC_a || ((((uint32)
                         rtb_TmpSignalConversionAtVePD_l) != CePDTR_e_No_Dischrg)
                       && (KeTHMR_b_PDTRBattDschrgEnbl))))
            {
                /* Condition '#7': '<S4393>:1:39' */
                /*  action 8 */
                /* Action '8': '<S4393>:1:113' */
                s381_iter = THMR_ac_Eight_o;
            }
            else if (rtb_TmpSignalConversionAtVeB_jd &&
                     (!rtb_TmpSignalConversionAtVeF_hw))
            {
                /* Decision 'D9': '<S4393>:1:61' */
                /*  action 9 */
                /* Action '9': '<S4393>:1:119' */
                s381_iter = THMR_ac_Nine;
            }
            else
            {
                /* Decision 'D10': '<S4393>:1:63' */
                /*  Default */
                /*  action 10 */
                /* Action '10': '<S4393>:1:125' */
                s381_iter = THMR_ac_Ten;
            }
        }
    }

    /* RelationalOperator: '<S4116>/RelationalOperator9' incorporates:
     *  Constant: '<S4395>/Calib'
     *  Selector: '<S4103>/Selector1'
     */
    rtb_RelationalOperator9_h = KaTHMR_b_FCCondAllwArray_NewLogic[s381_iter - 1];
    (void)Rte_Read_VeHPMR_e_FuelCellMdCmd_Value(&tmpRead_22);

    /* RelationalOperator: '<S4053>/RelationalOperator1' incorporates:
     *  Constant: '<S4102>/Constant'
     *  Inport: '<Root>/VeHPMR_e_FuelCellMdCmd'
     */
    rtb_RelationalOperator3_aj = (((uint32)tmpRead_22) == CeHPMR_e_FC_Enabled);

    /* Logic: '<S4103>/LogicalOperator3' incorporates:
     *  Constant: '<S4386>/Constant'
     *  Constant: '<S4398>/Calib'
     *  RelationalOperator: '<S4103>/RelationalOperator'
     *  SignalConversion generated from: '<S2>/VeFCRR_e_FcTempRange'
     */
    rtb_LogicalOperator3_jq = ((((uint32)rtb_TmpSignalConversionAtVeFC_i) ==
        CeFCRR_e_Freeze) && (KeTHMR_b_FCCritCold_FCAllwdEnbl));

    /* Outputs for Function Call SubSystem: '<S2>/LT_Batt_Loop' */
    /* Truth Table: '<S4103>/FC_AllwdTable' incorporates:
     *  RelationalOperator: '<S2869>/RelationalOperator'
     *  RelationalOperator: '<S3160>/Comparison10'
     *  Switch: '<S3945>/Switch'
     *  Switch: '<S3956>/Switch'
     */
    /* Truth Table Function 'THMR_FUNC_RU_MedTEH/Subsystem__Subsystem1/SelectMode/FC_Cond_Enablers/FC_AllwdTable': '<S4392>:1' */
    /*  HV Bat Contactors */
    /* Condition '#1': '<S4392>:1:17' */
    rtb_Logical27 = (((uint32)VeTHMR_e_BatCntctrStat) == CeHVTR_e_Closed);

    /* End of Outputs for SubSystem: '<S2>/LT_Batt_Loop' */

    /* Outputs for Function Call SubSystem: '<S2>/LTCL' */
    /*  FC Critical Cold - Freeze */
    /*  FC Critical Hot - Shutdown */
    /*  Key Off */
    /* Condition '#4': '<S4392>:1:29' */
    aVarTruthTableCondition_4 = (((uint32)VeTHMR_e_SSDR_KeySts) ==
        CeSSDR_e_KeyOff);

    /*  Key Run */
    /* Condition '#5': '<S4392>:1:33' */
    rtb_TmpSignalConversionAtVeF_hw = (((uint32)VeTHMR_e_SSDR_KeySts) ==
        CeSSDR_e_KeyRun);

    /* End of Outputs for SubSystem: '<S2>/LTCL' */
    /*  SCC PreCond */
    /*  PSA status */
    /*  FC Enable */
    /*  FC Power Sink */
    /*  FC Afterrun */
    rtb_AND_fe = (rtb_Logical27 && (!rtb_LogicalOperator3_jq));
    rtb_TmpSignalConversionAtVePD_i = !rtb_TmpSignalConversionAtPropSy;
    rtb_AND_de = !rtb_TmpSignalConversionAtVeF_hw;
    rtb_LogicalOperator_aa = ((((rtb_AND_fe && aVarTruthTableCondition_4) &&
        rtb_AND_de) && (!rtb_TmpSignalConversionAtVeTM_j)) &&
        rtb_TmpSignalConversionAtVePD_i);
    if (rtb_LogicalOperator_aa && rtb_UnitDelay3_ff)
    {
        /* Decision 'D1': '<S4392>:1:55' */
        /* Condition '#10': '<S4392>:1:53' */
        /*  action 1 */
        /* Action '1': '<S4392>:1:87' */
        s381_iter = THMR_ac_One;
    }
    else if (rtb_LogicalOperator_aa && (!rtb_UnitDelay3_ff))
    {
        /* Decision 'D2': '<S4392>:1:57' */
        /*  action 2 */
        /* Action '2': '<S4392>:1:93' */
        s381_iter = THMR_ac_Two_h;
    }
    else
    {
        rtb_LogicalOperator_aa = !aVarTruthTableCondition_4;
        rtb_AND_fe = (rtb_AND_fe && rtb_LogicalOperator_aa);
        if (rtb_AND_fe && rtb_UnitDelay3_ff)
        {
            /* Decision 'D3': '<S4392>:1:59' */
            /* Condition '#10': '<S4392>:1:53' */
            /*  action 3 */
            /* Action '3': '<S4392>:1:99' */
            s381_iter = THMR_ac_Three_o;
        }
        else if ((((rtb_AND_fe && rtb_TmpSignalConversionAtVeF_hw) &&
                   rtb_TmpSignalConversionAtVeTM_j) &&
                  rtb_TmpSignalConversionAtVePD_i) && rtb_RelationalOperator3_aj)
        {
            /* Decision 'D4': '<S4392>:1:61' */
            /* Condition '#6': '<S4392>:1:37' */
            /* Condition '#8': '<S4392>:1:45' */
            /*  action 4 */
            /* Action '4': '<S4392>:1:105' */
            s381_iter = THMR_ac_Four_m;
        }
        else
        {
            rtb_AND_fe = (rtb_Logical27 && (!rtb_LogicalOperator3_jq));
            rtb_UnitDelay3_ff = (rtb_AND_fe && rtb_LogicalOperator_aa);
            rtb_TmpSignalConversionAtVeTR_k = !rtb_RelationalOperator3_aj;
            if ((((rtb_UnitDelay3_ff && rtb_TmpSignalConversionAtVeF_hw) &&
                    rtb_TmpSignalConversionAtVeTM_j) &&
                    rtb_TmpSignalConversionAtVePD_i) &&
                    rtb_TmpSignalConversionAtVeTR_k)
            {
                /* Decision 'D5': '<S4392>:1:63' */
                /* Condition '#6': '<S4392>:1:37' */
                /*  action 5 */
                /* Action '5': '<S4392>:1:111' */
                s381_iter = THMR_ac_Five_f;
            }
            else if ((((rtb_UnitDelay3_ff && rtb_AND_de) &&
                       rtb_TmpSignalConversionAtVeTM_j) &&
                      rtb_TmpSignalConversionAtPropSy) &&
                     rtb_RelationalOperator3_aj)
            {
                /* Decision 'D6': '<S4392>:1:65' */
                /* Condition '#6': '<S4392>:1:37' */
                /* Condition '#7': '<S4392>:1:41' */
                /* Condition '#8': '<S4392>:1:45' */
                /*  action 6 */
                /* Action '6': '<S4392>:1:117' */
                s381_iter = THMR_ac_Six_p;
            }
            else if (((rtb_AND_fe && rtb_TmpSignalConversionAtVeTM_j) &&
                      rtb_TmpSignalConversionAtPropSy) &&
                     rtb_TmpSignalConversionAtVeTR_k)
            {
                /* Decision 'D7': '<S4392>:1:67' */
                /* Condition '#6': '<S4392>:1:37' */
                /* Condition '#7': '<S4392>:1:41' */
                /*  action 7 */
                /* Action '7': '<S4392>:1:123' */
                s381_iter = THMR_ac_Seven_c;
            }
            else
            {
                rtb_TmpSignalConversionAtVePD_i = (rtb_AND_fe &&
                    rtb_TmpSignalConversionAtPropSy);
                if (rtb_TmpSignalConversionAtVePD_i &&
                        rtb_RelationalOperator3_aj)
                {
                    /* Decision 'D8': '<S4392>:1:69' */
                    /* Condition '#7': '<S4392>:1:41' */
                    /* Condition '#8': '<S4392>:1:45' */
                    /*  action 8 */
                    /* Action '8': '<S4392>:1:129' */
                    s381_iter = THMR_ac_Eight_o;
                }
                else if ((rtb_TmpSignalConversionAtVePD_i &&
                          rtb_TmpSignalConversionAtVeTR_k) &&
                         rtb_TmpSignalConversionAtVeFC_a)
                {
                    /* Decision 'D9': '<S4392>:1:71' */
                    /* Condition '#7': '<S4392>:1:41' */
                    /* Condition '#9': '<S4392>:1:49' */
                    /*  action 9 */
                    /* Action '9': '<S4392>:1:135' */
                    s381_iter = THMR_ac_Nine;
                }
                else if ((rtb_AND_fe && rtb_TmpSignalConversionAtVeTR_k) &&
                         (!rtb_TmpSignalConversionAtVeFC_a))
                {
                    /* Decision 'D10': '<S4392>:1:73' */
                    /*  action 10 */
                    /* Action '10': '<S4392>:1:141' */
                    s381_iter = THMR_ac_Ten;
                }
                else
                {
                    rtb_AND_fe = (rtb_AND_fe && rtb_TmpSignalConversionAtVeT_f5);
                    if (rtb_AND_fe && aVarTruthTableCondition_4)
                    {
                        /* Decision 'D11': '<S4392>:1:75' */
                        /* Condition '#3': '<S4392>:1:25' */
                        /*  action 11 */
                        /* Action '11': '<S4392>:1:147' */
                        s381_iter = THMR_ac_Eleven;
                    }
                    else if (rtb_AND_fe && rtb_LogicalOperator_aa)
                    {
                        /* Decision 'D12': '<S4392>:1:77' */
                        /* Condition '#3': '<S4392>:1:25' */
                        /*  action 12 */
                        /* Action '12': '<S4392>:1:153' */
                        s381_iter = THMR_ac_Twelve;
                    }
                    else
                    {
                        /* Decision 'D13': '<S4392>:1:79' */
                        /*  Default */
                        /*  action 13 */
                        /* Action '13': '<S4392>:1:159' */
                        s381_iter = THMR_ac_Thirteen;
                    }
                }
            }
        }
    }

    /* RelationalOperator: '<S4116>/RelationalOperator3' incorporates:
     *  Constant: '<S4394>/Calib'
     *  Selector: '<S4103>/Selector3'
     */
    rtb_RelationalOperator3_aj = KaTHMR_b_FCCondAllwArray[s381_iter - 1];

    /* End of Outputs for SubSystem: '<S4103>/Turn Off Delay Sample Modified' */
#endif

    /* End of SignalConversion generated from: '<S4103>/VariantSource1' */

    /* Switch: '<S4103>/Switch2' incorporates:
     *  Constant: '<S4397>/Calib'
     */
    if (KeTHMR_b_FCAllowedtableNewLogic)
    {
        /* Switch: '<S4103>/Switch2' */
        rtb_TmpSignalConversionAtPropSy = rtb_RelationalOperator9_h;
    }
    else
    {
        /* Switch: '<S4103>/Switch2' */
        rtb_TmpSignalConversionAtPropSy = rtb_RelationalOperator3_aj;
    }

    /* End of Switch: '<S4103>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S5086>/Hysteresis' */
    /* Switch: '<S5088>/Switch1' incorporates:
     *  Constant: '<S5090>/Calib'
     *  RelationalOperator: '<S5088>/Greater  Than'
     *  Sum: '<S5086>/Subtraction1'
     */
    if (rtb_TmpSignalConversionAtVeF_n4 > (rtb_TmpSignalConversionAtVeFCRR +
            KeTHMR_dT_FCPsvCool_RadOpen_RSP))
    {
        /* Switch: '<S5088>/Switch1' incorporates:
         *  Constant: '<S5088>/Constant Value'
         */
        rtb_RelationalOperator9_h = true;
    }
    else
    {
        /* Switch: '<S5088>/Switch1' incorporates:
         *  Constant: '<S5089>/Calib'
         *  RelationalOperator: '<S5088>/Greater  Than1'
         *  Sum: '<S5086>/Subtraction'
         *  UnitDelay: '<S5088>/Unit Delay'
         */
        rtb_RelationalOperator9_h = ((rtb_TmpSignalConversionAtVeF_n4 >=
            (KeTHMR_dT_FCPsvCool_RadOpen_LSP + rtb_TmpSignalConversionAtVeFCRR))
            && (THMR_ac_DW.UnitDelay_DSTATE_d5));
    }

    /* End of Switch: '<S5088>/Switch1' */
    /* End of Outputs for SubSystem: '<S5086>/Hysteresis' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeFCRR_b_FcCoolReq' */
    (void)Rte_Read_VeFCRR_b_FcCoolReq_Value(&rtb_AND_hz);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Outputs for Atomic SubSystem: '<S5086>/Hysteresis' */
    /* Update for UnitDelay: '<S5088>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_d5 = rtb_RelationalOperator9_h;

    /* End of Outputs for SubSystem: '<S5086>/Hysteresis' */

    /* Logic: '<S5074>/Logical5' incorporates:
     *  Constant: '<S5087>/Calib'
     *  Logic: '<S5074>/Logical7'
     */
    VeTHMR_b_FCPsvCool_Req = (((rtb_AND_hz && rtb_TmpSignalConversionAtPropSy) &&
        (!KeTHMR_b_DsblFCPsvCool)) && rtb_RelationalOperator9_h);

    /* Outputs for Atomic SubSystem: '<S5079>/Hysteresis' */
    /* Switch: '<S5083>/Switch1' incorporates:
     *  Constant: '<S5085>/Calib'
     *  RelationalOperator: '<S5083>/Greater  Than'
     *  Sum: '<S5079>/Subtraction1'
     */
    if (rtb_TmpSignalConversionAtVeTM_f > (rtb_TmpSignalConversionAtVeT_ge +
            KeTHMR_dT_FCPsvCool_RadOpen_RSP))
    {
        /* Switch: '<S5083>/Switch1' incorporates:
         *  Constant: '<S5083>/Constant Value'
         */
        rtb_RelationalOperator9_h = true;
    }
    else
    {
        /* Switch: '<S5083>/Switch1' incorporates:
         *  Constant: '<S5084>/Calib'
         *  RelationalOperator: '<S5083>/Greater  Than1'
         *  Sum: '<S5079>/Subtraction'
         *  UnitDelay: '<S5083>/Unit Delay'
         */
        rtb_RelationalOperator9_h = ((rtb_TmpSignalConversionAtVeTM_f >=
            (KeTHMR_dT_FCPsvCool_RadOpen_LSP + rtb_TmpSignalConversionAtVeT_ge))
            && (THMR_ac_DW.UnitDelay_DSTATE_mk));
    }

    /* End of Switch: '<S5083>/Switch1' */

    /* Update for UnitDelay: '<S5083>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_mk = rtb_RelationalOperator9_h;

    /* End of Outputs for SubSystem: '<S5079>/Hysteresis' */

    /* Logic: '<S5073>/Logical2' incorporates:
     *  Logic: '<S4116>/Logical1'
     *  Logic: '<S4598>/Logical5'
     *  Logic: '<S5091>/LogicalOperator'
     *  Logic: '<S5131>/Logical2'
     */
    rtb_TmpSignalConversionAtVeTR_k = !rtb_TmpSignalConversionAtVeB_cu;

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Logic: '<S5073>/Logical1' incorporates:
     *  Constant: '<S5075>/Constant'
     *  Constant: '<S5077>/Calib'
     *  Constant: '<S5078>/Calib'
     *  Constant: '<S5080>/Constant'
     *  Constant: '<S5081>/Constant'
     *  Constant: '<S5082>/Calib'
     *  Logic: '<S5073>/Logical2'
     *  Logic: '<S5073>/Logical3'
     *  Logic: '<S5073>/Logical4'
     *  Logic: '<S5073>/LogicalOperator'
     *  Logic: '<S5076>/LogicalOperator'
     *  Logic: '<S5076>/LogicalOperator1'
     *  RelationalOperator: '<S2689>/Comparison19'
     *  RelationalOperator: '<S5073>/RelationalOperator'
     *  RelationalOperator: '<S5076>/RelationalOperator'
     *  RelationalOperator: '<S5076>/RelationalOperator1'
     *  Switch: '<S2296>/Switch2'
     */
    VeTHMR_b_FC_BoostCool = (((((((VeTHMR_b_FCPsvCool_Req) &&
        ((CeFCRR_e_ShutDown == ((uint32)rtb_TmpSignalConversionAtVeFC_i)) ||
         ((((uint32)rtb_TmpSignalConversionAtVeFC_i) == CeFCRR_e_ExcessiveTemp) &&
          (KeTHMR_b_FCBoostCoolReq_ExcsvTemp)))) &&
        (rtb_TmpSignalConversionAtVeCT_c || (KeTHMR_b_IgnrDefrost4FCBoostCool)))
        && (CeTHMR_e_EmergencyLevel4 == ((uint32)VeTHMR_e_PPCTIS_OT_BD))) &&
        rtb_TmpSignalConversionAtVeTR_k) && (!KeTHMR_b_DsblFCBoostCool)) &&
        (!rtb_RelationalOperator9_h));

    /* Outputs for Atomic SubSystem: '<S5092>/Hysteresis' */
    /* Switch: '<S5096>/Switch1' incorporates:
     *  Constant: '<S5099>/Calib'
     *  RelationalOperator: '<S5096>/Greater  Than'
     *  Sum: '<S5092>/Subtraction1'
     */
    if (rtb_TmpSignalConversionAtVeF_n4 > (rtb_TmpSignalConversionAtVeFCRR +
            KeTHMR_dT_FCVlvCls_Stblz_RSP))
    {
        /* Switch: '<S5096>/Switch1' incorporates:
         *  Constant: '<S5096>/Constant Value'
         */
        rtb_RelationalOperator9_h = true;
    }
    else
    {
        /* Switch: '<S5096>/Switch1' incorporates:
         *  Constant: '<S5098>/Calib'
         *  RelationalOperator: '<S5096>/Greater  Than1'
         *  Sum: '<S5092>/Subtraction'
         *  UnitDelay: '<S5096>/Unit Delay'
         */
        rtb_RelationalOperator9_h = ((rtb_TmpSignalConversionAtVeF_n4 >=
            (KeTHMR_dT_FCVlvCls_Stblz_LSP + rtb_TmpSignalConversionAtVeFCRR)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_ci));
    }

    /* End of Switch: '<S5096>/Switch1' */

    /* Update for UnitDelay: '<S5096>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_ci = rtb_RelationalOperator9_h;

    /* End of Outputs for SubSystem: '<S5092>/Hysteresis' */

    /* Logic: '<S5092>/LogicalOperator' */
    rtb_RelationalOperator9_h = !rtb_RelationalOperator9_h;

    /* Outputs for Atomic SubSystem: '<S5092>/EdgeRising' */
    /* Logic: '<S5095>/AND' incorporates:
     *  Logic: '<S5095>/OR1'
     *  UnitDelay: '<S5095>/Unit Delay'
     */
    rtb_RelationalOperator3_aj = (rtb_RelationalOperator9_h &&
        (!THMR_ac_DW.UnitDelay_DSTATE_mb));

    /* Update for UnitDelay: '<S5095>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_mb = rtb_RelationalOperator9_h;

    /* End of Outputs for SubSystem: '<S5092>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S5092>/Turn On Delay Sample Resetable Delay' */
    /* Outputs for Atomic SubSystem: '<S5100>/EdgeRising with resetable delay' */
    /* Logic: '<S5101>/AND' incorporates:
     *  Logic: '<S5101>/OR1'
     *  UnitDelay: '<S5101>/Unit Delay'
     */
    rtb_AND_hz = (rtb_RelationalOperator9_h && (!THMR_ac_DW.UnitDelay_DSTATE_em));

    /* Switch: '<S5103>/Switch1' */
    if (rtb_RelationalOperator3_aj)
    {
        /* Update for UnitDelay: '<S5101>/Unit Delay' incorporates:
         *  Constant: '<S5101>/Constant1'
         *  Switch: '<S5103>/Switch1'
         */
        THMR_ac_DW.UnitDelay_DSTATE_em = false;
    }
    else
    {
        /* Update for UnitDelay: '<S5101>/Unit Delay' incorporates:
         *  Switch: '<S5103>/Switch1'
         *  UnitDelay: '<S5103>/Unit Delay'
         */
        THMR_ac_DW.UnitDelay_DSTATE_em = THMR_ac_DW.UnitDelay_DSTATE_ag;
    }

    /* End of Switch: '<S5103>/Switch1' */

    /* Update for UnitDelay: '<S5103>/Unit Delay' incorporates:
     *  Switch: '<S5103>/Switch3'
     */
    THMR_ac_DW.UnitDelay_DSTATE_ag = ((!rtb_RelationalOperator3_aj) &&
        rtb_RelationalOperator9_h);

    /* End of Outputs for SubSystem: '<S5100>/EdgeRising with resetable delay' */

    /* Switch: '<S5100>/Switch1' incorporates:
     *  Logic: '<S5100>/OR'
     *  Logic: '<S5100>/OR1'
     *  Switch: '<S5102>/Switch1'
     */
    if ((!rtb_RelationalOperator9_h) || rtb_AND_hz)
    {
        /* Switch: '<S5238>/Init' incorporates:
         *  Constant: '<S5100>/Constant Value1'
         */
        rtb_Switch_i3 = 0U;
    }
    else
    {
        if (rtb_RelationalOperator3_aj)
        {
            /* Switch: '<S5102>/Switch1' incorporates:
             *  Constant: '<S5100>/Constant Value'
             *  Constant: '<S5100>/Constant1'
             *  Sum: '<S5100>/Summation'
             */
            rtb_Switch_i3 = 1U;
        }
        else
        {
            /* Sum: '<S5100>/Summation' incorporates:
             *  Constant: '<S5100>/Constant Value'
             *  Switch: '<S5102>/Switch1'
             *  UnitDelay: '<S5102>/Unit Delay'
             */
            rtb_Switch_i3 = (uint16)(((uint32)THMR_ac_DW.UnitDelay_DSTATE_gna) +
                1U);
        }

        /* MinMax: '<S5100>/Minimum' incorporates:
         *  Constant: '<S5097>/Calib'
         */
        if (KeTHMR_Cnt_FCActvPsvHeatDbnc < rtb_Switch_i3)
        {
            /* Switch: '<S5238>/Init' */
            rtb_Switch_i3 = KeTHMR_Cnt_FCActvPsvHeatDbnc;
        }

        /* End of MinMax: '<S5100>/Minimum' */
    }

    /* End of Switch: '<S5100>/Switch1' */
    /* End of Outputs for SubSystem: '<S5092>/Turn On Delay Sample Resetable Delay' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeFCRR_b_FcHeatReq' */
    (void)Rte_Read_VeFCRR_b_FcHeatReq_Value(&rtb_OR1_b3);

    /* Inport: '<Root>/VePMIR_T_HTAuxPumpTemp' */
    (void)Rte_Read_VePMIR_T_HTAuxPumpTemp_Value(&rtb_Sum3);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Outputs for Atomic SubSystem: '<S5092>/Turn On Delay Sample Resetable Delay' */
    /* Switch: '<S5102>/Switch3' */
    if (rtb_RelationalOperator3_aj)
    {
        /* Update for UnitDelay: '<S5102>/Unit Delay' incorporates:
         *  Constant: '<S5100>/Constant1'
         */
        THMR_ac_DW.UnitDelay_DSTATE_gna = 0U;
    }
    else
    {
        /* Update for UnitDelay: '<S5102>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_gna = rtb_Switch_i3;
    }

    /* End of Switch: '<S5102>/Switch3' */
    /* End of Outputs for SubSystem: '<S5092>/Turn On Delay Sample Resetable Delay' */

    /* Logic: '<S5091>/LogicalOperator2' incorporates:
     *  Logic: '<S4099>/Logical8'
     *  Logic: '<S4107>/Logical3'
     *  Logic: '<S4733>/Logical15'
     *  Logic: '<S4918>/LogicalOperator2'
     *  Logic: '<S4919>/LogicalOperator2'
     */
    rtb_VariantMerge_For_Variant__j = !VeTHMR_b_ThrmlNotAllow_BattWallPwr_Limitd;

    /* Outputs for Atomic SubSystem: '<S5092>/Turn On Delay Sample Resetable Delay' */
    /* Logic: '<S5091>/Logical2' incorporates:
     *  Constant: '<S5093>/Calib'
     *  Constant: '<S5094>/Calib'
     *  Constant: '<S5097>/Calib'
     *  Logic: '<S5091>/Logical1'
     *  Logic: '<S5091>/LogicalOperator1'
     *  Logic: '<S5091>/LogicalOperator2'
     *  Logic: '<S5091>/LogicalOperator4'
     *  Logic: '<S5100>/AND'
     *  RelationalOperator: '<S5100>/Greater  Than'
     */
    VeTHMR_b_FC_ActvPsvHeat_Req = (((((((rtb_RelationalOperator9_h &&
        (rtb_Switch_i3 >= KeTHMR_Cnt_FCActvPsvHeatDbnc)) || rtb_OR1_b3) &&
        rtb_TmpSignalConversionAtPropSy) && (rtb_TmpSignalConversionAtVeTR_k ||
        (KeTHMR_b_IgnrBattCritFCActvPsvHeat))) &&
        rtb_VariantMerge_For_Variant__j) && rtb_TmpSignalConversionAtVeTR_i) &&
        (!KeTHMR_b_DsblFCActvPsvHeat));

    /* End of Outputs for SubSystem: '<S5092>/Turn On Delay Sample Resetable Delay' */

    /* If: '<S4573>/If1' incorporates:
     *  Constant: '<S4109>/Calib'
     *  Logic: '<S4573>/LogicalOperator'
     *  RelationalOperator: '<S4053>/RelationalOperator'
     */
    if (VeTHMR_b_FC_BoostCool)
    {
        /* Outputs for IfAction SubSystem: '<S4573>/BoostCooling' incorporates:
         *  ActionPort: '<S5105>/ActionPort'
         */
        /* Merge: '<S4573>/Merge2' incorporates:
         *  Constant: '<S5110>/Constant'
         *  SignalConversion generated from: '<S5105>/FC_ThrmlState'
         */
        THMR_ac_B.VeTHMR_e_FCThrmlState = CeTHMR_e_FCBoostCool;

        /* End of Outputs for SubSystem: '<S4573>/BoostCooling' */
    }
    else if (VeTHMR_b_FCPsvCool_Req)
    {
        /* Outputs for IfAction SubSystem: '<S4573>/PsvCool' incorporates:
         *  ActionPort: '<S5107>/ActionPort'
         */
        /* Merge: '<S4573>/Merge2' incorporates:
         *  Constant: '<S5112>/Constant'
         *  SignalConversion generated from: '<S5107>/FC_ThrmlState'
         */
        THMR_ac_B.VeTHMR_e_FCThrmlState = CeTHMR_e_FCPsvCool;

        /* End of Outputs for SubSystem: '<S4573>/PsvCool' */
    }
    else if (VeTHMR_b_FC_ActvPsvHeat_Req)
    {
        /* Outputs for IfAction SubSystem: '<S4573>/ActvPsvHeat' incorporates:
         *  ActionPort: '<S5104>/ActionPort'
         */
        /* Merge: '<S4573>/Merge2' incorporates:
         *  Constant: '<S5109>/Constant'
         *  SignalConversion generated from: '<S5104>/FC_ThrmlState'
         */
        THMR_ac_B.VeTHMR_e_FCThrmlState = CeTHMR_e_FCActvPsvHeat;

        /* End of Outputs for SubSystem: '<S4573>/ActvPsvHeat' */
    }
    else if (rtb_TmpSignalConversionAtPropSy || (rtb_TmpSignalConversionAtVeFCPR
              >= KeTHMR_P_FCMinOnPwr))
    {
        /* Outputs for IfAction SubSystem: '<S4573>/Stabilize' incorporates:
         *  ActionPort: '<S5108>/ActionPort'
         */
        /* Merge: '<S4573>/Merge2' incorporates:
         *  Constant: '<S5113>/Constant'
         *  SignalConversion generated from: '<S5108>/FC_ThrmlState'
         */
        THMR_ac_B.VeTHMR_e_FCThrmlState = CeTHMR_e_FCStabilize;

        /* End of Outputs for SubSystem: '<S4573>/Stabilize' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S4573>/Off' incorporates:
         *  ActionPort: '<S5106>/ActionPort'
         */
        /* Merge: '<S4573>/Merge2' incorporates:
         *  Constant: '<S5111>/Constant'
         *  SignalConversion generated from: '<S5106>/FC_ThrmlState'
         */
        THMR_ac_B.VeTHMR_e_FCThrmlState = CeTHMR_e_FCCondOff;

        /* End of Outputs for SubSystem: '<S4573>/Off' */
    }

    /* End of If: '<S4573>/If1' */

    /* Lookup_n-D: '<S4414>/Vector' incorporates:
     *  Lookup_n-D: '<S4418>/Vector'
     *  Lookup_n-D: '<S4475>/Vector'
     *  SignalConversion generated from: '<S2>/VeTAIR_Pct_HTL_BypsVlv_ActlPstn'
     *  Switch: '<S4416>/Switch1'
     */
    rtb_Switch1_d = look1_iflf_binlcapw(rtb_TmpSignalConversionAtVeT_dg, ((const
        float32 *)&(KxTHMR_Pct_HTCLPstnFlwpct[0])), ((const float32 *)
        &(KtTHMR_Pct_HTCLPstnFlwpct[0])), 8U);

    /* Abs: '<S4404>/Abs' incorporates:
     *  Abs: '<S4415>/Abs'
     *  Abs: '<S4470>/Abs'
     *  Constant: '<S4404>/Constant'
     *  Lookup_n-D: '<S4414>/Vector'
     *  Sum: '<S4404>/Add'
     *  Switch: '<S4416>/Switch1'
     */
    rtb_TmpSignalConversionAtVeT_j5 = fabsf(1.0F - rtb_Switch1_d);

    /* Sum: '<S4404>/Add1' incorporates:
     *  Abs: '<S4404>/Abs'
     *  Lookup_n-D: '<S4414>/Vector'
     *  Product: '<S4404>/Product'
     *  Product: '<S4404>/Product1'
     */
    VeTHMR_T_HCCTOS_Arb = (rtb_TmpSignalConversionAtVeT_j5 * rtb_Sum3) +
        (rtb_Switch1_d * rtb_TmpSignalConversionAtVePM_l);

    /* Switch: '<S4409>/Switch1' incorporates:
     *  Constant: '<S4405>/Constant1'
     *  Constant: '<S4405>/Constant2'
     *  Constant: '<S4406>/Constant1'
     *  Constant: '<S4406>/Constant2'
     *  Constant: '<S4407>/Constant1'
     *  Constant: '<S4407>/Constant2'
     *  Constant: '<S4411>/Calib'
     *  Constant: '<S4412>/Calib'
     *  Constant: '<S4413>/Calib'
     *  Logic: '<S4104>/Logical1'
     *  Logic: '<S4104>/Logical16'
     *  Logic: '<S4104>/Logical2'
     *  Logic: '<S4104>/Logical3'
     *  Logic: '<S4405>/Logical Operator'
     *  Logic: '<S4406>/Logical Operator'
     *  Logic: '<S4407>/Logical Operator'
     *  RelationalOperator: '<S4405>/Relational Operator1'
     *  RelationalOperator: '<S4405>/Relational Operator2'
     *  RelationalOperator: '<S4406>/Relational Operator1'
     *  RelationalOperator: '<S4406>/Relational Operator2'
     *  RelationalOperator: '<S4407>/Relational Operator1'
     *  RelationalOperator: '<S4407>/Relational Operator2'
     */
    if (((((tmp_e != 0U) && (tmp_f == 0U)) && (KeTHMR_b_Enbl_HCCTOS_CrctLow_flt))
         || (((tmp_g != 0U) && (tmp_h == 0U)) &&
             (KeTHMR_b_Enbl_HCCTOS_CrctHigh_flt))) || (((tmp_i != 0U) && (tmp_j ==
           0U)) && (KeTHMR_b_Enbl_HCCTOS_Rtnlty_flt)))
    {
        /* Switch: '<S4408>/Switch1' incorporates:
         *  Constant: '<S4410>/Calib'
         *  RelationalOperator: '<S4104>/RelationalOperator1'
         */
        if (rtb_TmpSignalConversionAtVeT_dg < KeTHMR_Pct_HTLVlvFullyOpen)
        {
            /* Switch: '<S4409>/Switch1' */
            rtb_TmpSignalConversionAtVePM_l = VeTHMR_T_HCCTOS_Arb;
        }

        /* End of Switch: '<S4408>/Switch1' */
    }
    else
    {
        /* Switch: '<S4409>/Switch1' */
        rtb_TmpSignalConversionAtVePM_l = rtb_TmpSignalConversionAtVeTR_h;
    }

    /* End of Switch: '<S4409>/Switch1' */

    /* Sum: '<S4470>/Add1' incorporates:
     *  Product: '<S4470>/Product'
     *  Product: '<S4470>/Product1'
     */
    VeTHMR_T_LTR_InletTemp = (rtb_TmpSignalConversionAtVeT_j5 *
        rtb_TmpSignalConversionAtVeTM_f) + (rtb_Switch1_d *
        rtb_TmpSignalConversionAtVePM_l);

    /* Switch: '<S4111>/Switch2' incorporates:
     *  Constant: '<S4474>/Calib'
     */
    if (KeTHMR_b_EnblLTRInTempArb)
    {
        /* Switch: '<S4111>/Switch1' incorporates:
         *  Constant: '<S4471>/Constant'
         *  Constant: '<S4473>/Calib'
         *  Merge: '<S4573>/Merge2'
         *  RelationalOperator: '<S4111>/RelationalOperator'
         *  RelationalOperator: '<S4111>/RelationalOperator1'
         *  Switch: '<S4472>/Switch1'
         */
        if (((uint32)THMR_ac_B.VeTHMR_e_FCThrmlState) == CeTHMR_e_FCBoostCool)
        {
            /* Switch: '<S4111>/Switch2' incorporates:
             *  Switch: '<S4111>/Switch1'
             */
            VeTHMR_T_LTRInletTemp = rtb_TmpSignalConversionAtVeT_ge;
        }
        else if (rtb_TmpSignalConversionAtVeT_dg >= KeTHMR_Pct_HTLVlvFullyOpen)
        {
            /* Switch: '<S4472>/Switch1' incorporates:
             *  Switch: '<S4111>/Switch1'
             *  Switch: '<S4111>/Switch2'
             */
            VeTHMR_T_LTRInletTemp = rtb_TmpSignalConversionAtVePM_l;
        }
        else
        {
            /* Switch: '<S4111>/Switch2' incorporates:
             *  Switch: '<S4111>/Switch1'
             *  Switch: '<S4472>/Switch1'
             */
            VeTHMR_T_LTRInletTemp = VeTHMR_T_LTR_InletTemp;
        }

        /* End of Switch: '<S4111>/Switch1' */
    }
    else
    {
        /* Switch: '<S4111>/Switch2' */
        VeTHMR_T_LTRInletTemp = rtb_TmpSignalConversionAtVeTM_f;
    }

    /* End of Switch: '<S4111>/Switch2' */

    /* Switch: '<S4478>/Switch1' incorporates:
     *  Constant: '<S4477>/Constant'
     *  Constant: '<S4484>/Calib'
     *  Constant: '<S4485>/Calib'
     *  DataStoreRead: '<S4477>/StatusByte_MtrElect_CT_SnsrPerf'
     *  Logic: '<S4112>/Logical5'
     *  Logic: '<S4112>/Logical6'
     *  Logic: '<S4112>/LogicalOperator'
     *  RelationalOperator: '<S4477>/RelationalOperator'
     *  S-Function (sfix_bitop): '<S4477>/BitwiseOperator7'
     *  Switch: '<S4112>/Switch1'
     */
    if ((((((sint32)THMR_ac_DW.StatusByte_MtrElect_CT_SnsrPerf) & 32) > 0) ||
            rtb_TmpSignalConversionAtVeTM_o) && (KeTHMR_b_PPCTIS_Fault_chk_Enbl))
    {
        /* Switch: '<S4478>/Switch1' incorporates:
         *  Constant: '<S4483>/Calib'
         *  Sum: '<S4112>/Sum'
         */
        THMR_ac_B.Switch1_j = rtb_TmpSignalConversionAtVeTM_f -
            KeTHMR_T_PECTOS_PPCTIS_Delta;
    }
    else if (!KeTHMR_b_EnblPPCTISArb)
    {
        /* Switch: '<S4478>/Switch1' incorporates:
         *  Switch: '<S4112>/Switch1'
         */
        THMR_ac_B.Switch1_j = rtb_TmpSignalConversionAtVeT_jp;
    }
    else
    {
        /* RelationalOperator: '<S4486>/RelationalOperator1' incorporates:
         *  RelationalOperator: '<S4486>/RelationalOperator2'
         *  RelationalOperator: '<S4486>/RelationalOperator3'
         *  Switch: '<S4112>/Switch1'
         *  UnitDelay: '<S4486>/UnitDelay2'
         */
        rtb_LogicalOperator_gg_tmp = THMR_ac_DW.UnitDelay2_DSTATE_gc;

        /* Switch: '<S4480>/Switch1' incorporates:
         *  Constant: '<S4481>/Calib'
         *  Constant: '<S4482>/Calib'
         *  Constant: '<S4488>/Constant'
         *  Constant: '<S4489>/Constant'
         *  Constant: '<S4490>/Constant'
         *  Logic: '<S4112>/Logical1'
         *  Logic: '<S4486>/LogicalOperator'
         *  RelationalOperator: '<S4112>/RelationalOperator'
         *  RelationalOperator: '<S4112>/RelationalOperator1'
         *  RelationalOperator: '<S4486>/RelationalOperator1'
         *  RelationalOperator: '<S4486>/RelationalOperator2'
         *  RelationalOperator: '<S4486>/RelationalOperator3'
         *  Switch: '<S4112>/Switch1'
         *  Switch: '<S4479>/Switch1'
         */
        if (((((uint32)rtb_LogicalOperator_gg_tmp) != CeTHMR_e_PassiveHeating) &&
             (((uint32)rtb_LogicalOperator_gg_tmp) != CeTHMR_e_PassiveCooling)) &&
            (((uint32)rtb_LogicalOperator_gg_tmp) != CeTHMR_e_ActvPsvHeating))
        {
            /* Switch: '<S4478>/Switch1' incorporates:
             *  Switch: '<S4480>/Switch1'
             */
            THMR_ac_B.Switch1_j = rtb_TmpSignalConversionAtVeT_jp;
        }
        else if ((rtb_TmpSignalConversionAtVeTAIR >=
                  KeTHMR_Pct_LTRVlvFullyClsd_Min) &&
                 (rtb_TmpSignalConversionAtVeTAIR <=
                  KeTHMR_Pct_LTRVlvFullyClsd_Max))
        {
            /* Switch: '<S4478>/Switch1' incorporates:
             *  Switch: '<S4479>/Switch1'
             *  Switch: '<S4480>/Switch1'
             */
            THMR_ac_B.Switch1_j = rtb_TmpSignalConversionAtVeTM_p;
        }
        else
        {
            /* Lookup_n-D: '<S4487>/Vector' incorporates:
             *  SignalConversion generated from: '<S2>/VeTAIR_Pct_LTR_BypsVlv_ActlPstn'
             *  Switch: '<S4479>/Switch1'
             */
            rtb_TmpSignalConversionAtVeTAIR = look1_iflf_binlcapw
                (rtb_TmpSignalConversionAtVeTAIR, ((const float32 *)
                  &(KxTHMR_Pct_LTCLPstnFlwpct[0])), ((const float32 *)
                  &(KtTHMR_Pct_LTCLPstnFlwpct[0])), 12U);

            /* Switch: '<S4478>/Switch1' incorporates:
             *  Abs: '<S4476>/Abs'
             *  Constant: '<S4476>/Constant'
             *  Product: '<S4476>/Product'
             *  Product: '<S4476>/Product1'
             *  Sum: '<S4476>/Add'
             *  Sum: '<S4476>/Add1'
             *  Switch: '<S4479>/Switch1'
             *  Switch: '<S4480>/Switch1'
             */
            THMR_ac_B.Switch1_j = (fabsf(1.0F - rtb_TmpSignalConversionAtVeTAIR)
                                   * rtb_TmpSignalConversionAtVeTM_p) +
                (rtb_TmpSignalConversionAtVeTAIR * VeTHMR_T_LTRInletTemp);
        }

        /* End of Switch: '<S4480>/Switch1' */
    }

    /* End of Switch: '<S4478>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S4814>/Hysteresis3' */
    /* Switch: '<S4842>/Switch1' incorporates:
     *  Constant: '<S4871>/Calib'
     *  RelationalOperator: '<S4842>/GreaterThan'
     *  Sum: '<S4814>/Subtract7'
     */
    if (rtb_TmpSignalConversionAtVeBT_k > (KeTHMR_dT_PsvPmpClntHys_RSP +
            THMR_ac_B.Switch1_j))
    {
        /* Switch: '<S4842>/Switch1' incorporates:
         *  Constant: '<S4842>/ConstantValue'
         */
        VeTHMR_b_BTIS_PPCTIS_TempChk = true;
    }
    else
    {
        /* Switch: '<S4842>/Switch1' incorporates:
         *  Constant: '<S4868>/Calib'
         *  RelationalOperator: '<S4842>/GreaterThan1'
         *  Sum: '<S4814>/Subtract3'
         *  UnitDelay: '<S4842>/UnitDelay'
         */
        VeTHMR_b_BTIS_PPCTIS_TempChk = ((rtb_TmpSignalConversionAtVeBT_k >=
            (THMR_ac_B.Switch1_j - KeTHMR_dT_PsvPmpClntHys)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_nk));
    }

    /* End of Switch: '<S4842>/Switch1' */

    /* Update for UnitDelay: '<S4842>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_nk = VeTHMR_b_BTIS_PPCTIS_TempChk;

    /* End of Outputs for SubSystem: '<S4814>/Hysteresis3' */

    /* Sum: '<S4814>/Subtract8' incorporates:
     *  Constant: '<S4861>/Calib'
     *  Sum: '<S4815>/Subtract3'
     */
    rtb_Switch10 = KeTHMR_dT_AmbTmpHys_BTIS_RSP +
        TmpSignalConversionAtOutAirTemp;

    /* Outputs for Atomic SubSystem: '<S4814>/Hysteresis5' */
    /* Switch: '<S4844>/Switch1' incorporates:
     *  RelationalOperator: '<S4844>/GreaterThan'
     *  Sum: '<S4814>/Subtract8'
     */
    if (rtb_TmpSignalConversionAtVeBT_k > rtb_Switch10)
    {
        /* Switch: '<S4844>/Switch1' incorporates:
         *  Constant: '<S4844>/ConstantValue'
         */
        VeTHMR_b_BTIS_Amb_TempChk = true;
    }
    else
    {
        /* Switch: '<S4844>/Switch1' incorporates:
         *  Constant: '<S4860>/Calib'
         *  RelationalOperator: '<S4844>/GreaterThan1'
         *  Sum: '<S4814>/Subtract6'
         *  UnitDelay: '<S4844>/UnitDelay'
         */
        VeTHMR_b_BTIS_Amb_TempChk = ((rtb_TmpSignalConversionAtVeBT_k >=
            (TmpSignalConversionAtOutAirTemp - KeTHMR_dT_AmbTmpHys_BTIS)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_fvv));
    }

    /* End of Switch: '<S4844>/Switch1' */

    /* Update for UnitDelay: '<S4844>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_fvv = VeTHMR_b_BTIS_Amb_TempChk;

    /* End of Outputs for SubSystem: '<S4814>/Hysteresis5' */

    /* RelationalOperator: '<S4736>/RelationalOperator' incorporates:
     *  Constant: '<S4812>/Calib'
     */
    rtb_RelationalOperator9_h = (rtb_TmpSignalConversionAtVePMPR >
        KeTHMR_dV_MinBTCLFlw4TempUpdt);

    /* Outputs for Atomic SubSystem: '<S4736>/Debounce2' */
    /* Outputs for Atomic SubSystem: '<S4801>/EdgeBi' */
    /* RelationalOperator: '<S4824>/NotEqual' incorporates:
     *  UnitDelay: '<S4824>/UnitDelay'
     */
    rtb_RelationalOperator3_aj = (rtb_RelationalOperator9_h !=
        THMR_ac_DW.UnitDelay_DSTATE_ji);

    /* Update for UnitDelay: '<S4824>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ji = rtb_RelationalOperator9_h;

    /* End of Outputs for SubSystem: '<S4801>/EdgeBi' */

    /* Logic: '<S4801>/Logical1' incorporates:
     *  UnitDelay: '<S4801>/UnitDelay1'
     */
    rtb_TmpSignalConversionAtVeTM_o = (rtb_RelationalOperator3_aj ||
        (THMR_ac_DW.UnitDelay1_DSTATE_kj));

    /* Outputs for Atomic SubSystem: '<S4801>/SignalLatchOnWithReset' */
    /* Logic: '<S4825>/OR1' incorporates:
     *  Logic: '<S4825>/NOT'
     *  Logic: '<S4825>/OR'
     *  UnitDelay: '<S4801>/UnitDelay3'
     *  UnitDelay: '<S4825>/UnitDelay'
     */
    rtb_OR1_b3 = ((THMR_ac_DW.UnitDelay3_DSTATE_pl) ||
                  ((!rtb_TmpSignalConversionAtVeTM_o) &&
                   (THMR_ac_DW.UnitDelay_DSTATE_p5)));

    /* Update for UnitDelay: '<S4825>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_p5 = rtb_OR1_b3;

    /* End of Outputs for SubSystem: '<S4801>/SignalLatchOnWithReset' */

    /* Switch: '<S4827>/Init' incorporates:
     *  Constant: '<S4827>/InitialCondition'
     *  Logic: '<S4827>/FixPtLogicalOperator'
     *  Logic: '<S4827>/Logical2'
     *  UnitDelay: '<S4827>/FixPtUnitDelay1'
     *  UnitDelay: '<S4827>/FixPtUnitDelay2'
     */
    if (rtb_TmpSignalConversionAtVeTM_o || (((sint32)
            THMR_ac_DW.FixPtUnitDelay2_DSTATE_d) == 0))
    {
        rtb_Switch_i3 = 0U;
    }
    else
    {
        rtb_Switch_i3 = THMR_ac_DW.FixPtUnitDelay1_DSTATE_c;
    }

    /* End of Switch: '<S4827>/Init' */

    /* Switch: '<S5238>/Init' incorporates:
     *  Sum: '<S4801>/Sum1'
     *  Switch: '<S4801>/Switch2'
     */
    rtb_Switch_i3 = (uint16)(((uint32)(rtb_OR1_b3 ? 1U : 0U)) + ((uint32)
        rtb_Switch_i3));

    /* RelationalOperator: '<S4801>/Equal1' incorporates:
     *  Constant: '<S4804>/Calib'
     */
    rtb_OR1_b3 = (((float32)rtb_Switch_i3) >= KeTHMR_Cnt_dbncBTCLFlw4TempUpdt);

    /* Switch: '<S4801>/Switch' */
    if (!rtb_OR1_b3)
    {
        /* Switch: '<S4826>/Init' incorporates:
         *  Logic: '<S4826>/Logical2'
         *  UnitDelay: '<S4826>/FixPtUnitDelay2'
         */
        if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_i) != 0)
        {
            /* Switch: '<S4801>/Switch' incorporates:
             *  UnitDelay: '<S4826>/FixPtUnitDelay1'
             */
            rtb_RelationalOperator9_h = THMR_ac_DW.FixPtUnitDelay1_DSTATE_f;
        }

        /* End of Switch: '<S4826>/Init' */
    }

    /* End of Switch: '<S4801>/Switch' */

    /* Update for UnitDelay: '<S4801>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_pl = rtb_RelationalOperator3_aj;

    /* Update for UnitDelay: '<S4801>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_kj = rtb_OR1_b3;

    /* Update for UnitDelay: '<S4827>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4827>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_d = 1U;

    /* Switch: '<S4827>/Reset' */
    if (rtb_TmpSignalConversionAtVeTM_o)
    {
        /* Update for UnitDelay: '<S4827>/FixPtUnitDelay1' incorporates:
         *  Constant: '<S4827>/InitialCondition'
         */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_c = 0U;
    }
    else
    {
        /* Update for UnitDelay: '<S4827>/FixPtUnitDelay1' */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_c = rtb_Switch_i3;
    }

    /* End of Switch: '<S4827>/Reset' */

    /* Update for UnitDelay: '<S4826>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4826>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_i = 1U;

    /* Update for UnitDelay: '<S4826>/FixPtUnitDelay1' */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE_f = rtb_RelationalOperator9_h;

    /* End of Outputs for SubSystem: '<S4736>/Debounce2' */

    /* Switch: '<S4847>/Switch1' */
    if (rtb_RelationalOperator9_h)
    {
        /* RelationalOperator: '<S4116>/RelationalOperator9' incorporates:
         *  Constant: '<S4849>/Calib'
         *  Constant: '<S4856>/Calib'
         *  Logic: '<S4814>/Logical12'
         *  Logic: '<S4814>/Logical13'
         *  Logic: '<S4814>/Logical5'
         */
        rtb_RelationalOperator9_h = (((VeTHMR_b_BTIS_PPCTIS_TempChk) ||
            (KeTHMR_b_PPCTIS_BTIS_Ovrrd)) && ((KeTHMR_b_AmbTmp_BTIS_Ovrrd) ||
            (VeTHMR_b_BTIS_Amb_TempChk)));
    }
    else
    {
        /* RelationalOperator: '<S4116>/RelationalOperator9' incorporates:
         *  Constant: '<S4814>/Constant'
         */
        rtb_RelationalOperator9_h = true;
    }

    /* End of Switch: '<S4847>/Switch1' */

    /* Sum: '<S4814>/Subtract10' incorporates:
     *  Constant: '<S4865>/Calib'
     *  Sum: '<S4815>/Subtract6'
     */
    rtb_Switch15 = KeTHMR_dT_AmbTmpHys_PPCTIS_RSP +
        TmpSignalConversionAtOutAirTemp;

    /* Outputs for Atomic SubSystem: '<S4814>/Hysteresis4' */
    /* Switch: '<S4843>/Switch1' incorporates:
     *  RelationalOperator: '<S4843>/GreaterThan'
     *  Sum: '<S4814>/Subtract10'
     */
    if (THMR_ac_B.Switch1_j > rtb_Switch15)
    {
        /* Switch: '<S4843>/Switch1' incorporates:
         *  Constant: '<S4843>/ConstantValue'
         */
        rtb_RelationalOperator3_aj = true;
    }
    else
    {
        /* Switch: '<S4843>/Switch1' incorporates:
         *  Constant: '<S4864>/Calib'
         *  RelationalOperator: '<S4843>/GreaterThan1'
         *  Sum: '<S4814>/Subtract9'
         *  UnitDelay: '<S4843>/UnitDelay'
         */
        rtb_RelationalOperator3_aj = ((THMR_ac_B.Switch1_j >=
            (TmpSignalConversionAtOutAirTemp - KeTHMR_dT_AmbTmpHys_PPCTIS)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_ll));
    }

    /* End of Switch: '<S4843>/Switch1' */

    /* Update for UnitDelay: '<S4843>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ll = rtb_RelationalOperator3_aj;

    /* End of Outputs for SubSystem: '<S4814>/Hysteresis4' */

    /* Sum: '<S4814>/Subtract2' incorporates:
     *  Constant: '<S4870>/Calib'
     *  Sum: '<S4815>/Subtract7'
     */
    rtb_TmpSignalConversionAtVeTAIR = KeTHMR_dT_PsvPmpClntHys_CellMaxRSP +
        THMR_ac_B.Switch1_j;

    /* Outputs for Atomic SubSystem: '<S4814>/Hysteresis1' */
    /* Switch: '<S4840>/Switch1' incorporates:
     *  RelationalOperator: '<S4840>/GreaterThan'
     *  Sum: '<S4814>/Subtract2'
     */
    if (rtb_TmpSignalConversionAtVeBTRR > rtb_TmpSignalConversionAtVeTAIR)
    {
        /* Switch: '<S4840>/Switch1' incorporates:
         *  Constant: '<S4840>/ConstantValue'
         */
        VeTHMR_b_CellMax_PPCTISChk = true;
    }
    else
    {
        /* Switch: '<S4840>/Switch1' incorporates:
         *  Constant: '<S4869>/Calib'
         *  RelationalOperator: '<S4840>/GreaterThan1'
         *  Sum: '<S4814>/Subtract1'
         *  UnitDelay: '<S4840>/UnitDelay'
         */
        VeTHMR_b_CellMax_PPCTISChk = ((rtb_TmpSignalConversionAtVeBTRR >=
            (THMR_ac_B.Switch1_j - KeTHMR_dT_PsvPmpClntHys_CellMaxLSP)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_d0));
    }

    /* End of Switch: '<S4840>/Switch1' */

    /* Update for UnitDelay: '<S4840>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_d0 = VeTHMR_b_CellMax_PPCTISChk;

    /* End of Outputs for SubSystem: '<S4814>/Hysteresis1' */

    /* RelationalOperator: '<S4814>/Comparison1' incorporates:
     *  RelationalOperator: '<S4597>/RelationalOperator1'
     *  RelationalOperator: '<S4626>/RelationalOperator3'
     *  RelationalOperator: '<S4688>/RelationalOperator3'
     *  RelationalOperator: '<S4765>/RelationalOperator'
     *  RelationalOperator: '<S4765>/RelationalOperator1'
     *  RelationalOperator: '<S4765>/RelationalOperator2'
     *  RelationalOperator: '<S4765>/RelationalOperator3'
     *  RelationalOperator: '<S4815>/Comparison1'
     *  UnitDelay: '<S4568>/UnitDelay'
     */
    rtb_LogicalOperator_gg_tmp = THMR_ac_DW.UnitDelay_DSTATE_jph;

    /* Outputs for Atomic SubSystem: '<S4814>/CountDownResetEnabled' */
    /* Switch: '<S4831>/Switch1' incorporates:
     *  Constant: '<S4831>/ConstantValue'
     *  Constant: '<S4834>/Constant'
     *  Logic: '<S4814>/Logical7'
     *  RelationalOperator: '<S4814>/Comparison1'
     *  RelationalOperator: '<S4831>/GreaterThan'
     *  Switch: '<S4831>/Switch2'
     *  UnitDelay: '<S4831>/UnitDelay'
     */
    if (((uint32)rtb_LogicalOperator_gg_tmp) != CeTHMR_e_PassiveCooling)
    {
        /* Switch: '<S4831>/Switch1' incorporates:
         *  Constant: '<S4848>/Calib'
         */
        rtb_Switch_i3 = KeTHMR_Cnt_PsvCool_Dbnc;
    }
    else if (((sint32)THMR_ac_DW.UnitDelay_DSTATE_iah) > 0)
    {
        /* Switch: '<S4831>/Switch2' incorporates:
         *  Constant: '<S4831>/ConstantValue1'
         *  Sum: '<S4831>/Subtraction'
         *  Switch: '<S4831>/Switch1'
         *  UnitDelay: '<S4831>/UnitDelay'
         */
        rtb_Switch_i3 = (uint16)((sint32)(((sint32)
            THMR_ac_DW.UnitDelay_DSTATE_iah) - 1));
    }
    else
    {
        /* Switch: '<S4831>/Switch1' incorporates:
         *  Switch: '<S4831>/Switch2'
         *  UnitDelay: '<S4831>/UnitDelay'
         */
        rtb_Switch_i3 = THMR_ac_DW.UnitDelay_DSTATE_iah;
    }

    /* End of Switch: '<S4831>/Switch1' */

    /* Update for UnitDelay: '<S4831>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_iah = rtb_Switch_i3;

    /* Logic: '<S4814>/Logical4' incorporates:
     *  Constant: '<S4831>/ConstantValue2'
     *  RelationalOperator: '<S4831>/GreaterThan1'
     */
    VeTHMR_b_BattPsvCoolDbnc = (((sint32)rtb_Switch_i3) <= 0);

    /* End of Outputs for SubSystem: '<S4814>/CountDownResetEnabled' */

    /* Sum: '<S4814>/Subtract5' incorporates:
     *  Constant: '<S4867>/Calib'
     *  Sum: '<S4815>/Subtract9'
     */
    rtb_Sum3 = KeTHMR_dT_BTIStHys_CellMaxRSP + rtb_TmpSignalConversionAtVeBT_k;

    /* Outputs for Atomic SubSystem: '<S4814>/Hysteresis2' */
    /* Switch: '<S4841>/Switch1' incorporates:
     *  RelationalOperator: '<S4841>/GreaterThan'
     *  Sum: '<S4814>/Subtract5'
     */
    if (rtb_TmpSignalConversionAtVeBTRR > rtb_Sum3)
    {
        /* Switch: '<S4841>/Switch1' incorporates:
         *  Constant: '<S4841>/ConstantValue'
         */
        VeTHMR_b_CellMax_BTISChk = true;
    }
    else
    {
        /* Switch: '<S4841>/Switch1' incorporates:
         *  Constant: '<S4866>/Calib'
         *  RelationalOperator: '<S4841>/GreaterThan1'
         *  Sum: '<S4814>/Subtract4'
         *  UnitDelay: '<S4841>/UnitDelay'
         */
        VeTHMR_b_CellMax_BTISChk = ((rtb_TmpSignalConversionAtVeBTRR >=
            (rtb_TmpSignalConversionAtVeBT_k - KeTHMR_dT_BTISHys_CellMaxLSP)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_cat));
    }

    /* End of Switch: '<S4841>/Switch1' */

    /* Update for UnitDelay: '<S4841>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_cat = VeTHMR_b_CellMax_BTISChk;

    /* End of Outputs for SubSystem: '<S4814>/Hysteresis2' */

    /* Outputs for Atomic SubSystem: '<S4814>/Hysteresis7' */
    /* Switch: '<S4846>/Switch1' incorporates:
     *  Constant: '<S4863>/Calib'
     *  RelationalOperator: '<S4846>/GreaterThan'
     *  Sum: '<S4814>/Subtract12'
     */
    if (rtb_TmpSignalConversionAtVeBTRR > (KeTHMR_dT_AmbTmpHys_CellMaxRSP +
            TmpSignalConversionAtOutAirTemp))
    {
        /* Switch: '<S4846>/Switch1' incorporates:
         *  Constant: '<S4846>/ConstantValue'
         */
        VeTHMR_b_CellMax_AmbTmpChk = true;
    }
    else
    {
        /* Switch: '<S4846>/Switch1' incorporates:
         *  Constant: '<S4862>/Calib'
         *  RelationalOperator: '<S4846>/GreaterThan1'
         *  Sum: '<S4814>/Subtract11'
         *  UnitDelay: '<S4846>/UnitDelay'
         */
        VeTHMR_b_CellMax_AmbTmpChk = ((rtb_TmpSignalConversionAtVeBTRR >=
            (TmpSignalConversionAtOutAirTemp - KeTHMR_dT_AmbTmpHys_CellMaxLSP)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_e0));
    }

    /* End of Switch: '<S4846>/Switch1' */

    /* Update for UnitDelay: '<S4846>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_e0 = VeTHMR_b_CellMax_AmbTmpChk;

    /* End of Outputs for SubSystem: '<S4814>/Hysteresis7' */

    /* Lookup_n-D: '<S4813>/Vector' incorporates:
     *  Switch: '<S3944>/Switch'
     */
    VeTHMR_T_AmbBasedOnVehSpd = look1_iflf_binlcapw(VeTHMR_v_Vehicle, ((const
        float32 *)&(KxTHMR_T_VehSpdBasedAmbTemp[0])), ((const float32 *)
        &(KtTHMR_T_VehSpdBasedAmbTemp[0])), 7U);

    /* Outputs for Atomic SubSystem: '<S4814>/Hysteresis6' */
    /* Switch: '<S4845>/Switch1' incorporates:
     *  Constant: '<S4874>/Calib'
     *  RelationalOperator: '<S4845>/GreaterThan'
     */
    if (VeTHMR_v_Vehicle > KeTHMR_v_VehSpd_DeemStopHyst)
    {
        /* Switch: '<S4845>/Switch1' incorporates:
         *  Constant: '<S4845>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeTM_o = true;
    }
    else
    {
        /* Switch: '<S4845>/Switch1' incorporates:
         *  Constant: '<S4873>/Calib'
         *  RelationalOperator: '<S4845>/GreaterThan1'
         *  UnitDelay: '<S4845>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeTM_o = ((VeTHMR_v_Vehicle >=
            KeTHMR_v_VehSpd_DeemStop) && (THMR_ac_DW.UnitDelay_DSTATE_l4));
    }

    /* End of Switch: '<S4845>/Switch1' */

    /* Update for UnitDelay: '<S4845>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_l4 = rtb_TmpSignalConversionAtVeTM_o;

    /* End of Outputs for SubSystem: '<S4814>/Hysteresis6' */

    /* Outputs for Atomic SubSystem: '<S4814>/EdgeRising' */
    /* Logic: '<S4833>/OR1' incorporates:
     *  UnitDelay: '<S4833>/UnitDelay'
     */
    rtb_OR1_b3 = !THMR_ac_DW.UnitDelay_DSTATE_p2;

    /* Update for UnitDelay: '<S4833>/UnitDelay' incorporates:
     *  Constant: '<S4814>/TRUEConstant'
     */
    THMR_ac_DW.UnitDelay_DSTATE_p2 = true;

    /* Outputs for Atomic SubSystem: '<S4814>/DigitalLowpassResetEnabled' */
    /* Switch: '<S4832>/Switch1' incorporates:
     *  Logic: '<S4833>/AND'
     */
    if (rtb_OR1_b3)
    {
        /* Switch: '<S4832>/Switch1' incorporates:
         *  Constant: '<S4814>/ConstantValue8'
         */
        rtb_TmpSignalConversionAtVeTM_p = 0.0F;
    }
    else
    {
        /* Switch: '<S4832>/Switch1' incorporates:
         *  Constant: '<S4872>/Calib'
         *  Product: '<S4832>/Multiplication'
         *  Sum: '<S4832>/Subtraction'
         *  Sum: '<S4832>/Summation'
         *  UnitDelay: '<S4832>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeTM_p = ((VeTHMR_I_ChrgCrntReqDelta_AD -
            THMR_ac_DW.UnitDelay_DSTATE_bv) * KeTHMR_k_ChrgCrntReq_Coeff) +
            THMR_ac_DW.UnitDelay_DSTATE_bv;
    }

    /* End of Switch: '<S4832>/Switch1' */
    /* End of Outputs for SubSystem: '<S4814>/EdgeRising' */

    /* Update for UnitDelay: '<S4832>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_bv = rtb_TmpSignalConversionAtVeTM_p;

    /* End of Outputs for SubSystem: '<S4814>/DigitalLowpassResetEnabled' */

    /* Logic: '<S4814>/Logical8' */
    rtb_OR1_b3 = !rtb_TmpSignalConversionAtVeTM_o;

    /* Outputs for Atomic SubSystem: '<S4814>/TimerResetTriggerEnabled1' */
    /* Outputs for Atomic SubSystem: '<S4881>/EdgeRising' */
    /* Logic: '<S4882>/AND' incorporates:
     *  Logic: '<S4882>/OR1'
     *  UnitDelay: '<S4882>/UnitDelay'
     */
    rtb_AND_hz = (rtb_OR1_b3 && (!THMR_ac_DW.UnitDelay_DSTATE_kn));

    /* Update for UnitDelay: '<S4882>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kn = rtb_OR1_b3;

    /* End of Outputs for SubSystem: '<S4881>/EdgeRising' */

    /* Switch: '<S4881>/Switch1' incorporates:
     *  Constant: '<S4881>/ConstantValue3'
     *  Logic: '<S4814>/Logical6'
     *  Logic: '<S4881>/AND1'
     *  RelationalOperator: '<S4881>/GreaterThan2'
     *  Switch: '<S4881>/Switch2'
     *  UnitDelay: '<S4881>/UnitDelay'
     */
    if (rtb_AND_hz && (THMR_ac_DW.UnitDelay_DSTATE_ca <= 0.0F))
    {
        /* Switch: '<S4881>/Switch1' incorporates:
         *  Constant: '<S4814>/ConstantValue2'
         *  Lookup_n-D: '<S4878>/Vector'
         *  Product: '<S4814>/Product'
         *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
         */
        rtb_TmpSignalConversionAtVePMPR = look1_iflf_binlcapw
            (TmpSignalConversionAtOutAirTemp, ((const float32 *)
              &(KxTHMR_t_AmbTempBasedPsvDuration[0])), ((const float32 *)
              &(KtTHMR_t_AmbTempBasedPsvDuration[0])), 6U) * 60.0F;
    }
    else if (!rtb_TmpSignalConversionAtVeTM_o)
    {
        /* Switch: '<S4881>/Switch2' incorporates:
         *  Constant: '<S4814>/ConstantValue3'
         *  Constant: '<S4881>/ConstantValue4'
         *  MinMax: '<S4881>/Maximum'
         *  Sum: '<S4881>/Subtraction'
         *  Switch: '<S4881>/Switch1'
         */
        rtb_TmpSignalConversionAtVePMPR = fmaxf(THMR_ac_DW.UnitDelay_DSTATE_ca -
            0.1F, 0.0F);
    }
    else
    {
        /* Switch: '<S4881>/Switch1' incorporates:
         *  Switch: '<S4881>/Switch2'
         */
        rtb_TmpSignalConversionAtVePMPR = THMR_ac_DW.UnitDelay_DSTATE_ca;
    }

    /* End of Switch: '<S4881>/Switch1' */

    /* Update for UnitDelay: '<S4881>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ca = rtb_TmpSignalConversionAtVePMPR;

    /* End of Outputs for SubSystem: '<S4814>/TimerResetTriggerEnabled1' */

    /* Switch: '<S4814>/Switch1' incorporates:
     *  Switch: '<S4814>/Switch'
     */
    if (rtb_TmpSignalConversionAtVeTM_o)
    {
        /* Switch: '<S4814>/Switch1' incorporates:
         *  RelationalOperator: '<S4814>/Comparison2'
         */
        VeTHMR_b_AmbChk_PsvCool = (TmpSignalConversionAtOutAirTemp <=
            VeTHMR_T_AmbBasedOnVehSpd);
    }
    else if (VeTHMR_b_PlugdIn_Or_Chrg)
    {
        /* Switch: '<S4879>/Switch1' incorporates:
         *  Constant: '<S4814>/ConstantValue1'
         *  Constant: '<S4814>/ConstantValue5'
         *  Constant: '<S4828>/Constant'
         *  Constant: '<S4829>/Constant'
         *  Constant: '<S4830>/Constant'
         *  RelationalOperator: '<S4814>/Comparison10'
         *  RelationalOperator: '<S4814>/Comparison5'
         *  RelationalOperator: '<S4814>/Comparison6'
         *  Switch: '<S4814>/Switch'
         *  Switch: '<S4879>/Switch2'
         *  Switch: '<S4879>/Switch3'
         *  Switch: '<S49>/Switch'
         */
        if (((uint32)VeTHMR_e_ChargingLevel_AD) == CeOBCR_e_ChargingLvlAC1)
        {
            rtb_TmpSignalConversionAtVePMPR = 1.0F;
        }
        else if (((uint32)VeTHMR_e_ChargingLevel_AD) == CeOBCR_e_ChargingLvlAC2)
        {
            /* Switch: '<S4879>/Switch2' incorporates:
             *  Constant: '<S4814>/ConstantValue4'
             */
            rtb_TmpSignalConversionAtVePMPR = 2.0F;
        }
        else if (((uint32)VeTHMR_e_ChargingLevel_AD) == CeOBCR_e_ChargingLvlDC2)
        {
            /* Switch: '<S4879>/Switch3' incorporates:
             *  Constant: '<S4814>/ConstantValue7'
             *  Switch: '<S4879>/Switch2'
             */
            rtb_TmpSignalConversionAtVePMPR = 3.0F;
        }
        else
        {
            rtb_TmpSignalConversionAtVePMPR = 0.0F;
        }

        /* End of Switch: '<S4879>/Switch1' */

        /* Switch: '<S4880>/Switch2' incorporates:
         *  Constant: '<S4814>/ConstantValue13'
         *  Constant: '<S4814>/ConstantValue9'
         *  Constant: '<S4835>/Constant'
         *  Constant: '<S4836>/Constant'
         *  Constant: '<S4838>/Constant'
         *  Constant: '<S4839>/Constant'
         *  RelationalOperator: '<S4814>/Comparison12'
         *  RelationalOperator: '<S4814>/Comparison13'
         *  RelationalOperator: '<S4814>/Comparison14'
         *  RelationalOperator: '<S4814>/Comparison15'
         *  Switch: '<S4814>/Switch'
         *  Switch: '<S4880>/Switch3'
         *  Switch: '<S4880>/Switch4'
         *  Switch: '<S4880>/Switch5'
         *  Switch: '<S4880>/Switch6'
         *  Switch: '<S49>/Switch2'
         */
        if (((uint32)VeTHMR_e_PwrLevSet_AD) == CeOBCR_e_PwrLimReq_Min)
        {
            rtb_TmpSignalConversionAtVeHT_h = 20.0F;
        }
        else if (((uint32)VeTHMR_e_PwrLevSet_AD) == CeOBCR_e_PwrLimReq_Slow)
        {
            /* Switch: '<S4880>/Switch3' incorporates:
             *  Constant: '<S4814>/ConstantValue10'
             */
            rtb_TmpSignalConversionAtVeHT_h = 40.0F;
        }
        else if (((uint32)VeTHMR_e_PwrLevSet_AD) == CeOBCR_e_PwrLimReq_Reduced)
        {
            /* Switch: '<S4880>/Switch4' incorporates:
             *  Constant: '<S4814>/ConstantValue11'
             *  Switch: '<S4880>/Switch3'
             */
            rtb_TmpSignalConversionAtVeHT_h = 60.0F;
        }
        else if (((uint32)VeTHMR_e_PwrLevSet_AD) == CeOBCR_e_PwrLimReq_Quick)
        {
            /* Switch: '<S4880>/Switch5' incorporates:
             *  Constant: '<S4814>/ConstantValue12'
             *  Switch: '<S4880>/Switch3'
             *  Switch: '<S4880>/Switch4'
             */
            rtb_TmpSignalConversionAtVeHT_h = 80.0F;
        }
        else
        {
            rtb_TmpSignalConversionAtVeHT_h = 100.0F;
        }

        /* End of Switch: '<S4880>/Switch2' */

        /* Switch: '<S4814>/Switch1' incorporates:
         *  Constant: '<S4858>/Calib'
         *  Constant: '<S4859>/Calib'
         *  Logic: '<S4814>/Logical10'
         *  Logic: '<S4814>/Logical11'
         *  Logic: '<S4814>/Logical9'
         *  Lookup_n-D: '<S4875>/Vector'
         *  Lookup_n-D: '<S4876>/Vector'
         *  Product: '<S4814>/Product1'
         *  RelationalOperator: '<S4814>/Comparison3'
         *  RelationalOperator: '<S4814>/Comparison8'
         *  Switch: '<S4814>/Switch'
         */
        VeTHMR_b_AmbChk_PsvCool = (((TmpSignalConversionAtOutAirTemp <=
            look2_iflf_binlcapw(rtb_TmpSignalConversionAtVePMPR,
                                rtb_TmpSignalConversionAtVeHT_h, ((const float32
            *)&(KxTHMR_T_ChrgLvlBasedAmbTemp[0])), ((const float32 *)
            &(KyTHMR_T_ChrgLvlBasedAmbTemp[0])), ((const float32 *)
            &(KtTHMR_T_ChrgLvlBasedAmbTemp[0])), THMR_ac_ConstP.pooled40, 3U)) &&
            (KeTHMR_b_PsvCool_ChrgLvlAmbTemp_Enb)) ||
            ((KeTHMR_b_PsvCool_ChrgPwrReqAmbTemp_Enb) &&
             (TmpSignalConversionAtOutAirTemp <= look1_iflf_binlcapw
              (VeTHMR_U_HV_BatVolt_AD * rtb_TmpSignalConversionAtVeTM_p, ((const
            float32 *)&(KxTHMR_T_ChrgPwrReqBasedAmbTemp[0])), ((const float32 *)
            &(KtTHMR_T_ChrgPwrReqBasedAmbTemp[0])), 9U))));
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S4814>/TimerResetTriggerEnabled1' */
        /* Switch: '<S4814>/Switch1' incorporates:
         *  Constant: '<S4881>/ConstantValue2'
         *  RelationalOperator: '<S4881>/GreaterThan1'
         *  Switch: '<S4814>/Switch'
         */
        VeTHMR_b_AmbChk_PsvCool = (rtb_TmpSignalConversionAtVePMPR > 0.0F);

        /* End of Outputs for SubSystem: '<S4814>/TimerResetTriggerEnabled1' */
    }

    /* End of Switch: '<S4814>/Switch1' */

    /* Logic: '<S4814>/Logical2' incorporates:
     *  Constant: '<S4850>/Calib'
     *  Constant: '<S4851>/Calib'
     *  Constant: '<S4852>/Calib'
     *  Constant: '<S4853>/Calib'
     *  Constant: '<S4854>/Calib'
     *  Constant: '<S4855>/Calib'
     *  Constant: '<S4857>/Calib'
     *  Logic: '<S4814>/Logical1'
     *  Logic: '<S4814>/Logical14'
     *  Logic: '<S4814>/Logical15'
     *  Logic: '<S4814>/Logical16'
     *  Logic: '<S4814>/Logical17'
     *  Logic: '<S4814>/Logical18'
     *  Logic: '<S4814>/Logical19'
     *  Logic: '<S4814>/Logical3'
     *  Lookup_n-D: '<S4877>/Vector'
     *  RelationalOperator: '<S4814>/Comparison4'
     *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
     *  SignalConversion generated from: '<S2>/VeBTRR_T_CellTempMaxUsed'
     */
    VeTHMR_b_PsvCool_Cond1 = ((((((rtb_RelationalOperator9_h &&
        ((KeTHMR_b_AmbTmp_PPCTIS_Ovrrd) || rtb_RelationalOperator3_aj)) &&
        (((KeTHMR_b_PPCTIS_CellMax_Enbl) && (VeTHMR_b_CellMax_PPCTISChk)) ||
         (((VeTHMR_b_BattPsvCoolDbnc) || (KeTHMR_b_BattPsvCool_Dbnc_Ovrrd)) &&
          ((VeTHMR_b_CellMax_BTISChk) || (KeTHMR_b_BTIS_CellMax_Ovrrd))))) &&
        (KeTHMR_b_Enbl_BTISHiChk_PsvCool)) &&
        ((KeTHMR_b_BattPsvCool_BTISMaxAllwd_Ovrrd) ||
         (rtb_TmpSignalConversionAtVeBT_k < look2_iflf_binlcapw
          (rtb_TmpSignalConversionAtVeBTRR, TmpSignalConversionAtOutAirTemp, ((
        const float32 *)&(KxTHMR_T_PsvCool_BTISMaxAllwd[0])), ((const float32 *)
        &(KyTHMR_T_PsvCool_BTISMaxAllwd[0])), ((const float32 *)
        &(KtTHMR_T_PsvCool_BTISMaxAllwd[0])), THMR_ac_ConstP.pooled40, 3U)))) &&
        ((KeTHMR_b_AmbTmp_CellMax_Ovrrd) || (VeTHMR_b_CellMax_AmbTmpChk))) &&
        (VeTHMR_b_AmbChk_PsvCool));

    /* Switch: '<S4571>/Switch' incorporates:
     *  Sum: '<S4815>/Subtract1'
     */
    rtb_TmpSignalConversionAtVeTM_p = THMR_ac_B.Switch1_j -
        rtb_TmpSignalConversionAtVeBT_k;

    /* Switch: '<S4905>/Switch1' incorporates:
     *  Constant: '<S4905>/ConstantValue2'
     *  RelationalOperator: '<S4905>/Comparison1'
     */
    if (rtb_TmpSignalConversionAtVeTM_p < 0.0F)
    {
        /* Switch: '<S4905>/Switch1' incorporates:
         *  Constant: '<S4906>/Calib'
         */
        rtb_TmpSignalConversionAtVeTM_p = KeTHMR_T_ClntTmpDiff;
    }

    /* End of Switch: '<S4905>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S4815>/Hysteresis5' */
    /* Switch: '<S4889>/Switch1' incorporates:
     *  Constant: '<S4901>/Calib'
     *  RelationalOperator: '<S4889>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeTM_p > KeTHMR_dT_BTISTmpHys_PsvClnt_RSP)
    {
        /* Switch: '<S4889>/Switch1' incorporates:
         *  Constant: '<S4889>/ConstantValue'
         */
        rtb_RelationalOperator9_h = true;
    }
    else
    {
        /* Switch: '<S4889>/Switch1' incorporates:
         *  Constant: '<S4900>/Calib'
         *  RelationalOperator: '<S4889>/GreaterThan1'
         *  UnitDelay: '<S4889>/UnitDelay'
         */
        rtb_RelationalOperator9_h = ((rtb_TmpSignalConversionAtVeTM_p >=
            KeTHMR_dT_BTISTmpHys_PsvClnt_LSP) && (THMR_ac_DW.UnitDelay_DSTATE_nw));
    }

    /* End of Switch: '<S4889>/Switch1' */

    /* Update for UnitDelay: '<S4889>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_nw = rtb_RelationalOperator9_h;

    /* End of Outputs for SubSystem: '<S4815>/Hysteresis5' */

    /* Logic: '<S4815>/Logical6' incorporates:
     *  Constant: '<S4891>/Calib'
     *  Constant: '<S4894>/Calib'
     *  Logic: '<S4815>/Logical8'
     *  Logic: '<S4815>/Logical9'
     *  RelationalOperator: '<S4815>/Comparison3'
     */
    VeTHMR_b_PPCTIS_BTIS_TempChk = ((!rtb_RelationalOperator9_h) ||
        ((rtb_TmpSignalConversionAtVeTM_p < KeTHMR_T_ClntTmpDiff) &&
         (KeTHMR_b_EnblTmpDiff_PPCTIS_BTIS)));

    /* Outputs for Atomic SubSystem: '<S4815>/Hysteresis1' */
    /* Switch: '<S4885>/Switch1' incorporates:
     *  RelationalOperator: '<S4885>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeBT_k > rtb_Switch10)
    {
        /* Switch: '<S4885>/Switch1' incorporates:
         *  Constant: '<S4885>/ConstantValue'
         */
        rtb_RelationalOperator9_h = true;
    }
    else
    {
        /* Switch: '<S4885>/Switch1' incorporates:
         *  Constant: '<S4895>/Calib'
         *  RelationalOperator: '<S4885>/GreaterThan1'
         *  Sum: '<S4815>/Subtract4'
         *  UnitDelay: '<S4885>/UnitDelay'
         */
        rtb_RelationalOperator9_h = ((rtb_TmpSignalConversionAtVeBT_k >=
            (TmpSignalConversionAtOutAirTemp - KeTHMR_dT_AmbTmpHys_BTIS)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_j04));
    }

    /* End of Switch: '<S4885>/Switch1' */

    /* Update for UnitDelay: '<S4885>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_j04 = rtb_RelationalOperator9_h;

    /* End of Outputs for SubSystem: '<S4815>/Hysteresis1' */

    /* Outputs for Atomic SubSystem: '<S4815>/Hysteresis4' */
    /* Switch: '<S4888>/Switch1' incorporates:
     *  RelationalOperator: '<S4888>/GreaterThan'
     */
    if (THMR_ac_B.Switch1_j > rtb_Switch15)
    {
        /* Switch: '<S4888>/Switch1' incorporates:
         *  Constant: '<S4888>/ConstantValue'
         */
        VeTHMR_b_PPCTIS_Amb_TempChk = true;
    }
    else
    {
        /* Switch: '<S4888>/Switch1' incorporates:
         *  Constant: '<S4897>/Calib'
         *  RelationalOperator: '<S4888>/GreaterThan1'
         *  Sum: '<S4815>/Subtract5'
         *  UnitDelay: '<S4888>/UnitDelay'
         */
        VeTHMR_b_PPCTIS_Amb_TempChk = ((THMR_ac_B.Switch1_j >=
            (TmpSignalConversionAtOutAirTemp - KeTHMR_dT_AmbTmpHys_PPCTIS)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_kr));
    }

    /* End of Switch: '<S4888>/Switch1' */

    /* Update for UnitDelay: '<S4888>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kr = VeTHMR_b_PPCTIS_Amb_TempChk;

    /* End of Outputs for SubSystem: '<S4815>/Hysteresis4' */

    /* Outputs for Atomic SubSystem: '<S4815>/Hysteresis2' */
    /* Switch: '<S4886>/Switch1' incorporates:
     *  RelationalOperator: '<S4886>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeBTRR > rtb_TmpSignalConversionAtVeTAIR)
    {
        /* Switch: '<S4886>/Switch1' incorporates:
         *  Constant: '<S4886>/ConstantValue'
         */
        rtb_RelationalOperator3_aj = true;
    }
    else
    {
        /* Switch: '<S4886>/Switch1' incorporates:
         *  Constant: '<S4903>/Calib'
         *  RelationalOperator: '<S4886>/GreaterThan1'
         *  Sum: '<S4815>/Subtract2'
         *  UnitDelay: '<S4886>/UnitDelay'
         */
        rtb_RelationalOperator3_aj = ((rtb_TmpSignalConversionAtVeBTRR >=
            (THMR_ac_B.Switch1_j - KeTHMR_dT_PsvPmpClntHys_CellMaxLSP)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_gs));
    }

    /* End of Switch: '<S4886>/Switch1' */

    /* Update for UnitDelay: '<S4886>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_gs = rtb_RelationalOperator3_aj;

    /* End of Outputs for SubSystem: '<S4815>/Hysteresis2' */

    /* Outputs for Atomic SubSystem: '<S4815>/CountDownResetEnabled' */
    /* Switch: '<S4883>/Switch1' incorporates:
     *  Constant: '<S4883>/ConstantValue'
     *  Constant: '<S4884>/Constant'
     *  Logic: '<S4815>/Logical7'
     *  RelationalOperator: '<S4815>/Comparison1'
     *  RelationalOperator: '<S4883>/GreaterThan'
     *  Switch: '<S4883>/Switch2'
     *  UnitDelay: '<S4883>/UnitDelay'
     */
    if (((uint32)rtb_LogicalOperator_gg_tmp) != CeTHMR_e_PassiveCooling)
    {
        /* Switch: '<S4883>/Switch1' incorporates:
         *  Constant: '<S4890>/Calib'
         */
        rtb_Switch_i3 = KeTHMR_Cnt_PsvCool_Dbnc;
    }
    else if (((sint32)THMR_ac_DW.UnitDelay_DSTATE_gt) > 0)
    {
        /* Switch: '<S4883>/Switch2' incorporates:
         *  Constant: '<S4883>/ConstantValue1'
         *  Sum: '<S4883>/Subtraction'
         *  Switch: '<S4883>/Switch1'
         *  UnitDelay: '<S4883>/UnitDelay'
         */
        rtb_Switch_i3 = (uint16)((sint32)(((sint32)
            THMR_ac_DW.UnitDelay_DSTATE_gt) - 1));
    }
    else
    {
        /* Switch: '<S4883>/Switch1' incorporates:
         *  Switch: '<S4883>/Switch2'
         *  UnitDelay: '<S4883>/UnitDelay'
         */
        rtb_Switch_i3 = THMR_ac_DW.UnitDelay_DSTATE_gt;
    }

    /* End of Switch: '<S4883>/Switch1' */

    /* Update for UnitDelay: '<S4883>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_gt = rtb_Switch_i3;

    /* End of Outputs for SubSystem: '<S4815>/CountDownResetEnabled' */

    /* Outputs for Atomic SubSystem: '<S4815>/Hysteresis3' */
    /* Switch: '<S4887>/Switch1' incorporates:
     *  RelationalOperator: '<S4887>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeBTRR > rtb_Sum3)
    {
        /* Switch: '<S4887>/Switch1' incorporates:
         *  Constant: '<S4887>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeTM_o = true;
    }
    else
    {
        /* Switch: '<S4887>/Switch1' incorporates:
         *  Constant: '<S4899>/Calib'
         *  RelationalOperator: '<S4887>/GreaterThan1'
         *  Sum: '<S4815>/Subtract8'
         *  UnitDelay: '<S4887>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeTM_o = ((rtb_TmpSignalConversionAtVeBTRR >=
            (rtb_TmpSignalConversionAtVeBT_k - KeTHMR_dT_BTISHys_CellMaxLSP)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_ma));
    }

    /* End of Switch: '<S4887>/Switch1' */

    /* Update for UnitDelay: '<S4887>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ma = rtb_TmpSignalConversionAtVeTM_o;

    /* End of Outputs for SubSystem: '<S4815>/Hysteresis3' */

    /* Outputs for Atomic SubSystem: '<S4815>/CountDownResetEnabled' */
    /* Logic: '<S4815>/Logical1' incorporates:
     *  Constant: '<S4883>/ConstantValue2'
     *  Constant: '<S4892>/Calib'
     *  Constant: '<S4893>/Calib'
     *  Logic: '<S4815>/Logical2'
     *  Logic: '<S4815>/Logical3'
     *  Logic: '<S4815>/Logical4'
     *  Logic: '<S4815>/Logical5'
     *  RelationalOperator: '<S4815>/Comparison2'
     *  RelationalOperator: '<S4883>/GreaterThan1'
     */
    VeTHMR_b_PsvCool_Cond2 = ((((((VeTHMR_b_PPCTIS_BTIS_TempChk) &&
        rtb_RelationalOperator9_h) && (VeTHMR_b_PPCTIS_Amb_TempChk)) &&
        ((TmpSignalConversionAtOutAirTemp <= VeTHMR_T_AmbBasedOnVehSpd) ||
         (KeTHMR_b_DsblAmbChk_PsvCool))) && (rtb_RelationalOperator3_aj ||
        ((((sint32)rtb_Switch_i3) <= 0) && rtb_TmpSignalConversionAtVeTM_o))) &&
        (KeTHMR_b_EnblBattPsvClngChck2));

    /* End of Outputs for SubSystem: '<S4815>/CountDownResetEnabled' */

    /* Outputs for Atomic SubSystem: '<S4818>/Hysteresis6' */
    /* Switch: '<S4911>/Switch1' incorporates:
     *  Constant: '<S4913>/Calib'
     *  RelationalOperator: '<S4911>/GreaterThan'
     */
    if (THMR_ac_B.Switch1_j > KeTHMR_T_PPCTIS_RSPTh_PsvCool)
    {
        /* Switch: '<S4911>/Switch1' incorporates:
         *  Constant: '<S4911>/ConstantValue'
         */
        rtb_RelationalOperator9_h = true;
    }
    else
    {
        /* Switch: '<S4911>/Switch1' incorporates:
         *  Constant: '<S4912>/Calib'
         *  RelationalOperator: '<S4911>/GreaterThan1'
         *  UnitDelay: '<S4911>/UnitDelay'
         */
        rtb_RelationalOperator9_h = ((THMR_ac_B.Switch1_j >=
            KeTHMR_T_PPCTIS_LSPTh_PsvCool) && (THMR_ac_DW.UnitDelay_DSTATE_pf));
    }

    /* End of Switch: '<S4911>/Switch1' */

    /* Update for UnitDelay: '<S4911>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_pf = rtb_RelationalOperator9_h;

    /* End of Outputs for SubSystem: '<S4818>/Hysteresis6' */

    /* Logic: '<S4818>/Logical13' */
    VeTHMR_b_LowPPCTIS_PsvCool = !rtb_RelationalOperator9_h;

    /* Logic: '<S4736>/Logical4' incorporates:
     *  Constant: '<S4914>/Calib'
     *  Logic: '<S4818>/Logical12'
     *  RelationalOperator: '<S4818>/Comparison1'
     */
    rtb_VariantMerge_For_Variant__m = (((VeTHMR_b_PsvCool_Cond1) ||
        (VeTHMR_b_PsvCool_Cond2)) || (((TmpSignalConversionAtOutAirTemp <=
        VeTHMR_T_AmbBasedOnVehSpd) && (VeTHMR_b_LowPPCTIS_PsvCool)) &&
        (KeTHMR_b_Enbl_LTLAmb_PsvCool)));

    /* Outputs for Atomic SubSystem: '<S4736>/Debounce1' */
    /* Outputs for Atomic SubSystem: '<S4800>/EdgeBi' */
    /* RelationalOperator: '<S4820>/NotEqual' incorporates:
     *  UnitDelay: '<S4820>/UnitDelay'
     */
    rtb_RelationalOperator9_h = (rtb_VariantMerge_For_Variant__m !=
        THMR_ac_DW.UnitDelay_DSTATE_j2);

    /* Update for UnitDelay: '<S4820>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_j2 = rtb_VariantMerge_For_Variant__m;

    /* End of Outputs for SubSystem: '<S4800>/EdgeBi' */

    /* Logic: '<S4800>/Logical1' incorporates:
     *  UnitDelay: '<S4800>/UnitDelay1'
     */
    rtb_RelationalOperator3_aj = (rtb_RelationalOperator9_h ||
        (THMR_ac_DW.UnitDelay1_DSTATE_fd));

    /* Outputs for Atomic SubSystem: '<S4800>/SignalLatchOnWithReset' */
    /* Logic: '<S4821>/OR1' incorporates:
     *  Logic: '<S4821>/NOT'
     *  Logic: '<S4821>/OR'
     *  UnitDelay: '<S4800>/UnitDelay3'
     *  UnitDelay: '<S4821>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeTM_o = ((THMR_ac_DW.UnitDelay3_DSTATE_c) ||
        ((!rtb_RelationalOperator3_aj) && (THMR_ac_DW.UnitDelay_DSTATE_cw)));

    /* Update for UnitDelay: '<S4821>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_cw = rtb_TmpSignalConversionAtVeTM_o;

    /* End of Outputs for SubSystem: '<S4800>/SignalLatchOnWithReset' */

    /* Switch: '<S4823>/Init' incorporates:
     *  Constant: '<S4823>/InitialCondition'
     *  Logic: '<S4823>/FixPtLogicalOperator'
     *  Logic: '<S4823>/Logical2'
     *  UnitDelay: '<S4823>/FixPtUnitDelay1'
     *  UnitDelay: '<S4823>/FixPtUnitDelay2'
     */
    if (rtb_RelationalOperator3_aj || (((sint32)
            THMR_ac_DW.FixPtUnitDelay2_DSTATE_hp) == 0))
    {
        rtb_Switch_i3 = 0U;
    }
    else
    {
        rtb_Switch_i3 = THMR_ac_DW.FixPtUnitDelay1_DSTATE_d0;
    }

    /* End of Switch: '<S4823>/Init' */

    /* Switch: '<S5238>/Init' incorporates:
     *  Sum: '<S4800>/Sum1'
     *  Switch: '<S4800>/Switch2'
     */
    rtb_Switch_i3 = (uint16)(((uint32)(rtb_TmpSignalConversionAtVeTM_o ? 1U : 0U))
        + ((uint32)rtb_Switch_i3));

    /* RelationalOperator: '<S4800>/Equal1' incorporates:
     *  Constant: '<S4803>/Calib'
     */
    rtb_TmpSignalConversionAtVeTM_o = (((float32)rtb_Switch_i3) >=
        KeTHMR_Cnt_BattPsvCoolDbnc);

    /* Switch: '<S4800>/Switch' */
    if (!rtb_TmpSignalConversionAtVeTM_o)
    {
        /* Switch: '<S4822>/Init' incorporates:
         *  Logic: '<S4822>/Logical2'
         *  UnitDelay: '<S4822>/FixPtUnitDelay2'
         */
        if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_a) != 0)
        {
            /* Switch: '<S4800>/Switch' incorporates:
             *  UnitDelay: '<S4822>/FixPtUnitDelay1'
             */
            rtb_VariantMerge_For_Variant__m =
                THMR_ac_DW.FixPtUnitDelay1_DSTATE_bs;
        }

        /* End of Switch: '<S4822>/Init' */
    }

    /* End of Switch: '<S4800>/Switch' */
    /* End of Outputs for SubSystem: '<S4736>/Debounce1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeBTRR_b_BattCellBalancing' */
    (void)Rte_Read_VeBTRR_b_BattCellBalancing_Value(&rtb_Logical3_pf);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Outputs for Atomic SubSystem: '<S4736>/Debounce1' */
    /* Update for UnitDelay: '<S4800>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_c = rtb_RelationalOperator9_h;

    /* Update for UnitDelay: '<S4800>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_fd = rtb_TmpSignalConversionAtVeTM_o;

    /* Update for UnitDelay: '<S4823>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4823>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_hp = 1U;

    /* Switch: '<S4823>/Reset' */
    if (rtb_RelationalOperator3_aj)
    {
        /* Update for UnitDelay: '<S4823>/FixPtUnitDelay1' incorporates:
         *  Constant: '<S4823>/InitialCondition'
         */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_d0 = 0U;
    }
    else
    {
        /* Update for UnitDelay: '<S4823>/FixPtUnitDelay1' */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_d0 = rtb_Switch_i3;
    }

    /* End of Switch: '<S4823>/Reset' */

    /* Update for UnitDelay: '<S4822>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4822>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_a = 1U;

    /* Update for UnitDelay: '<S4822>/FixPtUnitDelay1' */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE_bs = rtb_VariantMerge_For_Variant__m;

    /* End of Outputs for SubSystem: '<S4736>/Debounce1' */

    /* Logic: '<S4594>/Logical3' incorporates:
     *  Constant: '<S4731>/Constant'
     *  Constant: '<S4732>/Calib'
     *  Logic: '<S4594>/Logical1'
     *  Logic: '<S4594>/Logical2'
     *  RelationalOperator: '<S4594>/Comparison1'
     */
    rtb_Logical3_pf = (((((uint32)rtb_TmpSignalConversionAtVeAVTR) ==
                         CeAVTR_e_EVA_Balancing) || rtb_Logical3_pf) &&
                       ((THMR_ac_B.Switch1_h) ||
                        (KeTHMR_b_Enbl_BattAllwd_balancing)));

    /* RelationalOperator: '<S4116>/RelationalOperator9' incorporates:
     *  Constant: '<S4508>/Constant'
     */
    rtb_RelationalOperator9_h = (((uint32)rtb_TmpSignalConversionAtVeRCVR) ==
        CeRCVR_e_Faulty_Closed);

    /* RelationalOperator: '<S4116>/RelationalOperator3' incorporates:
     *  Constant: '<S4498>/Constant'
     */
    rtb_RelationalOperator3_aj = (((uint32)rtb_TmpSignalConversionAtVeRCVR) ==
        CeRCVR_e_Faulty_Open);

    /* RelationalOperator: '<S4116>/RelationalOperator2' incorporates:
     *  Constant: '<S4500>/Constant'
     */
    rtb_TmpSignalConversionAtVeB_jd = (((uint32)rtb_TmpSignalConversionAtVeRCVR)
        == CeRCVR_e_Faulty_Open_Bypass);

    /* RelationalOperator: '<S4116>/RelationalOperator1' incorporates:
     *  Constant: '<S4505>/Constant'
     */
    rtb_Logical27 = (((uint32)rtb_TmpSignalConversionAtVeRCVR) == CeRCVR_e_SNA);

    /* RelationalOperator: '<S4116>/RelationalOperator' incorporates:
     *  Constant: '<S4509>/Constant'
     *  SignalConversion generated from: '<S2>/VeRCVR_e_CPV_Valve_Stuck_State'
     */
    rtb_TmpSignalConversionAtVeTM_o = (((uint32)rtb_TmpSignalConversionAtVeRC_k)
        == CeRCVR_e_Faulty_Closed);

    /* RelationalOperator: '<S4116>/RelationalOperator5' incorporates:
     *  Constant: '<S4506>/Constant'
     *  RelationalOperator: '<S4116>/RelationalOperator'
     *  SignalConversion generated from: '<S2>/VeRCVR_e_CPV_Valve_Stuck_State'
     */
    rtb_OR1_b3 = (((uint32)rtb_TmpSignalConversionAtVeRC_k) ==
                  CeRCVR_e_Faulty_Open);

    /* RelationalOperator: '<S4116>/RelationalOperator10' incorporates:
     *  Constant: '<S4501>/Constant'
     *  RelationalOperator: '<S4116>/RelationalOperator'
     *  SignalConversion generated from: '<S2>/VeRCVR_e_CPV_Valve_Stuck_State'
     */
    rtb_AND_hz = (((uint32)rtb_TmpSignalConversionAtVeRC_k) ==
                  CeRCVR_e_Faulty_Open_Bypass);

    /* RelationalOperator: '<S4116>/RelationalOperator4' incorporates:
     *  Constant: '<S4499>/Constant'
     *  RelationalOperator: '<S4116>/RelationalOperator'
     *  SignalConversion generated from: '<S2>/VeRCVR_e_CPV_Valve_Stuck_State'
     */
    rtb_TmpSignalConversionAtVeFC_a = (((uint32)rtb_TmpSignalConversionAtVeRC_k)
        == CeRCVR_e_SNA);

    /* RelationalOperator: '<S4116>/RelationalOperator6' incorporates:
     *  Constant: '<S4512>/Constant'
     */
    rtb_TmpSignalConversionAtVeTM_j = (((uint32)rtb_TmpSignalConversionAtVeRC_a)
        == CeRCVR_e_Faulty_Closed);

    /* RelationalOperator: '<S4116>/RelationalOperator8' incorporates:
     *  Constant: '<S4510>/Constant'
     */
    rtb_TmpSignalConversionAtVeT_f5 = (((uint32)rtb_TmpSignalConversionAtVeRC_a)
        == CeRCVR_e_Faulty_Open);

    /* RelationalOperator: '<S4116>/RelationalOperator7' incorporates:
     *  Constant: '<S4507>/Constant'
     */
    rtb_UnitDelay3_ff = (((uint32)rtb_TmpSignalConversionAtVeRC_a) ==
                         CeRCVR_e_SNA);

    /* RelationalOperator: '<S4116>/RelationalOperator12' incorporates:
     *  Constant: '<S4504>/Constant'
     */
    rtb_LogicalOperator3_jq = (((uint32)rtb_TmpSignalConversionAtVeRC_c) ==
        CeRCVR_e_Faulty_Closed);

    /* RelationalOperator: '<S4116>/RelationalOperator14' incorporates:
     *  Constant: '<S4503>/Constant'
     */
    rtb_TmpSignalConversionAtVeF_hw = (((uint32)rtb_TmpSignalConversionAtVeRC_c)
        == CeRCVR_e_Faulty_Open);

    /* RelationalOperator: '<S4116>/RelationalOperator13' incorporates:
     *  Constant: '<S4502>/Constant'
     */
    aVarTruthTableCondition_4 = (((uint32)rtb_TmpSignalConversionAtVeRC_c) ==
        CeRCVR_e_SNA);

    /* Logic: '<S4525>/Logical Operator' incorporates:
     *  Constant: '<S4525>/Constant1'
     *  Constant: '<S4525>/Constant2'
     *  RelationalOperator: '<S4525>/Relational Operator1'
     *  RelationalOperator: '<S4525>/Relational Operator2'
     */
    rtb_LogicalOperator_dv = ((rtb_AND_bp_tmp != 0U) && (rtb_AND_bp_tmp_0 == 0U));

    /* Logic: '<S4116>/LogicalOperator2' incorporates:
     *  Constant: '<S4523>/Constant1'
     *  Constant: '<S4523>/Constant2'
     *  Constant: '<S4524>/Constant1'
     *  Constant: '<S4524>/Constant2'
     *  Logic: '<S4523>/Logical Operator'
     *  Logic: '<S4524>/Logical Operator'
     *  RelationalOperator: '<S4523>/Relational Operator1'
     *  RelationalOperator: '<S4523>/Relational Operator2'
     *  RelationalOperator: '<S4524>/Relational Operator1'
     *  RelationalOperator: '<S4524>/Relational Operator2'
     */
    rtb_TmpSignalConversionAtVeB_m4 = (((rtb_Logical2_lz_tmp != 0U) &&
        (rtb_Logical2_lz_tmp_0 == 0U)) || ((rtb_Logical2_lz_tmp_1 != 0U) &&
        (rtb_Logical2_lz_tmp_2 == 0U)));

    /* Logic: '<S4116>/LogicalOperator1' incorporates:
     *  Constant: '<S4513>/Constant1'
     *  Constant: '<S4513>/Constant2'
     *  Constant: '<S4514>/Constant1'
     *  Constant: '<S4514>/Constant2'
     *  Constant: '<S4515>/Constant1'
     *  Constant: '<S4515>/Constant2'
     *  Logic: '<S4513>/Logical Operator'
     *  Logic: '<S4514>/Logical Operator'
     *  Logic: '<S4515>/Logical Operator'
     *  RelationalOperator: '<S4513>/Relational Operator1'
     *  RelationalOperator: '<S4513>/Relational Operator2'
     *  RelationalOperator: '<S4514>/Relational Operator1'
     *  RelationalOperator: '<S4514>/Relational Operator2'
     *  RelationalOperator: '<S4515>/Relational Operator1'
     *  RelationalOperator: '<S4515>/Relational Operator2'
     */
    rtb_LogicalOperator1_nm = ((((rtb_TmpSignalConversionAtVePD_0 != 0U) &&
        (rtb_TmpSignalConversionAtVePD_1 == 0U)) ||
        ((rtb_TmpSignalConversionAtVePD_2 != 0U) &&
         (rtb_TmpSignalConversionAtVePD_3 == 0U))) ||
        ((rtb_TmpSignalConversionAtVePD_4 != 0U) &&
         (rtb_TmpSignalConversionAtVePD_5 == 0U)));

    /* Logic: '<S4116>/LogicalOperator4' incorporates:
     *  Constant: '<S4519>/Constant1'
     *  Constant: '<S4519>/Constant2'
     *  Constant: '<S4520>/Constant1'
     *  Constant: '<S4520>/Constant2'
     *  Constant: '<S4521>/Constant1'
     *  Constant: '<S4521>/Constant2'
     *  DataStoreRead: '<S4519>/StatusByte_AC_RefrigTempSnsr5CktPerf'
     *  DataStoreRead: '<S4520>/StatusByte_AC_RefrigTempSnsr5CktShotoBat'
     *  DataStoreRead: '<S4521>/StatusByte_AC_RefrigTempSnsr5CktShotoGro'
     *  Logic: '<S4519>/Logical Operator'
     *  Logic: '<S4520>/Logical Operator'
     *  Logic: '<S4521>/Logical Operator'
     *  RelationalOperator: '<S4519>/Relational Operator1'
     *  RelationalOperator: '<S4519>/Relational Operator2'
     *  RelationalOperator: '<S4520>/Relational Operator1'
     *  RelationalOperator: '<S4520>/Relational Operator2'
     *  RelationalOperator: '<S4521>/Relational Operator1'
     *  RelationalOperator: '<S4521>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S4519>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4519>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S4520>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4520>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S4521>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4521>/Bitwise Operator2'
     */
    rtb_LogicalOperator4_j = (((((((uint32)
        THMR_ac_DW.StatusByte_AC_RefrigTempSnsr5_f) & 1U) != 0U) && ((((uint32)
        THMR_ac_DW.StatusByte_AC_RefrigTempSnsr5_f) & 64U) == 0U)) ||
        (((((uint32)THMR_ac_DW.StatusByte_AC_RefrigTempSnsr5_d) & 1U) != 0U) &&
         ((((uint32)THMR_ac_DW.StatusByte_AC_RefrigTempSnsr5_d) & 64U) == 0U))) ||
        (((((uint32)THMR_ac_DW.StatusByte_AC_RefrigTempSnsr5Ck) & 1U) != 0U) &&
         ((((uint32)THMR_ac_DW.StatusByte_AC_RefrigTempSnsr5Ck) & 64U) == 0U)));

    /* Switch: '<S5134>/Switch2' incorporates:
     *  Constant: '<S4516>/Constant1'
     *  Constant: '<S4516>/Constant2'
     *  Constant: '<S4517>/Constant1'
     *  Constant: '<S4517>/Constant2'
     *  DataStoreRead: '<S4516>/StatusByte_AC_RefrigPresSnsrDCktPerf'
     *  DataStoreRead: '<S4517>/StatusByte_AC_RefrigPresSnsrDCkt'
     *  Logic: '<S4116>/LogicalOperator5'
     *  Logic: '<S4516>/Logical Operator'
     *  Logic: '<S4517>/Logical Operator'
     *  RelationalOperator: '<S4516>/Relational Operator1'
     *  RelationalOperator: '<S4516>/Relational Operator2'
     *  RelationalOperator: '<S4517>/Relational Operator1'
     *  RelationalOperator: '<S4517>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S4516>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4516>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S4517>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4517>/Bitwise Operator2'
     */
    rtb_TmpSignalConversionAtVeTP_c = ((((((uint32)
        THMR_ac_DW.StatusByte_AC_RefrigPresSnsrDCk) & 1U) != 0U) && ((((uint32)
        THMR_ac_DW.StatusByte_AC_RefrigPresSnsrDCk) & 64U) == 0U)) ||
        (((((uint32)THMR_ac_DW.StatusByte_AC_RefrigPresSnsrD_d) & 1U) != 0U) &&
         ((((uint32)THMR_ac_DW.StatusByte_AC_RefrigPresSnsrD_d) & 64U) == 0U)));

    /* UnitDelay: '<S5236>/UnitDelay' incorporates:
     *  Constant: '<S4518>/Constant1'
     *  Constant: '<S4518>/Constant2'
     *  Constant: '<S4522>/Constant1'
     *  Constant: '<S4522>/Constant2'
     *  DataStoreRead: '<S4518>/StatusByte_AC_RefrigTempSnsr4CktPerf'
     *  DataStoreRead: '<S4522>/StatusByte_AC_RefrigTempSnsrDCkt'
     *  Logic: '<S4116>/LogicalOperator6'
     *  Logic: '<S4518>/Logical Operator'
     *  Logic: '<S4522>/Logical Operator'
     *  RelationalOperator: '<S4518>/Relational Operator1'
     *  RelationalOperator: '<S4518>/Relational Operator2'
     *  RelationalOperator: '<S4522>/Relational Operator1'
     *  RelationalOperator: '<S4522>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S4518>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4518>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S4522>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4522>/Bitwise Operator2'
     */
    rtb_VariantMerge_For_Variant__b = ((((((uint32)
        THMR_ac_DW.StatusByte_AC_RefrigTempSnsrDCk) & 1U) != 0U) && ((((uint32)
        THMR_ac_DW.StatusByte_AC_RefrigTempSnsrDCk) & 64U) == 0U)) ||
        (((((uint32)THMR_ac_DW.StatusByte_AC_RefrigTempSnsr4Ck) & 1U) != 0U) &&
         ((((uint32)THMR_ac_DW.StatusByte_AC_RefrigTempSnsr4Ck) & 64U) == 0U)));

    /* Product: '<S4116>/Product9' incorporates:
     *  Constant: '<S4529>/Calib'
     *  Product: '<S4116>/Product'
     */
    rtb_Product9_h[0] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[0] ? ((sint32)
        (rtb_RelationalOperator9_h ? 1 : 0)) : 0);
    rtb_Product9_h[1] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[1] ? ((sint32)
        (rtb_RelationalOperator3_aj ? 1 : 0)) : 0);
    rtb_Product9_h[2] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[2] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_jd ? 1 : 0)) : 0);
    rtb_Product9_h[3] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[3] ? ((sint32)
        (rtb_Logical27 ? 1 : 0)) : 0);
    rtb_Product9_h[4] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[4] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_o ? 1 : 0)) : 0);
    rtb_Product9_h[5] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[5] ? ((sint32)
        (rtb_OR1_b3 ? 1 : 0)) : 0);
    rtb_Product9_h[6] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[6] ? ((sint32)
        (rtb_AND_hz ? 1 : 0)) : 0);
    rtb_Product9_h[7] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[7] ? ((sint32)
        (rtb_TmpSignalConversionAtVeFC_a ? 1 : 0)) : 0);
    rtb_Product9_h[8] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[8] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_j ? 1 : 0)) : 0);
    rtb_Product9_h[9] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[9] ? ((sint32)
        (rtb_TmpSignalConversionAtVeT_f5 ? 1 : 0)) : 0);
    rtb_Product9_h[10] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[10] ? ((sint32)
        (rtb_UnitDelay3_ff ? 1 : 0)) : 0);
    rtb_Product9_h[11] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[11] ? ((sint32)
        (rtb_LogicalOperator3_jq ? 1 : 0)) : 0);
    rtb_Product9_h[12] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[12] ? ((sint32)
        (rtb_TmpSignalConversionAtVeF_hw ? 1 : 0)) : 0);
    rtb_Product9_h[13] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[13] ? ((sint32)
        (aVarTruthTableCondition_4 ? 1 : 0)) : 0);
    rtb_Product9_h[14] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[14] ? ((sint32)
        (rtb_LogicalOperator_dv ? 1 : 0)) : 0);
    rtb_Product9_h[15] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[15] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_m4 ? 1 : 0)) : 0);
    rtb_Product9_h[16] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[16] ? ((sint32)
        (rtb_LogicalOperator1_nm ? 1 : 0)) : 0);
    rtb_Product9_h[17] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[17] ? ((sint32)
        (rtb_LogicalOperator4_j ? 1 : 0)) : 0);
    rtb_Product9_h[18] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[18] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTP_c ? 1 : 0)) : 0);
    rtb_Product9_h[19] = (sint8)(KaTHMR_b_BattPsvCoolDsbl_RA[19] ? ((sint32)
        (rtb_VariantMerge_For_Variant__b ? 1 : 0)) : 0);

    /* MinMax: '<S4116>/MinMax' */
    rtb_Switch_i3 = (uint16)rtb_Product9_h[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 19;
            rtb_DataTypeConversion2++)
    {
        u1 = (uint16)rtb_Product9_h[rtb_DataTypeConversion2 + 1];
        if (rtb_Switch_i3 > u1)
        {
            rtb_Switch_i3 = 1U;
        }
        else
        {
            rtb_Switch_i3 = u1;
        }
    }

    /* Logic: '<S4736>/Logical14' incorporates:
     *  Constant: '<S4809>/Calib'
     *  Logic: '<S4598>/Logical14'
     *  Logic: '<S4599>/Logical14'
     */
    rtb_OR1_k3 = (rtb_TmpSignalConversionAtVeTR_i || (KeTHMR_b_DsblImpctChk));

    /* Logic: '<S4736>/Logical9' incorporates:
     *  Constant: '<S4807>/Calib'
     *  Logic: '<S4598>/Logical9'
     *  Logic: '<S4599>/Logical9'
     *  Logic: '<S4736>/Logical8'
     */
    rtb_Switch1_az = ((!rtb_Logical3_pf) || (KeTHMR_b_DsblCellBalChk));

    /* Logic: '<S4816>/Logical1' */
    rtb_TmpSignalConversionAtVePM_a = !rtb_TmpSignalConversionAtVePM_a;

    /* Logic: '<S4816>/Logical13' incorporates:
     *  Constant: '<S4909>/Calib'
     *  Logic: '<S4624>/Logical13'
     *  Logic: '<S4686>/Logical13'
     *  Logic: '<S4816>/Logical1'
     */
    rtb_AND_de = (rtb_TmpSignalConversionAtVePM_a || (KeTHMR_b_DsblDryRunFAChk));

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Logic: '<S4736>/Logical5' incorporates:
     *  Constant: '<S4802>/Constant'
     *  Constant: '<S4805>/Calib'
     *  Constant: '<S4806>/Calib'
     *  Constant: '<S4808>/Calib'
     *  Constant: '<S4810>/Calib'
     *  Constant: '<S4811>/Calib'
     *  Constant: '<S4907>/Constant'
     *  Constant: '<S4908>/Calib'
     *  Constant: '<S4910>/Calib'
     *  Constant: '<S4915>/Constant'
     *  Constant: '<S4916>/Calib'
     *  Constant: '<S4917>/Calib'
     *  DataTypeConversion: '<S4116>/DataTypeConversion'
     *  Delay: '<S4736>/Delay'
     *  Inport: '<S2741>/In1'
     *  Logic: '<S4736>/Logical1'
     *  Logic: '<S4736>/Logical10'
     *  Logic: '<S4736>/Logical11'
     *  Logic: '<S4736>/Logical14'
     *  Logic: '<S4736>/Logical2'
     *  Logic: '<S4736>/Logical3'
     *  Logic: '<S4736>/Logical6'
     *  Logic: '<S4736>/Logical7'
     *  Logic: '<S4736>/Logical9'
     *  Logic: '<S4816>/Logical12'
     *  Logic: '<S4816>/Logical13'
     *  Logic: '<S4816>/Logical14'
     *  Logic: '<S4817>/Logical14'
     *  Logic: '<S4819>/Logical1'
     *  Logic: '<S4819>/Logical2'
     *  Logic: '<S4819>/Logical3'
     *  MinMax: '<S4116>/MinMax'
     *  RelationalOperator: '<S2928>/Relational Operator6'
     *  RelationalOperator: '<S4736>/Comparison1'
     *  RelationalOperator: '<S4736>/Comparison6'
     *  RelationalOperator: '<S4816>/Comparison1'
     *  RelationalOperator: '<S4819>/RelationalOperator1'
     *  RelationalOperator: '<S4819>/RelationalOperator3'
     */
    VeTHMR_b_BattPassiveCool = (((((((((((rtb_VariantMerge_For_Variant__m &&
        (rtb_TmpSignalConversionAtVeBT_p || (KeTHMR_b_DsblcoolreqChk_PsvCool))) &&
        rtb_OR1_k3) && ((!THMR_ac_DW.Delay_DSTATE_p) ||
                        (KeTHMR_b_DsblActvCoolChk))) && rtb_Switch1_az) &&
        ((((uint32)rtb_TmpSignalConversionAtVeBRDR) != CeBRDR_e_BatCltLvlLo) ||
         (KeTHMR_b_DsblClntLoChk))) && (rtb_AND_de && ((((uint32)
        rtb_TmpSignalConversionAtVeP_pf) == CePMPR_e_FTSNA_False) ||
        (KeTHMR_b_DsblDryRunChk)))) && ((THMR_ac_B.Switch1_h) ||
        (KeTHMR_b_Enbl_BattAllwd_PsvCool))) && (rtb_TmpSignalConversionAtVeBTRR <=
        KeTHMR_T_CellTempMaxPsv)) && (((((uint32)VeTHMR_e_EmrgcyFanRq_Lvl_B4D) ==
        CeTHMR_e_No_EmrgcyFanRq) || (!KeTHMR_b_BattPsvCool_EmrgcyEnbl)) &&
        (rtb_Sum_e < KeTHMR_Pct_LTCLPsvCool_AHHNrmlzdAF))) && (((sint32)
        rtb_Switch_i3) == 0)) && (!KeTHMR_b_DsblPassiveCool));

    /* Logic: '<S4733>/Logical9' incorporates:
     *  SignalConversion generated from: '<S4733>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblRA_BattCoolingFlt_PsvCool

    /* Switch: '<S5127>/Switch' */
    rtb_Switch_az2 = ((VeTHMR_b_BattCoolFlts_AllowRA_PsvCooling) &&
                      (VeTHMR_b_BattPassiveCool));

#else

    /* Switch: '<S5127>/Switch' incorporates:
     *  Constant: '<S4733>/Constant'
     *  SignalConversion generated from: '<S4733>/VariantSource'
     */
    rtb_Switch_az2 = false;

#endif

    /* End of Logic: '<S4733>/Logical9' */

    /* Product: '<S4116>/Product9' incorporates:
     *  Constant: '<S4526>/Calib'
     *  Product: '<S4116>/Product5'
     */
    rtb_Product9_h[0] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[0] ? ((sint32)
        (rtb_RelationalOperator9_h ? 1 : 0)) : 0);
    rtb_Product9_h[1] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[1] ? ((sint32)
        (rtb_RelationalOperator3_aj ? 1 : 0)) : 0);
    rtb_Product9_h[2] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[2] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_jd ? 1 : 0)) : 0);
    rtb_Product9_h[3] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[3] ? ((sint32)
        (rtb_Logical27 ? 1 : 0)) : 0);
    rtb_Product9_h[4] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[4] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_o ? 1 : 0)) : 0);
    rtb_Product9_h[5] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[5] ? ((sint32)
        (rtb_OR1_b3 ? 1 : 0)) : 0);
    rtb_Product9_h[6] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[6] ? ((sint32)
        (rtb_AND_hz ? 1 : 0)) : 0);
    rtb_Product9_h[7] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[7] ? ((sint32)
        (rtb_TmpSignalConversionAtVeFC_a ? 1 : 0)) : 0);
    rtb_Product9_h[8] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[8] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_j ? 1 : 0)) : 0);
    rtb_Product9_h[9] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[9] ? ((sint32)
        (rtb_TmpSignalConversionAtVeT_f5 ? 1 : 0)) : 0);
    rtb_Product9_h[10] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[10] ? ((sint32)
        (rtb_UnitDelay3_ff ? 1 : 0)) : 0);
    rtb_Product9_h[11] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[11] ? ((sint32)
        (rtb_LogicalOperator3_jq ? 1 : 0)) : 0);
    rtb_Product9_h[12] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[12] ? ((sint32)
        (rtb_TmpSignalConversionAtVeF_hw ? 1 : 0)) : 0);
    rtb_Product9_h[13] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[13] ? ((sint32)
        (aVarTruthTableCondition_4 ? 1 : 0)) : 0);
    rtb_Product9_h[14] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[14] ? ((sint32)
        (rtb_LogicalOperator_dv ? 1 : 0)) : 0);
    rtb_Product9_h[15] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[15] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_m4 ? 1 : 0)) : 0);
    rtb_Product9_h[16] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[16] ? ((sint32)
        (rtb_LogicalOperator1_nm ? 1 : 0)) : 0);
    rtb_Product9_h[17] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[17] ? ((sint32)
        (rtb_LogicalOperator4_j ? 1 : 0)) : 0);
    rtb_Product9_h[18] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[18] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTP_c ? 1 : 0)) : 0);
    rtb_Product9_h[19] = (sint8)(KaTHMR_b_BattActvCoolDsbl_RA[19] ? ((sint32)
        (rtb_VariantMerge_For_Variant__b ? 1 : 0)) : 0);

    /* MinMax: '<S4116>/MinMax5' */
    rtb_Switch_i3 = (uint16)rtb_Product9_h[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 19;
            rtb_DataTypeConversion2++)
    {
        u1 = (uint16)rtb_Product9_h[rtb_DataTypeConversion2 + 1];
        if (rtb_Switch_i3 > u1)
        {
            rtb_Switch_i3 = 1U;
        }
        else
        {
            rtb_Switch_i3 = u1;
        }
    }

    /* Logic: '<S4733>/Logical5' incorporates:
     *  Constant: '<S4739>/Constant'
     *  Constant: '<S4743>/Calib'
     *  Constant: '<S4762>/Calib'
     *  DataTypeConversion: '<S4116>/DataTypeConversion5'
     *  Logic: '<S4733>/Logical10'
     *  Logic: '<S4733>/Logical11'
     *  Logic: '<S4733>/Logical6'
     *  Logic: '<S4733>/Logical7'
     *  Logic: '<S4746>/Logical3'
     *  MinMax: '<S4116>/MinMax5'
     *  RelationalOperator: '<S4733>/Comparison2'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     */
    VeTHMR_b_BattCondNew_BS = (((((((((VeTHMR_b_CellMax_ActvCool) || (((uint32)
        rtb_TmpSignalConversionAtVePD_l) == CePDTR_e_Dischrg_ForcBatCool_Hys)) &&
        rtb_TmpSignalConversionAtVeTR_i) && rtb_VariantMerge_For_Variant__j) &&
        rtb_Logical2_iq) && ((THMR_ac_B.Switch1_h) ||
        (KeTHMR_b_Enbl_BattAllwd_ActvCool))) && (!KeTHMR_b_DsblActvCool)) &&
        (!rtb_Switch_az2)) && (((sint32)rtb_Switch_i3) == 0));

    /* Product: '<S4116>/Product9' incorporates:
     *  Constant: '<S4527>/Calib'
     *  Product: '<S4116>/Product4'
     */
    rtb_Product9_h[0] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[0] ? ((sint32)
        (rtb_RelationalOperator9_h ? 1 : 0)) : 0);
    rtb_Product9_h[1] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[1] ? ((sint32)
        (rtb_RelationalOperator3_aj ? 1 : 0)) : 0);
    rtb_Product9_h[2] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[2] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_jd ? 1 : 0)) : 0);
    rtb_Product9_h[3] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[3] ? ((sint32)
        (rtb_Logical27 ? 1 : 0)) : 0);
    rtb_Product9_h[4] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[4] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_o ? 1 : 0)) : 0);
    rtb_Product9_h[5] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[5] ? ((sint32)
        (rtb_OR1_b3 ? 1 : 0)) : 0);
    rtb_Product9_h[6] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[6] ? ((sint32)
        (rtb_AND_hz ? 1 : 0)) : 0);
    rtb_Product9_h[7] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[7] ? ((sint32)
        (rtb_TmpSignalConversionAtVeFC_a ? 1 : 0)) : 0);
    rtb_Product9_h[8] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[8] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_j ? 1 : 0)) : 0);
    rtb_Product9_h[9] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[9] ? ((sint32)
        (rtb_TmpSignalConversionAtVeT_f5 ? 1 : 0)) : 0);
    rtb_Product9_h[10] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[10] ? ((sint32)
        (rtb_UnitDelay3_ff ? 1 : 0)) : 0);
    rtb_Product9_h[11] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[11] ? ((sint32)
        (rtb_LogicalOperator3_jq ? 1 : 0)) : 0);
    rtb_Product9_h[12] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[12] ? ((sint32)
        (rtb_TmpSignalConversionAtVeF_hw ? 1 : 0)) : 0);
    rtb_Product9_h[13] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[13] ? ((sint32)
        (aVarTruthTableCondition_4 ? 1 : 0)) : 0);
    rtb_Product9_h[14] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[14] ? ((sint32)
        (rtb_LogicalOperator_dv ? 1 : 0)) : 0);
    rtb_Product9_h[15] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[15] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_m4 ? 1 : 0)) : 0);
    rtb_Product9_h[16] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[16] ? ((sint32)
        (rtb_LogicalOperator1_nm ? 1 : 0)) : 0);
    rtb_Product9_h[17] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[17] ? ((sint32)
        (rtb_LogicalOperator4_j ? 1 : 0)) : 0);
    rtb_Product9_h[18] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[18] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTP_c ? 1 : 0)) : 0);
    rtb_Product9_h[19] = (sint8)(KaTHMR_b_BattActvHeatDsbl_RA[19] ? ((sint32)
        (rtb_VariantMerge_For_Variant__b ? 1 : 0)) : 0);

    /* MinMax: '<S4116>/MinMax4' */
    rtb_Switch_i3 = (uint16)rtb_Product9_h[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 19;
            rtb_DataTypeConversion2++)
    {
        u1 = (uint16)rtb_Product9_h[rtb_DataTypeConversion2 + 1];
        if (rtb_Switch_i3 > u1)
        {
            rtb_Switch_i3 = 1U;
        }
        else
        {
            rtb_Switch_i3 = u1;
        }
    }

    /* Switch: '<S4610>/Switch' incorporates:
     *  Constant: '<S4611>/Calib'
     *  Constant: '<S4612>/Calib'
     */
    if (KeTHMR_b_DsblBattAllwd_SD)
    {
        rtb_AND_fe = KeTHMR_b_DsblBattAllwd_D;
    }
    else
    {
        rtb_AND_fe = THMR_ac_B.Switch1_h;
    }

    /* End of Switch: '<S4610>/Switch' */

    /* RelationalOperator: '<S4597>/RelationalOperator' incorporates:
     *  RelationalOperator: '<S4919>/RelationalOperator'
     *  UnitDelay: '<S4118>/UnitDelay5'
     */
    rtb_Logical17_o_tmp = THMR_ac_DW.UnitDelay5_DSTATE_k;

    /* Logic: '<S4597>/Logical2' incorporates:
     *  Constant: '<S4537>/Calib'
     *  Constant: '<S4607>/Constant'
     *  Constant: '<S4608>/Constant'
     *  Constant: '<S4609>/Constant'
     *  DataTypeConversion: '<S4116>/DataTypeConversion4'
     *  Logic: '<S4116>/Logical11'
     *  Logic: '<S4116>/LogicalOperator'
     *  Logic: '<S4116>/LogicalOperator10'
     *  Logic: '<S4116>/LogicalOperator8'
     *  Logic: '<S4597>/Logical1'
     *  Logic: '<S4597>/Logical3'
     *  MinMax: '<S4116>/MinMax4'
     *  RelationalOperator: '<S4597>/Comparison1'
     *  RelationalOperator: '<S4597>/RelationalOperator'
     *  RelationalOperator: '<S4597>/RelationalOperator1'
     */
    THMR_ac_B.Logical2 = (((((rtb_TmpSignalConversionAtVeB_ba || (((uint32)
        rtb_TmpSignalConversionAtVeAVTR) == CeAVTR_e_EVA_Heat)) && rtb_AND_fe) &&
                            (((uint32)rtb_Logical17_o_tmp) !=
        CeTHMR_e_FCBoostCool)) &&
                           (((!KeTHMR_b_EnblHTLVlvStckSNAAndBattNotCrit_RA) ||
        ((!rtb_UnitDelay3_ff) || rtb_TmpSignalConversionAtVeB_cu)) && (((sint32)
        rtb_Switch_i3) == 0))) && (((uint32)rtb_LogicalOperator_gg_tmp) !=
                           CeTHMR_e_ActiveCooling));

    /* Outputs for Atomic SubSystem: '<S4628>/Hysteresis1' */
    /* Switch: '<S4639>/Switch1' incorporates:
     *  Constant: '<S4641>/Calib'
     *  RelationalOperator: '<S4639>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeCT_i >
            KeTHMR_T_HCCTISErr_EnblLTCLActvPsvHeat_RSP)
    {
        /* Switch: '<S4639>/Switch1' incorporates:
         *  Constant: '<S4639>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeB_ba = true;
    }
    else
    {
        /* Switch: '<S4639>/Switch1' incorporates:
         *  Constant: '<S4640>/Calib'
         *  RelationalOperator: '<S4639>/GreaterThan1'
         *  UnitDelay: '<S4639>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeB_ba = ((rtb_TmpSignalConversionAtVeCT_i >=
            KeTHMR_T_HCCTISErr_EnblLTCLActvPsvHeat_LSP) &&
            (THMR_ac_DW.UnitDelay_DSTATE_cnh));
    }

    /* End of Switch: '<S4639>/Switch1' */
    /* End of Outputs for SubSystem: '<S4628>/Hysteresis1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeCTRR_b_TrueCab_HeatReq' */
    (void)Rte_Read_VeCTRR_b_TrueCab_HeatReq_Value(&rtb_Switch1_cck);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Outputs for Atomic SubSystem: '<S4628>/Hysteresis1' */
    /* Update for UnitDelay: '<S4639>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_cnh = rtb_TmpSignalConversionAtVeB_ba;

    /* End of Outputs for SubSystem: '<S4628>/Hysteresis1' */

    /* Logic: '<S4569>/LogicalOperator' incorporates:
     *  Logic: '<S5117>/Logical16'
     */
    rtb_AND_fe = ((THMR_ac_B.Switch1_az) && rtb_TmpSignalConversionAtVeBT_f);

    /* Product: '<S4116>/Product9' incorporates:
     *  Constant: '<S4532>/Calib'
     *  Product: '<S4116>/Product10'
     */
    rtb_Product9_h[0] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[0] ? ((sint32)
        (rtb_RelationalOperator9_h ? 1 : 0)) : 0);
    rtb_Product9_h[1] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[1] ? ((sint32)
        (rtb_RelationalOperator3_aj ? 1 : 0)) : 0);
    rtb_Product9_h[2] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[2] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_jd ? 1 : 0)) : 0);
    rtb_Product9_h[3] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[3] ? ((sint32)
        (rtb_Logical27 ? 1 : 0)) : 0);
    rtb_Product9_h[4] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[4] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_o ? 1 : 0)) : 0);
    rtb_Product9_h[5] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[5] ? ((sint32)
        (rtb_OR1_b3 ? 1 : 0)) : 0);
    rtb_Product9_h[6] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[6] ? ((sint32)
        (rtb_AND_hz ? 1 : 0)) : 0);
    rtb_Product9_h[7] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[7] ? ((sint32)
        (rtb_TmpSignalConversionAtVeFC_a ? 1 : 0)) : 0);
    rtb_Product9_h[8] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[8] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_j ? 1 : 0)) : 0);
    rtb_Product9_h[9] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[9] ? ((sint32)
        (rtb_TmpSignalConversionAtVeT_f5 ? 1 : 0)) : 0);
    rtb_Product9_h[10] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[10] ? ((sint32)
        (rtb_UnitDelay3_ff ? 1 : 0)) : 0);
    rtb_Product9_h[11] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[11] ? ((sint32)
        (rtb_LogicalOperator3_jq ? 1 : 0)) : 0);
    rtb_Product9_h[12] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[12] ? ((sint32)
        (rtb_TmpSignalConversionAtVeF_hw ? 1 : 0)) : 0);
    rtb_Product9_h[13] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[13] ? ((sint32)
        (aVarTruthTableCondition_4 ? 1 : 0)) : 0);
    rtb_Product9_h[14] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[14] ? ((sint32)
        (rtb_LogicalOperator_dv ? 1 : 0)) : 0);
    rtb_Product9_h[15] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[15] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_m4 ? 1 : 0)) : 0);
    rtb_Product9_h[16] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[16] ? ((sint32)
        (rtb_LogicalOperator1_nm ? 1 : 0)) : 0);
    rtb_Product9_h[17] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[17] ? ((sint32)
        (rtb_LogicalOperator4_j ? 1 : 0)) : 0);
    rtb_Product9_h[18] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[18] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTP_c ? 1 : 0)) : 0);
    rtb_Product9_h[19] = (sint8)(KaTHMR_b_CabActvHeatDsbl_RA[19] ? ((sint32)
        (rtb_VariantMerge_For_Variant__b ? 1 : 0)) : 0);

    /* MinMax: '<S4116>/MinMax10' */
    rtb_Switch_i3 = (uint16)rtb_Product9_h[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 19;
            rtb_DataTypeConversion2++)
    {
        u1 = (uint16)rtb_Product9_h[rtb_DataTypeConversion2 + 1];
        if (rtb_Switch_i3 > u1)
        {
            rtb_Switch_i3 = 1U;
        }
        else
        {
            rtb_Switch_i3 = u1;
        }
    }

    /* Logic: '<S4919>/LogicalOperator' incorporates:
     *  Constant: '<S4923>/Constant'
     *  Constant: '<S4924>/Calib'
     *  DataTypeConversion: '<S4116>/DataTypeConversion10'
     *  Logic: '<S4569>/LogicalOperator'
     *  Logic: '<S4919>/LogicalOperator3'
     *  Logic: '<S4919>/LogicalOperator4'
     *  Logic: '<S4919>/LogicalOperator5'
     *  Logic: '<S4919>/LogicalOperator6'
     *  MinMax: '<S4116>/MinMax10'
     *  RelationalOperator: '<S4919>/RelationalOperator'
     */
    VeTHMR_b_CabActvHeat = (((((rtb_AND_fe && ((rtb_TmpSignalConversionAtVeCT_o &&
        (rtb_Switch1_cck || (KeTHMR_b_TrueCabHeatOvrd))) ||
        rtb_TmpSignalConversionAtVeCT_m)) && rtb_TmpSignalConversionAtVeTR_i) &&
        rtb_VariantMerge_For_Variant__j) && (((uint32)rtb_Logical17_o_tmp) !=
        CeTHMR_e_FCBoostCool)) && (((sint32)rtb_Switch_i3) == 0));

    /* Logic: '<S4921>/Logical5' incorporates:
     *  Logic: '<S4107>/Logical8'
     */
    rtb_TmpSignalConversionAtBattCn = !VeTHMR_b_HTAPFunPer_FltDtct_AD;

    /* Logic: '<S4921>/Logical9' incorporates:
     *  Constant: '<S4967>/Constant1'
     *  Constant: '<S4967>/Constant2'
     *  Constant: '<S4968>/Constant1'
     *  Constant: '<S4968>/Constant2'
     *  Constant: '<S4969>/Calib'
     *  Constant: '<S4970>/Calib'
     *  Constant: '<S4971>/Calib'
     *  Constant: '<S4972>/Calib'
     *  Logic: '<S4921>/Logical'
     *  Logic: '<S4921>/Logical1'
     *  Logic: '<S4921>/Logical10'
     *  Logic: '<S4921>/Logical3'
     *  Logic: '<S4921>/Logical4'
     *  Logic: '<S4921>/Logical5'
     *  Logic: '<S4921>/Logical6'
     *  Logic: '<S4921>/Logical7'
     *  Logic: '<S4921>/Logical8'
     *  Logic: '<S4967>/Logical Operator'
     *  Logic: '<S4968>/Logical Operator'
     *  RelationalOperator: '<S4967>/Relational Operator1'
     *  RelationalOperator: '<S4967>/Relational Operator2'
     *  RelationalOperator: '<S4968>/Relational Operator1'
     *  RelationalOperator: '<S4968>/Relational Operator2'
     */
    rtb_TmpSignalConversionAtVeCT_m = (((((!KeTHMR_b_Enbl_FltRct_CoolPmpAPerf) ||
        rtb_TmpSignalConversionAtBattCn) && ((!KeTHMR_b_Enbl_FltRct_CoolPmpALOC)
        || ((rtb_Logical2_lz_tmp == 0U) || (rtb_Logical2_lz_tmp_0 != 0U)))) &&
        ((!KeTHMR_b_Enbl_FltRct_CoolHtrAPerf) ||
         (!THMR_ac_B.TmpSignalConversionAtVeHCDR_b_H))) &&
        ((!KeTHMR_b_Enbl_FltRct_CoolHtrALOC) || ((VeTHMR_b_BCH_U1008_DTCSet_tmp ==
        0U) || (VeTHMR_b_BCH_U1008_DTCSet_tmp_0 != 0U))));

    /* Logic: '<S4921>/Logical2' */
    rtb_Logical2_iq = ((VeTHMR_b_CabActvHeat) && rtb_TmpSignalConversionAtVeCT_m);

    /* Switch: '<S4628>/Switch' */
    if (rtb_Logical2_iq)
    {
        /* Logic: '<S5066>/LogicalOperator1' incorporates:
         *  Logic: '<S4628>/Logical12'
         */
        rtb_TmpSignalConversionAtVeB_ba = !rtb_TmpSignalConversionAtVeB_ba;
    }
    else
    {
        /* Logic: '<S5066>/LogicalOperator1' incorporates:
         *  Constant: '<S4628>/Constant'
         */
        rtb_TmpSignalConversionAtVeB_ba = true;
    }

    /* End of Switch: '<S4628>/Switch' */

    /* Logic: '<S4628>/Logical13' */
    VeTHMR_b_BattHTCLMixClnt_HeatReq = ((THMR_ac_B.Logical2) &&
        rtb_TmpSignalConversionAtVeB_ba);

    /* Sum: '<S4627>/Sum2' incorporates:
     *  Constant: '<S4627>/Constant4'
     *  Constant: '<S4638>/Calib'
     *  Product: '<S4627>/Product2'
     *  Product: '<S4627>/Product3'
     *  Sum: '<S4627>/Sum3'
     */
    VeTHMR_T_LTCLTgt_BattActvPsvHeating_B4D = ((1.0F -
        KeTHMR_r_LTLTgt_HCCTISBTLPri) * THMR_ac_B.Vector_h) +
        (rtb_TmpSignalConversionAtVeCTRR * KeTHMR_r_LTLTgt_HCCTISBTLPri);

    /* Sum: '<S4627>/Sum1' incorporates:
     *  MinMax: '<S4627>/MinMax'
     */
    rtb_TmpSignalConversionAtVeTM_p = fminf(THMR_ac_B.Switch1_j,
        rtb_TmpSignalConversionAtVeTM_f) -
        VeTHMR_T_LTCLTgt_BattActvPsvHeating_B4D;

    /* Outputs for Atomic SubSystem: '<S4627>/Hysteresis2' */
    /* Switch: '<S4635>/Switch1' incorporates:
     *  Constant: '<S4636>/Calib'
     *  RelationalOperator: '<S4635>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeTM_p > KeTHMR_T_BattLTLdeltaT_MaxLim)
    {
        /* Switch: '<S4635>/Switch1' incorporates:
         *  Constant: '<S4635>/ConstantValue'
         */
        rtb_Switch1_cck = true;
    }
    else
    {
        /* Switch: '<S4635>/Switch1' incorporates:
         *  Constant: '<S4637>/Calib'
         *  RelationalOperator: '<S4635>/GreaterThan1'
         *  UnitDelay: '<S4635>/UnitDelay'
         */
        rtb_Switch1_cck = ((rtb_TmpSignalConversionAtVeTM_p >=
                            KeTHMR_T_BattLTLdeltaT_MinLim) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_dj));
    }

    /* End of Switch: '<S4635>/Switch1' */

    /* Update for UnitDelay: '<S4635>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_dj = rtb_Switch1_cck;

    /* End of Outputs for SubSystem: '<S4627>/Hysteresis2' */

    /* Switch: '<S4613>/Switch1' incorporates:
     *  Constant: '<S4632>/Calib'
     *  Logic: '<S4613>/Logical2'
     *  RelationalOperator: '<S4613>/Comparison5'
     *  Sum: '<S4613>/Subtraction'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

    if (KeTHMR_b_BTLHTLDrctConnct)
    {
        /* Logic: '<S4574>/LogicalOperator' */
        rtb_LogicalOperator_iw = VeTHMR_b_BattHTCLMixClnt_HeatReq;
    }
    else
    {
        /* RelationalOperator: '<S4627>/Comparison6' incorporates:
         *  RelationalOperator: '<S4627>/Comparison1'
         *  UnitDelay: '<S4627>/UnitDelay1'
         */
        rtb_Switch1_o0g = THMR_ac_DW.UnitDelay1_DSTATE_iu;

        /* Logic: '<S4574>/LogicalOperator' incorporates:
         *  Constant: '<S4633>/Constant'
         *  Constant: '<S4634>/Constant'
         *  Logic: '<S4627>/Logical14'
         *  RelationalOperator: '<S4627>/Comparison1'
         *  RelationalOperator: '<S4627>/Comparison6'
         *  Switch: '<S4627>/Switch1'
         */
        rtb_LogicalOperator_iw = ((((CeTHMR_e_CabinActiveHeating == ((uint32)
            rtb_Switch1_o0g)) || (((uint32)rtb_Switch1_o0g) ==
            CeTHMR_e_CabinActivePassiveHeating)) && rtb_Switch1_cck) ||
            ((CeTHMR_e_CabinActiveHeating != ((uint32)rtb_Switch1_o0g)) &&
             (((uint32)rtb_Switch1_o0g) != CeTHMR_e_CabinActivePassiveHeating)));
    }

#else

    /* Outputs for Atomic SubSystem: '<S4613>/Hysteresis' */
    /* Switch: '<S4629>/Switch1' incorporates:
     *  Constant: '<S4631>/Calib'
     *  RelationalOperator: '<S4629>/Greater  Than'
     *  Sum: '<S4613>/Subtraction'
     */
    if (VeTHMR_T_EngCoolantTemp > (rtb_TmpSignalConversionAtVeT_n0 +
            KeTHMR_T_ECT_ECHTIS_Hyst))
    {
        /* Switch: '<S4629>/Switch1' incorporates:
         *  Constant: '<S4629>/Constant Value'
         */
        rtb_LogicalOperator_iw = true;
    }
    else
    {
        /* Switch: '<S4629>/Switch1' incorporates:
         *  RelationalOperator: '<S4629>/Greater  Than1'
         *  UnitDelay: '<S4629>/Unit Delay'
         */
        rtb_LogicalOperator_iw = ((VeTHMR_T_EngCoolantTemp >=
            rtb_TmpSignalConversionAtVeT_n0) && (THMR_ac_DW.UnitDelay_DSTATE_po));
    }

    /* End of Switch: '<S4629>/Switch1' */

    /* Update for UnitDelay: '<S4629>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_po = rtb_LogicalOperator_iw;

    /* Logic: '<S4574>/LogicalOperator' incorporates:
     *  Constant: '<S4630>/Calib'
     *  Logic: '<S4613>/Logical2'
     *  RelationalOperator: '<S4613>/Comparison5'
     */
    rtb_LogicalOperator_iw = ((rtb_TmpSignalConversionAtVeTA_b >
        KeTHMR_P_EngHotPwr_Min) && rtb_LogicalOperator_iw);

    /* End of Outputs for SubSystem: '<S4613>/Hysteresis' */
#endif

    /* End of Switch: '<S4613>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S4623>/Hysteresis2' */
    /* Switch: '<S4643>/Switch1' incorporates:
     *  Constant: '<S4645>/Calib'
     *  RelationalOperator: '<S4643>/GreaterThan'
     */
    if (VeTHMR_P_ClntHeatAbsrbFrmEDU_Arb > KeTHMR_P_EDURawWasteHeat_Batt_MaxLim)
    {
        /* Switch: '<S4643>/Switch1' incorporates:
         *  Constant: '<S4643>/ConstantValue'
         */
        rtb_VariantMerge_For_Variant__m = true;
    }
    else
    {
        /* Switch: '<S4643>/Switch1' incorporates:
         *  Constant: '<S4646>/Calib'
         *  RelationalOperator: '<S4643>/GreaterThan1'
         *  UnitDelay: '<S4643>/UnitDelay'
         */
        rtb_VariantMerge_For_Variant__m = ((VeTHMR_P_ClntHeatAbsrbFrmEDU_Arb >=
            KeTHMR_P_EDURawWasteHeat_Batt_MinLim) &&
            (THMR_ac_DW.UnitDelay_DSTATE_pl));
    }

    /* End of Switch: '<S4643>/Switch1' */

    /* Update for UnitDelay: '<S4643>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_pl = rtb_VariantMerge_For_Variant__m;

    /* End of Outputs for SubSystem: '<S4623>/Hysteresis2' */

    /* Logic: '<S4596>/Logical5' */
    rtb_TmpSignalConversionAtVeCPDR = !rtb_TmpSignalConversionAtVeCPDR;

    /* Logic: '<S4596>/Logical' incorporates:
     *  Constant: '<S4601>/Constant1'
     *  Constant: '<S4601>/Constant2'
     *  Constant: '<S4602>/Constant1'
     *  Constant: '<S4602>/Constant2'
     *  Constant: '<S4603>/Calib'
     *  Constant: '<S4604>/Calib'
     *  Constant: '<S4605>/Calib'
     *  Constant: '<S4606>/Calib'
     *  DataStoreRead: '<S4601>/StatusByte_LostCommHB_CoolPmp'
     *  Logic: '<S4596>/Logical1'
     *  Logic: '<S4596>/Logical10'
     *  Logic: '<S4596>/Logical3'
     *  Logic: '<S4596>/Logical4'
     *  Logic: '<S4596>/Logical5'
     *  Logic: '<S4596>/Logical6'
     *  Logic: '<S4596>/Logical7'
     *  Logic: '<S4596>/Logical8'
     *  Logic: '<S4601>/LogicalOperator'
     *  Logic: '<S4602>/LogicalOperator'
     *  RelationalOperator: '<S4601>/RelationalOperator1'
     *  RelationalOperator: '<S4601>/RelationalOperator2'
     *  RelationalOperator: '<S4602>/RelationalOperator1'
     *  RelationalOperator: '<S4602>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S4601>/BitwiseOperator2'
     */
    rtb_Switch1_cck = (((((!KeTHMR_b_Enbl_FltRct_BattCoolPmpPerf) ||
                          rtb_TmpSignalConversionAtVeCPDR) &&
                         ((!KeTHMR_b_Enbl_FltRct_LostCommHB_CoolPmp) ||
                          (((((sint32)THMR_ac_DW.StatusByte_LostCommHB_CoolPmp)
        & 1) <= 0) || (rtb_AND_bp_tmp_0 != 0U)))) &&
                        ((!KeTHMR_b_Enbl_FltRct_CoolantHeaterBPerf) ||
                         (!THMR_ac_B.TmpSignalConversionAtVeHCDR__os))) &&
                       ((!KeTHMR_b_Enbl_FltRct_LostCommHB_CooltHtr4) ||
                        ((rtb_Logical3_ks_tmp <= 0) ||
                         (VeTHMR_b_BCH_U04B8_DTCSet_tmp != 0U))));

    /* Logic: '<S5066>/LogicalOperator1' incorporates:
     *  Logic: '<S4596>/Logical9'
     */
    rtb_TmpSignalConversionAtVeB_ba = !rtb_Switch1_cck;

    /* Outputs for Atomic SubSystem: '<S4647>/Hysteresis1' */
    /* Switch: '<S4652>/Switch1' incorporates:
     *  Constant: '<S4664>/Calib'
     *  RelationalOperator: '<S4652>/GreaterThan'
     *  Sum: '<S4647>/Subtract4'
     */
    if (THMR_ac_B.Switch1_j > (rtb_TmpSignalConversionAtVeBT_k +
                               KeTHMR_dT_PPCTIS_BTIS_RSP_BattActvPsvHeat))
    {
        /* Switch: '<S4652>/Switch1' incorporates:
         *  Constant: '<S4652>/ConstantValue'
         */
        rtb_Switch_az2 = true;
    }
    else
    {
        /* Switch: '<S4652>/Switch1' incorporates:
         *  Constant: '<S4663>/Calib'
         *  RelationalOperator: '<S4652>/GreaterThan1'
         *  Sum: '<S4647>/Subtract3'
         *  UnitDelay: '<S4652>/UnitDelay'
         */
        rtb_Switch_az2 = ((THMR_ac_B.Switch1_j >=
                           (rtb_TmpSignalConversionAtVeBT_k -
                            KeTHMR_dT_PPCTIS_BTIS_LSP_BattActvPsvHeat)) &&
                          (THMR_ac_DW.UnitDelay_DSTATE_ob3));
    }

    /* End of Switch: '<S4652>/Switch1' */

    /* Update for UnitDelay: '<S4652>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ob3 = rtb_Switch_az2;

    /* End of Outputs for SubSystem: '<S4647>/Hysteresis1' */

    /* Outputs for Atomic SubSystem: '<S4647>/Hysteresis3' */
    /* Switch: '<S4653>/Switch1' incorporates:
     *  Constant: '<S4658>/Calib'
     *  RelationalOperator: '<S4653>/GreaterThan'
     */
    if (THMR_ac_B.Switch1_j > KeTHMR_T_PPCTIStooHot_BattActvPsvHeat_RSP)
    {
        /* Switch: '<S4653>/Switch1' incorporates:
         *  Constant: '<S4653>/ConstantValue'
         */
        rtb_NotEqual_fo = true;
    }
    else
    {
        /* Switch: '<S4653>/Switch1' incorporates:
         *  Constant: '<S4657>/Calib'
         *  RelationalOperator: '<S4653>/GreaterThan1'
         *  UnitDelay: '<S4653>/UnitDelay'
         */
        rtb_NotEqual_fo = ((THMR_ac_B.Switch1_j >=
                            KeTHMR_T_PPCTIStooHot_BattActvPsvHeat_LSP) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_br));
    }

    /* End of Switch: '<S4653>/Switch1' */

    /* Update for UnitDelay: '<S4653>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_br = rtb_NotEqual_fo;

    /* End of Outputs for SubSystem: '<S4647>/Hysteresis3' */

    /* Outputs for Atomic SubSystem: '<S4647>/Hysteresis4' */
    /* Switch: '<S4654>/Switch1' incorporates:
     *  Constant: '<S4656>/Calib'
     *  RelationalOperator: '<S4654>/GreaterThan'
     */
    if (THMR_ac_B.Switch1_j > KeTHMR_T_PPCTIStooCold_BattActvPsvHeat_RSP)
    {
        /* Switch: '<S4654>/Switch1' incorporates:
         *  Constant: '<S4654>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeBT_f = true;
    }
    else
    {
        /* Switch: '<S4654>/Switch1' incorporates:
         *  Constant: '<S4655>/Calib'
         *  RelationalOperator: '<S4654>/GreaterThan1'
         *  UnitDelay: '<S4654>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeBT_f = ((THMR_ac_B.Switch1_j >=
            KeTHMR_T_PPCTIStooCold_BattActvPsvHeat_LSP) &&
            (THMR_ac_DW.UnitDelay_DSTATE_etp));
    }

    /* End of Switch: '<S4654>/Switch1' */

    /* Update for UnitDelay: '<S4654>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_etp = rtb_TmpSignalConversionAtVeBT_f;

    /* End of Outputs for SubSystem: '<S4647>/Hysteresis4' */

    /* Logic: '<S4647>/LogicalOperator1' incorporates:
     *  Constant: '<S4659>/Calib'
     *  Constant: '<S4660>/Calib'
     *  Constant: '<S4661>/Calib'
     *  Constant: '<S4662>/Calib'
     *  Logic: '<S4647>/Logical1'
     *  Logic: '<S4647>/Logical2'
     *  Logic: '<S4647>/LogicalOperator'
     *  Logic: '<S4647>/LogicalOperator2'
     *  RelationalOperator: '<S4647>/RelationalOperator'
     *  Sum: '<S4647>/Subtract1'
     */
    VeTHMR_b_ClntChck_BatActvPsvHeat = ((((rtb_Switch_az2 ||
        (KeTHMR_b_BattActvPsvOvrride_BattLTCL)) && (!rtb_NotEqual_fo)) &&
        (rtb_TmpSignalConversionAtVeBT_f ||
         (KeTHMR_b_BattActvPsvOvrride_LTCLtooCold))) && ((((THMR_ac_B.Switch1_j
        - rtb_TmpSignalConversionAtVeBT_o) <= KeTHMR_dT_Clnt2Hot4Batt_ActvPsv) ||
        rtb_TmpSignalConversionAtVeB_ba) ||
        (KeTHMR_b_BattActvPsvOvrride_CellLTCL)));

    /* Logic: '<S4623>/Logical1' incorporates:
     *  Logic: '<S4623>/Logical7'
     */
    rtb_Switch_az2 = ((rtb_VariantMerge_For_Variant__m ||
                       rtb_TmpSignalConversionAtVeB_ba) &&
                      (VeTHMR_b_ClntChck_BatActvPsvHeat));

    /* Outputs for Atomic SubSystem: '<S4623>/Debounce2' */
    /* Outputs for Atomic SubSystem: '<S4642>/EdgeBi' */
    /* RelationalOperator: '<S4648>/NotEqual' incorporates:
     *  UnitDelay: '<S4648>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant__m = (rtb_Switch_az2 !=
        THMR_ac_DW.UnitDelay_DSTATE_hm);

    /* Update for UnitDelay: '<S4648>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_hm = rtb_Switch_az2;

    /* End of Outputs for SubSystem: '<S4642>/EdgeBi' */

    /* Logic: '<S4642>/Logical1' incorporates:
     *  UnitDelay: '<S4642>/UnitDelay1'
     */
    rtb_NotEqual_fo = (rtb_VariantMerge_For_Variant__m ||
                       (THMR_ac_DW.UnitDelay1_DSTATE_oa));

    /* Outputs for Atomic SubSystem: '<S4642>/SignalLatchOnWithReset' */
    /* Logic: '<S4649>/OR1' incorporates:
     *  Logic: '<S4649>/NOT'
     *  Logic: '<S4649>/OR'
     *  UnitDelay: '<S4642>/UnitDelay3'
     *  UnitDelay: '<S4649>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeBT_f = ((THMR_ac_DW.UnitDelay3_DSTATE_n) ||
        ((!rtb_NotEqual_fo) && (THMR_ac_DW.UnitDelay_DSTATE_ord)));

    /* Update for UnitDelay: '<S4649>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ord = rtb_TmpSignalConversionAtVeBT_f;

    /* End of Outputs for SubSystem: '<S4642>/SignalLatchOnWithReset' */

    /* Switch: '<S4651>/Init' incorporates:
     *  Constant: '<S4651>/InitialCondition'
     *  Logic: '<S4651>/FixPtLogicalOperator'
     *  Logic: '<S4651>/Logical2'
     *  UnitDelay: '<S4651>/FixPtUnitDelay1'
     *  UnitDelay: '<S4651>/FixPtUnitDelay2'
     */
    if (rtb_NotEqual_fo || (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_nl) == 0))
    {
        rtb_Switch_i3 = 0U;
    }
    else
    {
        rtb_Switch_i3 = THMR_ac_DW.FixPtUnitDelay1_DSTATE_ce;
    }

    /* End of Switch: '<S4651>/Init' */

    /* Switch: '<S5238>/Init' incorporates:
     *  Sum: '<S4642>/Sum1'
     *  Switch: '<S4642>/Switch2'
     */
    rtb_Switch_i3 = (uint16)(((uint32)(rtb_TmpSignalConversionAtVeBT_f ? 1U : 0U))
        + ((uint32)rtb_Switch_i3));

    /* RelationalOperator: '<S4642>/Equal1' incorporates:
     *  Constant: '<S4644>/Calib'
     */
    rtb_TmpSignalConversionAtVeBT_f = (((float32)rtb_Switch_i3) >=
        KeTHMR_Cnt_BattPsvHeatDbnc);

    /* Switch: '<S4642>/Switch' */
    if (!rtb_TmpSignalConversionAtVeBT_f)
    {
        /* Switch: '<S4650>/Init' incorporates:
         *  Logic: '<S4650>/Logical2'
         *  UnitDelay: '<S4650>/FixPtUnitDelay2'
         */
        if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_du) != 0)
        {
            /* Switch: '<S4642>/Switch' incorporates:
             *  UnitDelay: '<S4650>/FixPtUnitDelay1'
             */
            rtb_Switch_az2 = THMR_ac_DW.FixPtUnitDelay1_DSTATE_oa;
        }

        /* End of Switch: '<S4650>/Init' */
    }

    /* End of Switch: '<S4642>/Switch' */

    /* Update for UnitDelay: '<S4642>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_n = rtb_VariantMerge_For_Variant__m;

    /* Update for UnitDelay: '<S4642>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_oa = rtb_TmpSignalConversionAtVeBT_f;

    /* Update for UnitDelay: '<S4651>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4651>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_nl = 1U;

    /* Switch: '<S4651>/Reset' */
    if (rtb_NotEqual_fo)
    {
        /* Update for UnitDelay: '<S4651>/FixPtUnitDelay1' incorporates:
         *  Constant: '<S4651>/InitialCondition'
         */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_ce = 0U;
    }
    else
    {
        /* Update for UnitDelay: '<S4651>/FixPtUnitDelay1' */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_ce = rtb_Switch_i3;
    }

    /* End of Switch: '<S4651>/Reset' */

    /* Update for UnitDelay: '<S4650>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4650>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_du = 1U;

    /* Update for UnitDelay: '<S4650>/FixPtUnitDelay1' */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE_oa = rtb_Switch_az2;

    /* End of Outputs for SubSystem: '<S4623>/Debounce2' */

    /* SignalConversion generated from: '<S4226>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_ShrdBattCab_Heater

    /* Outputs for Atomic SubSystem: '<S4226>/Off' */
    /* VariantMerge generated from: '<S4226>/VariantSource' incorporates:
     *  Gain: '<S4231>/Gain'
     */
    THMR_ac_B.VariantMerge_Fo_at = THMR_ac_B.Switch1_h;

    /* End of Outputs for SubSystem: '<S4226>/Off' */
#else

    /* Outputs for Atomic SubSystem: '<S4226>/On' */
    /* Gain: '<S4232>/Gain' */
    rtb_Gain_pg = THMR_ac_B.Switch1_h;

    /* VariantMerge generated from: '<S4226>/VariantSource' incorporates:
     *  Constant: '<S4230>/ConstantValue'
     *  SignalConversion generated from: '<S4226>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_at = false;

    /* End of Outputs for SubSystem: '<S4226>/On' */
#endif

    /* End of SignalConversion generated from: '<S4226>/VariantSource' */

    /* RelationalOperator: '<S4626>/RelationalOperator' incorporates:
     *  RelationalOperator: '<S4688>/RelationalOperator'
     *  RelationalOperator: '<S4931>/RelationalOperator'
     *  UnitDelay: '<S4118>/UnitDelay1'
     */
    rtb_Logical1_bnh_tmp = THMR_ac_DW.UnitDelay1_DSTATE_kb;

    /* Logic: '<S4626>/Logical7' incorporates:
     *  Constant: '<S4670>/Constant'
     *  Constant: '<S4671>/Constant'
     *  Logic: '<S4626>/Logical6'
     *  RelationalOperator: '<S4626>/RelationalOperator'
     *  RelationalOperator: '<S4626>/RelationalOperator3'
     */
    rtb_NotEqual_fo = ((((uint32)rtb_LogicalOperator_gg_tmp) ==
                        CeTHMR_e_PassiveCooling) || (((uint32)
                         rtb_Logical1_bnh_tmp) != CeTHMR_e_PsvCooling_LTCLVlvSt));

    /* Outputs for Atomic SubSystem: '<S4626>/Debounce2' */
    /* Outputs for Atomic SubSystem: '<S4669>/EdgeBi' */
    /* RelationalOperator: '<S4674>/NotEqual' incorporates:
     *  UnitDelay: '<S4674>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant__m = (rtb_NotEqual_fo !=
        THMR_ac_DW.UnitDelay_DSTATE_lj);

    /* Update for UnitDelay: '<S4674>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_lj = rtb_NotEqual_fo;

    /* End of Outputs for SubSystem: '<S4669>/EdgeBi' */

    /* Logic: '<S4669>/Logical1' incorporates:
     *  UnitDelay: '<S4669>/UnitDelay1'
     */
    rtb_TmpSignalConversionAtVeBT_f = (rtb_VariantMerge_For_Variant__m ||
        (THMR_ac_DW.UnitDelay1_DSTATE_i3));

    /* Outputs for Atomic SubSystem: '<S4669>/SignalLatchOnWithReset' */
    /* Logic: '<S4675>/OR1' incorporates:
     *  Logic: '<S4675>/NOT'
     *  Logic: '<S4675>/OR'
     *  UnitDelay: '<S4669>/UnitDelay3'
     *  UnitDelay: '<S4675>/UnitDelay'
     */
    rtb_LogicalOperator1_fo = ((THMR_ac_DW.UnitDelay3_DSTATE_j0) ||
        ((!rtb_TmpSignalConversionAtVeBT_f) && (THMR_ac_DW.UnitDelay_DSTATE_ff)));

    /* Update for UnitDelay: '<S4675>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ff = rtb_LogicalOperator1_fo;

    /* End of Outputs for SubSystem: '<S4669>/SignalLatchOnWithReset' */

    /* Switch: '<S4677>/Init' incorporates:
     *  Constant: '<S4677>/InitialCondition'
     *  Logic: '<S4677>/FixPtLogicalOperator'
     *  Logic: '<S4677>/Logical2'
     *  UnitDelay: '<S4677>/FixPtUnitDelay1'
     *  UnitDelay: '<S4677>/FixPtUnitDelay2'
     */
    if (rtb_TmpSignalConversionAtVeBT_f || (((sint32)
            THMR_ac_DW.FixPtUnitDelay2_DSTATE_dc) == 0))
    {
        rtb_Switch_i3 = 0U;
    }
    else
    {
        rtb_Switch_i3 = THMR_ac_DW.FixPtUnitDelay1_DSTATE_i;
    }

    /* End of Switch: '<S4677>/Init' */

    /* Switch: '<S5238>/Init' incorporates:
     *  Sum: '<S4669>/Sum1'
     *  Switch: '<S4669>/Switch2'
     */
    rtb_Switch_i3 = (uint16)(((uint32)(rtb_LogicalOperator1_fo ? 1U : 0U)) +
        ((uint32)rtb_Switch_i3));

    /* RelationalOperator: '<S4669>/Equal1' incorporates:
     *  Constant: '<S4672>/Calib'
     */
    rtb_LogicalOperator1_fo = (rtb_Switch_i3 >=
        KeTHMR_Cnt_LTCLCool_InhbtPsvHeatStates);

    /* Switch: '<S4669>/Switch' */
    if (!rtb_LogicalOperator1_fo)
    {
        /* Switch: '<S4676>/Init' incorporates:
         *  Logic: '<S4676>/Logical2'
         *  UnitDelay: '<S4676>/FixPtUnitDelay2'
         */
        if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_cf) != 0)
        {
            /* Switch: '<S4669>/Switch' incorporates:
             *  UnitDelay: '<S4676>/FixPtUnitDelay1'
             */
            rtb_NotEqual_fo = THMR_ac_DW.FixPtUnitDelay1_DSTATE_pr;
        }

        /* End of Switch: '<S4676>/Init' */
    }

    /* End of Switch: '<S4669>/Switch' */

    /* Update for UnitDelay: '<S4669>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_j0 = rtb_VariantMerge_For_Variant__m;

    /* Update for UnitDelay: '<S4669>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_i3 = rtb_LogicalOperator1_fo;

    /* Update for UnitDelay: '<S4677>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4677>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_dc = 1U;

    /* Switch: '<S4677>/Reset' */
    if (rtb_TmpSignalConversionAtVeBT_f)
    {
        /* Update for UnitDelay: '<S4677>/FixPtUnitDelay1' incorporates:
         *  Constant: '<S4677>/InitialCondition'
         */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_i = 0U;
    }
    else
    {
        /* Update for UnitDelay: '<S4677>/FixPtUnitDelay1' */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_i = rtb_Switch_i3;
    }

    /* End of Switch: '<S4677>/Reset' */

    /* Update for UnitDelay: '<S4676>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4676>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_cf = 1U;

    /* Update for UnitDelay: '<S4676>/FixPtUnitDelay1' */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE_pr = rtb_NotEqual_fo;

    /* End of Outputs for SubSystem: '<S4626>/Debounce2' */

    /* Product: '<S4116>/Product9' incorporates:
     *  Constant: '<S4528>/Calib'
     *  Product: '<S4116>/Product2'
     */
    rtb_Product9_h[0] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[0] ? ((sint32)
        (rtb_RelationalOperator9_h ? 1 : 0)) : 0);
    rtb_Product9_h[1] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[1] ? ((sint32)
        (rtb_RelationalOperator3_aj ? 1 : 0)) : 0);
    rtb_Product9_h[2] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[2] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_jd ? 1 : 0)) : 0);
    rtb_Product9_h[3] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[3] ? ((sint32)
        (rtb_Logical27 ? 1 : 0)) : 0);
    rtb_Product9_h[4] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[4] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_o ? 1 : 0)) : 0);
    rtb_Product9_h[5] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[5] ? ((sint32)
        (rtb_OR1_b3 ? 1 : 0)) : 0);
    rtb_Product9_h[6] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[6] ? ((sint32)
        (rtb_AND_hz ? 1 : 0)) : 0);
    rtb_Product9_h[7] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[7] ? ((sint32)
        (rtb_TmpSignalConversionAtVeFC_a ? 1 : 0)) : 0);
    rtb_Product9_h[8] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[8] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_j ? 1 : 0)) : 0);
    rtb_Product9_h[9] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[9] ? ((sint32)
        (rtb_TmpSignalConversionAtVeT_f5 ? 1 : 0)) : 0);
    rtb_Product9_h[10] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[10] ? ((sint32)
        (rtb_UnitDelay3_ff ? 1 : 0)) : 0);
    rtb_Product9_h[11] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[11] ? ((sint32)
        (rtb_LogicalOperator3_jq ? 1 : 0)) : 0);
    rtb_Product9_h[12] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[12] ? ((sint32)
        (rtb_TmpSignalConversionAtVeF_hw ? 1 : 0)) : 0);
    rtb_Product9_h[13] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[13] ? ((sint32)
        (aVarTruthTableCondition_4 ? 1 : 0)) : 0);
    rtb_Product9_h[14] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[14] ? ((sint32)
        (rtb_LogicalOperator_dv ? 1 : 0)) : 0);
    rtb_Product9_h[15] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[15] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_m4 ? 1 : 0)) : 0);
    rtb_Product9_h[16] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[16] ? ((sint32)
        (rtb_LogicalOperator1_nm ? 1 : 0)) : 0);
    rtb_Product9_h[17] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[17] ? ((sint32)
        (rtb_LogicalOperator4_j ? 1 : 0)) : 0);
    rtb_Product9_h[18] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[18] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTP_c ? 1 : 0)) : 0);
    rtb_Product9_h[19] = (sint8)(KaTHMR_b_BattActvPsvHeatDsbl_RA[19] ? ((sint32)
        (rtb_VariantMerge_For_Variant__b ? 1 : 0)) : 0);

    /* MinMax: '<S4116>/MinMax2' */
    rtb_Switch_i3 = (uint16)rtb_Product9_h[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 19;
            rtb_DataTypeConversion2++)
    {
        u1 = (uint16)rtb_Product9_h[rtb_DataTypeConversion2 + 1];
        if (rtb_Switch_i3 > u1)
        {
            rtb_Switch_i3 = 1U;
        }
        else
        {
            rtb_Switch_i3 = u1;
        }
    }

    /* Logic: '<S4598>/Logical6' incorporates:
     *  Constant: '<S4511>/Constant'
     *  Constant: '<S4538>/Calib'
     *  DataTypeConversion: '<S4116>/DataTypeConversion2'
     *  Logic: '<S4116>/Logical1'
     *  Logic: '<S4116>/LogicalOperator11'
     *  Logic: '<S4116>/LogicalOperator3'
     *  Logic: '<S4116>/LogicalOperator7'
     *  Logic: '<S4116>/LogicalOperator9'
     *  Logic: '<S5128>/LogicalOperator1'
     *  MinMax: '<S4116>/MinMax2'
     *  RelationalOperator: '<S4116>/Comparison21'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     */
    rtb_VariantMerge_For_Variant__m =
        (((!KeTHMR_b_EnblLTRVlvStckClsdAndBattNotCrit_RA) || ((((!rtb_Logical27)
             && (!rtb_RelationalOperator9_h)) ||
            (!rtb_TmpSignalConversionAtVeTR_k)) || (((uint32)
             rtb_TmpSignalConversionAtVePD_l) != CePDTR_e_No_Dischrg))) &&
         (((sint32)rtb_Switch_i3) == 0));

    /* Logic: '<S4598>/Logical3' incorporates:
     *  Constant: '<S4614>/Constant'
     *  Constant: '<S4615>/Constant'
     *  Constant: '<S4616>/Constant'
     *  Constant: '<S4617>/Calib'
     *  Constant: '<S4618>/Calib'
     *  Constant: '<S4619>/Calib'
     *  Constant: '<S4621>/Calib'
     *  Constant: '<S4665>/Constant'
     *  Constant: '<S4666>/Calib'
     *  Constant: '<S4668>/Calib'
     *  Constant: '<S4673>/Calib'
     *  Logic: '<S4598>/Logical10'
     *  Logic: '<S4598>/Logical11'
     *  Logic: '<S4598>/Logical12'
     *  Logic: '<S4598>/Logical2'
     *  Logic: '<S4598>/Logical4'
     *  Logic: '<S4598>/Logical6'
     *  Logic: '<S4598>/Logical7'
     *  Logic: '<S4624>/Logical12'
     *  Logic: '<S4624>/Logical14'
     *  Logic: '<S4625>/Logical14'
     *  Logic: '<S4626>/Logical1'
     *  RelationalOperator: '<S4598>/Comparison6'
     *  RelationalOperator: '<S4598>/RelationalOperator1'
     *  RelationalOperator: '<S4598>/RelationalOperator2'
     *  RelationalOperator: '<S4624>/Comparison1'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     *  UnitDelay: '<S4598>/UnitDelay1'
     */
    VeTHMR_b_BattActvPsvHeat = ((((((((((((((THMR_ac_B.Logical2) &&
        rtb_LogicalOperator_iw) && rtb_Switch_az2) && rtb_OR1_k3) &&
        rtb_Switch1_az) && ((((uint32)rtb_TmpSignalConversionAtVeBRDR) !=
        CeBRDR_e_BatCltLvlLo) || (KeTHMR_b_DsblClntLoChk))) && (rtb_AND_de &&
        ((((uint32)rtb_TmpSignalConversionAtVeP_pf) == CePMPR_e_FTSNA_False) ||
         (KeTHMR_b_DsblDryRunChk)))) && ((THMR_ac_B.Switch1_h) ||
        (KeTHMR_b_Enbl_BattAllwd_ActvPsvHeat))) &&
        ((KeTHMR_b_BattCritAllowBattActvPsvHeat) ||
         rtb_TmpSignalConversionAtVeTR_k)) && ((((uint32)
        rtb_TmpSignalConversionAtVePD_l) == CePDTR_e_No_Dischrg) ||
        (THMR_ac_B.VariantMerge_Fo_at))) && ((KeTHMR_b_BTLHTLDrctConnct) ||
        rtb_NotEqual_fo)) && ((((uint32)THMR_ac_DW.UnitDelay1_DSTATE_kf) !=
        CeTHMR_e_CabinActivePassiveHeating) ||
        (KeTHMR_b_AlwaysPriotzBattActvPsvHeat))) &&
        rtb_VariantMerge_For_Variant__m) && (!KeTHMR_b_DsblBattActvPassiveHeat));

    /* Outputs for Atomic SubSystem: '<S4679>/Hysteresis' */
    /* Switch: '<S4703>/Switch1' incorporates:
     *  Constant: '<S4708>/Calib'
     *  RelationalOperator: '<S4703>/Greater  Than'
     *  Sum: '<S4679>/Subtract2'
     */
    if (rtb_TmpSignalConversionAtVeT_ge > (KeTHMR_dT_HXCTOS_BTISBattPsvRSP +
            rtb_TmpSignalConversionAtVeBT_k))
    {
        /* Switch: '<S4703>/Switch1' incorporates:
         *  Constant: '<S4703>/Constant Value'
         */
        rtb_LogicalOperator_iw = true;
    }
    else
    {
        /* Switch: '<S4703>/Switch1' incorporates:
         *  Constant: '<S4707>/Calib'
         *  RelationalOperator: '<S4703>/Greater  Than1'
         *  Sum: '<S4679>/Subtract1'
         *  UnitDelay: '<S4703>/Unit Delay'
         */
        rtb_LogicalOperator_iw = ((rtb_TmpSignalConversionAtVeT_ge >=
            (rtb_TmpSignalConversionAtVeBT_k - KeTHMR_dT_HXCTOS_BTISBattPsvLSP))
            && (THMR_ac_DW.UnitDelay_DSTATE_ou));
    }

    /* End of Switch: '<S4703>/Switch1' */

    /* Update for UnitDelay: '<S4703>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_ou = rtb_LogicalOperator_iw;

    /* End of Outputs for SubSystem: '<S4679>/Hysteresis' */

    /* Switch: '<S4679>/Switch' incorporates:
     *  Constant: '<S4705>/Calib'
     */
    if (KeTHMR_b_BTLHTLDrctConnct)
    {
        /* Switch: '<S4709>/Init' incorporates:
         *  Constant: '<S4700>/Constant'
         *  UnitDelay: '<S4709>/FixPt Unit Delay1'
         *  UnitDelay: '<S4709>/FixPt Unit Delay2'
         */
        if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_l) != 0)
        {
            rtb_Switch1_o0g = CeTHMR_e_NoCabinHeating;
        }
        else
        {
            rtb_Switch1_o0g = THMR_ac_DW.FixPtUnitDelay1_DSTATE_do;
        }

        /* End of Switch: '<S4709>/Init' */

        /* Switch: '<S4679>/Switch' incorporates:
         *  Constant: '<S4679>/FALSEConstant'
         *  Constant: '<S4701>/Constant'
         *  Constant: '<S4706>/Calib'
         *  Constant: '<S4714>/Constant1'
         *  Constant: '<S4714>/Constant2'
         *  Constant: '<S4715>/Constant1'
         *  Constant: '<S4715>/Constant2'
         *  Constant: '<S4716>/Constant1'
         *  Constant: '<S4716>/Constant2'
         *  DataStoreRead: '<S4714>/StatusByte_RadCooTempSnsr3CktLo'
         *  DataStoreRead: '<S4715>/StatusByte_RadCooTempSnsr3CktHi'
         *  DataStoreRead: '<S4716>/StatusByte_RadCooTempSnsr3CktPerf'
         *  Logic: '<S4679>/Logical2'
         *  Logic: '<S4679>/Logical3'
         *  Logic: '<S4679>/Logical4'
         *  Logic: '<S4679>/Logical9'
         *  Logic: '<S4702>/Logical4'
         *  Logic: '<S4714>/Logical Operator'
         *  Logic: '<S4715>/Logical Operator'
         *  Logic: '<S4716>/Logical Operator'
         *  RelationalOperator: '<S4679>/RelationalOperator'
         *  RelationalOperator: '<S4679>/RelationalOperator1'
         *  RelationalOperator: '<S4714>/Relational Operator1'
         *  RelationalOperator: '<S4714>/Relational Operator2'
         *  RelationalOperator: '<S4715>/Relational Operator1'
         *  RelationalOperator: '<S4715>/Relational Operator2'
         *  RelationalOperator: '<S4716>/Relational Operator1'
         *  RelationalOperator: '<S4716>/Relational Operator2'
         *  S-Function (sfix_bitop): '<S4714>/Bitwise Operator1'
         *  S-Function (sfix_bitop): '<S4714>/Bitwise Operator2'
         *  S-Function (sfix_bitop): '<S4715>/Bitwise Operator1'
         *  S-Function (sfix_bitop): '<S4715>/Bitwise Operator2'
         *  S-Function (sfix_bitop): '<S4716>/Bitwise Operator1'
         *  S-Function (sfix_bitop): '<S4716>/Bitwise Operator2'
         */
        rtb_LogicalOperator_iw = (((((!rtb_LogicalOperator_iw) &&
            (rtb_TmpSignalConversionAtVeHTIR <= 0.0F)) &&
            rtb_TmpSignalConversionAtVePD_p) && ((((uint32)rtb_Switch1_o0g) ==
            CeTHMR_e_NoCabinHeating) || (KeTHMR_b_IgnrCabHeat4BattPsvHeat))) &&
            (((((((uint32)THMR_ac_DW.StatusByte_RadCooTempSnsr3CktLo) & 1U) ==
                0U) || ((((uint32)THMR_ac_DW.StatusByte_RadCooTempSnsr3CktLo) &
                         64U) != 0U)) && (((((uint32)
            THMR_ac_DW.StatusByte_RadCooTempSnsr3CktHi) & 1U) == 0U) ||
            ((((uint32)THMR_ac_DW.StatusByte_RadCooTempSnsr3CktHi) & 64U) != 0U)))
             && (((((uint32)THMR_ac_DW.StatusByte_RadCooTempSnsr3CktPe) & 1U) ==
                  0U) || ((((uint32)THMR_ac_DW.StatusByte_RadCooTempSnsr3CktPe)
                           & 64U) != 0U))));
    }
    else
    {
        /* Switch: '<S4679>/Switch' incorporates:
         *  Constant: '<S4679>/FALSEConstant1'
         */
        rtb_LogicalOperator_iw = false;
    }

    /* Outputs for Atomic SubSystem: '<S4679>/Debounce1' */
    /* Outputs for Atomic SubSystem: '<S4699>/EdgeBi' */
    /* RelationalOperator: '<S4710>/NotEqual' incorporates:
     *  UnitDelay: '<S4710>/UnitDelay'
     */
    rtb_Switch_az2 = (rtb_LogicalOperator_iw != THMR_ac_DW.UnitDelay_DSTATE_ak4);

    /* Update for UnitDelay: '<S4710>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ak4 = rtb_LogicalOperator_iw;

    /* End of Outputs for SubSystem: '<S4699>/EdgeBi' */

    /* Logic: '<S4699>/Logical1' incorporates:
     *  UnitDelay: '<S4699>/UnitDelay1'
     */
    rtb_NotEqual_fo = (rtb_Switch_az2 || (THMR_ac_DW.UnitDelay1_DSTATE_iy));

    /* Outputs for Atomic SubSystem: '<S4699>/SignalLatchOnWithReset1' */
    /* Logic: '<S4711>/OR1' incorporates:
     *  Logic: '<S4711>/NOT'
     *  Logic: '<S4711>/OR'
     *  UnitDelay: '<S4699>/UnitDelay3'
     *  UnitDelay: '<S4711>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeBT_f = ((THMR_ac_DW.UnitDelay3_DSTATE_gw) ||
        ((!rtb_NotEqual_fo) && (THMR_ac_DW.UnitDelay_DSTATE_dkd)));

    /* Update for UnitDelay: '<S4711>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_dkd = rtb_TmpSignalConversionAtVeBT_f;

    /* End of Outputs for SubSystem: '<S4699>/SignalLatchOnWithReset1' */

    /* Switch: '<S4713>/Init' incorporates:
     *  Constant: '<S4713>/InitialCondition'
     *  Logic: '<S4713>/FixPtLogicalOperator'
     *  Logic: '<S4713>/Logical2'
     *  UnitDelay: '<S4713>/FixPtUnitDelay1'
     *  UnitDelay: '<S4713>/FixPtUnitDelay2'
     */
    if (rtb_NotEqual_fo || (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_j) == 0))
    {
        rtb_Switch_i3 = 0U;
    }
    else
    {
        rtb_Switch_i3 = THMR_ac_DW.FixPtUnitDelay1_DSTATE_ad;
    }

    /* End of Switch: '<S4713>/Init' */

    /* Switch: '<S5238>/Init' incorporates:
     *  Sum: '<S4699>/Sum1'
     *  Switch: '<S4699>/Switch2'
     */
    rtb_Switch_i3 = (uint16)(((uint32)(rtb_TmpSignalConversionAtVeBT_f ? 1U : 0U))
        + ((uint32)rtb_Switch_i3));

    /* RelationalOperator: '<S4699>/Equal1' incorporates:
     *  Constant: '<S4704>/Calib'
     */
    rtb_TmpSignalConversionAtVeBT_f = (((float32)rtb_Switch_i3) >=
        KeTHMR_Cnt_BattPsvHeatDbnc);

    /* Switch: '<S4699>/Switch' */
    if (!rtb_TmpSignalConversionAtVeBT_f)
    {
        /* Switch: '<S4712>/Init' incorporates:
         *  Logic: '<S4712>/Logical2'
         *  UnitDelay: '<S4712>/FixPtUnitDelay2'
         */
        if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_pb) != 0)
        {
            /* Switch: '<S4699>/Switch' incorporates:
             *  UnitDelay: '<S4712>/FixPtUnitDelay1'
             */
            rtb_LogicalOperator_iw = THMR_ac_DW.FixPtUnitDelay1_DSTATE_af;
        }

        /* End of Switch: '<S4712>/Init' */
    }

    /* End of Switch: '<S4699>/Switch' */

    /* Update for UnitDelay: '<S4699>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_gw = rtb_Switch_az2;

    /* Update for UnitDelay: '<S4699>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_iy = rtb_TmpSignalConversionAtVeBT_f;

    /* Update for UnitDelay: '<S4713>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4713>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_j = 1U;

    /* Switch: '<S4713>/Reset' */
    if (rtb_NotEqual_fo)
    {
        /* Update for UnitDelay: '<S4713>/FixPtUnitDelay1' incorporates:
         *  Constant: '<S4713>/InitialCondition'
         */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_ad = 0U;
    }
    else
    {
        /* Update for UnitDelay: '<S4713>/FixPtUnitDelay1' */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_ad = rtb_Switch_i3;
    }

    /* End of Switch: '<S4713>/Reset' */

    /* Update for UnitDelay: '<S4712>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4712>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_pb = 1U;

    /* Update for UnitDelay: '<S4712>/FixPtUnitDelay1' */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE_af = rtb_LogicalOperator_iw;

    /* End of Outputs for SubSystem: '<S4679>/Debounce1' */

    /* Outputs for Atomic SubSystem: '<S4678>/Hysteresis1' */
    /* Switch: '<S4690>/Switch1' incorporates:
     *  Constant: '<S4694>/Calib'
     *  RelationalOperator: '<S4690>/GreaterThan'
     *  Sum: '<S4678>/Subtract2'
     */
    if (rtb_TmpSignalConversionAtVeBT_o > (KeTHMR_dT_PsvPmpClntHys_CellMinRSP +
            THMR_ac_B.Switch1_j))
    {
        /* Switch: '<S4690>/Switch1' incorporates:
         *  Constant: '<S4690>/ConstantValue'
         */
        rtb_Switch_az2 = true;
    }
    else
    {
        /* Switch: '<S4690>/Switch1' incorporates:
         *  Constant: '<S4693>/Calib'
         *  RelationalOperator: '<S4690>/GreaterThan1'
         *  Sum: '<S4678>/Subtract1'
         *  UnitDelay: '<S4690>/UnitDelay'
         */
        rtb_Switch_az2 = ((rtb_TmpSignalConversionAtVeBT_o >=
                           (THMR_ac_B.Switch1_j -
                            KeTHMR_dT_PsvPmpClntHys_CellMinLSP)) &&
                          (THMR_ac_DW.UnitDelay_DSTATE_bsk));
    }

    /* End of Switch: '<S4690>/Switch1' */

    /* Update for UnitDelay: '<S4690>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_bsk = rtb_Switch_az2;

    /* End of Outputs for SubSystem: '<S4678>/Hysteresis1' */

    /* Logic: '<S4678>/LogicalOperator' */
    VeTHMR_b_BattPsvHeat_CellTempChk = !rtb_Switch_az2;

    /* Logic: '<S4678>/Logical6' incorporates:
     *  Constant: '<S4692>/Calib'
     *  Logic: '<S4678>/Logical4'
     */
    rtb_Switch_az2 = ((VeTHMR_b_BattPsvHeat_CellTempChk) &&
                      ((VeTHMR_b_ClntChck_BatActvPsvHeat) ||
                       (KeTHMR_b_IgnrClntCrtrea4BattPsvHeat)));

    /* Outputs for Atomic SubSystem: '<S4678>/Debounce1' */
    /* Outputs for Atomic SubSystem: '<S4689>/EdgeBi' */
    /* RelationalOperator: '<S4695>/NotEqual' incorporates:
     *  UnitDelay: '<S4695>/UnitDelay'
     */
    rtb_NotEqual_fo = (rtb_Switch_az2 != THMR_ac_DW.UnitDelay_DSTATE_ps);

    /* Update for UnitDelay: '<S4695>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ps = rtb_Switch_az2;

    /* End of Outputs for SubSystem: '<S4689>/EdgeBi' */

    /* Logic: '<S4689>/Logical1' incorporates:
     *  UnitDelay: '<S4689>/UnitDelay1'
     */
    rtb_TmpSignalConversionAtVeBT_f = (rtb_NotEqual_fo ||
        (THMR_ac_DW.UnitDelay1_DSTATE_my));

    /* Outputs for Atomic SubSystem: '<S4689>/SignalLatchOnWithReset' */
    /* Logic: '<S4696>/OR1' incorporates:
     *  Logic: '<S4696>/NOT'
     *  Logic: '<S4696>/OR'
     *  UnitDelay: '<S4689>/UnitDelay3'
     *  UnitDelay: '<S4696>/UnitDelay'
     */
    rtb_LogicalOperator1_fo = ((THMR_ac_DW.UnitDelay3_DSTATE_d) ||
        ((!rtb_TmpSignalConversionAtVeBT_f) && (THMR_ac_DW.UnitDelay_DSTATE_nol)));

    /* Update for UnitDelay: '<S4696>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_nol = rtb_LogicalOperator1_fo;

    /* End of Outputs for SubSystem: '<S4689>/SignalLatchOnWithReset' */

    /* Switch: '<S4698>/Init' incorporates:
     *  Constant: '<S4698>/InitialCondition'
     *  Logic: '<S4698>/FixPtLogicalOperator'
     *  Logic: '<S4698>/Logical2'
     *  UnitDelay: '<S4698>/FixPtUnitDelay1'
     *  UnitDelay: '<S4698>/FixPtUnitDelay2'
     */
    if (rtb_TmpSignalConversionAtVeBT_f || (((sint32)
            THMR_ac_DW.FixPtUnitDelay2_DSTATE_l4) == 0))
    {
        rtb_Switch_i3 = 0U;
    }
    else
    {
        rtb_Switch_i3 = THMR_ac_DW.FixPtUnitDelay1_DSTATE_j;
    }

    /* End of Switch: '<S4698>/Init' */

    /* Switch: '<S5238>/Init' incorporates:
     *  Sum: '<S4689>/Sum1'
     *  Switch: '<S4689>/Switch2'
     */
    rtb_Switch_i3 = (uint16)(((uint32)(rtb_LogicalOperator1_fo ? 1U : 0U)) +
        ((uint32)rtb_Switch_i3));

    /* RelationalOperator: '<S4689>/Equal1' incorporates:
     *  Constant: '<S4691>/Calib'
     */
    rtb_LogicalOperator1_fo = (((float32)rtb_Switch_i3) >=
        KeTHMR_Cnt_BattPsvHeatDbnc);

    /* Switch: '<S4689>/Switch' */
    if (!rtb_LogicalOperator1_fo)
    {
        /* Switch: '<S4697>/Init' incorporates:
         *  Logic: '<S4697>/Logical2'
         *  UnitDelay: '<S4697>/FixPtUnitDelay2'
         */
        if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_ai) != 0)
        {
            /* Switch: '<S4689>/Switch' incorporates:
             *  UnitDelay: '<S4697>/FixPtUnitDelay1'
             */
            rtb_Switch_az2 = THMR_ac_DW.FixPtUnitDelay1_DSTATE_o;
        }

        /* End of Switch: '<S4697>/Init' */
    }

    /* End of Switch: '<S4689>/Switch' */

    /* Update for UnitDelay: '<S4689>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_d = rtb_NotEqual_fo;

    /* Update for UnitDelay: '<S4689>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_my = rtb_LogicalOperator1_fo;

    /* Update for UnitDelay: '<S4698>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4698>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_l4 = 1U;

    /* Switch: '<S4698>/Reset' */
    if (rtb_TmpSignalConversionAtVeBT_f)
    {
        /* Update for UnitDelay: '<S4698>/FixPtUnitDelay1' incorporates:
         *  Constant: '<S4698>/InitialCondition'
         */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_j = 0U;
    }
    else
    {
        /* Update for UnitDelay: '<S4698>/FixPtUnitDelay1' */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_j = rtb_Switch_i3;
    }

    /* End of Switch: '<S4698>/Reset' */

    /* Update for UnitDelay: '<S4697>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4697>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_ai = 1U;

    /* Update for UnitDelay: '<S4697>/FixPtUnitDelay1' */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE_o = rtb_Switch_az2;

    /* End of Outputs for SubSystem: '<S4678>/Debounce1' */

    /* Logic: '<S4688>/Logical7' incorporates:
     *  Constant: '<S4722>/Constant'
     *  Constant: '<S4723>/Constant'
     *  Logic: '<S4688>/Logical6'
     *  RelationalOperator: '<S4688>/RelationalOperator'
     *  RelationalOperator: '<S4688>/RelationalOperator3'
     */
    rtb_NotEqual_fo = ((((uint32)rtb_LogicalOperator_gg_tmp) ==
                        CeTHMR_e_PassiveCooling) || (((uint32)
                         rtb_Logical1_bnh_tmp) != CeTHMR_e_PsvCooling_LTCLVlvSt));

    /* Outputs for Atomic SubSystem: '<S4688>/Debounce2' */
    /* Outputs for Atomic SubSystem: '<S4721>/EdgeBi' */
    /* RelationalOperator: '<S4726>/NotEqual' incorporates:
     *  UnitDelay: '<S4726>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeBT_f = (rtb_NotEqual_fo !=
        THMR_ac_DW.UnitDelay_DSTATE_ok);

    /* Update for UnitDelay: '<S4726>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ok = rtb_NotEqual_fo;

    /* End of Outputs for SubSystem: '<S4721>/EdgeBi' */

    /* Logic: '<S4721>/Logical1' incorporates:
     *  UnitDelay: '<S4721>/UnitDelay1'
     */
    rtb_LogicalOperator1_fo = (rtb_TmpSignalConversionAtVeBT_f ||
        (THMR_ac_DW.UnitDelay1_DSTATE_hz));

    /* Outputs for Atomic SubSystem: '<S4721>/SignalLatchOnWithReset' */
    /* Logic: '<S4727>/OR1' incorporates:
     *  Logic: '<S4727>/NOT'
     *  Logic: '<S4727>/OR'
     *  UnitDelay: '<S4721>/UnitDelay3'
     *  UnitDelay: '<S4727>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeBT_m = ((THMR_ac_DW.UnitDelay3_DSTATE_j2) ||
        ((!rtb_LogicalOperator1_fo) && (THMR_ac_DW.UnitDelay_DSTATE_f3)));

    /* Update for UnitDelay: '<S4727>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_f3 = rtb_TmpSignalConversionAtVeBT_m;

    /* End of Outputs for SubSystem: '<S4721>/SignalLatchOnWithReset' */

    /* Switch: '<S4729>/Init' incorporates:
     *  Constant: '<S4729>/InitialCondition'
     *  Logic: '<S4729>/FixPtLogicalOperator'
     *  Logic: '<S4729>/Logical2'
     *  UnitDelay: '<S4729>/FixPtUnitDelay1'
     *  UnitDelay: '<S4729>/FixPtUnitDelay2'
     */
    if (rtb_LogicalOperator1_fo || (((sint32)
            THMR_ac_DW.FixPtUnitDelay2_DSTATE_a0) == 0))
    {
        rtb_Switch_i3 = 0U;
    }
    else
    {
        rtb_Switch_i3 = THMR_ac_DW.FixPtUnitDelay1_DSTATE_dg;
    }

    /* End of Switch: '<S4729>/Init' */

    /* Switch: '<S5238>/Init' incorporates:
     *  Sum: '<S4721>/Sum1'
     *  Switch: '<S4721>/Switch2'
     */
    rtb_Switch_i3 = (uint16)(((uint32)(rtb_TmpSignalConversionAtVeBT_m ? 1U : 0U))
        + ((uint32)rtb_Switch_i3));

    /* RelationalOperator: '<S4721>/Equal1' incorporates:
     *  Constant: '<S4724>/Calib'
     */
    rtb_TmpSignalConversionAtVeBT_m = (rtb_Switch_i3 >=
        KeTHMR_Cnt_LTCLCool_InhbtPsvHeatStates);

    /* Switch: '<S4721>/Switch' */
    if (!rtb_TmpSignalConversionAtVeBT_m)
    {
        /* Switch: '<S4728>/Init' incorporates:
         *  Logic: '<S4728>/Logical2'
         *  UnitDelay: '<S4728>/FixPtUnitDelay2'
         */
        if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_f) != 0)
        {
            /* Switch: '<S4721>/Switch' incorporates:
             *  UnitDelay: '<S4728>/FixPtUnitDelay1'
             */
            rtb_NotEqual_fo = THMR_ac_DW.FixPtUnitDelay1_DSTATE_iq;
        }

        /* End of Switch: '<S4728>/Init' */
    }

    /* End of Switch: '<S4721>/Switch' */

    /* Update for UnitDelay: '<S4721>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_j2 = rtb_TmpSignalConversionAtVeBT_f;

    /* Update for UnitDelay: '<S4721>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_hz = rtb_TmpSignalConversionAtVeBT_m;

    /* Update for UnitDelay: '<S4729>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4729>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_a0 = 1U;

    /* Switch: '<S4729>/Reset' */
    if (rtb_LogicalOperator1_fo)
    {
        /* Update for UnitDelay: '<S4729>/FixPtUnitDelay1' incorporates:
         *  Constant: '<S4729>/InitialCondition'
         */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_dg = 0U;
    }
    else
    {
        /* Update for UnitDelay: '<S4729>/FixPtUnitDelay1' */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_dg = rtb_Switch_i3;
    }

    /* End of Switch: '<S4729>/Reset' */

    /* Update for UnitDelay: '<S4728>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4728>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_f = 1U;

    /* Update for UnitDelay: '<S4728>/FixPtUnitDelay1' */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE_iq = rtb_NotEqual_fo;

    /* End of Outputs for SubSystem: '<S4688>/Debounce2' */

    /* Product: '<S4116>/Product9' incorporates:
     *  Constant: '<S4530>/Calib'
     *  Product: '<S4116>/Product1'
     */
    rtb_Product9_h[0] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[0] ? ((sint32)
        (rtb_RelationalOperator9_h ? 1 : 0)) : 0);
    rtb_Product9_h[1] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[1] ? ((sint32)
        (rtb_RelationalOperator3_aj ? 1 : 0)) : 0);
    rtb_Product9_h[2] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[2] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_jd ? 1 : 0)) : 0);
    rtb_Product9_h[3] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[3] ? ((sint32)
        (rtb_Logical27 ? 1 : 0)) : 0);
    rtb_Product9_h[4] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[4] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_o ? 1 : 0)) : 0);
    rtb_Product9_h[5] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[5] ? ((sint32)
        (rtb_OR1_b3 ? 1 : 0)) : 0);
    rtb_Product9_h[6] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[6] ? ((sint32)
        (rtb_AND_hz ? 1 : 0)) : 0);
    rtb_Product9_h[7] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[7] ? ((sint32)
        (rtb_TmpSignalConversionAtVeFC_a ? 1 : 0)) : 0);
    rtb_Product9_h[8] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[8] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_j ? 1 : 0)) : 0);
    rtb_Product9_h[9] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[9] ? ((sint32)
        (rtb_TmpSignalConversionAtVeT_f5 ? 1 : 0)) : 0);
    rtb_Product9_h[10] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[10] ? ((sint32)
        (rtb_UnitDelay3_ff ? 1 : 0)) : 0);
    rtb_Product9_h[11] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[11] ? ((sint32)
        (rtb_LogicalOperator3_jq ? 1 : 0)) : 0);
    rtb_Product9_h[12] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[12] ? ((sint32)
        (rtb_TmpSignalConversionAtVeF_hw ? 1 : 0)) : 0);
    rtb_Product9_h[13] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[13] ? ((sint32)
        (aVarTruthTableCondition_4 ? 1 : 0)) : 0);
    rtb_Product9_h[14] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[14] ? ((sint32)
        (rtb_LogicalOperator_dv ? 1 : 0)) : 0);
    rtb_Product9_h[15] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[15] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_m4 ? 1 : 0)) : 0);
    rtb_Product9_h[16] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[16] ? ((sint32)
        (rtb_LogicalOperator1_nm ? 1 : 0)) : 0);
    rtb_Product9_h[17] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[17] ? ((sint32)
        (rtb_LogicalOperator4_j ? 1 : 0)) : 0);
    rtb_Product9_h[18] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[18] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTP_c ? 1 : 0)) : 0);
    rtb_Product9_h[19] = (sint8)(KaTHMR_b_BattPsvHeatDsbl_RA[19] ? ((sint32)
        (rtb_VariantMerge_For_Variant__b ? 1 : 0)) : 0);

    /* MinMax: '<S4116>/MinMax1' */
    rtb_Switch_i3 = (uint16)rtb_Product9_h[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 19;
            rtb_DataTypeConversion2++)
    {
        u1 = (uint16)rtb_Product9_h[rtb_DataTypeConversion2 + 1];
        if (rtb_Switch_i3 > u1)
        {
            rtb_Switch_i3 = 1U;
        }
        else
        {
            rtb_Switch_i3 = u1;
        }
    }

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeBTRR_b_Psv_BattHeatReq' */
    (void)Rte_Read_VeBTRR_b_Psv_BattHeatReq_Value(&rtb_Switch1_nqi);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Logic: '<S4599>/Logical4' incorporates:
     *  Logic: '<S4574>/LogicalOperator3'
     *  Logic: '<S5131>/Logical1'
     */
    rtb_TmpSignalConversionAtVeBT_f = !THMR_ac_B.Logical2;

    /* Logic: '<S4599>/Logical5' incorporates:
     *  Constant: '<S4680>/Constant'
     *  Constant: '<S4681>/Calib'
     *  Constant: '<S4683>/Calib'
     *  Constant: '<S4685>/Calib'
     *  Constant: '<S4717>/Constant'
     *  Constant: '<S4718>/Calib'
     *  Constant: '<S4720>/Calib'
     *  Constant: '<S4725>/Calib'
     *  DataTypeConversion: '<S4116>/DataTypeConversion1'
     *  Logic: '<S4599>/Logical10'
     *  Logic: '<S4599>/Logical11'
     *  Logic: '<S4599>/Logical2'
     *  Logic: '<S4599>/Logical3'
     *  Logic: '<S4599>/Logical4'
     *  Logic: '<S4686>/Logical12'
     *  Logic: '<S4686>/Logical14'
     *  Logic: '<S4687>/Logical14'
     *  Logic: '<S4688>/Logical1'
     *  MinMax: '<S4116>/MinMax1'
     *  RelationalOperator: '<S4599>/Comparison6'
     *  RelationalOperator: '<S4599>/RelationalOperator'
     *  RelationalOperator: '<S4686>/Comparison1'
     */
    VeTHMR_b_BattPassiveHeat = ((((((((((((rtb_Switch1_nqi &&
        rtb_LogicalOperator_iw) && rtb_Switch_az2) && rtb_OR1_k3) &&
        rtb_Switch1_az) && ((((uint32)rtb_TmpSignalConversionAtVeBRDR) !=
        CeBRDR_e_BatCltLvlLo) || (KeTHMR_b_DsblClntLoChk))) && (rtb_AND_de &&
        ((((uint32)rtb_TmpSignalConversionAtVeP_pf) == CePMPR_e_FTSNA_False) ||
         (KeTHMR_b_DsblDryRunChk)))) && ((THMR_ac_B.Switch1_h) ||
        (KeTHMR_b_Enbl_BattAllwd_PsvHeat))) && (rtb_TmpSignalConversionAtVeBT_o >=
        KeTHMR_T_CellTempMin_BattPsvHeatEnbl)) && ((KeTHMR_b_BTLHTLDrctConnct) ||
        rtb_NotEqual_fo)) && (((sint32)rtb_Switch_i3) == 0)) &&
        (!KeTHMR_b_DsblPassiveHeat)) && rtb_TmpSignalConversionAtVeBT_f);

    /* Logic: '<S4921>/Logical9' */
    rtb_TmpSignalConversionAtVeCT_m = !rtb_TmpSignalConversionAtVeCT_m;

    /* RelationalOperator: '<S4925>/RelationalOperator8' incorporates:
     *  Logic: '<S4925>/Logical1'
     *  Logic: '<S4925>/Logical2'
     *  Logic: '<S4925>/LogicalOperator1'
     *  Logic: '<S4925>/LogicalOperator4'
     *  Logic: '<S4932>/Logical1'
     *  Logic: '<S4933>/Logical1'
     *  RelationalOperator: '<S4925>/Comparison5'
     *  Sum: '<S4925>/Subtraction'
     *  Sum: '<S4932>/Subtract3'
     *  Sum: '<S4932>/Subtract5'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_ECM_Absent

    /* Outputs for Atomic SubSystem: '<S4933>/Hysteresis1' */
    /* Outputs for Atomic SubSystem: '<S4933>/Hysteresis3' */
    /* Outputs for Atomic SubSystem: '<S4932>/Hysteresis1' */
    /* Outputs for Atomic SubSystem: '<S4932>/Hysteresis2' */
    /* Outputs for Atomic SubSystem: '<S4925>/Hysteresis1' */
    /* RelationalOperator: '<S4925>/RelationalOperator8' incorporates:
     *  Constant: '<S4935>/Constant'
     */
    rtb_TmpSignalConversionAtVeBT_m = (((uint32)rtb_TmpSignalConversionAtVeRC_a)
        == CeRCVR_e_Faulty_Open);

    /* Switch: '<S4937>/Switch1' incorporates:
     *  Constant: '<S4939>/Calib'
     *  RelationalOperator: '<S4937>/GreaterThan'
     */
    if (VeTHMR_P_ClntHeatAbsrbFrmEDU_Arb > KeTHMR_P_EDURawWasteHeat_Cab_MaxLim)
    {
        /* Switch: '<S4937>/Switch1' incorporates:
         *  Constant: '<S4937>/ConstantValue'
         */
        rtb_Switch1_btw = true;
    }
    else
    {
        /* Switch: '<S4937>/Switch1' incorporates:
         *  Constant: '<S4940>/Calib'
         *  RelationalOperator: '<S4937>/GreaterThan1'
         *  UnitDelay: '<S4937>/UnitDelay'
         */
        rtb_Switch1_btw = ((VeTHMR_P_ClntHeatAbsrbFrmEDU_Arb >=
                            KeTHMR_P_EDURawWasteHeat_Cab_MinLim) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_is0));
    }

    /* End of Switch: '<S4937>/Switch1' */

    /* Update for UnitDelay: '<S4937>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_is0 = rtb_Switch1_btw;

    /* Switch: '<S4944>/Switch1' incorporates:
     *  Constant: '<S4946>/Calib'
     *  RelationalOperator: '<S4944>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeTM_f > (rtb_TmpSignalConversionAtVePM_l +
            KeTHMR_dT_PECTOS_HCCTOS_RSP_CabActvPsvHeat))
    {
        /* Switch: '<S4944>/Switch1' incorporates:
         *  Constant: '<S4944>/ConstantValue'
         */
        rtb_Switch1_nqi = true;
    }
    else
    {
        /* Switch: '<S4944>/Switch1' incorporates:
         *  Constant: '<S4945>/Calib'
         *  RelationalOperator: '<S4944>/GreaterThan1'
         *  Sum: '<S4932>/Subtract2'
         *  UnitDelay: '<S4944>/UnitDelay'
         */
        rtb_Switch1_nqi = ((rtb_TmpSignalConversionAtVeTM_f >=
                            (rtb_TmpSignalConversionAtVePM_l -
                             KeTHMR_dT_PECTOS_HCCTOS_LSP_CabActvPsvHeat)) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_fv));
    }

    /* End of Switch: '<S4944>/Switch1' */

    /* Update for UnitDelay: '<S4944>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_fv = rtb_Switch1_nqi;

    /* Switch: '<S4943>/Switch1' incorporates:
     *  Constant: '<S4948>/Calib'
     *  RelationalOperator: '<S4943>/GreaterThan'
     */
    if (THMR_ac_B.Switch1_j > (rtb_TmpSignalConversionAtVeT_n0 +
                               KeTHMR_dT_PPCTIS_ECHTIS_RSP_CabActvPsvHeat))
    {
        /* Switch: '<S4943>/Switch1' incorporates:
         *  Constant: '<S4943>/ConstantValue'
         */
        rtb_LogicalOperator_iw = true;
    }
    else
    {
        /* Switch: '<S4943>/Switch1' incorporates:
         *  Constant: '<S4947>/Calib'
         *  RelationalOperator: '<S4943>/GreaterThan1'
         *  Sum: '<S4932>/Subtract1'
         *  UnitDelay: '<S4943>/UnitDelay'
         */
        rtb_LogicalOperator_iw = ((THMR_ac_B.Switch1_j >=
            (rtb_TmpSignalConversionAtVeT_n0 -
             KeTHMR_dT_PPCTIS_ECHTIS_LSP_CabActvPsvHeat)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_gz));
    }

    /* End of Switch: '<S4943>/Switch1' */

    /* Update for UnitDelay: '<S4943>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_gz = rtb_LogicalOperator_iw;

    /* Switch: '<S4950>/Switch1' incorporates:
     *  Constant: '<S4952>/Calib'
     *  RelationalOperator: '<S4950>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVePM_l > KeTHMR_T_HCCTOStooHot4LTCL)
    {
        /* Switch: '<S4950>/Switch1' incorporates:
         *  Constant: '<S4950>/ConstantValue'
         */
        rtb_Switch_az2 = true;
    }
    else
    {
        /* Switch: '<S4950>/Switch1' incorporates:
         *  Constant: '<S4951>/Calib'
         *  RelationalOperator: '<S4950>/GreaterThan1'
         *  UnitDelay: '<S4950>/UnitDelay'
         */
        rtb_Switch_az2 = ((rtb_TmpSignalConversionAtVePM_l >=
                           KeTHMR_T_HCCTOSNominal4LTCL) &&
                          (THMR_ac_DW.UnitDelay_DSTATE_le));
    }

    /* End of Switch: '<S4950>/Switch1' */

    /* Update for UnitDelay: '<S4950>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_le = rtb_Switch_az2;

    /* Switch: '<S4949>/Switch1' incorporates:
     *  Constant: '<S4954>/Calib'
     *  RelationalOperator: '<S4949>/GreaterThan'
     */
    if (THMR_ac_B.Switch1_j > KeTHMR_T_PPCTIStooHot4LTCL)
    {
        /* Switch: '<S4949>/Switch1' incorporates:
         *  Constant: '<S4949>/ConstantValue'
         */
        rtb_NotEqual_fo = true;
    }
    else
    {
        /* Switch: '<S4949>/Switch1' incorporates:
         *  Constant: '<S4953>/Calib'
         *  RelationalOperator: '<S4949>/GreaterThan1'
         *  UnitDelay: '<S4949>/UnitDelay'
         */
        rtb_NotEqual_fo = ((THMR_ac_B.Switch1_j >= KeTHMR_T_PPCTISNominal4LTCL) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_n5));
    }

    /* End of Switch: '<S4949>/Switch1' */

    /* Update for UnitDelay: '<S4949>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_n5 = rtb_NotEqual_fo;

    /* VariantMerge generated from: '<S4925>/VariantSource' */
    rtb_Switch1_btw = ((((rtb_TmpSignalConversionAtVeBT_m ||
                          rtb_TmpSignalConversionAtVeCT_m) || rtb_Switch1_btw) &&
                        (rtb_Switch1_nqi || rtb_LogicalOperator_iw)) &&
                       ((!rtb_Switch_az2) && (!rtb_NotEqual_fo)));

    /* End of Outputs for SubSystem: '<S4925>/Hysteresis1' */
    /* End of Outputs for SubSystem: '<S4932>/Hysteresis2' */
    /* End of Outputs for SubSystem: '<S4932>/Hysteresis1' */
    /* End of Outputs for SubSystem: '<S4933>/Hysteresis3' */
    /* End of Outputs for SubSystem: '<S4933>/Hysteresis1' */
#else

    /* Outputs for Atomic SubSystem: '<S4925>/Hysteresis' */
    /* Switch: '<S4936>/Switch1' incorporates:
     *  Constant: '<S4942>/Calib'
     *  RelationalOperator: '<S4936>/Greater  Than'
     *  Sum: '<S4925>/Subtraction'
     */
    if (VeTHMR_T_EngCoolantTemp > (rtb_TmpSignalConversionAtVeT_n0 +
            KeTHMR_T_ECT_ECHTIS_Hyst))
    {
        /* Switch: '<S4936>/Switch1' incorporates:
         *  Constant: '<S4936>/Constant Value'
         */
        rtb_Switch1_btw = true;
    }
    else
    {
        /* Switch: '<S4936>/Switch1' incorporates:
         *  RelationalOperator: '<S4936>/Greater  Than1'
         *  UnitDelay: '<S4936>/Unit Delay'
         */
        rtb_Switch1_btw = ((VeTHMR_T_EngCoolantTemp >=
                            rtb_TmpSignalConversionAtVeT_n0) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_lv));
    }

    /* End of Switch: '<S4936>/Switch1' */

    /* Update for UnitDelay: '<S4936>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_lv = rtb_Switch1_btw;

    /* VariantMerge generated from: '<S4925>/VariantSource' incorporates:
     *  Constant: '<S4941>/Calib'
     *  Logic: '<S4925>/Logical2'
     *  RelationalOperator: '<S4925>/Comparison5'
     */
    rtb_Switch1_btw = ((rtb_TmpSignalConversionAtVeTA_b > KeTHMR_P_EngHotPwr_Min)
                       && rtb_Switch1_btw);

    /* End of Outputs for SubSystem: '<S4925>/Hysteresis' */
#endif

    /* End of RelationalOperator: '<S4925>/RelationalOperator8' */

    /* Outputs for Atomic SubSystem: '<S4925>/Debounce2' */
    /* Outputs for Atomic SubSystem: '<S4934>/EdgeBi' */
    /* RelationalOperator: '<S4955>/NotEqual' incorporates:
     *  UnitDelay: '<S4955>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeBT_m = (rtb_Switch1_btw !=
        THMR_ac_DW.UnitDelay_DSTATE_jmx);

    /* Update for UnitDelay: '<S4955>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_jmx = rtb_Switch1_btw;

    /* End of Outputs for SubSystem: '<S4934>/EdgeBi' */

    /* Logic: '<S4934>/Logical1' incorporates:
     *  UnitDelay: '<S4934>/UnitDelay1'
     */
    rtb_Switch1_nqi = (rtb_TmpSignalConversionAtVeBT_m ||
                       (THMR_ac_DW.UnitDelay1_DSTATE_di));

    /* Outputs for Atomic SubSystem: '<S4934>/SignalLatchOnWithReset' */
    /* Logic: '<S4956>/OR1' incorporates:
     *  Logic: '<S4956>/NOT'
     *  Logic: '<S4956>/OR'
     *  UnitDelay: '<S4934>/UnitDelay3'
     *  UnitDelay: '<S4956>/UnitDelay'
     */
    rtb_LogicalOperator_iw = ((THMR_ac_DW.UnitDelay3_DSTATE_lm) ||
        ((!rtb_Switch1_nqi) && (THMR_ac_DW.UnitDelay_DSTATE_ixn)));

    /* Update for UnitDelay: '<S4956>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ixn = rtb_LogicalOperator_iw;

    /* End of Outputs for SubSystem: '<S4934>/SignalLatchOnWithReset' */

    /* Switch: '<S4958>/Init' incorporates:
     *  Constant: '<S4958>/InitialCondition'
     *  Logic: '<S4958>/FixPtLogicalOperator'
     *  Logic: '<S4958>/Logical2'
     *  UnitDelay: '<S4958>/FixPtUnitDelay1'
     *  UnitDelay: '<S4958>/FixPtUnitDelay2'
     */
    if (rtb_Switch1_nqi || (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_eg) == 0))
    {
        rtb_Switch_i3 = 0U;
    }
    else
    {
        rtb_Switch_i3 = THMR_ac_DW.FixPtUnitDelay1_DSTATE_p;
    }

    /* End of Switch: '<S4958>/Init' */

    /* Switch: '<S5238>/Init' incorporates:
     *  Sum: '<S4934>/Sum1'
     *  Switch: '<S4934>/Switch2'
     */
    rtb_Switch_i3 = (uint16)(((uint32)(rtb_LogicalOperator_iw ? 1U : 0U)) +
        ((uint32)rtb_Switch_i3));

    /* RelationalOperator: '<S4934>/Equal1' incorporates:
     *  Constant: '<S4938>/Calib'
     */
    rtb_LogicalOperator_iw = (((float32)rtb_Switch_i3) >=
        KeTHMR_Cnt_CabPsvHeatDbnc);

    /* Switch: '<S4934>/Switch' */
    if (!rtb_LogicalOperator_iw)
    {
        /* Switch: '<S4957>/Init' incorporates:
         *  Logic: '<S4957>/Logical2'
         *  UnitDelay: '<S4957>/FixPtUnitDelay2'
         */
        if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_hn) != 0)
        {
            /* Switch: '<S4934>/Switch' incorporates:
             *  UnitDelay: '<S4957>/FixPtUnitDelay1'
             */
            rtb_Switch1_btw = THMR_ac_DW.FixPtUnitDelay1_DSTATE_n5;
        }

        /* End of Switch: '<S4957>/Init' */
    }

    /* End of Switch: '<S4934>/Switch' */

    /* Update for UnitDelay: '<S4934>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_lm = rtb_TmpSignalConversionAtVeBT_m;

    /* Update for UnitDelay: '<S4934>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_di = rtb_LogicalOperator_iw;

    /* Update for UnitDelay: '<S4958>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4958>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_eg = 1U;

    /* Switch: '<S4958>/Reset' */
    if (rtb_Switch1_nqi)
    {
        /* Update for UnitDelay: '<S4958>/FixPtUnitDelay1' incorporates:
         *  Constant: '<S4958>/InitialCondition'
         */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_p = 0U;
    }
    else
    {
        /* Update for UnitDelay: '<S4958>/FixPtUnitDelay1' */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_p = rtb_Switch_i3;
    }

    /* End of Switch: '<S4958>/Reset' */

    /* Update for UnitDelay: '<S4957>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4957>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_hn = 1U;

    /* Update for UnitDelay: '<S4957>/FixPtUnitDelay1' */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE_n5 = rtb_Switch1_btw;

    /* End of Outputs for SubSystem: '<S4925>/Debounce2' */

    /* RelationalOperator: '<S4931>/RelationalOperator3' incorporates:
     *  RelationalOperator: '<S4922>/RelationalOperator1'
     *  RelationalOperator: '<S4982>/Comparison2'
     *  UnitDelay: '<S4569>/UnitDelay1'
     */
    VeTHMR_b_LearningOk_tmp = THMR_ac_DW.UnitDelay1_DSTATE_au;

    /* Logic: '<S4931>/Logical7' incorporates:
     *  Constant: '<S4960>/Constant'
     *  Constant: '<S4961>/Constant'
     *  Logic: '<S4931>/Logical6'
     *  RelationalOperator: '<S4931>/RelationalOperator'
     *  RelationalOperator: '<S4931>/RelationalOperator3'
     */
    rtb_TmpSignalConversionAtVeBT_m = ((((uint32)VeTHMR_b_LearningOk_tmp) ==
        CeTHMR_e_PassiveCooling) || (((uint32)rtb_Logical1_bnh_tmp) !=
        CeTHMR_e_PsvCooling_LTCLVlvSt));

    /* Outputs for Atomic SubSystem: '<S4931>/Debounce2' */
    /* Outputs for Atomic SubSystem: '<S4959>/EdgeBi' */
    /* RelationalOperator: '<S4963>/NotEqual' incorporates:
     *  UnitDelay: '<S4963>/UnitDelay'
     */
    rtb_Switch1_nqi = (rtb_TmpSignalConversionAtVeBT_m !=
                       THMR_ac_DW.UnitDelay_DSTATE_jn);

    /* Update for UnitDelay: '<S4963>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_jn = rtb_TmpSignalConversionAtVeBT_m;

    /* End of Outputs for SubSystem: '<S4959>/EdgeBi' */

    /* Logic: '<S4959>/Logical1' incorporates:
     *  UnitDelay: '<S4959>/UnitDelay1'
     */
    rtb_LogicalOperator_iw = (rtb_Switch1_nqi ||
        (THMR_ac_DW.UnitDelay1_DSTATE_bj));

    /* Outputs for Atomic SubSystem: '<S4959>/SignalLatchOnWithReset' */
    /* Logic: '<S4964>/OR1' incorporates:
     *  Logic: '<S4964>/NOT'
     *  Logic: '<S4964>/OR'
     *  UnitDelay: '<S4959>/UnitDelay3'
     *  UnitDelay: '<S4964>/UnitDelay'
     */
    rtb_Switch_az2 = ((THMR_ac_DW.UnitDelay3_DSTATE_m0) ||
                      ((!rtb_LogicalOperator_iw) &&
                       (THMR_ac_DW.UnitDelay_DSTATE_fec)));

    /* Update for UnitDelay: '<S4964>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_fec = rtb_Switch_az2;

    /* End of Outputs for SubSystem: '<S4959>/SignalLatchOnWithReset' */

    /* Switch: '<S4966>/Init' incorporates:
     *  Constant: '<S4966>/InitialCondition'
     *  Logic: '<S4966>/FixPtLogicalOperator'
     *  Logic: '<S4966>/Logical2'
     *  UnitDelay: '<S4966>/FixPtUnitDelay1'
     *  UnitDelay: '<S4966>/FixPtUnitDelay2'
     */
    if (rtb_LogicalOperator_iw || (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_e)
         == 0))
    {
        rtb_Switch_i3 = 0U;
    }
    else
    {
        rtb_Switch_i3 = THMR_ac_DW.FixPtUnitDelay1_DSTATE_gc;
    }

    /* End of Switch: '<S4966>/Init' */

    /* Switch: '<S5238>/Init' incorporates:
     *  Sum: '<S4959>/Sum1'
     *  Switch: '<S4959>/Switch2'
     */
    rtb_Switch_i3 = (uint16)(((uint32)(rtb_Switch_az2 ? 1U : 0U)) + ((uint32)
        rtb_Switch_i3));

    /* RelationalOperator: '<S4959>/Equal1' incorporates:
     *  Constant: '<S4962>/Calib'
     */
    rtb_Switch_az2 = (rtb_Switch_i3 >= KeTHMR_Cnt_LTCLCool_InhbtPsvHeatStates);

    /* Switch: '<S4959>/Switch' */
    if (!rtb_Switch_az2)
    {
        /* Switch: '<S4965>/Init' incorporates:
         *  Logic: '<S4965>/Logical2'
         *  UnitDelay: '<S4965>/FixPtUnitDelay2'
         */
        if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_c) != 0)
        {
            /* Switch: '<S4959>/Switch' incorporates:
             *  UnitDelay: '<S4965>/FixPtUnitDelay1'
             */
            rtb_TmpSignalConversionAtVeBT_m =
                THMR_ac_DW.FixPtUnitDelay1_DSTATE_al;
        }

        /* End of Switch: '<S4965>/Init' */
    }

    /* End of Switch: '<S4959>/Switch' */

    /* Update for UnitDelay: '<S4959>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_m0 = rtb_Switch1_nqi;

    /* Update for UnitDelay: '<S4959>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_bj = rtb_Switch_az2;

    /* Update for UnitDelay: '<S4966>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4966>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_e = 1U;

    /* Switch: '<S4966>/Reset' */
    if (rtb_LogicalOperator_iw)
    {
        /* Update for UnitDelay: '<S4966>/FixPtUnitDelay1' incorporates:
         *  Constant: '<S4966>/InitialCondition'
         */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_gc = 0U;
    }
    else
    {
        /* Update for UnitDelay: '<S4966>/FixPtUnitDelay1' */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_gc = rtb_Switch_i3;
    }

    /* End of Switch: '<S4966>/Reset' */

    /* Update for UnitDelay: '<S4965>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S4965>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_c = 1U;

    /* Update for UnitDelay: '<S4965>/FixPtUnitDelay1' */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE_al = rtb_TmpSignalConversionAtVeBT_m;

    /* End of Outputs for SubSystem: '<S4931>/Debounce2' */

    /* Product: '<S4116>/Product9' incorporates:
     *  Constant: '<S4533>/Calib'
     *  Product: '<S4116>/Product3'
     */
    rtb_Product9_h[0] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[0] ? ((sint32)
        (rtb_RelationalOperator9_h ? 1 : 0)) : 0);
    rtb_Product9_h[1] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[1] ? ((sint32)
        (rtb_RelationalOperator3_aj ? 1 : 0)) : 0);
    rtb_Product9_h[2] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[2] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_jd ? 1 : 0)) : 0);
    rtb_Product9_h[3] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[3] ? ((sint32)
        (rtb_Logical27 ? 1 : 0)) : 0);
    rtb_Product9_h[4] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[4] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_o ? 1 : 0)) : 0);
    rtb_Product9_h[5] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[5] ? ((sint32)
        (rtb_OR1_b3 ? 1 : 0)) : 0);
    rtb_Product9_h[6] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[6] ? ((sint32)
        (rtb_AND_hz ? 1 : 0)) : 0);
    rtb_Product9_h[7] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[7] ? ((sint32)
        (rtb_TmpSignalConversionAtVeFC_a ? 1 : 0)) : 0);
    rtb_Product9_h[8] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[8] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_j ? 1 : 0)) : 0);
    rtb_Product9_h[9] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[9] ? ((sint32)
        (rtb_TmpSignalConversionAtVeT_f5 ? 1 : 0)) : 0);
    rtb_Product9_h[10] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[10] ? ((sint32)
        (rtb_UnitDelay3_ff ? 1 : 0)) : 0);
    rtb_Product9_h[11] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[11] ? ((sint32)
        (rtb_LogicalOperator3_jq ? 1 : 0)) : 0);
    rtb_Product9_h[12] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[12] ? ((sint32)
        (rtb_TmpSignalConversionAtVeF_hw ? 1 : 0)) : 0);
    rtb_Product9_h[13] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[13] ? ((sint32)
        (aVarTruthTableCondition_4 ? 1 : 0)) : 0);
    rtb_Product9_h[14] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[14] ? ((sint32)
        (rtb_LogicalOperator_dv ? 1 : 0)) : 0);
    rtb_Product9_h[15] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[15] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_m4 ? 1 : 0)) : 0);
    rtb_Product9_h[16] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[16] ? ((sint32)
        (rtb_LogicalOperator1_nm ? 1 : 0)) : 0);
    rtb_Product9_h[17] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[17] ? ((sint32)
        (rtb_LogicalOperator4_j ? 1 : 0)) : 0);
    rtb_Product9_h[18] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[18] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTP_c ? 1 : 0)) : 0);
    rtb_Product9_h[19] = (sint8)(KaTHMR_b_CabActvPsvHeatDsbl_RA[19] ? ((sint32)
        (rtb_VariantMerge_For_Variant__b ? 1 : 0)) : 0);

    /* MinMax: '<S4116>/MinMax3' */
    rtb_Switch_i3 = (uint16)rtb_Product9_h[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 19;
            rtb_DataTypeConversion2++)
    {
        u1 = (uint16)rtb_Product9_h[rtb_DataTypeConversion2 + 1];
        if (rtb_Switch_i3 > u1)
        {
            rtb_Switch_i3 = 1U;
        }
        else
        {
            rtb_Switch_i3 = u1;
        }
    }

    /* Logic: '<S4920>/Logical6' incorporates:
     *  Logic: '<S4107>/Logical6'
     */
    rtb_LogicalOperator1_fo = !VeTHMR_b_HTAuxPmpDryRunFA_AD;

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* Logic: '<S4920>/LogicalOperator' incorporates:
     *  Constant: '<S4926>/Constant'
     *  Constant: '<S4927>/Constant'
     *  Constant: '<S4928>/Calib'
     *  Constant: '<S4929>/Calib'
     *  Constant: '<S4930>/Calib'
     *  DataTypeConversion: '<S4116>/DataTypeConversion3'
     *  Logic: '<S4920>/Logical2'
     *  Logic: '<S4920>/Logical3'
     *  Logic: '<S4920>/Logical6'
     *  Logic: '<S4920>/LogicalOperator2'
     *  Logic: '<S4920>/LogicalOperator3'
     *  MinMax: '<S4116>/MinMax3'
     *  RelationalOperator: '<S1465>/Comparison1'
     *  RelationalOperator: '<S4920>/Comparison5'
     *  RelationalOperator: '<S4920>/RelationalOperator'
     *  RelationalOperator: '<S4920>/RelationalOperator3'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     *  Switch: '<S3792>/Switch'
     */
    VeTHMR_b_CabActvPsvHeat = ((((((((VeTHMR_b_CabActvHeat) && rtb_Switch1_btw) &&
        (rtb_TmpSignalConversionAtVeCTRR <=
         KeTHMR_T_HCCTISTgt_AllwCabActvPsvCond)) && (((uint32)
        rtb_TmpSignalConversionAtVePD_l) == CePDTR_e_No_Dischrg)) &&
        rtb_TmpSignalConversionAtVeBT_m) && (((sint32)rtb_Switch_i3) == 0)) && (
        !KeTHMR_b_DsblCabActvPsvHeat)) &&
        ((KeTHMR_b_BypassHTAPDryRun_CabinActvPsvHeat) || ((((uint32)
        VeTHMR_e_HTAuxPumpDryRun_AD) == CePMPR_e_FTSNA_False) &&
        rtb_LogicalOperator1_fo)));

    /* Logic: '<S4918>/LogicalOperator' incorporates:
     *  Logic: '<S4569>/LogicalOperator'
     */
    VeTHMR_b_CabActvCool = (((rtb_AND_fe && (VeTHMR_b_AC_CompReq)) &&
        rtb_TmpSignalConversionAtVeTR_i) && rtb_VariantMerge_For_Variant__j);

    /* Outputs for Atomic SubSystem: '<S4922>/Hysteresis2' */
    /* Switch: '<S4976>/Switch1' incorporates:
     *  Constant: '<S4977>/Calib'
     *  RelationalOperator: '<S4976>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeT_n0 > KeTHMR_T_ECHTISHtPumpDsbl)
    {
        /* Switch: '<S4976>/Switch1' incorporates:
         *  Constant: '<S4976>/ConstantValue'
         */
        rtb_Switch_az2 = true;
    }
    else
    {
        /* Switch: '<S4976>/Switch1' incorporates:
         *  Constant: '<S4978>/Calib'
         *  RelationalOperator: '<S4976>/GreaterThan1'
         *  UnitDelay: '<S4976>/UnitDelay'
         */
        rtb_Switch_az2 = ((rtb_TmpSignalConversionAtVeT_n0 >=
                           KeTHMR_T_ECHTIS_HtPumpEnbl) &&
                          (THMR_ac_DW.UnitDelay_DSTATE_ex));
    }

    /* End of Switch: '<S4976>/Switch1' */

    /* Update for UnitDelay: '<S4976>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ex = rtb_Switch_az2;

    /* End of Outputs for SubSystem: '<S4922>/Hysteresis2' */

    /* Product: '<S4116>/Product9' incorporates:
     *  Constant: '<S4535>/Calib'
     *  Product: '<S4116>/Product6'
     */
    rtb_Product9_h[0] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[0] ? ((sint32)
        (rtb_RelationalOperator9_h ? 1 : 0)) : 0);
    rtb_Product9_h[1] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[1] ? ((sint32)
        (rtb_RelationalOperator3_aj ? 1 : 0)) : 0);
    rtb_Product9_h[2] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[2] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_jd ? 1 : 0)) : 0);
    rtb_Product9_h[3] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[3] ? ((sint32)
        (rtb_Logical27 ? 1 : 0)) : 0);
    rtb_Product9_h[4] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[4] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_o ? 1 : 0)) : 0);
    rtb_Product9_h[5] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[5] ? ((sint32)
        (rtb_OR1_b3 ? 1 : 0)) : 0);
    rtb_Product9_h[6] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[6] ? ((sint32)
        (rtb_AND_hz ? 1 : 0)) : 0);
    rtb_Product9_h[7] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[7] ? ((sint32)
        (rtb_TmpSignalConversionAtVeFC_a ? 1 : 0)) : 0);
    rtb_Product9_h[8] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[8] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_j ? 1 : 0)) : 0);
    rtb_Product9_h[9] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[9] ? ((sint32)
        (rtb_TmpSignalConversionAtVeT_f5 ? 1 : 0)) : 0);
    rtb_Product9_h[10] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[10] ? ((sint32)
        (rtb_UnitDelay3_ff ? 1 : 0)) : 0);
    rtb_Product9_h[11] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[11] ? ((sint32)
        (rtb_LogicalOperator3_jq ? 1 : 0)) : 0);
    rtb_Product9_h[12] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[12] ? ((sint32)
        (rtb_TmpSignalConversionAtVeF_hw ? 1 : 0)) : 0);
    rtb_Product9_h[13] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[13] ? ((sint32)
        (aVarTruthTableCondition_4 ? 1 : 0)) : 0);
    rtb_Product9_h[14] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[14] ? ((sint32)
        (rtb_LogicalOperator_dv ? 1 : 0)) : 0);
    rtb_Product9_h[15] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[15] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_m4 ? 1 : 0)) : 0);
    rtb_Product9_h[16] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[16] ? ((sint32)
        (rtb_LogicalOperator1_nm ? 1 : 0)) : 0);
    rtb_Product9_h[17] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[17] ? ((sint32)
        (rtb_LogicalOperator4_j ? 1 : 0)) : 0);
    rtb_Product9_h[18] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[18] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTP_c ? 1 : 0)) : 0);
    rtb_Product9_h[19] = (sint8)(KaTHMR_b_HeatPumpDsbl_RA[19] ? ((sint32)
        (rtb_VariantMerge_For_Variant__b ? 1 : 0)) : 0);

    /* MinMax: '<S4116>/MinMax6' */
    rtb_Switch_i3 = (uint16)rtb_Product9_h[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 19;
            rtb_DataTypeConversion2++)
    {
        u1 = (uint16)rtb_Product9_h[rtb_DataTypeConversion2 + 1];
        if (rtb_Switch_i3 > u1)
        {
            rtb_Switch_i3 = 1U;
        }
        else
        {
            rtb_Switch_i3 = u1;
        }
    }

    /* Logic: '<S4922>/LogicalOperator1' incorporates:
     *  Logic: '<S4570>/LogicalOperator4'
     */
    rtb_OR1_k3 = !VeTHMR_b_CabActvCool;

    /* Logic: '<S4922>/LogicalOperator' incorporates:
     *  Constant: '<S4974>/Constant'
     *  Constant: '<S4975>/Constant'
     *  Constant: '<S4979>/Calib'
     *  Constant: '<S4980>/Calib'
     *  Constant: '<S4981>/Calib'
     *  DataTypeConversion: '<S4116>/DataTypeConversion6'
     *  Logic: '<S4922>/LogicalOperator1'
     *  Logic: '<S4922>/LogicalOperator2'
     *  Logic: '<S4922>/LogicalOperator5'
     *  Logic: '<S4922>/LogicalOperator6'
     *  Logic: '<S4922>/LogicalOperator7'
     *  MinMax: '<S4116>/MinMax6'
     *  RelationalOperator: '<S4922>/RelationalOperator1'
     *  RelationalOperator: '<S4922>/RelationalOperator2'
     *  RelationalOperator: '<S4922>/RelationalOperator3'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     */
    VeTHMR_b_CabHeatPumpAllow_Raw = (((((((VeTHMR_b_CabActvHeat) && (((uint32)
        VeTHMR_b_LearningOk_tmp) != CeTHMR_e_ActiveCooling)) && (rtb_OR1_k3 ||
        (TmpSignalConversionAtOutAirTemp <= KeTHMR_T_HeatPumpDsblAAT_CabCool))) &&
        (!rtb_Switch_az2)) && (KeTHMR_b_HeatPumpEquipped)) && ((((uint32)
        rtb_TmpSignalConversionAtVePD_l) == CePDTR_e_No_Dischrg) ||
        (KeTHMR_b_OVStateHeatPumpDsbl_Ovrd))) && (((sint32)rtb_Switch_i3) == 0));

    /* UnitDelay: '<S4985>/UnitDelay1' */
    rtb_Switch1_btw = THMR_ac_DW.UnitDelay1_DSTATE_ii;

    /* Logic: '<S4986>/AND' */
    THMR_ac_B.AND_j = rtb_Switch1_btw;

    /* Outputs for Atomic SubSystem: '<S4767>/Hysteresis1' */
    /* Switch: '<S4781>/Switch1' incorporates:
     *  Constant: '<S4786>/Calib'
     *  RelationalOperator: '<S4781>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeBTRR >
            KeTHMR_T_Celltemp_EnblWasteHeatRcvry_Deice)
    {
        /* Switch: '<S4781>/Switch1' incorporates:
         *  Constant: '<S4781>/ConstantValue'
         */
        rtb_Switch_az2 = true;
    }
    else
    {
        /* Switch: '<S4781>/Switch1' incorporates:
         *  Constant: '<S4784>/Calib'
         *  RelationalOperator: '<S4781>/GreaterThan1'
         *  UnitDelay: '<S4781>/UnitDelay'
         */
        rtb_Switch_az2 = ((rtb_TmpSignalConversionAtVeBTRR >=
                           KeTHMR_T_Celltemp_DsblWasteHeatRcvry_Deice) &&
                          (THMR_ac_DW.UnitDelay_DSTATE_kas));
    }

    /* End of Switch: '<S4781>/Switch1' */

    /* Update for UnitDelay: '<S4781>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kas = rtb_Switch_az2;

    /* End of Outputs for SubSystem: '<S4767>/Hysteresis1' */

    /* Outputs for Atomic SubSystem: '<S4767>/Hysteresis4' */
    /* Switch: '<S4782>/Switch1' incorporates:
     *  Constant: '<S4785>/Calib'
     *  RelationalOperator: '<S4782>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeBTRR > KeTHMR_T_Celltemp_EnblWasteHeatRcvry)
    {
        /* Switch: '<S4782>/Switch1' incorporates:
         *  Constant: '<S4782>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeBT_m = true;
    }
    else
    {
        /* Switch: '<S4782>/Switch1' incorporates:
         *  Constant: '<S4783>/Calib'
         *  RelationalOperator: '<S4782>/GreaterThan1'
         *  UnitDelay: '<S4782>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeBT_m = ((rtb_TmpSignalConversionAtVeBTRR >=
            KeTHMR_T_Celltemp_DsblWasteHeatRcvry) &&
            (THMR_ac_DW.UnitDelay_DSTATE_mz));
    }

    /* End of Switch: '<S4782>/Switch1' */

    /* Update for UnitDelay: '<S4782>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_mz = rtb_TmpSignalConversionAtVeBT_m;

    /* End of Outputs for SubSystem: '<S4767>/Hysteresis4' */

    /* Product: '<S4116>/Product9' incorporates:
     *  Constant: '<S4531>/Calib'
     *  Product: '<S4116>/Product7'
     */
    rtb_Product9_h[0] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[0] ? ((sint32)
        (rtb_RelationalOperator9_h ? 1 : 0)) : 0);
    rtb_Product9_h[1] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[1] ? ((sint32)
        (rtb_RelationalOperator3_aj ? 1 : 0)) : 0);
    rtb_Product9_h[2] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[2] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_jd ? 1 : 0)) : 0);
    rtb_Product9_h[3] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[3] ? ((sint32)
        (rtb_Logical27 ? 1 : 0)) : 0);
    rtb_Product9_h[4] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[4] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_o ? 1 : 0)) : 0);
    rtb_Product9_h[5] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[5] ? ((sint32)
        (rtb_OR1_b3 ? 1 : 0)) : 0);
    rtb_Product9_h[6] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[6] ? ((sint32)
        (rtb_AND_hz ? 1 : 0)) : 0);
    rtb_Product9_h[7] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[7] ? ((sint32)
        (rtb_TmpSignalConversionAtVeFC_a ? 1 : 0)) : 0);
    rtb_Product9_h[8] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[8] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_j ? 1 : 0)) : 0);
    rtb_Product9_h[9] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[9] ? ((sint32)
        (rtb_TmpSignalConversionAtVeT_f5 ? 1 : 0)) : 0);
    rtb_Product9_h[10] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[10] ?
        ((sint32)(rtb_UnitDelay3_ff ? 1 : 0)) : 0);
    rtb_Product9_h[11] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[11] ?
        ((sint32)(rtb_LogicalOperator3_jq ? 1 : 0)) : 0);
    rtb_Product9_h[12] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[12] ?
        ((sint32)(rtb_TmpSignalConversionAtVeF_hw ? 1 : 0)) : 0);
    rtb_Product9_h[13] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[13] ?
        ((sint32)(aVarTruthTableCondition_4 ? 1 : 0)) : 0);
    rtb_Product9_h[14] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[14] ?
        ((sint32)(rtb_LogicalOperator_dv ? 1 : 0)) : 0);
    rtb_Product9_h[15] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[15] ?
        ((sint32)(rtb_TmpSignalConversionAtVeB_m4 ? 1 : 0)) : 0);
    rtb_Product9_h[16] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[16] ?
        ((sint32)(rtb_LogicalOperator1_nm ? 1 : 0)) : 0);
    rtb_Product9_h[17] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[17] ?
        ((sint32)(rtb_LogicalOperator4_j ? 1 : 0)) : 0);
    rtb_Product9_h[18] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[18] ?
        ((sint32)(rtb_TmpSignalConversionAtVeTP_c ? 1 : 0)) : 0);
    rtb_Product9_h[19] = (sint8)(KaTHMR_b_BattWasteHeatRcvryDsbl_RA[19] ?
        ((sint32)(rtb_VariantMerge_For_Variant__b ? 1 : 0)) : 0);

    /* MinMax: '<S4116>/MinMax7' */
    rtb_Switch_i3 = (uint16)rtb_Product9_h[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 19;
            rtb_DataTypeConversion2++)
    {
        u1 = (uint16)rtb_Product9_h[rtb_DataTypeConversion2 + 1];
        if (rtb_Switch_i3 > u1)
        {
            rtb_Switch_i3 = 1U;
        }
        else
        {
            rtb_Switch_i3 = u1;
        }
    }

    /* Sum: '<S4769>/Add1' incorporates:
     *  Constant: '<S4790>/Calib'
     *  Sum: '<S5139>/Add1'
     */
    rtb_Switch10 = TmpSignalConversionAtOutAirTemp +
        KeTHMR_dT_AATClnt_EnblHPWasteHeatRcvry_RSP;

    /* Outputs for Atomic SubSystem: '<S4769>/Hysteresis2' */
    /* Switch: '<S4788>/Switch1' incorporates:
     *  RelationalOperator: '<S4788>/GreaterThan'
     *  Sum: '<S4769>/Add1'
     */
    if (rtb_TmpSignalConversionAtVeTRIR > rtb_Switch10)
    {
        /* Switch: '<S4788>/Switch1' incorporates:
         *  Constant: '<S4788>/ConstantValue'
         */
        rtb_Switch1_nqi = true;
    }
    else
    {
        /* Switch: '<S4788>/Switch1' incorporates:
         *  Constant: '<S4789>/Calib'
         *  RelationalOperator: '<S4788>/GreaterThan1'
         *  Sum: '<S4769>/Add'
         *  UnitDelay: '<S4788>/UnitDelay'
         */
        rtb_Switch1_nqi = ((rtb_TmpSignalConversionAtVeTRIR >=
                            (KeTHMR_dT_AATClnt_EnblHPWasteHeatRcvry_LSP +
                             TmpSignalConversionAtOutAirTemp)) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_dl5));
    }

    /* End of Switch: '<S4788>/Switch1' */

    /* Update for UnitDelay: '<S4788>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_dl5 = rtb_Switch1_nqi;

    /* End of Outputs for SubSystem: '<S4769>/Hysteresis2' */

    /* Outputs for Atomic SubSystem: '<S4766>/EdgeRising1' */
    /* Logic: '<S4778>/OR1' incorporates:
     *  UnitDelay: '<S4778>/UnitDelay'
     */
    rtb_LogicalOperator_iw = !THMR_ac_DW.UnitDelay_DSTATE_e0h;

    /* Update for UnitDelay: '<S4778>/UnitDelay' incorporates:
     *  Constant: '<S4766>/TRUEConstant1'
     */
    THMR_ac_DW.UnitDelay_DSTATE_e0h = true;

    /* Outputs for Atomic SubSystem: '<S4766>/DigitalLowpassResetEnabled' */
    /* Switch: '<S4777>/Switch1' incorporates:
     *  Logic: '<S4778>/AND'
     */
    if (rtb_LogicalOperator_iw)
    {
        /* Switch: '<S4777>/Switch1' incorporates:
         *  Constant: '<S4766>/ConstantValue6'
         */
        rtb_TmpSignalConversionAtVeBT_o = 0.0F;
    }
    else
    {
        /* Switch: '<S4777>/Switch1' incorporates:
         *  Constant: '<S4780>/Calib'
         *  Product: '<S4777>/Multiplication'
         *  Sum: '<S4777>/Subtraction'
         *  Sum: '<S4777>/Summation'
         *  UnitDelay: '<S4777>/Unit Delay'
         */
        rtb_TmpSignalConversionAtVeBT_o = ((VeTHMR_dV_MinAchvblArflwEst_Ohx -
            THMR_ac_DW.UnitDelay_DSTATE_me) * KeTHMR_k_EstOhxArflw_LPFCoeff) +
            THMR_ac_DW.UnitDelay_DSTATE_me;
    }

    /* End of Switch: '<S4777>/Switch1' */
    /* End of Outputs for SubSystem: '<S4766>/EdgeRising1' */

    /* Update for UnitDelay: '<S4777>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_me = rtb_TmpSignalConversionAtVeBT_o;

    /* End of Outputs for SubSystem: '<S4766>/DigitalLowpassResetEnabled' */

    /* Switch: '<S4767>/Switch3' */
    if (THMR_ac_B.AND_j)
    {
        rtb_TmpSignalConversionAtVeBT_m = rtb_Switch_az2;
    }

    /* End of Switch: '<S4767>/Switch3' */

    /* RelationalOperator: '<S4763>/RelationalOperator3' incorporates:
     *  RelationalOperator: '<S5114>/RelationalOperator3'
     *  RelationalOperator: '<S5115>/RelationalOperator2'
     *  UnitDelay: '<S4118>/UnitDelay6'
     */
    VeTHMR_e_CabCoolThermalState = THMR_ac_DW.UnitDelay6_DSTATE_n;

    /* Switch: '<S4763>/Switch1' incorporates:
     *  Constant: '<S4770>/Constant'
     *  Constant: '<S4771>/Calib'
     *  Constant: '<S4772>/Calib'
     *  RelationalOperator: '<S4763>/RelationalOperator3'
     */
    if (((uint32)VeTHMR_e_CabCoolThermalState) == CeTHMR_e_CabinActiveCooling)
    {
        rtb_Switch15 = KeTHMR_T_WasteHeatRcvryEnblAATMax_CabCool;
    }
    else
    {
        rtb_Switch15 = KeTHMR_T_WasteHeatRcvryEnblAATMax;
    }

    /* End of Switch: '<S4763>/Switch1' */

    /* Logic: '<S4734>/LogicalOperator1' incorporates:
     *  Logic: '<S4574>/LogicalOperator2'
     */
    rtb_Switch1_az = ((VeTHMR_b_CabHeatPumpAllow_Raw) || (THMR_ac_B.AND_j));

    /* Logic: '<S4734>/Logical5' incorporates:
     *  Constant: '<S4764>/Calib'
     *  Constant: '<S4773>/Constant'
     *  Constant: '<S4774>/Constant'
     *  Constant: '<S4775>/Constant'
     *  Constant: '<S4776>/Constant'
     *  Constant: '<S4779>/Calib'
     *  Constant: '<S4787>/Calib'
     *  DataTypeConversion: '<S4116>/DataTypeConversion7'
     *  Logic: '<S4734>/Logical1'
     *  Logic: '<S4734>/Logical7'
     *  Logic: '<S4734>/LogicalOperator'
     *  Logic: '<S4734>/LogicalOperator1'
     *  Logic: '<S4734>/LogicalOperator2'
     *  Logic: '<S4734>/LogicalOperator3'
     *  Logic: '<S4765>/LogicalOperator'
     *  Logic: '<S4768>/Logical3'
     *  MinMax: '<S4116>/MinMax7'
     *  RelationalOperator: '<S4763>/RelationalOperator1'
     *  RelationalOperator: '<S4765>/RelationalOperator'
     *  RelationalOperator: '<S4765>/RelationalOperator1'
     *  RelationalOperator: '<S4765>/RelationalOperator2'
     *  RelationalOperator: '<S4765>/RelationalOperator3'
     *  RelationalOperator: '<S4766>/RelationalOperator2'
     */
    VeTHMR_b_BattActvWasteheatRecvry_Req = ((((((rtb_Switch1_az &&
        ((THMR_ac_B.Switch1_h) || (KeTHMR_b_Enbl_BattAllwd_ActvWsteHeatRecovry)))
        && ((((((uint32)rtb_LogicalOperator_gg_tmp) != CeTHMR_e_ActiveCooling) &&
              (((uint32)rtb_LogicalOperator_gg_tmp) != CeTHMR_e_Heating)) &&
             (((uint32)rtb_LogicalOperator_gg_tmp) != CeTHMR_e_ActvPsvHeating)) &&
            (((uint32)rtb_LogicalOperator_gg_tmp) != CeTHMR_e_EmergencyCooling)))
        && (rtb_TmpSignalConversionAtVeBT_p || rtb_TmpSignalConversionAtVeBT_m))
        && (!KeTHMR_b_DsblBattWasteHeatRcvry)) && (((sint32)rtb_Switch_i3) == 0))
        && ((THMR_ac_B.AND_j) || (((rtb_Switch15 >=
        TmpSignalConversionAtOutAirTemp) && rtb_Switch1_nqi) &&
        (rtb_TmpSignalConversionAtVeBT_o <=
         KeTHMR_dV_MinAirflw_EnblHPWasteHeatRcvry))));

    /* Outputs for Atomic SubSystem: '<S5121>/Hysteresis2' */
    /* Switch: '<S5149>/Switch1' incorporates:
     *  Constant: '<S5152>/Calib'
     *  RelationalOperator: '<S5149>/GreaterThan'
     */
    if (THMR_ac_B.Switch1_j > KeTHMR_T_PPCTISCold_EnblWasteHeatRcvryDeice_RSP)
    {
        /* Switch: '<S5149>/Switch1' incorporates:
         *  Constant: '<S5149>/ConstantValue'
         */
        rtb_Switch_az2 = true;
    }
    else
    {
        /* Switch: '<S5149>/Switch1' incorporates:
         *  Constant: '<S5151>/Calib'
         *  RelationalOperator: '<S5149>/GreaterThan1'
         *  UnitDelay: '<S5149>/UnitDelay'
         */
        rtb_Switch_az2 = ((THMR_ac_B.Switch1_j >=
                           KeTHMR_T_PPCTISCold_EnblWasteHeatRcvryDeice_LSP) &&
                          (THMR_ac_DW.UnitDelay_DSTATE_cdf));
    }

    /* End of Switch: '<S5149>/Switch1' */

    /* Update for UnitDelay: '<S5149>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_cdf = rtb_Switch_az2;

    /* End of Outputs for SubSystem: '<S5121>/Hysteresis2' */

    /* Outputs for Atomic SubSystem: '<S5121>/Hysteresis4' */
    /* Switch: '<S5150>/Switch1' incorporates:
     *  Constant: '<S5154>/Calib'
     *  RelationalOperator: '<S5150>/GreaterThan'
     */
    if (THMR_ac_B.Switch1_j > KeTHMR_T_PPCTISCold_EnblWasteHeatRcvry_RSP)
    {
        /* Switch: '<S5150>/Switch1' incorporates:
         *  Constant: '<S5150>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeBT_p = true;
    }
    else
    {
        /* Switch: '<S5150>/Switch1' incorporates:
         *  Constant: '<S5153>/Calib'
         *  RelationalOperator: '<S5150>/GreaterThan1'
         *  UnitDelay: '<S5150>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeBT_p = ((THMR_ac_B.Switch1_j >=
            KeTHMR_T_PPCTISCold_EnblWasteHeatRcvry_LSP) &&
            (THMR_ac_DW.UnitDelay_DSTATE_ja));
    }

    /* End of Switch: '<S5150>/Switch1' */

    /* Update for UnitDelay: '<S5150>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ja = rtb_TmpSignalConversionAtVeBT_p;

    /* End of Outputs for SubSystem: '<S5121>/Hysteresis4' */

    /* Outputs for Atomic SubSystem: '<S5121>/Hysteresis1' */
    /* Switch: '<S5148>/Switch1' incorporates:
     *  Constant: '<S5156>/Calib'
     *  RelationalOperator: '<S5148>/GreaterThan'
     */
    if (THMR_ac_B.Switch1_j > KeTHMR_T_PPCTISHot_EnblWasteHeatRcvry_RSP)
    {
        /* Switch: '<S5148>/Switch1' incorporates:
         *  Constant: '<S5148>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeBT_m = true;
    }
    else
    {
        /* Switch: '<S5148>/Switch1' incorporates:
         *  Constant: '<S5155>/Calib'
         *  RelationalOperator: '<S5148>/GreaterThan1'
         *  UnitDelay: '<S5148>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeBT_m = ((THMR_ac_B.Switch1_j >=
            KeTHMR_T_PPCTISHot_EnblWasteHeatRcvry_LSP) &&
            (THMR_ac_DW.UnitDelay_DSTATE_no));
    }

    /* End of Switch: '<S5148>/Switch1' */

    /* Update for UnitDelay: '<S5148>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_no = rtb_TmpSignalConversionAtVeBT_m;

    /* End of Outputs for SubSystem: '<S5121>/Hysteresis1' */

    /* Product: '<S4116>/Product9' incorporates:
     *  Constant: '<S4534>/Calib'
     *  Product: '<S4116>/Product8'
     */
    rtb_Product9_h[0] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[0] ? ((sint32)
        (rtb_RelationalOperator9_h ? 1 : 0)) : 0);
    rtb_Product9_h[1] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[1] ? ((sint32)
        (rtb_RelationalOperator3_aj ? 1 : 0)) : 0);
    rtb_Product9_h[2] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[2] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_jd ? 1 : 0)) : 0);
    rtb_Product9_h[3] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[3] ? ((sint32)
        (rtb_Logical27 ? 1 : 0)) : 0);
    rtb_Product9_h[4] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[4] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_o ? 1 : 0)) : 0);
    rtb_Product9_h[5] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[5] ? ((sint32)
        (rtb_OR1_b3 ? 1 : 0)) : 0);
    rtb_Product9_h[6] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[6] ? ((sint32)
        (rtb_AND_hz ? 1 : 0)) : 0);
    rtb_Product9_h[7] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[7] ? ((sint32)
        (rtb_TmpSignalConversionAtVeFC_a ? 1 : 0)) : 0);
    rtb_Product9_h[8] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[8] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_j ? 1 : 0)) : 0);
    rtb_Product9_h[9] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[9] ? ((sint32)
        (rtb_TmpSignalConversionAtVeT_f5 ? 1 : 0)) : 0);
    rtb_Product9_h[10] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[10] ?
        ((sint32)(rtb_UnitDelay3_ff ? 1 : 0)) : 0);
    rtb_Product9_h[11] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[11] ?
        ((sint32)(rtb_LogicalOperator3_jq ? 1 : 0)) : 0);
    rtb_Product9_h[12] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[12] ?
        ((sint32)(rtb_TmpSignalConversionAtVeF_hw ? 1 : 0)) : 0);
    rtb_Product9_h[13] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[13] ?
        ((sint32)(aVarTruthTableCondition_4 ? 1 : 0)) : 0);
    rtb_Product9_h[14] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[14] ?
        ((sint32)(rtb_LogicalOperator_dv ? 1 : 0)) : 0);
    rtb_Product9_h[15] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[15] ?
        ((sint32)(rtb_TmpSignalConversionAtVeB_m4 ? 1 : 0)) : 0);
    rtb_Product9_h[16] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[16] ?
        ((sint32)(rtb_LogicalOperator1_nm ? 1 : 0)) : 0);
    rtb_Product9_h[17] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[17] ?
        ((sint32)(rtb_LogicalOperator4_j ? 1 : 0)) : 0);
    rtb_Product9_h[18] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[18] ?
        ((sint32)(rtb_TmpSignalConversionAtVeTP_c ? 1 : 0)) : 0);
    rtb_Product9_h[19] = (sint8)(KaTHMR_b_EDUWasteHeatRcvryDsbl_RA[19] ?
        ((sint32)(rtb_VariantMerge_For_Variant__b ? 1 : 0)) : 0);

    /* MinMax: '<S4116>/MinMax8' */
    rtb_Switch_i3 = (uint16)rtb_Product9_h[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 19;
            rtb_DataTypeConversion2++)
    {
        u1 = (uint16)rtb_Product9_h[rtb_DataTypeConversion2 + 1];
        if (rtb_Switch_i3 > u1)
        {
            rtb_Switch_i3 = 1U;
        }
        else
        {
            rtb_Switch_i3 = u1;
        }
    }

    /* Outputs for Atomic SubSystem: '<S5139>/Hysteresis2' */
    /* Switch: '<S5253>/Switch1' incorporates:
     *  RelationalOperator: '<S5253>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeTM_f > rtb_Switch10)
    {
        /* Switch: '<S5253>/Switch1' incorporates:
         *  Constant: '<S5253>/ConstantValue'
         */
        rtb_Switch1_nqi = true;
    }
    else
    {
        /* Switch: '<S5253>/Switch1' incorporates:
         *  Constant: '<S5254>/Calib'
         *  RelationalOperator: '<S5253>/GreaterThan1'
         *  Sum: '<S5139>/Add'
         *  UnitDelay: '<S5253>/UnitDelay'
         */
        rtb_Switch1_nqi = ((rtb_TmpSignalConversionAtVeTM_f >=
                            (KeTHMR_dT_AATClnt_EnblHPWasteHeatRcvry_LSP +
                             TmpSignalConversionAtOutAirTemp)) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_ml));
    }

    /* End of Switch: '<S5253>/Switch1' */

    /* Update for UnitDelay: '<S5253>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ml = rtb_Switch1_nqi;

    /* End of Outputs for SubSystem: '<S5139>/Hysteresis2' */

    /* Outputs for Atomic SubSystem: '<S5136>/EdgeRising1' */
    /* Logic: '<S5245>/OR1' incorporates:
     *  UnitDelay: '<S5245>/UnitDelay'
     */
    rtb_LogicalOperator_iw = !THMR_ac_DW.UnitDelay_DSTATE_fe;

    /* Update for UnitDelay: '<S5245>/UnitDelay' incorporates:
     *  Constant: '<S5136>/TRUEConstant1'
     */
    THMR_ac_DW.UnitDelay_DSTATE_fe = true;

    /* Outputs for Atomic SubSystem: '<S5136>/DigitalLowpassResetEnabled' */
    /* Switch: '<S5244>/Switch1' incorporates:
     *  Logic: '<S5245>/AND'
     */
    if (rtb_LogicalOperator_iw)
    {
        /* Switch: '<S5244>/Switch1' incorporates:
         *  Constant: '<S5136>/ConstantValue6'
         */
        rtb_TmpSignalConversionAtVeBT_o = 0.0F;
    }
    else
    {
        /* Switch: '<S5244>/Switch1' incorporates:
         *  Constant: '<S5247>/Calib'
         *  Product: '<S5244>/Multiplication'
         *  Sum: '<S5244>/Subtraction'
         *  Sum: '<S5244>/Summation'
         *  UnitDelay: '<S5244>/Unit Delay'
         */
        rtb_TmpSignalConversionAtVeBT_o = ((VeTHMR_dV_MinAchvblArflwEst_Ohx -
            THMR_ac_DW.UnitDelay_DSTATE_ih) * KeTHMR_k_EstOhxArflw_LPFCoeff) +
            THMR_ac_DW.UnitDelay_DSTATE_ih;
    }

    /* End of Switch: '<S5244>/Switch1' */
    /* End of Outputs for SubSystem: '<S5136>/EdgeRising1' */

    /* Update for UnitDelay: '<S5244>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_ih = rtb_TmpSignalConversionAtVeBT_o;

    /* End of Outputs for SubSystem: '<S5136>/DigitalLowpassResetEnabled' */

    /* Switch: '<S5121>/Switch1' */
    if (THMR_ac_B.AND_j)
    {
        rtb_TmpSignalConversionAtVeBT_p = rtb_Switch_az2;
    }

    /* End of Switch: '<S5121>/Switch1' */

    /* Switch: '<S5114>/Switch1' incorporates:
     *  Constant: '<S5140>/Constant'
     *  Constant: '<S5141>/Calib'
     *  Constant: '<S5142>/Calib'
     *  RelationalOperator: '<S5114>/RelationalOperator3'
     */
    if (((uint32)VeTHMR_e_CabCoolThermalState) == CeTHMR_e_CabinActiveCooling)
    {
        rtb_Switch10 = KeTHMR_T_WasteHeatRcvryEnblAATMax_CabCool;
    }
    else
    {
        rtb_Switch10 = KeTHMR_T_WasteHeatRcvryEnblAATMax;
    }

    /* End of Switch: '<S5114>/Switch1' */

    /* RelationalOperator: '<S5135>/RelationalOperator' incorporates:
     *  RelationalOperator: '<S5135>/RelationalOperator1'
     *  RelationalOperator: '<S5135>/RelationalOperator2'
     *  RelationalOperator: '<S5135>/RelationalOperator3'
     *  RelationalOperator: '<S5135>/RelationalOperator4'
     *  UnitDelay: '<S5135>/UnitDelay1'
     */
    rtb_LogicalOperator_gg_tmp = THMR_ac_DW.UnitDelay1_DSTATE_je;

    /* Logic: '<S4574>/LogicalOperator' incorporates:
     *  Constant: '<S5120>/Calib'
     *  Constant: '<S5239>/Constant'
     *  Constant: '<S5240>/Constant'
     *  Constant: '<S5241>/Constant'
     *  Constant: '<S5242>/Constant'
     *  Constant: '<S5243>/Constant'
     *  Constant: '<S5246>/Calib'
     *  DataTypeConversion: '<S4116>/DataTypeConversion8'
     *  Logic: '<S4574>/LogicalOperator1'
     *  Logic: '<S4574>/LogicalOperator4'
     *  Logic: '<S4574>/LogicalOperator5'
     *  Logic: '<S4574>/LogicalOperator6'
     *  Logic: '<S5121>/LogicalOperator'
     *  Logic: '<S5121>/LogicalOperator1'
     *  Logic: '<S5135>/LogicalOperator'
     *  MinMax: '<S4116>/MinMax8'
     *  RelationalOperator: '<S5114>/RelationalOperator1'
     *  RelationalOperator: '<S5135>/RelationalOperator'
     *  RelationalOperator: '<S5135>/RelationalOperator1'
     *  RelationalOperator: '<S5135>/RelationalOperator2'
     *  RelationalOperator: '<S5135>/RelationalOperator3'
     *  RelationalOperator: '<S5135>/RelationalOperator4'
     *  RelationalOperator: '<S5136>/RelationalOperator2'
     */
    rtb_LogicalOperator_iw = ((((((rtb_Switch1_az && (((((((uint32)
        rtb_LogicalOperator_gg_tmp) != CeTHMR_e_ActiveCooling) && (((uint32)
        rtb_LogicalOperator_gg_tmp) != CeTHMR_e_Heating)) && (((uint32)
        rtb_LogicalOperator_gg_tmp) != CeTHMR_e_ActvPsvHeating)) && (((uint32)
        rtb_LogicalOperator_gg_tmp) != CeTHMR_e_EmergencyCooling)) && (((uint32)
        rtb_LogicalOperator_gg_tmp) != CeTHMR_e_Balancing))) &&
        (rtb_TmpSignalConversionAtVeBT_p && (!rtb_TmpSignalConversionAtVeBT_m)))
        && (!KeTHMR_b_DsblEDUWasteHeatRcvry)) && rtb_TmpSignalConversionAtVeBT_f)
        && (((sint32)rtb_Switch_i3) == 0)) && ((THMR_ac_B.AND_j) ||
        (((rtb_Switch10 >= TmpSignalConversionAtOutAirTemp) && rtb_Switch1_nqi) &&
         (rtb_TmpSignalConversionAtVeBT_o <=
          KeTHMR_dV_MinAirflw_EnblHPWasteHeatRcvry))));

    /* Switch: '<S5304>/Switch3' incorporates:
     *  Constant: '<S5189>/Calib'
     *  Constant: '<S5190>/Calib'
     *  Logic: '<S5128>/Logical'
     *  Logic: '<S5128>/LogicalOperator'
     */
    rtb_VariantMerge_For_Variant__m = ((((VeTHMR_b_BattHTCLMixClnt_HeatReq) &&
        (KeTHMR_b_ShrdHtr_CombAllLoops)) && (!KeTHMR_b_BTLHTLDrctConnct)) &&
        rtb_VariantMerge_For_Variant__m);

    /* Switch: '<S5137>/Switch1' incorporates:
     *  Constant: '<S5248>/Constant'
     *  Constant: '<S5249>/Calib'
     *  RelationalOperator: '<S5137>/RelationalOperator'
     *  Switch: '<S5137>/Switch5'
     *  UnitDelay: '<S4118>/UnitDelay3'
     */
    if (KeTHMR_b_UseLTRInTemp4VlvCntrl)
    {
        /* Switch: '<S5137>/Switch1' */
        VeTHMR_T_LTCLTemp4VlvCntrl = VeTHMR_T_LTRInletTemp;
    }
    else if (((uint32)THMR_ac_DW.UnitDelay3_DSTATE_j3) ==
             CeTHMR_e_PassiveCooling)
    {
        /* Switch: '<S5137>/Switch5' incorporates:
         *  Switch: '<S5137>/Switch1'
         */
        VeTHMR_T_LTCLTemp4VlvCntrl = rtb_TmpSignalConversionAtVeBT_k;
    }
    else
    {
        /* Switch: '<S5137>/Switch1' incorporates:
         *  Switch: '<S5137>/Switch5'
         */
        VeTHMR_T_LTCLTemp4VlvCntrl = THMR_ac_B.Switch1_j;
    }

    /* End of Switch: '<S5137>/Switch1' */

    /* Switch: '<S4574>/Switch2' incorporates:
     *  Logic: '<S5117>/Logical16'
     */
    if (rtb_AND_fe && (VeTHMR_b_CabActvHeat))
    {
        /* Switch: '<S4574>/Switch2' */
        rtb_TmpSignalConversionAtVeBT_o = rtb_TmpSignalConversionAtVeCTRR;
    }
    else
    {
        /* Switch: '<S4574>/Switch2' incorporates:
         *  Constant: '<S5119>/Calib'
         */
        rtb_TmpSignalConversionAtVeBT_o = KeTHMR_T_HCCTISBTISTgtDef_frWCond;
    }

    /* End of Switch: '<S4574>/Switch2' */

    /* Switch: '<S4574>/Switch1' incorporates:
     *  Logic: '<S5116>/Logical'
     */
    if (((THMR_ac_B.Logical2) && (THMR_ac_B.Switch1_h)) &&
            (THMR_ac_B.VariantMerge_Fo_at))
    {
        /* Switch: '<S4574>/Switch1' */
        rtb_TmpSignalConversionAtVeTM_p = THMR_ac_B.Vector_h;
    }
    else
    {
        /* Switch: '<S4574>/Switch1' incorporates:
         *  Constant: '<S5119>/Calib'
         */
        rtb_TmpSignalConversionAtVeTM_p = KeTHMR_T_HCCTISBTISTgtDef_frWCond;
    }

    /* End of Switch: '<S4574>/Switch1' */

    /* MinMax: '<S5138>/MinMax' incorporates:
     *  Constant: '<S5250>/Calib'
     *  Constant: '<S5251>/Calib'
     *  Constant: '<S5252>/Calib'
     *  Sum: '<S5138>/Add1'
     *  Sum: '<S5138>/Add2'
     */
    THMR_ac_B.MinMax_j = fmaxf(fmaxf(rtb_TmpSignalConversionAtVeBT_o +
        KeTHMR_T_HCCTISTgtOffset_frWCondTgt, rtb_TmpSignalConversionAtVeTM_p +
        KeTHMR_T_BTISTgtOffset_frWCondTgt), KeTHMR_T_WcondTgtCnst);

    /* Switch: '<S5127>/Switch' incorporates:
     *  Constant: '<S5188>/Calib'
     */
    if (KeTHMR_b_ShrdHtr_CombAllLoops)
    {
        /* Switch: '<S5127>/Switch' incorporates:
         *  Constant: '<S5186>/Constant'
         *  RelationalOperator: '<S5127>/RelationalOperator3'
         *  UnitDelay: '<S4118>/UnitDelay3'
         */
        rtb_Switch_az2 = (((uint32)THMR_ac_DW.UnitDelay3_DSTATE_j3) ==
                          CeTHMR_e_PassiveHeating);
    }
    else
    {
        /* RelationalOperator: '<S5127>/RelationalOperator2' incorporates:
         *  RelationalOperator: '<S5127>/RelationalOperator1'
         *  UnitDelay: '<S4118>/UnitDelay3'
         */
        rtb_LogicalOperator_gg_tmp = THMR_ac_DW.UnitDelay3_DSTATE_j3;

        /* Switch: '<S5127>/Switch' incorporates:
         *  Constant: '<S5185>/Constant'
         *  Constant: '<S5187>/Constant'
         *  Logic: '<S5127>/LogicalOperator1'
         *  RelationalOperator: '<S5127>/RelationalOperator1'
         *  RelationalOperator: '<S5127>/RelationalOperator2'
         */
        rtb_Switch_az2 = ((CeTHMR_e_ActvPsvHeating == ((uint32)
                            rtb_LogicalOperator_gg_tmp)) || (((uint32)
                            rtb_LogicalOperator_gg_tmp) ==
                           CeTHMR_e_PassiveHeating));
    }

    /* End of Switch: '<S5127>/Switch' */

    /* RelationalOperator: '<S5129>/RelationalOperator2' incorporates:
     *  RelationalOperator: '<S5134>/RelationalOperator6'
     *  RelationalOperator: '<S5134>/RelationalOperator7'
     *  UnitDelay: '<S4118>/UnitDelay4'
     */
    rtb_Switch1_o0g = THMR_ac_DW.UnitDelay4_DSTATE_j;

    /* RelationalOperator: '<S5129>/RelationalOperator2' incorporates:
     *  Constant: '<S5191>/Constant'
     */
    rtb_TmpSignalConversionAtVeBT_p = (CeTHMR_e_CabinActivePassiveHeating ==
        ((uint32)rtb_Switch1_o0g));

    /* RelationalOperator: '<S5130>/RelationalOperator2' incorporates:
     *  RelationalOperator: '<S5115>/RelationalOperator4'
     *  RelationalOperator: '<S5122>/Comparison4'
     *  RelationalOperator: '<S5134>/RelationalOperator4'
     *  RelationalOperator: '<S5134>/RelationalOperator5'
     *  UnitDelay: '<S4118>/UnitDelay3'
     */
    rtb_LogicalOperator_gg_tmp = THMR_ac_DW.UnitDelay3_DSTATE_j3;

    /* If: '<S5133>/LTCL_Valve_Tgt' incorporates:
     *  Constant: '<S5192>/Constant'
     *  RelationalOperator: '<S5130>/RelationalOperator2'
     */
    if (CeTHMR_e_PassiveCooling == ((uint32)rtb_LogicalOperator_gg_tmp))
    {
        /* Outputs for IfAction SubSystem: '<S5133>/LTCL_Tgt_PsvCool_Batt' incorporates:
         *  ActionPort: '<S5201>/ActionPort'
         */
        /* Merge: '<S5133>/Merge' incorporates:
         *  Constant: '<S5206>/Calib'
         *  Constant: '<S5207>/Calib'
         *  MinMax: '<S5201>/MinMax'
         *  Sum: '<S5201>/Add'
         */
        VeTHMR_T_LTRVlv_Tgt = fminf(rtb_Switch1_l3 -
            KeTHMR_dT_PPCTIS_Tgt_BattPsvCool, KeTHMR_T_PPCTIS_Tgt_BattPsvCool);

        /* End of Outputs for SubSystem: '<S5133>/LTCL_Tgt_PsvCool_Batt' */
    }
    else if (rtb_VariantMerge_For_Variant__m)
    {
        /* Outputs for IfAction SubSystem: '<S5133>/LTCL_Tgt_PsvHeat_BattCabin' incorporates:
         *  ActionPort: '<S5203>/ActionPort'
         */
        /* Merge: '<S5133>/Merge' incorporates:
         *  Constant: '<S5209>/Calib'
         *  Constant: '<S5210>/Calib'
         *  Constant: '<S5211>/Calib'
         *  MinMax: '<S5203>/MinMax'
         *  MinMax: '<S5203>/MinMax1'
         *  Sum: '<S5203>/Add'
         */
        VeTHMR_T_LTRVlv_Tgt = fmaxf(fminf(rtb_TmpSignalConversionAtVeCTRR +
            KeTHMR_dT_PPCTIS_Tgt_CabPsvHeat, KeTHMR_T_PPCTIS_Tgt_CabPsvHeat),
            KeTHMR_T_PPCTIS_Tgt_BattPsvHeat);

        /* End of Outputs for SubSystem: '<S5133>/LTCL_Tgt_PsvHeat_BattCabin' */
    }
    else if (rtb_Switch_az2)
    {
        /* Outputs for IfAction SubSystem: '<S5133>/LTCL_Tgt_PsvHeat_Batt' incorporates:
         *  ActionPort: '<S5202>/ActionPort'
         */
        /* Merge: '<S5133>/Merge' incorporates:
         *  Constant: '<S5208>/Calib'
         *  SignalConversion generated from: '<S5202>/TempTgt'
         */
        VeTHMR_T_LTRVlv_Tgt = KeTHMR_T_PPCTIS_Tgt_BattPsvHeat;

        /* End of Outputs for SubSystem: '<S5133>/LTCL_Tgt_PsvHeat_Batt' */
    }
    else if (rtb_TmpSignalConversionAtVeBT_p)
    {
        /* Outputs for IfAction SubSystem: '<S5133>/LTCL_Tgt_PsvHeat_Cabin' incorporates:
         *  ActionPort: '<S5204>/ActionPort'
         */
        /* Merge: '<S5133>/Merge' incorporates:
         *  Constant: '<S5212>/Calib'
         *  Constant: '<S5213>/Calib'
         *  MinMax: '<S5204>/MinMax'
         *  Sum: '<S5204>/Add'
         */
        VeTHMR_T_LTRVlv_Tgt = fminf(rtb_TmpSignalConversionAtVeCTRR +
            KeTHMR_dT_PPCTIS_Tgt_CabPsvHeat, KeTHMR_T_PPCTIS_Tgt_CabPsvHeat);

        /* End of Outputs for SubSystem: '<S5133>/LTCL_Tgt_PsvHeat_Cabin' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S5133>/LTRValveClose_AccmltHeat' incorporates:
         *  ActionPort: '<S5205>/ActionPort'
         */
        /* Lookup_n-D: '<S5214>/Vector' incorporates:
         *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
         */
        VeTHMR_T_LTCLVlvAllowTempDflt_Ambient = look1_iflf_binlcapw
            (TmpSignalConversionAtOutAirTemp, ((const float32 *)
              &(KxTHMR_T_LTCLVlvAllowTempDflt_Ambient[0])), ((const float32 *)
              &(KtTHMR_T_LTCLVlvAllowTempDflt_Ambient[0])), 4U);

        /* Merge: '<S5133>/Merge' incorporates:
         *  SignalConversion: '<S5205>/SignalConversion'
         */
        VeTHMR_T_LTRVlv_Tgt = VeTHMR_T_LTCLVlvAllowTempDflt_Ambient;

        /* End of Outputs for SubSystem: '<S5133>/LTRValveClose_AccmltHeat' */
    }

    /* End of If: '<S5133>/LTCL_Valve_Tgt' */

    /* Outputs for Atomic SubSystem: '<S5123>/EdgeRising' */
    /* Logic: '<S5170>/OR1' incorporates:
     *  UnitDelay: '<S5170>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeBT_m = !THMR_ac_DW.UnitDelay_DSTATE_a4;

    /* Update for UnitDelay: '<S5170>/UnitDelay' incorporates:
     *  Constant: '<S5123>/Constant3'
     */
    THMR_ac_DW.UnitDelay_DSTATE_a4 = true;

    /* Outputs for Atomic SubSystem: '<S5123>/DigitalLowpassResetEnabled' */
    /* Switch: '<S5169>/Switch1' incorporates:
     *  Logic: '<S5170>/AND'
     */
    if (rtb_TmpSignalConversionAtVeBT_m)
    {
        /* Switch: '<S5169>/Switch1' */
        rtb_TmpSignalConversionAtVePMPR = VeTHMR_v_Vehicle;
    }
    else
    {
        /* Switch: '<S5169>/Switch1' incorporates:
         *  Constant: '<S5178>/Calib'
         *  Product: '<S5169>/Multiplication'
         *  Sum: '<S5169>/Subtraction'
         *  Sum: '<S5169>/Summation'
         *  UnitDelay: '<S5169>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVePMPR = ((VeTHMR_v_Vehicle -
            THMR_ac_DW.UnitDelay_DSTATE_mi) *
            KeTHMR_r_VehSpdLwPassFltrCf_frLTCLtooHotThrsh) +
            THMR_ac_DW.UnitDelay_DSTATE_mi;
    }

    /* End of Switch: '<S5169>/Switch1' */
    /* End of Outputs for SubSystem: '<S5123>/EdgeRising' */

    /* Update for UnitDelay: '<S5169>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_mi = rtb_TmpSignalConversionAtVePMPR;

    /* End of Outputs for SubSystem: '<S5123>/DigitalLowpassResetEnabled' */

    /* Outputs for Atomic SubSystem: '<S5123>/Hysteresis2' */
    /* Switch: '<S5171>/Switch1' incorporates:
     *  Constant: '<S5177>/Calib'
     *  RelationalOperator: '<S5171>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVePMPR > KeTHMR_T_VehSpd_RSP_frLTCLtooHotThrsh)
    {
        /* Switch: '<S5171>/Switch1' incorporates:
         *  Constant: '<S5171>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeBT_m = true;
    }
    else
    {
        /* Switch: '<S5171>/Switch1' incorporates:
         *  Constant: '<S5176>/Calib'
         *  RelationalOperator: '<S5171>/GreaterThan1'
         *  UnitDelay: '<S5171>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeBT_m = ((rtb_TmpSignalConversionAtVePMPR >=
            KeTHMR_T_VehSpd_LSP_frLTCLtooHotThrsh) &&
            (THMR_ac_DW.UnitDelay_DSTATE_ak));
    }

    /* End of Switch: '<S5171>/Switch1' */

    /* Update for UnitDelay: '<S5171>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ak = rtb_TmpSignalConversionAtVeBT_m;

    /* End of Outputs for SubSystem: '<S5123>/Hysteresis2' */

    /* Switch: '<S5123>/Switch1' incorporates:
     *  Constant: '<S5173>/Calib'
     *  Constant: '<S5175>/Calib'
     */
    if (rtb_TmpSignalConversionAtVeBT_m)
    {
        rtb_TmpSignalConversionAtVePMPR = KeTHMR_T_VehSpdHigh_LTCLtooHot_RSP;
    }
    else
    {
        rtb_TmpSignalConversionAtVePMPR = KeTHMR_T_VehSpdLow_LTCLtooHot_RSP;
    }

    /* End of Switch: '<S5123>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S4574>/Hysteresis2' */
    /* Switch: '<S5118>/Switch1' incorporates:
     *  RelationalOperator: '<S5118>/GreaterThan'
     *  Switch: '<S5123>/Switch2'
     */
    if (THMR_ac_B.Switch1_j > rtb_TmpSignalConversionAtVePMPR)
    {
        /* Switch: '<S5118>/Switch1' incorporates:
         *  Constant: '<S5118>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeBT_m = true;
    }
    else
    {
        if (rtb_TmpSignalConversionAtVeBT_m)
        {
            /* Switch: '<S5123>/Switch2' incorporates:
             *  Constant: '<S5172>/Calib'
             */
            rtb_TmpSignalConversionAtVePMPR = KeTHMR_T_VehSpdHigh_LTCLtooHot_LSP;
        }
        else
        {
            /* Switch: '<S5123>/Switch2' incorporates:
             *  Constant: '<S5174>/Calib'
             */
            rtb_TmpSignalConversionAtVePMPR = KeTHMR_T_VehSpdLow_LTCLtooHot_LSP;
        }

        /* Switch: '<S5118>/Switch1' incorporates:
         *  RelationalOperator: '<S5118>/GreaterThan1'
         *  UnitDelay: '<S5118>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeBT_m = ((THMR_ac_B.Switch1_j >=
            rtb_TmpSignalConversionAtVePMPR) && (THMR_ac_DW.UnitDelay_DSTATE_ah));
    }

    /* End of Switch: '<S5118>/Switch1' */

    /* Update for UnitDelay: '<S5118>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ah = rtb_TmpSignalConversionAtVeBT_m;

    /* End of Outputs for SubSystem: '<S4574>/Hysteresis2' */

    /* Product: '<S4116>/Product9' incorporates:
     *  Constant: '<S4536>/Calib'
     */
    rtb_Product9_h[0] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[0] ? ((sint32)
        (rtb_RelationalOperator9_h ? 1 : 0)) : 0);
    rtb_Product9_h[1] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[1] ? ((sint32)
        (rtb_RelationalOperator3_aj ? 1 : 0)) : 0);
    rtb_Product9_h[2] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[2] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_jd ? 1 : 0)) : 0);
    rtb_Product9_h[3] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[3] ? ((sint32)
        (rtb_Logical27 ? 1 : 0)) : 0);
    rtb_Product9_h[4] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[4] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_o ? 1 : 0)) : 0);
    rtb_Product9_h[5] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[5] ? ((sint32)
        (rtb_OR1_b3 ? 1 : 0)) : 0);
    rtb_Product9_h[6] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[6] ? ((sint32)
        (rtb_AND_hz ? 1 : 0)) : 0);
    rtb_Product9_h[7] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[7] ? ((sint32)
        (rtb_TmpSignalConversionAtVeFC_a ? 1 : 0)) : 0);
    rtb_Product9_h[8] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[8] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTM_j ? 1 : 0)) : 0);
    rtb_Product9_h[9] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[9] ? ((sint32)
        (rtb_TmpSignalConversionAtVeT_f5 ? 1 : 0)) : 0);
    rtb_Product9_h[10] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[10] ? ((sint32)
        (rtb_UnitDelay3_ff ? 1 : 0)) : 0);
    rtb_Product9_h[11] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[11] ? ((sint32)
        (rtb_LogicalOperator3_jq ? 1 : 0)) : 0);
    rtb_Product9_h[12] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[12] ? ((sint32)
        (rtb_TmpSignalConversionAtVeF_hw ? 1 : 0)) : 0);
    rtb_Product9_h[13] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[13] ? ((sint32)
        (aVarTruthTableCondition_4 ? 1 : 0)) : 0);
    rtb_Product9_h[14] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[14] ? ((sint32)
        (rtb_LogicalOperator_dv ? 1 : 0)) : 0);
    rtb_Product9_h[15] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[15] ? ((sint32)
        (rtb_TmpSignalConversionAtVeB_m4 ? 1 : 0)) : 0);
    rtb_Product9_h[16] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[16] ? ((sint32)
        (rtb_LogicalOperator1_nm ? 1 : 0)) : 0);
    rtb_Product9_h[17] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[17] ? ((sint32)
        (rtb_LogicalOperator4_j ? 1 : 0)) : 0);
    rtb_Product9_h[18] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[18] ? ((sint32)
        (rtb_TmpSignalConversionAtVeTP_c ? 1 : 0)) : 0);
    rtb_Product9_h[19] = (sint8)(KaTHMR_b_WCondLTRSuppDsbl_RA[19] ? ((sint32)
        (rtb_VariantMerge_For_Variant__b ? 1 : 0)) : 0);

    /* MinMax: '<S4116>/MinMax9' */
    rtb_Switch_i3 = (uint16)rtb_Product9_h[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 19;
            rtb_DataTypeConversion2++)
    {
        u1 = (uint16)rtb_Product9_h[rtb_DataTypeConversion2 + 1];
        if (rtb_Switch_i3 > u1)
        {
            rtb_Switch_i3 = 1U;
        }
        else
        {
            rtb_Switch_i3 = u1;
        }
    }

    /* Logic: '<S5115>/LogicalOperator2' incorporates:
     *  Logic: '<S5134>/LogicalOperator4'
     */
    rtb_TmpSignalConversionAtVeBT_m = !rtb_TmpSignalConversionAtVeBT_m;

    /* Logic: '<S5115>/LogicalOperator1' incorporates:
     *  Constant: '<S5143>/Constant'
     *  Constant: '<S5144>/Constant'
     *  Constant: '<S5145>/Calib'
     *  Constant: '<S5146>/Calib'
     *  Constant: '<S5147>/Calib'
     *  DataTypeConversion: '<S4116>/DataTypeConversion9'
     *  Logic: '<S5115>/LogicalOperator2'
     *  Logic: '<S5115>/LogicalOperator3'
     *  Logic: '<S5115>/LogicalOperator6'
     *  Logic: '<S5115>/LogicalOperator7'
     *  Logic: '<S5115>/LogicalOperator8'
     *  Logic: '<S5115>/LogicalOperator9'
     *  MinMax: '<S4116>/MinMax9'
     *  RelationalOperator: '<S5115>/RelationalOperator2'
     *  RelationalOperator: '<S5115>/RelationalOperator4'
     */
    THMR_ac_B.LogicalOperator1 = (((((((uint32)VeTHMR_e_CabCoolThermalState) ==
        CeTHMR_e_CabinActiveCooling) &&
        (KeTHMR_b_EnblCabActvCoolCond_frWcondLTRSup)) || ((((uint32)
        rtb_LogicalOperator_gg_tmp) == CeTHMR_e_ActiveCooling) &&
        (KeTHMR_b_EnblBattActvCoolCond_frWcondLTRSup))) &&
        (rtb_TmpSignalConversionAtVeBT_m ||
         (KeTHMR_b_DsblLTCLTooHotCheck_frWcondLTRSup))) && (((sint32)
        rtb_Switch_i3) == 0));

    /* Outputs for Atomic SubSystem: '<S5134>/Hysteresis2' */
    /* Switch: '<S5222>/Switch1' incorporates:
     *  Constant: '<S5231>/Calib'
     *  RelationalOperator: '<S5222>/GreaterThan'
     *  Sum: '<S5134>/Add2'
     */
    if (VeTHMR_T_HCCTISArb > (rtb_TmpSignalConversionAtVeBT_o +
                              KeTHMR_T_WCondLTRSupp_CabDelta_RSP))
    {
        /* Switch: '<S5222>/Switch1' incorporates:
         *  Constant: '<S5222>/ConstantValue'
         */
        rtb_RelationalOperator9_h = true;
    }
    else
    {
        /* Switch: '<S5222>/Switch1' incorporates:
         *  Constant: '<S5230>/Calib'
         *  RelationalOperator: '<S5222>/GreaterThan1'
         *  Sum: '<S5134>/Add1'
         *  UnitDelay: '<S5222>/UnitDelay'
         */
        rtb_RelationalOperator9_h = ((VeTHMR_T_HCCTISArb >=
            (rtb_TmpSignalConversionAtVeBT_o -
             KeTHMR_T_WCondLTRSupp_CabDelta_LSP)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_j0));
    }

    /* End of Switch: '<S5222>/Switch1' */

    /* Update for UnitDelay: '<S5222>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_j0 = rtb_RelationalOperator9_h;

    /* End of Outputs for SubSystem: '<S5134>/Hysteresis2' */

    /* Outputs for Atomic SubSystem: '<S5134>/Hysteresis3' */
    /* Switch: '<S5223>/Switch1' incorporates:
     *  Constant: '<S5229>/Calib'
     *  RelationalOperator: '<S5223>/GreaterThan'
     *  Sum: '<S5134>/Add4'
     */
    if (rtb_TmpSignalConversionAtVeBT_k > (rtb_TmpSignalConversionAtVeTM_p +
            KeTHMR_T_WCondLTRSupp_BattDelta_RSP))
    {
        /* Switch: '<S5223>/Switch1' incorporates:
         *  Constant: '<S5223>/ConstantValue'
         */
        rtb_RelationalOperator3_aj = true;
    }
    else
    {
        /* Switch: '<S5223>/Switch1' incorporates:
         *  Constant: '<S5228>/Calib'
         *  RelationalOperator: '<S5223>/GreaterThan1'
         *  Sum: '<S5134>/Add3'
         *  UnitDelay: '<S5223>/UnitDelay'
         */
        rtb_RelationalOperator3_aj = ((rtb_TmpSignalConversionAtVeBT_k >=
            (rtb_TmpSignalConversionAtVeTM_p -
             KeTHMR_T_WCondLTRSupp_BattDelta_LSP)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_i0));
    }

    /* End of Switch: '<S5223>/Switch1' */

    /* Update for UnitDelay: '<S5223>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_i0 = rtb_RelationalOperator3_aj;

    /* End of Outputs for SubSystem: '<S5134>/Hysteresis3' */

    /* Sum: '<S5134>/Add5' */
    rtb_TmpSignalConversionAtVeBT_o = rtb_TmpSignalConversionAtVeT_n0 -
        THMR_ac_B.MinMax_j;

    /* Outputs for Atomic SubSystem: '<S5134>/Hysteresis1' */
    /* Switch: '<S5221>/Switch1' incorporates:
     *  Constant: '<S5227>/Calib'
     *  RelationalOperator: '<S5221>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeBT_o > KeTHMR_T_WCondErrorDelta_RSP)
    {
        /* Switch: '<S5221>/Switch1' incorporates:
         *  Constant: '<S5221>/ConstantValue'
         */
        rtb_Switch1_nqi = true;
    }
    else
    {
        /* Switch: '<S5221>/Switch1' incorporates:
         *  Constant: '<S5226>/Calib'
         *  RelationalOperator: '<S5221>/GreaterThan1'
         *  UnitDelay: '<S5221>/UnitDelay'
         */
        rtb_Switch1_nqi = ((rtb_TmpSignalConversionAtVeBT_o >=
                            KeTHMR_T_WCondErrorDelta_LSP) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_ad));
    }

    /* End of Switch: '<S5221>/Switch1' */

    /* Update for UnitDelay: '<S5221>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ad = rtb_Switch1_nqi;

    /* End of Outputs for SubSystem: '<S5134>/Hysteresis1' */

    /* Outputs for Atomic SubSystem: '<S5134>/Hysteresis4' */
    /* Switch: '<S5224>/Switch1' incorporates:
     *  Constant: '<S5233>/Calib'
     *  RelationalOperator: '<S5224>/GreaterThan'
     *  Sum: '<S5134>/Add8'
     */
    if (rtb_TmpSignalConversionAtVeT_n0 > (THMR_ac_B.Switch1_j +
            KeTHMR_T_WCondLTRSupp_HTLHghrLTL_RSP))
    {
        /* Switch: '<S5224>/Switch1' incorporates:
         *  Constant: '<S5224>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeTM_o = true;
    }
    else
    {
        /* Switch: '<S5224>/Switch1' incorporates:
         *  Constant: '<S5232>/Calib'
         *  RelationalOperator: '<S5224>/GreaterThan1'
         *  Sum: '<S5134>/Add6'
         *  UnitDelay: '<S5224>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeTM_o = ((rtb_TmpSignalConversionAtVeT_n0 >=
            (THMR_ac_B.Switch1_j + KeTHMR_T_WCondLTRSupp_HTLHghrLTL_LSP)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_py));
    }

    /* End of Switch: '<S5224>/Switch1' */

    /* Update for UnitDelay: '<S5224>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_py = rtb_TmpSignalConversionAtVeTM_o;

    /* End of Outputs for SubSystem: '<S5134>/Hysteresis4' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Logic: '<S5134>/LogicalOperator3' incorporates:
     *  Constant: '<S5216>/Constant'
     *  Constant: '<S5217>/Constant'
     *  Constant: '<S5218>/Constant'
     *  Constant: '<S5219>/Constant'
     *  Constant: '<S5220>/Constant'
     *  Constant: '<S5234>/Calib'
     *  Logic: '<S5134>/LogicalOperator1'
     *  Logic: '<S5134>/LogicalOperator2'
     *  Logic: '<S5134>/LogicalOperator5'
     *  Logic: '<S5134>/LogicalOperator6'
     *  RelationalOperator: '<S2689>/Comparison19'
     *  RelationalOperator: '<S5134>/RelationalOperator1'
     *  RelationalOperator: '<S5134>/RelationalOperator3'
     *  RelationalOperator: '<S5134>/RelationalOperator4'
     *  RelationalOperator: '<S5134>/RelationalOperator5'
     *  RelationalOperator: '<S5134>/RelationalOperator6'
     *  RelationalOperator: '<S5134>/RelationalOperator7'
     *  Switch: '<S2296>/Switch2'
     *  Switch: '<S5134>/Switch1'
     *  Switch: '<S5134>/Switch2'
     */
    rtb_RelationalOperator9_h = ((((((THMR_ac_B.LogicalOperator1) &&
        (rtb_TmpSignalConversionAtVeBT_m && (((uint32)VeTHMR_e_PPCTIS_OT_BD) ==
        CeTHMR_e_EmergencyLevel4))) && (((((CeTHMR_e_CabinActiveHeating ==
        ((uint32)rtb_Switch1_o0g)) || (((uint32)rtb_Switch1_o0g) ==
        CeTHMR_e_CabinActivePassiveHeating)) && rtb_RelationalOperator9_h) ||
        ((CeTHMR_e_CabinActiveHeating != ((uint32)rtb_Switch1_o0g)) && (((uint32)
        rtb_Switch1_o0g) != CeTHMR_e_CabinActivePassiveHeating))) &&
        ((((CeTHMR_e_Heating == ((uint32)rtb_LogicalOperator_gg_tmp)) ||
           (((uint32)rtb_LogicalOperator_gg_tmp) == CeTHMR_e_ActvPsvHeating)) &&
          rtb_RelationalOperator3_aj) || ((CeTHMR_e_Heating != ((uint32)
        rtb_LogicalOperator_gg_tmp)) && (((uint32)rtb_LogicalOperator_gg_tmp) !=
        CeTHMR_e_ActvPsvHeating))))) && rtb_Switch1_nqi) &&
        rtb_TmpSignalConversionAtVeTM_o) && (TmpSignalConversionAtOutAirTemp >
        KeTHMR_T_WCondLTRSupp_MinAmbTemp));

    /* Outputs for Atomic SubSystem: '<S5134>/Debounce2' */
    /* Outputs for Atomic SubSystem: '<S5215>/EdgeBi' */
    /* RelationalOperator: '<S5235>/NotEqual' incorporates:
     *  UnitDelay: '<S5235>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeBT_m = (rtb_RelationalOperator9_h !=
        THMR_ac_DW.UnitDelay_DSTATE_d3);

    /* Update for UnitDelay: '<S5235>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_d3 = rtb_RelationalOperator9_h;

    /* End of Outputs for SubSystem: '<S5215>/EdgeBi' */

    /* Logic: '<S5215>/Logical1' incorporates:
     *  UnitDelay: '<S5215>/UnitDelay1'
     */
    rtb_RelationalOperator3_aj = (rtb_TmpSignalConversionAtVeBT_m ||
        (THMR_ac_DW.UnitDelay1_DSTATE_nj));

    /* Outputs for Atomic SubSystem: '<S5215>/SignalLatchOnWithReset' */
    /* Logic: '<S5236>/OR1' incorporates:
     *  Logic: '<S5236>/NOT'
     *  Logic: '<S5236>/OR'
     *  UnitDelay: '<S5215>/UnitDelay3'
     *  UnitDelay: '<S5236>/UnitDelay'
     */
    rtb_Switch1_nqi = ((THMR_ac_DW.UnitDelay3_DSTATE_kv) ||
                       ((!rtb_RelationalOperator3_aj) &&
                        (THMR_ac_DW.UnitDelay_DSTATE_iq)));

    /* Update for UnitDelay: '<S5236>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_iq = rtb_Switch1_nqi;

    /* End of Outputs for SubSystem: '<S5215>/SignalLatchOnWithReset' */

    /* Switch: '<S5238>/Init' incorporates:
     *  Constant: '<S5238>/InitialCondition'
     *  Logic: '<S5238>/FixPtLogicalOperator'
     *  Logic: '<S5238>/Logical2'
     *  UnitDelay: '<S5238>/FixPtUnitDelay1'
     *  UnitDelay: '<S5238>/FixPtUnitDelay2'
     */
    if (rtb_RelationalOperator3_aj || (((sint32)
            THMR_ac_DW.FixPtUnitDelay2_DSTATE_py) == 0))
    {
        rtb_Switch_i3 = 0U;
    }
    else
    {
        rtb_Switch_i3 = THMR_ac_DW.FixPtUnitDelay1_DSTATE_a;
    }

    /* End of Switch: '<S5238>/Init' */

    /* Sum: '<S5215>/Sum1' incorporates:
     *  Switch: '<S5215>/Switch2'
     */
    rtb_Switch_i3 = (uint16)(((uint32)(rtb_Switch1_nqi ? 1U : 0U)) + ((uint32)
        rtb_Switch_i3));

    /* RelationalOperator: '<S5215>/Equal1' incorporates:
     *  Constant: '<S5225>/Calib'
     */
    rtb_Switch1_nqi = (((float32)rtb_Switch_i3) >= KeTHMR_Cnt_WCondLTRSupp_Dbnc);

    /* Switch: '<S5215>/Switch' incorporates:
     *  Logic: '<S5237>/Logical2'
     *  Switch: '<S5237>/Init'
     *  UnitDelay: '<S5237>/FixPtUnitDelay2'
     */
    if (rtb_Switch1_nqi)
    {
        /* Switch: '<S5215>/Switch' */
        THMR_ac_B.Switch_i = rtb_RelationalOperator9_h;
    }
    else if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_b) == 0)
    {
        /* Switch: '<S5237>/Init' incorporates:
         *  Switch: '<S5215>/Switch'
         */
        THMR_ac_B.Switch_i = rtb_RelationalOperator9_h;
    }
    else
    {
        /* Switch: '<S5215>/Switch' incorporates:
         *  UnitDelay: '<S5237>/FixPtUnitDelay1'
         */
        THMR_ac_B.Switch_i = THMR_ac_DW.FixPtUnitDelay1_DSTATE_h;
    }

    /* End of Switch: '<S5215>/Switch' */

    /* Update for UnitDelay: '<S5215>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_kv = rtb_TmpSignalConversionAtVeBT_m;

    /* Update for UnitDelay: '<S5215>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_nj = rtb_Switch1_nqi;

    /* Update for UnitDelay: '<S5238>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S5238>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_py = 1U;

    /* Switch: '<S5238>/Reset' */
    if (rtb_RelationalOperator3_aj)
    {
        /* Update for UnitDelay: '<S5238>/FixPtUnitDelay1' incorporates:
         *  Constant: '<S5238>/InitialCondition'
         */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_a = 0U;
    }
    else
    {
        /* Update for UnitDelay: '<S5238>/FixPtUnitDelay1' */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_a = rtb_Switch_i3;
    }

    /* End of Switch: '<S5238>/Reset' */

    /* Update for UnitDelay: '<S5237>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S5237>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_b = 1U;

    /* Update for UnitDelay: '<S5237>/FixPtUnitDelay1' */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE_h = THMR_ac_B.Switch_i;

    /* End of Outputs for SubSystem: '<S5134>/Debounce2' */

    /* Switch: '<S4574>/Switch5' */
    if (THMR_ac_B.Switch_i)
    {
        /* Switch: '<S4574>/Switch5' incorporates:
         *  MinMax: '<S4574>/MinMax1'
         */
        THMR_ac_B.Switch5_o = fminf(THMR_ac_B.MinMax_j, VeTHMR_T_LTRVlv_Tgt);
    }
    else
    {
        /* Switch: '<S4574>/Switch5' */
        THMR_ac_B.Switch5_o = VeTHMR_T_LTRVlv_Tgt;
    }

    /* End of Switch: '<S4574>/Switch5' */

    /* Sum: '<S4574>/Add' */
    THMR_ac_B.Add = VeTHMR_T_LTCLTemp4VlvCntrl - THMR_ac_B.Switch5_o;

    /* Outputs for Atomic SubSystem: '<S5125>/Hysteresis1' */
    /* Switch: '<S5181>/Switch1' incorporates:
     *  Constant: '<S5125>/Constant2'
     *  RelationalOperator: '<S5181>/GreaterThan'
     */
    if (THMR_ac_B.Add > 0.0F)
    {
        /* Switch: '<S5181>/Switch1' incorporates:
         *  Constant: '<S5181>/ConstantValue'
         */
        rtb_RelationalOperator9_h = true;
    }
    else
    {
        /* Switch: '<S5181>/Switch1' incorporates:
         *  Constant: '<S5182>/Calib'
         *  RelationalOperator: '<S5181>/GreaterThan1'
         *  UnitDelay: '<S5181>/UnitDelay'
         */
        rtb_RelationalOperator9_h = ((THMR_ac_B.Add >= KeTHMR_dT_LTRVlvClosedHys)
            && (THMR_ac_DW.UnitDelay_DSTATE_i4));
    }

    /* End of Switch: '<S5181>/Switch1' */

    /* Update for UnitDelay: '<S5181>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_i4 = rtb_RelationalOperator9_h;

    /* End of Outputs for SubSystem: '<S5125>/Hysteresis1' */

    /* Switch: '<S5304>/Switch3' incorporates:
     *  Logic: '<S5125>/LogicalOperator'
     *  Logic: '<S5125>/LogicalOperator1'
     */
    rtb_VariantMerge_For_Variant__m = (rtb_VariantMerge_For_Variant__m &&
        (!rtb_RelationalOperator9_h));

    /* Outputs for Atomic SubSystem: '<S5066>/Hysteresis4' */
    /* Switch: '<S5067>/Switch1' incorporates:
     *  Constant: '<S5069>/Calib'
     *  RelationalOperator: '<S5067>/GreaterThan'
     *  Sum: '<S5066>/Add'
     */
    if (THMR_ac_B.Switch1_j > (rtb_TmpSignalConversionAtVeTRIR +
                               KeTHMR_dT_PPCTISBTOS_CombWasteRcvry_RSP))
    {
        /* Switch: '<S5067>/Switch1' incorporates:
         *  Constant: '<S5067>/ConstantValue'
         */
        rtb_RelationalOperator9_h = true;
    }
    else
    {
        /* Switch: '<S5067>/Switch1' incorporates:
         *  Constant: '<S5068>/Calib'
         *  RelationalOperator: '<S5067>/GreaterThan1'
         *  Sum: '<S5066>/Add1'
         *  UnitDelay: '<S5067>/UnitDelay'
         */
        rtb_RelationalOperator9_h = ((THMR_ac_B.Switch1_j >=
            (rtb_TmpSignalConversionAtVeTRIR -
             KeTHMR_dT_PPCTISBTOS_CombWasteRcvry_LSP)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_nl));
    }

    /* End of Switch: '<S5067>/Switch1' */

    /* Update for UnitDelay: '<S5067>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_nl = rtb_RelationalOperator9_h;

    /* End of Outputs for SubSystem: '<S5066>/Hysteresis4' */

    /* Switch: '<S5062>/Switch1' incorporates:
     *  Logic: '<S5066>/LogicalOperator1'
     */
    if (!rtb_RelationalOperator9_h)
    {
        /* Switch: '<S5062>/Switch1' incorporates:
         *  Constant: '<S5063>/Calib'
         */
        Switch3_h[0] = KeTHMR_k_LoopPriorty_CombWasteRcvryHP;
        Switch3_h[1] = KeTHMR_k_LoopPriorty_CombWasteRcvryHP;
    }
    else
    {
        /* Switch: '<S5062>/Switch1' incorporates:
         *  Constant: '<S5064>/Calib'
         *  Lookup_n-D: '<S5065>/Vector'
         *  SignalConversion generated from: '<S2>/VeBTRR_T_CellTempMaxUsed'
         *  Switch: '<S4478>/Switch1'
         */
        Switch3_h[0] = look2_iflf_binlcapw(THMR_ac_B.Switch1_j,
            rtb_TmpSignalConversionAtVeBTRR, ((const float32 *)
            &(KxTHMR_k_LoopPriorty_BTCLWsteHeatRcvryHP[0])), ((const float32 *)
            &(KyTHMR_k_LoopPriorty_BTCLWsteHeatRcvryHP[0])), ((const float32 *)
            &(KtTHMR_k_LoopPriorty_BTCLWsteHeatRcvryHP[0])),
            THMR_ac_ConstP.pooled44, 6U);
        Switch3_h[1] = KeTHMR_k_LoopPriorty_LTCLWasteRcvryHP;
    }

    /* End of Switch: '<S5062>/Switch1' */

    /* Switch: '<S4571>/Switch2' */
    if (VeTHMR_b_BattActvPsvHeat)
    {
        /* Switch: '<S4571>/Switch1' */
        if (rtb_TmpSignalConversionAtVeB_ba)
        {
            /* Switch: '<S4571>/Switch2' incorporates:
             *  Constant: '<S5045>/Calib'
             */
            rtb_Product_o0[0] = KeTHMR_k_LoopPriorty_BattActvPsvHeat_Ovrrd;
        }
        else
        {
            /* Switch: '<S4571>/Switch2' incorporates:
             *  Lookup_n-D: '<S5050>/Vector'
             *  SignalConversion generated from: '<S2>/VeBTRR_dT_CellUnderTemp'
             *  SignalConversion generated from: '<S2>/VeCTRR_dT_HtrCorTmp_Err'
             */
            rtb_Product_o0[0] = look2_iflf_binlcapw
                (rtb_TmpSignalConversionAtVeB_nb,
                 rtb_TmpSignalConversionAtVeCT_i, ((const float32 *)
                  &(KxTHMR_k_LoopPriorty_BattActvPsvHeat[0])), ((const float32 *)
                  &(KyTHMR_k_LoopPriorty_BattActvPsvHeat[0])), ((const float32 *)
                  &(KtTHMR_k_LoopPriorty_BattActvPsvHeat[0])),
                 THMR_ac_ConstP.pooled41, 4U);
        }

        /* End of Switch: '<S4571>/Switch1' */
    }
    else
    {
        /* Switch: '<S4571>/Switch2' incorporates:
         *  Constant: '<S4571>/Constant'
         */
        rtb_Product_o0[0] = -1.0F;
    }

    if (VeTHMR_b_BattPassiveCool)
    {
        /* Switch: '<S4571>/Switch2' incorporates:
         *  Constant: '<S5046>/Calib'
         */
        rtb_Product_o0[1] = KeTHMR_k_LoopPriorty_BattPsvCool;
    }
    else
    {
        /* Switch: '<S4571>/Switch2' incorporates:
         *  Constant: '<S4571>/Constant'
         */
        rtb_Product_o0[1] = -1.0F;
    }

    if (VeTHMR_b_BattPassiveHeat)
    {
        /* Switch: '<S4571>/Switch2' incorporates:
         *  Constant: '<S5047>/Calib'
         */
        rtb_Product_o0[2] = KeTHMR_k_LoopPriorty_BattPsvHeat;
    }
    else
    {
        /* Switch: '<S4571>/Switch2' incorporates:
         *  Constant: '<S4571>/Constant'
         */
        rtb_Product_o0[2] = -1.0F;
    }

    if (VeTHMR_b_CabActvPsvHeat)
    {
        /* Switch: '<S4571>/Switch' */
        if (rtb_TmpSignalConversionAtVeCT_m)
        {
            /* Switch: '<S4571>/Switch2' incorporates:
             *  Constant: '<S5048>/Calib'
             */
            rtb_Product_o0[3] = KeTHMR_k_LoopPriorty_CabActvPsvHeat_Ovrrd;
        }
        else
        {
            /* Switch: '<S4571>/Switch2' incorporates:
             *  Lookup_n-D: '<S5060>/Vector'
             *  Lookup_n-D: '<S5061>/Vector'
             *  MinMax: '<S5058>/MinMax1'
             *  SignalConversion generated from: '<S2>/VeBTRR_dT_CellUnderTemp'
             *  SignalConversion generated from: '<S2>/VeCTRR_T_HtrCoreTmp_Tgt_Arb'
             *  SignalConversion generated from: '<S2>/VeCTRR_dT_HtrCorTmp_Err'
             *  Switch: '<S4478>/Switch1'
             */
            rtb_Product_o0[3] = fmaxf(look2_iflf_binlcapw
                (rtb_TmpSignalConversionAtVeB_nb,
                 rtb_TmpSignalConversionAtVeCT_i, ((const float32 *)
                &(KxTHMR_k_LoopPriorty_CabActvPsvHeat[0])), ((const float32 *)
                &(KyTHMR_k_LoopPriorty_CabActvPsvHeat[0])), ((const float32 *)
                &(KtTHMR_k_LoopPriorty_CabActvPsvHeat[0])),
                 THMR_ac_ConstP.pooled41, 4U), look2_iflf_binlcapw
                (THMR_ac_B.Switch1_j, rtb_TmpSignalConversionAtVeCTRR, ((const
                float32 *)&(KxTHMR_k_LoopPriorty_CabActvPsvHeat_HP[0])), ((const
                float32 *)&(KyTHMR_k_LoopPriorty_CabActvPsvHeat_HP[0])), ((const
                float32 *)&(KtTHMR_k_LoopPriorty_CabActvPsvHeat_HP[0])),
                 THMR_ac_ConstP.pooled44, 6U));
        }

        /* End of Switch: '<S4571>/Switch' */
    }
    else
    {
        /* Switch: '<S4571>/Switch2' incorporates:
         *  Constant: '<S4571>/Constant'
         */
        rtb_Product_o0[3] = -1.0F;
    }

    if (VeTHMR_b_BattActvWasteheatRecvry_Req)
    {
        /* Switch: '<S4571>/Switch2' */
        rtb_Product_o0[4] = Switch3_h[0];
    }
    else
    {
        /* Switch: '<S4571>/Switch2' incorporates:
         *  Constant: '<S4571>/Constant'
         */
        rtb_Product_o0[4] = -1.0F;
    }

    if (rtb_LogicalOperator_iw)
    {
        /* Switch: '<S4571>/Switch2' */
        rtb_Product_o0[5] = Switch3_h[1];
    }
    else
    {
        /* Switch: '<S4571>/Switch2' incorporates:
         *  Constant: '<S4571>/Constant'
         */
        rtb_Product_o0[5] = -1.0F;
    }

    if (rtb_VariantMerge_For_Variant__m)
    {
        /* Switch: '<S4571>/Switch2' incorporates:
         *  Constant: '<S5049>/Calib'
         */
        rtb_Product_o0[6] = KeTHMR_k_LoopPriorty_LTCLActvPsvHeat;
    }
    else
    {
        /* Switch: '<S4571>/Switch2' incorporates:
         *  Constant: '<S4571>/Constant'
         */
        rtb_Product_o0[6] = -1.0F;
    }

    /* End of Switch: '<S4571>/Switch2' */

    /* MinMax: '<S4571>/MinMax' */
    rtb_TmpSignalConversionAtVeB_nb = rtb_Product_o0[0];
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 6;
            rtb_DataTypeConversion2++)
    {
        rtb_TmpSignalConversionAtVeB_nb = fmaxf(rtb_TmpSignalConversionAtVeB_nb,
            rtb_Product_o0[rtb_DataTypeConversion2 + 1]);
    }

    for (i = 0; i < 7; i++)
    {
        /* Logic: '<S4571>/LogicalOperator' incorporates:
         *  MinMax: '<S4571>/MinMax'
         *  RelationalOperator: '<S4571>/RelationalOperator'
         */
        rtb_LogicalOperator_dd1[i] = (rtb_TmpSignalConversionAtVeB_nb ==
            rtb_Product_o0[i]);
    }

    /* Logic: '<S4571>/LogicalOperator' */
    rtb_RelationalOperator9_h = rtb_LogicalOperator_dd1[0];
    rtb_TmpSignalConversionAtVeB_ba = rtb_LogicalOperator_dd1[1];
    rtb_TmpSignalConversionAtVeCT_m = rtb_LogicalOperator_dd1[2];
    rtb_RelationalOperator3_aj = rtb_LogicalOperator_dd1[3];
    rtb_Switch1_nqi = rtb_LogicalOperator_dd1[4];
    rtb_TmpSignalConversionAtVeBT_m = rtb_LogicalOperator_dd1[5];
    rtb_TmpSignalConversionAtVeTM_o = rtb_LogicalOperator_dd1[6];

    /* Gain: '<S5056>/Gain' incorporates:
     *  Logic: '<S4571>/LogicalOperator'
     */
    VeTHMR_b_BattActvPsvHeat_Arb = ((VeTHMR_b_BattActvPsvHeat) &&
        rtb_RelationalOperator9_h);

    /* Gain: '<S5051>/Gain' incorporates:
     *  Logic: '<S4571>/LogicalOperator'
     */
    VeTHMR_b_BattActvWstHeatRcvry_Arb = ((VeTHMR_b_BattActvWasteheatRecvry_Req) &&
        rtb_Switch1_nqi);

    /* Gain: '<S5055>/Gain' incorporates:
     *  Logic: '<S4571>/LogicalOperator'
     */
    VeTHMR_b_BattPassiveCool_Arb = ((VeTHMR_b_BattPassiveCool) &&
        rtb_TmpSignalConversionAtVeB_ba);

    /* Gain: '<S5054>/Gain' incorporates:
     *  Logic: '<S4571>/LogicalOperator'
     */
    VeTHMR_b_BattPassiveHeat_Arb = ((VeTHMR_b_BattPassiveHeat) &&
        rtb_TmpSignalConversionAtVeCT_m);

    /* Switch: '<S4586>/Switch1' incorporates:
     *  Constant: '<S4730>/Calib'
     *  Logic: '<S4596>/Logical2'
     *  Logic: '<S4600>/Logical6'
     *  Logic: '<S4600>/LogicalOperator'
     *  Switch: '<S4585>/Switch1'
     *  Switch: '<S4587>/Switch1'
     *  Switch: '<S4588>/Switch1'
     *  Switch: '<S4589>/Switch1'
     *  Switch: '<S4590>/Switch1'
     *  Switch: '<S4591>/Switch1'
     *  Switch: '<S4592>/Switch1'
     */
    if (VeTHMR_b_BattCondEmergencyCool)
    {
        /* Switch: '<S4586>/Switch1' incorporates:
         *  Constant: '<S4581>/Constant'
         */
        VeTHMR_e_BatThrmlSt_B4D = CeTHMR_e_EmergencyCooling;
    }
    else if (VeTHMR_b_BattCondNew_BS)
    {
        /* Switch: '<S4587>/Switch1' incorporates:
         *  Constant: '<S4576>/Constant'
         *  Switch: '<S4586>/Switch1'
         */
        VeTHMR_e_BatThrmlSt_B4D = CeTHMR_e_ActiveCooling;
    }
    else if (VeTHMR_b_BattActvPsvHeat_Arb)
    {
        /* Switch: '<S4591>/Switch1' incorporates:
         *  Constant: '<S4583>/Constant'
         *  Switch: '<S4586>/Switch1'
         *  Switch: '<S4587>/Switch1'
         */
        VeTHMR_e_BatThrmlSt_B4D = CeTHMR_e_ActvPsvHeating;
    }
    else if (((THMR_ac_B.Logical2) && rtb_Switch1_cck) &&
             (!KeTHMR_b_DsblActvHeat))
    {
        /* Switch: '<S4588>/Switch1' incorporates:
         *  Constant: '<S4578>/Constant'
         *  Switch: '<S4586>/Switch1'
         *  Switch: '<S4587>/Switch1'
         *  Switch: '<S4591>/Switch1'
         */
        VeTHMR_e_BatThrmlSt_B4D = CeTHMR_e_Heating;
    }
    else if (VeTHMR_b_BattActvWstHeatRcvry_Arb)
    {
        /* Switch: '<S4592>/Switch1' incorporates:
         *  Constant: '<S4584>/Constant'
         *  Switch: '<S4586>/Switch1'
         *  Switch: '<S4587>/Switch1'
         *  Switch: '<S4588>/Switch1'
         *  Switch: '<S4591>/Switch1'
         */
        VeTHMR_e_BatThrmlSt_B4D = CeTHMR_e_BTLActvWasteHeatRcvry;
    }
    else if (VeTHMR_b_BattPassiveCool_Arb)
    {
        /* Switch: '<S4585>/Switch1' incorporates:
         *  Constant: '<S4580>/Constant'
         *  Switch: '<S4586>/Switch1'
         *  Switch: '<S4587>/Switch1'
         *  Switch: '<S4588>/Switch1'
         *  Switch: '<S4591>/Switch1'
         *  Switch: '<S4592>/Switch1'
         */
        VeTHMR_e_BatThrmlSt_B4D = CeTHMR_e_PassiveCooling;
    }
    else if (VeTHMR_b_BattPassiveHeat_Arb)
    {
        /* Switch: '<S4590>/Switch1' incorporates:
         *  Constant: '<S4577>/Constant'
         *  Switch: '<S4585>/Switch1'
         *  Switch: '<S4586>/Switch1'
         *  Switch: '<S4587>/Switch1'
         *  Switch: '<S4588>/Switch1'
         *  Switch: '<S4591>/Switch1'
         *  Switch: '<S4592>/Switch1'
         */
        VeTHMR_e_BatThrmlSt_B4D = CeTHMR_e_PassiveHeating;
    }
    else if (rtb_Logical3_pf)
    {
        /* Switch: '<S4589>/Switch1' incorporates:
         *  Constant: '<S4579>/Constant'
         *  Switch: '<S4585>/Switch1'
         *  Switch: '<S4586>/Switch1'
         *  Switch: '<S4587>/Switch1'
         *  Switch: '<S4588>/Switch1'
         *  Switch: '<S4590>/Switch1'
         *  Switch: '<S4591>/Switch1'
         *  Switch: '<S4592>/Switch1'
         */
        VeTHMR_e_BatThrmlSt_B4D = CeTHMR_e_Balancing;
    }
    else
    {
        /* Switch: '<S4586>/Switch1' incorporates:
         *  Constant: '<S4582>/Constant'
         *  Switch: '<S4585>/Switch1'
         *  Switch: '<S4587>/Switch1'
         *  Switch: '<S4588>/Switch1'
         *  Switch: '<S4589>/Switch1'
         *  Switch: '<S4590>/Switch1'
         *  Switch: '<S4591>/Switch1'
         *  Switch: '<S4592>/Switch1'
         */
        VeTHMR_e_BatThrmlSt_B4D = CeTHMR_e_NoConditioning;
    }

    /* End of Switch: '<S4586>/Switch1' */

    /* Gain: '<S4064>/Gain' incorporates:
     *  Constant: '<S5359>/Constant'
     *  Constant: '<S5360>/Constant'
     *  Logic: '<S4095>/Logical1'
     *  RelationalOperator: '<S4095>/Comparison1'
     *  RelationalOperator: '<S4095>/Comparison4'
     *  Switch: '<S4586>/Switch1'
     */
    THMR_ac_B.Gain_du = ((CeTHMR_e_ActiveCooling == ((uint32)
                           VeTHMR_e_BatThrmlSt_B4D)) || (((uint32)
                           VeTHMR_e_BatThrmlSt_B4D) == CeTHMR_e_EmergencyCooling));

    /* Gain: '<S5052>/Gain' incorporates:
     *  Logic: '<S4571>/LogicalOperator'
     */
    VeTHMR_b_CabActvPsvHeat_Arb = ((VeTHMR_b_CabActvPsvHeat) &&
        rtb_RelationalOperator3_aj);

    /* Gain: '<S5053>/Gain' incorporates:
     *  Logic: '<S4571>/LogicalOperator'
     */
    VeTHMR_b_LTCLActvWstHeatRcvry_Arb = (rtb_LogicalOperator_iw &&
        rtb_TmpSignalConversionAtVeBT_m);

    /* Sum: '<S5005>/Add1' incorporates:
     *  Constant: '<S5009>/Calib'
     *  Sum: '<S5006>/Add1'
     */
    rtb_Switch10 = TmpSignalConversionAtOutAirTemp +
        KeTHMR_dT_AATClnt_EnblOhxHPWasteHeatRcvry_RSP;

    /* Outputs for Atomic SubSystem: '<S5005>/Hysteresis2' */
    /* Switch: '<S5007>/Switch1' incorporates:
     *  RelationalOperator: '<S5007>/GreaterThan'
     *  Sum: '<S5005>/Add1'
     */
    if (rtb_TmpSignalConversionAtVeTRIR > rtb_Switch10)
    {
        /* Switch: '<S5007>/Switch1' incorporates:
         *  Constant: '<S5007>/ConstantValue'
         */
        rtb_RelationalOperator9_h = true;
    }
    else
    {
        /* Switch: '<S5007>/Switch1' incorporates:
         *  Constant: '<S5008>/Calib'
         *  RelationalOperator: '<S5007>/GreaterThan1'
         *  Sum: '<S5005>/Add'
         *  UnitDelay: '<S5007>/UnitDelay'
         */
        rtb_RelationalOperator9_h = ((rtb_TmpSignalConversionAtVeTRIR >=
            (KeTHMR_dT_AATClnt_EnblOhxHPWasteHeatRcvry_LSP +
             TmpSignalConversionAtOutAirTemp)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_md));
    }

    /* End of Switch: '<S5007>/Switch1' */

    /* Update for UnitDelay: '<S5007>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_md = rtb_RelationalOperator9_h;

    /* End of Outputs for SubSystem: '<S5005>/Hysteresis2' */

    /* Outputs for Atomic SubSystem: '<S5006>/Hysteresis2' */
    /* Switch: '<S5010>/Switch1' incorporates:
     *  RelationalOperator: '<S5010>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeTM_f > rtb_Switch10)
    {
        /* Switch: '<S5010>/Switch1' incorporates:
         *  Constant: '<S5010>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeBT_m = true;
    }
    else
    {
        /* Switch: '<S5010>/Switch1' incorporates:
         *  Constant: '<S5011>/Calib'
         *  RelationalOperator: '<S5010>/GreaterThan1'
         *  Sum: '<S5006>/Add'
         *  UnitDelay: '<S5010>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeBT_m = ((rtb_TmpSignalConversionAtVeTM_f >=
            (KeTHMR_dT_AATClnt_EnblOhxHPWasteHeatRcvry_LSP +
             TmpSignalConversionAtOutAirTemp)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_dpr));
    }

    /* End of Switch: '<S5010>/Switch1' */

    /* Update for UnitDelay: '<S5010>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_dpr = rtb_TmpSignalConversionAtVeBT_m;

    /* End of Outputs for SubSystem: '<S5006>/Hysteresis2' */

    /* Logic: '<S4982>/LogicalOperator9' incorporates:
     *  Constant: '<S5001>/Constant'
     *  Constant: '<S5002>/Constant'
     *  Constant: '<S5003>/Calib'
     *  Constant: '<S5004>/Calib'
     *  Logic: '<S4982>/LogicalOperator1'
     *  Logic: '<S4982>/LogicalOperator2'
     *  Logic: '<S4982>/LogicalOperator6'
     *  Logic: '<S4982>/LogicalOperator7'
     *  Logic: '<S4982>/LogicalOperator8'
     *  RelationalOperator: '<S4982>/Comparison2'
     *  RelationalOperator: '<S4982>/Comparison3'
     *  RelationalOperator: '<S4982>/RelationalOperator3'
     *  RelationalOperator: '<S4982>/RelationalOperator4'
     *  UnitDelay: '<S4118>/UnitDelay7'
     */
    VeTHMR_b_CabHeatPumpAllow_Ohx = (((KeTHMR_T_HeatPumpEnblAATMax >=
        TmpSignalConversionAtOutAirTemp) && (TmpSignalConversionAtOutAirTemp >=
        KeTHMR_T_HeatPumpEnblAATMin)) && (((((uint32)VeTHMR_b_LearningOk_tmp) !=
        CeTHMR_e_BTLActvWasteHeatRcvry) || (!rtb_RelationalOperator9_h)) &&
        ((((uint32)THMR_ac_DW.UnitDelay7_DSTATE_f) !=
          CeTHMR_e_LTCLActvWasteHeatRcvry) || (!rtb_TmpSignalConversionAtVeBT_m))));

    /* Logic: '<S4922>/LogicalOperator3' incorporates:
     *  Logic: '<S4118>/LogicalOperator2'
     */
    rtb_Logical3_pf = !THMR_ac_B.AND_j;

    /* Logic: '<S4922>/LogicalOperator4' incorporates:
     *  Logic: '<S4922>/LogicalOperator3'
     */
    VeTHMR_b_CabHeatPumpAllowOhx = (((VeTHMR_b_CabHeatPumpAllow_Ohx) &&
        (VeTHMR_b_CabHeatPumpAllow_Raw)) && rtb_Logical3_pf);

    /* Logic: '<S4118>/LogicalOperator1' incorporates:
     *  Logic: '<S4118>/LogicalOperator'
     */
    VeTHMR_b_CabHeatPumpAllow = ((((VeTHMR_b_LTCLActvWstHeatRcvry_Arb) ||
        (VeTHMR_b_BattActvWstHeatRcvry_Arb)) || (VeTHMR_b_CabHeatPumpAllowOhx)) &&
        rtb_Logical3_pf);

    /* If: '<S4570>/If1' incorporates:
     *  Logic: '<S4570>/LogicalOperator2'
     *  Logic: '<S4570>/LogicalOperator3'
     *  Logic: '<S4570>/LogicalOperator5'
     *  Logic: '<S4570>/LogicalOperator6'
     */
    if (rtb_Logical2_iq && (VeTHMR_b_CabActvCool))
    {
        /* Outputs for IfAction SubSystem: '<S4570>/CabinHeatingandCooling' incorporates:
         *  ActionPort: '<S5015>/ActionPort'
         */
        /* Merge: '<S4570>/Merge' incorporates:
         *  Constant: '<S5033>/Constant'
         *  SignalConversion generated from: '<S5015>/CabThermalMode'
         */
        VeTHMR_e_CabThermalMode = CeTHMR_e_Cab_Cooling_n_Heating;

        /* Switch: '<S5015>/Switch1' */
        if (VeTHMR_b_CabActvPsvHeat_Arb)
        {
            /* Switch: '<S5015>/Switch1' incorporates:
             *  Constant: '<S5035>/Constant'
             */
            rtb_Switch1_o0g = CeTHMR_e_CabinActivePassiveHeating;
        }
        else
        {
            /* Switch: '<S5015>/Switch1' incorporates:
             *  Constant: '<S5034>/Constant'
             */
            rtb_Switch1_o0g = CeTHMR_e_CabinActiveHeating;
        }

        /* End of Switch: '<S5015>/Switch1' */

        /* Merge: '<S4570>/Merge1' incorporates:
         *  DataTypeConversion: '<S5031>/DataTypeConversion'
         *  Switch: '<S5015>/Switch1'
         */
        THMR_ac_B.VeTHMR_e_CabHeatThermalState = rtb_Switch1_o0g;

        /* Switch: '<S5015>/Switch2' incorporates:
         *  Constant: '<S5039>/Constant'
         *  Constant: '<S5040>/Calib'
         *  Logic: '<S5015>/LogicalOperator'
         *  Logic: '<S5038>/LogicalOperator'
         *  RelationalOperator: '<S5038>/RelationalOperator'
         *  Switch: '<S5015>/Switch1'
         */
        if ((VeTHMR_b_CabHeatPumpAllow) && ((((uint32)rtb_Switch1_o0g) !=
                CeTHMR_e_CabinActivePassiveHeating) ||
                (KeTHMR_b_AllwHeatPumpActvPsvHeatCab)))
        {
            /* Merge: '<S4570>/Merge3' incorporates:
             *  Constant: '<S5036>/Constant'
             */
            THMR_ac_B.VeTHMR_e_CabHeatThermalMode = CeTHMR_e_HeatPump;
        }
        else
        {
            /* Merge: '<S4570>/Merge3' incorporates:
             *  Constant: '<S5037>/Constant'
             */
            THMR_ac_B.VeTHMR_e_CabHeatThermalMode = CeTHMR_e_ElectricHtr;
        }

        /* End of Switch: '<S5015>/Switch2' */

        /* Merge: '<S4570>/Merge2' incorporates:
         *  Constant: '<S5032>/Constant'
         *  SignalConversion generated from: '<S5015>/CabCoolThermalState'
         */
        VeTHMR_e_CabCoolThermalState = CeTHMR_e_CabinActiveCooling;

        /* End of Outputs for SubSystem: '<S4570>/CabinHeatingandCooling' */
    }
    else if (rtb_Logical2_iq && rtb_OR1_k3)
    {
        /* Outputs for IfAction SubSystem: '<S4570>/CabinHeatingOnly' incorporates:
         *  ActionPort: '<S5014>/ActionPort'
         */
        /* Merge: '<S4570>/Merge' incorporates:
         *  Constant: '<S5023>/Constant'
         *  SignalConversion generated from: '<S5014>/CabThermalMode'
         */
        VeTHMR_e_CabThermalMode = CeTHMR_e_Cab_Heating;

        /* Switch: '<S5014>/Switch1' */
        if (VeTHMR_b_CabActvPsvHeat_Arb)
        {
            /* Switch: '<S5014>/Switch1' incorporates:
             *  Constant: '<S5025>/Constant'
             */
            rtb_Switch1_o0g = CeTHMR_e_CabinActivePassiveHeating;
        }
        else
        {
            /* Switch: '<S5014>/Switch1' incorporates:
             *  Constant: '<S5024>/Constant'
             */
            rtb_Switch1_o0g = CeTHMR_e_CabinActiveHeating;
        }

        /* End of Switch: '<S5014>/Switch1' */

        /* Merge: '<S4570>/Merge1' incorporates:
         *  DataTypeConversion: '<S5021>/DataTypeConversion'
         *  Switch: '<S5014>/Switch1'
         */
        THMR_ac_B.VeTHMR_e_CabHeatThermalState = rtb_Switch1_o0g;

        /* Switch: '<S5014>/Switch2' incorporates:
         *  Constant: '<S5029>/Constant'
         *  Constant: '<S5030>/Calib'
         *  Logic: '<S5014>/LogicalOperator'
         *  Logic: '<S5028>/Logical1'
         *  RelationalOperator: '<S5028>/Comparison5'
         *  Switch: '<S5014>/Switch1'
         */
        if ((VeTHMR_b_CabHeatPumpAllow) && ((((uint32)rtb_Switch1_o0g) !=
                CeTHMR_e_CabinActivePassiveHeating) ||
                (KeTHMR_b_AllwHeatPumpActvPsvHeatCab)))
        {
            /* Merge: '<S4570>/Merge3' incorporates:
             *  Constant: '<S5026>/Constant'
             */
            THMR_ac_B.VeTHMR_e_CabHeatThermalMode = CeTHMR_e_HeatPump;
        }
        else
        {
            /* Merge: '<S4570>/Merge3' incorporates:
             *  Constant: '<S5027>/Constant'
             */
            THMR_ac_B.VeTHMR_e_CabHeatThermalMode = CeTHMR_e_ElectricHtr;
        }

        /* End of Switch: '<S5014>/Switch2' */

        /* Merge: '<S4570>/Merge2' incorporates:
         *  Constant: '<S5022>/Constant'
         *  SignalConversion generated from: '<S5014>/CabCoolThermalState'
         */
        VeTHMR_e_CabCoolThermalState = CeTHMR_e_NoCabinCooling;

        /* End of Outputs for SubSystem: '<S4570>/CabinHeatingOnly' */
    }
    else if ((!rtb_Logical2_iq) && (VeTHMR_b_CabActvCool))
    {
        /* Outputs for IfAction SubSystem: '<S4570>/CabinCoolingOnly' incorporates:
         *  ActionPort: '<S5013>/ActionPort'
         */
        /* Merge: '<S4570>/Merge' incorporates:
         *  Constant: '<S5018>/Constant'
         *  SignalConversion generated from: '<S5013>/CabThermalMode'
         */
        VeTHMR_e_CabThermalMode = CeTHMR_e_Cab_Cooling;

        /* Merge: '<S4570>/Merge1' incorporates:
         *  Constant: '<S5019>/Constant'
         *  SignalConversion generated from: '<S5013>/CabHeatThermalState'
         */
        THMR_ac_B.VeTHMR_e_CabHeatThermalState = CeTHMR_e_NoCabinHeating;

        /* Merge: '<S4570>/Merge3' incorporates:
         *  Constant: '<S5020>/Constant'
         *  SignalConversion generated from: '<S5013>/CabHeatThermalMode'
         */
        THMR_ac_B.VeTHMR_e_CabHeatThermalMode = CeTHMR_e_NoActvHeat;

        /* Merge: '<S4570>/Merge2' incorporates:
         *  Constant: '<S5017>/Constant'
         *  SignalConversion generated from: '<S5013>/CabCoolThermalState'
         */
        VeTHMR_e_CabCoolThermalState = CeTHMR_e_CabinActiveCooling;

        /* End of Outputs for SubSystem: '<S4570>/CabinCoolingOnly' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S4570>/NoCond' incorporates:
         *  ActionPort: '<S5016>/ActionPort'
         */
        /* Merge: '<S4570>/Merge' incorporates:
         *  Constant: '<S5042>/Constant'
         *  SignalConversion generated from: '<S5016>/CabThermalMode'
         */
        VeTHMR_e_CabThermalMode = CeTHMR_e_Cab_NoConditioning;

        /* Merge: '<S4570>/Merge1' incorporates:
         *  Constant: '<S5043>/Constant'
         *  SignalConversion generated from: '<S5016>/CabHeatThermalState'
         */
        THMR_ac_B.VeTHMR_e_CabHeatThermalState = CeTHMR_e_NoCabinHeating;

        /* Merge: '<S4570>/Merge3' incorporates:
         *  Constant: '<S5044>/Constant'
         *  SignalConversion generated from: '<S5016>/CabHeatThermalMode'
         */
        THMR_ac_B.VeTHMR_e_CabHeatThermalMode = CeTHMR_e_NoActvHeat;

        /* Merge: '<S4570>/Merge2' incorporates:
         *  Constant: '<S5041>/Constant'
         *  SignalConversion generated from: '<S5016>/CabCoolThermalState'
         */
        VeTHMR_e_CabCoolThermalState = CeTHMR_e_NoCabinCooling;

        /* End of Outputs for SubSystem: '<S4570>/NoCond' */
    }

    /* End of If: '<S4570>/If1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VePMIR_n_HTAuxPumpRPMAct' */
    (void)Rte_Read_VePMIR_n_HTAuxPumpRPMAct_Value(&rtb_Product9);

    /* Inport: '<Root>/VeFSCR_b_HoodAjarBatCrit' */
    (void)Rte_Read_VeFSCR_b_HoodAjarBatCrit_Value(&tmpRead_16);

    /* Inport: '<Root>/VeTAIR_Pct_ECM_RadFanReq' */
    (void)Rte_Read_VeTAIR_Pct_ECM_RadFanReq_Value(&rtb_UnitDelay9);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* RelationalOperator: '<S4101>/Comparison9' incorporates:
     *  Merge: '<S4570>/Merge3'
     *  RelationalOperator: '<S4110>/RelationalOperator14'
     *  RelationalOperator: '<S4110>/RelationalOperator17'
     *  RelationalOperator: '<S4110>/RelationalOperator2'
     *  RelationalOperator: '<S4110>/RelationalOperator21'
     *  RelationalOperator: '<S4110>/RelationalOperator25'
     *  RelationalOperator: '<S4110>/RelationalOperator6'
     *  RelationalOperator: '<S4110>/RelationalOperator9'
     *  Switch: '<S4463>/Switch1'
     *  Switch: '<S4464>/Switch1'
     *  Switch: '<S4465>/Switch1'
     *  Switch: '<S4466>/Switch1'
     *  Switch: '<S4467>/Switch1'
     *  Switch: '<S4468>/Switch1'
     */
    VeTHMR_b_CompressorReqOn_0_tmp = THMR_ac_B.VeTHMR_e_CabHeatThermalMode;

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LT_Batt_Loop'
     */
    /* Logic: '<S4101>/Logical4' incorporates:
     *  Constant: '<S4379>/Constant'
     *  Constant: '<S4380>/Constant'
     *  Constant: '<S4381>/Constant'
     *  Constant: '<S4382>/Constant'
     *  Constant: '<S4383>/Constant'
     *  Constant: '<S4384>/Constant'
     *  Logic: '<S4101>/Logical1'
     *  Logic: '<S4101>/Logical2'
     *  Logic: '<S4101>/Logical3'
     *  Logic: '<S4101>/Logical5'
     *  Logic: '<S4101>/Logical6'
     *  Merge: '<S4570>/Merge2'
     *  RelationalOperator: '<S3160>/Comparison10'
     *  RelationalOperator: '<S4101>/Comparison2'
     *  RelationalOperator: '<S4101>/Comparison5'
     *  RelationalOperator: '<S4101>/Comparison6'
     *  RelationalOperator: '<S4101>/Comparison7'
     *  RelationalOperator: '<S4101>/Comparison8'
     *  RelationalOperator: '<S4101>/Comparison9'
     *  Switch: '<S3956>/Switch'
     *  Switch: '<S4586>/Switch1'
     */
    VeTHMR_b_CompressorReqOn_0 = ((((((((CeTHMR_e_ActiveCooling == ((uint32)
        VeTHMR_e_BatThrmlSt_B4D)) || (((uint32)VeTHMR_e_BatThrmlSt_B4D) ==
        CeTHMR_e_EmergencyCooling)) || (((uint32)VeTHMR_e_CabCoolThermalState) ==
        CeTHMR_e_CabinActiveCooling)) || (CeTHMR_e_HeatPump == ((uint32)
        VeTHMR_b_CompressorReqOn_0_tmp))) || (THMR_ac_B.AND_j)) && (((((uint32)
        VeTHMR_e_BatCntctrStat) == CeHVTR_e_Closed) &&
        rtb_TmpSignalConversionAtOutAir) || ((VeTHMR_b_AlternatorMode_Actv) &&
        (((uint32)VeTHMR_e_BatCntctrStat) == CeHVTR_e_Open)))) &&
        rtb_TmpSignalConversionAtVeTR_i) && rtb_VariantMerge_For_Variant__j);

    /* Switch: '<S4385>/Switch1' */
    VeTHMR_b_CompressorReqOn_BS = VeTHMR_b_CompressorReqOn_0;

    /* Gain: '<S4065>/Gain' */
    THMR_ac_B.Gain_jf = VeTHMR_b_CompressorReqOn_BS;

    /* Switch: '<S4495>/Switch1' incorporates:
     *  Constant: '<S4493>/Constant'
     *  Constant: '<S4494>/Constant'
     *  Constant: '<S4496>/Calib'
     *  Constant: '<S4497>/Calib'
     *  Logic: '<S4115>/Logical1'
     *  Logic: '<S4115>/Logical2'
     *  Logic: '<S4115>/Logical4'
     *  RelationalOperator: '<S4115>/Comparison1'
     *  RelationalOperator: '<S4115>/Comparison2'
     *  RelationalOperator: '<S4115>/Comparison3'
     *  RelationalOperator: '<S4115>/Comparison4'
     */
    VeTHMR_b_RadFanReqstd_StaFlow = ((((rtb_SumSub1_ni >= KeTHMR_Pct_RunFanSpd) ||
        (rtb_UnitDelay9 >= KeTHMR_Pct_ECM_RadFanSpd_Min)) || tmpRead_16) &&
        ((((uint32)rtb_TmpSignalConversionAtVePM_f) != CePMTR_e_DISBL_All_Thrml)
         || (((uint32)rtb_TmpSignalConversionAtVePM_f) != CePMTR_e_ENB_Only_Pmps)));

    /* Gain: '<S4059>/Gain' */
    THMR_ac_B.Gain_bh = VeTHMR_b_RadFanReqstd_StaFlow;

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* Logic: '<S4107>/Logical4' incorporates:
     *  Constant: '<S4427>/Constant'
     *  Constant: '<S4428>/Constant1'
     *  Constant: '<S4428>/Constant2'
     *  Constant: '<S4429>/Calib'
     *  Constant: '<S4430>/Calib'
     *  Constant: '<S4431>/Calib'
     *  Constant: '<S4432>/Calib'
     *  Logic: '<S4107>/Logical1'
     *  Logic: '<S4107>/Logical10'
     *  Logic: '<S4107>/Logical5'
     *  Logic: '<S4107>/Logical7'
     *  Logic: '<S4107>/Logical9'
     *  Logic: '<S4428>/Logical Operator'
     *  RelationalOperator: '<S1465>/Comparison1'
     *  RelationalOperator: '<S4107>/Comparison4'
     *  RelationalOperator: '<S4107>/Comparison5'
     *  RelationalOperator: '<S4428>/Relational Operator1'
     *  RelationalOperator: '<S4428>/Relational Operator2'
     *  Switch: '<S3792>/Switch'
     */
    rtb_TmpSignalConversionAtBattCn = (((((((VeTHMR_b_HVC_HtrReqstd_StaFlow_AD) &&
        rtb_TmpSignalConversionAtVeTR_i) && rtb_VariantMerge_For_Variant__j) &&
        (rtb_Product9 >= KeTHMR_n_HT_AuxPmpFlw_MinHtrEnb)) &&
        ((KeTHMR_b_BypassHTAPDryRun) || ((((uint32)VeTHMR_e_HTAuxPumpDryRun_AD) ==
        CePMPR_e_FTSNA_False) && rtb_LogicalOperator1_fo))) &&
        (rtb_TmpSignalConversionAtBattCn || (KeTHMR_b_BypassHTAP_FltDtct))) &&
        ((KeTHMR_b_BypassHTAP_LOC) || ((rtb_Logical2_lz_tmp == 0U) ||
        (rtb_Logical2_lz_tmp_0 != 0U))));

    /* Logic: '<S4099>/Logical3' incorporates:
     *  Constant: '<S4242>/Constant'
     *  Constant: '<S4243>/Constant1'
     *  Constant: '<S4243>/Constant2'
     *  Constant: '<S4244>/Calib'
     *  Constant: '<S4245>/Calib'
     *  Constant: '<S4246>/Calib'
     *  Constant: '<S4247>/Calib'
     *  Constant: '<S4248>/Calib'
     *  Constant: '<S4249>/Calib'
     *  DataStoreRead: '<S4243>/StatusByte_BattCoolPmpOveSpd'
     *  Logic: '<S4099>/Logical1'
     *  Logic: '<S4099>/Logical2'
     *  Logic: '<S4099>/Logical4'
     *  Logic: '<S4099>/Logical5'
     *  Logic: '<S4099>/Logical6'
     *  Logic: '<S4099>/LogicalOperator'
     *  Logic: '<S4099>/LogicalOperator1'
     *  Logic: '<S4243>/Logical Operator'
     *  RelationalOperator: '<S4099>/Comparison11'
     *  RelationalOperator: '<S4099>/Comparison12'
     *  RelationalOperator: '<S4243>/Relational Operator1'
     *  RelationalOperator: '<S4243>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S4243>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S4243>/Bitwise Operator2'
     */
    rtb_TmpSignalConversionAtVePM_a = (((((((rtb_TmpSignalConversionAtVePMIR >=
        KeTHMR_n_LT_ActPmpRPM_MinHtrEnb) ||
        (KeTHMR_b_LT_ActPmpRPM_MinHtrEnb_Ovrd)) &&
        rtb_TmpSignalConversionAtVeTR_i) && ((((((uint32)
        rtb_TmpSignalConversionAtVeP_pf) == CePMPR_e_FTSNA_False) ||
        (KeTHMR_b_LT_ActPmp_DryRun_Ovrd)) && (rtb_TmpSignalConversionAtVePM_a ||
        (KeTHMR_b_LT_ActPmp_DryRunFA_Ovrd))) && ((((((uint32)
        THMR_ac_DW.StatusByte_BattCoolPmpOveSpd) & 1U) == 0U) || ((((uint32)
        THMR_ac_DW.StatusByte_BattCoolPmpOveSpd) & 64U) != 0U)) ||
        (KeTHMR_b_LTAP_DryRun_DFIR_Ovrd)))) &&
        (VeTHMR_b_HVC_BattHtrReqstd_StaFlow_AD)) &&
        rtb_VariantMerge_For_Variant__j) && (rtb_TmpSignalConversionAtVeCPDR ||
        (KeTHMR_b_LT_ActPmp_FltDtct_Ovrd)));

    /* Outputs for Enabled SubSystem: '<S4097>/Htr1' incorporates:
     *  EnablePort: '<S4119>/Enable'
     */
    /* Constant: '<S4123>/Calib' */
    if (KeTHMR_b_Htr1_Slctn_State)
    {
        THMR_ac_DW.Htr1_MODE = true;

        /* If: '<S4119>/If' incorporates:
         *  Constant: '<S4132>/Calib'
         *  Constant: '<S4133>/Calib'
         *  Constant: '<S4134>/Calib'
         */
        if (KeTHMR_b_Htr1_Cntrl_Mchnztn_1)
        {
            /* Outputs for IfAction SubSystem: '<S4119>/Cntrl_Mech_1' incorporates:
             *  ActionPort: '<S4128>/ActionPort'
             */
            /* Merge: '<S4119>/Merge' incorporates:
             *  Gain: '<S4139>/Gain'
             */
            THMR_ac_B.Merge_k = rtb_TmpSignalConversionAtBattCn;

            /* Gain: '<S4140>/Gain' */
            VeTHMR_P_Mechnztn1_Htr1Pwr = VeTHMR_P_ECH_HtrPwrTgt_B4D;

            /* Merge: '<S4119>/Merge1' incorporates:
             *  SignalConversion: '<S4128>/SignalConversion'
             */
            THMR_ac_B.Merge1_g = VeTHMR_P_Mechnztn1_Htr1Pwr;

            /* End of Outputs for SubSystem: '<S4119>/Cntrl_Mech_1' */
        }
        else if (KeTHMR_b_Htr1_Cntrl_Mchnztn_2)
        {
            /* Outputs for IfAction SubSystem: '<S4119>/Cntrl_Mech2' incorporates:
             *  ActionPort: '<S4127>/ActionPort'
             */
            /* Merge: '<S4119>/Merge' incorporates:
             *  Gain: '<S4137>/Gain'
             */
            THMR_ac_B.Merge_k = rtb_TmpSignalConversionAtVePM_a;

            /* Gain: '<S4138>/Gain' */
            VeTHMR_P_Mechnztn2_Htr1Pwr = VeTHMR_P_HVC_BattHtrPwr_AD;

            /* Merge: '<S4119>/Merge1' incorporates:
             *  SignalConversion: '<S4127>/SignalConversion'
             */
            THMR_ac_B.Merge1_g = VeTHMR_P_Mechnztn2_Htr1Pwr;

            /* End of Outputs for SubSystem: '<S4119>/Cntrl_Mech2' */
        }
        else if (KeTHMR_b_Htr1_Cntrl_Mchnztn_3)
        {
            /* Outputs for IfAction SubSystem: '<S4119>/Cntrl_Mech_3' incorporates:
             *  ActionPort: '<S4129>/ActionPort'
             */
            /* Merge: '<S4119>/Merge' incorporates:
             *  Gain: '<S4141>/Gain'
             */
            THMR_ac_B.Merge_k = rtb_VariantMerge_For_Variant_p3;

            /* Gain: '<S4142>/Gain' */
            VeTHMR_P_Mechnztn3_Htr1Pwr = Switch;

            /* Merge: '<S4119>/Merge1' incorporates:
             *  SignalConversion: '<S4129>/SignalConversion'
             */
            THMR_ac_B.Merge1_g = VeTHMR_P_Mechnztn3_Htr1Pwr;

            /* End of Outputs for SubSystem: '<S4119>/Cntrl_Mech_3' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S4119>/Cntrl_Mech_4' incorporates:
             *  ActionPort: '<S4130>/ActionPort'
             */
            /* Merge: '<S4119>/Merge' incorporates:
             *  Constant: '<S4097>/ConstantValue9'
             *  Gain: '<S4143>/Gain'
             */
            THMR_ac_B.Merge_k = false;

            /* Merge: '<S4119>/Merge1' incorporates:
             *  SignalConversion: '<S4130>/SignalConversion'
             */
            THMR_ac_B.Merge1_g = 0.0F;

            /* End of Outputs for SubSystem: '<S4119>/Cntrl_Mech_4' */
        }

        /* End of If: '<S4119>/If' */

        /* SignalConversion generated from: '<S4119>/ECH_ClntTempTgt' incorporates:
         *  Constant: '<S4131>/Calib'
         */
        THMR_ac_B.OutportBufferForECH_ClntTempTgt = KeTHMR_T_ECH_ClntTempTgt;
    }
    else
    {
        if (THMR_ac_DW.Htr1_MODE)
        {
            /* Disable for SignalConversion generated from: '<S4119>/ECH_ClntTempTgt' incorporates:
             *  Outport: '<S4119>/ECH_ClntTempTgt'
             */
            THMR_ac_B.OutportBufferForECH_ClntTempTgt = 0.0F;
            THMR_ac_DW.Htr1_MODE = false;
        }
    }

    /* End of Outputs for SubSystem: '<S4097>/Htr1' */

    /* Gain: '<S4062>/Gain' */
    THMR_ac_B.Gain_nq = THMR_ac_B.Merge_k;

    /* Outputs for Enabled SubSystem: '<S4097>/Htr2' incorporates:
     *  EnablePort: '<S4120>/Enable'
     */
    /* Constant: '<S4124>/Calib' */
    if (KeTHMR_b_Htr2_Slctn_State)
    {
        THMR_ac_DW.Htr2_MODE = true;

        /* If: '<S4120>/If' incorporates:
         *  Constant: '<S4152>/Calib'
         *  Constant: '<S4153>/Calib'
         *  Constant: '<S4154>/Calib'
         */
        if (KeTHMR_b_Htr2_Cntrl_Mchnztn_1)
        {
            /* Outputs for IfAction SubSystem: '<S4120>/Cntrl_Mech_1' incorporates:
             *  ActionPort: '<S4148>/ActionPort'
             */
            /* Merge: '<S4120>/Merge' incorporates:
             *  Gain: '<S4159>/Gain'
             */
            THMR_ac_B.Merge_e = rtb_TmpSignalConversionAtBattCn;

            /* Gain: '<S4160>/Gain' */
            VeTHMR_P_Mechnztn1_Htr2Pwr = VeTHMR_P_ECH_HtrPwrTgt_B4D;

            /* Merge: '<S4120>/Merge1' incorporates:
             *  SignalConversion: '<S4148>/SignalConversion'
             */
            THMR_ac_B.Merge1_b = VeTHMR_P_Mechnztn1_Htr2Pwr;

            /* End of Outputs for SubSystem: '<S4120>/Cntrl_Mech_1' */
        }
        else if (KeTHMR_b_Htr2_Cntrl_Mchnztn_2)
        {
            /* Outputs for IfAction SubSystem: '<S4120>/Cntrl_Mech2' incorporates:
             *  ActionPort: '<S4147>/ActionPort'
             */
            /* Merge: '<S4120>/Merge' incorporates:
             *  Gain: '<S4157>/Gain'
             */
            THMR_ac_B.Merge_e = rtb_TmpSignalConversionAtVePM_a;

            /* Gain: '<S4158>/Gain' */
            VeTHMR_P_Mechnztn2_Htr2Pwr = VeTHMR_P_HVC_BattHtrPwr_AD;

            /* Merge: '<S4120>/Merge1' incorporates:
             *  SignalConversion: '<S4147>/SignalConversion'
             */
            THMR_ac_B.Merge1_b = VeTHMR_P_Mechnztn2_Htr2Pwr;

            /* End of Outputs for SubSystem: '<S4120>/Cntrl_Mech2' */
        }
        else if (KeTHMR_b_Htr2_Cntrl_Mchnztn_3)
        {
            /* Outputs for IfAction SubSystem: '<S4120>/Cntrl_Mech_3' incorporates:
             *  ActionPort: '<S4149>/ActionPort'
             */
            /* Merge: '<S4120>/Merge' incorporates:
             *  Gain: '<S4161>/Gain'
             */
            THMR_ac_B.Merge_e = rtb_VariantMerge_For_Variant_p3;

            /* Gain: '<S4162>/Gain' */
            VeTHMR_P_Mechnzt3_Htr2Pwr = Switch;

            /* Merge: '<S4120>/Merge1' incorporates:
             *  SignalConversion: '<S4149>/SignalConversion'
             */
            THMR_ac_B.Merge1_b = VeTHMR_P_Mechnzt3_Htr2Pwr;

            /* End of Outputs for SubSystem: '<S4120>/Cntrl_Mech_3' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S4120>/Cntrl_Mech_4' incorporates:
             *  ActionPort: '<S4150>/ActionPort'
             */
            /* Merge: '<S4120>/Merge' incorporates:
             *  Constant: '<S4097>/ConstantValue9'
             *  Gain: '<S4163>/Gain'
             */
            THMR_ac_B.Merge_e = false;

            /* Merge: '<S4120>/Merge1' incorporates:
             *  SignalConversion: '<S4150>/SignalConversion'
             */
            THMR_ac_B.Merge1_b = 0.0F;

            /* End of Outputs for SubSystem: '<S4120>/Cntrl_Mech_4' */
        }

        /* End of If: '<S4120>/If' */

        /* SignalConversion generated from: '<S4120>/Htr2_ClntTempTgt' incorporates:
         *  Constant: '<S4151>/Calib'
         */
        THMR_ac_B.OutportBufferForHtr2_ClntTempTg = KeTHMR_T_Htr2_ClntTempTgt;
    }
    else
    {
        if (THMR_ac_DW.Htr2_MODE)
        {
            /* Disable for SignalConversion generated from: '<S4120>/Htr2_ClntTempTgt' incorporates:
             *  Outport: '<S4120>/Htr2_ClntTempTgt'
             */
            THMR_ac_B.OutportBufferForHtr2_ClntTempTg = 0.0F;
            THMR_ac_DW.Htr2_MODE = false;
        }
    }

    /* End of Outputs for SubSystem: '<S4097>/Htr2' */

    /* Gain: '<S4060>/Gain' */
    THMR_ac_B.Gain_jp = THMR_ac_B.Merge_e;

    /* Outputs for Enabled SubSystem: '<S4097>/Htr3' incorporates:
     *  EnablePort: '<S4121>/Enable'
     */
    /* Constant: '<S4125>/Calib' */
    if (KeTHMR_b_Htr3_Slctn_State)
    {
        THMR_ac_DW.Htr3_MODE = true;

        /* If: '<S4121>/If' incorporates:
         *  Constant: '<S4172>/Calib'
         *  Constant: '<S4173>/Calib'
         *  Constant: '<S4174>/Calib'
         */
        if (KeTHMR_b_Htr3_Cntrl_Mchnztn_1)
        {
            /* Outputs for IfAction SubSystem: '<S4121>/Cntrl_Mech_1' incorporates:
             *  ActionPort: '<S4168>/ActionPort'
             */
            /* Merge: '<S4121>/Merge' incorporates:
             *  Gain: '<S4179>/Gain'
             */
            THMR_ac_B.Merge_f = rtb_TmpSignalConversionAtBattCn;

            /* Gain: '<S4180>/Gain' */
            VeTHMR_P_Mechnztn1_Htr3Pwr = VeTHMR_P_ECH_HtrPwrTgt_B4D;

            /* Merge: '<S4121>/Merge1' incorporates:
             *  SignalConversion: '<S4168>/SignalConversion'
             */
            THMR_ac_B.Merge1_c = VeTHMR_P_Mechnztn1_Htr3Pwr;

            /* End of Outputs for SubSystem: '<S4121>/Cntrl_Mech_1' */
        }
        else if (KeTHMR_b_Htr3_Cntrl_Mchnztn_2)
        {
            /* Outputs for IfAction SubSystem: '<S4121>/Cntrl_Mech2' incorporates:
             *  ActionPort: '<S4167>/ActionPort'
             */
            /* Merge: '<S4121>/Merge' incorporates:
             *  Gain: '<S4177>/Gain'
             */
            THMR_ac_B.Merge_f = rtb_TmpSignalConversionAtVePM_a;

            /* Gain: '<S4178>/Gain' */
            VeTHMR_P_Mechnztn2_Htr3Pwr = VeTHMR_P_HVC_BattHtrPwr_AD;

            /* Merge: '<S4121>/Merge1' incorporates:
             *  SignalConversion: '<S4167>/SignalConversion'
             */
            THMR_ac_B.Merge1_c = VeTHMR_P_Mechnztn2_Htr3Pwr;

            /* End of Outputs for SubSystem: '<S4121>/Cntrl_Mech2' */
        }
        else if (KeTHMR_b_Htr3_Cntrl_Mchnztn_3)
        {
            /* Outputs for IfAction SubSystem: '<S4121>/Cntrl_Mech_3' incorporates:
             *  ActionPort: '<S4169>/ActionPort'
             */
            /* Merge: '<S4121>/Merge' incorporates:
             *  Gain: '<S4181>/Gain'
             */
            THMR_ac_B.Merge_f = rtb_VariantMerge_For_Variant_p3;

            /* Gain: '<S4182>/Gain' */
            VeTHMR_P_Mechnztn3_Htr3Pwr = Switch;

            /* Merge: '<S4121>/Merge1' incorporates:
             *  SignalConversion: '<S4169>/SignalConversion'
             */
            THMR_ac_B.Merge1_c = VeTHMR_P_Mechnztn3_Htr3Pwr;

            /* End of Outputs for SubSystem: '<S4121>/Cntrl_Mech_3' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S4121>/Cntrl_Mech_4' incorporates:
             *  ActionPort: '<S4170>/ActionPort'
             */
            /* Merge: '<S4121>/Merge' incorporates:
             *  Constant: '<S4097>/ConstantValue9'
             *  Gain: '<S4183>/Gain'
             */
            THMR_ac_B.Merge_f = false;

            /* Merge: '<S4121>/Merge1' incorporates:
             *  SignalConversion: '<S4170>/SignalConversion'
             */
            THMR_ac_B.Merge1_c = 0.0F;

            /* End of Outputs for SubSystem: '<S4121>/Cntrl_Mech_4' */
        }

        /* End of If: '<S4121>/If' */

        /* SignalConversion generated from: '<S4121>/Htr3_ClntTempTgt' incorporates:
         *  Constant: '<S4171>/Calib'
         */
        THMR_ac_B.OutportBufferForHtr3_ClntTempTg = KeTHMR_T_Htr3_ClntTempTgt;
    }
    else
    {
        if (THMR_ac_DW.Htr3_MODE)
        {
            /* Disable for SignalConversion generated from: '<S4121>/Htr3_ClntTempTgt' incorporates:
             *  Outport: '<S4121>/Htr3_ClntTempTgt'
             */
            THMR_ac_B.OutportBufferForHtr3_ClntTempTg = 0.0F;
            THMR_ac_DW.Htr3_MODE = false;
        }
    }

    /* End of Outputs for SubSystem: '<S4097>/Htr3' */

    /* Gain: '<S4066>/Gain' */
    THMR_ac_B.Gain_cs = THMR_ac_B.Merge_f;

    /* Outputs for Enabled SubSystem: '<S4097>/Htr4' incorporates:
     *  EnablePort: '<S4122>/Enable'
     */
    /* Constant: '<S4126>/Calib' */
    if (KeTHMR_b_Htr4_Slctn_State)
    {
        THMR_ac_DW.Htr4_MODE = true;

        /* If: '<S4122>/If' incorporates:
         *  Constant: '<S4192>/Calib'
         *  Constant: '<S4193>/Calib'
         *  Constant: '<S4194>/Calib'
         */
        if (KeTHMR_b_Htr4_Cntrl_Mchnztn_1)
        {
            /* Outputs for IfAction SubSystem: '<S4122>/Cntrl_Mech_1' incorporates:
             *  ActionPort: '<S4188>/ActionPort'
             */
            /* Merge: '<S4122>/Merge' incorporates:
             *  Gain: '<S4199>/Gain'
             */
            THMR_ac_B.Merge_d = rtb_TmpSignalConversionAtBattCn;

            /* Gain: '<S4200>/Gain' */
            VeTHMR_P_Mechnztn1_Htr4Pwr = VeTHMR_P_ECH_HtrPwrTgt_B4D;

            /* Merge: '<S4122>/Merge1' incorporates:
             *  SignalConversion: '<S4188>/SignalConversion'
             */
            THMR_ac_B.Merge1_k = VeTHMR_P_Mechnztn1_Htr4Pwr;

            /* End of Outputs for SubSystem: '<S4122>/Cntrl_Mech_1' */
        }
        else if (KeTHMR_b_Htr4_Cntrl_Mchnztn_2)
        {
            /* Outputs for IfAction SubSystem: '<S4122>/Cntrl_Mech2' incorporates:
             *  ActionPort: '<S4187>/ActionPort'
             */
            /* Merge: '<S4122>/Merge' incorporates:
             *  Gain: '<S4197>/Gain'
             */
            THMR_ac_B.Merge_d = rtb_TmpSignalConversionAtVePM_a;

            /* Gain: '<S4198>/Gain' */
            VeTHMR_P_Mechnztn2_Htr4Pwr = VeTHMR_P_HVC_BattHtrPwr_AD;

            /* Merge: '<S4122>/Merge1' incorporates:
             *  SignalConversion: '<S4187>/SignalConversion'
             */
            THMR_ac_B.Merge1_k = VeTHMR_P_Mechnztn2_Htr4Pwr;

            /* End of Outputs for SubSystem: '<S4122>/Cntrl_Mech2' */
        }
        else if (KeTHMR_b_Htr4_Cntrl_Mchnztn_3)
        {
            /* Outputs for IfAction SubSystem: '<S4122>/Cntrl_Mech_3' incorporates:
             *  ActionPort: '<S4189>/ActionPort'
             */
            /* Merge: '<S4122>/Merge' incorporates:
             *  Gain: '<S4201>/Gain'
             */
            THMR_ac_B.Merge_d = rtb_VariantMerge_For_Variant_p3;

            /* Gain: '<S4202>/Gain' */
            VeTHMR_P_Mechnztn3_Htr4Pwr = Switch;

            /* Merge: '<S4122>/Merge1' incorporates:
             *  SignalConversion: '<S4189>/SignalConversion'
             */
            THMR_ac_B.Merge1_k = VeTHMR_P_Mechnztn3_Htr4Pwr;

            /* End of Outputs for SubSystem: '<S4122>/Cntrl_Mech_3' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S4122>/Cntrl_Mech_4' incorporates:
             *  ActionPort: '<S4190>/ActionPort'
             */
            /* Merge: '<S4122>/Merge' incorporates:
             *  Constant: '<S4097>/ConstantValue9'
             *  Gain: '<S4203>/Gain'
             */
            THMR_ac_B.Merge_d = false;

            /* Merge: '<S4122>/Merge1' incorporates:
             *  SignalConversion: '<S4190>/SignalConversion'
             */
            THMR_ac_B.Merge1_k = 0.0F;

            /* End of Outputs for SubSystem: '<S4122>/Cntrl_Mech_4' */
        }

        /* End of If: '<S4122>/If' */

        /* SignalConversion generated from: '<S4122>/Htr4_ClntTempTgt' incorporates:
         *  Constant: '<S4191>/Calib'
         */
        THMR_ac_B.OutportBufferForHtr4_ClntTempTg = KeTHMR_T_Htr4_ClntTempTgt;
    }
    else
    {
        if (THMR_ac_DW.Htr4_MODE)
        {
            /* Disable for SignalConversion generated from: '<S4122>/Htr4_ClntTempTgt' incorporates:
             *  Outport: '<S4122>/Htr4_ClntTempTgt'
             */
            THMR_ac_B.OutportBufferForHtr4_ClntTempTg = 0.0F;
            THMR_ac_DW.Htr4_MODE = false;
        }
    }

    /* End of Outputs for SubSystem: '<S4097>/Htr4' */

    /* Gain: '<S4067>/Gain' */
    THMR_ac_B.Gain_mk = THMR_ac_B.Merge_d;

    /* Gain: '<S4068>/Gain' incorporates:
     *  Constant: '<S4123>/Calib'
     */
    THMR_ac_B.Gain_h3 = KeTHMR_b_Htr1_Slctn_State;

    /* Gain: '<S4069>/Gain' incorporates:
     *  Constant: '<S4124>/Calib'
     */
    THMR_ac_B.Gain_a = KeTHMR_b_Htr2_Slctn_State;

    /* Gain: '<S4070>/Gain' incorporates:
     *  Constant: '<S4125>/Calib'
     */
    THMR_ac_B.Gain_nhg = KeTHMR_b_Htr3_Slctn_State;

    /* Gain: '<S4071>/Gain' incorporates:
     *  Constant: '<S4126>/Calib'
     */
    THMR_ac_B.Gain_l3 = KeTHMR_b_Htr4_Slctn_State;

    /* Gain: '<S4073>/Gain' */
    THMR_ac_B.Gain_py = VeTHMR_b_LTPsvPump_FltDtctd_AD;

    /* Switch: '<S5307>/Switch' incorporates:
     *  Constant: '<S5310>/Calib'
     *  Constant: '<S5317>/Calib'
     *  Inport: '<Root>/VePMPR_n_PECP_RPM_Op_St'
     *  Switch: '<S5301>/Switch'
     */
    if (KeTHMR_b_PECP_RPM_Flw_OpSt)
    {
        (void)Rte_Read_VePMPR_n_PECP_RPM_Op_St_Value(&rtb_UnitDelay10);

        /* Gain: '<S4074>/Gain' incorporates:
         *  Constant: '<S5305>/ConstantValue'
         *  Inport: '<Root>/VePMPR_n_PECP_RPM_Op_St'
         *  RelationalOperator: '<S5305>/Comparison'
         *  Switch: '<S5304>/Switch3'
         */
        THMR_ac_B.Gain_kx = (rtb_UnitDelay10 > 0.0F);
    }
    else if (KeTHMR_b_LTPsvPump_On_SD)
    {
        /* Gain: '<S4074>/Gain' incorporates:
         *  Constant: '<S5309>/Calib'
         *  Switch: '<S5301>/Switch'
         *  Switch: '<S5304>/Switch3'
         */
        THMR_ac_B.Gain_kx = KeTHMR_b_LTPsvPump_On_D;
    }
    else
    {
        /* Gain: '<S4074>/Gain' incorporates:
         *  Switch: '<S5301>/Switch'
         *  Switch: '<S5304>/Switch3'
         */
        THMR_ac_B.Gain_kx = THMR_ac_B.Comparison1;
    }

    /* End of Switch: '<S5307>/Switch' */

    /* Gain: '<S4075>/Gain' */
    THMR_ac_B.Gain_li = VeTHMR_b_LTPsvPump2_FltDtctd_AD;

    /* Switch: '<S5308>/Switch' incorporates:
     *  Constant: '<S5312>/Calib'
     *  Constant: '<S5318>/Calib'
     *  Inport: '<Root>/VePMPR_n_PECP2_RPM_Op_St'
     *  Switch: '<S5302>/Switch1'
     */
    if (KeTHMR_b_PECP2_RPM_Flw_OpSt)
    {
        (void)Rte_Read_VePMPR_n_PECP2_RPM_Op_St_Value(&rtb_UnitDelay12);

        /* Gain: '<S4076>/Gain' incorporates:
         *  Constant: '<S5306>/ConstantValue'
         *  Inport: '<Root>/VePMPR_n_PECP2_RPM_Op_St'
         *  RelationalOperator: '<S5306>/Comparison'
         *  Switch: '<S5304>/Switch3'
         */
        THMR_ac_B.Gain_me = (rtb_UnitDelay12 > 0.0F);
    }
    else if (KeTHMR_b_LTPsvPump2_On_SD)
    {
        /* Gain: '<S4076>/Gain' incorporates:
         *  Constant: '<S5311>/Calib'
         *  Switch: '<S5302>/Switch1'
         *  Switch: '<S5304>/Switch3'
         */
        THMR_ac_B.Gain_me = KeTHMR_b_LTPsvPump2_On_D;
    }
    else
    {
        /* Gain: '<S4076>/Gain' incorporates:
         *  Switch: '<S5302>/Switch1'
         *  Switch: '<S5304>/Switch3'
         */
        THMR_ac_B.Gain_me = THMR_ac_B.Comparison69;
    }

    /* End of Switch: '<S5308>/Switch' */

    /* Gain: '<S4077>/Gain' */
    THMR_ac_B.Gain_ha = VeTHMR_b_LTActPump_FltDtctd_AD;

    /* Switch: '<S5303>/Switch2' incorporates:
     *  Constant: '<S5314>/Calib'
     */
    if (KeTHMR_b_LTActPump_On_SD)
    {
        /* Gain: '<S4078>/Gain' incorporates:
         *  Constant: '<S5313>/Calib'
         */
        THMR_ac_B.Gain_mh = KeTHMR_b_LTActPump_On_D;
    }
    else
    {
        /* Gain: '<S4078>/Gain' */
        THMR_ac_B.Gain_mh = THMR_ac_B.Comparison2;
    }

    /* End of Switch: '<S5303>/Switch2' */

    /* Gain: '<S4079>/Gain' */
    THMR_ac_B.Gain_gh = VeTHMR_b_HTAuxPump_FltDtctd_AD;

    /* Switch: '<S5304>/Switch3' incorporates:
     *  Constant: '<S5316>/Calib'
     */
    if (KeTHMR_b_HTAuxPump_On_SD)
    {
        /* Gain: '<S4080>/Gain' incorporates:
         *  Constant: '<S5315>/Calib'
         */
        THMR_ac_B.Gain_bz = KeTHMR_b_HTAuxPump_On_D;
    }
    else
    {
        /* Gain: '<S4080>/Gain' */
        THMR_ac_B.Gain_bz = THMR_ac_B.Comparison3;
    }

    /* End of Switch: '<S5304>/Switch3' */

    /* Switch: '<S4094>/Switch' incorporates:
     *  Constant: '<S5346>/Calib'
     *  Inport: '<Root>/VePMIR_b_LTActvPumpRespErr'
     *  Inport: '<Root>/VePMPR_n_LT_ActvPmpCmd'
     */
    if (KeTHMR_b_LTAP_ExpOff_SelDial)
    {
        /* Switch: '<S4094>/Switch' incorporates:
         *  Constant: '<S5340>/Calib'
         */
        VeTHMR_b_LTActPmp_ExpctdOff = KeTHMR_b_LTAP_ExpOff_Dial;
    }
    else
    {
        (void)Rte_Read_VePMPR_n_LT_ActvPmpCmd_Value(&rtb_UnitDelay13);
        (void)Rte_Read_VePMIR_b_LTActvPumpRespErr_Value
            (&VeTHMR_b_LTActPmp_ExpctdOff);

        /* Switch: '<S4094>/Switch' incorporates:
         *  Constant: '<S5319>/Constant'
         *  Constant: '<S5320>/Constant'
         *  Constant: '<S5321>/Constant'
         *  Constant: '<S5322>/Constant'
         *  Constant: '<S5323>/Constant'
         *  Constant: '<S5324>/Constant'
         *  Constant: '<S5325>/Constant'
         *  Constant: '<S5326>/Constant'
         *  Constant: '<S5327>/Constant'
         *  Constant: '<S5328>/Constant'
         *  Constant: '<S5329>/Constant'
         *  Constant: '<S5330>/Calib'
         *  Constant: '<S5331>/Calib'
         *  Constant: '<S5332>/Calib'
         *  Constant: '<S5333>/Calib'
         *  Constant: '<S5334>/Calib'
         *  Constant: '<S5335>/Calib'
         *  Constant: '<S5336>/Calib'
         *  Constant: '<S5337>/Calib'
         *  Constant: '<S5338>/Calib'
         *  Constant: '<S5339>/Calib'
         *  Constant: '<S5341>/Calib'
         *  Constant: '<S5342>/Calib'
         *  Constant: '<S5343>/Calib'
         *  Constant: '<S5344>/Calib'
         *  Constant: '<S5345>/Calib'
         *  Constant: '<S5347>/Calib'
         *  Constant: '<S5348>/Calib'
         *  Constant: '<S5354>/Constant'
         *  Constant: '<S5355>/Constant'
         *  Constant: '<S5356>/Calib'
         *  Constant: '<S5357>/Calib'
         *  Constant: '<S5358>/Calib'
         *  DataStoreRead: '<S5326>/StatusByte_CommBusOff'
         *  DataStoreRead: '<S5327>/StatusByte_CommBus_B_Off'
         *  DataStoreRead: '<S5328>/StatusByte_LosCommBECM_A_CANC11'
         *  DataStoreRead: '<S5329>/StatusByte_LosCommBECM_A'
         *  Inport: '<Root>/VePMIR_b_LTActvPumpRespErr'
         *  Inport: '<Root>/VePMPR_n_LT_ActvPmpCmd'
         *  Logic: '<S4094>/Logical'
         *  Logic: '<S4094>/Logical1'
         *  Logic: '<S4094>/Logical10'
         *  Logic: '<S4094>/Logical11'
         *  Logic: '<S4094>/Logical12'
         *  Logic: '<S4094>/Logical13'
         *  Logic: '<S4094>/Logical14'
         *  Logic: '<S4094>/Logical15'
         *  Logic: '<S4094>/Logical16'
         *  Logic: '<S4094>/Logical17'
         *  Logic: '<S4094>/Logical18'
         *  Logic: '<S4094>/Logical19'
         *  Logic: '<S4094>/Logical2'
         *  Logic: '<S4094>/Logical20'
         *  Logic: '<S4094>/Logical21'
         *  Logic: '<S4094>/Logical22'
         *  Logic: '<S4094>/Logical3'
         *  Logic: '<S4094>/Logical4'
         *  Logic: '<S4094>/Logical5'
         *  Logic: '<S4094>/Logical6'
         *  Logic: '<S4094>/Logical7'
         *  Logic: '<S4094>/Logical8'
         *  Logic: '<S4094>/Logical9'
         *  Logic: '<S5349>/Logical2'
         *  Logic: '<S5349>/Logical4'
         *  Logic: '<S5350>/Logical8'
         *  Logic: '<S5350>/Logical9'
         *  Logic: '<S5351>/Logical12'
         *  Logic: '<S5352>/Logical12'
         *  Logic: '<S5353>/Logical12'
         *  RelationalOperator: '<S4094>/Comparison1'
         *  RelationalOperator: '<S4094>/Comparison2'
         *  RelationalOperator: '<S4094>/Comparison3'
         *  RelationalOperator: '<S4094>/Comparison4'
         *  RelationalOperator: '<S4094>/Comparison5'
         *  RelationalOperator: '<S4094>/Comparison6'
         *  RelationalOperator: '<S4094>/Comparison7'
         *  RelationalOperator: '<S4101>/Comparison8'
         *  RelationalOperator: '<S5326>/RelationalOperator'
         *  RelationalOperator: '<S5327>/RelationalOperator'
         *  RelationalOperator: '<S5328>/RelationalOperator'
         *  RelationalOperator: '<S5329>/RelationalOperator'
         *  RelationalOperator: '<S5349>/Comparison6'
         *  RelationalOperator: '<S5350>/Comparison7'
         *  RelationalOperator: '<S5351>/Comparison6'
         *  RelationalOperator: '<S5352>/Comparison6'
         *  RelationalOperator: '<S5353>/Comparison6'
         *  S-Function (sfix_bitop): '<S5326>/BitwiseOperator7'
         *  S-Function (sfix_bitop): '<S5327>/BitwiseOperator7'
         *  S-Function (sfix_bitop): '<S5328>/BitwiseOperator7'
         *  S-Function (sfix_bitop): '<S5329>/BitwiseOperator7'
         *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
         *  Switch: '<S226>/Switch'
         *  Switch: '<S235>/Switch'
         *  Switch: '<S4586>/Switch1'
         */
        VeTHMR_b_LTActPmp_ExpctdOff = ((((((((((((((((((uint32)
            VeTHMR_e_BatThrmlSt_B4D) != CeTHMR_e_ActiveCooling) ||
            (KeTHMR_b_LTAP_ExpOff_ActCoolChk_OV)) && ((((uint32)
            VeTHMR_e_BatThrmlSt_B4D) != CeTHMR_e_Heating) ||
            (KeTHMR_b_LTAP_ExpOff_BatHeatChk_OV))) && ((((uint32)
            VeTHMR_e_BatThrmlSt_B4D) != CeTHMR_e_Balancing) ||
            (KeTHMR_b_LTAP_ExpOff_BatBlncChk_OV))) && ((((uint32)
            VeTHMR_e_BatThrmlSt_B4D) != CeTHMR_e_PassiveCooling) ||
            (KeTHMR_b_LTAP_ExpOff_BatPsvCoolChk_OV))) && ((((uint32)
            VeTHMR_e_BatThrmlSt_B4D) != CeTHMR_e_PassiveHeating) ||
            (KeTHMR_b_LTAP_ExpOff_BatPsvHeatChk_OV))) && ((((uint32)
            rtb_TmpSignalConversionAtVePD_l) != CePDTR_e_Dischrg_ForcBatHeat_Hys)
            || (KeTHMR_b_LTAP_ExpOff_FrcdBattHeat_OV))) && ((((uint32)
            rtb_TmpSignalConversionAtVePD_l) != CePDTR_e_Dischrg_ForcBatCool_Hys)
            || (KeTHMR_b_LTAP_ExpOff_FrcdBattCool_OV))) && ((((((uint32)
            VeTHMR_e_BPCM_LIN_BusOff) != CeBPCR_e_LIN_BusOff_Enabled) &&
            (!VeTHMR_b_BPCM_LIN_BusOff_FA)) &&
            (VeTHMR_b_BPCM_LIN_BusOff_SgnlRcvd)) ||
            (KeTHMR_b_LTAP_ExpOff_BPCM_LINBusChk_OV))) && ((((((uint32)
            VeTHMR_e_BPCM_LOC_BCP) != CeBPCR_e_LOC_BCP_True) &&
            (!VeTHMR_b_BPCM_LOC_BCP_FA)) && (VeTHMR_b_BPCM_LOC_BCP_SgnlRcvd)) ||
            (KeTHMR_b_LTAP_ExpOff_BPCM_LOCChk_OV))) && ((((((sint32)
            THMR_ac_DW.StatusByte_CommBusOff) & 1) <= 0) || (((((sint32)
            THMR_ac_DW.StatusByte_CommBus_B_Off) & 1) <= 0) &&
            (!KeTHMR_b_CommBus_B_Off_Ovrd))) ||
            (KeTHMR_b_LTAP_ExpOff_ePTBusOff_OV))) && ((((((sint32)
            THMR_ac_DW.StatusByte_LosCommBECM_A) & 1) <= 0) || (((((sint32)
            THMR_ac_DW.StatusByte_LosCommBECM_A_CANC11) & 1) <= 0) &&
            (!KeTHMR_b_LosCommBECM_A_CANC11_Ovrd))) ||
            (KeTHMR_b_LTAP_ExpOff_LOCwBPCM_OV))) && ((VeTHMR_dV_LTAPFlwReq_Mod_1
            <= KeTHMR_dV_LTAP_ExpOff_MinLTAPFlow) ||
            (KeTHMR_b_LTAP_ExpOff_FlwChk_OV))) && ((!VeTHMR_b_LTActPmp_ExpctdOff)
            || (KeTHMR_b_LTAP_ExpOff_RsErrChk_OV))) &&
            ((rtb_TmpSignalConversionAtVePMIR <= KeTHMR_n_LTAP_ExpOff_MinLTAPSpd)
             || (KeTHMR_b_LTAP_ExpOff_ActSpdChk_OV))) && ((rtb_UnitDelay13 <=
            KeTHMR_n_LTAP_ExpOff_MinLTAPCmnd) ||
            (KeTHMR_b_LTAP_ExpOff_CmndSpdChk_OV)));
    }

    /* End of Switch: '<S4094>/Switch' */

    /* Gain: '<S4055>/Gain' */
    THMR_ac_B.Gain_ge = VeTHMR_b_LTActPmp_ExpctdOff;

    /* Outputs for Atomic SubSystem: '<S4087>/Hysteresis' */
    /* Switch: '<S5285>/Switch1' incorporates:
     *  Constant: '<S4046>/Calib'
     *  RelationalOperator: '<S5285>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeBTRR > KeTHMR_T_BattCellPriorityThresholdHigh)
    {
        /* Switch: '<S5285>/Switch1' incorporates:
         *  Constant: '<S5285>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVePM_a = true;
    }
    else
    {
        /* Switch: '<S5285>/Switch1' incorporates:
         *  Constant: '<S4047>/Calib'
         *  RelationalOperator: '<S5285>/GreaterThan1'
         *  UnitDelay: '<S5285>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVePM_a = ((rtb_TmpSignalConversionAtVeBTRR >=
            KeTHMR_T_BattCellPriorityThresholdLow) &&
            (THMR_ac_DW.UnitDelay_DSTATE_kqg));
    }

    /* End of Switch: '<S5285>/Switch1' */

    /* Update for UnitDelay: '<S5285>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kqg = rtb_TmpSignalConversionAtVePM_a;

    /* End of Outputs for SubSystem: '<S4087>/Hysteresis' */

    /* Switch: '<S5286>/Switch1' */
    if (rtb_TmpSignalConversionAtVePM_a)
    {
        /* Switch: '<S5287>/Switch1' */
        if (VeTHMR_b_CabAllowCond)
        {
            /* Switch: '<S5286>/Switch1' incorporates:
             *  Logic: '<S4087>/Logical'
             *  Switch: '<S5287>/Switch1'
             */
            VeTHMR_b_BattPriorityOvercabin = ((VeTHMR_b_CabAllowCond) &&
                rtb_TmpSignalConversionAtVeCT_c);
        }
        else
        {
            /* Switch: '<S5286>/Switch1' incorporates:
             *  Constant: '<S4087>/ConstantValue1'
             *  Switch: '<S5287>/Switch1'
             */
            VeTHMR_b_BattPriorityOvercabin = true;
        }
    }
    else
    {
        /* Switch: '<S5286>/Switch1' incorporates:
         *  Constant: '<S4087>/ConstantValue'
         */
        VeTHMR_b_BattPriorityOvercabin = false;
    }

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeBTRR_dT_CellTempDelta' */
    /* Gateway: THMR_FUNC_RU_MedTEH/Subsystem__Subsystem1/ThermalMode */
    /* During: THMR_FUNC_RU_MedTEH/Subsystem__Subsystem1/ThermalMode */
    (void)Rte_Read_VeBTRR_dT_CellTempDelta_Value(&rtb_UnitDelay11);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Chart: '<S83>/ThermalMode' incorporates:
     *  Constant: '<S5274>/Calib'
     *  Constant: '<S5275>/Calib'
     *  Constant: '<S5276>/Calib'
     *  Constant: '<S5284>/Calib'
     *  Constant: '<S5288>/Calib'
     *  Constant: '<S5289>/Calib'
     *  Constant: '<S5298>/Calib'
     *  Constant: '<S5299>/Calib'
     *  Constant: '<S5300>/Calib'
     *  Gain: '<S4027>/Gain'
     *  Gain: '<S4032>/Gain'
     *  Gain: '<S4033>/Gain'
     *  Gain: '<S4034>/Gain'
     *  Gain: '<S4035>/Gain'
     */
    if (((uint32)THMR_ac_DW.is_active_c17_THMR_ac) == 0U)
    {
        /* Entry: THMR_FUNC_RU_MedTEH/Subsystem__Subsystem1/ThermalMode */
        THMR_ac_DW.is_active_c17_THMR_ac = 1U;

        /* Entry Internal: THMR_FUNC_RU_MedTEH/Subsystem__Subsystem1/ThermalMode */
        THMR_enter_internal_ThermalMode();

        /* Entry Internal 'BattCond': '<S4096>:32' */
        /* Transition: '<S4096>:115' */
        THMR_ac_DW.is_BattCond = THMR_ac_IN_Off;

        /* Entry Internal 'Off': '<S4096>:38' */
        if (rtb_UnitDelay11 > KeTHMR_dT_CellTempDltOn)
        {
            /* Transition: '<S4096>:130' */
            THMR_ac_DW.is_Off = THMR_ac_IN_Balancing;

            /* Entry 'Balancing': '<S4096>:39' */
        }
        else
        {
            THMR_ac_DW.is_Off = THMR_ac_IN_PumpOff;

            /* Entry 'PumpOff': '<S4096>:40' */
        }

        /* Entry Internal 'Control': '<S4096>:19' */
        /* Entry Internal 'ACComp': '<S4096>:24' */
        /* Transition: '<S4096>:96' */
        THMR_ac_DW.is_ACComp = THMR_ac_IN_Off_b;

        /* Entry 'Off': '<S4096>:25' */
        THMR_ac_B.VeTHMR_e_ACComp = CeTHMR_e_ACOff;

        /* Entry Internal 'RadFan': '<S4096>:28' */
        /* Transition: '<S4096>:102' */
        THMR_ac_DW.is_RadFan = THMR_ac_IN_Off_b;

        /* Entry 'Off': '<S4096>:29' */
        THMR_ac_B.VeTHMR_e_RadFan = CeFSCR_e_RadFan_OFF;

        /* Entry Internal 'RSV': '<S4096>:3' */
        /* Transition: '<S4096>:91' */
        THMR_ac_DW.is_RSV = THMR_ac_IN_OpenAll;

        /* Entry 'OpenAll': '<S4096>:1' */
        THMR_ac_B.VeTHMR_e_RSV = CeTHMR_e_AllOpen;
        THMR_ac_DW.RSV_count = 0.0F;

        /* Entry Internal 'Heater': '<S4096>:419' */
        /* Entry Internal 'Htr1': '<S4096>:420' */
        /* Transition: '<S4096>:452' */
        THMR_ac_DW.is_Htr1 = THMR_ac_IN_Slct;

        /* Entry 'Slct': '<S4096>:422' */
        THMR_ac_B.VeTHMR_e_Htr1 = CeTHMR_e_HtrDefault;

        /* Entry Internal 'Htr2': '<S4096>:425' */
        /* Transition: '<S4096>:465' */
        THMR_ac_DW.is_Htr2 = THMR_ac_IN_Slct;

        /* Entry 'Slct': '<S4096>:427' */
        THMR_ac_B.VeTHMR_e_Htr2 = CeTHMR_e_HtrDefault;

        /* Entry Internal 'Htr3': '<S4096>:430' */
        /* Transition: '<S4096>:478' */
        THMR_ac_DW.is_Htr3 = THMR_ac_IN_Slct;

        /* Entry 'Slct': '<S4096>:432' */
        THMR_ac_B.VeTHMR_e_Htr3 = CeTHMR_e_HtrDefault;

        /* Entry Internal 'Htr4': '<S4096>:435' */
        /* Transition: '<S4096>:491' */
        THMR_ac_DW.is_Htr4 = THMR_ac_IN_Slct;

        /* Entry 'Slct': '<S4096>:437' */
        THMR_ac_B.VeTHMR_e_Htr4 = CeTHMR_e_HtrDefault;

        /* Entry Internal 'Pumps': '<S4096>:507' */
        /* Entry Internal 'PECP2': '<S4096>:512' */
        /* Transition: '<S4096>:530' */
        THMR_ac_DW.is_PECP2 = THMR_ac_IN_Off_b;

        /* Entry 'Off': '<S4096>:513' */
        THMR_ac_B.VeTHMR_e_LTPsvPmp2_OpState = CeTHMR_e_PumpOff;

        /* Entry Internal 'LTAP': '<S4096>:516' */
        /* Transition: '<S4096>:546' */
        THMR_ac_DW.is_LTAP = THMR_ac_IN_Off_b;

        /* Entry 'Off': '<S4096>:517' */
        THMR_ac_B.VeTHMR_e_LTActPmp_OpState = CeTHMR_e_PumpOff;

        /* Entry Internal 'HTAP': '<S4096>:520' */
        /* Transition: '<S4096>:547' */
        THMR_ac_DW.is_HTAP = THMR_ac_IN_Off_b;

        /* Entry 'Off': '<S4096>:521' */
        THMR_ac_B.VeTHMR_e_HTAuxPmp_OpState = CeTHMR_e_PumpOff;

        /* Entry Internal 'PECP': '<S4096>:508' */
        /* Transition: '<S4096>:524' */
        THMR_ac_DW.is_PECP = THMR_ac_IN_Off_b;

        /* Entry 'Off': '<S4096>:511' */
        THMR_ac_B.VeTHMR_e_LTPsvPmp_OpState = CeTHMR_e_PumpOff;
    }
    else
    {
        THMR_ac_ThermalMode(((const boolean *)&(KeTHMR_b_StartAgain)), ((const
                              boolean *)&(KeTHMR_b_ShutdownPending)), ((const
                              boolean *)&(KeTHMR_b_PowerFault)));

        /* During 'BattCond': '<S4096>:32' */
        switch (THMR_ac_DW.is_BattCond)
        {
          case THMR_ac_IN_Cooling:
            /* During 'Cooling': '<S4096>:34' */
            if (((sint32)THMR_ac_DW.is_ThermalMode) == 1)
            {
                /* Transition: '<S4096>:112' */
                /* Exit Internal 'Cooling': '<S4096>:34' */
                THMR_ac_DW.is_Cooling = THMR_ac_IN_NO_ACTIVE_CHILD;
                THMR_ac_DW.is_BattCond = THMR_ac_IN_Fault_i;

                /* Entry 'Fault': '<S4096>:33' */
            }
            else if ((((VeTHMR_T_CellTempMax <= ((rtb_Add_h -
                          KeTHMR_dT_CellTempPassCoolOfst) -
                         KeTHMR_dT_CellTempHysteresis)) ||
                       ((VeTHMR_T_CellTempMax <= (rtb_Add_h -
                          KeTHMR_dT_CellTempHysteresis)) &&
                        (TmpSignalConversionAtOutAirTemp >=
                         (VeTHMR_T_CellTempMax - KeTHMR_dT_RecircAmbCellDelta))))
                      || ((((sint32)THMR_ac_DW.is_ThermalMode) != 4) &&
                          (((sint32)THMR_ac_DW.is_OffPlug) != 2))) && (((sint32)
                       THMR_ac_DW.is_ThermalMode) != 1))
            {
                /* Transition: '<S4096>:114' */
                /* Exit Internal 'Cooling': '<S4096>:34' */
                THMR_ac_DW.is_Cooling = THMR_ac_IN_NO_ACTIVE_CHILD;
                THMR_ac_DW.is_BattCond = THMR_ac_IN_Off;

                /* Entry Internal 'Off': '<S4096>:38' */
                if (rtb_UnitDelay11 > KeTHMR_dT_CellTempDltOn)
                {
                    /* Transition: '<S4096>:130' */
                    THMR_ac_DW.is_Off = THMR_ac_IN_Balancing;

                    /* Entry 'Balancing': '<S4096>:39' */
                }
                else
                {
                    THMR_ac_DW.is_Off = THMR_ac_IN_PumpOff;

                    /* Entry 'PumpOff': '<S4096>:40' */
                }
            }
            else
            {
                switch (THMR_ac_DW.is_Cooling)
                {
                  case THMR_ac_IN_ActiveCooling:
                    /* During 'ActiveCooling': '<S4096>:36' */
                    /* Transition: '<S4096>:123' */
                    THMR_ac_DW.is_Cooling = THMR_ac_IN_PassiveCooling;

                    /* Entry 'PassiveCooling': '<S4096>:35' */
                    break;

                  case THMR_ac_IN_PassiveCooling:
                    /* During 'PassiveCooling': '<S4096>:35' */
                    break;

                  default:
                    /* During 'Recirculation': '<S4096>:37' */
                    /* Transition: '<S4096>:127' */
                    THMR_ac_DW.is_Cooling = THMR_ac_IN_PassiveCooling;

                    /* Entry 'PassiveCooling': '<S4096>:35' */
                    break;
                }
            }
            break;

          case THMR_ac_IN_Fault_i:
            /* During 'Fault': '<S4096>:33' */
            if (((sint32)THMR_ac_DW.is_ThermalMode) != 1)
            {
                /* Transition: '<S4096>:117' */
                THMR_ac_DW.is_BattCond = THMR_ac_IN_Off;

                /* Entry Internal 'Off': '<S4096>:38' */
                if (rtb_UnitDelay11 > KeTHMR_dT_CellTempDltOn)
                {
                    /* Transition: '<S4096>:130' */
                    THMR_ac_DW.is_Off = THMR_ac_IN_Balancing;

                    /* Entry 'Balancing': '<S4096>:39' */
                }
                else
                {
                    THMR_ac_DW.is_Off = THMR_ac_IN_PumpOff;

                    /* Entry 'PumpOff': '<S4096>:40' */
                }
            }
            break;

          case THMR_ac_IN_Heating:
            /* During 'Heating': '<S4096>:41' */
            if (((VeTHMR_T_CellTempMin >= (VeTHMR_T_MinBattAllow +
                    KeTHMR_dT_CellTempHystHeat)) ||
                    (((THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i) &&
                      (VeTHMR_P_ChrgThermBdgt_AfterDial <=
                       (KeTHMR_P_ChrgBudgetMinHeat - KeTHMR_dP_ChrgThermBdgtHyst)))
                     || ((!THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i) &&
                         (KeTHMR_P_RU_ThermalPwrLim_tst == 0.0F)))) && (((sint32)
                    THMR_ac_DW.is_ThermalMode) != 1))
            {
                /* Transition: '<S4096>:119' */
                THMR_ac_DW.is_BattCond = THMR_ac_IN_Off;

                /* Entry Internal 'Off': '<S4096>:38' */
                if (rtb_UnitDelay11 > KeTHMR_dT_CellTempDltOn)
                {
                    /* Transition: '<S4096>:130' */
                    THMR_ac_DW.is_Off = THMR_ac_IN_Balancing;

                    /* Entry 'Balancing': '<S4096>:39' */
                }
                else
                {
                    THMR_ac_DW.is_Off = THMR_ac_IN_PumpOff;

                    /* Entry 'PumpOff': '<S4096>:40' */
                }
            }
            else
            {
                if (((sint32)THMR_ac_DW.is_ThermalMode) == 1)
                {
                    /* Transition: '<S4096>:120' */
                    THMR_ac_DW.is_BattCond = THMR_ac_IN_Fault_i;

                    /* Entry 'Fault': '<S4096>:33' */
                }
            }
            break;

          default:
            /* During 'Off': '<S4096>:38' */
            if (((((VeTHMR_T_CellTempMax > (rtb_Add_h -
                     KeTHMR_dT_CellTempPassCoolOfst)) &&
                    (TmpSignalConversionAtOutAirTemp < (VeTHMR_T_CellTempMax -
                     (KeTHMR_dT_RecircAmbCellDelta +
                      KeTHMR_dT_RecircAmbCellDeltaHyst)))) ||
                    (VeTHMR_T_CellTempMax > rtb_Add_h)) && ((((sint32)
                    THMR_ac_DW.is_ThermalMode) == 4) || (((sint32)
                    THMR_ac_DW.is_OffPlug) == 2))) && (((sint32)
                    THMR_ac_DW.is_ThermalMode) != 1))
            {
                /* Transition: '<S4096>:113' */
                /* Exit Internal 'Off': '<S4096>:38' */
                THMR_ac_DW.is_Off = THMR_ac_IN_NO_ACTIVE_CHILD;
                THMR_ac_DW.is_BattCond = THMR_ac_IN_Cooling;

                /* Entry 'Cooling': '<S4096>:34' */
                /* Entry Internal 'Cooling': '<S4096>:34' */
                /* Transition: '<S4096>:129' */
                THMR_ac_DW.is_Cooling = THMR_ac_IN_PassiveCooling;

                /* Entry 'PassiveCooling': '<S4096>:35' */
            }
            else if (((sint32)THMR_ac_DW.is_ThermalMode) == 1)
            {
                /* Transition: '<S4096>:116' */
                /* Exit Internal 'Off': '<S4096>:38' */
                THMR_ac_DW.is_Off = THMR_ac_IN_NO_ACTIVE_CHILD;
                THMR_ac_DW.is_BattCond = THMR_ac_IN_Fault_i;

                /* Entry 'Fault': '<S4096>:33' */
            }
            else if (((VeTHMR_T_CellTempMin < VeTHMR_T_MinBattAllow) &&
                      (((THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i) &&
                        (VeTHMR_P_ChrgThermBdgt_AfterDial >
                         KeTHMR_P_ChrgBudgetMinHeat)) ||
                       ((!THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i) &&
                        (KeTHMR_P_RU_ThermalPwrLim_tst > 0.0F)))) && (((sint32)
                       THMR_ac_DW.is_ThermalMode) != 1))
            {
                /* Transition: '<S4096>:118' */
                /* Exit Internal 'Off': '<S4096>:38' */
                THMR_ac_DW.is_Off = THMR_ac_IN_NO_ACTIVE_CHILD;
                THMR_ac_DW.is_BattCond = THMR_ac_IN_Heating;

                /* Entry 'Heating': '<S4096>:41' */
            }
            else if (((sint32)THMR_ac_DW.is_Off) == 1)
            {
                /* During 'Balancing': '<S4096>:39' */
                if (rtb_UnitDelay11 <= KeTHMR_dT_CellTempDltOff)
                {
                    /* Transition: '<S4096>:132' */
                    THMR_ac_DW.is_Off = THMR_ac_IN_PumpOff;

                    /* Entry 'PumpOff': '<S4096>:40' */
                }
            }
            else
            {
                /* During 'PumpOff': '<S4096>:40' */
                if (rtb_UnitDelay11 > KeTHMR_dT_CellTempDltOn)
                {
                    /* Transition: '<S4096>:133' */
                    THMR_ac_DW.is_Off = THMR_ac_IN_Balancing;

                    /* Entry 'Balancing': '<S4096>:39' */
                }
            }
            break;
        }

        THMR_ac_Control(((const boolean *)&(KeTHMR_b_ACCompFaultTest)), &In1, ((
                          const boolean *)&(KeTHMR_b_RSVFault)), &Gain_bl,
                        &rtb_RelationalOperator7_p, &Gain_nh);
    }

    /* End of Chart: '<S83>/ThermalMode' */

    /* DataTypeConversion: '<S4040>/DataTypeConversion' */
    VeTHMR_e_RadFan_State_B4SET = THMR_ac_B.VeTHMR_e_RadFan;

    /* DataTypeConversion: '<S4042>/DataTypeConversion' */
    VeTHMR_e_Htr1_State_B4SET = THMR_ac_B.VeTHMR_e_Htr1;

    /* DataTypeConversion: '<S4043>/DataTypeConversion' */
    VeTHMR_e_Htr2_State_B4SET = THMR_ac_B.VeTHMR_e_Htr2;

    /* DataTypeConversion: '<S4044>/DataTypeConversion' */
    VeTHMR_e_Htr3_State_B4SET = THMR_ac_B.VeTHMR_e_Htr3;

    /* DataTypeConversion: '<S4045>/DataTypeConversion' */
    VeTHMR_e_Htr4_State_B4SET = THMR_ac_B.VeTHMR_e_Htr4;

    /* SignalConversion generated from: '<S4226>/VariantSource1' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_ShrdBattCab_Heater

    /* Gain: '<S5057>/Gain' incorporates:
     *  Constant: '<S4229>/ConstantValue'
     */
    rtb_Gain_c = false;

#else

    /* Gain: '<S5057>/Gain' incorporates:
     *  SignalConversion generated from: '<S4226>/VariantSource1'
     */
    rtb_Gain_c = rtb_Gain_pg;

#endif

    /* End of SignalConversion generated from: '<S4226>/VariantSource1' */

    /* SignalConversion generated from: '<S4226>/VariantSource1' */
    VeTHMR_b_BattAllowed_SeprtHtr = rtb_Gain_c;

    /* Switch: '<S4286>/Switch1' incorporates:
     *  Constant: '<S4291>/Calib'
     *  Constant: '<S4295>/Calib'
     *  Constant: '<S4297>/Calib'
     *  Logic: '<S4254>/Logical3'
     *  Logic: '<S4254>/Logical5'
     *  RelationalOperator: '<S4254>/Comparison1'
     *  Switch: '<S4284>/Switch1'
     *  Switch: '<S4285>/Switch1'
     *  Switch: '<S4287>/Switch1'
     */
    if (((VeTHMR_b_ThrmLoad_Shed) && (rtb_TmpSignalConversionAtVeCT_c ||
            (KeTHMR_b_DsblDfrst_LoadShedRejCab))) &&
            (KeTHMR_b_EnblLoadShed_RejCab))
    {
        /* Switch: '<S4286>/Switch1' incorporates:
         *  Constant: '<S4276>/Constant'
         */
        VeTHMR_e_HVACPerf_Mode = CeTHMR_e_LoadShed;
    }
    else if (VeTHMR_b_AlternatorMode_Actv)
    {
        /* Switch: '<S4286>/Switch1' incorporates:
         *  Constant: '<S4274>/Constant'
         *  Switch: '<S4285>/Switch1'
         */
        VeTHMR_e_HVACPerf_Mode = CeTHMR_e_AltrntrMode;
    }
    else if (rtb_TmpSignalConversionAtVeB_cu)
    {
        /* Switch: '<S4286>/Switch1' incorporates:
         *  Constant: '<S4278>/Constant'
         *  Switch: '<S4285>/Switch1'
         *  Switch: '<S4287>/Switch1'
         */
        VeTHMR_e_HVACPerf_Mode = CeTHMR_e_BattCrit;
    }
    else if (VeTHMR_P_PwrBdgt_PwrLimitAvail_BD < KeTHMR_P_PwrBudgt_LowThrsh)
    {
        /* Switch: '<S4286>/Switch1' incorporates:
         *  Constant: '<S4277>/Constant'
         *  Switch: '<S4284>/Switch1'
         *  Switch: '<S4285>/Switch1'
         *  Switch: '<S4287>/Switch1'
         */
        VeTHMR_e_HVACPerf_Mode = CeTHMR_e_LowPwrbudget;
    }
    else
    {
        /* Logic: '<S4254>/Logical1' incorporates:
         *  RelationalOperator: '<S4254>/RelationalOperator'
         *  RelationalOperator: '<S4254>/RelationalOperator1'
         *  Switch: '<S4284>/Switch1'
         *  Switch: '<S4285>/Switch1'
         *  Switch: '<S4287>/Switch1'
         */
        rtb_TmpSignalConversionAtVePMTR = ((!rtb_TmpSignalConversionAtVePMTR) ||
            (!rtb_TmpSignalConversionAtVeP_el));

        /* Switch: '<S4289>/Switch1' incorporates:
         *  Constant: '<S4283>/Constant'
         *  Constant: '<S4292>/Calib'
         *  Constant: '<S4293>/Calib'
         *  Constant: '<S4294>/Calib'
         *  Constant: '<S4296>/Calib'
         *  Logic: '<S4254>/Logical10'
         *  Logic: '<S4254>/Logical2'
         *  Logic: '<S4254>/Logical7'
         *  Logic: '<S4254>/Logical8'
         *  Logic: '<S4254>/Logical9'
         *  RelationalOperator: '<S4254>/RelationalOperator2'
         *  Switch: '<S3953>/Switch'
         *  Switch: '<S4284>/Switch1'
         *  Switch: '<S4285>/Switch1'
         *  Switch: '<S4287>/Switch1'
         *  Switch: '<S4288>/Switch1'
         *  Switch: '<S4290>/Switch1'
         */
        if ((rtb_TmpSignalConversionAtVePMTR && (!VeTHMR_b_REMDisabled)) &&
                (KeTHMR_b_CabDsblRemEnbl))
        {
            /* Switch: '<S4286>/Switch1' incorporates:
             *  Constant: '<S4281>/Constant'
             *  Switch: '<S4289>/Switch1'
             */
            VeTHMR_e_HVACPerf_Mode = CeTHMR_e_CabDsblREM;
        }
        else if ((rtb_TmpSignalConversionAtVePMTR && (((uint32)
                    VeTHMR_e_ShippingMode) != CePLTR_e_ShipingMode_CUST_MD)) &&
                 (KeTHMR_b_CabDsblShippingEnbl))
        {
            /* Switch: '<S4290>/Switch1' incorporates:
             *  Constant: '<S4282>/Constant'
             *  Switch: '<S4286>/Switch1'
             *  Switch: '<S4289>/Switch1'
             */
            VeTHMR_e_HVACPerf_Mode = CeTHMR_e_CabDsblShipping;
        }
        else if ((rtb_TmpSignalConversionAtVeBT_e &&
                  (rtb_TmpSignalConversionAtVeCT_c ||
                   (KeTHMR_b_DsblDfrst_HybAltMdShedRejCab))) &&
                 (KeTHMR_b_EnblHybAltMd_RejCab))
        {
            /* Switch: '<S4288>/Switch1' incorporates:
             *  Constant: '<S4280>/Constant'
             *  Switch: '<S4286>/Switch1'
             *  Switch: '<S4289>/Switch1'
             *  Switch: '<S4290>/Switch1'
             */
            VeTHMR_e_HVACPerf_Mode = CeTHMR_e_HybAltMode;
        }
        else
        {
            /* Switch: '<S4286>/Switch1' incorporates:
             *  Constant: '<S4275>/Constant'
             *  Switch: '<S4288>/Switch1'
             *  Switch: '<S4289>/Switch1'
             *  Switch: '<S4290>/Switch1'
             */
            VeTHMR_e_HVACPerf_Mode = CeTHMR_e_NormalMode;
        }
    }

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeTPCR_b_HtrOrEAC_FltRawPrst' */
    (void)Rte_Read_VeTPCR_b_HtrOrEAC_FltRawPrst_Value(&rtb_Switch1_hj);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Switch: '<S4254>/Switch' incorporates:
     *  Constant: '<S4279>/Constant'
     *  RelationalOperator: '<S4254>/Comparison4'
     *  Switch: '<S4286>/Switch1'
     */
    VeTHMR_b_CabRejFlag = (((uint32)VeTHMR_e_HVACPerf_Mode) !=
                           CeTHMR_e_NormalMode);

    /* Logic: '<S4250>/Logical2' incorporates:
     *  Constant: '<S4255>/Calib'
     *  Switch: '<S4250>/Switch1'
     */
    VeTHMR_b_CabHeatReq_NotAllow_SOC = (((!KeTHMR_b_CabNotAlw_KeyRun_TurnOff_SD)
        && (VeTHMR_b_CabReq_NotAllow_Key_RUN)) ||
        (VeTHMR_b_CabReq_NotAllow_SOC_Wall));

    /* Logic: '<S4250>/Logical4' incorporates:
     *  Constant: '<S4256>/Calib'
     */
    VeTHMR_b_CabHeatReq_Chk = (((VeTHMR_b_AC_CompReq) ||
        rtb_TmpSignalConversionAtVeCT_o) || (KeTHMR_b_No_HVAC_Rq_Message4));

    /* Logic: '<S4258>/LogicalOperator' incorporates:
     *  Constant: '<S4303>/Constant'
     *  Constant: '<S4304>/Constant'
     *  Constant: '<S4305>/Constant'
     *  Constant: '<S4306>/Constant1'
     *  Constant: '<S4306>/Constant2'
     *  Constant: '<S4307>/Constant'
     *  Constant: '<S4308>/Calib'
     *  Constant: '<S4309>/Calib'
     *  Constant: '<S4310>/Calib'
     *  Constant: '<S4311>/Calib'
     *  Constant: '<S4312>/Calib'
     *  DataStoreRead: '<S4303>/StatusByte_CommBusOff'
     *  DataStoreRead: '<S4304>/StatusByte_CommBus_B_Off'
     *  DataStoreRead: '<S4305>/StatusByte_HiSpdCANCommBus'
     *  DataStoreRead: '<S4307>/StatusByte_ThrmlRlyCtrlCkt'
     *  Logic: '<S4258>/LogicalOperator1'
     *  Logic: '<S4258>/LogicalOperator2'
     *  Logic: '<S4258>/LogicalOperator3'
     *  Logic: '<S4258>/LogicalOperator4'
     *  Logic: '<S4258>/LogicalOperator5'
     *  Logic: '<S4306>/Logical Operator'
     *  RelationalOperator: '<S4303>/RelationalOperator'
     *  RelationalOperator: '<S4304>/RelationalOperator'
     *  RelationalOperator: '<S4305>/RelationalOperator'
     *  RelationalOperator: '<S4306>/Relational Operator1'
     *  RelationalOperator: '<S4306>/Relational Operator2'
     *  RelationalOperator: '<S4307>/RelationalOperator'
     *  S-Function (sfix_bitop): '<S4303>/BitwiseOperator7'
     *  S-Function (sfix_bitop): '<S4304>/BitwiseOperator7'
     *  S-Function (sfix_bitop): '<S4305>/BitwiseOperator7'
     *  S-Function (sfix_bitop): '<S4307>/BitwiseOperator7'
     */
    VeTHMR_b_ThrmlCommFlts_InhibitMsg4 = ((((((((sint32)
        THMR_ac_DW.StatusByte_ThrmlRlyCtrlCkt) & 1) > 0) &&
        (KeTHMR_b_InhibitMsg4_ThrmlRlyFlt)) || (((((sint32)
        THMR_ac_DW.StatusByte_HiSpdCANCommBus) & 1) > 0) &&
        (KeTHMR_b_InhibitMsg4_CanCBusoff))) || (((tmpRead_1b != 0U) &&
        (VeTHMR_b_BCH_U1009_DTCSet_tmp == 0U)) &&
        (KeTHMR_b_InhibitMsg4_LIN2Busoff))) || ((((((sint32)
        THMR_ac_DW.StatusByte_CommBusOff) & 1) > 0) && (((((sint32)
        THMR_ac_DW.StatusByte_CommBus_B_Off) & 1) > 0) ||
        (KeTHMR_b_CommBus_B_Off_Ovrd))) && (KeTHMR_b_InhibitMsg4_CanEptBusoff)));

    /* Logic: '<S4250>/Logical3' incorporates:
     *  Logic: '<S4250>/Logical6'
     *  Logic: '<S4250>/LogicalOperator'
     */
    VeTHMR_b_HVAC_turnedOff_B4D = (((VeTHMR_b_CabHeatReq_NotAllow_SOC) &&
        (VeTHMR_b_CabHeatReq_Chk)) && ((!rtb_Switch1_hj) &&
        (!VeTHMR_b_ThrmlCommFlts_InhibitMsg4)));

    /* Switch: '<S4416>/Switch1' incorporates:
     *  Constant: '<S4417>/Calib'
     *  RelationalOperator: '<S4105>/RelationalOperator'
     */
    if (rtb_TmpSignalConversionAtVeT_dg >= KeTHMR_Pct_HTLVlvFullyOpen)
    {
        /* Switch: '<S4416>/Switch1' */
        VeTHMR_T_HTCLHexInletTemp = rtb_TmpSignalConversionAtVeTM_f;
    }
    else
    {
        /* Switch: '<S4416>/Switch1' incorporates:
         *  Product: '<S4415>/Product'
         *  Product: '<S4415>/Product1'
         *  Sum: '<S4415>/Add1'
         */
        VeTHMR_T_HTCLHexInletTemp = (rtb_TmpSignalConversionAtVeT_j5 *
            rtb_TmpSignalConversionAtVePM_l) + (rtb_Switch1_d *
            rtb_TmpSignalConversionAtVeTM_f);
    }

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/MBC_HTL_LTCL'
     */
    /* RelationalOperator: '<S4110>/RelationalOperator1' incorporates:
     *  Merge: '<S4570>/Merge1'
     *  RelationalOperator: '<S4110>/RelationalOperator13'
     *  RelationalOperator: '<S4110>/RelationalOperator16'
     *  RelationalOperator: '<S4110>/RelationalOperator20'
     *  RelationalOperator: '<S4110>/RelationalOperator24'
     *  RelationalOperator: '<S4110>/RelationalOperator5'
     *  RelationalOperator: '<S4110>/RelationalOperator8'
     *  RelationalOperator: '<S64>/Comparison4'
     *  Switch: '<S4463>/Switch1'
     *  Switch: '<S4464>/Switch1'
     *  Switch: '<S4465>/Switch1'
     *  Switch: '<S4466>/Switch1'
     *  Switch: '<S4467>/Switch1'
     *  Switch: '<S4468>/Switch1'
     */
    rtb_Switch1_o0g = THMR_ac_B.VeTHMR_e_CabHeatThermalState;

    /* Switch: '<S4463>/Switch1' incorporates:
     *  Constant: '<S4438>/Constant'
     *  Constant: '<S4439>/Constant'
     *  Constant: '<S4440>/Constant'
     *  Constant: '<S4441>/Constant'
     *  Constant: '<S4442>/Constant'
     *  Constant: '<S4443>/Constant'
     *  Constant: '<S4444>/Constant'
     *  Constant: '<S4445>/Constant'
     *  Constant: '<S4446>/Constant'
     *  Constant: '<S4447>/Constant'
     *  Constant: '<S4448>/Constant'
     *  Constant: '<S4449>/Constant'
     *  Constant: '<S4450>/Constant'
     *  Constant: '<S4451>/Constant'
     *  Constant: '<S4452>/Constant'
     *  Constant: '<S4453>/Constant'
     *  Constant: '<S4454>/Constant'
     *  Constant: '<S4455>/Constant'
     *  Constant: '<S4456>/Constant'
     *  Constant: '<S4457>/Constant'
     *  Constant: '<S4458>/Constant'
     *  Constant: '<S4459>/Constant'
     *  Constant: '<S4460>/Constant'
     *  Constant: '<S4461>/Constant'
     *  Constant: '<S4462>/Constant'
     *  Logic: '<S4110>/LogicalOperator'
     *  Logic: '<S4110>/LogicalOperator1'
     *  Logic: '<S4110>/LogicalOperator2'
     *  Logic: '<S4110>/LogicalOperator3'
     *  Logic: '<S4110>/LogicalOperator4'
     *  Logic: '<S4110>/LogicalOperator5'
     *  Logic: '<S4110>/LogicalOperator6'
     *  RelationalOperator: '<S4101>/Comparison8'
     *  RelationalOperator: '<S4110>/RelationalOperator'
     *  RelationalOperator: '<S4110>/RelationalOperator1'
     *  RelationalOperator: '<S4110>/RelationalOperator10'
     *  RelationalOperator: '<S4110>/RelationalOperator11'
     *  RelationalOperator: '<S4110>/RelationalOperator12'
     *  RelationalOperator: '<S4110>/RelationalOperator13'
     *  RelationalOperator: '<S4110>/RelationalOperator14'
     *  RelationalOperator: '<S4110>/RelationalOperator15'
     *  RelationalOperator: '<S4110>/RelationalOperator16'
     *  RelationalOperator: '<S4110>/RelationalOperator17'
     *  RelationalOperator: '<S4110>/RelationalOperator18'
     *  RelationalOperator: '<S4110>/RelationalOperator19'
     *  RelationalOperator: '<S4110>/RelationalOperator2'
     *  RelationalOperator: '<S4110>/RelationalOperator20'
     *  RelationalOperator: '<S4110>/RelationalOperator21'
     *  RelationalOperator: '<S4110>/RelationalOperator23'
     *  RelationalOperator: '<S4110>/RelationalOperator24'
     *  RelationalOperator: '<S4110>/RelationalOperator25'
     *  RelationalOperator: '<S4110>/RelationalOperator3'
     *  RelationalOperator: '<S4110>/RelationalOperator4'
     *  RelationalOperator: '<S4110>/RelationalOperator5'
     *  RelationalOperator: '<S4110>/RelationalOperator6'
     *  RelationalOperator: '<S4110>/RelationalOperator7'
     *  RelationalOperator: '<S4110>/RelationalOperator8'
     *  RelationalOperator: '<S4110>/RelationalOperator9'
     *  Switch: '<S4464>/Switch1'
     *  Switch: '<S4465>/Switch1'
     *  Switch: '<S4466>/Switch1'
     *  Switch: '<S4467>/Switch1'
     *  Switch: '<S4468>/Switch1'
     *  Switch: '<S4469>/Switch1'
     *  Switch: '<S4586>/Switch1'
     */
    if ((((((uint32)VeTHMR_e_CabThermalMode) == CeTHMR_e_Cab_Cooling_n_Heating) &&
          (((uint32)rtb_Switch1_o0g) == CeTHMR_e_CabinActiveHeating)) &&
            (((uint32)VeTHMR_b_CompressorReqOn_0_tmp) == CeTHMR_e_ElectricHtr)) &&
        (((uint32)VeTHMR_e_BatThrmlSt_B4D) == CeTHMR_e_ActiveCooling))
    {
        /* Switch: '<S4463>/Switch1' incorporates:
         *  Constant: '<S4110>/Constant'
         */
        THMR_ac_B.Switch1_m = 7.0F;
    }
    else if (((((uint32)VeTHMR_e_CabThermalMode) ==
               CeTHMR_e_Cab_Cooling_n_Heating) && (((uint32)rtb_Switch1_o0g) ==
               CeTHMR_e_CabinActiveHeating)) && (((uint32)
               VeTHMR_b_CompressorReqOn_0_tmp) == CeTHMR_e_ElectricHtr))
    {
        /* Switch: '<S4464>/Switch1' incorporates:
         *  Constant: '<S4110>/Constant1'
         *  Switch: '<S4463>/Switch1'
         */
        THMR_ac_B.Switch1_m = 3.0F;
    }
    else if ((((((uint32)VeTHMR_e_CabThermalMode) == CeTHMR_e_Cab_Cooling) &&
               (((uint32)rtb_Switch1_o0g) == CeTHMR_e_NoCabinHeating)) &&
              (((uint32)VeTHMR_b_CompressorReqOn_0_tmp) == CeTHMR_e_NoActvHeat))
             && (((uint32)VeTHMR_e_BatThrmlSt_B4D) == CeTHMR_e_ActiveCooling))
    {
        /* Switch: '<S4465>/Switch1' incorporates:
         *  Constant: '<S4110>/Constant2'
         *  Switch: '<S4463>/Switch1'
         *  Switch: '<S4464>/Switch1'
         */
        THMR_ac_B.Switch1_m = 8.0F;
    }
    else if ((((((uint32)VeTHMR_e_CabThermalMode) ==
                CeTHMR_e_Cab_Cooling_n_Heating) && (((uint32)rtb_Switch1_o0g) ==
                CeTHMR_e_CabinActiveHeating)) && (((uint32)
                VeTHMR_b_CompressorReqOn_0_tmp) == CeTHMR_e_HeatPump)) &&
             (((uint32)VeTHMR_e_BatThrmlSt_B4D) ==
              CeTHMR_e_BTLActvWasteHeatRcvry))
    {
        /* Switch: '<S4466>/Switch1' incorporates:
         *  Constant: '<S4110>/Constant3'
         *  Switch: '<S4463>/Switch1'
         *  Switch: '<S4464>/Switch1'
         *  Switch: '<S4465>/Switch1'
         */
        THMR_ac_B.Switch1_m = 15.0F;
    }
    else if (((((uint32)VeTHMR_e_CabThermalMode) ==
               CeTHMR_e_Cab_Cooling_n_Heating) && (((uint32)rtb_Switch1_o0g) ==
               CeTHMR_e_CabinActiveHeating)) && (((uint32)
               VeTHMR_b_CompressorReqOn_0_tmp) == CeTHMR_e_HeatPump))
    {
        /* Switch: '<S4467>/Switch1' incorporates:
         *  Constant: '<S4110>/Constant4'
         *  Switch: '<S4463>/Switch1'
         *  Switch: '<S4464>/Switch1'
         *  Switch: '<S4465>/Switch1'
         *  Switch: '<S4466>/Switch1'
         */
        THMR_ac_B.Switch1_m = 14.0F;
    }
    else if ((((((uint32)VeTHMR_e_CabThermalMode) == CeTHMR_e_Cab_Heating) &&
               (((uint32)rtb_Switch1_o0g) == CeTHMR_e_CabinActiveHeating)) &&
              (((uint32)VeTHMR_b_CompressorReqOn_0_tmp) == CeTHMR_e_HeatPump)) &&
             (((uint32)VeTHMR_e_BatThrmlSt_B4D) ==
              CeTHMR_e_BTLActvWasteHeatRcvry))
    {
        /* Switch: '<S4468>/Switch1' incorporates:
         *  Constant: '<S4110>/Constant5'
         *  Switch: '<S4463>/Switch1'
         *  Switch: '<S4464>/Switch1'
         *  Switch: '<S4465>/Switch1'
         *  Switch: '<S4466>/Switch1'
         *  Switch: '<S4467>/Switch1'
         */
        THMR_ac_B.Switch1_m = 11.0F;
    }
    else if (((((uint32)VeTHMR_e_CabThermalMode) == CeTHMR_e_Cab_Heating) &&
              (((uint32)rtb_Switch1_o0g) == CeTHMR_e_CabinActiveHeating)) &&
             (((uint32)VeTHMR_b_CompressorReqOn_0_tmp) == CeTHMR_e_HeatPump))
    {
        /* Switch: '<S4469>/Switch1' incorporates:
         *  Constant: '<S4110>/Constant6'
         *  Switch: '<S4463>/Switch1'
         *  Switch: '<S4464>/Switch1'
         *  Switch: '<S4465>/Switch1'
         *  Switch: '<S4466>/Switch1'
         *  Switch: '<S4467>/Switch1'
         *  Switch: '<S4468>/Switch1'
         */
        THMR_ac_B.Switch1_m = 10.0F;
    }
    else
    {
        /* Switch: '<S4463>/Switch1' incorporates:
         *  Constant: '<S4110>/Constant7'
         *  Switch: '<S4464>/Switch1'
         *  Switch: '<S4465>/Switch1'
         *  Switch: '<S4466>/Switch1'
         *  Switch: '<S4467>/Switch1'
         *  Switch: '<S4468>/Switch1'
         *  Switch: '<S4469>/Switch1'
         */
        THMR_ac_B.Switch1_m = 99.0F;
    }

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeTAIR_b_AC_CompElecPwr_FA' */
    (void)Rte_Read_VeTAIR_b_AC_CompElecPwr_FA_Value(&rtb_Switch1_cys);

    /* Inport: '<Root>/VeTAIR_P_AC_CompElecPwr' */
    (void)Rte_Read_VeTAIR_P_AC_CompElecPwr_Value(&rtb_UnitDelay15);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Switch: '<S4973>/Switch1' */
    if (rtb_Switch1_cys)
    {
        /* Switch: '<S4973>/Switch1' incorporates:
         *  Constant: '<S4973>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVeBTRR = 0.0F;
    }
    else
    {
        /* Switch: '<S4973>/Switch1' */
        rtb_TmpSignalConversionAtVeBTRR = rtb_UnitDelay15;
    }

    /* End of Switch: '<S4973>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S4973>/ProtectedDivision' */
    /* Switch: '<S4984>/Switch1' incorporates:
     *  Constant: '<S4984>/ConstantValue'
     *  Constant: '<S4984>/ConstantValue1'
     *  Constant: '<S4984>/ConstantValue2'
     *  Constant: '<S4984>/ConstantValue3'
     *  Logic: '<S4984>/AND'
     *  RelationalOperator: '<S4984>/GreaterThanorEqual'
     *  RelationalOperator: '<S4984>/GreaterThanorEqual1'
     *  RelationalOperator: '<S4984>/NotEqual'
     *  RelationalOperator: '<S4984>/NotEqual1'
     *  Switch: '<S4984>/Switch2'
     *  Switch: '<S4984>/Switch3'
     */
    if ((VeTHMR_P_WCondWasteHeat_Net != 0.0F) &&
            (rtb_TmpSignalConversionAtVeBTRR != 0.0F))
    {
        /* Switch: '<S4984>/Switch1' incorporates:
         *  Product: '<S4984>/Division'
         */
        rtb_TmpSignalConversionAtVeBTRR = VeTHMR_P_WCondWasteHeat_Net /
            rtb_TmpSignalConversionAtVeBTRR;
    }
    else if (VeTHMR_P_WCondWasteHeat_Net > 0.0F)
    {
        /* Switch: '<S4984>/Switch2' incorporates:
         *  Constant: '<S4984>/MAXFLOAT'
         *  Switch: '<S4984>/Switch1'
         */
        rtb_TmpSignalConversionAtVeBTRR = 3.402823466E+38F;
    }
    else if (VeTHMR_P_WCondWasteHeat_Net < 0.0F)
    {
        /* Switch: '<S4984>/Switch3' incorporates:
         *  Constant: '<S4984>/MINFLOAT'
         *  Switch: '<S4984>/Switch1'
         *  Switch: '<S4984>/Switch2'
         */
        rtb_TmpSignalConversionAtVeBTRR = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S4984>/Switch1' incorporates:
         *  Constant: '<S4984>/ConstantValue4'
         *  Switch: '<S4984>/Switch2'
         *  Switch: '<S4984>/Switch3'
         */
        rtb_TmpSignalConversionAtVeBTRR = 0.0F;
    }

    /* End of Switch: '<S4984>/Switch1' */
    /* End of Outputs for SubSystem: '<S4973>/ProtectedDivision' */

    /* Sum: '<S4985>/Sum3' */
    rtb_TmpSignalConversionAtVePMIR = TmpSignalConversionAtOutAirTemp -
        rtb_TmpSignalConversionAtVeTA_c;

    /* Outputs for Atomic SubSystem: '<S4985>/Hysteresis2' */
    /* Switch: '<S4990>/Switch1' incorporates:
     *  Constant: '<S4995>/Calib'
     *  RelationalOperator: '<S4990>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVePMIR > KeTHMR_T_AATRefDeltaDeicing_RSP)
    {
        /* Switch: '<S4990>/Switch1' incorporates:
         *  Constant: '<S4990>/ConstantValue'
         */
        rtb_Switch1_hj = true;
    }
    else
    {
        /* Switch: '<S4990>/Switch1' incorporates:
         *  Constant: '<S4994>/Calib'
         *  RelationalOperator: '<S4990>/GreaterThan1'
         *  UnitDelay: '<S4990>/UnitDelay'
         */
        rtb_Switch1_hj = ((rtb_TmpSignalConversionAtVePMIR >=
                           KeTHMR_T_AATRefDeltaDeicing_LSP) &&
                          (THMR_ac_DW.UnitDelay_DSTATE_gp));
    }

    /* End of Switch: '<S4990>/Switch1' */

    /* Update for UnitDelay: '<S4990>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_gp = rtb_Switch1_hj;

    /* End of Outputs for SubSystem: '<S4985>/Hysteresis2' */

    /* Sum: '<S4985>/Sum4' incorporates:
     *  Constant: '<S4991>/Calib'
     */
    rtb_TmpSignalConversionAtVeBTRR = KeTHMR_K_COPNominalHP -
        rtb_TmpSignalConversionAtVeBTRR;

    /* Outputs for Atomic SubSystem: '<S4985>/Hysteresis1' */
    /* Switch: '<S4989>/Switch1' incorporates:
     *  Constant: '<S4993>/Calib'
     *  RelationalOperator: '<S4989>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVeBTRR > KeTHMR_K_CritCOPDeltaDeIcing_RSP)
    {
        /* Switch: '<S4989>/Switch1' incorporates:
         *  Constant: '<S4989>/ConstantValue'
         */
        rtb_Switch1_cys = true;
    }
    else
    {
        /* Switch: '<S4989>/Switch1' incorporates:
         *  Constant: '<S4992>/Calib'
         *  RelationalOperator: '<S4989>/GreaterThan1'
         *  UnitDelay: '<S4989>/UnitDelay'
         */
        rtb_Switch1_cys = ((rtb_TmpSignalConversionAtVeBTRR >=
                            KeTHMR_K_CritCOPDeltaDeIcing_LSP) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_ny));
    }

    /* End of Switch: '<S4989>/Switch1' */

    /* Update for UnitDelay: '<S4989>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ny = rtb_Switch1_cys;

    /* End of Outputs for SubSystem: '<S4985>/Hysteresis1' */

    /* Switch: '<S4985>/Switch1' incorporates:
     *  Constant: '<S4998>/Calib'
     *  Logic: '<S4985>/Logical10'
     *  Logic: '<S4985>/Logical8'
     */
    if (KeTHMR_b_DeIcngANDORStrtgySelect)
    {
        rtb_AND_fe = (rtb_Switch1_hj && rtb_Switch1_cys);
    }
    else
    {
        rtb_AND_fe = (rtb_Switch1_hj || rtb_Switch1_cys);
    }

    /* End of Switch: '<S4985>/Switch1' */

    /* Logic: '<S4985>/Logical1' incorporates:
     *  Constant: '<S4983>/Constant'
     *  Constant: '<S4996>/Calib'
     *  Logic: '<S4973>/LogicalOperator'
     *  RelationalOperator: '<S4973>/Comparison9'
     *  RelationalOperator: '<S4985>/Comparison'
     *  UnitDelay: '<S4118>/UnitDelay2'
     */
    VeTHMR_b_IceDetectedOHX = ((((((uint32)THMR_ac_DW.UnitDelay2_DSTATE_jz) ==
        CeTHMR_e_HeatPump) && (VeTHMR_b_CabHeatPumpAllowOhx)) &&
        (rtb_TmpSignalConversionAtVeTA_c < KeTHMR_T_RefTDeIcingEnable)) &&
        rtb_AND_fe);

    /* Outputs for Atomic SubSystem: '<S4985>/SignalLatchOnWithReset' */
    /* Logic: '<S5000>/OR1' incorporates:
     *  Logic: '<S5000>/NOT'
     *  Logic: '<S5000>/OR'
     *  UnitDelay: '<S4985>/UnitDelay2'
     *  UnitDelay: '<S5000>/UnitDelay'
     */
    VeTHMR_b_DeIceDurationOn = ((VeTHMR_b_IceDetectedOHX) ||
        ((!THMR_ac_DW.UnitDelay2_DSTATE_hk) && (THMR_ac_DW.UnitDelay_DSTATE_er)));

    /* Update for UnitDelay: '<S5000>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_er = VeTHMR_b_DeIceDurationOn;

    /* End of Outputs for SubSystem: '<S4985>/SignalLatchOnWithReset' */

    /* Logic: '<S4985>/Logical4' incorporates:
     *  Constant: '<S4997>/Calib'
     */
    VeTHMR_b_DeIceStarted = ((VeTHMR_b_DeIceDurationOn) ||
        (KeTHMR_b_DeIcingStartOverrid));

    /* Outputs for Atomic SubSystem: '<S4985>/EdgeRising1' */
    /* Logic: '<S4988>/AND' incorporates:
     *  Logic: '<S4988>/OR1'
     *  UnitDelay: '<S4988>/UnitDelay'
     */
    rtb_Switch1_hj = !THMR_ac_DW.UnitDelay_DSTATE_gwz;

    /* Update for UnitDelay: '<S4988>/UnitDelay' incorporates:
     *  Constant: '<S4985>/TRUEConstant2'
     */
    THMR_ac_DW.UnitDelay_DSTATE_gwz = true;

    /* End of Outputs for SubSystem: '<S4985>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S4985>/CountDownResetEnabled2' */
    /* Switch: '<S4987>/Switch1' incorporates:
     *  Constant: '<S4987>/ConstantValue'
     *  Logic: '<S4985>/Logical'
     *  Logic: '<S4985>/Logical5'
     *  Logic: '<S4987>/AND'
     *  RelationalOperator: '<S4987>/GreaterThan'
     *  Switch: '<S4987>/Switch2'
     *  UnitDelay: '<S4985>/UnitDelay3'
     *  UnitDelay: '<S4987>/UnitDelay'
     */
    if ((rtb_Switch1_btw && (THMR_ac_DW.UnitDelay3_DSTATE_pz)) || rtb_Switch1_hj)
    {
        /* Switch: '<S4987>/Switch1' incorporates:
         *  Constant: '<S4999>/Calib'
         */
        rtb_TmpSignalConversionAtVeTA_c = KeTHMR_t_oHXDeIceDuration;
    }
    else if ((VeTHMR_b_DeIceStarted) && (THMR_ac_DW.UnitDelay_DSTATE_e5h > 0.0F))
    {
        /* Switch: '<S4987>/Switch2' incorporates:
         *  Constant: '<S4987>/ConstantValue1'
         *  Sum: '<S4987>/Subtraction'
         *  Switch: '<S4987>/Switch1'
         *  UnitDelay: '<S4987>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeTA_c = THMR_ac_DW.UnitDelay_DSTATE_e5h - 1.0F;
    }
    else
    {
        /* Switch: '<S4987>/Switch1' incorporates:
         *  Switch: '<S4987>/Switch2'
         *  UnitDelay: '<S4987>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeTA_c = THMR_ac_DW.UnitDelay_DSTATE_e5h;
    }

    /* End of Switch: '<S4987>/Switch1' */

    /* Update for UnitDelay: '<S4987>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_e5h = rtb_TmpSignalConversionAtVeTA_c;

    /* Logic: '<S4985>/Logical9' incorporates:
     *  Constant: '<S4987>/ConstantValue2'
     *  RelationalOperator: '<S4987>/GreaterThan1'
     */
    VeTHMR_b_DeIcingCmplt = (rtb_TmpSignalConversionAtVeTA_c <= 0.0F);

    /* End of Outputs for SubSystem: '<S4985>/CountDownResetEnabled2' */

    /* Switch: '<S5122>/Switch6' incorporates:
     *  Constant: '<S5158>/Constant'
     *  Constant: '<S5166>/Constant'
     *  Constant: '<S5167>/Constant'
     *  Constant: '<S5168>/Calib'
     *  Inport: '<Root>/VeBTRR_b_PlugdIn_Or_Chrg'
     *  Logic: '<S5159>/LogicalOperator'
     *  Logic: '<S5159>/LogicalOperator1'
     *  RelationalOperator: '<S4116>/RelationalOperator'
     *  RelationalOperator: '<S5122>/Comparison4'
     *  RelationalOperator: '<S5159>/RelationalOperator'
     *  RelationalOperator: '<S5159>/RelationalOperator1'
     *  SignalConversion generated from: '<S2>/VeRCVR_e_CPV_Valve_Stuck_State'
     *  Switch: '<S5122>/Switch1'
     */
    if (((uint32)rtb_LogicalOperator_gg_tmp) == CeTHMR_e_PassiveCooling)
    {
        /* Switch: '<S5122>/Switch13' incorporates:
         *  Constant: '<S5165>/Calib'
         *  Logic: '<S5157>/LogicalOperator'
         */
        if ((KeTHMR_b_SelectNewTempTgt_PsvRA) &&
                (VeTHMR_b_BattCoolFlts_AllowRA_PsvCooling))
        {
            /* Switch: '<S5122>/Switch6' incorporates:
             *  Constant: '<S5164>/Calib'
             */
            VeTHMR_T_PPCTISTgt_Fan = KeTHMR_T_PsvPmpClnt_TempTgt_PsvCool_RA;
        }
        else
        {
            /* Switch: '<S5122>/Switch6' incorporates:
             *  Constant: '<S5163>/Calib'
             */
            VeTHMR_T_PPCTISTgt_Fan = KeTHMR_T_PsvPmpClnt_TempTgt_PsvCool;
        }

        /* End of Switch: '<S5122>/Switch13' */
    }
    else if (((CeRCVR_e_SNA == ((uint32)rtb_TmpSignalConversionAtVeRC_k)) ||
              (((uint32)rtb_TmpSignalConversionAtVeRC_k) == CeRCVR_e_Faulty_Open))
             && (KeTHMR_b_Enbl_BattCPV_Vlv_Open_SNA))
    {
        /* Switch: '<S5122>/Switch6' incorporates:
         *  Constant: '<S5161>/Calib'
         *  Switch: '<S5122>/Switch1'
         */
        VeTHMR_T_PPCTISTgt_Fan = KeTHMR_T_PmpClnt_In_TempTgt_BattCPVFault;
    }
    else
    {
        (void)Rte_Read_VeBTRR_b_PlugdIn_Or_Chrg_Value(&rtb_Switch1_p1);

        /* Switch: '<S5122>/Switch5' incorporates:
         *  Inport: '<Root>/VeBTRR_b_PlugdIn_Or_Chrg'
         *  Switch: '<S5122>/Switch1'
         */
        if (rtb_Switch1_p1)
        {
            /* Switch: '<S5122>/Switch6' incorporates:
             *  Constant: '<S5162>/Calib'
             *  Switch: '<S5122>/Switch1'
             */
            VeTHMR_T_PPCTISTgt_Fan = KeTHMR_T_PsvPmpClnt_TempTgt_PlgdIn_or_Chrg;
        }
        else
        {
            /* Switch: '<S5122>/Switch6' incorporates:
             *  Constant: '<S5160>/Calib'
             *  Switch: '<S5122>/Switch1'
             */
            VeTHMR_T_PPCTISTgt_Fan = KeTHMR_T_PmpClnt_In_TempTgt;
        }

        /* End of Switch: '<S5122>/Switch5' */
    }

    /* End of Switch: '<S5122>/Switch6' */

    /* Outputs for Atomic SubSystem: '<S5124>/Hysteresis1' */
    /* Switch: '<S5179>/Switch1' incorporates:
     *  Constant: '<S5124>/Constant2'
     *  RelationalOperator: '<S5179>/GreaterThan'
     */
    if (THMR_ac_B.Add > 0.0F)
    {
        /* Switch: '<S5179>/Switch1' incorporates:
         *  Constant: '<S5179>/ConstantValue'
         */
        rtb_Switch1_p1 = true;
    }
    else
    {
        /* Switch: '<S5179>/Switch1' incorporates:
         *  Constant: '<S5180>/Calib'
         *  RelationalOperator: '<S5179>/GreaterThan1'
         *  UnitDelay: '<S5179>/UnitDelay'
         */
        rtb_Switch1_p1 = ((THMR_ac_B.Add >= KeTHMR_dT_LTRVlvClosedHys) &&
                          (THMR_ac_DW.UnitDelay_DSTATE_kie));
    }

    /* End of Switch: '<S5179>/Switch1' */

    /* Update for UnitDelay: '<S5179>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kie = rtb_Switch1_p1;

    /* End of Outputs for SubSystem: '<S5124>/Hysteresis1' */

    /* Outputs for Atomic SubSystem: '<S5126>/Hysteresis1' */
    /* Switch: '<S5183>/Switch1' incorporates:
     *  Constant: '<S5126>/Constant2'
     *  RelationalOperator: '<S5183>/GreaterThan'
     */
    if (THMR_ac_B.Add > 0.0F)
    {
        /* Switch: '<S5183>/Switch1' incorporates:
         *  Constant: '<S5183>/ConstantValue'
         */
        rtb_Switch1_hj = true;
    }
    else
    {
        /* Switch: '<S5183>/Switch1' incorporates:
         *  Constant: '<S5184>/Calib'
         *  RelationalOperator: '<S5183>/GreaterThan1'
         *  UnitDelay: '<S5183>/UnitDelay'
         */
        rtb_Switch1_hj = ((THMR_ac_B.Add >= KeTHMR_dT_LTRVlvClosedHys) &&
                          (THMR_ac_DW.UnitDelay_DSTATE_jm));
    }

    /* End of Switch: '<S5183>/Switch1' */

    /* Update for UnitDelay: '<S5183>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_jm = rtb_Switch1_hj;

    /* End of Outputs for SubSystem: '<S5126>/Hysteresis1' */

    /* Outputs for Atomic SubSystem: '<S5131>/Hysteresis2' */
    /* Switch: '<S5194>/Switch1' incorporates:
     *  RelationalOperator: '<S5194>/GreaterThan'
     */
    if (VeTHMR_T_LTRInletTemp > VeTHMR_T_PPCTISTgt_Fan)
    {
        /* Switch: '<S5194>/Switch1' incorporates:
         *  Constant: '<S5194>/ConstantValue'
         */
        rtb_Switch1_cys = true;
    }
    else
    {
        /* Switch: '<S5194>/Switch1' incorporates:
         *  Constant: '<S5198>/Calib'
         *  RelationalOperator: '<S5194>/GreaterThan1'
         *  Sum: '<S5131>/Add'
         *  UnitDelay: '<S5194>/UnitDelay'
         */
        rtb_Switch1_cys = ((VeTHMR_T_LTRInletTemp >= (KeTHMR_dT_LTRVlvOpenHys +
                             VeTHMR_T_PPCTISTgt_Fan)) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_koq));
    }

    /* End of Switch: '<S5194>/Switch1' */

    /* Update for UnitDelay: '<S5194>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_koq = rtb_Switch1_cys;

    /* End of Outputs for SubSystem: '<S5131>/Hysteresis2' */

    /* Outputs for Atomic SubSystem: '<S5132>/Hysteresis6' */
    /* Switch: '<S5199>/Switch1' incorporates:
     *  Constant: '<S5132>/Constant2'
     *  RelationalOperator: '<S5199>/GreaterThan'
     */
    if (THMR_ac_B.Add > 0.0F)
    {
        /* Switch: '<S5199>/Switch1' incorporates:
         *  Constant: '<S5199>/ConstantValue'
         */
        rtb_TmpSignalConversionAtVePMTR = true;
    }
    else
    {
        /* Switch: '<S5199>/Switch1' incorporates:
         *  Constant: '<S5200>/Calib'
         *  RelationalOperator: '<S5199>/GreaterThan1'
         *  UnitDelay: '<S5199>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVePMTR = ((THMR_ac_B.Add >=
            KeTHMR_dT_LTRVlvClosedHys) && (THMR_ac_DW.UnitDelay_DSTATE_bbw));
    }

    /* End of Switch: '<S5199>/Switch1' */

    /* Update for UnitDelay: '<S5199>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_bbw = rtb_TmpSignalConversionAtVePMTR;

    /* End of Outputs for SubSystem: '<S5132>/Hysteresis6' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* If: '<S4575>/If2' incorporates:
     *  Constant: '<S5193>/Constant'
     *  Constant: '<S5195>/Calib'
     *  Constant: '<S5196>/Calib'
     *  Constant: '<S5197>/Calib'
     *  Inport: '<S2741>/In1'
     *  Logic: '<S4571>/LogicalOperator'
     *  Logic: '<S4575>/LogicalOperator'
     *  Logic: '<S5124>/LogicalOperator'
     *  Logic: '<S5124>/LogicalOperator1'
     *  Logic: '<S5126>/LogicalOperator'
     *  Logic: '<S5126>/LogicalOperator1'
     *  Logic: '<S5131>/Logical1'
     *  Logic: '<S5131>/Logical11'
     *  Logic: '<S5131>/Logical2'
     *  Logic: '<S5131>/Logical3'
     *  Logic: '<S5131>/Logical4'
     *  Logic: '<S5131>/Logical5'
     *  Logic: '<S5131>/LogicalOperator'
     *  Logic: '<S5132>/LogicalOperator'
     *  RelationalOperator: '<S2928>/Relational Operator6'
     *  RelationalOperator: '<S5131>/RelationalOperator1'
     *  RelationalOperator: '<S5131>/RelationalOperator2'
     *  RelationalOperator: '<S5131>/RelationalOperator3'
     */
    if ((rtb_Switch1_cys || (((((uint32)VeTHMR_e_EmrgcyFanRq_Lvl_B4D) !=
                               CeTHMR_e_No_EmrgcyFanRq) || (rtb_Sum_e >=
            KeTHMR_Pct_LTCLPsvCool_AHHNrmlzdAF)) &&
                             ((!THMR_ac_B.VariantMerge_Fo_at) ||
                              (rtb_TmpSignalConversionAtVeTR_k &&
                               (rtb_TmpSignalConversionAtVeBT_f ||
                                (!KeTHMR_b_EnblBattHeatChck4LTRbypassInER)))))) ||
        (VeTHMR_Pct_Normlzd_Aftrrun >= KeTHMR_Pct_LTCLPsvCool_AftrRunNrmlzdAF))
    {
        /* Outputs for IfAction SubSystem: '<S4575>/LTCLCooling' incorporates:
         *  ActionPort: '<S5257>/ActionPort'
         */
        /* Merge: '<S4575>/Merge' incorporates:
         *  Constant: '<S5265>/Constant'
         *  SignalConversion generated from: '<S5257>/LTCLValveState'
         */
        THMR_ac_B.VeTHMR_e_LTCLRadVlvState = CeTHMR_e_PsvCooling_LTCLVlvSt;

        /* Merge: '<S4575>/Merge1' incorporates:
         *  Constant: '<S5264>/Constant'
         *  SignalConversion generated from: '<S5257>/LTCL_Mode'
         */
        THMR_ac_B.VeTHMR_e_LTCLThrmlMode = CeTHMR_e_LTCLPassiveCooling;

        /* End of Outputs for SubSystem: '<S4575>/LTCLCooling' */
    }
    else if (rtb_VariantMerge_For_Variant__m && rtb_TmpSignalConversionAtVeTM_o)
    {
        /* Outputs for IfAction SubSystem: '<S4575>/LTCLActvPsvHeating' incorporates:
         *  ActionPort: '<S5256>/ActionPort'
         */
        /* Merge: '<S4575>/Merge' incorporates:
         *  Constant: '<S5263>/Constant'
         *  SignalConversion generated from: '<S5256>/LTCLValveState'
         */
        THMR_ac_B.VeTHMR_e_LTCLRadVlvState = CeTHMR_e_PsvHeating_LTCLVlvSt;

        /* Merge: '<S4575>/Merge1' incorporates:
         *  Constant: '<S5262>/Constant'
         *  SignalConversion generated from: '<S5256>/LTCLMode'
         */
        THMR_ac_B.VeTHMR_e_LTCLThrmlMode = CeTHMR_e_LTCLActvPsvHeating;

        /* End of Outputs for SubSystem: '<S4575>/LTCLActvPsvHeating' */
    }
    else if (VeTHMR_b_LTCLActvWstHeatRcvry_Arb)
    {
        /* Outputs for IfAction SubSystem: '<S4575>/LTCLWasteRecovery' incorporates:
         *  ActionPort: '<S5259>/ActionPort'
         */
        /* Merge: '<S4575>/Merge' incorporates:
         *  Constant: '<S5269>/Constant'
         *  SignalConversion generated from: '<S5259>/LTCLValveState'
         */
        THMR_ac_B.VeTHMR_e_LTCLRadVlvState = CeTHMR_e_Blocked_LTCLVlvSt;

        /* Merge: '<S4575>/Merge1' incorporates:
         *  Constant: '<S5268>/Constant'
         *  SignalConversion generated from: '<S5259>/LTCL_Mode'
         */
        THMR_ac_B.VeTHMR_e_LTCLThrmlMode = CeTHMR_e_LTCLActvWasteHeatRcvry;

        /* End of Outputs for SubSystem: '<S4575>/LTCLWasteRecovery' */
    }
    else if ((rtb_Switch_az2 && (!rtb_Switch1_p1)) ||
             (rtb_TmpSignalConversionAtVeBT_p && (!rtb_Switch1_hj)))
    {
        /* Outputs for IfAction SubSystem: '<S4575>/LTCLHeating' incorporates:
         *  ActionPort: '<S5258>/ActionPort'
         */
        /* Merge: '<S4575>/Merge' incorporates:
         *  Constant: '<S5267>/Constant'
         *  SignalConversion generated from: '<S5258>/LTCLValveState'
         */
        THMR_ac_B.VeTHMR_e_LTCLRadVlvState = CeTHMR_e_PsvHeating_LTCLVlvSt;

        /* Merge: '<S4575>/Merge1' incorporates:
         *  Constant: '<S5266>/Constant'
         *  SignalConversion generated from: '<S5258>/LTCLMode'
         */
        THMR_ac_B.VeTHMR_e_LTCLThrmlMode = CeTHMR_e_LTCLPassiveCooling;

        /* End of Outputs for SubSystem: '<S4575>/LTCLHeating' */
    }
    else if (!rtb_TmpSignalConversionAtVePMTR)
    {
        /* Outputs for IfAction SubSystem: '<S4575>/LTCL_AccumulateHeat' incorporates:
         *  ActionPort: '<S5260>/ActionPort'
         */
        /* Merge: '<S4575>/Merge' incorporates:
         *  Constant: '<S5271>/Constant'
         *  SignalConversion generated from: '<S5260>/LTCLValveState'
         */
        THMR_ac_B.VeTHMR_e_LTCLRadVlvState = CeTHMR_e_PsvHeating_LTCLVlvSt;

        /* Merge: '<S4575>/Merge1' incorporates:
         *  Constant: '<S5270>/Constant'
         *  SignalConversion generated from: '<S5260>/LTCLMode'
         */
        THMR_ac_B.VeTHMR_e_LTCLThrmlMode = CeTHMR_e_LTCLPassiveHeating;

        /* End of Outputs for SubSystem: '<S4575>/LTCL_AccumulateHeat' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S4575>/LTCL_Balancing_PI' incorporates:
         *  ActionPort: '<S5261>/ActionPort'
         */
        /* Merge: '<S4575>/Merge' incorporates:
         *  Constant: '<S5273>/Constant'
         *  SignalConversion generated from: '<S5261>/LTCLValveState'
         */
        THMR_ac_B.VeTHMR_e_LTCLRadVlvState = CeTHMR_e_Balancing_LTCLVlvSt;

        /* Merge: '<S4575>/Merge1' incorporates:
         *  Constant: '<S5272>/Constant'
         *  SignalConversion generated from: '<S5261>/LTCL_Mode'
         */
        THMR_ac_B.VeTHMR_e_LTCLThrmlMode = CeTHMR_e_LTCLBalancing;

        /* End of Outputs for SubSystem: '<S4575>/LTCL_Balancing_PI' */
    }

    /* End of If: '<S4575>/If2' */

    /* SignalConversion generated from: '<S4114>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FlashingFlagDsblMsg10

    /* VariantMerge generated from: '<S4114>/VariantSource' */
    rtb_VariantMerge_For_Variant__p = VeTHMR_b_Flashing_Flag_AD;

#else

    /* VariantMerge generated from: '<S4114>/VariantSource' incorporates:
     *  Constant: '<S4114>/Constant'
     *  SignalConversion generated from: '<S4114>/VariantSource'
     */
    rtb_VariantMerge_For_Variant__p = false;

#endif

    /* End of SignalConversion generated from: '<S4114>/VariantSource' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeFSCR_b_HVFuncRejHdAjar' */
    (void)Rte_Read_VeFSCR_b_HVFuncRejHdAjar_Value(&tmpRead_17);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Update for UnitDelay: '<S4335>/UnitDelay1' incorporates:
     *  Switch: '<S4586>/Switch1'
     */
    THMR_ac_DW.UnitDelay1_DSTATE_ncb = VeTHMR_e_BatThrmlSt_B4D;

    /* Update for UnitDelay: '<S4545>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_or = VeTHMR_b_ESSR_EngOff;

    /* Update for UnitDelay: '<S4108>/UnitDelay' incorporates:
     *  Switch: '<S3945>/Switch'
     */
    THMR_ac_DW.UnitDelay_DSTATE_hp4 = VeTHMR_e_SSDR_KeySts;

    /* Update for UnitDelay: '<S4486>/UnitDelay2' incorporates:
     *  Switch: '<S4586>/Switch1'
     */
    THMR_ac_DW.UnitDelay2_DSTATE_gc = VeTHMR_e_BatThrmlSt_B4D;

    /* Update for UnitDelay: '<S4568>/UnitDelay' incorporates:
     *  UnitDelay: '<S4118>/UnitDelay3'
     */
    THMR_ac_DW.UnitDelay_DSTATE_jph = THMR_ac_DW.UnitDelay3_DSTATE_j3;

    /* Update for Delay: '<S4736>/Delay' */
    THMR_ac_DW.Delay_DSTATE_p = VeTHMR_b_BattCondNew_BS;

    /* Update for UnitDelay: '<S4118>/UnitDelay5' incorporates:
     *  Merge: '<S4573>/Merge2'
     */
    THMR_ac_DW.UnitDelay5_DSTATE_k = THMR_ac_B.VeTHMR_e_FCThrmlState;

    /* Update for UnitDelay: '<S4627>/UnitDelay1' incorporates:
     *  UnitDelay: '<S4118>/UnitDelay4'
     */
    THMR_ac_DW.UnitDelay1_DSTATE_iu = THMR_ac_DW.UnitDelay4_DSTATE_j;

    /* Update for UnitDelay: '<S4118>/UnitDelay1' incorporates:
     *  Merge: '<S4575>/Merge'
     */
    THMR_ac_DW.UnitDelay1_DSTATE_kb = THMR_ac_B.VeTHMR_e_LTCLRadVlvState;

    /* Update for UnitDelay: '<S4598>/UnitDelay1' incorporates:
     *  UnitDelay: '<S4118>/UnitDelay4'
     */
    THMR_ac_DW.UnitDelay1_DSTATE_kf = THMR_ac_DW.UnitDelay4_DSTATE_j;

    /* Update for UnitDelay: '<S4709>/FixPt Unit Delay2' incorporates:
     *  Constant: '<S4709>/FixPt Constant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_l = 0U;

    /* Update for UnitDelay: '<S4709>/FixPt Unit Delay1' incorporates:
     *  UnitDelay: '<S4118>/UnitDelay4'
     */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE_do = THMR_ac_DW.UnitDelay4_DSTATE_j;

    /* Update for UnitDelay: '<S4569>/UnitDelay1' incorporates:
     *  UnitDelay: '<S4118>/UnitDelay3'
     */
    THMR_ac_DW.UnitDelay1_DSTATE_au = THMR_ac_DW.UnitDelay3_DSTATE_j3;

    /* Update for UnitDelay: '<S4985>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_ii = VeTHMR_b_DeIceStarted;

    /* Update for UnitDelay: '<S4118>/UnitDelay6' incorporates:
     *  Merge: '<S4570>/Merge2'
     */
    THMR_ac_DW.UnitDelay6_DSTATE_n = VeTHMR_e_CabCoolThermalState;

    /* Update for UnitDelay: '<S5135>/UnitDelay1' incorporates:
     *  UnitDelay: '<S4118>/UnitDelay3'
     */
    THMR_ac_DW.UnitDelay1_DSTATE_je = THMR_ac_DW.UnitDelay3_DSTATE_j3;

    /* Update for UnitDelay: '<S4118>/UnitDelay3' incorporates:
     *  Switch: '<S4586>/Switch1'
     */
    THMR_ac_DW.UnitDelay3_DSTATE_j3 = VeTHMR_e_BatThrmlSt_B4D;

    /* Update for UnitDelay: '<S4118>/UnitDelay4' incorporates:
     *  Merge: '<S4570>/Merge1'
     */
    THMR_ac_DW.UnitDelay4_DSTATE_j = THMR_ac_B.VeTHMR_e_CabHeatThermalState;

    /* Update for UnitDelay: '<S4118>/UnitDelay7' incorporates:
     *  Merge: '<S4575>/Merge1'
     */
    THMR_ac_DW.UnitDelay7_DSTATE_f = THMR_ac_B.VeTHMR_e_LTCLThrmlMode;

    /* Update for UnitDelay: '<S4118>/UnitDelay2' incorporates:
     *  Merge: '<S4570>/Merge3'
     */
    THMR_ac_DW.UnitDelay2_DSTATE_jz = THMR_ac_B.VeTHMR_e_CabHeatThermalMode;

    /* Update for UnitDelay: '<S4985>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_hk = VeTHMR_b_DeIcingCmplt;

    /* Update for UnitDelay: '<S4985>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_pz = VeTHMR_b_DeIcingCmplt;

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Miscellaneous_Outputs'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Clnt_Pmp_State_Determination'
     */
    /* RelationalOperator: '<S51>/Comparison27' incorporates:
     *  DataTypeConversion: '<S3621>/DataTypeConversion'
     *  RelationalOperator: '<S51>/Comparison28'
     *  Switch: '<S3347>/Switch2'
     */
    rtb_RelationalOperator_kg_tmp = VeTHMR_e_HCP_LTP_FanAftRun_Rq_BD_SF;

    /* Logic: '<S51>/Logical8' incorporates:
     *  Constant: '<S608>/Constant'
     *  Constant: '<S609>/Constant'
     *  Constant: '<S636>/Calib'
     *  DataTypeConversion: '<S3621>/DataTypeConversion'
     *  RelationalOperator: '<S51>/Comparison27'
     *  RelationalOperator: '<S51>/Comparison28'
     */
    rtb_Switch1_p1 = (((((uint32)VeTHMR_e_HCP_LTP_FanAftRun_Rq_BD_SF) !=
                        CeTMIR_e_No_AftRunRequest) && (((uint32)
                         VeTHMR_e_HCP_LTP_FanAftRun_Rq_BD_SF) !=
                        CeTMIR_e_SNA_AftRunRequest)) &&
                      (KeTHMR_b_AftrRunStateOvrdEnbl));

    /* Switch: '<S618>/Switch1' incorporates:
     *  Constant: '<S637>/Calib'
     */
    if (rtb_Switch1_p1)
    {
        rtb_TmpSignalConversionAtVeTA_n = KeTHMR_dV_LTP_AftrRunPmpFlowFrPmpState;
    }
    else
    {
        rtb_TmpSignalConversionAtVeTA_n = rtb_Switch1_muc;
    }

    /* End of Switch: '<S618>/Switch1' */

    /* RelationalOperator: '<S51>/Comparison1' incorporates:
     *  Constant: '<S51>/ConstantValue3'
     */
    THMR_ac_B.Comparison1 = (rtb_TmpSignalConversionAtVeTA_n > 0.0F);

    /* Switch: '<S627>/Switch1' incorporates:
     *  Constant: '<S637>/Calib'
     */
    if (rtb_Switch1_p1)
    {
        rtb_TmpSignalConversionAtVeTA_n = KeTHMR_dV_LTP_AftrRunPmpFlowFrPmpState;
    }
    else
    {
        rtb_TmpSignalConversionAtVeTA_n = rtb_Switch1_pm;
    }

    /* End of Switch: '<S627>/Switch1' */

    /* RelationalOperator: '<S51>/Comparison69' incorporates:
     *  Constant: '<S51>/ConstantValue4'
     */
    THMR_ac_B.Comparison69 = (rtb_TmpSignalConversionAtVeTA_n > 0.0F);

    /* RelationalOperator: '<S51>/Comparison3' incorporates:
     *  Constant: '<S51>/ConstantValue2'
     */
    THMR_ac_B.Comparison3 = (VeTHMR_dV_HT_AuxPmpFlw_B4D > 0.0F);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* RelationalOperator: '<S51>/Comparison2' incorporates:
     *  Constant: '<S51>/ConstantValue1'
     *  Gain: '<S1171>/Gain'
     */
    THMR_ac_B.Comparison2 = (rtb_TmpSignalConversionAtVeTPDR > 0.0F);

    /* Switch: '<S648>/Switch1' incorporates:
     *  Constant: '<S653>/Calib'
     */
    if (KeTHMR_b_LTPsvPump2_Slct)
    {
        /* Switch: '<S648>/Switch1' incorporates:
         *  Constant: '<S654>/Calib'
         *  S-Function (sfix_bitop): '<S644>/FixPt Bitwise Operator1'
         *  Switch: '<S647>/Switch1'
         */
        rtb_TmpSignalConversionAtVePRXR = (uint8)((KeTHMR_b_LTPsvPump_Slct ?
            ((uint8)1) : ((uint8)0)) | ((uint8)2));
    }
    else
    {
        /* Switch: '<S648>/Switch1' incorporates:
         *  Constant: '<S654>/Calib'
         *  S-Function (sfix_bitop): '<S640>/FixPt Bitwise Operator3'
         *  S-Function (sfix_bitop): '<S640>/FixPt Bitwise Operator4'
         *  S-Function (sfix_bitop): '<S640>/FixPt Bitwise Operator5'
         *  Switch: '<S647>/Switch1'
         */
        rtb_TmpSignalConversionAtVePRXR = (uint8)(~((uint8)(((uint8)(~((uint8)
            (KeTHMR_b_LTPsvPump_Slct ? ((uint8)1) : ((uint8)0))))) | ((uint8)2))));
    }

    /* End of Switch: '<S648>/Switch1' */

    /* Switch: '<S649>/Switch1' incorporates:
     *  Constant: '<S652>/Calib'
     */
    if (KeTHMR_b_LTActPump_Slct)
    {
        /* Switch: '<S649>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S645>/FixPt Bitwise Operator1'
         */
        rtb_TmpSignalConversionAtVePRXR |= (uint8)4;
    }
    else
    {
        /* Switch: '<S649>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S641>/FixPt Bitwise Operator3'
         *  S-Function (sfix_bitop): '<S641>/FixPt Bitwise Operator4'
         *  S-Function (sfix_bitop): '<S641>/FixPt Bitwise Operator5'
         */
        rtb_TmpSignalConversionAtVePRXR = (uint8)(~((uint8)(((uint8)
            (~rtb_TmpSignalConversionAtVePRXR)) | ((uint8)4))));
    }

    /* End of Switch: '<S649>/Switch1' */

    /* Switch: '<S650>/Switch1' incorporates:
     *  Constant: '<S651>/Calib'
     */
    if (KeTHMR_b_HTAuxPump_Slct)
    {
        /* Switch: '<S650>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S646>/FixPt Bitwise Operator1'
         */
        rtb_TmpSignalConversionAtVePRXR |= (uint8)8;
    }
    else
    {
        /* Switch: '<S650>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S642>/FixPt Bitwise Operator3'
         *  S-Function (sfix_bitop): '<S642>/FixPt Bitwise Operator4'
         *  S-Function (sfix_bitop): '<S642>/FixPt Bitwise Operator5'
         */
        rtb_TmpSignalConversionAtVePRXR = (uint8)(~((uint8)(((uint8)
            (~rtb_TmpSignalConversionAtVePRXR)) | ((uint8)8))));
    }

    /* End of Switch: '<S650>/Switch1' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    /* Outputs for Function Call SubSystem: '<S2>/ClntProp3wayValves_State' */
    /* RelationalOperator: '<S567>/Comparison5' */
    rtb_AND_fe = !THMR_ac_B.OutportBufferForOut3;

    /* RelationalOperator: '<S567>/Comparison1' */
    rtb_TmpSignalConversionAtVePD_i = !THMR_ac_B.OutportBufferForOut4;

    /* RelationalOperator: '<S567>/Comparison' */
    rtb_TmpSignalConversionAtVePD_p = !rtb_VariantMerge_For_Variant_ik;

    /* Logic: '<S567>/Logical' incorporates:
     *  Logic: '<S571>/Logical'
     *  Switch: '<S559>/Switch1'
     *  Switch: '<S560>/Switch1'
     *  Switch: '<S561>/Switch1'
     *  Switch: '<S562>/Switch1'
     */
    rtb_AND_de = (rtb_TmpSignalConversionAtVePD_p && rtb_AND_fe);

    /* Switch: '<S559>/Switch1' incorporates:
     *  Logic: '<S567>/Logical'
     */
    if (rtb_AND_de && rtb_TmpSignalConversionAtVePD_i)
    {
        /* Switch: '<S559>/Switch1' incorporates:
         *  Constant: '<S550>/Constant'
         */
        THMR_ac_B.Switch1_jj = CeTHMR_e_NoVlvPwrd;
    }
    else
    {
        /* Logic: '<S568>/Logical' incorporates:
         *  Logic: '<S572>/Logical'
         *  RelationalOperator: '<S568>/Comparison'
         *  Switch: '<S560>/Switch1'
         *  Switch: '<S561>/Switch1'
         *  Switch: '<S562>/Switch1'
         *  Switch: '<S563>/Switch1'
         */
        rtb_AND_fe = (rtb_VariantMerge_For_Variant_ik && rtb_AND_fe);

        /* Switch: '<S560>/Switch1' incorporates:
         *  Logic: '<S568>/Logical'
         */
        if (rtb_AND_fe && rtb_TmpSignalConversionAtVePD_i)
        {
            /* Switch: '<S559>/Switch1' incorporates:
             *  Constant: '<S551>/Constant'
             *  Switch: '<S560>/Switch1'
             */
            THMR_ac_B.Switch1_jj = CeTHMR_e_Vlv1Pwrd;
        }
        else
        {
            /* Logic: '<S569>/Logical' incorporates:
             *  Logic: '<S573>/Logical'
             *  RelationalOperator: '<S569>/Comparison5'
             *  Switch: '<S561>/Switch1'
             *  Switch: '<S562>/Switch1'
             *  Switch: '<S563>/Switch1'
             *  Switch: '<S564>/Switch1'
             */
            rtb_TmpSignalConversionAtVePD_p = (rtb_TmpSignalConversionAtVePD_p &&
                (THMR_ac_B.OutportBufferForOut3));

            /* Switch: '<S561>/Switch1' incorporates:
             *  Logic: '<S569>/Logical'
             *  Logic: '<S570>/Logical'
             *  Logic: '<S571>/Logical'
             *  Logic: '<S572>/Logical'
             *  Logic: '<S573>/Logical'
             *  RelationalOperator: '<S570>/Comparison'
             *  RelationalOperator: '<S570>/Comparison5'
             *  RelationalOperator: '<S571>/Comparison1'
             *  RelationalOperator: '<S572>/Comparison1'
             *  RelationalOperator: '<S573>/Comparison1'
             *  Switch: '<S562>/Switch1'
             *  Switch: '<S563>/Switch1'
             *  Switch: '<S564>/Switch1'
             *  Switch: '<S565>/Switch1'
             */
            if (rtb_TmpSignalConversionAtVePD_p &&
                    rtb_TmpSignalConversionAtVePD_i)
            {
                /* Switch: '<S559>/Switch1' incorporates:
                 *  Constant: '<S552>/Constant'
                 *  Switch: '<S561>/Switch1'
                 */
                THMR_ac_B.Switch1_jj = CeTHMR_e_Vlv2Pwrd;
            }
            else if ((rtb_VariantMerge_For_Variant_ik &&
                      (THMR_ac_B.OutportBufferForOut3)) &&
                     rtb_TmpSignalConversionAtVePD_i)
            {
                /* Switch: '<S562>/Switch1' incorporates:
                 *  Constant: '<S553>/Constant'
                 *  Switch: '<S559>/Switch1'
                 *  Switch: '<S561>/Switch1'
                 */
                THMR_ac_B.Switch1_jj = CeTHMR_e_Vlv1N2Pwrd;
            }
            else if (rtb_AND_de && (THMR_ac_B.OutportBufferForOut4))
            {
                /* Switch: '<S563>/Switch1' incorporates:
                 *  Constant: '<S554>/Constant'
                 *  Switch: '<S559>/Switch1'
                 *  Switch: '<S562>/Switch1'
                 */
                THMR_ac_B.Switch1_jj = CeTHMR_e_Vlv3Pwrd;
            }
            else if (rtb_AND_fe && (THMR_ac_B.OutportBufferForOut4))
            {
                /* Switch: '<S564>/Switch1' incorporates:
                 *  Constant: '<S555>/Constant'
                 *  Switch: '<S559>/Switch1'
                 *  Switch: '<S562>/Switch1'
                 *  Switch: '<S563>/Switch1'
                 */
                THMR_ac_B.Switch1_jj = CeTHMR_e_Vlv1N3Pwrd;
            }
            else if (rtb_TmpSignalConversionAtVePD_p &&
                     (THMR_ac_B.OutportBufferForOut4))
            {
                /* Switch: '<S565>/Switch1' incorporates:
                 *  Constant: '<S556>/Constant'
                 *  Switch: '<S559>/Switch1'
                 *  Switch: '<S562>/Switch1'
                 *  Switch: '<S563>/Switch1'
                 *  Switch: '<S564>/Switch1'
                 */
                THMR_ac_B.Switch1_jj = CeTHMR_e_Vlv2N3Pwrd;
            }
            else
            {
                /* Switch: '<S559>/Switch1' incorporates:
                 *  Constant: '<S557>/Constant'
                 *  Switch: '<S562>/Switch1'
                 *  Switch: '<S563>/Switch1'
                 *  Switch: '<S564>/Switch1'
                 *  Switch: '<S565>/Switch1'
                 *  Switch: '<S566>/Switch1'
                 */
                THMR_ac_B.Switch1_jj = CeTHMR_e_Vlv1N2N3Pwrd;
            }
        }
    }

    /* RelationalOperator: '<S592>/Comparison5' */
    rtb_Gain_pg = !THMR_ac_B.VeTHMR_b_ThreeW_Prop_Valve2_Enb;

    /* RelationalOperator: '<S592>/Comparison1' */
    rtb_TmpSignalConversionAtVePMTR = !THMR_ac_B.VeTHMR_b_ThreeW_Prop_Valve3_Enb;

    /* RelationalOperator: '<S592>/Comparison' */
    rtb_Gain_c = !VeTHMR_b_ThreeW_Prop_Valve1_Enb;

    /* Logic: '<S592>/Logical' incorporates:
     *  Logic: '<S596>/Logical'
     */
    rtb_TmpSignalConversionAtVeP_el = (rtb_Gain_c && rtb_Gain_pg);

    /* Logic: '<S592>/Logical' */
    VeTHMR_b_All_Prop_Vlv_Unpwrd = (rtb_TmpSignalConversionAtVeP_el &&
        rtb_TmpSignalConversionAtVePMTR);

    /* Logic: '<S593>/Logical' incorporates:
     *  Logic: '<S597>/Logical'
     *  RelationalOperator: '<S593>/Comparison'
     */
    rtb_Gain_pg = ((VeTHMR_b_ThreeW_Prop_Valve1_Enb) && rtb_Gain_pg);

    /* Logic: '<S593>/Logical' */
    VeTHMR_b_OnlyVlv1 = (rtb_Gain_pg && rtb_TmpSignalConversionAtVePMTR);

    /* Logic: '<S594>/Logical' incorporates:
     *  Logic: '<S598>/Logical'
     *  RelationalOperator: '<S594>/Comparison5'
     */
    rtb_Gain_c = (rtb_Gain_c && (THMR_ac_B.VeTHMR_b_ThreeW_Prop_Valve2_Enb));

    /* Logic: '<S594>/Logical' */
    VeTHMR_b_OnlyVlv2 = (rtb_Gain_c && rtb_TmpSignalConversionAtVePMTR);

    /* Logic: '<S595>/Logical' incorporates:
     *  Logic: '<S599>/Logical'
     *  RelationalOperator: '<S595>/Comparison'
     *  RelationalOperator: '<S595>/Comparison5'
     */
    rtb_Switch1_hj = ((VeTHMR_b_ThreeW_Prop_Valve1_Enb) &&
                      (THMR_ac_B.VeTHMR_b_ThreeW_Prop_Valve2_Enb));

    /* Logic: '<S595>/Logical' */
    VeTHMR_b_Vlv1_N_2 = (rtb_Switch1_hj && rtb_TmpSignalConversionAtVePMTR);

    /* Logic: '<S596>/Logical' incorporates:
     *  RelationalOperator: '<S596>/Comparison1'
     */
    VeTHMR_b_OnlyVlv3 = (rtb_TmpSignalConversionAtVeP_el &&
                         (THMR_ac_B.VeTHMR_b_ThreeW_Prop_Valve3_Enb));

    /* Logic: '<S597>/Logical' incorporates:
     *  RelationalOperator: '<S597>/Comparison1'
     */
    VeTHMR_b_Vlv1_N_3 = (rtb_Gain_pg &&
                         (THMR_ac_B.VeTHMR_b_ThreeW_Prop_Valve3_Enb));

    /* Logic: '<S598>/Logical' incorporates:
     *  RelationalOperator: '<S598>/Comparison1'
     */
    VeTHMR_b_Vlv2_N_3 = (rtb_Gain_c &&
                         (THMR_ac_B.VeTHMR_b_ThreeW_Prop_Valve3_Enb));

    /* Logic: '<S599>/Logical' incorporates:
     *  RelationalOperator: '<S599>/Comparison1'
     */
    VeTHMR_b_AllPropValves = (rtb_Switch1_hj &&
        (THMR_ac_B.VeTHMR_b_ThreeW_Prop_Valve3_Enb));

    /* Switch: '<S584>/Switch1' incorporates:
     *  Switch: '<S585>/Switch1'
     *  Switch: '<S586>/Switch1'
     *  Switch: '<S587>/Switch1'
     *  Switch: '<S588>/Switch1'
     *  Switch: '<S589>/Switch1'
     *  Switch: '<S590>/Switch1'
     */
    if (VeTHMR_b_All_Prop_Vlv_Unpwrd)
    {
        /* Switch: '<S584>/Switch1' incorporates:
         *  Constant: '<S576>/Constant'
         */
        THMR_ac_B.Switch1_bm = CeTHMR_e_NoVlvPwrd;
    }
    else if (VeTHMR_b_OnlyVlv1)
    {
        /* Switch: '<S585>/Switch1' incorporates:
         *  Constant: '<S575>/Constant'
         *  Switch: '<S584>/Switch1'
         */
        THMR_ac_B.Switch1_bm = CeTHMR_e_Vlv1Pwrd;
    }
    else if (VeTHMR_b_OnlyVlv2)
    {
        /* Switch: '<S586>/Switch1' incorporates:
         *  Constant: '<S577>/Constant'
         *  Switch: '<S584>/Switch1'
         *  Switch: '<S585>/Switch1'
         */
        THMR_ac_B.Switch1_bm = CeTHMR_e_Vlv2Pwrd;
    }
    else if (VeTHMR_b_Vlv1_N_2)
    {
        /* Switch: '<S587>/Switch1' incorporates:
         *  Constant: '<S578>/Constant'
         *  Switch: '<S584>/Switch1'
         *  Switch: '<S585>/Switch1'
         *  Switch: '<S586>/Switch1'
         */
        THMR_ac_B.Switch1_bm = CeTHMR_e_Vlv1N2Pwrd;
    }
    else if (VeTHMR_b_OnlyVlv3)
    {
        /* Switch: '<S588>/Switch1' incorporates:
         *  Constant: '<S579>/Constant'
         *  Switch: '<S584>/Switch1'
         *  Switch: '<S585>/Switch1'
         *  Switch: '<S586>/Switch1'
         *  Switch: '<S587>/Switch1'
         */
        THMR_ac_B.Switch1_bm = CeTHMR_e_Vlv3Pwrd;
    }
    else if (VeTHMR_b_Vlv1_N_3)
    {
        /* Switch: '<S589>/Switch1' incorporates:
         *  Constant: '<S580>/Constant'
         *  Switch: '<S584>/Switch1'
         *  Switch: '<S585>/Switch1'
         *  Switch: '<S586>/Switch1'
         *  Switch: '<S587>/Switch1'
         *  Switch: '<S588>/Switch1'
         */
        THMR_ac_B.Switch1_bm = CeTHMR_e_Vlv1N3Pwrd;
    }
    else if (VeTHMR_b_Vlv2_N_3)
    {
        /* Switch: '<S590>/Switch1' incorporates:
         *  Constant: '<S581>/Constant'
         *  Switch: '<S584>/Switch1'
         *  Switch: '<S585>/Switch1'
         *  Switch: '<S586>/Switch1'
         *  Switch: '<S587>/Switch1'
         *  Switch: '<S588>/Switch1'
         *  Switch: '<S589>/Switch1'
         */
        THMR_ac_B.Switch1_bm = CeTHMR_e_Vlv2N3Pwrd;
    }
    else
    {
        /* Switch: '<S584>/Switch1' incorporates:
         *  Constant: '<S582>/Constant'
         *  Switch: '<S585>/Switch1'
         *  Switch: '<S586>/Switch1'
         *  Switch: '<S587>/Switch1'
         *  Switch: '<S588>/Switch1'
         *  Switch: '<S589>/Switch1'
         *  Switch: '<S590>/Switch1'
         *  Switch: '<S591>/Switch1'
         */
        THMR_ac_B.Switch1_bm = CeTHMR_e_Vlv1N2N3Pwrd;
    }

    /* End of Switch: '<S584>/Switch1' */
    /* End of Outputs for SubSystem: '<S2>/ClntProp3wayValves_State' */
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* Inport: '<Root>/VeFCRR_dV_FlowReq' */
    (void)Rte_Read_VeFCRR_dV_FlowReq_Value(&rtb_Merge1);

    /* Outputs for Function Call SubSystem: '<S2>/FC_Loop' */
    /* Switch: '<S902>/Switch4' incorporates:
     *  Lookup_n-D: '<S749>/Vector'
     *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
     *  Sum: '<S722>/Subtraction8'
     *  Switch: '<S302>/Switch1'
     */
    rtb_TmpSignalConversionAtVeTM_p = TmpSignalConversionAtOutAirTemp +
        look2_iflf_binlcapw(TmpSignalConversionAtOutAirTemp,
                            VeTHMR_p_HghRfrgtPres_Arb, ((const float32 *)
        &(KxTHMR_dT_CondAirWarmupEst[0])), ((const float32 *)
        &(KyTHMR_dT_CondAirWarmupEst[0])), ((const float32 *)
        &(KtTHMR_dT_CondAirWarmupEst[0])), THMR_ac_ConstP.pooled44, 6U);

    /* Sum: '<S722>/Subtraction9' incorporates:
     *  Lookup_n-D: '<S750>/Vector'
     *  Switch: '<S4111>/Switch2'
     *  Switch: '<S902>/Switch4'
     */
    rtb_TmpSignalConversionAtVeBTRR = rtb_TmpSignalConversionAtVeTM_p +
        look2_iflf_binlcapw(rtb_TmpSignalConversionAtVeTM_p,
                            VeTHMR_T_LTRInletTemp, ((const float32 *)
        &(KxTHMR_dT_LTRAirWarmupEst[0])), ((const float32 *)
        &(KyTHMR_dT_LTRAirWarmupEst[0])), ((const float32 *)
        &(KtTHMR_dT_LTRAirWarmupEst[0])), THMR_ac_ConstP.pooled44, 6U);

    /* RelationalOperator: '<S723>/RelationalOperator' incorporates:
     *  Merge: '<S4573>/Merge2'
     *  RelationalOperator: '<S724>/Comparison1'
     *  RelationalOperator: '<S724>/Comparison12'
     *  RelationalOperator: '<S724>/Comparison2'
     *  RelationalOperator: '<S724>/Comparison3'
     *  RelationalOperator: '<S724>/Comparison4'
     *  RelationalOperator: '<S729>/RelationalOperator2'
     *  RelationalOperator: '<S729>/RelationalOperator3'
     *  RelationalOperator: '<S789>/RelationalOperator4'
     *  RelationalOperator: '<S853>/RelationalOperator1'
     *  RelationalOperator: '<S853>/RelationalOperator2'
     */
    rtb_Logical17_o_tmp = THMR_ac_B.VeTHMR_e_FCThrmlState;

    /* If: '<S723>/FCL_Flow' incorporates:
     *  Constant: '<S751>/Constant'
     *  RelationalOperator: '<S723>/RelationalOperator'
     */
    if (((uint32)rtb_Logical17_o_tmp) == CeTHMR_e_FCCondOff)
    {
        /* Outputs for IfAction SubSystem: '<S723>/FCL_Flow_Off' incorporates:
         *  ActionPort: '<S752>/ActionPort'
         */
        /* Merge: '<S723>/Merge1' incorporates:
         *  Constant: '<S752>/Constant'
         *  SignalConversion generated from: '<S752>/FCL_Flow_off'
         */
        rtb_Merge1 = 0.0F;

        /* End of Outputs for SubSystem: '<S723>/FCL_Flow_Off' */
    }

    /* End of If: '<S723>/FCL_Flow' */

    /* Sum: '<S724>/Add' */
    rtb_TmpSignalConversionAtVeTM_f = rtb_TmpSignalConversionAtVeFCRR +
        rtb_TmpSignalConversionAtVeF_n4;

    /* RelationalOperator: '<S724>/Comparison4' incorporates:
     *  Constant: '<S757>/Constant'
     */
    rtb_Switch1_p1 = (((uint32)rtb_Logical17_o_tmp) == CeTHMR_e_FCStabilize);

    /* UnitDelay: '<S784>/UnitDelay' */
    rtb_TmpSignalConversionAtVeTRIR = THMR_ac_DW.UnitDelay_DSTATE_hj;

    /* Outputs for Atomic SubSystem: '<S763>/EdgeRising' */
    /* Logic: '<S767>/AND' incorporates:
     *  Logic: '<S767>/OR1'
     *  UnitDelay: '<S767>/Unit Delay'
     */
    rtb_Switch1_hj = (rtb_Switch1_p1 && (!THMR_ac_DW.UnitDelay_DSTATE_dt));

    /* Update for UnitDelay: '<S767>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_dt = rtb_Switch1_p1;

    /* End of Outputs for SubSystem: '<S763>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S763>/EdgeRising1' */
    /* Logic: '<S768>/OR1' incorporates:
     *  UnitDelay: '<S768>/Unit Delay'
     */
    rtb_Switch1_cys = !THMR_ac_DW.UnitDelay_DSTATE_c4;

    /* Update for UnitDelay: '<S768>/Unit Delay' incorporates:
     *  Constant: '<S763>/TRUEConstant1'
     */
    THMR_ac_DW.UnitDelay_DSTATE_c4 = true;

    /* End of Outputs for SubSystem: '<S763>/EdgeRising1' */

    /* Switch: '<S55>/Switch2' incorporates:
     *  Constant: '<S737>/Calib'
     *  Inport: '<Root>/VeTAIR_Pct_HTRBV_ActuatorPosAct'
     */
    if (KeTHMR_b_UseFCVlvFdb4FlwEst)
    {
        (void)Rte_Read_VeTAIR_Pct_HTRBV_ActuatorPosAct_Value(&rtb_Switch_eu);

        /* Switch: '<S55>/Switch2' incorporates:
         *  Inport: '<Root>/VeTAIR_Pct_HTRBV_ActuatorPosAct'
         *  Lookup_n-D: '<S743>/Vector'
         */
        rtb_TmpSignalConversionAtVePMIR = look1_iflf_binlcapw(rtb_Switch_eu, ((
            const float32 *)&(KxTHMR_Pct_FC_VlvFdpPosPct[0])), ((const float32 *)
            &(KtTHMR_Pct_FC_VlvFdpPosPct[0])), 8U);
    }
    else
    {
        /* Switch: '<S55>/Switch2' incorporates:
         *  UnitDelay: '<S55>/Unit Delay3'
         */
        rtb_TmpSignalConversionAtVePMIR = THMR_ac_DW.UnitDelay3_DSTATE_l;
    }

    /* End of Switch: '<S55>/Switch2' */

    /* If: '<S763>/If' incorporates:
     *  Logic: '<S768>/AND'
     */
    if (rtb_Switch1_hj)
    {
        /* Outputs for IfAction SubSystem: '<S763>/IfAct' incorporates:
         *  ActionPort: '<S769>/Action Port'
         */
        /* Merge: '<S763>/Merge1' incorporates:
         *  Constant: '<S763>/TRUEConstant2'
         *  Inport: '<S769>/LTR_PID_Cmd_Prev'
         *  Lookup_n-D: '<S779>/Vector'
         *  Sum: '<S763>/Add'
         *  Switch: '<S55>/Switch2'
         */
        THMR_ac_B.Merge1 = 1.0F - look1_iflf_binlcapw
            (rtb_TmpSignalConversionAtVePMIR, ((const float32 *)
              &(KxTHMR_Pct_HTRConversionRCVR[0])), ((const float32 *)
              &(KtTHMR_Pct_HTRConversionRCVR[0])), 5U);

        /* End of Outputs for SubSystem: '<S763>/IfAct' */

        /* Outputs for Atomic SubSystem: '<S763>/PIDControl' */
        /* Switch: '<S783>/Switch' */
        rtb_Switch_eu = THMR_ac_B.Merge1;

        /* End of Outputs for SubSystem: '<S763>/PIDControl' */
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S763>/EdgeRising1' */
        if (rtb_Switch1_cys)
        {
            /* Outputs for IfAction SubSystem: '<S763>/IfAct1' incorporates:
             *  ActionPort: '<S770>/Action Port'
             */
            /* Merge: '<S763>/Merge1' incorporates:
             *  Constant: '<S785>/Calib'
             *  SignalConversion generated from: '<S770>/Out1'
             */
            THMR_ac_B.Merge1 = KeTHMR_Pct_FCVlvInit;

            /* End of Outputs for SubSystem: '<S763>/IfAct1' */
        }

        /* End of Outputs for SubSystem: '<S763>/EdgeRising1' */

        /* Outputs for Atomic SubSystem: '<S763>/PIDControl' */
        /* Switch: '<S783>/Switch' incorporates:
         *  Constant: '<S763>/Constant1'
         *  Lookup_n-D: '<S780>/Vector'
         *  Product: '<S783>/Multiplication1'
         *  SignalConversion generated from: '<S2>/VeFCPR_I_FCPS_Curr'
         *  Sum: '<S722>/Subtraction9'
         *  Sum: '<S783>/Sum//Sub'
         *  UnitDelay: '<S783>/UnitDelay'
         */
        rtb_Switch_eu = ((rtb_TmpSignalConversionAtVeTM_f * look2_iflf_binlcapw
                          (rtb_TmpSignalConversionAtVeBTRR,
                           rtb_TmpSignalConversionAtVeFC_p, ((const float32 *)
                            &(KxTHMR_k_FCPropVlv_Ki[0])), ((const float32 *)
                            &(KyTHMR_k_FCPropVlv_Ki[0])), ((const float32 *)
                            &(KtTHMR_k_FCPropVlv_Ki[0])),
                           THMR_ac_ConstP.pooled41, 4U)) * 0.1F) +
            THMR_ac_DW.UnitDelay_DSTATE_kt;

        /* End of Outputs for SubSystem: '<S763>/PIDControl' */
    }

    /* End of If: '<S763>/If' */

    /* Outputs for Atomic SubSystem: '<S763>/PIDControl' */
    /* Outputs for Atomic SubSystem: '<S783>/integral_term' */
    /* Switch: '<S786>/Switch1' incorporates:
     *  Constant: '<S774>/Calib'
     *  RelationalOperator: '<S786>/RelationalOperator'
     */
    if (KeTHMR_Pct_FCVlv_PI_IntgrlTerm_Max < rtb_Switch_eu)
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = KeTHMR_Pct_FCVlv_PI_IntgrlTerm_Max;
    }
    else
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = rtb_Switch_eu;
    }

    /* End of Switch: '<S786>/Switch1' */

    /* Switch: '<S786>/Switch' incorporates:
     *  Constant: '<S775>/Calib'
     *  RelationalOperator: '<S786>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTA_n > KeTHMR_Pct_FCVlv_PI_IntgrlTerm_Min)
    {
        /* Switch: '<S786>/Switch' */
        rtb_Switch_eu = rtb_TmpSignalConversionAtVeTA_n;
    }
    else
    {
        /* Switch: '<S786>/Switch' */
        rtb_Switch_eu = KeTHMR_Pct_FCVlv_PI_IntgrlTerm_Min;
    }

    /* End of Switch: '<S786>/Switch' */
    /* End of Outputs for SubSystem: '<S783>/integral_term' */

    /* Sum: '<S783>/Sum//Sub1' incorporates:
     *  Constant: '<S763>/Constant1'
     *  Constant: '<S778>/Calib'
     *  Lookup_n-D: '<S781>/Vector'
     *  Product: '<S783>/Multiplication2'
     *  Product: '<S783>/derivative_term'
     *  Product: '<S783>/proportional_term'
     *  SignalConversion generated from: '<S2>/VeFCPR_I_FCPS_Curr'
     *  Sum: '<S722>/Subtraction9'
     *  Sum: '<S783>/Sum//Sub2'
     *  UnitDelay: '<S783>/UnitDelay1'
     */
    rtb_TmpSignalConversionAtVeT_dg = (((rtb_TmpSignalConversionAtVeTM_f -
        THMR_ac_DW.UnitDelay1_DSTATE_h4) * KeTHMR_k_FCPropVlv_Kd) / 0.1F) +
        ((rtb_TmpSignalConversionAtVeTM_f * look2_iflf_binlcapw
          (rtb_TmpSignalConversionAtVeBTRR, rtb_TmpSignalConversionAtVeFC_p, ((
             const float32 *)&(KxTHMR_k_FCPropVlv_Kp[0])), ((const float32 *)
            &(KyTHMR_k_FCPropVlv_Kp[0])), ((const float32 *)
            &(KtTHMR_k_FCPropVlv_Kp[0])), THMR_ac_ConstP.pooled41, 4U)) +
         rtb_Switch_eu);

    /* Update for UnitDelay: '<S783>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_h4 = rtb_TmpSignalConversionAtVeTM_f;

    /* Update for UnitDelay: '<S783>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kt = rtb_Switch_eu;

    /* Outputs for Atomic SubSystem: '<S763>/Limiter1' */
    /* Switch: '<S782>/Switch1' incorporates:
     *  Constant: '<S772>/Calib'
     *  RelationalOperator: '<S782>/RelationalOperator'
     *  Switch: '<S783>/Switch1'
     */
    if (KeTHMR_Pct_FCVlv_PICmdMax < rtb_TmpSignalConversionAtVeT_dg)
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = KeTHMR_Pct_FCVlv_PICmdMax;
    }
    else
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = rtb_TmpSignalConversionAtVeT_dg;
    }

    /* End of Switch: '<S782>/Switch1' */
    /* End of Outputs for SubSystem: '<S763>/PIDControl' */

    /* Switch: '<S782>/Switch' incorporates:
     *  Constant: '<S773>/Calib'
     *  RelationalOperator: '<S782>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTA_n > KeTHMR_Pct_FCVlv_PICmdMin)
    {
        /* Switch: '<S782>/Switch' */
        VeTHMR_Pct_FCVlv_PICmd = rtb_TmpSignalConversionAtVeTA_n;
    }
    else
    {
        /* Switch: '<S782>/Switch' */
        VeTHMR_Pct_FCVlv_PICmd = KeTHMR_Pct_FCVlv_PICmdMin;
    }

    /* End of Switch: '<S782>/Switch' */
    /* End of Outputs for SubSystem: '<S763>/Limiter1' */

    /* Sum: '<S784>/Sum2' */
    rtb_Switch_eu = VeTHMR_Pct_FCVlv_PICmd - rtb_TmpSignalConversionAtVeTRIR;

    /* Switch: '<S787>/Switch1' incorporates:
     *  Constant: '<S771>/Calib'
     *  RelationalOperator: '<S784>/Comparison1'
     */
    if (rtb_TmpSignalConversionAtVeTRIR < KeTHMR_Pct_FCVlv_MinRampPct)
    {
        /* Switch: '<S787>/Switch1' incorporates:
         *  Constant: '<S777>/Calib'
         *  MinMax: '<S784>/MinMax'
         *  MinMax: '<S784>/MinMax1'
         *  Sum: '<S784>/Sum1'
         */
        rtb_TmpSignalConversionAtVeTM_f = fmaxf(fminf
            (KeTHMR_Pct_FCVlv_MinRampPct - rtb_TmpSignalConversionAtVeTRIR,
             rtb_Switch_eu), KeTHMR_Pct_FCVlv_RmpRateLim_Up);
    }
    else
    {
        /* Switch: '<S787>/Switch1' incorporates:
         *  Constant: '<S777>/Calib'
         */
        rtb_TmpSignalConversionAtVeTM_f = KeTHMR_Pct_FCVlv_RmpRateLim_Up;
    }

    /* End of Switch: '<S787>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S784>/integral_term' */
    /* Switch: '<S788>/Switch1' incorporates:
     *  RelationalOperator: '<S788>/RelationalOperator'
     */
    if (rtb_TmpSignalConversionAtVeTM_f < rtb_Switch_eu)
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = rtb_TmpSignalConversionAtVeTM_f;
    }
    else
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = rtb_Switch_eu;
    }

    /* End of Switch: '<S788>/Switch1' */

    /* Switch: '<S788>/Switch' incorporates:
     *  Constant: '<S776>/Calib'
     *  RelationalOperator: '<S788>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTA_n <= KeTHMR_Pct_FCVlv_RmpRateLim_Dwn)
    {
        rtb_TmpSignalConversionAtVeTA_n = KeTHMR_Pct_FCVlv_RmpRateLim_Dwn;
    }

    /* End of Switch: '<S788>/Switch' */
    /* End of Outputs for SubSystem: '<S784>/integral_term' */

    /* Sum: '<S784>/Sum3' */
    VeTHMR_Pct_FCVlv_Balancing = rtb_TmpSignalConversionAtVeTA_n +
        rtb_TmpSignalConversionAtVeTRIR;

    /* If: '<S724>/LTCL_Valve_Pos' incorporates:
     *  Constant: '<S754>/Constant'
     *  Constant: '<S755>/Constant'
     *  Constant: '<S756>/Constant'
     *  Constant: '<S758>/Constant'
     *  Logic: '<S724>/LogicalOperator1'
     *  RelationalOperator: '<S724>/Comparison1'
     *  RelationalOperator: '<S724>/Comparison12'
     *  RelationalOperator: '<S724>/Comparison2'
     *  RelationalOperator: '<S724>/Comparison3'
     */
    if ((CeTHMR_e_FCBoostCool == ((uint32)rtb_Logical17_o_tmp)) || (((uint32)
            rtb_Logical17_o_tmp) == CeTHMR_e_FCPsvCool))
    {
        /* Outputs for IfAction SubSystem: '<S724>/FCL_Cooling_Pos' incorporates:
         *  ActionPort: '<S760>/ActionPort'
         */
        THMR_ac_FCL_Cooling_Pos(&THMR_ac_B.Merge1_l);

        /* End of Outputs for SubSystem: '<S724>/FCL_Cooling_Pos' */
    }
    else if (((uint32)rtb_Logical17_o_tmp) == CeTHMR_e_FCActvPsvHeat)
    {
        /* Outputs for IfAction SubSystem: '<S724>/FCL_Heating_Pos' incorporates:
         *  ActionPort: '<S762>/ActionPort'
         */
        /* Merge: '<S724>/Merge1' incorporates:
         *  Constant: '<S766>/Calib'
         *  SignalConversion generated from: '<S762>/Opn'
         */
        THMR_ac_B.Merge1_l = KeTHMR_Pct_FCVlv_BypassRad;

        /* End of Outputs for SubSystem: '<S724>/FCL_Heating_Pos' */
    }
    else if (rtb_Switch1_p1)
    {
        /* Outputs for IfAction SubSystem: '<S724>/FCL_Balance_Pos' incorporates:
         *  ActionPort: '<S759>/ActionPort'
         */
        THMR_ac_LTCL_Default_Pos(VeTHMR_Pct_FCVlv_Balancing, &THMR_ac_B.Merge1_l);

        /* End of Outputs for SubSystem: '<S724>/FCL_Balance_Pos' */
    }
    else
    {
        if (((uint32)rtb_Logical17_o_tmp) == CeTHMR_e_FCCondOff)
        {
            /* Outputs for IfAction SubSystem: '<S724>/FCL_Dflt_Pos' incorporates:
             *  ActionPort: '<S761>/ActionPort'
             */
            THMR_ac_FCL_Cooling_Pos(&THMR_ac_B.Merge1_l);

            /* End of Outputs for SubSystem: '<S724>/FCL_Dflt_Pos' */
        }
    }

    /* End of If: '<S724>/LTCL_Valve_Pos' */

    /* Outputs for Atomic SubSystem: '<S789>/Hysteresis' */
    /* Switch: '<S796>/Switch1' incorporates:
     *  Constant: '<S804>/Calib'
     *  RelationalOperator: '<S796>/Greater  Than'
     */
    if (rtb_TmpSignalConversionAtVeF_n4 > KeTHMR_T_FCCTOSHot_FCSDerate_RSP)
    {
        /* Switch: '<S796>/Switch1' incorporates:
         *  Constant: '<S796>/Constant Value'
         */
        rtb_Switch1_p1 = true;
    }
    else
    {
        /* Switch: '<S796>/Switch1' incorporates:
         *  Constant: '<S803>/Calib'
         *  RelationalOperator: '<S796>/Greater  Than1'
         *  UnitDelay: '<S796>/Unit Delay'
         */
        rtb_Switch1_p1 = ((rtb_TmpSignalConversionAtVeF_n4 >=
                           KeTHMR_T_FCCTOSHot_FCSDerate_LSP) &&
                          (THMR_ac_DW.UnitDelay_DSTATE_eb));
    }

    /* End of Switch: '<S796>/Switch1' */

    /* Update for UnitDelay: '<S796>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_eb = rtb_Switch1_p1;

    /* End of Outputs for SubSystem: '<S789>/Hysteresis' */

    /* Sum: '<S790>/Subtraction15' incorporates:
     *  Sum: '<S726>/Subtraction3'
     *  Sum: '<S902>/Subtraction1'
     */
    rtb_Sum_e = rtb_TmpSignalConversionAtVeF_n4 -
        rtb_TmpSignalConversionAtVeFC_f;

    /* MinMax: '<S790>/MinMax' incorporates:
     *  Constant: '<S813>/Calib'
     *  Product: '<S790>/Product1'
     *  Sum: '<S790>/Subtraction1'
     *  Sum: '<S790>/Subtraction15'
     *  Sum: '<S790>/Subtraction2'
     */
    VeTHMR_dT_FCSDerate_Error = fmaxf((rtb_Sum_e -
        rtb_TmpSignalConversionAtVeF_ob) * KeTHMR_r_FCClntdTTgtfctr_FCSDerate,
        rtb_TmpSignalConversionAtVeF_n4 - rtb_TmpSignalConversionAtVeFCRR);

    /* Outputs for Atomic SubSystem: '<S789>/Hysteresis1' */
    /* Switch: '<S797>/Switch1' incorporates:
     *  Constant: '<S806>/Calib'
     *  RelationalOperator: '<S797>/Greater  Than'
     */
    if (VeTHMR_dT_FCSDerate_Error > KeTHMR_dT_FCClntdT_FCSDerate_RSP)
    {
        /* Switch: '<S797>/Switch1' incorporates:
         *  Constant: '<S797>/Constant Value'
         */
        rtb_Switch1_hj = true;
    }
    else
    {
        /* Switch: '<S797>/Switch1' incorporates:
         *  Constant: '<S805>/Calib'
         *  RelationalOperator: '<S797>/Greater  Than1'
         *  UnitDelay: '<S797>/Unit Delay'
         */
        rtb_Switch1_hj = ((VeTHMR_dT_FCSDerate_Error >=
                           KeTHMR_dT_FCClntdT_FCSDerate_LSP) &&
                          (THMR_ac_DW.UnitDelay_DSTATE_og));
    }

    /* End of Switch: '<S797>/Switch1' */

    /* Update for UnitDelay: '<S797>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_og = rtb_Switch1_hj;

    /* End of Outputs for SubSystem: '<S789>/Hysteresis1' */

    /* Outputs for Atomic SubSystem: '<S789>/Hysteresis2' */
    /* Switch: '<S798>/Switch1' incorporates:
     *  Constant: '<S802>/Calib'
     *  RelationalOperator: '<S798>/Greater  Than'
     */
    if (VeTHMR_Pct_HV_BatSOC > KeTHMR_Pct_HVBatSOC_FCSDerate_RSP)
    {
        /* Switch: '<S798>/Switch1' incorporates:
         *  Constant: '<S798>/Constant Value'
         */
        rtb_Switch1_cys = true;
    }
    else
    {
        /* Switch: '<S798>/Switch1' incorporates:
         *  Constant: '<S801>/Calib'
         *  RelationalOperator: '<S798>/Greater  Than1'
         *  UnitDelay: '<S798>/Unit Delay'
         */
        rtb_Switch1_cys = ((VeTHMR_Pct_HV_BatSOC >=
                            KeTHMR_Pct_HVBatSOC_FCSDerate_LSP) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_k4b));
    }

    /* End of Switch: '<S798>/Switch1' */

    /* Update for UnitDelay: '<S798>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_k4b = rtb_Switch1_cys;

    /* End of Outputs for SubSystem: '<S789>/Hysteresis2' */

    /* MinMax: '<S980>/MinMax' incorporates:
     *  SignalConversion generated from: '<S742>/Vector'
     */
    rtb_Switch1_pn[0] = rtb_TmpSignalConversionAtVeTR_p;
    rtb_Switch1_pn[1] = VeTHMR_T_HTCLHexInletTemp;

    /* Lookup_n-D: '<S742>/Vector' */
    for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 2;
            rtb_DataTypeConversion2++)
    {
        rtb_Switch1_pn[rtb_DataTypeConversion2] = look1_iflf_binlcapw
            (rtb_Switch1_pn[rtb_DataTypeConversion2], ((const float32 *)
              &(KxTHMR_K_CoolantHeatCap[0])), ((const float32 *)
              &(KtTHMR_K_CoolantHeatCap[0])), 5U);
    }

    /* End of Lookup_n-D: '<S742>/Vector' */

    /* Product: '<S728>/Product' incorporates:
     *  Constant: '<S843>/Calib'
     */
    rtb_Switch_eu = rtb_Merge1 * KeTHMR_K_FCHEXBrnchFlwRatio;

    /* Outputs for Atomic SubSystem: '<S728>/Limiter2' */
    /* Switch: '<S845>/Switch1' incorporates:
     *  Constant: '<S844>/Calib'
     *  RelationalOperator: '<S845>/RelationalOperator'
     */
    if (KeTHMR_dV_MaxFCHEXBrnchFlw < rtb_Switch_eu)
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = KeTHMR_dV_MaxFCHEXBrnchFlw;
    }
    else
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = rtb_Switch_eu;
    }

    /* End of Switch: '<S845>/Switch1' */

    /* Switch: '<S845>/Switch' incorporates:
     *  Constant: '<S728>/Constant'
     *  RelationalOperator: '<S845>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTA_n > 0.0F)
    {
        /* Switch: '<S845>/Switch' */
        rtb_TmpSignalConversionAtVeTRIR = rtb_TmpSignalConversionAtVeTA_n;
    }
    else
    {
        /* Switch: '<S845>/Switch' */
        rtb_TmpSignalConversionAtVeTRIR = 0.0F;
    }

    /* End of Switch: '<S845>/Switch' */
    /* End of Outputs for SubSystem: '<S728>/Limiter2' */

    /* Sum: '<S732>/Subtraction1' incorporates:
     *  Sum: '<S727>/Subtraction15'
     *  Sum: '<S735>/Subtraction13'
     */
    rtb_TmpSignalConversionAtVeBT_o = rtb_Merge1 -
        rtb_TmpSignalConversionAtVeTRIR;

    /* Product: '<S732>/Product1' incorporates:
     *  Lookup_n-D: '<S890>/Vector'
     *  Sum: '<S732>/Subtraction1'
     *  Switch: '<S55>/Switch2'
     */
    rtb_Switch_eu = rtb_TmpSignalConversionAtVeBT_o * look1_iflf_binlcapw
        (rtb_TmpSignalConversionAtVePMIR, ((const float32 *)
          &(KxTHMR_Pct_FCLPstnFlwpct[0])), ((const float32 *)
          &(KtTHMR_Pct_FCLPstnFlwpct[0])), 8U);

    /* Product: '<S733>/Product2' incorporates:
     *  Sum: '<S733>/Subtraction5'
     */
    rtb_TmpSignalConversionAtVePM_n = (rtb_Switch1_pn[1] *
        rtb_TmpSignalConversionAtVePM_n) * (rtb_TmpSignalConversionAtVeT_ge -
        VeTHMR_T_HTCLHexInletTemp);

    /* Product: '<S733>/Product3' */
    rtb_TmpSignalConversionAtVeTM_f = rtb_TmpSignalConversionAtVeTRIR *
        rtb_Switch1_pn[0];

    /* Outputs for Atomic SubSystem: '<S733>/ProtectedDivision2' */
    /* Switch: '<S891>/Switch1' incorporates:
     *  Constant: '<S891>/ConstantValue'
     *  Constant: '<S891>/ConstantValue1'
     *  Constant: '<S891>/ConstantValue2'
     *  Constant: '<S891>/ConstantValue3'
     *  Logic: '<S891>/AND'
     *  RelationalOperator: '<S891>/GreaterThanorEqual'
     *  RelationalOperator: '<S891>/GreaterThanorEqual1'
     *  RelationalOperator: '<S891>/NotEqual'
     *  RelationalOperator: '<S891>/NotEqual1'
     *  Switch: '<S891>/Switch2'
     *  Switch: '<S891>/Switch3'
     */
    if ((rtb_TmpSignalConversionAtVePM_n != 0.0F) &&
            (rtb_TmpSignalConversionAtVeTM_f != 0.0F))
    {
        /* Switch: '<S891>/Switch1' incorporates:
         *  Product: '<S891>/Division'
         */
        rtb_TmpSignalConversionAtVePM_n /= rtb_TmpSignalConversionAtVeTM_f;
    }
    else if (rtb_TmpSignalConversionAtVePM_n > 0.0F)
    {
        /* Switch: '<S891>/Switch2' incorporates:
         *  Constant: '<S891>/MAXFLOAT'
         *  Switch: '<S891>/Switch1'
         */
        rtb_TmpSignalConversionAtVePM_n = 3.402823466E+38F;
    }
    else if (rtb_TmpSignalConversionAtVePM_n < 0.0F)
    {
        /* Switch: '<S891>/Switch3' incorporates:
         *  Constant: '<S891>/MINFLOAT'
         *  Switch: '<S891>/Switch1'
         *  Switch: '<S891>/Switch2'
         */
        rtb_TmpSignalConversionAtVePM_n = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S891>/Switch1' incorporates:
         *  Constant: '<S891>/ConstantValue4'
         *  Switch: '<S891>/Switch2'
         *  Switch: '<S891>/Switch3'
         */
        rtb_TmpSignalConversionAtVePM_n = 0.0F;
    }

    /* End of Switch: '<S891>/Switch1' */
    /* End of Outputs for SubSystem: '<S733>/ProtectedDivision2' */

    /* Sum: '<S731>/Subtraction7' incorporates:
     *  Abs: '<S726>/Abs'
     *  MinMax: '<S726>/MinMax'
     *  Product: '<S731>/Product4'
     *  Product: '<S731>/Product5'
     *  Product: '<S731>/Product6'
     *  Sum: '<S726>/Subtraction4'
     *  Sum: '<S733>/Subtraction6'
     *  Sum: '<S734>/Subtraction2'
     */
    rtb_TmpSignalConversionAtVePM_n = (((rtb_TmpSignalConversionAtVeFCRR - fminf
        (rtb_TmpSignalConversionAtVeF_ob, fabsf(rtb_Sum_e))) * rtb_Merge1) -
        ((rtb_TmpSignalConversionAtVeT_ge + rtb_TmpSignalConversionAtVePM_n) *
         rtb_TmpSignalConversionAtVeTRIR)) - (((rtb_Merge1 - rtb_Switch_eu) -
        rtb_TmpSignalConversionAtVeTRIR) * rtb_TmpSignalConversionAtVeTR_p);

    /* Outputs for Atomic SubSystem: '<S731>/ProtectedDivision1' */
    /* Switch: '<S889>/Switch1' incorporates:
     *  Constant: '<S889>/ConstantValue'
     *  Constant: '<S889>/ConstantValue1'
     *  Constant: '<S889>/ConstantValue2'
     *  Constant: '<S889>/ConstantValue3'
     *  Logic: '<S889>/AND'
     *  RelationalOperator: '<S889>/GreaterThanorEqual'
     *  RelationalOperator: '<S889>/GreaterThanorEqual1'
     *  RelationalOperator: '<S889>/NotEqual'
     *  RelationalOperator: '<S889>/NotEqual1'
     *  Switch: '<S889>/Switch2'
     *  Switch: '<S889>/Switch3'
     */
    if ((rtb_TmpSignalConversionAtVePM_n != 0.0F) && (rtb_Switch_eu != 0.0F))
    {
        /* Switch: '<S889>/Switch1' incorporates:
         *  Product: '<S889>/Division'
         */
        rtb_TmpSignalConversionAtVePM_n /= rtb_Switch_eu;
    }
    else if (rtb_TmpSignalConversionAtVePM_n > 0.0F)
    {
        /* Switch: '<S889>/Switch2' incorporates:
         *  Constant: '<S889>/MAXFLOAT'
         *  Switch: '<S889>/Switch1'
         */
        rtb_TmpSignalConversionAtVePM_n = 3.402823466E+38F;
    }
    else if (rtb_TmpSignalConversionAtVePM_n < 0.0F)
    {
        /* Switch: '<S889>/Switch3' incorporates:
         *  Constant: '<S889>/MINFLOAT'
         *  Switch: '<S889>/Switch1'
         *  Switch: '<S889>/Switch2'
         */
        rtb_TmpSignalConversionAtVePM_n = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S889>/Switch1' incorporates:
         *  Constant: '<S889>/ConstantValue4'
         *  Switch: '<S889>/Switch2'
         *  Switch: '<S889>/Switch3'
         */
        rtb_TmpSignalConversionAtVePM_n = 0.0F;
    }

    /* End of Switch: '<S889>/Switch1' */
    /* End of Outputs for SubSystem: '<S731>/ProtectedDivision1' */

    /* Switch: '<S855>/Switch3' incorporates:
     *  Constant: '<S879>/Calib'
     *  Sum: '<S855>/Subtraction10'
     */
    if (KeTHMR_b_FCAirdT4Airflw)
    {
        rtb_Switch10 = rtb_TmpSignalConversionAtVeTR_p -
            rtb_TmpSignalConversionAtVeBTRR;
    }
    else
    {
        rtb_Switch10 = rtb_TmpSignalConversionAtVeBTRR;
    }

    /* End of Switch: '<S855>/Switch3' */

    /* Lookup_n-D: '<S863>/Vector' incorporates:
     *  Product: '<S730>/Product7'
     *  Product: '<S730>/Product8'
     *  Sum: '<S730>/Subtraction'
     */
    VeTHMR_dV_FC_HTR_AirFlow_Raw = look2_iflf_binlcapw((rtb_Switch1_pn[0] *
        rtb_Switch_eu) * (rtb_TmpSignalConversionAtVeTR_p -
                          rtb_TmpSignalConversionAtVePM_n), rtb_Switch10, ((
        const float32 *)&(KxTHMR_dV_FC_HTR_AirFlowRaw[0])), ((const float32 *)
        &(KyTHMR_dV_FC_HTR_AirFlowRaw[0])), ((const float32 *)
        &(KtTHMR_dV_FC_HTR_AirFlowRaw[0])), THMR_ac_ConstP.pooled34, 7U);

    /* Outputs for Atomic SubSystem: '<S730>/Digital Lowpass Reset Enabled' */
    /* Switch: '<S858>/Switch1' incorporates:
     *  Constant: '<S730>/Constant6'
     *  Constant: '<S859>/Calib'
     *  Constant: '<S860>/Calib'
     *  Constant: '<S861>/Calib'
     *  Logic: '<S730>/LogicalOperator1'
     *  RelationalOperator: '<S730>/RelationalOperator2'
     *  RelationalOperator: '<S730>/RelationalOperator3'
     *  Switch: '<S854>/Switch1'
     */
    if ((rtb_TmpSignalConversionAtVePMIR < KeTHMR_Pct_FCVlvPos_FrzAirflowPTerm) &&
        (rtb_TmpSignalConversionAtVePMIR >= KeTHMR_Pct_FCVlvPos_FrzAirflowITerm))
    {
        rtb_TmpSignalConversionAtVeTRIR =
            KeTHMR_dT_FCAirflwTgtOffset_VlvCntrlActv;
    }
    else
    {
        rtb_TmpSignalConversionAtVeTRIR = 0.0F;
    }

    /* End of Switch: '<S858>/Switch1' */

    /* Switch: '<S854>/Switch1' incorporates:
     *  Constant: '<S862>/Calib'
     *  Product: '<S854>/Multiplication'
     *  Sum: '<S730>/Subtraction1'
     *  Sum: '<S854>/Subtraction'
     *  Sum: '<S854>/Summation'
     *  UnitDelay: '<S854>/Unit Delay'
     */
    rtb_TmpSignalConversionAtVePM_n = (((rtb_TmpSignalConversionAtVeFCRR +
        rtb_TmpSignalConversionAtVeTRIR) - THMR_ac_DW.UnitDelay_DSTATE_mg) *
        KeTHMR_k_HTRAirflw_MFltrCoeff) + THMR_ac_DW.UnitDelay_DSTATE_mg;

    /* Update for UnitDelay: '<S854>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_mg = rtb_TmpSignalConversionAtVePM_n;

    /* End of Outputs for SubSystem: '<S730>/Digital Lowpass Reset Enabled' */

    /* Sum: '<S730>/Subtraction12' */
    rtb_TmpSignalConversionAtVePM_n = rtb_TmpSignalConversionAtVeF_n4 -
        rtb_TmpSignalConversionAtVePM_n;

    /* Outputs for Atomic SubSystem: '<S853>/Hysteresis' */
    /* Switch: '<S871>/Switch1' incorporates:
     *  Constant: '<S874>/Calib'
     *  RelationalOperator: '<S871>/Greater  Than'
     */
    if (rtb_TmpSignalConversionAtVePM_n > KeTHMR_dT_FCStblz_FanAllwdEnbl)
    {
        /* Switch: '<S871>/Switch1' incorporates:
         *  Constant: '<S871>/Constant Value'
         */
        rtb_TmpSignalConversionAtVePMTR = true;
    }
    else
    {
        /* Switch: '<S871>/Switch1' incorporates:
         *  Constant: '<S873>/Calib'
         *  RelationalOperator: '<S871>/Greater  Than1'
         *  UnitDelay: '<S871>/Unit Delay'
         */
        rtb_TmpSignalConversionAtVePMTR = ((rtb_TmpSignalConversionAtVePM_n >=
            KeTHMR_dT_FCStblz_FanAllwdDsbl) && (THMR_ac_DW.UnitDelay_DSTATE_dk));
    }

    /* End of Switch: '<S871>/Switch1' */

    /* Update for UnitDelay: '<S871>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_dk = rtb_TmpSignalConversionAtVePMTR;

    /* End of Outputs for SubSystem: '<S853>/Hysteresis' */

    /* Logic: '<S853>/LogicalOperator2' incorporates:
     *  Constant: '<S870>/Constant'
     *  RelationalOperator: '<S853>/RelationalOperator2'
     */
    rtb_TmpSignalConversionAtVePMTR = ((((uint32)rtb_Logical17_o_tmp) ==
        CeTHMR_e_FCStabilize) && rtb_TmpSignalConversionAtVePMTR);

    /* Outputs for Atomic SubSystem: '<S853>/EdgeBi' */
    /* RelationalOperator: '<S867>/Not Equal' incorporates:
     *  UnitDelay: '<S867>/Unit Delay'
     */
    rtb_TmpSignalConversionAtVeP_el = (rtb_TmpSignalConversionAtVePMTR !=
        THMR_ac_DW.UnitDelay_DSTATE_iu);

    /* Update for UnitDelay: '<S867>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_iu = rtb_TmpSignalConversionAtVePMTR;

    /* End of Outputs for SubSystem: '<S853>/EdgeBi' */

    /* Outputs for Atomic SubSystem: '<S853>/Turn On Delay Sample Resetable Delay' */
    /* Outputs for Atomic SubSystem: '<S875>/EdgeRising with resetable delay' */
    /* Logic: '<S876>/AND' incorporates:
     *  Logic: '<S876>/OR1'
     *  UnitDelay: '<S876>/Unit Delay'
     */
    rtb_Gain_pg = (rtb_TmpSignalConversionAtVePMTR &&
                   (!THMR_ac_DW.UnitDelay_DSTATE_dz));

    /* Switch: '<S878>/Switch1' */
    if (rtb_TmpSignalConversionAtVeP_el)
    {
        /* Update for UnitDelay: '<S876>/Unit Delay' incorporates:
         *  Constant: '<S876>/Constant1'
         *  Switch: '<S878>/Switch1'
         */
        THMR_ac_DW.UnitDelay_DSTATE_dz = false;
    }
    else
    {
        /* Update for UnitDelay: '<S876>/Unit Delay' incorporates:
         *  Switch: '<S878>/Switch1'
         *  UnitDelay: '<S878>/Unit Delay'
         */
        THMR_ac_DW.UnitDelay_DSTATE_dz = THMR_ac_DW.UnitDelay_DSTATE_eh;
    }

    /* End of Switch: '<S878>/Switch1' */

    /* Update for UnitDelay: '<S878>/Unit Delay' incorporates:
     *  Switch: '<S878>/Switch3'
     */
    THMR_ac_DW.UnitDelay_DSTATE_eh = ((!rtb_TmpSignalConversionAtVeP_el) &&
        rtb_TmpSignalConversionAtVePMTR);

    /* End of Outputs for SubSystem: '<S875>/EdgeRising with resetable delay' */

    /* Switch: '<S875>/Switch1' incorporates:
     *  Logic: '<S875>/OR'
     *  Logic: '<S875>/OR1'
     *  Switch: '<S877>/Switch1'
     */
    if ((!rtb_TmpSignalConversionAtVePMTR) || rtb_Gain_pg)
    {
        /* Sum: '<S792>/Sum1' incorporates:
         *  Constant: '<S875>/Constant Value1'
         */
        rtb_Switch_i3 = 0U;
    }
    else
    {
        if (rtb_TmpSignalConversionAtVeP_el)
        {
            /* Switch: '<S877>/Switch1' incorporates:
             *  Constant: '<S875>/Constant Value'
             *  Constant: '<S875>/Constant1'
             *  Sum: '<S875>/Summation'
             */
            rtb_Switch_i3 = 1U;
        }
        else
        {
            /* Sum: '<S875>/Summation' incorporates:
             *  Constant: '<S875>/Constant Value'
             *  Switch: '<S877>/Switch1'
             *  UnitDelay: '<S877>/Unit Delay'
             */
            rtb_Switch_i3 = (uint16)(((uint32)THMR_ac_DW.UnitDelay_DSTATE_cfc) +
                1U);
        }

        /* MinMax: '<S875>/Minimum' incorporates:
         *  Constant: '<S872>/Calib'
         */
        if (KeTHMR_Cnt_FCAirflwStblzDbnc < rtb_Switch_i3)
        {
            /* Sum: '<S792>/Sum1' */
            rtb_Switch_i3 = KeTHMR_Cnt_FCAirflwStblzDbnc;
        }

        /* End of MinMax: '<S875>/Minimum' */
    }

    /* End of Switch: '<S875>/Switch1' */

    /* Switch: '<S877>/Switch3' */
    if (rtb_TmpSignalConversionAtVeP_el)
    {
        /* Update for UnitDelay: '<S877>/Unit Delay' incorporates:
         *  Constant: '<S875>/Constant1'
         */
        THMR_ac_DW.UnitDelay_DSTATE_cfc = 0U;
    }
    else
    {
        /* Update for UnitDelay: '<S877>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_cfc = rtb_Switch_i3;
    }

    /* End of Switch: '<S877>/Switch3' */

    /* Logic: '<S853>/LogicalOperator' incorporates:
     *  Constant: '<S868>/Constant'
     *  Constant: '<S869>/Constant'
     *  Constant: '<S872>/Calib'
     *  Logic: '<S853>/LogicalOperator1'
     *  Logic: '<S875>/AND'
     *  RelationalOperator: '<S853>/RelationalOperator1'
     *  RelationalOperator: '<S875>/Greater  Than'
     */
    rtb_TmpSignalConversionAtVePMTR = (((((uint32)rtb_Logical17_o_tmp) ==
        CeTHMR_e_FCBoostCool) || (((uint32)rtb_Logical17_o_tmp) ==
        CeTHMR_e_FCPsvCool)) || (rtb_TmpSignalConversionAtVePMTR &&
        (rtb_Switch_i3 >= KeTHMR_Cnt_FCAirflwStblzDbnc)));

    /* End of Outputs for SubSystem: '<S853>/Turn On Delay Sample Resetable Delay' */

    /* Outputs for Atomic SubSystem: '<S856>/EdgeRising' */
    /* Logic: '<S880>/OR1' incorporates:
     *  UnitDelay: '<S880>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeP_el = !THMR_ac_DW.UnitDelay_DSTATE_bs;

    /* Update for UnitDelay: '<S880>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_bs = rtb_TmpSignalConversionAtVePMTR;

    /* Outputs for Atomic SubSystem: '<S856>/PIDControl' */
    /* Switch: '<S887>/Switch' incorporates:
     *  Constant: '<S856>/Constant4'
     *  Delay: '<S730>/Delay'
     *  Logic: '<S856>/LogicalOperator'
     *  Logic: '<S880>/AND'
     *  RelationalOperator: '<S856>/RelationalOperator'
     *  Switch: '<S887>/Switch2'
     */
    if (rtb_TmpSignalConversionAtVePMTR && rtb_TmpSignalConversionAtVeP_el)
    {
        /* Switch: '<S887>/Switch' incorporates:
         *  Constant: '<S881>/Calib'
         */
        rtb_Switch_eu = KeTHMR_dV_HTRAirflow_PID_Init;
    }
    else
    {
        if ((THMR_ac_DW.Delay_DSTATE_g) && (rtb_TmpSignalConversionAtVePM_n >
                0.0F))
        {
            /* Switch: '<S887>/Switch2' incorporates:
             *  Constant: '<S887>/Constant'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S887>/Switch2' incorporates:
             *  Constant: '<S856>/Constant1'
             *  Lookup_n-D: '<S885>/Vector'
             *  Product: '<S887>/Multiplication1'
             *  SignalConversion generated from: '<S2>/VeFCPR_I_FCPS_Curr'
             *  Sum: '<S722>/Subtraction9'
             */
            rtb_Switch10 = (rtb_TmpSignalConversionAtVePM_n *
                            look2_iflf_binlcapw(rtb_TmpSignalConversionAtVeBTRR,
                             rtb_TmpSignalConversionAtVeFC_p, ((const float32 *)
                              &(KxTHMR_k_FCAirflw_Ki[0])), ((const float32 *)
                              &(KyTHMR_k_FCAirflw_Ki[0])), ((const float32 *)
                              &(KtTHMR_k_FCAirflw_Ki[0])),
                             THMR_ac_ConstP.pooled41, 4U)) * 0.1F;
        }

        /* Switch: '<S887>/Switch' incorporates:
         *  Sum: '<S887>/Sum//Sub'
         *  UnitDelay: '<S887>/UnitDelay'
         */
        rtb_Switch_eu = rtb_Switch10 + THMR_ac_DW.UnitDelay_DSTATE_m5;
    }

    /* End of Switch: '<S887>/Switch' */
    /* End of Outputs for SubSystem: '<S856>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S887>/integral_term' */
    /* Switch: '<S888>/Switch1' incorporates:
     *  Constant: '<S882>/Calib'
     *  RelationalOperator: '<S888>/RelationalOperator'
     */
    if (KeTHMR_dV_MaxHTRAirflow < rtb_Switch_eu)
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = KeTHMR_dV_MaxHTRAirflow;
    }
    else
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = rtb_Switch_eu;
    }

    /* End of Switch: '<S888>/Switch1' */

    /* Switch: '<S888>/Switch' incorporates:
     *  Constant: '<S883>/Calib'
     *  RelationalOperator: '<S888>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTA_n > KeTHMR_dV_MinHTRAirflow_PID)
    {
        /* Switch: '<S888>/Switch' */
        rtb_Switch_eu = rtb_TmpSignalConversionAtVeTA_n;
    }
    else
    {
        /* Switch: '<S888>/Switch' */
        rtb_Switch_eu = KeTHMR_dV_MinHTRAirflow_PID;
    }

    /* End of Switch: '<S888>/Switch' */
    /* End of Outputs for SubSystem: '<S887>/integral_term' */

    /* Switch: '<S887>/Switch1' */
    if (rtb_TmpSignalConversionAtVePMTR)
    {
        /* Switch: '<S887>/Switch1' incorporates:
         *  Constant: '<S856>/Constant1'
         *  Constant: '<S884>/Calib'
         *  Lookup_n-D: '<S886>/Vector'
         *  Product: '<S887>/Multiplication2'
         *  Product: '<S887>/derivative_term'
         *  Product: '<S887>/proportional_term'
         *  SignalConversion generated from: '<S2>/VeFCPR_I_FCPS_Curr'
         *  Sum: '<S722>/Subtraction9'
         *  Sum: '<S887>/Sum//Sub1'
         *  Sum: '<S887>/Sum//Sub2'
         *  UnitDelay: '<S887>/UnitDelay1'
         */
        VeTHMR_dV_FCAirflw_ClsLp_PID = (((rtb_TmpSignalConversionAtVePM_n -
            THMR_ac_DW.UnitDelay1_DSTATE_iz) * KeTHMR_k_FCAirflw_Kd) / 0.1F) +
            ((rtb_TmpSignalConversionAtVePM_n * look2_iflf_binlcapw
              (rtb_TmpSignalConversionAtVeBTRR, rtb_TmpSignalConversionAtVeFC_p,
               ((const float32 *)&(KxTHMR_k_FCAirflw_Kp[0])), ((const float32 *)
                &(KyTHMR_k_FCAirflw_Kp[0])), ((const float32 *)
                &(KtTHMR_k_FCAirflw_Kp[0])), THMR_ac_ConstP.pooled41, 4U)) +
             rtb_Switch_eu);
    }
    else
    {
        /* Switch: '<S887>/Switch1' incorporates:
         *  UnitDelay: '<S887>/UnitDelay2'
         */
        VeTHMR_dV_FCAirflw_ClsLp_PID = THMR_ac_DW.UnitDelay2_DSTATE_pk;
    }

    /* End of Switch: '<S887>/Switch1' */

    /* Update for UnitDelay: '<S887>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_iz = rtb_TmpSignalConversionAtVePM_n;

    /* Update for UnitDelay: '<S887>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_m5 = rtb_Switch_eu;

    /* Update for UnitDelay: '<S887>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_pk = VeTHMR_dV_FCAirflw_ClsLp_PID;

    /* End of Outputs for SubSystem: '<S856>/PIDControl' */

    /* Sum: '<S730>/Subtraction11' */
    rtb_TmpSignalConversionAtVeFC_p = VeTHMR_dV_FC_HTR_AirFlow_Raw +
        VeTHMR_dV_FCAirflw_ClsLp_PID;

    /* Switch: '<S857>/Switch1' */
    if (rtb_TmpSignalConversionAtVePMTR)
    {
        /* Lookup_n-D: '<S864>/Vector' incorporates:
         *  SignalConversion generated from: '<S2>/VeCSVR_v_VehSpd'
         */
        rtb_TmpSignalConversionAtVePM_n = look1_iflf_binlcapw
            (rtb_TmpSignalConversionAtVeCSVR, ((const float32 *)
              &(KxTHMR_dV_MaxHTRAirflow[0])), ((const float32 *)
              &(KtTHMR_dV_MaxHTRAirflow[0])), 4U);

        /* Outputs for Atomic SubSystem: '<S730>/Limiter1' */
        /* Switch: '<S865>/Switch1' incorporates:
         *  RelationalOperator: '<S865>/RelationalOperator'
         */
        if (rtb_TmpSignalConversionAtVePM_n >= rtb_TmpSignalConversionAtVeFC_p)
        {
            /* Switch: '<S865>/Switch1' */
            rtb_TmpSignalConversionAtVePM_n = rtb_TmpSignalConversionAtVeFC_p;
        }

        /* End of Switch: '<S865>/Switch1' */

        /* Switch: '<S865>/Switch' incorporates:
         *  Constant: '<S730>/Constant1'
         *  RelationalOperator: '<S865>/RelationalOperator1'
         */
        if (rtb_TmpSignalConversionAtVePM_n > 0.0F)
        {
            /* Switch: '<S857>/Switch1' */
            VeTHMR_dV_FC_HTR_AirFlow_Need = rtb_TmpSignalConversionAtVePM_n;
        }
        else
        {
            /* Switch: '<S857>/Switch1' */
            VeTHMR_dV_FC_HTR_AirFlow_Need = 0.0F;
        }

        /* End of Switch: '<S865>/Switch' */
        /* End of Outputs for SubSystem: '<S730>/Limiter1' */
    }
    else
    {
        /* Switch: '<S857>/Switch1' incorporates:
         *  Constant: '<S730>/Constant4'
         */
        VeTHMR_dV_FC_HTR_AirFlow_Need = 0.0F;
    }

    /* End of Switch: '<S857>/Switch1' */

    /* Logic: '<S789>/LogicalOperator1' incorporates:
     *  Constant: '<S793>/Constant'
     *  Constant: '<S794>/Constant'
     *  Constant: '<S795>/Constant'
     *  Constant: '<S800>/Calib'
     *  Constant: '<S807>/Calib'
     *  Constant: '<S808>/Calib'
     *  Logic: '<S789>/LogicalOperator'
     *  Logic: '<S789>/LogicalOperator2'
     *  RelationalOperator: '<S789>/RelationalOperator1'
     *  RelationalOperator: '<S789>/RelationalOperator2'
     *  RelationalOperator: '<S789>/RelationalOperator3'
     *  RelationalOperator: '<S789>/RelationalOperator4'
     */
    rtb_TmpSignalConversionAtVePMTR = ((((((rtb_Switch1_p1 && rtb_Switch1_hj) &&
        (!rtb_Switch1_cys)) && (VeTHMR_dV_FC_HTR_AirFlow_Need >=
        KeTHMR_dV_FCSAirflwReq_FCSDerate)) && (THMR_ac_B.Merge1_l <=
        KeTHMR_Pct_FCSVlvReq_FCSDerate)) && (((((uint32)rtb_Logical17_o_tmp) ==
        CeTHMR_e_FCBoostCool) || (((uint32)rtb_Logical17_o_tmp) ==
        CeTHMR_e_FCPsvCool)) || (((uint32)rtb_Logical17_o_tmp) ==
        CeTHMR_e_FCStabilize))) && (rtb_Merge1 >=
        KeTHMR_dV_FCSClntflwReq_FCSDerate));

    /* Outputs for Atomic SubSystem: '<S789>/Debounce1' */
    /* Outputs for Atomic SubSystem: '<S792>/EdgeBi' */
    /* RelationalOperator: '<S809>/NotEqual' incorporates:
     *  UnitDelay: '<S809>/UnitDelay'
     */
    rtb_Switch1_p1 = (rtb_TmpSignalConversionAtVePMTR !=
                      THMR_ac_DW.UnitDelay_DSTATE_jg);

    /* Update for UnitDelay: '<S809>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_jg = rtb_TmpSignalConversionAtVePMTR;

    /* End of Outputs for SubSystem: '<S792>/EdgeBi' */

    /* Logic: '<S792>/Logical1' incorporates:
     *  UnitDelay: '<S792>/UnitDelay1'
     */
    rtb_Switch1_hj = (rtb_Switch1_p1 || (THMR_ac_DW.UnitDelay1_DSTATE_k5));

    /* Outputs for Atomic SubSystem: '<S792>/SignalLatchOnWithReset1' */
    /* Logic: '<S810>/OR1' incorporates:
     *  Logic: '<S810>/NOT'
     *  Logic: '<S810>/OR'
     *  UnitDelay: '<S792>/UnitDelay3'
     *  UnitDelay: '<S810>/UnitDelay'
     */
    rtb_Switch1_cys = ((THMR_ac_DW.UnitDelay3_DSTATE_h) || ((!rtb_Switch1_hj) &&
                        (THMR_ac_DW.UnitDelay_DSTATE_dr)));

    /* Update for UnitDelay: '<S810>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_dr = rtb_Switch1_cys;

    /* End of Outputs for SubSystem: '<S792>/SignalLatchOnWithReset1' */

    /* Switch: '<S812>/Init' incorporates:
     *  Constant: '<S812>/InitialCondition'
     *  Logic: '<S812>/FixPtLogicalOperator'
     *  Logic: '<S812>/Logical2'
     *  UnitDelay: '<S812>/FixPtUnitDelay1'
     *  UnitDelay: '<S812>/FixPtUnitDelay2'
     */
    if (rtb_Switch1_hj || (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_n) == 0))
    {
        rtb_Switch_i3 = 0U;
    }
    else
    {
        rtb_Switch_i3 = THMR_ac_DW.FixPtUnitDelay1_DSTATE_d;
    }

    /* End of Switch: '<S812>/Init' */

    /* Sum: '<S792>/Sum1' incorporates:
     *  Switch: '<S792>/Switch2'
     */
    rtb_Switch_i3 = (uint16)(((uint32)(rtb_Switch1_cys ? 1U : 0U)) + ((uint32)
        rtb_Switch_i3));

    /* RelationalOperator: '<S792>/Equal1' incorporates:
     *  Constant: '<S799>/Calib'
     */
    rtb_Switch1_cys = (((float32)rtb_Switch_i3) >= KeTHMR_Cnt_FCSDerateDebounce);

    /* Switch: '<S792>/Switch' */
    if (!rtb_Switch1_cys)
    {
        /* Switch: '<S811>/Init' incorporates:
         *  Logic: '<S811>/Logical2'
         *  UnitDelay: '<S811>/FixPtUnitDelay2'
         */
        if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_ga) != 0)
        {
            /* Switch: '<S792>/Switch' incorporates:
             *  UnitDelay: '<S811>/FixPtUnitDelay1'
             */
            rtb_TmpSignalConversionAtVePMTR =
                THMR_ac_DW.FixPtUnitDelay1_DSTATE_n;
        }

        /* End of Switch: '<S811>/Init' */
    }

    /* End of Switch: '<S792>/Switch' */

    /* Update for UnitDelay: '<S792>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_h = rtb_Switch1_p1;

    /* Update for UnitDelay: '<S792>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_k5 = rtb_Switch1_cys;

    /* Update for UnitDelay: '<S812>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S812>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_n = 1U;

    /* Switch: '<S812>/Reset' */
    if (rtb_Switch1_hj)
    {
        /* Update for UnitDelay: '<S812>/FixPtUnitDelay1' incorporates:
         *  Constant: '<S812>/InitialCondition'
         */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_d = 0U;
    }
    else
    {
        /* Update for UnitDelay: '<S812>/FixPtUnitDelay1' */
        THMR_ac_DW.FixPtUnitDelay1_DSTATE_d = rtb_Switch_i3;
    }

    /* End of Switch: '<S812>/Reset' */

    /* Update for UnitDelay: '<S811>/FixPtUnitDelay2' incorporates:
     *  Constant: '<S811>/FixPtConstant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_ga = 1U;

    /* Update for UnitDelay: '<S811>/FixPtUnitDelay1' */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE_n = rtb_TmpSignalConversionAtVePMTR;

    /* End of Outputs for SubSystem: '<S789>/Debounce1' */

    /* Outputs for Enabled SubSystem: '<S791>/Enabled Subsystem' incorporates:
     *  EnablePort: '<S814>/Enable'
     */
    if (rtb_TmpSignalConversionAtVePMTR)
    {
        /* Inport: '<S814>/FCS_ActualPwr' */
        THMR_ac_B.FCS_ActualPwr = rtb_TmpSignalConversionAtVeFCPR;
    }

    /* End of Outputs for SubSystem: '<S791>/Enabled Subsystem' */

    /* Outputs for Atomic SubSystem: '<S815>/EdgeRising' */
    /* Logic: '<S826>/OR1' incorporates:
     *  UnitDelay: '<S826>/Unit Delay'
     */
    rtb_Switch1_p1 = !THMR_ac_DW.UnitDelay_DSTATE_a1;

    /* Update for UnitDelay: '<S826>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_a1 = rtb_TmpSignalConversionAtVePMTR;

    /* End of Outputs for SubSystem: '<S815>/EdgeRising' */

    /* Sum: '<S791>/Subtraction1' incorporates:
     *  Constant: '<S821>/Calib'
     */
    rtb_TmpSignalConversionAtVeBTRR = VeTHMR_dT_FCSDerate_Error -
        KeTHMR_dT_FCClntErrTgt_FCSDerate;

    /* Product: '<S791>/Product1' incorporates:
     *  Lookup_n-D: '<S822>/Vector'
     *  SignalConversion generated from: '<S2>/VeFCPR_T_FCPS_HTCoolOutTemp'
     */
    rtb_TmpSignalConversionAtVePM_n = look1_iflf_binlcapw
        (rtb_TmpSignalConversionAtVeF_n4, ((const float32 *)
          &(KxTHMR_K_MaxFCSDerateFctr[0])), ((const float32 *)
          &(KtTHMR_K_MaxFCSDerateFctr[0])), 6U) *
        rtb_TmpSignalConversionAtVeF_l2;

    /* MinMax: '<S791>/MinMax' incorporates:
     *  Constant: '<S817>/Calib'
     *  Lookup_n-D: '<S823>/Vector'
     *  Product: '<S791>/Product2'
     *  SignalConversion generated from: '<S2>/VeFCPR_T_FCPS_HTCoolOutTemp'
     */
    rtb_Switch_eu = fmaxf(look1_iflf_binlcapw(rtb_TmpSignalConversionAtVeF_n4,
                           ((const float32 *)&(KxTHMR_K_MinFCSDerateFctr[0])),
                           ((const float32 *)&(KtTHMR_K_MinFCSDerateFctr[0])),
                           6U) * rtb_TmpSignalConversionAtVeF_l2,
                          KeTHMR_P_MinAllwdFCSDeratePwr);

    /* Outputs for Atomic SubSystem: '<S815>/PIDControl' */
    /* Outputs for Atomic SubSystem: '<S815>/EdgeRising' */
    /* Switch: '<S831>/Switch' incorporates:
     *  Constant: '<S815>/Constant1'
     *  Logic: '<S815>/LogicalOperator1'
     *  Logic: '<S826>/AND'
     *  RelationalOperator: '<S815>/RelationalOperator1'
     *  Switch: '<S831>/Switch2'
     *  UnitDelay: '<S791>/Unit Delay'
     */
    if (rtb_TmpSignalConversionAtVePMTR && rtb_Switch1_p1)
    {
        /* Switch: '<S831>/Switch' incorporates:
         *  Constant: '<S830>/Calib'
         */
        rtb_TmpSignalConversionAtVeTM_f = KeTHMR_P_FCSDeratePwr_IV;
    }
    else
    {
        if ((THMR_ac_DW.UnitDelay_DSTATE_h5) && (rtb_TmpSignalConversionAtVeBTRR
             > 0.0F))
        {
            /* Switch: '<S831>/Switch2' incorporates:
             *  Constant: '<S831>/ConstantValue1'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S831>/Switch2' incorporates:
             *  Constant: '<S815>/Constant4'
             *  Constant: '<S828>/Calib'
             *  Product: '<S831>/Multiplication1'
             */
            rtb_Switch10 = (rtb_TmpSignalConversionAtVeBTRR *
                            KeTHMR_K_FCSDerateKi) * 0.1F;
        }

        /* Switch: '<S831>/Switch' incorporates:
         *  Sum: '<S831>/Sum//Sub'
         *  UnitDelay: '<S831>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeTM_f = rtb_Switch10 +
            THMR_ac_DW.UnitDelay_DSTATE_ki;
    }

    /* End of Switch: '<S831>/Switch' */
    /* End of Outputs for SubSystem: '<S815>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S831>/integral_term' */
    /* Switch: '<S832>/Switch1' incorporates:
     *  RelationalOperator: '<S832>/RelationalOperator'
     */
    if (rtb_TmpSignalConversionAtVePM_n < rtb_TmpSignalConversionAtVeTM_f)
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = rtb_TmpSignalConversionAtVePM_n;
    }
    else
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = rtb_TmpSignalConversionAtVeTM_f;
    }

    /* End of Switch: '<S832>/Switch1' */

    /* Switch: '<S832>/Switch' incorporates:
     *  RelationalOperator: '<S832>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTA_n > rtb_Switch_eu)
    {
        /* Switch: '<S832>/Switch' */
        rtb_TmpSignalConversionAtVeT_dg = rtb_TmpSignalConversionAtVeTA_n;
    }
    else
    {
        /* Switch: '<S832>/Switch' */
        rtb_TmpSignalConversionAtVeT_dg = rtb_Switch_eu;
    }

    /* End of Switch: '<S832>/Switch' */
    /* End of Outputs for SubSystem: '<S831>/integral_term' */

    /* Switch: '<S831>/Switch1' */
    if (rtb_TmpSignalConversionAtVePMTR)
    {
        /* Switch: '<S831>/Switch1' incorporates:
         *  Constant: '<S815>/Constant4'
         *  Constant: '<S827>/Calib'
         *  Constant: '<S829>/Calib'
         *  Product: '<S831>/Multiplication2'
         *  Product: '<S831>/derivative_term'
         *  Product: '<S831>/proportional_term'
         *  Sum: '<S831>/Sum//Sub1'
         *  Sum: '<S831>/Sum//Sub2'
         *  UnitDelay: '<S831>/UnitDelay1'
         */
        rtb_TmpSignalConversionAtVeTM_f = (((rtb_TmpSignalConversionAtVeBTRR -
            THMR_ac_DW.UnitDelay1_DSTATE_bl) * KeTHMR_K_FCSDerateKd) / 0.1F) +
            ((rtb_TmpSignalConversionAtVeBTRR * KeTHMR_K_FCSDerateKp) +
             rtb_TmpSignalConversionAtVeT_dg);
    }
    else
    {
        /* Switch: '<S831>/Switch1' incorporates:
         *  UnitDelay: '<S831>/UnitDelay2'
         */
        rtb_TmpSignalConversionAtVeTM_f = THMR_ac_DW.UnitDelay2_DSTATE_oz;
    }

    /* End of Switch: '<S831>/Switch1' */

    /* Update for UnitDelay: '<S831>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_bl = rtb_TmpSignalConversionAtVeBTRR;

    /* Update for UnitDelay: '<S831>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ki = rtb_TmpSignalConversionAtVeT_dg;

    /* Update for UnitDelay: '<S831>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_oz = rtb_TmpSignalConversionAtVeTM_f;

    /* End of Outputs for SubSystem: '<S815>/PIDControl' */

    /* Logic: '<S816>/LogicalOperator' incorporates:
     *  Constant: '<S816>/Constant4'
     *  Logic: '<S816>/LogicalOperator1'
     *  RelationalOperator: '<S816>/RelationalOperator2'
     *  UnitDelay: '<S816>/Unit Delay'
     */
    rtb_Switch1_p1 = (((!THMR_ac_DW.UnitDelay_DSTATE_nns) &&
                       (rtb_TmpSignalConversionAtVeBTRR >= 0.0F)) &&
                      rtb_TmpSignalConversionAtVePMTR);

    /* Outputs for Atomic SubSystem: '<S816>/EdgeRising' */
    /* Logic: '<S834>/AND' incorporates:
     *  Logic: '<S834>/OR1'
     *  UnitDelay: '<S834>/Unit Delay'
     */
    rtb_Switch1_hj = (rtb_Switch1_p1 && (!THMR_ac_DW.UnitDelay_DSTATE_ln));

    /* Update for UnitDelay: '<S834>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_ln = rtb_Switch1_p1;

    /* End of Outputs for SubSystem: '<S816>/EdgeRising' */

    /* Outputs for Enabled SubSystem: '<S816>/DeratePwr' incorporates:
     *  EnablePort: '<S833>/Enable'
     */
    if (rtb_Switch1_hj)
    {
        /* Inport: '<S833>/Input_Parameter' incorporates:
         *  Lookup_n-D: '<S837>/Vector'
         *  Sum: '<S791>/Subtraction1'
         *  Sum: '<S816>/Add'
         */
        THMR_ac_B.Input_Parameter = rtb_TmpSignalConversionAtVeFCPR -
            look1_iflf_binlcapw(rtb_TmpSignalConversionAtVeBTRR, ((const float32
            *)&(KxTHMR_Pct_FC_VlvFdpPosPct[0])), ((const float32 *)
            &(KtTHMR_Pct_FC_VlvFdpPosPct[0])), 8U);
    }

    /* End of Outputs for SubSystem: '<S816>/DeratePwr' */

    /* Outputs for Atomic SubSystem: '<S816>/Timer Reset Enabled' */
    /* Switch: '<S838>/Switch1' incorporates:
     *  Constant: '<S838>/Constant Value3'
     *  Logic: '<S838>/AND1'
     *  RelationalOperator: '<S838>/Greater  Than2'
     *  UnitDelay: '<S838>/Unit Delay'
     */
    if (rtb_Switch1_hj && (THMR_ac_DW.UnitDelay_DSTATE_gw <= 0.0F))
    {
        /* Switch: '<S838>/Switch1' incorporates:
         *  Constant: '<S836>/Calib'
         */
        rtb_TmpSignalConversionAtVeBTRR = KeTHMR_P_MinAllwdFCSDeratePwr;
    }
    else
    {
        /* Switch: '<S838>/Switch1' incorporates:
         *  Constant: '<S816>/Constant1'
         *  Constant: '<S838>/Constant Value4'
         *  MinMax: '<S838>/Maximum'
         *  Sum: '<S838>/Subtraction'
         */
        rtb_TmpSignalConversionAtVeBTRR = fmaxf(THMR_ac_DW.UnitDelay_DSTATE_gw -
            0.1F, 0.0F);
    }

    /* End of Switch: '<S838>/Switch1' */

    /* Update for UnitDelay: '<S838>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_gw = rtb_TmpSignalConversionAtVeBTRR;

    /* End of Outputs for SubSystem: '<S816>/Timer Reset Enabled' */

    /* Switch: '<S791>/Switch2' incorporates:
     *  Constant: '<S819>/Calib'
     *  Constant: '<S820>/Calib'
     *  Switch: '<S791>/Switch1'
     */
    if (KeTHMR_b_FCSDerate_AppSel)
    {
        /* Switch: '<S835>/Switch1' */
        if (rtb_TmpSignalConversionAtVePMTR)
        {
            /* Switch: '<S791>/Switch2' */
            rtb_TmpSignalConversionAtVeF_l2 = THMR_ac_B.Input_Parameter;
        }
        else
        {
            /* Switch: '<S791>/Switch2' incorporates:
             *  Constant: '<S836>/Calib'
             */
            rtb_TmpSignalConversionAtVeF_l2 = KeTHMR_P_MinAllwdFCSDeratePwr;
        }

        /* End of Switch: '<S835>/Switch1' */
    }
    else
    {
        if (KeTHMR_b_FCSDerationPwrSel)
        {
            /* Switch: '<S791>/Switch1' */
            rtb_TmpSignalConversionAtVeF_l2 = THMR_ac_B.FCS_ActualPwr;
        }

        /* Switch: '<S791>/Switch2' incorporates:
         *  Sum: '<S791>/Subtraction2'
         */
        rtb_TmpSignalConversionAtVeF_l2 -= rtb_TmpSignalConversionAtVeTM_f;
    }

    /* End of Switch: '<S791>/Switch2' */

    /* Sum: '<S727>/Subtraction2' incorporates:
     *  Constant: '<S839>/Calib'
     */
    rtb_TmpSignalConversionAtVeTM_f = KeTHMR_dT_FCCTOSTgtHTCLTgt_Max +
        rtb_TmpSignalConversionAtVeFCRR;

    /* Sum: '<S727>/Subtraction1' incorporates:
     *  Constant: '<S840>/Calib'
     */
    rtb_TmpSignalConversionAtVeT_dg = rtb_TmpSignalConversionAtVeFCRR -
        KeTHMR_dT_FCCTOSTgtHTCLTgt_Min;

    /* Sum: '<S735>/Subtraction14' incorporates:
     *  Product: '<S735>/Product10'
     *  Product: '<S735>/Product11'
     */
    rtb_TmpSignalConversionAtVeTR_p = (rtb_Merge1 *
        rtb_TmpSignalConversionAtVeTR_p) - (rtb_TmpSignalConversionAtVeBT_o *
        rtb_TmpSignalConversionAtVeF_n4);

    /* Product: '<S736>/Product9' incorporates:
     *  Constant: '<S893>/Calib'
     */
    rtb_Product9 = rtb_Merge1 * KeTHMR_K_FCWCACBrnchFlwRatio;

    /* Outputs for Atomic SubSystem: '<S736>/Limiter3' */
    /* Switch: '<S895>/Switch1' incorporates:
     *  Constant: '<S894>/Calib'
     *  RelationalOperator: '<S895>/RelationalOperator'
     */
    if (KeTHMR_dV_MaxFCWCACBrnchFlw < rtb_Product9)
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = KeTHMR_dV_MaxFCWCACBrnchFlw;
    }
    else
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = rtb_Product9;
    }

    /* End of Switch: '<S895>/Switch1' */

    /* Switch: '<S895>/Switch' incorporates:
     *  Constant: '<S736>/Constant2'
     *  RelationalOperator: '<S895>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTA_n > 0.0F)
    {
        /* Switch: '<S895>/Switch' */
        rtb_Product9 = rtb_TmpSignalConversionAtVeTA_n;
    }
    else
    {
        /* Switch: '<S895>/Switch' */
        rtb_Product9 = 0.0F;
    }

    /* End of Switch: '<S895>/Switch' */
    /* End of Outputs for SubSystem: '<S736>/Limiter3' */

    /* Outputs for Atomic SubSystem: '<S735>/ProtectedDivision3' */
    /* Switch: '<S892>/Switch1' incorporates:
     *  Constant: '<S892>/ConstantValue'
     *  Constant: '<S892>/ConstantValue1'
     *  Constant: '<S892>/ConstantValue2'
     *  Constant: '<S892>/ConstantValue3'
     *  Logic: '<S892>/AND'
     *  RelationalOperator: '<S892>/GreaterThanorEqual'
     *  RelationalOperator: '<S892>/GreaterThanorEqual1'
     *  RelationalOperator: '<S892>/NotEqual'
     *  RelationalOperator: '<S892>/NotEqual1'
     *  Switch: '<S892>/Switch2'
     *  Switch: '<S892>/Switch3'
     */
    if ((rtb_TmpSignalConversionAtVeTR_p != 0.0F) && (rtb_Product9 != 0.0F))
    {
        /* Switch: '<S892>/Switch1' incorporates:
         *  Product: '<S892>/Division'
         */
        rtb_TmpSignalConversionAtVeTR_p /= rtb_Product9;
    }
    else if (rtb_TmpSignalConversionAtVeTR_p > 0.0F)
    {
        /* Switch: '<S892>/Switch2' incorporates:
         *  Constant: '<S892>/MAXFLOAT'
         *  Switch: '<S892>/Switch1'
         */
        rtb_TmpSignalConversionAtVeTR_p = 3.402823466E+38F;
    }
    else if (rtb_TmpSignalConversionAtVeTR_p < 0.0F)
    {
        /* Switch: '<S892>/Switch3' incorporates:
         *  Constant: '<S892>/MINFLOAT'
         *  Switch: '<S892>/Switch1'
         *  Switch: '<S892>/Switch2'
         */
        rtb_TmpSignalConversionAtVeTR_p = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S892>/Switch1' incorporates:
         *  Constant: '<S892>/ConstantValue4'
         *  Switch: '<S892>/Switch2'
         *  Switch: '<S892>/Switch3'
         */
        rtb_TmpSignalConversionAtVeTR_p = 0.0F;
    }

    /* End of Switch: '<S892>/Switch1' */
    /* End of Outputs for SubSystem: '<S735>/ProtectedDivision3' */

    /* Sum: '<S727>/Subtraction16' incorporates:
     *  Product: '<S727>/Product12'
     *  Product: '<S727>/Product13'
     */
    rtb_TmpSignalConversionAtVeFCRR = (rtb_TmpSignalConversionAtVeBT_o *
        rtb_TmpSignalConversionAtVeFCRR) + (rtb_TmpSignalConversionAtVeTR_p *
        rtb_Product9);

    /* Outputs for Atomic SubSystem: '<S727>/ProtectedDivision4' */
    /* Switch: '<S842>/Switch1' incorporates:
     *  Constant: '<S842>/ConstantValue'
     *  Constant: '<S842>/ConstantValue1'
     *  Constant: '<S842>/ConstantValue2'
     *  Constant: '<S842>/ConstantValue3'
     *  Logic: '<S842>/AND'
     *  RelationalOperator: '<S842>/GreaterThanorEqual'
     *  RelationalOperator: '<S842>/GreaterThanorEqual1'
     *  RelationalOperator: '<S842>/NotEqual'
     *  RelationalOperator: '<S842>/NotEqual1'
     *  Switch: '<S842>/Switch2'
     *  Switch: '<S842>/Switch3'
     */
    if ((rtb_TmpSignalConversionAtVeFCRR != 0.0F) && (rtb_Merge1 != 0.0F))
    {
        /* Switch: '<S842>/Switch1' incorporates:
         *  Product: '<S842>/Division'
         */
        rtb_TmpSignalConversionAtVeFCRR /= rtb_Merge1;
    }
    else if (rtb_TmpSignalConversionAtVeFCRR > 0.0F)
    {
        /* Switch: '<S842>/Switch2' incorporates:
         *  Constant: '<S842>/MAXFLOAT'
         *  Switch: '<S842>/Switch1'
         */
        rtb_TmpSignalConversionAtVeFCRR = 3.402823466E+38F;
    }
    else if (rtb_TmpSignalConversionAtVeFCRR < 0.0F)
    {
        /* Switch: '<S842>/Switch3' incorporates:
         *  Constant: '<S842>/MINFLOAT'
         *  Switch: '<S842>/Switch1'
         *  Switch: '<S842>/Switch2'
         */
        rtb_TmpSignalConversionAtVeFCRR = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S842>/Switch1' incorporates:
         *  Constant: '<S842>/ConstantValue4'
         *  Switch: '<S842>/Switch2'
         *  Switch: '<S842>/Switch3'
         */
        rtb_TmpSignalConversionAtVeFCRR = 0.0F;
    }

    /* End of Switch: '<S842>/Switch1' */
    /* End of Outputs for SubSystem: '<S727>/ProtectedDivision4' */
    /* End of Outputs for SubSystem: '<S2>/FC_Loop' */

    /* Inport: '<Root>/VeTRIR_b_HeatExCool_TmpOut_FA' */
    (void)Rte_Read_VeTRIR_b_HeatExCool_TmpOut_FA_Value
        (&rtb_RelationalOperator5_o);

    /* Outputs for Function Call SubSystem: '<S2>/FC_Loop' */
    /* Outputs for Atomic SubSystem: '<S727>/Limiter1' */
    /* Switch: '<S841>/Switch1' incorporates:
     *  RelationalOperator: '<S841>/RelationalOperator'
     */
    if (rtb_TmpSignalConversionAtVeTM_f < rtb_TmpSignalConversionAtVeFCRR)
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = rtb_TmpSignalConversionAtVeTM_f;
    }
    else
    {
        /* Switch: '<S904>/Switch3' */
        rtb_TmpSignalConversionAtVeTA_n = rtb_TmpSignalConversionAtVeFCRR;
    }

    /* End of Switch: '<S841>/Switch1' */

    /* Switch: '<S841>/Switch' incorporates:
     *  RelationalOperator: '<S841>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTA_n > rtb_TmpSignalConversionAtVeT_dg)
    {
        rtb_TmpSignalConversionAtVeT_dg = rtb_TmpSignalConversionAtVeTA_n;
    }

    /* End of Switch: '<S841>/Switch' */
    /* End of Outputs for SubSystem: '<S727>/Limiter1' */

    /* If: '<S729>/FCL_HeatOffset' incorporates:
     *  Constant: '<S846>/Constant'
     *  Constant: '<S847>/Constant'
     *  Constant: '<S848>/Constant'
     *  Constant: '<S851>/Calib'
     *  Constant: '<S852>/Calib'
     *  RelationalOperator: '<S729>/RelationalOperator2'
     *  RelationalOperator: '<S729>/RelationalOperator3'
     *  SignalConversion generated from: '<S848>/Clsd'
     *  SignalConversion generated from: '<S849>/Offset_Stblz'
     *  SignalConversion generated from: '<S850>/Offset_Wrmup'
     */
    if (((uint32)rtb_Logical17_o_tmp) == CeTHMR_e_FCActvPsvHeat)
    {
        /* Outputs for IfAction SubSystem: '<S729>/FCL_HeatOffset_Wrmup' incorporates:
         *  ActionPort: '<S850>/ActionPort'
         */
        rtb_Switch10 = KeTHMR_dT_HexTempGrdOffset_Wrmup;

        /* End of Outputs for SubSystem: '<S729>/FCL_HeatOffset_Wrmup' */
    }
    else if (((uint32)rtb_Logical17_o_tmp) == CeTHMR_e_FCStabilize)
    {
        /* Outputs for IfAction SubSystem: '<S729>/FCL_HeatOffset_Stblz' incorporates:
         *  ActionPort: '<S849>/ActionPort'
         */
        rtb_Switch10 = KeTHMR_dT_HexTempGrdOffset_Stblz;

        /* End of Outputs for SubSystem: '<S729>/FCL_HeatOffset_Stblz' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S729>/FCL_HeatOffset_Dft' incorporates:
         *  ActionPort: '<S848>/ActionPort'
         */
        rtb_Switch10 = 0.0F;

        /* End of Outputs for SubSystem: '<S729>/FCL_HeatOffset_Dft' */
    }

    /* End of If: '<S729>/FCL_HeatOffset' */

    /* Sum: '<S729>/Subtraction17' */
    VeTHMR_T_FC_HTCLTgt_Arb = rtb_TmpSignalConversionAtVeT_dg + rtb_Switch10;

    /* Product: '<S55>/Product1' incorporates:
     *  Constant: '<S55>/Constant2'
     */
    rtb_TmpSignalConversionAtVeFCPR *= 1000.0F;

    /* Outputs for Enabled SubSystem: '<S949>/F02_02_04_04_02_TCoFuCellHiTSigOfs' incorporates:
     *  EnablePort: '<S1001>/Enable'
     */
    /* Constant: '<S1003>/Calib' */
    if (KeTHMR_b_AcvTCoFuCellHiTSigOfs_C)
    {
        /* Product: '<S1001>/Product1' incorporates:
         *  Constant: '<S1001>/Constant2'
         *  Constant: '<S1032>/Calib'
         */
        rtb_TmpSignalConversionAtVeFCRR = KeTHMR_dT_CoFuCellHiTSigOfsInc_C *
            0.1F;

        /* RelationalOperator: '<S1001>/Relational Operator2' incorporates:
         *  Constant: '<S1029>/Calib'
         *  Sum: '<S1001>/Sum1'
         *  UnitDelay: '<S1001>/Unit Delay'
         */
        rtb_Switch1_hj = (THMR_ac_DW.UnitDelay_DSTATE_et3 >=
                          (KeTHMR_T_CoFuCellHiTSigOfs_C -
                           rtb_TmpSignalConversionAtVeFCRR));

        /* Outputs for Atomic SubSystem: '<S1001>/EdgeRising' */
        /* Logic: '<S1027>/AND' incorporates:
         *  Logic: '<S1027>/OR1'
         *  UnitDelay: '<S1027>/Unit Delay'
         */
        rtb_Switch1_p1 = (rtb_Switch1_hj && (!THMR_ac_DW.UnitDelay_DSTATE_myo));

        /* Update for UnitDelay: '<S1027>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_myo = rtb_Switch1_hj;

        /* End of Outputs for SubSystem: '<S1001>/EdgeRising' */

        /* Switch: '<S1001>/Switch2' incorporates:
         *  Constant: '<S1001>/Constant3'
         *  Constant: '<S1031>/Calib'
         *  Product: '<S1001>/Product'
         */
        rtb_TmpSignalConversionAtVeTR_p = KeTHMR_dT_CoFuCellHiTSigOfsDec_C *
            0.1F;

        /* RelationalOperator: '<S1001>/Relational Operator1' incorporates:
         *  Constant: '<S1001>/Constant1'
         *  Sum: '<S1001>/Sum2'
         *  UnitDelay: '<S1001>/Unit Delay'
         */
        rtb_Switch1_hj = (THMR_ac_DW.UnitDelay_DSTATE_et3 <= (0.0F -
                           rtb_TmpSignalConversionAtVeTR_p));

        /* Outputs for Atomic SubSystem: '<S1001>/EdgeRising1' */
        /* Logic: '<S1028>/AND' incorporates:
         *  Logic: '<S1028>/OR1'
         *  UnitDelay: '<S1028>/Unit Delay'
         */
        rtb_Switch1_cys = (rtb_Switch1_hj && (!THMR_ac_DW.UnitDelay_DSTATE_pu));

        /* Update for UnitDelay: '<S1028>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_pu = rtb_Switch1_hj;

        /* End of Outputs for SubSystem: '<S1001>/EdgeRising1' */

        /* Logic: '<S1026>/Logical Operator2' incorporates:
         *  Logic: '<S1026>/Logical Operator1'
         *  Logic: '<S1026>/Logical Operator9'
         *  UnitDelay: '<S1026>/Unit Delay3'
         */
        rtb_Switch1_p1 = (((THMR_ac_DW.UnitDelay3_DSTATE_gu) || rtb_Switch1_p1) &&
                          (!rtb_Switch1_cys));

        /* Switch: '<S1001>/Switch2' */
        if (!rtb_Switch1_p1)
        {
            /* Switch: '<S1001>/Switch2' */
            rtb_TmpSignalConversionAtVeTR_p = rtb_TmpSignalConversionAtVeFCRR;
        }

        /* End of Switch: '<S1001>/Switch2' */

        /* Sum: '<S1001>/Sum3' incorporates:
         *  UnitDelay: '<S1001>/Unit Delay'
         */
        rtb_TmpSignalConversionAtVeFCRR = rtb_TmpSignalConversionAtVeTR_p +
            THMR_ac_DW.UnitDelay_DSTATE_et3;

        /* Switch: '<S1001>/Switch3' incorporates:
         *  Constant: '<S1030>/Calib'
         *  Switch: '<S1001>/Switch1'
         */
        if (KeTHMR_b_AcvRmpTCoFuCellHiTSigOfs_C)
        {
            /* Switch: '<S1001>/Switch3' */
            VeTHMR_T_CoFuCellHiTSigOfs = rtb_TmpSignalConversionAtVeFCRR;
        }
        else if (rtb_Switch1_p1)
        {
            /* Switch: '<S1001>/Switch1' incorporates:
             *  Constant: '<S1001>/Constant4'
             *  Switch: '<S1001>/Switch3'
             */
            VeTHMR_T_CoFuCellHiTSigOfs = 0.0F;
        }
        else
        {
            /* Switch: '<S1001>/Switch3' incorporates:
             *  Constant: '<S1029>/Calib'
             *  Switch: '<S1001>/Switch1'
             */
            VeTHMR_T_CoFuCellHiTSigOfs = KeTHMR_T_CoFuCellHiTSigOfs_C;
        }

        /* End of Switch: '<S1001>/Switch3' */

        /* Update for UnitDelay: '<S1026>/Unit Delay3' */
        THMR_ac_DW.UnitDelay3_DSTATE_gu = rtb_Switch1_p1;

        /* Update for UnitDelay: '<S1001>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_et3 = rtb_TmpSignalConversionAtVeFCRR;
    }

    /* End of Constant: '<S1003>/Calib' */
    /* End of Outputs for SubSystem: '<S949>/F02_02_04_04_02_TCoFuCellHiTSigOfs' */

    /* Switch: '<S949>/Switch1' incorporates:
     *  Constant: '<S1004>/Calib'
     *  Switch: '<S949>/Switch2'
     */
    if (KeTHMR_b_SelTarTCoFuCellHiTSigOfs_C)
    {
        /* Switch: '<S949>/Switch1' incorporates:
         *  Sum: '<S949>/Sum1'
         */
        rtb_TmpSignalConversionAtVeFCRR = VeTHMR_T_CoFuCellHiTSigOfs +
            rtb_TmpSignalConversionAtVeF_n4;

        /* Switch: '<S902>/Switch2' */
        rtb_MinMax7 = rtb_TmpSignalConversionAtVeFC_k;
    }
    else
    {
        /* Switch: '<S949>/Switch1' */
        rtb_TmpSignalConversionAtVeFCRR = rtb_TmpSignalConversionAtVeF_n4;

        /* Switch: '<S902>/Switch2' incorporates:
         *  Sum: '<S949>/Sum2'
         */
        rtb_MinMax7 = rtb_TmpSignalConversionAtVeFC_k +
            VeTHMR_T_CoFuCellHiTSigOfs;
    }

    /* End of Switch: '<S949>/Switch1' */

    /* UnitDelay: '<S950>/Unit Delay2' */
    VeTHMR_k_PwrFuCellMaxLimThStMchDelta = THMR_ac_DW.UnitDelay2_DSTATE_d;

    /* Lookup_n-D: '<S1010>/Vector' incorporates:
     *  UnitDelay: '<S950>/Unit Delay2'
     */
    rtb_TmpSignalConversionAtVeTR_p = look1_iflf_binlcapw
        (VeTHMR_k_PwrFuCellMaxLimThStMchDelta, ((const float32 *)
          &(KxTHMR_T_CoFuCellHiTOutSpOfs_T[0])), ((const float32 *)
          &(KtTHMR_T_CoFuCellHiTOutSpOfs_T[0])), 9U);

    /* Switch: '<S1018>/Switch1' incorporates:
     *  UnitDelay: '<S903>/Unit Delay'
     */
    if (THMR_ac_DW.UnitDelay_DSTATE_bx)
    {
        /* Switch: '<S1034>/Init' incorporates:
         *  UnitDelay: '<S1034>/FixPt Unit Delay2'
         */
        if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE) != 0)
        {
            /* Switch: '<S1034>/Init' */
            rtb_TmpSignalConversionAtVeTRIR = rtb_TmpSignalConversionAtVeTR_p;
        }
        else
        {
            /* Switch: '<S1034>/Init' incorporates:
             *  UnitDelay: '<S1034>/FixPt Unit Delay1'
             */
            rtb_TmpSignalConversionAtVeTRIR = THMR_ac_DW.FixPtUnitDelay1_DSTATE;
        }

        /* End of Switch: '<S1034>/Init' */

        /* Switch: '<S1018>/Switch1' incorporates:
         *  Constant: '<S1006>/Calib'
         *  Constant: '<S1007>/Calib'
         *  Constant: '<S949>/Constant5'
         *  MinMax: '<S1033>/MinMax'
         *  MinMax: '<S1033>/MinMax1'
         *  Product: '<S1018>/Product1'
         *  Product: '<S1018>/Product2'
         *  Sum: '<S1018>/Subtraction1'
         *  Sum: '<S1018>/Subtraction10'
         */
        VeTHMR_T_CoFuCellHiTOutSpPwrLimOfs = fminf
            (KeTHMR_dT_CoFuCellHiTOutSpOfsInc_C * 0.1F, fmaxf
             (rtb_TmpSignalConversionAtVeTR_p - rtb_TmpSignalConversionAtVeTRIR,
              KeTHMR_dT_CoFuCellHiTOutSpOfsDec_C * 0.1F)) +
            rtb_TmpSignalConversionAtVeTRIR;
    }
    else
    {
        /* Switch: '<S1018>/Switch1' */
        VeTHMR_T_CoFuCellHiTOutSpPwrLimOfs = rtb_TmpSignalConversionAtVeTR_p;
    }

    /* End of Switch: '<S1018>/Switch1' */

    /* Switch: '<S902>/Switch2' incorporates:
     *  Sum: '<S949>/Sum5'
     */
    rtb_MinMax7 += VeTHMR_T_CoFuCellHiTOutSpPwrLimOfs;

    /* MinMax: '<S949>/MinMax' incorporates:
     *  Constant: '<S1002>/Calib'
     */
    rtb_TmpSignalConversionAtVeTR_p = fminf(KeTHMR_T_CoFuCellHiTOutMax_C,
        rtb_MinMax7);

    /* Sum: '<S949>/Sum6' */
    VeTHMR_T_CoFuCellHiTInSp = rtb_TmpSignalConversionAtVeTR_p -
        rtb_TmpSignalConversionAtVeF_ob;

    /* RelationalOperator: '<S1000>/Relational Operator2' incorporates:
     *  Constant: '<S1025>/Calib'
     *  UnitDelay: '<S1000>/Unit Delay'
     */
    rtb_Switch1_hj = (THMR_ac_DW.UnitDelay_DSTATE_m0 >=
                      KeTHMR_Cnt_InitDlyTCoSenElVlv3WayFuCellCtl_C);

    /* Switch: '<S1022>/Switch2' incorporates:
     *  Logic: '<S1000>/Logical Operator4'
     *  Logic: '<S1022>/Logical Operator'
     *  UnitDelay: '<S1022>/Unit Delay1'
     */
    if (rtb_Switch1_hj && (THMR_ac_DW.UnitDelay1_DSTATE_a2))
    {
        /* MinMax: '<S1036>/MinMax' incorporates:
         *  Constant: '<S1009>/Calib'
         *  Constant: '<S1022>/Constant1'
         *  Constant: '<S1022>/Constant2'
         *  MinMax: '<S1036>/MinMax1'
         */
        rtb_TmpSignalConversionAtVeTRIR = fminf(1.0F, fmaxf
            (KeTHMR_k_TCoFuCellHiTInOutSpFil_C, 0.0F));

        /* Switch: '<S1022>/Switch2' incorporates:
         *  Constant: '<S1022>/Constant3'
         *  Product: '<S1022>/Product'
         *  Product: '<S1022>/Product1'
         *  Sum: '<S1022>/Sum'
         *  Sum: '<S1022>/Sum1'
         *  UnitDelay: '<S1022>/Unit Delay2'
         */
        Switch3_h[0] = ((1.0F - rtb_TmpSignalConversionAtVeTRIR) *
                        THMR_ac_DW.UnitDelay2_DSTATE_ek[0]) +
            (rtb_TmpSignalConversionAtVeTR_p * rtb_TmpSignalConversionAtVeTRIR);
        Switch3_h[1] = ((1.0F - rtb_TmpSignalConversionAtVeTRIR) *
                        THMR_ac_DW.UnitDelay2_DSTATE_ek[1]) +
            (VeTHMR_T_CoFuCellHiTInSp * rtb_TmpSignalConversionAtVeTRIR);
    }
    else
    {
        /* Switch: '<S1022>/Switch2' */
        Switch3_h[0] = rtb_TmpSignalConversionAtVeTR_p;
        Switch3_h[1] = VeTHMR_T_CoFuCellHiTInSp;
    }

    /* End of Switch: '<S1022>/Switch2' */

    /* MinMax: '<S994>/MinMax' incorporates:
     *  Constant: '<S949>/Constant3'
     *  Constant: '<S949>/Constant4'
     *  MinMax: '<S994>/MinMax1'
     *  Sum: '<S949>/Sum4'
     */
    VeTHMR_T_CoFuCellHiTOutDelta = fminf(200.0F, fmaxf
        (rtb_TmpSignalConversionAtVeFCRR - Switch3_h[0], -200.0F));

    /* Gain: '<S1020>/Gain' */
    VeTHMR_T_CoFuCellHiTInSpFil = Switch3_h[1];

    /* Switch: '<S1021>/Switch2' incorporates:
     *  Logic: '<S1000>/Logical Operator4'
     *  Logic: '<S1021>/Logical Operator'
     *  UnitDelay: '<S1021>/Unit Delay1'
     */
    if (rtb_Switch1_hj && (THMR_ac_DW.UnitDelay1_DSTATE_fjh))
    {
        /* MinMax: '<S1035>/MinMax' incorporates:
         *  Abs: '<S949>/Abs'
         *  Constant: '<S1021>/Constant1'
         *  Constant: '<S1021>/Constant2'
         *  Constant: '<S949>/Constant1'
         *  Constant: '<S949>/Constant2'
         *  Lookup_n-D: '<S1015>/Vector'
         *  MinMax: '<S1035>/MinMax1'
         *  MinMax: '<S993>/MinMax'
         *  MinMax: '<S993>/MinMax1'
         *  Sum: '<S949>/Sum3'
         *  UnitDelay: '<S949>/Unit Delay1'
         */
        rtb_TmpSignalConversionAtVeTR_p = fminf(1.0F, fmaxf(look1_iflf_binlcapw
            (fminf(50.0F, fmaxf(fabsf(rtb_TmpSignalConversionAtVeFCRR -
            THMR_ac_DW.UnitDelay1_DSTATE_k), 0.0F)), ((const float32 *)
            &(KxTHMR_k_TDifCoFuCellHiTOutFil_T[0])), ((const float32 *)
            &(KtTHMR_k_TDifCoFuCellHiTOutFil_T[0])), 6U), 0.0F));

        /* Switch: '<S1021>/Switch2' incorporates:
         *  Constant: '<S1021>/Constant3'
         *  Product: '<S1021>/Product'
         *  Product: '<S1021>/Product1'
         *  Sum: '<S1021>/Sum'
         *  Sum: '<S1021>/Sum1'
         *  UnitDelay: '<S1021>/Unit Delay2'
         */
        VeTHMR_T_CoFuCellHiTOutFil = ((1.0F - rtb_TmpSignalConversionAtVeTR_p) *
            THMR_ac_DW.UnitDelay2_DSTATE_d3) + (rtb_TmpSignalConversionAtVeFCRR *
            rtb_TmpSignalConversionAtVeTR_p);
    }
    else
    {
        /* Switch: '<S1021>/Switch2' */
        VeTHMR_T_CoFuCellHiTOutFil = rtb_TmpSignalConversionAtVeFCRR;
    }

    /* End of Switch: '<S1021>/Switch2' */

    /* Sum: '<S949>/Sum7' incorporates:
     *  MinMax: '<S949>/MinMax1'
     */
    VeTHMR_dT_TCoFuCellHiTOutFil = fmaxf(TmpSignalConversionAtOutAirTemp,
        VeTHMR_T_CoFuCellHiTOutFil) - TmpSignalConversionAtOutAirTemp;

    /* UnitDelay: '<S949>/Unit Delay' */
    rtb_TmpSignalConversionAtVeFCRR = THMR_ac_DW.UnitDelay_DSTATE_j;

    /* Lookup_n-D: '<S1012>/Vector' incorporates:
     *  Product: '<S55>/Product1'
     *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
     */
    VeTHMR_k_HeatTranCoefOutRadHiT1_MP = look2_iflf_binlcapw
        (TmpSignalConversionAtOutAirTemp, rtb_TmpSignalConversionAtVeFCPR, ((
           const float32 *)&(KxTHMR_k_HeatTranCoefOutRadHiT1_M[0])), ((const
           float32 *)&(KyTHMR_k_HeatTranCoefOutRadHiT1_M[0])), ((const float32 *)
          &(KtTHMR_k_HeatTranCoefOutRadHiT1_M[0])), THMR_ac_ConstP.pooled43, 8U);

    /* Switch: '<S949>/Switch4' incorporates:
     *  Constant: '<S1005>/Calib'
     */
    if (KeTHMR_b_TWaOutRadHiTSpdAirSel_C)
    {
        /* Switch: '<S902>/Switch4' incorporates:
         *  Constant: '<S949>/Constant8'
         *  Product: '<S949>/Divide'
         */
        rtb_TmpSignalConversionAtVeTM_p = rtb_TmpSignalConversionAtVeCSVR / 3.6F;
    }
    else
    {
        /* Switch: '<S902>/Switch4' incorporates:
         *  UnitDelay: '<S949>/Unit Delay2'
         */
        rtb_TmpSignalConversionAtVeTM_p = THMR_ac_DW.UnitDelay2_DSTATE_n;
    }

    /* End of Switch: '<S949>/Switch4' */

    /* Lookup_n-D: '<S1013>/Vector' incorporates:
     *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
     *  Switch: '<S902>/Switch4'
     */
    VeTHMR_k_HeatTranCoefOutRadHiT2_MP = look2_iflf_binlcapw
        (TmpSignalConversionAtOutAirTemp, rtb_TmpSignalConversionAtVeTM_p, ((
           const float32 *)&(KxTHMR_k_HeatTranCoefOutRadHiT2_M[0])), ((const
           float32 *)&(KyTHMR_k_HeatTranCoefOutRadHiT2_M[0])), ((const float32 *)
          &(KtTHMR_k_HeatTranCoefOutRadHiT2_M[0])), THMR_ac_ConstP.pooled43, 8U);

    /* Switch: '<S55>/Switch1' incorporates:
     *  Constant: '<S739>/Calib'
     *  Constant: '<S900>/Calib'
     *  RelationalOperator: '<S745>/Relational Operator1'
     *  Switch: '<S896>/Switch1'
     */
    if (KeTHMR_b_UseFdbFCWaPmp)
    {
        /* Switch: '<S902>/Switch4' incorporates:
         *  UnitDelay: '<S55>/Unit Delay2'
         */
        rtb_TmpSignalConversionAtVeTM_p = THMR_ac_DW.UnitDelay2_DSTATE_b;
    }
    else if (rtb_TmpSignalConversionAtVeP_jk >= KeTHMR_n_FCWaPump_MinSpdRPM)
    {
        /* Sum: '<S745>/Sum2' incorporates:
         *  Constant: '<S897>/Calib'
         *  Constant: '<S898>/Calib'
         *  Switch: '<S896>/Switch1'
         */
        rtb_TmpSignalConversionAtVeTR_p = KeTHMR_Pct_FCWaPump_MaxSpdPct -
            KeTHMR_Pct_FCWaPump_MinSpdPct;

        /* Sum: '<S745>/Sum1' incorporates:
         *  Constant: '<S899>/Calib'
         *  Constant: '<S900>/Calib'
         *  Switch: '<S896>/Switch1'
         */
        rtb_TmpSignalConversionAtVeTRIR = KeTHMR_n_FCWaPump_MaxSpdRPM -
            KeTHMR_n_FCWaPump_MinSpdRPM;

        /* Outputs for Atomic SubSystem: '<S745>/Protected Division' */
        /* Switch: '<S901>/Switch1' incorporates:
         *  Constant: '<S901>/Constant Value'
         *  Constant: '<S901>/Constant Value1'
         *  Constant: '<S901>/Constant Value2'
         *  Constant: '<S901>/Constant Value3'
         *  Logic: '<S901>/AND'
         *  RelationalOperator: '<S901>/Greater Than or Equal '
         *  RelationalOperator: '<S901>/Greater Than or Equal 1'
         *  RelationalOperator: '<S901>/Not Equal'
         *  RelationalOperator: '<S901>/Not Equal1'
         *  Switch: '<S896>/Switch1'
         *  Switch: '<S901>/Switch2'
         *  Switch: '<S901>/Switch3'
         */
        if ((rtb_TmpSignalConversionAtVeTR_p != 0.0F) &&
                (rtb_TmpSignalConversionAtVeTRIR != 0.0F))
        {
            /* Switch: '<S901>/Switch1' incorporates:
             *  Product: '<S901>/Division'
             */
            rtb_TmpSignalConversionAtVeTR_p /= rtb_TmpSignalConversionAtVeTRIR;
        }
        else if (rtb_TmpSignalConversionAtVeTR_p > 0.0F)
        {
            /* Switch: '<S901>/Switch2' incorporates:
             *  Constant: '<S901>/MAXFLOAT'
             *  Switch: '<S901>/Switch1'
             */
            rtb_TmpSignalConversionAtVeTR_p = 3.402823466E+38F;
        }
        else if (rtb_TmpSignalConversionAtVeTR_p < 0.0F)
        {
            /* Switch: '<S901>/Switch3' incorporates:
             *  Constant: '<S901>/MINFLOAT'
             *  Switch: '<S901>/Switch1'
             *  Switch: '<S901>/Switch2'
             */
            rtb_TmpSignalConversionAtVeTR_p = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S901>/Switch1' incorporates:
             *  Constant: '<S901>/Constant Value4'
             *  Switch: '<S901>/Switch2'
             *  Switch: '<S901>/Switch3'
             */
            rtb_TmpSignalConversionAtVeTR_p = 0.0F;
        }

        /* End of Switch: '<S901>/Switch1' */
        /* End of Outputs for SubSystem: '<S745>/Protected Division' */

        /* Switch: '<S902>/Switch4' incorporates:
         *  Constant: '<S898>/Calib'
         *  Constant: '<S900>/Calib'
         *  Product: '<S745>/Product1'
         *  Product: '<S745>/Product2'
         *  Sum: '<S745>/Sum3'
         *  Sum: '<S745>/Sum4'
         *  Switch: '<S896>/Switch1'
         */
        rtb_TmpSignalConversionAtVeTM_p = (rtb_TmpSignalConversionAtVeP_jk *
            rtb_TmpSignalConversionAtVeTR_p) - (KeTHMR_Pct_FCWaPump_MinSpdPct -
            (rtb_TmpSignalConversionAtVeTR_p * KeTHMR_n_FCWaPump_MinSpdRPM));
    }
    else
    {
        /* Switch: '<S902>/Switch4' incorporates:
         *  Constant: '<S745>/Constant7'
         *  Switch: '<S896>/Switch1'
         */
        rtb_TmpSignalConversionAtVeTM_p = 0.0F;
    }

    /* End of Switch: '<S55>/Switch1' */

    /* Lookup_n-D: '<S1014>/Vector' incorporates:
     *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
     *  Switch: '<S902>/Switch4'
     */
    VeTHMR_k_HeatTranCoefOutRadHiT3_MP = look2_iflf_binlcapw
        (TmpSignalConversionAtOutAirTemp, rtb_TmpSignalConversionAtVeTM_p, ((
           const float32 *)&(KxTHMR_k_HeatTranCoefOutRadHiT3_M[0])), ((const
           float32 *)&(KyTHMR_k_HeatTranCoefOutRadHiT3_M[0])), ((const float32 *)
          &(KtTHMR_k_HeatTranCoefOutRadHiT3_M[0])), THMR_ac_ConstP.pooled43, 8U);

    /* Switch: '<S949>/Switch3' incorporates:
     *  Constant: '<S1008>/Calib'
     *  Constant: '<S949>/Constant6'
     *  Constant: '<S949>/Constant7'
     *  RelationalOperator: '<S949>/Relational Operator2'
     */
    if (rtb_TmpSignalConversionAtVeFCRR > KeTHMR_k_ElVlv3WayFuCellPIDCls_C)
    {
        i = 0;
    }
    else
    {
        i = 2;
    }

    /* End of Switch: '<S949>/Switch3' */

    /* Switch: '<S902>/Switch2' incorporates:
     *  Constant: '<S949>/Constant9'
     *  MinMax: '<S995>/MinMax'
     *  MinMax: '<S995>/MinMax1'
     *  Product: '<S949>/Product1'
     *  Product: '<S949>/Product2'
     */
    rtb_MinMax7 = fminf((float32)i, fmaxf((VeTHMR_k_HeatTranCoefOutRadHiT2_MP *
                          VeTHMR_k_HeatTranCoefOutRadHiT3_MP) *
                         VeTHMR_k_HeatTranCoefOutRadHiT1_MP, 0.0F));

    /* MinMax: '<S949>/MinMax3' incorporates:
     *  MinMax: '<S949>/MinMax2'
     *  Product: '<S949>/Product'
     *  Sum: '<S949>/Sum8'
     */
    VeTHMR_T_WaOutRadHiTEstimRaw = fmaxf(TmpSignalConversionAtOutAirTemp, fminf
        ((VeTHMR_dT_TCoFuCellHiTOutFil * rtb_MinMax7) +
         TmpSignalConversionAtOutAirTemp, rtb_TmpSignalConversionAtVeFC_f));

    /* Logic: '<S903>/Logical Operator1' incorporates:
     *  Constant: '<S953>/Calib'
     *  Logic: '<S55>/Logical Operator4'
     */
    rtb_Switch1_p1 = ((KeTHMR_b_ElVlv3WayFuCellCtlDftSel_C) ||
                      rtb_RelationalOperator5_o);

    /* Switch: '<S1023>/Switch2' incorporates:
     *  Logic: '<S1000>/Logical Operator4'
     *  Logic: '<S1023>/Logical Operator'
     *  Switch: '<S949>/Switch5'
     *  UnitDelay: '<S1023>/Unit Delay1'
     */
    if (rtb_Switch1_hj && (THMR_ac_DW.UnitDelay1_DSTATE_gl))
    {
        /* MinMax: '<S1037>/MinMax' incorporates:
         *  Constant: '<S1023>/Constant1'
         *  Constant: '<S1023>/Constant2'
         *  Lookup_n-D: '<S1011>/Vector'
         *  MinMax: '<S1037>/MinMax1'
         *  UnitDelay: '<S949>/Unit Delay'
         */
        rtb_TmpSignalConversionAtVeP_jk = fminf(1.0F, fmaxf(look1_iflf_binlcapw
            (rtb_TmpSignalConversionAtVeFCRR, ((const float32 *)
            &(KxTHMR_T_WaOutRadHiTEstimFil_T[0])), ((const float32 *)
            &(KtTHMR_T_WaOutRadHiTEstimFil_T[0])), 5U), 0.0F));

        /* Switch: '<S1023>/Switch2' incorporates:
         *  Constant: '<S1023>/Constant3'
         *  Product: '<S1023>/Product'
         *  Product: '<S1023>/Product1'
         *  Sum: '<S1023>/Sum'
         *  Sum: '<S1023>/Sum1'
         *  UnitDelay: '<S1023>/Unit Delay2'
         */
        VeTHMR_T_WaOutRadHiTEstim = ((1.0F - rtb_TmpSignalConversionAtVeP_jk) *
            THMR_ac_DW.UnitDelay2_DSTATE_n5) + (VeTHMR_T_WaOutRadHiTEstimRaw *
            rtb_TmpSignalConversionAtVeP_jk);
    }
    else if (rtb_Switch1_p1)
    {
        /* Switch: '<S949>/Switch5' incorporates:
         *  Switch: '<S1023>/Switch2'
         */
        VeTHMR_T_WaOutRadHiTEstim = VeTHMR_T_WaOutRadHiTEstimRaw;
    }
    else
    {
        /* Switch: '<S1023>/Switch2' incorporates:
         *  Switch: '<S949>/Switch5'
         */
        VeTHMR_T_WaOutRadHiTEstim = rtb_TmpSignalConversionAtVeT_ge;
    }

    /* End of Switch: '<S1023>/Switch2' */

    /* Switch: '<S949>/Switch6' */
    if (rtb_Switch1_p1)
    {
        /* Switch: '<S949>/Switch6' */
        rtb_TmpSignalConversionAtVeT_ge = VeTHMR_T_WaOutRadHiTEstim;
    }

    /* End of Switch: '<S949>/Switch6' */

    /* Switch: '<S1024>/Switch2' incorporates:
     *  Logic: '<S1000>/Logical Operator4'
     *  Logic: '<S1024>/Logical Operator'
     *  UnitDelay: '<S1024>/Unit Delay1'
     */
    if (rtb_Switch1_hj && (THMR_ac_DW.UnitDelay1_DSTATE_ds))
    {
        /* MinMax: '<S1038>/MinMax' incorporates:
         *  Abs: '<S949>/Abs1'
         *  Constant: '<S1024>/Constant1'
         *  Constant: '<S1024>/Constant2'
         *  Constant: '<S949>/Constant13'
         *  Constant: '<S949>/Constant14'
         *  Lookup_n-D: '<S1016>/Vector'
         *  MinMax: '<S1038>/MinMax1'
         *  MinMax: '<S997>/MinMax'
         *  MinMax: '<S997>/MinMax1'
         *  Sum: '<S949>/Sum10'
         *  UnitDelay: '<S949>/Unit Delay3'
         */
        rtb_TmpSignalConversionAtVeP_jk = fminf(1.0F, fmaxf(look1_iflf_binlcapw
            (fminf(50.0F, fmaxf(fabsf(rtb_TmpSignalConversionAtVeT_ge -
            THMR_ac_DW.UnitDelay3_DSTATE_aj), 0.0F)), ((const float32 *)
            &(KxTHMR_k_TDifWaOutRadHiTFil_T[0])), ((const float32 *)
            &(KtTHMR_k_TDifWaOutRadHiTFil_T[0])), 6U), 0.0F));

        /* Switch: '<S1024>/Switch2' incorporates:
         *  Constant: '<S1024>/Constant3'
         *  Product: '<S1024>/Product'
         *  Product: '<S1024>/Product1'
         *  Sum: '<S1024>/Sum'
         *  Sum: '<S1024>/Sum1'
         *  UnitDelay: '<S1024>/Unit Delay2'
         */
        VeTHMR_T_WaOutRadHiTFil = ((1.0F - rtb_TmpSignalConversionAtVeP_jk) *
            THMR_ac_DW.UnitDelay2_DSTATE_l) + (rtb_TmpSignalConversionAtVeT_ge *
            rtb_TmpSignalConversionAtVeP_jk);
    }
    else
    {
        /* Switch: '<S1024>/Switch2' */
        VeTHMR_T_WaOutRadHiTFil = rtb_TmpSignalConversionAtVeT_ge;
    }

    /* End of Switch: '<S1024>/Switch2' */

    /* MinMax: '<S999>/MinMax' incorporates:
     *  Constant: '<S949>/Constant15'
     *  Constant: '<S949>/Constant16'
     *  MinMax: '<S999>/MinMax1'
     *  Sum: '<S949>/Sum12'
     */
    VeTHMR_T_DifFuCellInSpWaOutRadHiT = fminf(200.0F, fmaxf
        (VeTHMR_T_CoFuCellHiTInSpFil - VeTHMR_T_WaOutRadHiTFil, -200.0F));

    /* Outputs for Enabled SubSystem: '<S964>/F02_02_04_02_01_01_ElVlv_3_Way_FuCell_PID_Gain_Norm' incorporates:
     *  EnablePort: '<S969>/Enable'
     */
    /* Outputs for Enabled SubSystem: '<S964>/F02_02_04_02_01_02_ElVlv_3_Way_FuCell_PID_Gain_Dft' incorporates:
     *  EnablePort: '<S970>/Enable'
     */
    /* Logic: '<S964>/Logical Operator' */
    if (!rtb_Switch1_p1)
    {
        /* Merge: '<S964>/Merge3' incorporates:
         *  Lookup_n-D: '<S972>/Vector'
         *  MinMax: '<S994>/MinMax'
         *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
         */
        VeTHMR_k_DHiTRegFuCell = look2_iflf_binlcapw
            (VeTHMR_T_CoFuCellHiTOutDelta, TmpSignalConversionAtOutAirTemp, ((
               const float32 *)&(KxTHMR_k_DHiTRegFuCell_M[0])), ((const float32 *)
              &(KyTHMR_k_DHiTRegFuCell_M[0])), ((const float32 *)
              &(KtTHMR_k_DHiTRegFuCell_M[0])), THMR_ac_ConstP.pooled42, 9U);

        /* Merge: '<S964>/Merge2' incorporates:
         *  Lookup_n-D: '<S973>/Vector'
         *  MinMax: '<S994>/MinMax'
         *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
         */
        VeTHMR_k_IHiTRegFuCell = look2_iflf_binlcapw
            (VeTHMR_T_CoFuCellHiTOutDelta, TmpSignalConversionAtOutAirTemp, ((
               const float32 *)&(KxTHMR_k_IHiTRegFuCell_M[0])), ((const float32 *)
              &(KyTHMR_k_IHiTRegFuCell_M[0])), ((const float32 *)
              &(KtTHMR_k_IHiTRegFuCell_M[0])), THMR_ac_ConstP.pooled42, 9U);

        /* Merge: '<S964>/Merge1' incorporates:
         *  Lookup_n-D: '<S974>/Vector'
         *  MinMax: '<S994>/MinMax'
         *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
         */
        rtb_TmpSignalConversionAtVeT_ge = look2_iflf_binlcapw
            (VeTHMR_T_CoFuCellHiTOutDelta, TmpSignalConversionAtOutAirTemp, ((
               const float32 *)&(KxTHMR_k_PHiTRegFuCell_M[0])), ((const float32 *)
              &(KyTHMR_k_PHiTRegFuCell_M[0])), ((const float32 *)
              &(KtTHMR_k_PHiTRegFuCell_M[0])), THMR_ac_ConstP.pooled42, 9U);
    }
    else
    {
        /* Merge: '<S964>/Merge3' incorporates:
         *  Lookup_n-D: '<S975>/Vector'
         *  MinMax: '<S994>/MinMax'
         *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
         */
        VeTHMR_k_DHiTRegFuCell = look2_iflf_binlcapw
            (VeTHMR_T_CoFuCellHiTOutDelta, TmpSignalConversionAtOutAirTemp, ((
               const float32 *)&(KxTHMR_k_DHiTRegFuCellDft_M[0])), ((const
               float32 *)&(KyTHMR_k_DHiTRegFuCellDft_M[0])), ((const float32 *)
              &(KtTHMR_k_DHiTRegFuCellDft_M[0])), THMR_ac_ConstP.pooled42, 9U);

        /* Merge: '<S964>/Merge2' incorporates:
         *  Lookup_n-D: '<S976>/Vector'
         *  MinMax: '<S994>/MinMax'
         *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
         */
        VeTHMR_k_IHiTRegFuCell = look2_iflf_binlcapw
            (VeTHMR_T_CoFuCellHiTOutDelta, TmpSignalConversionAtOutAirTemp, ((
               const float32 *)&(KxTHMR_k_IHiTRegFuCellDft_M[0])), ((const
               float32 *)&(KyTHMR_k_IHiTRegFuCellDft_M[0])), ((const float32 *)
              &(KtTHMR_k_IHiTRegFuCellDft_M[0])), THMR_ac_ConstP.pooled42, 9U);

        /* Merge: '<S964>/Merge1' incorporates:
         *  Lookup_n-D: '<S977>/Vector'
         *  MinMax: '<S994>/MinMax'
         *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
         */
        rtb_TmpSignalConversionAtVeT_ge = look2_iflf_binlcapw
            (VeTHMR_T_CoFuCellHiTOutDelta, TmpSignalConversionAtOutAirTemp, ((
               const float32 *)&(KxTHMR_k_PHiTRegFuCellDft_M[0])), ((const
               float32 *)&(KyTHMR_k_PHiTRegFuCellDft_M[0])), ((const float32 *)
              &(KtTHMR_k_PHiTRegFuCellDft_M[0])), THMR_ac_ConstP.pooled42, 9U);
    }

    /* End of Logic: '<S964>/Logical Operator' */
    /* End of Outputs for SubSystem: '<S964>/F02_02_04_02_01_02_ElVlv_3_Way_FuCell_PID_Gain_Dft' */
    /* End of Outputs for SubSystem: '<S964>/F02_02_04_02_01_01_ElVlv_3_Way_FuCell_PID_Gain_Norm' */

    /* Product: '<S964>/Product2' incorporates:
     *  Lookup_n-D: '<S971>/Vector'
     *  MinMax: '<S999>/MinMax'
     */
    VeTHMR_k_PHiTRegFuCell = look1_iflf_binlcapw
        (VeTHMR_T_DifFuCellInSpWaOutRadHiT, ((const float32 *)
          &(KxTHMR_k_FacPHiTRegFuCell_T[0])), ((const float32 *)
          &(KtTHMR_k_FacPHiTRegFuCell_T[0])), 4U) *
        rtb_TmpSignalConversionAtVeT_ge;

    /* Product: '<S947>/Product' incorporates:
     *  Gain: '<S947>/Gain'
     */
    VeTHMR_k_ElVlv3WayFuCellProp_MP = (-VeTHMR_T_CoFuCellHiTOutDelta) *
        VeTHMR_k_PHiTRegFuCell;

    /* RelationalOperator: '<S928>/RelationalOperator5' incorporates:
     *  Constant: '<S928>/Constant2'
     *  DataTypeConversion: '<S55>/Data Type Conversion'
     *  SignalConversion generated from: '<S2>/VeFCPR_e_FCPS_HTCoolReq'
     */
    rtb_RelationalOperator5_o = (((float32)rtb_TmpSignalConversionAtVeFC_o) ==
        3.0F);

    /* Logic: '<S903>/Logical Operator3' incorporates:
     *  Constant: '<S952>/Calib'
     *  Logic: '<S903>/Logical Operator4'
     *  RelationalOperator: '<S903>/Relational Operator1'
     */
    rtb_Switch1_cys = ((!rtb_RelationalOperator5_o) &&
                       (rtb_TmpSignalConversionAtVeFCPR < KeTHMR_P_FuCellMin_C));

    /* Product: '<S947>/Product2' incorporates:
     *  Constant: '<S947>/Constant1'
     *  Gain: '<S947>/Gain1'
     *  Product: '<S947>/Product1'
     */
    rtb_TmpSignalConversionAtVeT_ge = ((-VeTHMR_T_CoFuCellHiTOutDelta) * 0.1F) *
        VeTHMR_k_IHiTRegFuCell;

    /* UnitDelay: '<S1094>/Unit Delay' incorporates:
     *  Constant: '<S947>/Constant4'
     *  RelationalOperator: '<S947>/Relational Operator'
     */
    rtb_TmpSignalConversionAtVeP_el = (rtb_TmpSignalConversionAtVeT_ge > 0.0F);

    /* Switch: '<S55>/Switch4' incorporates:
     *  Constant: '<S738>/Calib'
     *  UnitDelay: '<S55>/Unit Delay1'
     */
    if (KeTHMR_b_UseFdbFCVlvPos)
    {
        rtb_TmpSignalConversionAtVePMIR = THMR_ac_DW.UnitDelay1_DSTATE_a;
    }

    /* End of Switch: '<S55>/Switch4' */

    /* Logic: '<S965>/Logical Operator7' incorporates:
     *  Abs: '<S965>/Abs'
     *  Constant: '<S978>/Calib'
     *  Logic: '<S965>/Logical Operator1'
     *  Logic: '<S965>/Logical Operator2'
     *  Logic: '<S965>/Logical Operator3'
     *  Logic: '<S965>/Logical Operator4'
     *  Logic: '<S965>/Logical Operator5'
     *  Logic: '<S965>/Logical Operator6'
     *  RelationalOperator: '<S965>/Relational Operator'
     *  Sum: '<S965>/Sum'
     *  UnitDelay: '<S965>/Unit Delay'
     *  UnitDelay: '<S965>/Unit Delay1'
     *  UnitDelay: '<S965>/Unit Delay2'
     */
    VeTHMR_b_ElVlv3WayFuCell_Int_Hld = ((((fabsf(THMR_ac_DW.UnitDelay_DSTATE_jt
        - rtb_TmpSignalConversionAtVePMIR) > KeTHMR_k_ElVlv3WayFuCellReqDif_C) &&
        ((!THMR_ac_DW.UnitDelay1_DSTATE_ah) && (!THMR_ac_DW.UnitDelay2_DSTATE_pd)))
        || (rtb_TmpSignalConversionAtVeP_el && (THMR_ac_DW.UnitDelay1_DSTATE_ah)))
        || ((!rtb_TmpSignalConversionAtVeP_el) &&
            (THMR_ac_DW.UnitDelay2_DSTATE_pd)));

    /* Switch: '<S947>/Switch2' incorporates:
     *  Switch: '<S947>/Switch1'
     */
    if (rtb_Switch1_cys)
    {
        /* Switch: '<S947>/Switch2' incorporates:
         *  Constant: '<S947>/Constant3'
         */
        VeTHMR_k_ElVlv3WayFuCellInt_MP = 0.0F;
    }
    else
    {
        if (VeTHMR_b_ElVlv3WayFuCell_Int_Hld)
        {
            /* Switch: '<S947>/Switch1' incorporates:
             *  Constant: '<S947>/Constant2'
             */
            rtb_TmpSignalConversionAtVeT_ge = 0.0F;
        }

        /* Switch: '<S947>/Switch2' incorporates:
         *  Sum: '<S947>/Sum2'
         *  UnitDelay: '<S947>/Unit Delay1'
         */
        VeTHMR_k_ElVlv3WayFuCellInt_MP = THMR_ac_DW.UnitDelay1_DSTATE_lr +
            rtb_TmpSignalConversionAtVeT_ge;
    }

    /* End of Switch: '<S947>/Switch2' */

    /* Switch: '<S967>/Switch' incorporates:
     *  UnitDelay: '<S967>/Unit Delay'
     *  UnitDelay: '<S967>/Unit Delay1'
     */
    if (THMR_ac_DW.UnitDelay_DSTATE_kc != 0.0F)
    {
        rtb_Switch10 = THMR_ac_DW.UnitDelay1_DSTATE_h;
    }
    else
    {
        rtb_Switch10 = VeTHMR_T_CoFuCellHiTOutDelta;
    }

    /* End of Switch: '<S967>/Switch' */

    /* Sum: '<S947>/Sum' */
    rtb_TmpSignalConversionAtVeT_ge = VeTHMR_T_CoFuCellHiTOutDelta -
        rtb_Switch10;

    /* UnitDelay: '<S968>/Unit Delay1' */
    rtb_TmpSignalConversionAtVeP_jk = THMR_ac_DW.UnitDelay1_DSTATE_ot;

    /* UnitDelay: '<S968>/Unit Delay2' */
    rtb_TmpSignalConversionAtVeFCRR = THMR_ac_DW.UnitDelay2_DSTATE_da;

    /* UnitDelay: '<S968>/Unit Delay4' */
    rtb_TmpSignalConversionAtVeTR_p = THMR_ac_DW.UnitDelay4_DSTATE_o;

    /* UnitDelay: '<S968>/Unit Delay3' */
    rtb_TmpSignalConversionAtVePMIR = THMR_ac_DW.UnitDelay3_DSTATE_mq;

    /* UnitDelay: '<S968>/Unit Delay5' */
    rtb_TmpSignalConversionAtVeTRIR = THMR_ac_DW.UnitDelay5_DSTATE_o;

    /* UnitDelay: '<S968>/Unit Delay6' */
    rtb_TmpSignalConversionAtVeTM_f = THMR_ac_DW.UnitDelay6_DSTATE_i;

    /* UnitDelay: '<S968>/Unit Delay7' */
    rtb_TmpSignalConversionAtVeT_dg = THMR_ac_DW.UnitDelay7_DSTATE;

    /* UnitDelay: '<S968>/Unit Delay8' */
    rtb_Product9 = THMR_ac_DW.UnitDelay8_DSTATE;

    /* UnitDelay: '<S968>/Unit Delay9' */
    rtb_UnitDelay9 = THMR_ac_DW.UnitDelay9_DSTATE;

    /* UnitDelay: '<S968>/Unit Delay10' */
    rtb_UnitDelay10 = THMR_ac_DW.UnitDelay10_DSTATE;

    /* UnitDelay: '<S968>/Unit Delay12' */
    rtb_UnitDelay12 = THMR_ac_DW.UnitDelay12_DSTATE;

    /* UnitDelay: '<S968>/Unit Delay13' */
    rtb_UnitDelay13 = THMR_ac_DW.UnitDelay13_DSTATE;

    /* UnitDelay: '<S968>/Unit Delay11' */
    rtb_UnitDelay11 = THMR_ac_DW.UnitDelay11_DSTATE;

    /* UnitDelay: '<S968>/Unit Delay15' */
    rtb_UnitDelay15 = THMR_ac_DW.UnitDelay15_DSTATE;

    /* UnitDelay: '<S968>/Unit Delay16' */
    rtb_TmpSignalConversionAtVeB_nb = THMR_ac_DW.UnitDelay16_DSTATE;

    /* UnitDelay: '<S968>/Unit Delay14' */
    rtb_TmpSignalConversionAtVeCT_i = THMR_ac_DW.UnitDelay14_DSTATE;

    /* UnitDelay: '<S968>/Unit Delay18' */
    rtb_TmpSignalConversionAtVeT_n0 = THMR_ac_DW.UnitDelay18_DSTATE;

    /* UnitDelay: '<S968>/Unit Delay19' */
    rtb_TmpSignalConversionAtVeBT_o = THMR_ac_DW.UnitDelay19_DSTATE;

    /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
     *  Constant: '<S966>/Calib'
     *  Constant: '<S968>/Constant1'
     *  Constant: '<S968>/Constant4'
     *  MinMax: '<S979>/MinMax'
     *  MinMax: '<S979>/MinMax1'
     */
    switch ((sint32)fminf(20.0F, fmaxf(KeTHMR_Cnt_SampleFuCellHiToutGrd_C, 1.0F)))
    {
      case 1:
        /* MultiPortSwitch: '<S968>/Multiport Switch' */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP = rtb_TmpSignalConversionAtVeT_ge;
        break;

      case 2:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  UnitDelay: '<S968>/Unit Delay1'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP = rtb_TmpSignalConversionAtVeT_ge +
            THMR_ac_DW.UnitDelay1_DSTATE_ot;
        break;

      case 3:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay2'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP = (rtb_TmpSignalConversionAtVeT_ge
            + THMR_ac_DW.UnitDelay1_DSTATE_ot) + THMR_ac_DW.UnitDelay2_DSTATE_da;
        break;

      case 4:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum2'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay4'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP = ((rtb_TmpSignalConversionAtVeT_ge
            + THMR_ac_DW.UnitDelay1_DSTATE_ot) + THMR_ac_DW.UnitDelay2_DSTATE_da)
            + THMR_ac_DW.UnitDelay4_DSTATE_o;
        break;

      case 5:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum3'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            (((rtb_TmpSignalConversionAtVeT_ge + THMR_ac_DW.UnitDelay1_DSTATE_ot)
              + THMR_ac_DW.UnitDelay2_DSTATE_da) +
             THMR_ac_DW.UnitDelay4_DSTATE_o) + THMR_ac_DW.UnitDelay3_DSTATE_mq;
        break;

      case 6:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum3'
         *  Sum: '<S968>/Sum4'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         *  UnitDelay: '<S968>/Unit Delay5'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            ((((rtb_TmpSignalConversionAtVeT_ge +
                THMR_ac_DW.UnitDelay1_DSTATE_ot) +
               THMR_ac_DW.UnitDelay2_DSTATE_da) + THMR_ac_DW.UnitDelay4_DSTATE_o)
             + THMR_ac_DW.UnitDelay3_DSTATE_mq) + THMR_ac_DW.UnitDelay5_DSTATE_o;
        break;

      case 7:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum3'
         *  Sum: '<S968>/Sum4'
         *  Sum: '<S968>/Sum5'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         *  UnitDelay: '<S968>/Unit Delay5'
         *  UnitDelay: '<S968>/Unit Delay6'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            (((((rtb_TmpSignalConversionAtVeT_ge +
                 THMR_ac_DW.UnitDelay1_DSTATE_ot) +
                THMR_ac_DW.UnitDelay2_DSTATE_da) +
               THMR_ac_DW.UnitDelay4_DSTATE_o) + THMR_ac_DW.UnitDelay3_DSTATE_mq)
             + THMR_ac_DW.UnitDelay5_DSTATE_o) + THMR_ac_DW.UnitDelay6_DSTATE_i;
        break;

      case 8:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum3'
         *  Sum: '<S968>/Sum4'
         *  Sum: '<S968>/Sum5'
         *  Sum: '<S968>/Sum6'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         *  UnitDelay: '<S968>/Unit Delay5'
         *  UnitDelay: '<S968>/Unit Delay6'
         *  UnitDelay: '<S968>/Unit Delay7'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            ((((((rtb_TmpSignalConversionAtVeT_ge +
                  THMR_ac_DW.UnitDelay1_DSTATE_ot) +
                 THMR_ac_DW.UnitDelay2_DSTATE_da) +
                THMR_ac_DW.UnitDelay4_DSTATE_o) +
               THMR_ac_DW.UnitDelay3_DSTATE_mq) + THMR_ac_DW.UnitDelay5_DSTATE_o)
             + THMR_ac_DW.UnitDelay6_DSTATE_i) + THMR_ac_DW.UnitDelay7_DSTATE;
        break;

      case 9:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum3'
         *  Sum: '<S968>/Sum4'
         *  Sum: '<S968>/Sum5'
         *  Sum: '<S968>/Sum6'
         *  Sum: '<S968>/Sum7'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         *  UnitDelay: '<S968>/Unit Delay5'
         *  UnitDelay: '<S968>/Unit Delay6'
         *  UnitDelay: '<S968>/Unit Delay7'
         *  UnitDelay: '<S968>/Unit Delay8'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            (((((((rtb_TmpSignalConversionAtVeT_ge +
                   THMR_ac_DW.UnitDelay1_DSTATE_ot) +
                  THMR_ac_DW.UnitDelay2_DSTATE_da) +
                 THMR_ac_DW.UnitDelay4_DSTATE_o) +
                THMR_ac_DW.UnitDelay3_DSTATE_mq) +
               THMR_ac_DW.UnitDelay5_DSTATE_o) + THMR_ac_DW.UnitDelay6_DSTATE_i)
             + THMR_ac_DW.UnitDelay7_DSTATE) + THMR_ac_DW.UnitDelay8_DSTATE;
        break;

      case 10:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum3'
         *  Sum: '<S968>/Sum4'
         *  Sum: '<S968>/Sum5'
         *  Sum: '<S968>/Sum6'
         *  Sum: '<S968>/Sum7'
         *  Sum: '<S968>/Sum8'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         *  UnitDelay: '<S968>/Unit Delay5'
         *  UnitDelay: '<S968>/Unit Delay6'
         *  UnitDelay: '<S968>/Unit Delay7'
         *  UnitDelay: '<S968>/Unit Delay8'
         *  UnitDelay: '<S968>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            ((((((((rtb_TmpSignalConversionAtVeT_ge +
                    THMR_ac_DW.UnitDelay1_DSTATE_ot) +
                   THMR_ac_DW.UnitDelay2_DSTATE_da) +
                  THMR_ac_DW.UnitDelay4_DSTATE_o) +
                 THMR_ac_DW.UnitDelay3_DSTATE_mq) +
                THMR_ac_DW.UnitDelay5_DSTATE_o) + THMR_ac_DW.UnitDelay6_DSTATE_i)
              + THMR_ac_DW.UnitDelay7_DSTATE) + THMR_ac_DW.UnitDelay8_DSTATE) +
            THMR_ac_DW.UnitDelay9_DSTATE;
        break;

      case 11:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum3'
         *  Sum: '<S968>/Sum4'
         *  Sum: '<S968>/Sum5'
         *  Sum: '<S968>/Sum6'
         *  Sum: '<S968>/Sum7'
         *  Sum: '<S968>/Sum8'
         *  Sum: '<S968>/Sum9'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay10'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         *  UnitDelay: '<S968>/Unit Delay5'
         *  UnitDelay: '<S968>/Unit Delay6'
         *  UnitDelay: '<S968>/Unit Delay7'
         *  UnitDelay: '<S968>/Unit Delay8'
         *  UnitDelay: '<S968>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            (((((((((rtb_TmpSignalConversionAtVeT_ge +
                     THMR_ac_DW.UnitDelay1_DSTATE_ot) +
                    THMR_ac_DW.UnitDelay2_DSTATE_da) +
                   THMR_ac_DW.UnitDelay4_DSTATE_o) +
                  THMR_ac_DW.UnitDelay3_DSTATE_mq) +
                 THMR_ac_DW.UnitDelay5_DSTATE_o) +
                THMR_ac_DW.UnitDelay6_DSTATE_i) + THMR_ac_DW.UnitDelay7_DSTATE)
              + THMR_ac_DW.UnitDelay8_DSTATE) + THMR_ac_DW.UnitDelay9_DSTATE) +
            THMR_ac_DW.UnitDelay10_DSTATE;
        break;

      case 12:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum10'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum3'
         *  Sum: '<S968>/Sum4'
         *  Sum: '<S968>/Sum5'
         *  Sum: '<S968>/Sum6'
         *  Sum: '<S968>/Sum7'
         *  Sum: '<S968>/Sum8'
         *  Sum: '<S968>/Sum9'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay10'
         *  UnitDelay: '<S968>/Unit Delay12'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         *  UnitDelay: '<S968>/Unit Delay5'
         *  UnitDelay: '<S968>/Unit Delay6'
         *  UnitDelay: '<S968>/Unit Delay7'
         *  UnitDelay: '<S968>/Unit Delay8'
         *  UnitDelay: '<S968>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            ((((((((((rtb_TmpSignalConversionAtVeT_ge +
                      THMR_ac_DW.UnitDelay1_DSTATE_ot) +
                     THMR_ac_DW.UnitDelay2_DSTATE_da) +
                    THMR_ac_DW.UnitDelay4_DSTATE_o) +
                   THMR_ac_DW.UnitDelay3_DSTATE_mq) +
                  THMR_ac_DW.UnitDelay5_DSTATE_o) +
                 THMR_ac_DW.UnitDelay6_DSTATE_i) + THMR_ac_DW.UnitDelay7_DSTATE)
               + THMR_ac_DW.UnitDelay8_DSTATE) + THMR_ac_DW.UnitDelay9_DSTATE) +
             THMR_ac_DW.UnitDelay10_DSTATE) + THMR_ac_DW.UnitDelay12_DSTATE;
        break;

      case 13:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum10'
         *  Sum: '<S968>/Sum11'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum3'
         *  Sum: '<S968>/Sum4'
         *  Sum: '<S968>/Sum5'
         *  Sum: '<S968>/Sum6'
         *  Sum: '<S968>/Sum7'
         *  Sum: '<S968>/Sum8'
         *  Sum: '<S968>/Sum9'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay10'
         *  UnitDelay: '<S968>/Unit Delay12'
         *  UnitDelay: '<S968>/Unit Delay13'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         *  UnitDelay: '<S968>/Unit Delay5'
         *  UnitDelay: '<S968>/Unit Delay6'
         *  UnitDelay: '<S968>/Unit Delay7'
         *  UnitDelay: '<S968>/Unit Delay8'
         *  UnitDelay: '<S968>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            (((((((((((rtb_TmpSignalConversionAtVeT_ge +
                       THMR_ac_DW.UnitDelay1_DSTATE_ot) +
                      THMR_ac_DW.UnitDelay2_DSTATE_da) +
                     THMR_ac_DW.UnitDelay4_DSTATE_o) +
                    THMR_ac_DW.UnitDelay3_DSTATE_mq) +
                   THMR_ac_DW.UnitDelay5_DSTATE_o) +
                  THMR_ac_DW.UnitDelay6_DSTATE_i) + THMR_ac_DW.UnitDelay7_DSTATE)
                + THMR_ac_DW.UnitDelay8_DSTATE) + THMR_ac_DW.UnitDelay9_DSTATE)
              + THMR_ac_DW.UnitDelay10_DSTATE) + THMR_ac_DW.UnitDelay12_DSTATE)
            + THMR_ac_DW.UnitDelay13_DSTATE;
        break;

      case 14:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum10'
         *  Sum: '<S968>/Sum11'
         *  Sum: '<S968>/Sum12'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum3'
         *  Sum: '<S968>/Sum4'
         *  Sum: '<S968>/Sum5'
         *  Sum: '<S968>/Sum6'
         *  Sum: '<S968>/Sum7'
         *  Sum: '<S968>/Sum8'
         *  Sum: '<S968>/Sum9'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay10'
         *  UnitDelay: '<S968>/Unit Delay11'
         *  UnitDelay: '<S968>/Unit Delay12'
         *  UnitDelay: '<S968>/Unit Delay13'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         *  UnitDelay: '<S968>/Unit Delay5'
         *  UnitDelay: '<S968>/Unit Delay6'
         *  UnitDelay: '<S968>/Unit Delay7'
         *  UnitDelay: '<S968>/Unit Delay8'
         *  UnitDelay: '<S968>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            ((((((((((((rtb_TmpSignalConversionAtVeT_ge +
                        THMR_ac_DW.UnitDelay1_DSTATE_ot) +
                       THMR_ac_DW.UnitDelay2_DSTATE_da) +
                      THMR_ac_DW.UnitDelay4_DSTATE_o) +
                     THMR_ac_DW.UnitDelay3_DSTATE_mq) +
                    THMR_ac_DW.UnitDelay5_DSTATE_o) +
                   THMR_ac_DW.UnitDelay6_DSTATE_i) +
                  THMR_ac_DW.UnitDelay7_DSTATE) + THMR_ac_DW.UnitDelay8_DSTATE)
                + THMR_ac_DW.UnitDelay9_DSTATE) + THMR_ac_DW.UnitDelay10_DSTATE)
              + THMR_ac_DW.UnitDelay12_DSTATE) + THMR_ac_DW.UnitDelay13_DSTATE)
            + THMR_ac_DW.UnitDelay11_DSTATE;
        break;

      case 15:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum10'
         *  Sum: '<S968>/Sum11'
         *  Sum: '<S968>/Sum12'
         *  Sum: '<S968>/Sum13'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum3'
         *  Sum: '<S968>/Sum4'
         *  Sum: '<S968>/Sum5'
         *  Sum: '<S968>/Sum6'
         *  Sum: '<S968>/Sum7'
         *  Sum: '<S968>/Sum8'
         *  Sum: '<S968>/Sum9'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay10'
         *  UnitDelay: '<S968>/Unit Delay11'
         *  UnitDelay: '<S968>/Unit Delay12'
         *  UnitDelay: '<S968>/Unit Delay13'
         *  UnitDelay: '<S968>/Unit Delay15'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         *  UnitDelay: '<S968>/Unit Delay5'
         *  UnitDelay: '<S968>/Unit Delay6'
         *  UnitDelay: '<S968>/Unit Delay7'
         *  UnitDelay: '<S968>/Unit Delay8'
         *  UnitDelay: '<S968>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            (((((((((((((rtb_TmpSignalConversionAtVeT_ge +
                         THMR_ac_DW.UnitDelay1_DSTATE_ot) +
                        THMR_ac_DW.UnitDelay2_DSTATE_da) +
                       THMR_ac_DW.UnitDelay4_DSTATE_o) +
                      THMR_ac_DW.UnitDelay3_DSTATE_mq) +
                     THMR_ac_DW.UnitDelay5_DSTATE_o) +
                    THMR_ac_DW.UnitDelay6_DSTATE_i) +
                   THMR_ac_DW.UnitDelay7_DSTATE) + THMR_ac_DW.UnitDelay8_DSTATE)
                 + THMR_ac_DW.UnitDelay9_DSTATE) + THMR_ac_DW.UnitDelay10_DSTATE)
               + THMR_ac_DW.UnitDelay12_DSTATE) + THMR_ac_DW.UnitDelay13_DSTATE)
             + THMR_ac_DW.UnitDelay11_DSTATE) + THMR_ac_DW.UnitDelay15_DSTATE;
        break;

      case 16:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum10'
         *  Sum: '<S968>/Sum11'
         *  Sum: '<S968>/Sum12'
         *  Sum: '<S968>/Sum13'
         *  Sum: '<S968>/Sum14'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum3'
         *  Sum: '<S968>/Sum4'
         *  Sum: '<S968>/Sum5'
         *  Sum: '<S968>/Sum6'
         *  Sum: '<S968>/Sum7'
         *  Sum: '<S968>/Sum8'
         *  Sum: '<S968>/Sum9'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay10'
         *  UnitDelay: '<S968>/Unit Delay11'
         *  UnitDelay: '<S968>/Unit Delay12'
         *  UnitDelay: '<S968>/Unit Delay13'
         *  UnitDelay: '<S968>/Unit Delay15'
         *  UnitDelay: '<S968>/Unit Delay16'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         *  UnitDelay: '<S968>/Unit Delay5'
         *  UnitDelay: '<S968>/Unit Delay6'
         *  UnitDelay: '<S968>/Unit Delay7'
         *  UnitDelay: '<S968>/Unit Delay8'
         *  UnitDelay: '<S968>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            ((((((((((((((rtb_TmpSignalConversionAtVeT_ge +
                          THMR_ac_DW.UnitDelay1_DSTATE_ot) +
                         THMR_ac_DW.UnitDelay2_DSTATE_da) +
                        THMR_ac_DW.UnitDelay4_DSTATE_o) +
                       THMR_ac_DW.UnitDelay3_DSTATE_mq) +
                      THMR_ac_DW.UnitDelay5_DSTATE_o) +
                     THMR_ac_DW.UnitDelay6_DSTATE_i) +
                    THMR_ac_DW.UnitDelay7_DSTATE) + THMR_ac_DW.UnitDelay8_DSTATE)
                  + THMR_ac_DW.UnitDelay9_DSTATE) +
                 THMR_ac_DW.UnitDelay10_DSTATE) + THMR_ac_DW.UnitDelay12_DSTATE)
               + THMR_ac_DW.UnitDelay13_DSTATE) + THMR_ac_DW.UnitDelay11_DSTATE)
             + THMR_ac_DW.UnitDelay15_DSTATE) + THMR_ac_DW.UnitDelay16_DSTATE;
        break;

      case 17:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum10'
         *  Sum: '<S968>/Sum11'
         *  Sum: '<S968>/Sum12'
         *  Sum: '<S968>/Sum13'
         *  Sum: '<S968>/Sum14'
         *  Sum: '<S968>/Sum15'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum3'
         *  Sum: '<S968>/Sum4'
         *  Sum: '<S968>/Sum5'
         *  Sum: '<S968>/Sum6'
         *  Sum: '<S968>/Sum7'
         *  Sum: '<S968>/Sum8'
         *  Sum: '<S968>/Sum9'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay10'
         *  UnitDelay: '<S968>/Unit Delay11'
         *  UnitDelay: '<S968>/Unit Delay12'
         *  UnitDelay: '<S968>/Unit Delay13'
         *  UnitDelay: '<S968>/Unit Delay14'
         *  UnitDelay: '<S968>/Unit Delay15'
         *  UnitDelay: '<S968>/Unit Delay16'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         *  UnitDelay: '<S968>/Unit Delay5'
         *  UnitDelay: '<S968>/Unit Delay6'
         *  UnitDelay: '<S968>/Unit Delay7'
         *  UnitDelay: '<S968>/Unit Delay8'
         *  UnitDelay: '<S968>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            (((((((((((((((rtb_TmpSignalConversionAtVeT_ge +
                           THMR_ac_DW.UnitDelay1_DSTATE_ot) +
                          THMR_ac_DW.UnitDelay2_DSTATE_da) +
                         THMR_ac_DW.UnitDelay4_DSTATE_o) +
                        THMR_ac_DW.UnitDelay3_DSTATE_mq) +
                       THMR_ac_DW.UnitDelay5_DSTATE_o) +
                      THMR_ac_DW.UnitDelay6_DSTATE_i) +
                     THMR_ac_DW.UnitDelay7_DSTATE) +
                    THMR_ac_DW.UnitDelay8_DSTATE) + THMR_ac_DW.UnitDelay9_DSTATE)
                  + THMR_ac_DW.UnitDelay10_DSTATE) +
                 THMR_ac_DW.UnitDelay12_DSTATE) + THMR_ac_DW.UnitDelay13_DSTATE)
               + THMR_ac_DW.UnitDelay11_DSTATE) + THMR_ac_DW.UnitDelay15_DSTATE)
             + THMR_ac_DW.UnitDelay16_DSTATE) + THMR_ac_DW.UnitDelay14_DSTATE;
        break;

      case 18:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum10'
         *  Sum: '<S968>/Sum11'
         *  Sum: '<S968>/Sum12'
         *  Sum: '<S968>/Sum13'
         *  Sum: '<S968>/Sum14'
         *  Sum: '<S968>/Sum15'
         *  Sum: '<S968>/Sum16'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum3'
         *  Sum: '<S968>/Sum4'
         *  Sum: '<S968>/Sum5'
         *  Sum: '<S968>/Sum6'
         *  Sum: '<S968>/Sum7'
         *  Sum: '<S968>/Sum8'
         *  Sum: '<S968>/Sum9'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay10'
         *  UnitDelay: '<S968>/Unit Delay11'
         *  UnitDelay: '<S968>/Unit Delay12'
         *  UnitDelay: '<S968>/Unit Delay13'
         *  UnitDelay: '<S968>/Unit Delay14'
         *  UnitDelay: '<S968>/Unit Delay15'
         *  UnitDelay: '<S968>/Unit Delay16'
         *  UnitDelay: '<S968>/Unit Delay18'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         *  UnitDelay: '<S968>/Unit Delay5'
         *  UnitDelay: '<S968>/Unit Delay6'
         *  UnitDelay: '<S968>/Unit Delay7'
         *  UnitDelay: '<S968>/Unit Delay8'
         *  UnitDelay: '<S968>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            ((((((((((((((((rtb_TmpSignalConversionAtVeT_ge +
                            THMR_ac_DW.UnitDelay1_DSTATE_ot) +
                           THMR_ac_DW.UnitDelay2_DSTATE_da) +
                          THMR_ac_DW.UnitDelay4_DSTATE_o) +
                         THMR_ac_DW.UnitDelay3_DSTATE_mq) +
                        THMR_ac_DW.UnitDelay5_DSTATE_o) +
                       THMR_ac_DW.UnitDelay6_DSTATE_i) +
                      THMR_ac_DW.UnitDelay7_DSTATE) +
                     THMR_ac_DW.UnitDelay8_DSTATE) +
                    THMR_ac_DW.UnitDelay9_DSTATE) +
                   THMR_ac_DW.UnitDelay10_DSTATE) +
                  THMR_ac_DW.UnitDelay12_DSTATE) + THMR_ac_DW.UnitDelay13_DSTATE)
                + THMR_ac_DW.UnitDelay11_DSTATE) + THMR_ac_DW.UnitDelay15_DSTATE)
              + THMR_ac_DW.UnitDelay16_DSTATE) + THMR_ac_DW.UnitDelay14_DSTATE)
            + THMR_ac_DW.UnitDelay18_DSTATE;
        break;

      case 19:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum10'
         *  Sum: '<S968>/Sum11'
         *  Sum: '<S968>/Sum12'
         *  Sum: '<S968>/Sum13'
         *  Sum: '<S968>/Sum14'
         *  Sum: '<S968>/Sum15'
         *  Sum: '<S968>/Sum16'
         *  Sum: '<S968>/Sum19'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum3'
         *  Sum: '<S968>/Sum4'
         *  Sum: '<S968>/Sum5'
         *  Sum: '<S968>/Sum6'
         *  Sum: '<S968>/Sum7'
         *  Sum: '<S968>/Sum8'
         *  Sum: '<S968>/Sum9'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay10'
         *  UnitDelay: '<S968>/Unit Delay11'
         *  UnitDelay: '<S968>/Unit Delay12'
         *  UnitDelay: '<S968>/Unit Delay13'
         *  UnitDelay: '<S968>/Unit Delay14'
         *  UnitDelay: '<S968>/Unit Delay15'
         *  UnitDelay: '<S968>/Unit Delay16'
         *  UnitDelay: '<S968>/Unit Delay18'
         *  UnitDelay: '<S968>/Unit Delay19'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         *  UnitDelay: '<S968>/Unit Delay5'
         *  UnitDelay: '<S968>/Unit Delay6'
         *  UnitDelay: '<S968>/Unit Delay7'
         *  UnitDelay: '<S968>/Unit Delay8'
         *  UnitDelay: '<S968>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            (((((((((((((((((rtb_TmpSignalConversionAtVeT_ge +
                             THMR_ac_DW.UnitDelay1_DSTATE_ot) +
                            THMR_ac_DW.UnitDelay2_DSTATE_da) +
                           THMR_ac_DW.UnitDelay4_DSTATE_o) +
                          THMR_ac_DW.UnitDelay3_DSTATE_mq) +
                         THMR_ac_DW.UnitDelay5_DSTATE_o) +
                        THMR_ac_DW.UnitDelay6_DSTATE_i) +
                       THMR_ac_DW.UnitDelay7_DSTATE) +
                      THMR_ac_DW.UnitDelay8_DSTATE) +
                     THMR_ac_DW.UnitDelay9_DSTATE) +
                    THMR_ac_DW.UnitDelay10_DSTATE) +
                   THMR_ac_DW.UnitDelay12_DSTATE) +
                  THMR_ac_DW.UnitDelay13_DSTATE) + THMR_ac_DW.UnitDelay11_DSTATE)
                + THMR_ac_DW.UnitDelay15_DSTATE) + THMR_ac_DW.UnitDelay16_DSTATE)
              + THMR_ac_DW.UnitDelay14_DSTATE) + THMR_ac_DW.UnitDelay18_DSTATE)
            + THMR_ac_DW.UnitDelay19_DSTATE;
        break;

      default:
        /* MultiPortSwitch: '<S968>/Multiport Switch' incorporates:
         *  Sum: '<S968>/Sum'
         *  Sum: '<S968>/Sum1'
         *  Sum: '<S968>/Sum10'
         *  Sum: '<S968>/Sum11'
         *  Sum: '<S968>/Sum12'
         *  Sum: '<S968>/Sum13'
         *  Sum: '<S968>/Sum14'
         *  Sum: '<S968>/Sum15'
         *  Sum: '<S968>/Sum16'
         *  Sum: '<S968>/Sum19'
         *  Sum: '<S968>/Sum2'
         *  Sum: '<S968>/Sum20'
         *  Sum: '<S968>/Sum3'
         *  Sum: '<S968>/Sum4'
         *  Sum: '<S968>/Sum5'
         *  Sum: '<S968>/Sum6'
         *  Sum: '<S968>/Sum7'
         *  Sum: '<S968>/Sum8'
         *  Sum: '<S968>/Sum9'
         *  UnitDelay: '<S968>/Unit Delay1'
         *  UnitDelay: '<S968>/Unit Delay10'
         *  UnitDelay: '<S968>/Unit Delay11'
         *  UnitDelay: '<S968>/Unit Delay12'
         *  UnitDelay: '<S968>/Unit Delay13'
         *  UnitDelay: '<S968>/Unit Delay14'
         *  UnitDelay: '<S968>/Unit Delay15'
         *  UnitDelay: '<S968>/Unit Delay16'
         *  UnitDelay: '<S968>/Unit Delay17'
         *  UnitDelay: '<S968>/Unit Delay18'
         *  UnitDelay: '<S968>/Unit Delay19'
         *  UnitDelay: '<S968>/Unit Delay2'
         *  UnitDelay: '<S968>/Unit Delay3'
         *  UnitDelay: '<S968>/Unit Delay4'
         *  UnitDelay: '<S968>/Unit Delay5'
         *  UnitDelay: '<S968>/Unit Delay6'
         *  UnitDelay: '<S968>/Unit Delay7'
         *  UnitDelay: '<S968>/Unit Delay8'
         *  UnitDelay: '<S968>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiToutGrd_MP =
            ((((((((((((((((((rtb_TmpSignalConversionAtVeT_ge +
                              THMR_ac_DW.UnitDelay1_DSTATE_ot) +
                             THMR_ac_DW.UnitDelay2_DSTATE_da) +
                            THMR_ac_DW.UnitDelay4_DSTATE_o) +
                           THMR_ac_DW.UnitDelay3_DSTATE_mq) +
                          THMR_ac_DW.UnitDelay5_DSTATE_o) +
                         THMR_ac_DW.UnitDelay6_DSTATE_i) +
                        THMR_ac_DW.UnitDelay7_DSTATE) +
                       THMR_ac_DW.UnitDelay8_DSTATE) +
                      THMR_ac_DW.UnitDelay9_DSTATE) +
                     THMR_ac_DW.UnitDelay10_DSTATE) +
                    THMR_ac_DW.UnitDelay12_DSTATE) +
                   THMR_ac_DW.UnitDelay13_DSTATE) +
                  THMR_ac_DW.UnitDelay11_DSTATE) + THMR_ac_DW.UnitDelay15_DSTATE)
                + THMR_ac_DW.UnitDelay16_DSTATE) + THMR_ac_DW.UnitDelay14_DSTATE)
              + THMR_ac_DW.UnitDelay18_DSTATE) + THMR_ac_DW.UnitDelay19_DSTATE)
            + THMR_ac_DW.UnitDelay17_DSTATE;
        break;
    }

    /* End of MultiPortSwitch: '<S968>/Multiport Switch' */

    /* Product: '<S947>/Divide1' incorporates:
     *  Constant: '<S947>/Constant5'
     *  Constant: '<S966>/Calib'
     *  Gain: '<S947>/Gain2'
     *  Product: '<S947>/Divide'
     *  Product: '<S947>/Product3'
     */
    VeTHMR_k_ElVlv3WayFuCellDif_MP = ((-(VeTHMR_T_SumSampleFuCellHiToutGrd_MP /
        KeTHMR_Cnt_SampleFuCellHiToutGrd_C)) * VeTHMR_k_DHiTRegFuCell) / 0.1F;

    /* Sum: '<S947>/Sum1' */
    VeTHMR_k_ElVlv3WayFuCellPIDRaw = (VeTHMR_k_ElVlv3WayFuCellProp_MP +
        VeTHMR_k_ElVlv3WayFuCellInt_MP) + VeTHMR_k_ElVlv3WayFuCellDif_MP;

    /* Switch: '<S948>/Switch2' incorporates:
     *  Constant: '<S983>/Calib'
     */
    if (KeTHMR_b_SelFacHeatTranCoefOutRadHiT_C)
    {
        /* Sum: '<S949>/Sum9' */
        rtb_TmpSignalConversionAtVePMPR = VeTHMR_T_WaOutRadHiTEstim -
            TmpSignalConversionAtOutAirTemp;

        /* Outputs for Atomic SubSystem: '<S949>/Protected Division' */
        /* Switch: '<S1017>/Switch1' incorporates:
         *  Constant: '<S1017>/Constant Value'
         *  RelationalOperator: '<S1017>/Not Equal'
         */
        if (rtb_TmpSignalConversionAtVePMPR != 0.0F)
        {
            /* Switch: '<S1017>/Switch1' incorporates:
             *  Constant: '<S949>/Constant10'
             *  MinMax: '<S949>/MinMax4'
             *  Product: '<S1017>/Division'
             */
            rtb_TmpSignalConversionAtVePMPR /= fmaxf
                (VeTHMR_dT_TCoFuCellHiTOutFil, 0.1F);
        }
        else
        {
            /* Switch: '<S1017>/Switch1' incorporates:
             *  Constant: '<S1017>/Constant Value4'
             *  Switch: '<S1017>/Switch2'
             *  Switch: '<S1017>/Switch3'
             */
            rtb_TmpSignalConversionAtVePMPR = 0.0F;
        }

        /* End of Switch: '<S1017>/Switch1' */
        /* End of Outputs for SubSystem: '<S949>/Protected Division' */

        /* Switch: '<S902>/Switch2' incorporates:
         *  Constant: '<S949>/Constant11'
         *  Constant: '<S949>/Constant12'
         *  MinMax: '<S996>/MinMax'
         *  MinMax: '<S996>/MinMax1'
         */
        rtb_MinMax7 = fminf(1.0F, fmaxf(rtb_TmpSignalConversionAtVePMPR, 0.0F));
    }

    /* End of Switch: '<S948>/Switch2' */

    /* Switch: '<S902>/Switch2' incorporates:
     *  Lookup_n-D: '<S984>/Vector'
     */
    rtb_MinMax7 = look1_iflf_binlcapw(rtb_MinMax7, ((const float32 *)
        &(KxTHMR_k_FlowCorHiTFuCellMixPt_T[0])), ((const float32 *)
        &(KtTHMR_k_FlowCorHiTFuCellMixPt_T[0])), 10U);

    /* Product: '<S981>/Divide1' incorporates:
     *  Constant: '<S981>/Constant3'
     *  Sum: '<S981>/Subtraction3'
     *  UnitDelay: '<S981>/Unit Delay2'
     */
    rtb_TmpSignalConversionAtVePMPR = (VeTHMR_T_CoFuCellHiTInSpFil -
        THMR_ac_DW.UnitDelay2_DSTATE_ec) / 0.1F;

    /* UnitDelay: '<S991>/Unit Delay1' */
    rtb_TmpSignalConversionAtVeTAIR = THMR_ac_DW.UnitDelay1_DSTATE_fp;

    /* UnitDelay: '<S991>/Unit Delay2' */
    rtb_TmpSignalConversionAtVePM_l = THMR_ac_DW.UnitDelay2_DSTATE_gx;

    /* UnitDelay: '<S991>/Unit Delay4' */
    rtb_Sum3 = THMR_ac_DW.UnitDelay4_DSTATE_h;

    /* UnitDelay: '<S991>/Unit Delay3' */
    rtb_Switch1_d = THMR_ac_DW.UnitDelay3_DSTATE_j;

    /* UnitDelay: '<S991>/Unit Delay5' */
    Switch = THMR_ac_DW.UnitDelay5_DSTATE_h;

    /* UnitDelay: '<S991>/Unit Delay6' */
    rtb_TmpSignalConversionAtVeTPDR = THMR_ac_DW.UnitDelay6_DSTATE_h;

    /* UnitDelay: '<S991>/Unit Delay7' */
    rtb_TmpSignalConversionAtVeHT_h = THMR_ac_DW.UnitDelay7_DSTATE_b;

    /* UnitDelay: '<S991>/Unit Delay8' */
    rtb_TmpSignalConversionAtVeT_j5 = THMR_ac_DW.UnitDelay8_DSTATE_j;

    /* UnitDelay: '<S991>/Unit Delay9' */
    rtb_Switch1_pi = THMR_ac_DW.UnitDelay9_DSTATE_h;

    /* UnitDelay: '<S991>/Unit Delay10' */
    rtb_TmpSignalConversionAtVeHT_p = THMR_ac_DW.UnitDelay10_DSTATE_l;

    /* UnitDelay: '<S991>/Unit Delay12' */
    rtb_TmpSignalConversionAtVeHT_o = THMR_ac_DW.UnitDelay12_DSTATE_l;

    /* UnitDelay: '<S991>/Unit Delay13' */
    rtb_Switch1_giu = THMR_ac_DW.UnitDelay13_DSTATE_n;

    /* UnitDelay: '<S991>/Unit Delay11' */
    rtb_Switch2_i1 = THMR_ac_DW.UnitDelay11_DSTATE_f;

    /* UnitDelay: '<S991>/Unit Delay15' */
    rtb_TmpSignalConversionAtVeHT_k = THMR_ac_DW.UnitDelay15_DSTATE_l;

    /* UnitDelay: '<S991>/Unit Delay16' */
    Switch_o = THMR_ac_DW.UnitDelay16_DSTATE_o;

    /* UnitDelay: '<S991>/Unit Delay14' */
    rtb_MinMax1_c = THMR_ac_DW.UnitDelay14_DSTATE_i;

    /* UnitDelay: '<S991>/Unit Delay18' */
    rtb_Sum2_aq = THMR_ac_DW.UnitDelay18_DSTATE_m;

    /* UnitDelay: '<S991>/Unit Delay19' */
    rtb_TmpSignalConversionAtVeTFTR = THMR_ac_DW.UnitDelay19_DSTATE_d;

    /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
     *  Constant: '<S990>/Calib'
     *  Constant: '<S991>/Constant1'
     *  Constant: '<S991>/Constant4'
     *  MinMax: '<S992>/MinMax'
     *  MinMax: '<S992>/MinMax1'
     */
    switch ((sint32)fminf(20.0F, fmaxf(KeTHMR_Cnt_SampleFuCellHiTInSpGrd_C, 1.0F)))
    {
      case 1:
        /* MultiPortSwitch: '<S991>/Multiport Switch' */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP = rtb_TmpSignalConversionAtVePMPR;
        break;

      case 2:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  UnitDelay: '<S991>/Unit Delay1'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP = rtb_TmpSignalConversionAtVePMPR
            + THMR_ac_DW.UnitDelay1_DSTATE_fp;
        break;

      case 3:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay2'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP = (rtb_TmpSignalConversionAtVePMPR
            + THMR_ac_DW.UnitDelay1_DSTATE_fp) + THMR_ac_DW.UnitDelay2_DSTATE_gx;
        break;

      case 4:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum2'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay4'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            ((rtb_TmpSignalConversionAtVePMPR + THMR_ac_DW.UnitDelay1_DSTATE_fp)
             + THMR_ac_DW.UnitDelay2_DSTATE_gx) + THMR_ac_DW.UnitDelay4_DSTATE_h;
        break;

      case 5:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum3'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            (((rtb_TmpSignalConversionAtVePMPR + THMR_ac_DW.UnitDelay1_DSTATE_fp)
              + THMR_ac_DW.UnitDelay2_DSTATE_gx) +
             THMR_ac_DW.UnitDelay4_DSTATE_h) + THMR_ac_DW.UnitDelay3_DSTATE_j;
        break;

      case 6:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum3'
         *  Sum: '<S991>/Sum4'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         *  UnitDelay: '<S991>/Unit Delay5'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            ((((rtb_TmpSignalConversionAtVePMPR +
                THMR_ac_DW.UnitDelay1_DSTATE_fp) +
               THMR_ac_DW.UnitDelay2_DSTATE_gx) + THMR_ac_DW.UnitDelay4_DSTATE_h)
             + THMR_ac_DW.UnitDelay3_DSTATE_j) + THMR_ac_DW.UnitDelay5_DSTATE_h;
        break;

      case 7:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum3'
         *  Sum: '<S991>/Sum4'
         *  Sum: '<S991>/Sum5'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         *  UnitDelay: '<S991>/Unit Delay5'
         *  UnitDelay: '<S991>/Unit Delay6'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            (((((rtb_TmpSignalConversionAtVePMPR +
                 THMR_ac_DW.UnitDelay1_DSTATE_fp) +
                THMR_ac_DW.UnitDelay2_DSTATE_gx) +
               THMR_ac_DW.UnitDelay4_DSTATE_h) + THMR_ac_DW.UnitDelay3_DSTATE_j)
             + THMR_ac_DW.UnitDelay5_DSTATE_h) + THMR_ac_DW.UnitDelay6_DSTATE_h;
        break;

      case 8:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum3'
         *  Sum: '<S991>/Sum4'
         *  Sum: '<S991>/Sum5'
         *  Sum: '<S991>/Sum6'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         *  UnitDelay: '<S991>/Unit Delay5'
         *  UnitDelay: '<S991>/Unit Delay6'
         *  UnitDelay: '<S991>/Unit Delay7'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            ((((((rtb_TmpSignalConversionAtVePMPR +
                  THMR_ac_DW.UnitDelay1_DSTATE_fp) +
                 THMR_ac_DW.UnitDelay2_DSTATE_gx) +
                THMR_ac_DW.UnitDelay4_DSTATE_h) + THMR_ac_DW.UnitDelay3_DSTATE_j)
              + THMR_ac_DW.UnitDelay5_DSTATE_h) + THMR_ac_DW.UnitDelay6_DSTATE_h)
            + THMR_ac_DW.UnitDelay7_DSTATE_b;
        break;

      case 9:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum3'
         *  Sum: '<S991>/Sum4'
         *  Sum: '<S991>/Sum5'
         *  Sum: '<S991>/Sum6'
         *  Sum: '<S991>/Sum7'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         *  UnitDelay: '<S991>/Unit Delay5'
         *  UnitDelay: '<S991>/Unit Delay6'
         *  UnitDelay: '<S991>/Unit Delay7'
         *  UnitDelay: '<S991>/Unit Delay8'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            (((((((rtb_TmpSignalConversionAtVePMPR +
                   THMR_ac_DW.UnitDelay1_DSTATE_fp) +
                  THMR_ac_DW.UnitDelay2_DSTATE_gx) +
                 THMR_ac_DW.UnitDelay4_DSTATE_h) +
                THMR_ac_DW.UnitDelay3_DSTATE_j) + THMR_ac_DW.UnitDelay5_DSTATE_h)
              + THMR_ac_DW.UnitDelay6_DSTATE_h) + THMR_ac_DW.UnitDelay7_DSTATE_b)
            + THMR_ac_DW.UnitDelay8_DSTATE_j;
        break;

      case 10:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum3'
         *  Sum: '<S991>/Sum4'
         *  Sum: '<S991>/Sum5'
         *  Sum: '<S991>/Sum6'
         *  Sum: '<S991>/Sum7'
         *  Sum: '<S991>/Sum8'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         *  UnitDelay: '<S991>/Unit Delay5'
         *  UnitDelay: '<S991>/Unit Delay6'
         *  UnitDelay: '<S991>/Unit Delay7'
         *  UnitDelay: '<S991>/Unit Delay8'
         *  UnitDelay: '<S991>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            ((((((((rtb_TmpSignalConversionAtVePMPR +
                    THMR_ac_DW.UnitDelay1_DSTATE_fp) +
                   THMR_ac_DW.UnitDelay2_DSTATE_gx) +
                  THMR_ac_DW.UnitDelay4_DSTATE_h) +
                 THMR_ac_DW.UnitDelay3_DSTATE_j) +
                THMR_ac_DW.UnitDelay5_DSTATE_h) + THMR_ac_DW.UnitDelay6_DSTATE_h)
              + THMR_ac_DW.UnitDelay7_DSTATE_b) + THMR_ac_DW.UnitDelay8_DSTATE_j)
            + THMR_ac_DW.UnitDelay9_DSTATE_h;
        break;

      case 11:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum3'
         *  Sum: '<S991>/Sum4'
         *  Sum: '<S991>/Sum5'
         *  Sum: '<S991>/Sum6'
         *  Sum: '<S991>/Sum7'
         *  Sum: '<S991>/Sum8'
         *  Sum: '<S991>/Sum9'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay10'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         *  UnitDelay: '<S991>/Unit Delay5'
         *  UnitDelay: '<S991>/Unit Delay6'
         *  UnitDelay: '<S991>/Unit Delay7'
         *  UnitDelay: '<S991>/Unit Delay8'
         *  UnitDelay: '<S991>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            (((((((((rtb_TmpSignalConversionAtVePMPR +
                     THMR_ac_DW.UnitDelay1_DSTATE_fp) +
                    THMR_ac_DW.UnitDelay2_DSTATE_gx) +
                   THMR_ac_DW.UnitDelay4_DSTATE_h) +
                  THMR_ac_DW.UnitDelay3_DSTATE_j) +
                 THMR_ac_DW.UnitDelay5_DSTATE_h) +
                THMR_ac_DW.UnitDelay6_DSTATE_h) + THMR_ac_DW.UnitDelay7_DSTATE_b)
              + THMR_ac_DW.UnitDelay8_DSTATE_j) + THMR_ac_DW.UnitDelay9_DSTATE_h)
            + THMR_ac_DW.UnitDelay10_DSTATE_l;
        break;

      case 12:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum10'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum3'
         *  Sum: '<S991>/Sum4'
         *  Sum: '<S991>/Sum5'
         *  Sum: '<S991>/Sum6'
         *  Sum: '<S991>/Sum7'
         *  Sum: '<S991>/Sum8'
         *  Sum: '<S991>/Sum9'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay10'
         *  UnitDelay: '<S991>/Unit Delay12'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         *  UnitDelay: '<S991>/Unit Delay5'
         *  UnitDelay: '<S991>/Unit Delay6'
         *  UnitDelay: '<S991>/Unit Delay7'
         *  UnitDelay: '<S991>/Unit Delay8'
         *  UnitDelay: '<S991>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            ((((((((((rtb_TmpSignalConversionAtVePMPR +
                      THMR_ac_DW.UnitDelay1_DSTATE_fp) +
                     THMR_ac_DW.UnitDelay2_DSTATE_gx) +
                    THMR_ac_DW.UnitDelay4_DSTATE_h) +
                   THMR_ac_DW.UnitDelay3_DSTATE_j) +
                  THMR_ac_DW.UnitDelay5_DSTATE_h) +
                 THMR_ac_DW.UnitDelay6_DSTATE_h) +
                THMR_ac_DW.UnitDelay7_DSTATE_b) + THMR_ac_DW.UnitDelay8_DSTATE_j)
              + THMR_ac_DW.UnitDelay9_DSTATE_h) +
             THMR_ac_DW.UnitDelay10_DSTATE_l) + THMR_ac_DW.UnitDelay12_DSTATE_l;
        break;

      case 13:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum10'
         *  Sum: '<S991>/Sum11'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum3'
         *  Sum: '<S991>/Sum4'
         *  Sum: '<S991>/Sum5'
         *  Sum: '<S991>/Sum6'
         *  Sum: '<S991>/Sum7'
         *  Sum: '<S991>/Sum8'
         *  Sum: '<S991>/Sum9'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay10'
         *  UnitDelay: '<S991>/Unit Delay12'
         *  UnitDelay: '<S991>/Unit Delay13'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         *  UnitDelay: '<S991>/Unit Delay5'
         *  UnitDelay: '<S991>/Unit Delay6'
         *  UnitDelay: '<S991>/Unit Delay7'
         *  UnitDelay: '<S991>/Unit Delay8'
         *  UnitDelay: '<S991>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            (((((((((((rtb_TmpSignalConversionAtVePMPR +
                       THMR_ac_DW.UnitDelay1_DSTATE_fp) +
                      THMR_ac_DW.UnitDelay2_DSTATE_gx) +
                     THMR_ac_DW.UnitDelay4_DSTATE_h) +
                    THMR_ac_DW.UnitDelay3_DSTATE_j) +
                   THMR_ac_DW.UnitDelay5_DSTATE_h) +
                  THMR_ac_DW.UnitDelay6_DSTATE_h) +
                 THMR_ac_DW.UnitDelay7_DSTATE_b) +
                THMR_ac_DW.UnitDelay8_DSTATE_j) + THMR_ac_DW.UnitDelay9_DSTATE_h)
              + THMR_ac_DW.UnitDelay10_DSTATE_l) +
             THMR_ac_DW.UnitDelay12_DSTATE_l) + THMR_ac_DW.UnitDelay13_DSTATE_n;
        break;

      case 14:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum10'
         *  Sum: '<S991>/Sum11'
         *  Sum: '<S991>/Sum12'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum3'
         *  Sum: '<S991>/Sum4'
         *  Sum: '<S991>/Sum5'
         *  Sum: '<S991>/Sum6'
         *  Sum: '<S991>/Sum7'
         *  Sum: '<S991>/Sum8'
         *  Sum: '<S991>/Sum9'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay10'
         *  UnitDelay: '<S991>/Unit Delay11'
         *  UnitDelay: '<S991>/Unit Delay12'
         *  UnitDelay: '<S991>/Unit Delay13'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         *  UnitDelay: '<S991>/Unit Delay5'
         *  UnitDelay: '<S991>/Unit Delay6'
         *  UnitDelay: '<S991>/Unit Delay7'
         *  UnitDelay: '<S991>/Unit Delay8'
         *  UnitDelay: '<S991>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            ((((((((((((rtb_TmpSignalConversionAtVePMPR +
                        THMR_ac_DW.UnitDelay1_DSTATE_fp) +
                       THMR_ac_DW.UnitDelay2_DSTATE_gx) +
                      THMR_ac_DW.UnitDelay4_DSTATE_h) +
                     THMR_ac_DW.UnitDelay3_DSTATE_j) +
                    THMR_ac_DW.UnitDelay5_DSTATE_h) +
                   THMR_ac_DW.UnitDelay6_DSTATE_h) +
                  THMR_ac_DW.UnitDelay7_DSTATE_b) +
                 THMR_ac_DW.UnitDelay8_DSTATE_j) +
                THMR_ac_DW.UnitDelay9_DSTATE_h) +
               THMR_ac_DW.UnitDelay10_DSTATE_l) +
              THMR_ac_DW.UnitDelay12_DSTATE_l) + THMR_ac_DW.UnitDelay13_DSTATE_n)
            + THMR_ac_DW.UnitDelay11_DSTATE_f;
        break;

      case 15:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum10'
         *  Sum: '<S991>/Sum11'
         *  Sum: '<S991>/Sum12'
         *  Sum: '<S991>/Sum13'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum3'
         *  Sum: '<S991>/Sum4'
         *  Sum: '<S991>/Sum5'
         *  Sum: '<S991>/Sum6'
         *  Sum: '<S991>/Sum7'
         *  Sum: '<S991>/Sum8'
         *  Sum: '<S991>/Sum9'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay10'
         *  UnitDelay: '<S991>/Unit Delay11'
         *  UnitDelay: '<S991>/Unit Delay12'
         *  UnitDelay: '<S991>/Unit Delay13'
         *  UnitDelay: '<S991>/Unit Delay15'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         *  UnitDelay: '<S991>/Unit Delay5'
         *  UnitDelay: '<S991>/Unit Delay6'
         *  UnitDelay: '<S991>/Unit Delay7'
         *  UnitDelay: '<S991>/Unit Delay8'
         *  UnitDelay: '<S991>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            (((((((((((((rtb_TmpSignalConversionAtVePMPR +
                         THMR_ac_DW.UnitDelay1_DSTATE_fp) +
                        THMR_ac_DW.UnitDelay2_DSTATE_gx) +
                       THMR_ac_DW.UnitDelay4_DSTATE_h) +
                      THMR_ac_DW.UnitDelay3_DSTATE_j) +
                     THMR_ac_DW.UnitDelay5_DSTATE_h) +
                    THMR_ac_DW.UnitDelay6_DSTATE_h) +
                   THMR_ac_DW.UnitDelay7_DSTATE_b) +
                  THMR_ac_DW.UnitDelay8_DSTATE_j) +
                 THMR_ac_DW.UnitDelay9_DSTATE_h) +
                THMR_ac_DW.UnitDelay10_DSTATE_l) +
               THMR_ac_DW.UnitDelay12_DSTATE_l) +
              THMR_ac_DW.UnitDelay13_DSTATE_n) + THMR_ac_DW.UnitDelay11_DSTATE_f)
            + THMR_ac_DW.UnitDelay15_DSTATE_l;
        break;

      case 16:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum10'
         *  Sum: '<S991>/Sum11'
         *  Sum: '<S991>/Sum12'
         *  Sum: '<S991>/Sum13'
         *  Sum: '<S991>/Sum14'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum3'
         *  Sum: '<S991>/Sum4'
         *  Sum: '<S991>/Sum5'
         *  Sum: '<S991>/Sum6'
         *  Sum: '<S991>/Sum7'
         *  Sum: '<S991>/Sum8'
         *  Sum: '<S991>/Sum9'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay10'
         *  UnitDelay: '<S991>/Unit Delay11'
         *  UnitDelay: '<S991>/Unit Delay12'
         *  UnitDelay: '<S991>/Unit Delay13'
         *  UnitDelay: '<S991>/Unit Delay15'
         *  UnitDelay: '<S991>/Unit Delay16'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         *  UnitDelay: '<S991>/Unit Delay5'
         *  UnitDelay: '<S991>/Unit Delay6'
         *  UnitDelay: '<S991>/Unit Delay7'
         *  UnitDelay: '<S991>/Unit Delay8'
         *  UnitDelay: '<S991>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            ((((((((((((((rtb_TmpSignalConversionAtVePMPR +
                          THMR_ac_DW.UnitDelay1_DSTATE_fp) +
                         THMR_ac_DW.UnitDelay2_DSTATE_gx) +
                        THMR_ac_DW.UnitDelay4_DSTATE_h) +
                       THMR_ac_DW.UnitDelay3_DSTATE_j) +
                      THMR_ac_DW.UnitDelay5_DSTATE_h) +
                     THMR_ac_DW.UnitDelay6_DSTATE_h) +
                    THMR_ac_DW.UnitDelay7_DSTATE_b) +
                   THMR_ac_DW.UnitDelay8_DSTATE_j) +
                  THMR_ac_DW.UnitDelay9_DSTATE_h) +
                 THMR_ac_DW.UnitDelay10_DSTATE_l) +
                THMR_ac_DW.UnitDelay12_DSTATE_l) +
               THMR_ac_DW.UnitDelay13_DSTATE_n) +
              THMR_ac_DW.UnitDelay11_DSTATE_f) + THMR_ac_DW.UnitDelay15_DSTATE_l)
            + THMR_ac_DW.UnitDelay16_DSTATE_o;
        break;

      case 17:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum10'
         *  Sum: '<S991>/Sum11'
         *  Sum: '<S991>/Sum12'
         *  Sum: '<S991>/Sum13'
         *  Sum: '<S991>/Sum14'
         *  Sum: '<S991>/Sum15'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum3'
         *  Sum: '<S991>/Sum4'
         *  Sum: '<S991>/Sum5'
         *  Sum: '<S991>/Sum6'
         *  Sum: '<S991>/Sum7'
         *  Sum: '<S991>/Sum8'
         *  Sum: '<S991>/Sum9'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay10'
         *  UnitDelay: '<S991>/Unit Delay11'
         *  UnitDelay: '<S991>/Unit Delay12'
         *  UnitDelay: '<S991>/Unit Delay13'
         *  UnitDelay: '<S991>/Unit Delay14'
         *  UnitDelay: '<S991>/Unit Delay15'
         *  UnitDelay: '<S991>/Unit Delay16'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         *  UnitDelay: '<S991>/Unit Delay5'
         *  UnitDelay: '<S991>/Unit Delay6'
         *  UnitDelay: '<S991>/Unit Delay7'
         *  UnitDelay: '<S991>/Unit Delay8'
         *  UnitDelay: '<S991>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            (((((((((((((((rtb_TmpSignalConversionAtVePMPR +
                           THMR_ac_DW.UnitDelay1_DSTATE_fp) +
                          THMR_ac_DW.UnitDelay2_DSTATE_gx) +
                         THMR_ac_DW.UnitDelay4_DSTATE_h) +
                        THMR_ac_DW.UnitDelay3_DSTATE_j) +
                       THMR_ac_DW.UnitDelay5_DSTATE_h) +
                      THMR_ac_DW.UnitDelay6_DSTATE_h) +
                     THMR_ac_DW.UnitDelay7_DSTATE_b) +
                    THMR_ac_DW.UnitDelay8_DSTATE_j) +
                   THMR_ac_DW.UnitDelay9_DSTATE_h) +
                  THMR_ac_DW.UnitDelay10_DSTATE_l) +
                 THMR_ac_DW.UnitDelay12_DSTATE_l) +
                THMR_ac_DW.UnitDelay13_DSTATE_n) +
               THMR_ac_DW.UnitDelay11_DSTATE_f) +
              THMR_ac_DW.UnitDelay15_DSTATE_l) + THMR_ac_DW.UnitDelay16_DSTATE_o)
            + THMR_ac_DW.UnitDelay14_DSTATE_i;
        break;

      case 18:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum10'
         *  Sum: '<S991>/Sum11'
         *  Sum: '<S991>/Sum12'
         *  Sum: '<S991>/Sum13'
         *  Sum: '<S991>/Sum14'
         *  Sum: '<S991>/Sum15'
         *  Sum: '<S991>/Sum16'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum3'
         *  Sum: '<S991>/Sum4'
         *  Sum: '<S991>/Sum5'
         *  Sum: '<S991>/Sum6'
         *  Sum: '<S991>/Sum7'
         *  Sum: '<S991>/Sum8'
         *  Sum: '<S991>/Sum9'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay10'
         *  UnitDelay: '<S991>/Unit Delay11'
         *  UnitDelay: '<S991>/Unit Delay12'
         *  UnitDelay: '<S991>/Unit Delay13'
         *  UnitDelay: '<S991>/Unit Delay14'
         *  UnitDelay: '<S991>/Unit Delay15'
         *  UnitDelay: '<S991>/Unit Delay16'
         *  UnitDelay: '<S991>/Unit Delay18'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         *  UnitDelay: '<S991>/Unit Delay5'
         *  UnitDelay: '<S991>/Unit Delay6'
         *  UnitDelay: '<S991>/Unit Delay7'
         *  UnitDelay: '<S991>/Unit Delay8'
         *  UnitDelay: '<S991>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            ((((((((((((((((rtb_TmpSignalConversionAtVePMPR +
                            THMR_ac_DW.UnitDelay1_DSTATE_fp) +
                           THMR_ac_DW.UnitDelay2_DSTATE_gx) +
                          THMR_ac_DW.UnitDelay4_DSTATE_h) +
                         THMR_ac_DW.UnitDelay3_DSTATE_j) +
                        THMR_ac_DW.UnitDelay5_DSTATE_h) +
                       THMR_ac_DW.UnitDelay6_DSTATE_h) +
                      THMR_ac_DW.UnitDelay7_DSTATE_b) +
                     THMR_ac_DW.UnitDelay8_DSTATE_j) +
                    THMR_ac_DW.UnitDelay9_DSTATE_h) +
                   THMR_ac_DW.UnitDelay10_DSTATE_l) +
                  THMR_ac_DW.UnitDelay12_DSTATE_l) +
                 THMR_ac_DW.UnitDelay13_DSTATE_n) +
                THMR_ac_DW.UnitDelay11_DSTATE_f) +
               THMR_ac_DW.UnitDelay15_DSTATE_l) +
              THMR_ac_DW.UnitDelay16_DSTATE_o) + THMR_ac_DW.UnitDelay14_DSTATE_i)
            + THMR_ac_DW.UnitDelay18_DSTATE_m;
        break;

      case 19:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum10'
         *  Sum: '<S991>/Sum11'
         *  Sum: '<S991>/Sum12'
         *  Sum: '<S991>/Sum13'
         *  Sum: '<S991>/Sum14'
         *  Sum: '<S991>/Sum15'
         *  Sum: '<S991>/Sum16'
         *  Sum: '<S991>/Sum19'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum3'
         *  Sum: '<S991>/Sum4'
         *  Sum: '<S991>/Sum5'
         *  Sum: '<S991>/Sum6'
         *  Sum: '<S991>/Sum7'
         *  Sum: '<S991>/Sum8'
         *  Sum: '<S991>/Sum9'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay10'
         *  UnitDelay: '<S991>/Unit Delay11'
         *  UnitDelay: '<S991>/Unit Delay12'
         *  UnitDelay: '<S991>/Unit Delay13'
         *  UnitDelay: '<S991>/Unit Delay14'
         *  UnitDelay: '<S991>/Unit Delay15'
         *  UnitDelay: '<S991>/Unit Delay16'
         *  UnitDelay: '<S991>/Unit Delay18'
         *  UnitDelay: '<S991>/Unit Delay19'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         *  UnitDelay: '<S991>/Unit Delay5'
         *  UnitDelay: '<S991>/Unit Delay6'
         *  UnitDelay: '<S991>/Unit Delay7'
         *  UnitDelay: '<S991>/Unit Delay8'
         *  UnitDelay: '<S991>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            (((((((((((((((((rtb_TmpSignalConversionAtVePMPR +
                             THMR_ac_DW.UnitDelay1_DSTATE_fp) +
                            THMR_ac_DW.UnitDelay2_DSTATE_gx) +
                           THMR_ac_DW.UnitDelay4_DSTATE_h) +
                          THMR_ac_DW.UnitDelay3_DSTATE_j) +
                         THMR_ac_DW.UnitDelay5_DSTATE_h) +
                        THMR_ac_DW.UnitDelay6_DSTATE_h) +
                       THMR_ac_DW.UnitDelay7_DSTATE_b) +
                      THMR_ac_DW.UnitDelay8_DSTATE_j) +
                     THMR_ac_DW.UnitDelay9_DSTATE_h) +
                    THMR_ac_DW.UnitDelay10_DSTATE_l) +
                   THMR_ac_DW.UnitDelay12_DSTATE_l) +
                  THMR_ac_DW.UnitDelay13_DSTATE_n) +
                 THMR_ac_DW.UnitDelay11_DSTATE_f) +
                THMR_ac_DW.UnitDelay15_DSTATE_l) +
               THMR_ac_DW.UnitDelay16_DSTATE_o) +
              THMR_ac_DW.UnitDelay14_DSTATE_i) + THMR_ac_DW.UnitDelay18_DSTATE_m)
            + THMR_ac_DW.UnitDelay19_DSTATE_d;
        break;

      default:
        /* MultiPortSwitch: '<S991>/Multiport Switch' incorporates:
         *  Sum: '<S991>/Sum'
         *  Sum: '<S991>/Sum1'
         *  Sum: '<S991>/Sum10'
         *  Sum: '<S991>/Sum11'
         *  Sum: '<S991>/Sum12'
         *  Sum: '<S991>/Sum13'
         *  Sum: '<S991>/Sum14'
         *  Sum: '<S991>/Sum15'
         *  Sum: '<S991>/Sum16'
         *  Sum: '<S991>/Sum19'
         *  Sum: '<S991>/Sum2'
         *  Sum: '<S991>/Sum20'
         *  Sum: '<S991>/Sum3'
         *  Sum: '<S991>/Sum4'
         *  Sum: '<S991>/Sum5'
         *  Sum: '<S991>/Sum6'
         *  Sum: '<S991>/Sum7'
         *  Sum: '<S991>/Sum8'
         *  Sum: '<S991>/Sum9'
         *  UnitDelay: '<S991>/Unit Delay1'
         *  UnitDelay: '<S991>/Unit Delay10'
         *  UnitDelay: '<S991>/Unit Delay11'
         *  UnitDelay: '<S991>/Unit Delay12'
         *  UnitDelay: '<S991>/Unit Delay13'
         *  UnitDelay: '<S991>/Unit Delay14'
         *  UnitDelay: '<S991>/Unit Delay15'
         *  UnitDelay: '<S991>/Unit Delay16'
         *  UnitDelay: '<S991>/Unit Delay17'
         *  UnitDelay: '<S991>/Unit Delay18'
         *  UnitDelay: '<S991>/Unit Delay19'
         *  UnitDelay: '<S991>/Unit Delay2'
         *  UnitDelay: '<S991>/Unit Delay3'
         *  UnitDelay: '<S991>/Unit Delay4'
         *  UnitDelay: '<S991>/Unit Delay5'
         *  UnitDelay: '<S991>/Unit Delay6'
         *  UnitDelay: '<S991>/Unit Delay7'
         *  UnitDelay: '<S991>/Unit Delay8'
         *  UnitDelay: '<S991>/Unit Delay9'
         */
        VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP =
            ((((((((((((((((((rtb_TmpSignalConversionAtVePMPR +
                              THMR_ac_DW.UnitDelay1_DSTATE_fp) +
                             THMR_ac_DW.UnitDelay2_DSTATE_gx) +
                            THMR_ac_DW.UnitDelay4_DSTATE_h) +
                           THMR_ac_DW.UnitDelay3_DSTATE_j) +
                          THMR_ac_DW.UnitDelay5_DSTATE_h) +
                         THMR_ac_DW.UnitDelay6_DSTATE_h) +
                        THMR_ac_DW.UnitDelay7_DSTATE_b) +
                       THMR_ac_DW.UnitDelay8_DSTATE_j) +
                      THMR_ac_DW.UnitDelay9_DSTATE_h) +
                     THMR_ac_DW.UnitDelay10_DSTATE_l) +
                    THMR_ac_DW.UnitDelay12_DSTATE_l) +
                   THMR_ac_DW.UnitDelay13_DSTATE_n) +
                  THMR_ac_DW.UnitDelay11_DSTATE_f) +
                 THMR_ac_DW.UnitDelay15_DSTATE_l) +
                THMR_ac_DW.UnitDelay16_DSTATE_o) +
               THMR_ac_DW.UnitDelay14_DSTATE_i) +
              THMR_ac_DW.UnitDelay18_DSTATE_m) + THMR_ac_DW.UnitDelay19_DSTATE_d)
            + THMR_ac_DW.UnitDelay17_DSTATE_i;
        break;
    }

    /* End of MultiPortSwitch: '<S991>/Multiport Switch' */

    /* Product: '<S981>/Product1' incorporates:
     *  Constant: '<S989>/Calib'
     *  Constant: '<S990>/Calib'
     *  Product: '<S981>/Divide2'
     */
    VeTHMR_T_CoFuCellHiTInSpFilDFf = (VeTHMR_T_SumSampleFuCellHiTInSpGrd_MP /
        KeTHMR_Cnt_SampleFuCellHiTInSpGrd_C) *
        KeTHMR_Cnt_CoFuCellHiTInSpPredFf_C;

    /* Sum: '<S981>/Subtraction1' */
    VeTHMR_T_CoFuCellHiTInSpFilFf_MP = VeTHMR_T_CoFuCellHiTInSpFilDFf +
        VeTHMR_T_CoFuCellHiTInSpFil;

    /* MinMax: '<S988>/MinMax' incorporates:
     *  Constant: '<S981>/Constant1'
     *  Constant: '<S981>/Constant2'
     *  MinMax: '<S988>/MinMax1'
     */
    VeTHMR_T_CoFuCellHiTInSpFilFf = fminf(140.0F, fmaxf
        (VeTHMR_T_CoFuCellHiTInSpFilFf_MP, -40.0F));

    /* Product: '<S948>/Product1' incorporates:
     *  Sum: '<S948>/Subtraction1'
     */
    rtb_MinMax7 *= VeTHMR_T_CoFuCellHiTInSpFilFf - VeTHMR_T_WaOutRadHiTFil;

    /* Gain: '<S1019>/Gain' */
    VeTHMR_T_CoFuCellHiTOutSpFil = Switch3_h[0];

    /* MinMax: '<S948>/MinMax' incorporates:
     *  Constant: '<S948>/Constant3'
     *  Sum: '<S948>/Subtraction2'
     */
    rtb_Switch1_pn[0] = fmaxf(0.001F, VeTHMR_T_CoFuCellHiTOutFil -
        VeTHMR_T_WaOutRadHiTFil);
    rtb_Switch1_pn[1] = fmaxf(0.001F, VeTHMR_T_CoFuCellHiTOutSpFil -
        VeTHMR_T_WaOutRadHiTFil);

    /* Outputs for Atomic SubSystem: '<S948>/Protected Division' */
    /* RelationalOperator: '<S985>/Not Equal' incorporates:
     *  Constant: '<S985>/Constant Value'
     */
    rtb_TmpSignalConversionAtVeP_el = (rtb_MinMax7 != 0.0F);

    /* Switch: '<S985>/Switch2' incorporates:
     *  Constant: '<S985>/Constant Value2'
     *  Constant: '<S985>/Constant Value3'
     *  RelationalOperator: '<S985>/Greater Than or Equal '
     *  RelationalOperator: '<S985>/Greater Than or Equal 1'
     *  Switch: '<S985>/Switch3'
     */
    if (rtb_MinMax7 > 0.0F)
    {
        /* Switch: '<S904>/Switch3' incorporates:
         *  Constant: '<S985>/MAXFLOAT'
         */
        rtb_TmpSignalConversionAtVeTA_n = 3.402823466E+38F;
    }
    else if (rtb_MinMax7 < 0.0F)
    {
        /* Switch: '<S985>/Switch3' incorporates:
         *  Constant: '<S985>/MINFLOAT'
         *  Switch: '<S904>/Switch3'
         */
        rtb_TmpSignalConversionAtVeTA_n = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S904>/Switch3' incorporates:
         *  Constant: '<S985>/Constant Value4'
         *  Switch: '<S985>/Switch3'
         */
        rtb_TmpSignalConversionAtVeTA_n = 0.0F;
    }

    /* End of Switch: '<S985>/Switch2' */
    /* End of Outputs for SubSystem: '<S948>/Protected Division' */
    for (i = 0; i < 2; i++)
    {
        /* Outputs for Atomic SubSystem: '<S948>/Protected Division' */
        /* RelationalOperator: '<S985>/Not Equal1' */
        rtb_Switch1_nmk = rtb_Switch1_pn[i];

        /* MinMax: '<S980>/MinMax1' incorporates:
         *  Constant: '<S985>/Constant Value1'
         *  Logic: '<S985>/AND'
         *  Product: '<S985>/Division'
         *  RelationalOperator: '<S985>/Not Equal1'
         *  Switch: '<S985>/Switch1'
         */
        if (rtb_TmpSignalConversionAtVeP_el && (rtb_Switch1_nmk != 0.0F))
        {
            rtb_VeTHMR_Pct_FCHTRRadFanCmd = rtb_MinMax7 / rtb_Switch1_nmk;
        }
        else
        {
            rtb_VeTHMR_Pct_FCHTRRadFanCmd = rtb_TmpSignalConversionAtVeTA_n;
        }

        /* MinMax: '<S980>/MinMax' incorporates:
         *  Constant: '<S955>/Calib'
         *  Constant: '<S956>/Calib'
         *  Gain: '<S948>/Gain'
         *  MinMax: '<S980>/MinMax1'
         *  RelationalOperator: '<S985>/Not Equal1'
         */
        rtb_Switch1_pn[i] = fminf(KeTHMR_k_ElVlv3WayFuCellPIDMax_C, fmaxf(100.0F
            * rtb_VeTHMR_Pct_FCHTRRadFanCmd, KeTHMR_k_ElVlv3WayFuCellPIDMin_C));

        /* End of Outputs for SubSystem: '<S948>/Protected Division' */
    }

    /* Gain: '<S986>/Gain' */
    VeTHMR_k_ElVlv3WayFuCellMixPt = rtb_Switch1_pn[0];

    /* Gain: '<S987>/Gain' */
    VeTHMR_k_ElVlv3WayFuCellMixPtSp = rtb_Switch1_pn[1];

    /* Switch: '<S948>/Switch1' incorporates:
     *  Constant: '<S982>/Calib'
     */
    if (KeTHMR_b_ElVlv3WayFuCellMixPtSel_C)
    {
        /* Switch: '<S948>/Switch1' */
        VeTHMR_k_ElVlv3WayFuCellMixPtSel = VeTHMR_k_ElVlv3WayFuCellMixPt;
    }
    else
    {
        /* Switch: '<S948>/Switch1' */
        VeTHMR_k_ElVlv3WayFuCellMixPtSel = VeTHMR_k_ElVlv3WayFuCellMixPtSp;
    }

    /* End of Switch: '<S948>/Switch1' */

    /* Sum: '<S903>/Subtraction1' */
    rtb_MinMax7 = VeTHMR_k_ElVlv3WayFuCellPIDRaw +
        VeTHMR_k_ElVlv3WayFuCellMixPtSel;

    /* MinMax: '<S945>/MinMax' incorporates:
     *  Constant: '<S955>/Calib'
     *  Constant: '<S956>/Calib'
     *  MinMax: '<S945>/MinMax1'
     */
    VeTHMR_k_ElVlv3WayFuCellPID = fminf(KeTHMR_k_ElVlv3WayFuCellPIDMax_C, fmaxf
        (rtb_MinMax7, KeTHMR_k_ElVlv3WayFuCellPIDMin_C));

    /* Product: '<S950>/Product2' incorporates:
     *  Constant: '<S1048>/Calib'
     *  DataTypeConversion: '<S950>/Data Type Conversion'
     *  Lookup_n-D: '<S1052>/Vector'
     *  Lookup_n-D: '<S1053>/Vector'
     *  MinMax: '<S945>/MinMax'
     *  Product: '<S55>/Product1'
     *  Product: '<S950>/Product1'
     *  RelationalOperator: '<S950>/Relational Operator'
     */
    VeTHMR_P_FuCellMaxLimThStep = (rtb_TmpSignalConversionAtVeFCPR *
        look1_iflf_binlcapw(rtb_TmpSignalConversionAtVeFCPR, ((const float32 *)
        &(KxTHMR_k_FuCellEfcMaxLimThStep_T[0])), ((const float32 *)
        &(KtTHMR_k_FuCellEfcMaxLimThStep_T[0])), 7U)) * look2_iflf_binlcapw
        (VeTHMR_k_ElVlv3WayFuCellPID, (float32)((VeTHMR_k_ElVlv3WayFuCellPID >
           KeTHMR_k_ElVlv3WayFuCellPwrLimThHld_C) ? 1 : 0), ((const float32 *)
          &(KxTHMR_k_PwrFuCellMaxLimThStep_M[0])), ((const float32 *)
          &(KyTHMR_k_PwrFuCellMaxLimThStep_M[0])), ((const float32 *)
          &(KtTHMR_k_PwrFuCellMaxLimThStep_M[0])),
         THMR_ac_ConstP.Vector_maxIndex_jo, 8U);

    /* Lookup_n-D: '<S1054>/Vector' incorporates:
     *  Constant: '<S1048>/Calib'
     *  DataTypeConversion: '<S950>/Data Type Conversion'
     *  MinMax: '<S945>/MinMax'
     *  RelationalOperator: '<S950>/Relational Operator'
     */
    VeTHMR_t_LimFuCellPwrLimTh = look2_iflf_binlcapw(VeTHMR_k_ElVlv3WayFuCellPID,
        (float32)((VeTHMR_k_ElVlv3WayFuCellPID >
                   KeTHMR_k_ElVlv3WayFuCellPwrLimThHld_C) ? 1 : 0), ((const
        float32 *)&(KxTHMR_t_FuCellPwrLimTh_M[0])), ((const float32 *)
        &(KyTHMR_t_FuCellPwrLimTh_M[0])), ((const float32 *)
        &(KtTHMR_t_FuCellPwrLimTh_M[0])), THMR_ac_ConstP.Vector_maxIndex_ja, 7U);

    /* DataTypeConversion: '<S950>/Data Type Conversion2' incorporates:
     *  Gain: '<S950>/Gain'
     */
    rtb_Switch10 = fmodf(floorf(10.0F * VeTHMR_t_LimFuCellPwrLimTh),
                         4.2949673E+9F);

    /* DataTypeConversion: '<S950>/Data Type Conversion2' */
    rtb_DataTypeConversion2 = (rtb_Switch10 < 0.0F) ? (-((sint32)((uint32)
        ((float32)(-rtb_Switch10))))) : ((sint32)((uint32)rtb_Switch10));

    /* Sum: '<S950>/Sum2' incorporates:
     *  Constant: '<S1047>/Calib'
     *  Constant: '<S1048>/Calib'
     */
    rtb_Product1_nd = KeTHMR_k_ElVlv3WayFuCellPwrLimThHld_C +
        KeTHMR_k_ElVlv3WayFuCellPwrLimThDec_C;

    /* Sum: '<S950>/Sum1' incorporates:
     *  Constant: '<S1048>/Calib'
     *  Constant: '<S1049>/Calib'
     */
    rtb_TmpSignalConversionAtVeTA_n = KeTHMR_k_ElVlv3WayFuCellPwrLimThHld_C +
        KeTHMR_k_ElVlv3WayFuCellPwrLimThInc_C;

    /* Sum: '<S950>/Sum3' incorporates:
     *  UnitDelay: '<S950>/Unit Delay1'
     */
    VeTHMR_T_DifCoFuCellHiTOutSpDecHld_MP = THMR_ac_DW.UnitDelay1_DSTATE_j -
        rtb_TmpSignalConversionAtVeFC_k;

    /* RelationalOperator: '<S950>/Relational Operator1' incorporates:
     *  Constant: '<S1044>/Calib'
     */
    rtb_TmpSignalConversionAtVeP_el = (VeTHMR_T_DifCoFuCellHiTOutSpDecHld_MP >
        KeTHMR_T_DifCoFuCellHiTOutSpDecHld_C);

    /* Switch: '<S950>/Switch1' */
    if (rtb_Switch1_p1)
    {
        /* Switch: '<S950>/Switch1' incorporates:
         *  Constant: '<S1041>/Calib'
         */
        rtb_VeTHMR_Pct_FCHTRRadFanCmd = KeTHMR_P_FuCellMaxLimThMaxDft_C;
    }
    else
    {
        /* Switch: '<S950>/Switch1' incorporates:
         *  Constant: '<S1042>/Calib'
         */
        rtb_VeTHMR_Pct_FCHTRRadFanCmd = KeTHMR_P_FuCellMaxLimThMax_C;
    }

    /* End of Switch: '<S950>/Switch1' */

    /* Chart: '<S950>/ElVlv_3_Way_FuCell_PwrMaxLimTh' incorporates:
     *  Constant: '<S1043>/Calib'
     *  Constant: '<S1048>/Calib'
     *  Constant: '<S1050>/Calib'
     *  DataTypeConversion: '<S950>/Data Type Conversion3'
     *  UnitDelay: '<S903>/Unit Delay'
     */
    /* Gateway: THMR_FUNC_RU_MedTEH/FC_Loop/Subsystem/F02_02_04_ElVlv_3_Ways_FuCell/F02_02_04_05_ElVlv_3_Way_FuCell_PwrMaxLimTh/ElVlv_3_Way_FuCell_PwrMaxLimTh */
    /* During: THMR_FUNC_RU_MedTEH/FC_Loop/Subsystem/F02_02_04_ElVlv_3_Ways_FuCell/F02_02_04_05_ElVlv_3_Way_FuCell_PwrMaxLimTh/ElVlv_3_Way_FuCell_PwrMaxLimTh */
    if (((uint32)THMR_ac_DW.is_active_c8_THMR_ac) == 0U)
    {
        /* Entry: THMR_FUNC_RU_MedTEH/FC_Loop/Subsystem/F02_02_04_ElVlv_3_Ways_FuCell/F02_02_04_05_ElVlv_3_Way_FuCell_PwrMaxLimTh/ElVlv_3_Way_FuCell_PwrMaxLimTh */
        THMR_ac_DW.is_active_c8_THMR_ac = 1U;

        /* Entry Internal: THMR_FUNC_RU_MedTEH/FC_Loop/Subsystem/F02_02_04_ElVlv_3_Ways_FuCell/F02_02_04_05_ElVlv_3_Way_FuCell_PwrMaxLimTh/ElVlv_3_Way_FuCell_PwrMaxLimTh */
        /* Transition: '<S1040>:24' */
        THMR_ac_DW.is_c8_THMR_ac = THMR_ac_IN_STATE0_PWR_LIM_RESET;

        /* Entry 'STATE0_PWR_LIM_RESET': '<S1040>:23' */
        VeTHMR_y_PwrFuCellMaxLimTh = 0;
        VeTHMR_P_FuCellMaxLimThStMch = rtb_VeTHMR_Pct_FCHTRRadFanCmd;
        THMR_ac_DW.VeTHMR_P_FuCellMaxLimThStMchRef =
            VeTHMR_P_FuCellMaxLimThStMch;
        THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch = (float32)0.0;
        THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = 0;
    }
    else
    {
        switch (THMR_ac_DW.is_c8_THMR_ac)
        {
          case THMR_ac_IN_STATE0_PWR_LIM_RESET:
            VeTHMR_y_PwrFuCellMaxLimTh = 0;

            /* During 'STATE0_PWR_LIM_RESET': '<S1040>:23' */
            if ((VeTHMR_k_ElVlv3WayFuCellPID <
                    KeTHMR_k_ElVlv3WayFuCellPwrLimThHld_C) &&
                    (!THMR_ac_DW.UnitDelay_DSTATE_bx))
            {
                /* Transition: '<S1040>:26' */
                THMR_ac_DW.is_c8_THMR_ac = THMR_ac_IN_STATE1_PWR_LIM_SET;

                /* Entry 'STATE1_PWR_LIM_SET': '<S1040>:25' */
                VeTHMR_y_PwrFuCellMaxLimTh = 1;
                VeTHMR_P_FuCellMaxLimThStMch = rtb_TmpSignalConversionAtVeFCPR;
                THMR_ac_DW.VeTHMR_P_FuCellMaxLimThStMchRef =
                    VeTHMR_P_FuCellMaxLimThStMch;
            }
            else
            {
                if (rtb_TmpSignalConversionAtVeP_el)
                {
                    /* Transition: '<S1040>:46' */
                    THMR_ac_DW.is_c8_THMR_ac = THMR_IN_STATE6_PWR_LIM_HOLD_DEC;

                    /* Entry 'STATE6_PWR_LIM_HOLD_DEC': '<S1040>:33' */
                    VeTHMR_y_PwrFuCellMaxLimTh = 6;
                    THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = 0;
                }
            }
            break;

          case THMR_ac_IN_STATE1_PWR_LIM_SET:
            /* During 'STATE1_PWR_LIM_SET': '<S1040>:25' */
            /* Transition: '<S1040>:28' */
            THMR_ac_DW.is_c8_THMR_ac = THMR__IN_STATE2_PWR_LIM_MONITOR;

            /* Entry 'STATE2_PWR_LIM_MONITOR': '<S1040>:27' */
            VeTHMR_y_PwrFuCellMaxLimTh = 2;
            THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = 0;
            THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch =
                VeTHMR_P_FuCellMaxLimThStMch /
                THMR_ac_DW.VeTHMR_P_FuCellMaxLimThStMchRef;
            THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch--;
            THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch = fminf
                (THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch, (float32)0.0);
            THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch = fmaxf
                (THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch, THMR_ac_ConSngNegVal);
            break;

          case THMR__IN_STATE2_PWR_LIM_MONITOR:
            VeTHMR_y_PwrFuCellMaxLimTh = 2;

            /* During 'STATE2_PWR_LIM_MONITOR': '<S1040>:27' */
            if (VeTHMR_k_ElVlv3WayFuCellPID >=
                    KeTHMR_k_ElVlv3WayFuCellPwrLimThRst_C)
            {
                /* Transition: '<S1040>:29' */
                THMR_ac_DW.is_c8_THMR_ac = THMR_ac_IN_STATE0_PWR_LIM_RESET;

                /* Entry 'STATE0_PWR_LIM_RESET': '<S1040>:23' */
                VeTHMR_y_PwrFuCellMaxLimTh = 0;
                VeTHMR_P_FuCellMaxLimThStMch = rtb_VeTHMR_Pct_FCHTRRadFanCmd;
                THMR_ac_DW.VeTHMR_P_FuCellMaxLimThStMchRef =
                    VeTHMR_P_FuCellMaxLimThStMch;
                THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch = (float32)0.0;
                THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = 0;
            }
            else if (rtb_TmpSignalConversionAtVeP_el)
            {
                /* Transition: '<S1040>:34' */
                THMR_ac_DW.is_c8_THMR_ac = THMR_IN_STATE6_PWR_LIM_HOLD_DEC;

                /* Entry 'STATE6_PWR_LIM_HOLD_DEC': '<S1040>:33' */
                VeTHMR_y_PwrFuCellMaxLimTh = 6;
                THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = 0;
            }
            else if ((VeTHMR_k_ElVlv3WayFuCellPID >=
                      KeTHMR_k_ElVlv3WayFuCellPwrLimThHld_C) &&
                     (VeTHMR_k_ElVlv3WayFuCellPID <
                      rtb_TmpSignalConversionAtVeTA_n))
            {
                /* Transition: '<S1040>:36' */
                THMR_ac_DW.is_c8_THMR_ac = THMR_ac_IN_STATE5_PWR_LIM_HOLD;

                /* Entry 'STATE5_PWR_LIM_HOLD': '<S1040>:32' */
                VeTHMR_y_PwrFuCellMaxLimTh = 5;
                THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = 0;
            }
            else if (((THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh >=
                       rtb_DataTypeConversion2) && (VeTHMR_k_ElVlv3WayFuCellPID <=
                       rtb_Product1_nd)) && (VeTHMR_P_FuCellMaxLimThStMch >
                      KeTHMR_P_FuCellMaxLimThMin_C))
            {
                /* Transition: '<S1040>:37' */
                THMR_ac_DW.is_c8_THMR_ac = THMR_ac_IN_STATE3_PWR_LIM_DEC;

                /* Entry 'STATE3_PWR_LIM_DEC': '<S1040>:30' */
                VeTHMR_y_PwrFuCellMaxLimTh = 3;
                THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = 0;
                VeTHMR_P_FuCellMaxLimThStMch = VeTHMR_P_FuCellMaxLimThStMch +
                    VeTHMR_P_FuCellMaxLimThStep;
                VeTHMR_P_FuCellMaxLimThStMch = fmaxf
                    (VeTHMR_P_FuCellMaxLimThStMch, KeTHMR_P_FuCellMaxLimThMin_C);
            }
            else if (((THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh >=
                       rtb_DataTypeConversion2) && (VeTHMR_k_ElVlv3WayFuCellPID >=
                       rtb_TmpSignalConversionAtVeTA_n)) &&
                     (VeTHMR_P_FuCellMaxLimThStMch <
                      rtb_VeTHMR_Pct_FCHTRRadFanCmd))
            {
                /* Transition: '<S1040>:38' */
                THMR_ac_DW.is_c8_THMR_ac = THMR_ac_IN_STATE4_PWR_LIM_INC;

                /* Entry 'STATE4_PWR_LIM_INC': '<S1040>:31' */
                VeTHMR_y_PwrFuCellMaxLimTh = 4;
                THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = 0;
                VeTHMR_P_FuCellMaxLimThStMch = VeTHMR_P_FuCellMaxLimThStMch +
                    VeTHMR_P_FuCellMaxLimThStep;
                VeTHMR_P_FuCellMaxLimThStMch = fminf
                    (VeTHMR_P_FuCellMaxLimThStMch, rtb_VeTHMR_Pct_FCHTRRadFanCmd);
            }
            else
            {
                if (THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh > 2147483646)
                {
                    THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = MAX_int32_T;
                }
                else
                {
                    THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh++;
                }

                if (rtb_DataTypeConversion2 > 2147483646)
                {
                    i = MAX_int32_T;
                }
                else
                {
                    i = rtb_DataTypeConversion2 + 1;
                }

                if (THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh >= i)
                {
                    THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = i;
                }
            }
            break;

          case THMR_ac_IN_STATE3_PWR_LIM_DEC:
            /* During 'STATE3_PWR_LIM_DEC': '<S1040>:30' */
            if (VeTHMR_k_ElVlv3WayFuCellPID >=
                    KeTHMR_k_ElVlv3WayFuCellPwrLimThHld_C)
            {
                /* Transition: '<S1040>:40' */
                THMR_ac_DW.is_c8_THMR_ac = THMR_ac_IN_STATE5_PWR_LIM_HOLD;

                /* Entry 'STATE5_PWR_LIM_HOLD': '<S1040>:32' */
                VeTHMR_y_PwrFuCellMaxLimTh = 5;
                THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = 0;
            }
            else
            {
                /* Transition: '<S1040>:42' */
                THMR_ac_DW.is_c8_THMR_ac = THMR__IN_STATE2_PWR_LIM_MONITOR;

                /* Entry 'STATE2_PWR_LIM_MONITOR': '<S1040>:27' */
                VeTHMR_y_PwrFuCellMaxLimTh = 2;
                THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = 0;
                THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch =
                    VeTHMR_P_FuCellMaxLimThStMch /
                    THMR_ac_DW.VeTHMR_P_FuCellMaxLimThStMchRef;
                THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch--;
                THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch = fminf
                    (THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch, (float32)0.0);
                THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch = fmaxf
                    (THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch,
                     THMR_ac_ConSngNegVal);
            }
            break;

          case THMR_ac_IN_STATE4_PWR_LIM_INC:
            /* During 'STATE4_PWR_LIM_INC': '<S1040>:31' */
            if ((VeTHMR_k_ElVlv3WayFuCellPID >=
                    KeTHMR_k_ElVlv3WayFuCellPwrLimThHld_C) &&
                    (VeTHMR_k_ElVlv3WayFuCellPID <
                     rtb_TmpSignalConversionAtVeTA_n))
            {
                /* Transition: '<S1040>:39' */
                THMR_ac_DW.is_c8_THMR_ac = THMR_ac_IN_STATE5_PWR_LIM_HOLD;

                /* Entry 'STATE5_PWR_LIM_HOLD': '<S1040>:32' */
                VeTHMR_y_PwrFuCellMaxLimTh = 5;
                THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = 0;
            }
            else
            {
                /* Transition: '<S1040>:43' */
                THMR_ac_DW.is_c8_THMR_ac = THMR__IN_STATE2_PWR_LIM_MONITOR;

                /* Entry 'STATE2_PWR_LIM_MONITOR': '<S1040>:27' */
                VeTHMR_y_PwrFuCellMaxLimTh = 2;
                THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = 0;
                THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch =
                    VeTHMR_P_FuCellMaxLimThStMch /
                    THMR_ac_DW.VeTHMR_P_FuCellMaxLimThStMchRef;
                THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch--;
                THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch = fminf
                    (THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch, (float32)0.0);
                THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch = fmaxf
                    (THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch,
                     THMR_ac_ConSngNegVal);
            }
            break;

          case THMR_ac_IN_STATE5_PWR_LIM_HOLD:
            VeTHMR_y_PwrFuCellMaxLimTh = 5;

            /* During 'STATE5_PWR_LIM_HOLD': '<S1040>:32' */
            if (((VeTHMR_k_ElVlv3WayFuCellPID <= rtb_Product1_nd) ||
                    (VeTHMR_k_ElVlv3WayFuCellPID >=
                     rtb_TmpSignalConversionAtVeTA_n)) &&
                    (!rtb_TmpSignalConversionAtVeP_el))
            {
                /* Transition: '<S1040>:45' */
                THMR_ac_DW.is_c8_THMR_ac = THMR__IN_STATE2_PWR_LIM_MONITOR;

                /* Entry 'STATE2_PWR_LIM_MONITOR': '<S1040>:27' */
                VeTHMR_y_PwrFuCellMaxLimTh = 2;
                THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = 0;
                THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch =
                    VeTHMR_P_FuCellMaxLimThStMch /
                    THMR_ac_DW.VeTHMR_P_FuCellMaxLimThStMchRef;
                THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch--;
                THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch = fminf
                    (THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch, (float32)0.0);
                THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch = fmaxf
                    (THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch,
                     THMR_ac_ConSngNegVal);
            }
            break;

          default:
            VeTHMR_y_PwrFuCellMaxLimTh = 6;

            /* DataTypeConversion: '<S950>/Data Type Conversion3' incorporates:
             *  Constant: '<S1051>/Calib'
             *  Gain: '<S950>/Gain1'
             */
            /* During 'STATE6_PWR_LIM_HOLD_DEC': '<S1040>:33' */
            rtb_Switch10 = fmodf(floorf(10.0F * KeTHMR_t_LimFuCellPwrLimThDec_C),
                                 4.2949673E+9F);
            if ((!rtb_TmpSignalConversionAtVeP_el) &&
                    (THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh >= ((rtb_Switch10 <
                    0.0F) ? (-((sint32)((uint32)((float32)(-rtb_Switch10))))) :
                    ((sint32)((uint32)rtb_Switch10)))))
            {
                /* Transition: '<S1040>:44' */
                THMR_ac_DW.is_c8_THMR_ac = THMR_ac_IN_STATE5_PWR_LIM_HOLD;

                /* Entry 'STATE5_PWR_LIM_HOLD': '<S1040>:32' */
                VeTHMR_y_PwrFuCellMaxLimTh = 5;
                THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = 0;
            }
            else if (THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh > 2147483646)
            {
                THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh = MAX_int32_T;
            }
            else
            {
                THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh++;
            }
            break;
        }
    }

    /* End of Chart: '<S950>/ElVlv_3_Way_FuCell_PwrMaxLimTh' */

    /* Switch: '<S1055>/Switch1' incorporates:
     *  Constant: '<S950>/Constant2'
     *  Logic: '<S950>/Logical Operator4'
     *  RelationalOperator: '<S950>/Relational Operator2'
     */
    if (VeTHMR_y_PwrFuCellMaxLimTh >= 2)
    {
        /* Switch: '<S1057>/Init' incorporates:
         *  UnitDelay: '<S1057>/FixPt Unit Delay2'
         */
        if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_p) != 0)
        {
            /* Switch: '<S1057>/Init' */
            rtb_Product1_nd = VeTHMR_P_FuCellMaxLimThStMch;
        }
        else
        {
            /* Switch: '<S1057>/Init' incorporates:
             *  UnitDelay: '<S1057>/FixPt Unit Delay1'
             */
            rtb_Product1_nd = THMR_ac_DW.FixPtUnitDelay1_DSTATE_g;
        }

        /* End of Switch: '<S1057>/Init' */

        /* Switch: '<S1055>/Switch1' incorporates:
         *  Constant: '<S1045>/Calib'
         *  Constant: '<S1046>/Calib'
         *  Constant: '<S950>/Constant1'
         *  MinMax: '<S1056>/MinMax'
         *  MinMax: '<S1056>/MinMax1'
         *  Product: '<S1055>/Product1'
         *  Product: '<S1055>/Product2'
         *  Sum: '<S1055>/Subtraction1'
         *  Sum: '<S1055>/Subtraction10'
         */
        rtb_Product1_nd += fminf(KeTHMR_dP_FuCellMaxLimThInc_C * 0.1F, fmaxf
            (VeTHMR_P_FuCellMaxLimThStMch - rtb_Product1_nd,
             KeTHMR_dP_FuCellMaxLimThDec_C * 0.1F));
    }
    else
    {
        /* Switch: '<S1055>/Switch1' */
        rtb_Product1_nd = VeTHMR_P_FuCellMaxLimThStMch;
    }

    /* End of Switch: '<S1055>/Switch1' */

    /* Switch: '<S55>/Switch11' incorporates:
     *  Constant: '<S740>/Calib'
     *  Switch: '<S791>/Switch3'
     */
    if (KeTHMR_b_UseNucleusFCCntrls)
    {
        /* Switch: '<S904>/Switch2' incorporates:
         *  Constant: '<S950>/Constant3'
         *  Constant: '<S950>/Constant4'
         *  Constant: '<S950>/Constant5'
         *  MinMax: '<S1039>/MinMax'
         *  MinMax: '<S1039>/MinMax1'
         *  Product: '<S950>/Divide'
         */
        rtb_TmpSignalConversionAtVeTA_n = fminf(50.0F, fmaxf(rtb_Product1_nd /
            1000.0F, 0.0F));
    }
    else if (rtb_TmpSignalConversionAtVePMTR)
    {
        /* Outputs for Atomic SubSystem: '<S791>/Limiter1' */
        /* Switch: '<S824>/Switch1' incorporates:
         *  RelationalOperator: '<S824>/RelationalOperator'
         *  Switch: '<S791>/Switch3'
         */
        if (rtb_TmpSignalConversionAtVePM_n < rtb_TmpSignalConversionAtVeF_l2)
        {
            /* Switch: '<S824>/Switch1' */
            rtb_TmpSignalConversionAtVeTA_n = rtb_TmpSignalConversionAtVePM_n;
        }
        else
        {
            /* Switch: '<S824>/Switch1' */
            rtb_TmpSignalConversionAtVeTA_n = rtb_TmpSignalConversionAtVeF_l2;
        }

        /* End of Switch: '<S824>/Switch1' */

        /* Switch: '<S824>/Switch' incorporates:
         *  RelationalOperator: '<S824>/RelationalOperator1'
         *  Switch: '<S791>/Switch3'
         */
        if (rtb_TmpSignalConversionAtVeTA_n <= rtb_Switch_eu)
        {
            /* Switch: '<S904>/Switch2' incorporates:
             *  Switch: '<S791>/Switch3'
             */
            rtb_TmpSignalConversionAtVeTA_n = rtb_Switch_eu;
        }

        /* End of Switch: '<S824>/Switch' */
        /* End of Outputs for SubSystem: '<S791>/Limiter1' */
    }
    else
    {
        /* Switch: '<S904>/Switch2' incorporates:
         *  Constant: '<S818>/Calib'
         *  Switch: '<S791>/Switch3'
         */
        rtb_TmpSignalConversionAtVeTA_n = KeTHMR_P_NoFCSDerate_Pwr;
    }

    /* End of Switch: '<S55>/Switch11' */
    /* End of Outputs for SubSystem: '<S2>/FC_Loop' */

    /* Inport: '<Root>/VeESMR_P_FC_Max_Pwr_OV' */
    (void)Rte_Read_VeESMR_P_FC_Max_Pwr_OV_Value(&rtb_Switch3_l0);

    /* Outputs for Function Call SubSystem: '<S2>/FC_Loop' */
    /* MinMax: '<S55>/MinMax' */
    THMR_ac_B.MinMax = fminf(rtb_TmpSignalConversionAtVeTA_n, rtb_Switch3_l0);

    /* Outputs for Atomic SubSystem: '<S55>/Protected Division' */
    /* Switch: '<S744>/Switch1' incorporates:
     *  Constant: '<S741>/Calib'
     *  Constant: '<S744>/Constant Value'
     *  Constant: '<S744>/Constant Value1'
     *  Constant: '<S744>/Constant Value2'
     *  Constant: '<S744>/Constant Value3'
     *  Logic: '<S744>/AND'
     *  RelationalOperator: '<S744>/Greater Than or Equal '
     *  RelationalOperator: '<S744>/Greater Than or Equal 1'
     *  RelationalOperator: '<S744>/Not Equal'
     *  RelationalOperator: '<S744>/Not Equal1'
     *  Switch: '<S744>/Switch2'
     *  Switch: '<S744>/Switch3'
     */
    if ((Switch1_e != 0.0F) && (KeTHMR_k_EstHTRGrillArea != 0.0F))
    {
        /* Update for UnitDelay: '<S949>/Unit Delay2' incorporates:
         *  Product: '<S744>/Division'
         *  Switch: '<S744>/Switch1'
         */
        THMR_ac_DW.UnitDelay2_DSTATE_n = Switch1_e / KeTHMR_k_EstHTRGrillArea;
    }
    else if (Switch1_e > 0.0F)
    {
        /* Switch: '<S744>/Switch2' incorporates:
         *  Constant: '<S744>/MAXFLOAT'
         *  Switch: '<S744>/Switch1'
         *  UnitDelay: '<S949>/Unit Delay2'
         */
        THMR_ac_DW.UnitDelay2_DSTATE_n = 3.402823466E+38F;
    }
    else if (Switch1_e < 0.0F)
    {
        /* Switch: '<S744>/Switch3' incorporates:
         *  Constant: '<S744>/MINFLOAT'
         *  Switch: '<S744>/Switch1'
         *  Switch: '<S744>/Switch2'
         *  UnitDelay: '<S949>/Unit Delay2'
         */
        THMR_ac_DW.UnitDelay2_DSTATE_n = -3.402823466E+38F;
    }
    else
    {
        /* Update for UnitDelay: '<S949>/Unit Delay2' incorporates:
         *  Constant: '<S744>/Constant Value4'
         *  Switch: '<S744>/Switch1'
         *  Switch: '<S744>/Switch2'
         *  Switch: '<S744>/Switch3'
         */
        THMR_ac_DW.UnitDelay2_DSTATE_n = 0.0F;
    }

    /* End of Switch: '<S744>/Switch1' */
    /* End of Outputs for SubSystem: '<S55>/Protected Division' */

    /* Sum: '<S902>/Subtraction1' */
    VeTHMR_T_WaFuCellDeltaT = rtb_Sum_e;

    /* Switch: '<S902>/Switch1' incorporates:
     *  Constant: '<S910>/Calib'
     */
    if (KeTHMR_b_SelWaPmpFuCellCtlOfs_C)
    {
        rtb_Switch10 = rtb_TmpSignalConversionAtVeF_ob;
    }
    else
    {
        rtb_Switch10 = VeTHMR_T_WaFuCellDeltaT;
    }

    /* End of Switch: '<S902>/Switch1' */

    /* Sum: '<S902>/Subtraction4' incorporates:
     *  Lookup_n-D: '<S917>/Vector'
     *  Product: '<S55>/Product1'
     */
    VeTHMR_T_WaFuCellDeltaDifSp = rtb_Switch10 - look1_iflf_binlcapw
        (rtb_TmpSignalConversionAtVeFCPR, ((const float32 *)
          &(KxTHMR_T_WaPmpFuCellOfs_T[0])), ((const float32 *)
          &(KtTHMR_T_WaPmpFuCellOfs_T[0])), 7U);

    /* Sum: '<S902>/Subtraction2' */
    VeTHMR_T_WaFuCellPIDWaPmpRegRaw = rtb_TmpSignalConversionAtVeF_ob -
        VeTHMR_T_WaFuCellDeltaT;

    /* Outputs for Enabled SubSystem: '<S927>/Enabled Subsystem' incorporates:
     *  EnablePort: '<S932>/Enable'
     */
    /* Product: '<S932>/Product1' incorporates:
     *  Lookup_n-D: '<S920>/Vector'
     *  Sum: '<S902>/Subtraction1'
     */
    THMR_ac_B.Product1 = VeTHMR_T_WaFuCellPIDWaPmpRegRaw * look1_iflf_binlcapw
        (VeTHMR_T_WaFuCellDeltaT, ((const float32 *)
          &(KxTHMR_k_PFuCellWaPmpDelta_T[0])), ((const float32 *)
          &(KtTHMR_k_PFuCellWaPmpDelta_T[0])), 7U);

    /* End of Outputs for SubSystem: '<S927>/Enabled Subsystem' */

    /* Lookup_n-D: '<S919>/Vector' incorporates:
     *  Sum: '<S902>/Subtraction1'
     */
    rtb_TmpSignalConversionAtVeF_ob = look1_iflf_binlcapw
        (VeTHMR_T_WaFuCellDeltaT, ((const float32 *)
          &(KxTHMR_k_IFuCellWaPmpDelta_T[0])), ((const float32 *)
          &(KtTHMR_k_IFuCellWaPmpDelta_T[0])), 8U);

    /* Outputs for Atomic SubSystem: '<S928>/Hysteresis' */
    /* Switch: '<S939>/Switch1' incorporates:
     *  Constant: '<S941>/Calib'
     *  RelationalOperator: '<S939>/Greater  Than'
     */
    if (VeTHMR_T_CoFuCellHiTOutDelta > KeTHMR_T_WaPmpFuCellHiTOutDeltaMin_C)
    {
        /* Switch: '<S939>/Switch1' incorporates:
         *  Constant: '<S939>/Constant Value'
         */
        rtb_TmpSignalConversionAtVePMTR = true;
    }
    else
    {
        /* Switch: '<S939>/Switch1' incorporates:
         *  Constant: '<S940>/Calib'
         *  RelationalOperator: '<S939>/Greater  Than1'
         *  Sum: '<S928>/Subtraction2'
         *  UnitDelay: '<S939>/Unit Delay'
         */
        rtb_TmpSignalConversionAtVePMTR = ((VeTHMR_T_CoFuCellHiTOutDelta >=
            (KeTHMR_T_WaPmpFuCellHiTOutDeltaMin_C -
             KeTHMR_T_WaPmpFuCellHiTOutDeltaMinHys_C)) &&
            (THMR_ac_DW.UnitDelay_DSTATE_kp));
    }

    /* End of Switch: '<S939>/Switch1' */

    /* Update for UnitDelay: '<S939>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_kp = rtb_TmpSignalConversionAtVePMTR;

    /* End of Outputs for SubSystem: '<S928>/Hysteresis' */

    /* Logic: '<S928>/LogicalOperator8' incorporates:
     *  Constant: '<S928>/Constant'
     *  DataTypeConversion: '<S55>/Data Type Conversion'
     *  Logic: '<S928>/LogicalOperator6'
     *  RelationalOperator: '<S928>/RelationalOperator1'
     *  SignalConversion generated from: '<S2>/VeFCPR_e_FCPS_HTCoolReq'
     */
    rtb_TmpSignalConversionAtVePMTR = (((!rtb_TmpSignalConversionAtVePMTR) ||
        (((float32)rtb_TmpSignalConversionAtVeFC_o) == 0.0F)) ||
        rtb_RelationalOperator5_o);

    /* RelationalOperator: '<S944>/RelationalOperator6' incorporates:
     *  UnitDelay: '<S944>/Unit Delay6'
     */
    rtb_TmpSignalConversionAtVeP_el = (rtb_TmpSignalConversionAtVePMTR !=
        THMR_ac_DW.UnitDelay6_DSTATE_k);

    /* RelationalOperator: '<S928>/RelationalOperator2' incorporates:
     *  Constant: '<S942>/Calib'
     *  Sum: '<S928>/Subtraction1'
     *  UnitDelay: '<S928>/Unit Delay1'
     */
    rtb_Gain_pg = ((rtb_TmpSignalConversionAtVeTM_p -
                    THMR_ac_DW.UnitDelay1_DSTATE_hn) >
                   KeTHMR_k_WaPmpFuCellReqDif_C);

    /* Switch: '<S902>/Switch4' incorporates:
     *  Abs: '<S928>/Abs'
     *  Sum: '<S928>/Subtraction3'
     *  UnitDelay: '<S928>/Unit Delay2'
     */
    rtb_TmpSignalConversionAtVeTM_p -= THMR_ac_DW.UnitDelay2_DSTATE_a;
    rtb_TmpSignalConversionAtVeTM_p = fabsf(rtb_TmpSignalConversionAtVeTM_p);

    /* Outputs for Enabled SubSystem: '<S927>/Enabled Subsystem1' incorporates:
     *  EnablePort: '<S933>/Enable'
     */
    /* Outputs for Atomic SubSystem: '<S933>/EdgeRising' */
    /* Logic: '<S935>/OR1' incorporates:
     *  UnitDelay: '<S935>/Unit Delay'
     */
    rtb_Gain_c = !THMR_ac_DW.UnitDelay_DSTATE_pqv;

    /* Update for UnitDelay: '<S935>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_pqv = rtb_TmpSignalConversionAtVeP_el;

    /* Switch: '<S933>/Switch1' incorporates:
     *  Constant: '<S943>/Calib'
     *  Logic: '<S928>/LogicalOperator'
     *  Logic: '<S928>/LogicalOperator1'
     *  Logic: '<S928>/LogicalOperator2'
     *  Logic: '<S928>/LogicalOperator3'
     *  Logic: '<S928>/LogicalOperator4'
     *  Logic: '<S928>/LogicalOperator5'
     *  Logic: '<S928>/LogicalOperator7'
     *  Logic: '<S935>/AND'
     *  RelationalOperator: '<S928>/RelationalOperator3'
     *  Switch: '<S933>/Switch3'
     *  UnitDelay: '<S928>/Unit Delay'
     *  UnitDelay: '<S928>/Unit Delay3'
     *  UnitDelay: '<S928>/Unit Delay4'
     *  UnitDelay: '<S928>/Unit Delay5'
     */
    if (rtb_TmpSignalConversionAtVeP_el && rtb_Gain_c)
    {
        /* Switch: '<S933>/Switch1' incorporates:
         *  Constant: '<S902>/Constant1'
         */
        rtb_Switch3_l0 = 0.0F;
    }
    else
    {
        if ((((((THMR_ac_DW.UnitDelay_DSTATE_cs) || rtb_Gain_pg) ||
                ((rtb_TmpSignalConversionAtVeTM_p >
                  KeTHMR_k_WaPmpFuCellReqOvrd_C) &&
                 ((!THMR_ac_DW.UnitDelay4_DSTATE_d) &&
                  (!THMR_ac_DW.UnitDelay5_DSTATE_c)))) ||
                ((THMR_ac_DW.UnitDelay3_DSTATE_l2) &&
                 (THMR_ac_DW.UnitDelay4_DSTATE_d))) ||
                ((!THMR_ac_DW.UnitDelay3_DSTATE_l2) &&
                 (THMR_ac_DW.UnitDelay5_DSTATE_c))) ||
                rtb_TmpSignalConversionAtVePMTR)
        {
            /* Switch: '<S933>/Switch3' incorporates:
             *  Constant: '<S933>/Constant'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S933>/Switch3' incorporates:
             *  Constant: '<S902>/Constant2'
             *  Product: '<S933>/Product1'
             */
            rtb_Switch10 = (VeTHMR_T_WaFuCellPIDWaPmpRegRaw *
                            rtb_TmpSignalConversionAtVeF_ob) * 0.1F;
        }

        /* Switch: '<S937>/Switch' incorporates:
         *  Constant: '<S902>/Constant1'
         *  UnitDelay: '<S937>/Unit Delay'
         *  UnitDelay: '<S937>/Unit Delay1'
         */
        if (THMR_ac_DW.UnitDelay_DSTATE_g2 != 0.0F)
        {
            rtb_Switch15 = THMR_ac_DW.UnitDelay1_DSTATE_eb;
        }
        else
        {
            rtb_Switch15 = 0.0F;
        }

        /* End of Switch: '<S937>/Switch' */

        /* Switch: '<S933>/Switch1' incorporates:
         *  Sum: '<S933>/Subtraction10'
         */
        rtb_Switch3_l0 = rtb_Switch10 + rtb_Switch15;
    }

    /* End of Switch: '<S933>/Switch1' */
    /* End of Outputs for SubSystem: '<S933>/EdgeRising' */

    /* Switch: '<S936>/Switch2' incorporates:
     *  UnitDelay: '<S936>/Unit Delay'
     */
    if (THMR_ac_DW.UnitDelay_DSTATE_e5 >= 1.0F)
    {
        /* Switch: '<S936>/Switch2' */
        THMR_ac_B.Switch2_m = rtb_Switch3_l0;
    }
    else
    {
        /* Switch: '<S936>/Switch2' incorporates:
         *  Constant: '<S902>/Constant1'
         */
        THMR_ac_B.Switch2_m = 0.0F;
    }

    /* End of Switch: '<S936>/Switch2' */

    /* Update for UnitDelay: '<S937>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_eb = rtb_Switch3_l0;

    /* Update for UnitDelay: '<S937>/Unit Delay' incorporates:
     *  Constant: '<S937>/Constant1'
     */
    THMR_ac_DW.UnitDelay_DSTATE_g2 = 1.0F;

    /* Update for UnitDelay: '<S936>/Unit Delay' incorporates:
     *  Constant: '<S936>/Constant1'
     */
    THMR_ac_DW.UnitDelay_DSTATE_e5 = 1.0F;

    /* End of Outputs for SubSystem: '<S927>/Enabled Subsystem1' */

    /* Outputs for Enabled SubSystem: '<S927>/Enabled Subsystem2' incorporates:
     *  EnablePort: '<S934>/Enable'
     */
    /* Switch: '<S934>/Switch1' incorporates:
     *  Switch: '<S938>/Switch'
     *  UnitDelay: '<S938>/Unit Delay'
     */
    if (rtb_TmpSignalConversionAtVeP_el)
    {
        /* Switch: '<S934>/Switch1' incorporates:
         *  Constant: '<S934>/Constant1'
         */
        THMR_ac_B.Switch1_b = 0.0F;
    }
    else
    {
        if (THMR_ac_DW.UnitDelay_DSTATE_pa != 0.0F)
        {
            /* Switch: '<S938>/Switch' incorporates:
             *  UnitDelay: '<S938>/Unit Delay1'
             */
            rtb_Switch10 = THMR_ac_DW.UnitDelay1_DSTATE_d2;
        }
        else
        {
            /* Switch: '<S938>/Switch' */
            rtb_Switch10 = VeTHMR_T_WaFuCellPIDWaPmpRegRaw;
        }

        /* Switch: '<S934>/Switch1' incorporates:
         *  Constant: '<S902>/Constant2'
         *  Lookup_n-D: '<S918>/Vector'
         *  Product: '<S934>/Divide'
         *  Product: '<S934>/Product'
         *  Sum: '<S902>/Subtraction1'
         *  Sum: '<S934>/Subtraction1'
         */
        THMR_ac_B.Switch1_b = ((VeTHMR_T_WaFuCellPIDWaPmpRegRaw - rtb_Switch10) *
                               look1_iflf_binlcapw(VeTHMR_T_WaFuCellDeltaT, ((
            const float32 *)&(KxTHMR_k_DFuCellWaPmpDelta_T[0])), ((const float32
            *)&(KtTHMR_k_DFuCellWaPmpDelta_T[0])), 8U)) / 0.1F;
    }

    /* End of Switch: '<S934>/Switch1' */

    /* Update for UnitDelay: '<S938>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_d2 = VeTHMR_T_WaFuCellPIDWaPmpRegRaw;

    /* Update for UnitDelay: '<S938>/Unit Delay' incorporates:
     *  Constant: '<S938>/Constant1'
     */
    THMR_ac_DW.UnitDelay_DSTATE_pa = 1.0F;

    /* End of Outputs for SubSystem: '<S927>/Enabled Subsystem2' */

    /* Switch: '<S904>/Switch2' incorporates:
     *  Sum: '<S927>/Subtraction2'
     */
    rtb_TmpSignalConversionAtVeTA_n = (THMR_ac_B.Product1 + THMR_ac_B.Switch2_m)
        + THMR_ac_B.Switch1_b;

    /* MinMax: '<S931>/MinMax' incorporates:
     *  Constant: '<S908>/Calib'
     *  Constant: '<S909>/Calib'
     *  MinMax: '<S931>/MinMax1'
     */
    VeTHMR_T_WaFuCellPIDWaPmpReg = fminf(KeTHMR_T_WaPmpFuCellPIDMax_C, fmaxf
        (rtb_TmpSignalConversionAtVeTA_n, KeTHMR_T_WaPmpFuCellPIDMin_C));

    /* Sum: '<S902>/Subtraction3' */
    VeTHMR_T_WaFuCellPIDReg = VeTHMR_T_WaFuCellDeltaDifSp +
        VeTHMR_T_WaFuCellPIDWaPmpReg;

    /* Lookup_n-D: '<S923>/Vector' incorporates:
     *  Product: '<S55>/Product1'
     *  Sum: '<S902>/Subtraction3'
     */
    VeTHMR_k_WaPmpFuCellReg = look2_iflf_binlcapw
        (rtb_TmpSignalConversionAtVeFCPR, VeTHMR_T_WaFuCellPIDReg, ((const
           float32 *)&(KxTHMR_k_WaPmpFuCellReg_M[0])), ((const float32 *)
          &(KyTHMR_k_WaPmpFuCellReg_M[0])), ((const float32 *)
          &(KtTHMR_k_WaPmpFuCellReg_M[0])), THMR_ac_ConstP.pooled43, 8U);

    /* Lookup_n-D: '<S921>/Vector' incorporates:
     *  SignalConversion generated from: '<S2>/VeFCPR_T_FCPS_HTCoolOutTemp'
     */
    VeTHMR_k_WaPmpFuCellMin = look1_iflf_binlcapw
        (rtb_TmpSignalConversionAtVeF_n4, ((const float32 *)
          &(KxTHMR_k_WaPmpFuCellMin_T[0])), ((const float32 *)
          &(KtTHMR_k_WaPmpFuCellMin_T[0])), 4U);

    /* Lookup_n-D: '<S924>/Vector' incorporates:
     *  MinMax: '<S902>/MinMax'
     *  MinMax: '<S945>/MinMax'
     */
    VeTHMR_k_WaPmpFuCellReq = look2_iflf_binlcapw(fmaxf(VeTHMR_k_WaPmpFuCellMin,
        VeTHMR_k_WaPmpFuCellReg), VeTHMR_k_ElVlv3WayFuCellPID, ((const float32 *)
        &(KxTHMR_k_WaPmpFuCellReq_M[0])), ((const float32 *)
        &(KyTHMR_k_WaPmpFuCellReq_M[0])), ((const float32 *)
        &(KtTHMR_k_WaPmpFuCellReq_M[0])), THMR_ac_ConstP.pooled43, 8U);

    /* Lookup_n-D: '<S925>/Vector' incorporates:
     *  Lookup_n-D: '<S924>/Vector'
     *  MinMax: '<S994>/MinMax'
     */
    VeTHMR_k_WaPmpFuCellDeltaReq = look2_iflf_binlcapw(VeTHMR_k_WaPmpFuCellReq,
        VeTHMR_T_CoFuCellHiTOutDelta, ((const float32 *)
        &(KxTHMR_k_WaPmpFuCellTDeltaReq_M[0])), ((const float32 *)
        &(KyTHMR_k_WaPmpFuCellTDeltaReq_M[0])), ((const float32 *)
        &(KtTHMR_k_WaPmpFuCellTDeltaReq_M[0])), THMR_ac_ConstP.pooled45, 6U);

    /* Lookup_n-D: '<S922>/Vector' incorporates:
     *  Lookup_n-D: '<S924>/Vector'
     *  UnitDelay: '<S950>/Unit Delay2'
     */
    VeTHMR_k_WaPmpFuCellPwrMaxLimThDeltaReq = look2_iflf_binlcapw
        (VeTHMR_k_WaPmpFuCellReq, VeTHMR_k_PwrFuCellMaxLimThStMchDelta, ((const
           float32 *)&(KxTHMR_k_WaPmpFuCellPwrMaxLimThReq_M[0])), ((const
           float32 *)&(KyTHMR_k_WaPmpFuCellPwrMaxLimThReq_M[0])), ((const
           float32 *)&(KtTHMR_k_WaPmpFuCellPwrMaxLimThReq_M[0])),
         THMR_ac_ConstP.pooled45, 6U);

    /* MinMax: '<S902>/MinMax1' */
    rtb_Switch3_l0 = fmaxf(VeTHMR_k_WaPmpFuCellDeltaReq,
                           VeTHMR_k_WaPmpFuCellPwrMaxLimThDeltaReq);

    /* Outputs for Enabled SubSystem: '<S748>/F02_07_FuCellHiTHEX_TInTarRegCtl' incorporates:
     *  EnablePort: '<S905>/Enable'
     */
    /* Constant: '<S906>/Calib' */
    if (KeTHMR_b_FCAirdT4Airflw)
    {
        /* MinMax: '<S1100>/MinMax' incorporates:
         *  Constant: '<S1100>/Constant1'
         *  Constant: '<S1128>/Calib'
         *  Sum: '<S1100>/Sum'
         */
        rtb_TmpSignalConversionAtVeTM_p = fmaxf(VeTHMR_k_ElVlv3WayFuCellPID -
            KeTHMR_k_ElVlv3WayFuCellPIDByp_C, 0.0F);

        /* Outputs for Atomic SubSystem: '<S1100>/Protected Division' */
        /* Switch: '<S1130>/Switch1' incorporates:
         *  Constant: '<S1100>/Constant'
         *  Constant: '<S1128>/Calib'
         *  Constant: '<S1130>/Constant Value'
         *  Constant: '<S1130>/Constant Value1'
         *  Constant: '<S1130>/Constant Value2'
         *  Logic: '<S1130>/AND'
         *  RelationalOperator: '<S1130>/Greater Than or Equal '
         *  RelationalOperator: '<S1130>/Not Equal'
         *  RelationalOperator: '<S1130>/Not Equal1'
         *  Sum: '<S1100>/Sum1'
         *  Switch: '<S1130>/Switch2'
         */
        if ((rtb_TmpSignalConversionAtVeTM_p != 0.0F) && ((100.0F -
                KeTHMR_k_ElVlv3WayFuCellPIDByp_C) != 0.0F))
        {
            /* Switch: '<S1130>/Switch1' incorporates:
             *  Product: '<S1130>/Division'
             */
            VeTHMR_k_RadBypFuCellHiTHEX = rtb_TmpSignalConversionAtVeTM_p /
                (100.0F - KeTHMR_k_ElVlv3WayFuCellPIDByp_C);
        }
        else if (rtb_TmpSignalConversionAtVeTM_p > 0.0F)
        {
            /* Switch: '<S1130>/Switch2' incorporates:
             *  Constant: '<S1130>/MAXFLOAT'
             *  Switch: '<S1130>/Switch1'
             */
            VeTHMR_k_RadBypFuCellHiTHEX = 3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1130>/Switch1' incorporates:
             *  Constant: '<S1130>/Constant Value4'
             *  Switch: '<S1130>/Switch2'
             *  Switch: '<S1130>/Switch3'
             */
            VeTHMR_k_RadBypFuCellHiTHEX = 0.0F;
        }

        /* End of Switch: '<S1130>/Switch1' */
        /* End of Outputs for SubSystem: '<S1100>/Protected Division' */

        /* Gain: '<S1100>/Gain' incorporates:
         *  Constant: '<S1129>/Calib'
         *  Product: '<S1100>/Divide'
         *  Product: '<S1100>/Product'
         */
        VeTHMR_T_CoOutDeltaFuCellHiTHEX = -((VeTHMR_T_CoFuCellHiTOutDelta /
            KeTHMR_k_FuCellHiTHEXElVlv3WayByp_C) * VeTHMR_k_RadBypFuCellHiTHEX);

        /* RelationalOperator: '<S1098>/Relational Operator2' incorporates:
         *  Constant: '<S1109>/Calib'
         */
        rtb_TmpSignalConversionAtVeP_el = (VeTHMR_T_CoFuCellHiTOutDelta <
            KeTHMR_T_CoOutDeltaFuCellHiTHEXRstLo_C);

        /* Outputs for Atomic SubSystem: '<S1098>/Turn On Delay Time' */
        /* Outputs for Atomic SubSystem: '<S1119>/EdgeRising' */
        /* Logic: '<S1125>/AND' incorporates:
         *  Logic: '<S1125>/OR1'
         *  UnitDelay: '<S1125>/Unit Delay'
         */
        rtb_Gain_pg = (rtb_TmpSignalConversionAtVeP_el &&
                       (!THMR_ac_DW.UnitDelay_DSTATE_f0));

        /* Update for UnitDelay: '<S1125>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_f0 = rtb_TmpSignalConversionAtVeP_el;

        /* End of Outputs for SubSystem: '<S1119>/EdgeRising' */

        /* Switch: '<S1119>/Switch1' incorporates:
         *  Logic: '<S1119>/OR'
         *  Logic: '<S1119>/OR1'
         */
        if ((!rtb_TmpSignalConversionAtVeP_el) || rtb_Gain_pg)
        {
            /* Switch: '<S1119>/Switch1' incorporates:
             *  Constant: '<S1119>/Constant Value1'
             */
            rtb_TmpSignalConversionAtVeTM_p = 0.0F;
        }
        else
        {
            /* Switch: '<S1119>/Switch1' incorporates:
             *  Constant: '<S1098>/Constant1'
             *  Constant: '<S1116>/Calib'
             *  MinMax: '<S1119>/Minimum'
             *  Sum: '<S1119>/Summation'
             *  UnitDelay: '<S1119>/Unit Delay'
             */
            rtb_TmpSignalConversionAtVeTM_p = fminf
                (KeTHMR_t_TCoOutDeltaFuCellHiTHEXRstDly_C,
                 THMR_ac_DW.UnitDelay_DSTATE_dy + 0.1F);
        }

        /* End of Switch: '<S1119>/Switch1' */

        /* Update for UnitDelay: '<S1119>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_dy = rtb_TmpSignalConversionAtVeTM_p;

        /* Switch: '<S1098>/Switch1' incorporates:
         *  Constant: '<S1098>/Constant2'
         *  Constant: '<S1112>/Calib'
         *  Constant: '<S1116>/Calib'
         *  Logic: '<S1119>/AND'
         *  RelationalOperator: '<S1119>/Greater  Than'
         */
        if (rtb_TmpSignalConversionAtVeP_el && (rtb_TmpSignalConversionAtVeTM_p >=
             KeTHMR_t_TCoOutDeltaFuCellHiTHEXRstDly_C))
        {
            rtb_VeTHMR_Pct_FCHTRRadFanCmd =
                KeTHMR_k_RadBypFuCellHiTHEXHysHiRst_C;
        }
        else
        {
            rtb_VeTHMR_Pct_FCHTRRadFanCmd = 2.0F;
        }

        /* End of Switch: '<S1098>/Switch1' */
        /* End of Outputs for SubSystem: '<S1098>/Turn On Delay Time' */

        /* Outputs for Atomic SubSystem: '<S1098>/Hysteresis' */
        /* Switch: '<S1108>/Switch1' incorporates:
         *  RelationalOperator: '<S1108>/Greater  Than'
         */
        if (VeTHMR_k_RadBypFuCellHiTHEX > rtb_VeTHMR_Pct_FCHTRRadFanCmd)
        {
            /* Switch: '<S1108>/Switch1' incorporates:
             *  Constant: '<S1108>/Constant Value'
             */
            rtb_TmpSignalConversionAtVeP_el = true;
        }
        else
        {
            /* Switch: '<S1108>/Switch1' incorporates:
             *  Constant: '<S1113>/Calib'
             *  RelationalOperator: '<S1108>/Greater  Than1'
             *  UnitDelay: '<S1108>/Unit Delay'
             */
            rtb_TmpSignalConversionAtVeP_el = ((VeTHMR_k_RadBypFuCellHiTHEX >=
                KeTHMR_k_RadBypFuCellHiTHEXHysLoRst_C) &&
                (THMR_ac_DW.UnitDelay_DSTATE_df));
        }

        /* End of Switch: '<S1108>/Switch1' */

        /* Update for UnitDelay: '<S1108>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_df = rtb_TmpSignalConversionAtVeP_el;

        /* End of Outputs for SubSystem: '<S1098>/Hysteresis' */

        /* Logic: '<S1098>/Logical Operator9' incorporates:
         *  Logic: '<S1098>/Logical Operator7'
         *  Logic: '<S1098>/Logical Operator8'
         *  Lookup_n-D: '<S1117>/Vector'
         *  RelationalOperator: '<S1098>/Relational Operator3'
         *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
         */
        rtb_TmpSignalConversionAtVeP_el = (rtb_TmpSignalConversionAtVeP_el ||
            (rtb_TmpSignalConversionAtVeFCPR <= look1_iflf_binlcapw
             (TmpSignalConversionAtOutAirTemp, ((const float32 *)
            &(KxTHMR_P_FuCellHiTHEXCtlReqRst_T[0])), ((const float32 *)
            &(KtTHMR_P_FuCellHiTHEXCtlReqRst_T[0])), 7U)));

        /* Outputs for Atomic SubSystem: '<S1118>/Turn On Delay Time' */
        /* Outputs for Atomic SubSystem: '<S1121>/EdgeRising' */
        /* Logic: '<S1123>/AND' incorporates:
         *  Logic: '<S1123>/OR1'
         *  UnitDelay: '<S1123>/Unit Delay'
         */
        rtb_Gain_pg = (rtb_TmpSignalConversionAtVeP_el &&
                       (!THMR_ac_DW.UnitDelay_DSTATE_pg));

        /* Update for UnitDelay: '<S1123>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_pg = rtb_TmpSignalConversionAtVeP_el;

        /* End of Outputs for SubSystem: '<S1121>/EdgeRising' */

        /* Logic: '<S1121>/OR1' incorporates:
         *  Logic: '<S1118>/Logical Operator9'
         */
        rtb_TmpSignalConversionAtVeBT_p = !rtb_TmpSignalConversionAtVeP_el;

        /* Switch: '<S1121>/Switch1' incorporates:
         *  Logic: '<S1121>/OR'
         *  Logic: '<S1121>/OR1'
         */
        if (rtb_TmpSignalConversionAtVeBT_p || rtb_Gain_pg)
        {
            /* Switch: '<S1121>/Switch1' incorporates:
             *  Constant: '<S1121>/Constant Value1'
             */
            rtb_TmpSignalConversionAtVeTM_p = 0.0F;
        }
        else
        {
            /* Switch: '<S1121>/Switch1' incorporates:
             *  Constant: '<S1098>/Constant3'
             *  Constant: '<S1114>/Calib'
             *  MinMax: '<S1121>/Minimum'
             *  Sum: '<S1121>/Summation'
             *  UnitDelay: '<S1121>/Unit Delay'
             */
            rtb_TmpSignalConversionAtVeTM_p = fminf
                (KeTHMR_t_RadBypFuCellHiTHEXHysNotRstDly_C,
                 THMR_ac_DW.UnitDelay_DSTATE_et + 0.1F);
        }

        /* End of Switch: '<S1121>/Switch1' */

        /* Update for UnitDelay: '<S1121>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_et = rtb_TmpSignalConversionAtVeTM_p;

        /* End of Outputs for SubSystem: '<S1118>/Turn On Delay Time' */

        /* Outputs for Atomic SubSystem: '<S1118>/Turn On Delay Time1' */
        /* Outputs for Atomic SubSystem: '<S1122>/EdgeRising' */
        /* Logic: '<S1124>/AND' incorporates:
         *  Logic: '<S1124>/OR1'
         *  UnitDelay: '<S1124>/Unit Delay'
         */
        rtb_Gain_c = (rtb_TmpSignalConversionAtVeBT_p &&
                      (!THMR_ac_DW.UnitDelay_DSTATE_oc));

        /* Update for UnitDelay: '<S1124>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_oc = rtb_TmpSignalConversionAtVeBT_p;

        /* End of Outputs for SubSystem: '<S1122>/EdgeRising' */

        /* Logic: '<S1122>/OR1' incorporates:
         *  Logic: '<S1122>/AND'
         */
        rtb_AND_fe = !rtb_TmpSignalConversionAtVeBT_p;

        /* Switch: '<S1122>/Switch1' incorporates:
         *  Logic: '<S1122>/OR'
         *  Logic: '<S1122>/OR1'
         */
        if (rtb_AND_fe || rtb_Gain_c)
        {
            /* Switch: '<S1122>/Switch1' incorporates:
             *  Constant: '<S1122>/Constant Value1'
             */
            Switch1_e = 0.0F;
        }
        else
        {
            /* Switch: '<S1122>/Switch1' incorporates:
             *  Constant: '<S1098>/Constant3'
             *  Constant: '<S1115>/Calib'
             *  MinMax: '<S1122>/Minimum'
             *  Sum: '<S1122>/Summation'
             *  UnitDelay: '<S1122>/Unit Delay'
             */
            Switch1_e = fminf(KeTHMR_t_RadBypFuCellHiTHEXHysRstDly_C,
                              THMR_ac_DW.UnitDelay_DSTATE_g1 + 0.1F);
        }

        /* End of Switch: '<S1122>/Switch1' */

        /* Update for UnitDelay: '<S1122>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_g1 = Switch1_e;

        /* Outputs for Atomic SubSystem: '<S1118>/Turn On Delay Time' */
        /* Logic: '<S1120>/Logical Operator2' incorporates:
         *  Constant: '<S1114>/Calib'
         *  Constant: '<S1115>/Calib'
         *  Logic: '<S1120>/Logical Operator1'
         *  Logic: '<S1120>/Logical Operator9'
         *  Logic: '<S1121>/AND'
         *  Logic: '<S1122>/AND'
         *  RelationalOperator: '<S1121>/Greater  Than'
         *  RelationalOperator: '<S1122>/Greater  Than'
         *  UnitDelay: '<S1120>/Unit Delay3'
         */
        rtb_TmpSignalConversionAtVeP_el = (((THMR_ac_DW.UnitDelay3_DSTATE_o) ||
            (rtb_TmpSignalConversionAtVeP_el && (rtb_TmpSignalConversionAtVeTM_p
            >= KeTHMR_t_RadBypFuCellHiTHEXHysNotRstDly_C))) && (rtb_AND_fe ||
            (Switch1_e < KeTHMR_t_RadBypFuCellHiTHEXHysRstDly_C)));

        /* End of Outputs for SubSystem: '<S1118>/Turn On Delay Time' */
        /* End of Outputs for SubSystem: '<S1118>/Turn On Delay Time1' */

        /* Logic: '<S1098>/Logical Operator11' incorporates:
         *  Constant: '<S1098>/Constant4'
         *  Constant: '<S1098>/Constant5'
         *  DataTypeConversion: '<S55>/Data Type Conversion'
         *  Logic: '<S1098>/Logical Operator10'
         *  RelationalOperator: '<S1098>/Relational Operator4'
         *  RelationalOperator: '<S1098>/Relational Operator5'
         *  SignalConversion generated from: '<S2>/VeFCPR_e_FCPS_HTCoolReq'
         */
        VeTHMR_b_HiTPreHeatFuCell = (((((float32)rtb_TmpSignalConversionAtVeFC_o)
            == 0.0F) || (((float32)rtb_TmpSignalConversionAtVeFC_o) == 3.0F)) ||
            (!rtb_TmpSignalConversionAtVeP_el));

        /* UnitDelay: '<S1098>/Unit Delay' */
        rtb_TmpSignalConversionAtVeTM_p = THMR_ac_DW.UnitDelay_DSTATE_cn;

        /* MinMax: '<S1097>/MinMax1' incorporates:
         *  UnitDelay: '<S1098>/Unit Delay1'
         */
        Switch1_e = THMR_ac_DW.UnitDelay1_DSTATE_dk;

        /* Switch: '<S1098>/Switch' incorporates:
         *  Constant: '<S1111>/Calib'
         */
        if (KeTHMR_b_AcvTWaVeryLoTFuCellHiTHEX_C)
        {
            rtb_Switch10 = rtb_TmpSignalConversionAtVeTR_h;
        }
        else
        {
            rtb_Switch10 = rtb_TmpSignalConversionAtVeTM_p;
        }

        /* End of Switch: '<S1098>/Switch' */

        /* Abs: '<S1098>/Abs' incorporates:
         *  Sum: '<S1098>/Sum'
         */
        rtb_Switch1_pn[1] = fabsf(rtb_TmpSignalConversionAtVeTM_p - Switch1_e);

        /* Product: '<S1099>/Product2' incorporates:
         *  Constant: '<S1099>/Constant1'
         *  Gain: '<S1100>/Gain'
         *  Lookup_n-D: '<S1127>/Vector'
         *  Product: '<S1099>/Product1'
         */
        rtb_TmpSignalConversionAtVeTM_p = (VeTHMR_T_CoOutDeltaFuCellHiTHEX *
            look1_iflf_binlcapw(VeTHMR_T_CoOutDeltaFuCellHiTHEX, ((const float32
            *)&(KxTHMR_k_IFuCellHiTHEXTInTar_T[0])), ((const float32 *)
            &(KtTHMR_k_IFuCellHiTHEXTInTar_T[0])), 8U)) * 0.1F;

        /* RelationalOperator: '<S1099>/Relational Operator2' incorporates:
         *  Constant: '<S1099>/Constant3'
         */
        rtb_Gain_pg = (rtb_TmpSignalConversionAtVeTM_p > 0.0F);

        /* RelationalOperator: '<S1098>/Relational Operator1' incorporates:
         *  Constant: '<S1098>/Constant'
         *  DataTypeConversion: '<S55>/Data Type Conversion'
         *  SignalConversion generated from: '<S2>/VeFCPR_e_FCPS_HTCoolReq'
         */
        THMR_ac_B.RelationalOperator1 = (((float32)
            rtb_TmpSignalConversionAtVeFC_o) == 2.0F);

        /* Logic: '<S1098>/Logical Operator3' incorporates:
         *  Abs: '<S1098>/Abs'
         *  Constant: '<S1110>/Calib'
         *  Logic: '<S1098>/Logical Operator'
         *  Logic: '<S1098>/Logical Operator1'
         *  Logic: '<S1098>/Logical Operator2'
         *  Logic: '<S1098>/Logical Operator4'
         *  Logic: '<S1098>/Logical Operator5'
         *  Logic: '<S1098>/Logical Operator6'
         *  MinMax: '<S1098>/MinMax'
         *  RelationalOperator: '<S1098>/Relational Operator'
         *  Sum: '<S1098>/Sum'
         *  UnitDelay: '<S1098>/Unit Delay2'
         *  UnitDelay: '<S1098>/Unit Delay3'
         */
        VeTHMR_b_FuCellHiTHEX_Int_Hld = (((((fmaxf(fabsf(rtb_Switch10 -
            Switch1_e), rtb_Switch1_pn[1]) >
            KeTHMR_T_FuCellHiTHEXCtlReqErrOvrd_C) &&
            ((!THMR_ac_DW.UnitDelay2_DSTATE_fi) &&
             (!THMR_ac_DW.UnitDelay3_DSTATE_fu))) || (rtb_Gain_pg &&
            (THMR_ac_DW.UnitDelay2_DSTATE_fi))) || ((!rtb_Gain_pg) &&
            (THMR_ac_DW.UnitDelay3_DSTATE_fu))) ||
            (THMR_ac_B.RelationalOperator1));

        /* Switch: '<S1099>/Switch2' incorporates:
         *  Switch: '<S1099>/Switch1'
         */
        if (VeTHMR_b_HiTPreHeatFuCell)
        {
            /* Switch: '<S1099>/Switch2' incorporates:
             *  Constant: '<S1099>/Constant4'
             */
            rtb_TmpSignalConversionAtVeTM_p = 0.0F;
        }
        else
        {
            if (VeTHMR_b_FuCellHiTHEX_Int_Hld)
            {
                /* Switch: '<S1099>/Switch1' incorporates:
                 *  Constant: '<S1099>/Constant2'
                 */
                rtb_TmpSignalConversionAtVeTM_p = 0.0F;
            }

            /* Switch: '<S1099>/Switch2' incorporates:
             *  Sum: '<S1099>/Sum'
             *  UnitDelay: '<S1099>/Unit Delay'
             */
            rtb_TmpSignalConversionAtVeTM_p += THMR_ac_DW.UnitDelay_DSTATE_kl;
        }

        /* End of Switch: '<S1099>/Switch2' */

        /* Switch: '<S1126>/Switch2' incorporates:
         *  UnitDelay: '<S1126>/Unit Delay'
         */
        if (THMR_ac_DW.UnitDelay_DSTATE_g >= 1.0F)
        {
            /* Switch: '<S1126>/Switch2' */
            VeTHMR_T_FuCellHiTHEXIReg = rtb_TmpSignalConversionAtVeTM_p;
        }
        else
        {
            /* Switch: '<S1126>/Switch2' incorporates:
             *  Constant: '<S1099>/Constant5'
             */
            VeTHMR_T_FuCellHiTHEXIReg = 0.0F;
        }

        /* End of Switch: '<S1126>/Switch2' */

        /* Switch: '<S905>/Switch1' incorporates:
         *  Constant: '<S1104>/Calib'
         *  Constant: '<S905>/Constant2'
         */
        if (KeTHMR_b_AcvPropTCoOutDeltaFuCellHiTHEX_C)
        {
            rtb_Switch10 = VeTHMR_T_CoOutDeltaFuCellHiTHEX;
        }
        else
        {
            rtb_Switch10 = 0.0F;
        }

        /* End of Switch: '<S905>/Switch1' */

        /* Sum: '<S905>/Sum' */
        Switch1_e = rtb_Switch10 + VeTHMR_T_FuCellHiTHEXIReg;

        /* MinMax: '<S1097>/MinMax' incorporates:
         *  Constant: '<S1101>/Calib'
         *  Constant: '<S1102>/Calib'
         *  MinMax: '<S1097>/MinMax1'
         */
        VeTHMR_T_FuCellHiTHEXRegCtl = fminf(KeTHMR_T_FuCellHiTHEXCtlMax_C, fmaxf
            (Switch1_e, KeTHMR_T_FuCellHiTHEXCtlMin_C));

        /* UnitDelay: '<S1107>/Unit Delay1' */
        rtb_VeTHMR_Pct_FCHTRRadFanCmd = THMR_ac_DW.UnitDelay1_DSTATE_bq;

        /* Switch: '<S905>/Switch2' */
        if (VeTHMR_b_HiTPreHeatFuCell)
        {
            /* Switch: '<S905>/Switch2' incorporates:
             *  Constant: '<S905>/Constant1'
             */
            VeTHMR_T_FuCellHiTHEXTInTarRegCtlRaw = -40.0F;
        }
        else
        {
            /* Switch: '<S905>/Switch2' incorporates:
             *  Sum: '<S905>/Sum1'
             */
            VeTHMR_T_FuCellHiTHEXTInTarRegCtlRaw = VeTHMR_T_FuCellHiTHEXRegCtl +
                VeTHMR_T_CoFuCellHiTInSp;
        }

        /* End of Switch: '<S905>/Switch2' */

        /* Switch: '<S1107>/Switch2' incorporates:
         *  Logic: '<S1107>/Logical Operator1'
         *  Logic: '<S1107>/Logical Operator5'
         *  UnitDelay: '<S1107>/Unit Delay2'
         *  UnitDelay: '<S905>/Unit Delay2'
         */
        if ((THMR_ac_DW.UnitDelay2_DSTATE_lm) &&
                (!THMR_ac_DW.UnitDelay2_DSTATE_km))
        {
            /* Switch: '<S1107>/Switch2' incorporates:
             *  Constant: '<S1106>/Calib'
             *  Constant: '<S905>/Constant3'
             *  Product: '<S1107>/Divide'
             *  Product: '<S1107>/Product'
             *  Sum: '<S1107>/Sum1'
             *  Sum: '<S1107>/Sum2'
             *  Sum: '<S1107>/Sum3'
             */
            VeTHMR_T_FuCellHiTHEXTInTarRegCtlFil = rtb_VeTHMR_Pct_FCHTRRadFanCmd
                - ((0.1F / (KeTHMR_k_TCoFuCellHiTHEXMesDlyFil_C + 0.1F)) *
                   (rtb_VeTHMR_Pct_FCHTRRadFanCmd -
                    VeTHMR_T_FuCellHiTHEXTInTarRegCtlRaw));
        }
        else
        {
            /* Switch: '<S1107>/Switch2' */
            VeTHMR_T_FuCellHiTHEXTInTarRegCtlFil = VeTHMR_T_CoFuCellHiTInSp;
        }

        /* End of Switch: '<S1107>/Switch2' */

        /* Switch: '<S905>/Switch4' incorporates:
         *  Constant: '<S1105>/Calib'
         *  Switch: '<S905>/Switch3'
         */
        if (THMR_ac_B.RelationalOperator1)
        {
            /* Switch: '<S905>/Switch4' incorporates:
             *  Constant: '<S1103>/Calib'
             */
            THMR_ac_B.Switch4_a = KeTHMR_T_FuCellHiTHEXTInTarPreHeat_C;
        }
        else if (KeTHMR_b_SelFuCellHiTHEXTInTar_C)
        {
            /* Switch: '<S905>/Switch3' incorporates:
             *  Switch: '<S905>/Switch4'
             */
            THMR_ac_B.Switch4_a = VeTHMR_T_FuCellHiTHEXTInTarRegCtlRaw;
        }
        else
        {
            /* Switch: '<S905>/Switch4' incorporates:
             *  Switch: '<S905>/Switch3'
             */
            THMR_ac_B.Switch4_a = VeTHMR_T_FuCellHiTHEXTInTarRegCtlFil;
        }

        /* End of Switch: '<S905>/Switch4' */

        /* Update for UnitDelay: '<S1120>/Unit Delay3' */
        THMR_ac_DW.UnitDelay3_DSTATE_o = rtb_TmpSignalConversionAtVeP_el;

        /* Update for UnitDelay: '<S1099>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_kl = rtb_TmpSignalConversionAtVeTM_p;

        /* Update for UnitDelay: '<S1098>/Unit Delay' */
        THMR_ac_DW.UnitDelay_DSTATE_cn = VeTHMR_T_FuCellHiTHEXTInTarRegCtlFil;

        /* Update for UnitDelay: '<S1098>/Unit Delay1' */
        THMR_ac_DW.UnitDelay1_DSTATE_dk = VeTHMR_T_FuCellHiTHEXTInTarRegCtlRaw;

        /* Update for UnitDelay: '<S1098>/Unit Delay2' incorporates:
         *  Constant: '<S1101>/Calib'
         *  RelationalOperator: '<S1097>/Relational Operator1'
         */
        THMR_ac_DW.UnitDelay2_DSTATE_fi = (KeTHMR_T_FuCellHiTHEXCtlMax_C <=
            Switch1_e);

        /* Update for UnitDelay: '<S1098>/Unit Delay3' incorporates:
         *  Constant: '<S1102>/Calib'
         *  RelationalOperator: '<S1097>/Relational Operator'
         */
        THMR_ac_DW.UnitDelay3_DSTATE_fu = (Switch1_e <=
            KeTHMR_T_FuCellHiTHEXCtlMin_C);

        /* Update for UnitDelay: '<S1126>/Unit Delay' incorporates:
         *  Constant: '<S1126>/Constant1'
         */
        THMR_ac_DW.UnitDelay_DSTATE_g = 1.0F;

        /* Update for UnitDelay: '<S905>/Unit Delay2' */
        THMR_ac_DW.UnitDelay2_DSTATE_km = VeTHMR_b_HiTPreHeatFuCell;

        /* Update for UnitDelay: '<S1107>/Unit Delay2' incorporates:
         *  Constant: '<S1107>/Constant3'
         */
        THMR_ac_DW.UnitDelay2_DSTATE_lm = true;

        /* Update for UnitDelay: '<S1107>/Unit Delay1' */
        THMR_ac_DW.UnitDelay1_DSTATE_bq = VeTHMR_T_FuCellHiTHEXTInTarRegCtlFil;
    }

    /* End of Constant: '<S906>/Calib' */
    /* End of Outputs for SubSystem: '<S748>/F02_07_FuCellHiTHEX_TInTarRegCtl' */

    /* RelationalOperator: '<S902>/RelationalOperator3' incorporates:
     *  Abs: '<S902>/Abs'
     *  Constant: '<S916>/Calib'
     *  Sum: '<S902>/Subtraction5'
     */
    rtb_TmpSignalConversionAtVeP_el = (fabsf(VeTHMR_k_WaPmpFuCellReg -
        rtb_Switch3_l0) > KeTHMR_k_WaPmpFuCellGrdAcvDif_C);

    /* Switch: '<S926>/Switch1' */
    if (rtb_TmpSignalConversionAtVeP_el)
    {
        /* Switch: '<S930>/Init' incorporates:
         *  UnitDelay: '<S930>/FixPt Unit Delay2'
         */
        if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_h) != 0)
        {
            /* Switch: '<S930>/Init' */
            rtb_TmpSignalConversionAtVeTM_p = rtb_Switch3_l0;
        }
        else
        {
            /* Switch: '<S930>/Init' incorporates:
             *  UnitDelay: '<S930>/FixPt Unit Delay1'
             */
            rtb_TmpSignalConversionAtVeTM_p =
                THMR_ac_DW.FixPtUnitDelay1_DSTATE_m;
        }

        /* End of Switch: '<S930>/Init' */

        /* Switch: '<S926>/Switch1' incorporates:
         *  Constant: '<S902>/Constant3'
         *  Constant: '<S911>/Calib'
         *  Constant: '<S912>/Calib'
         *  MinMax: '<S929>/MinMax'
         *  MinMax: '<S929>/MinMax1'
         *  Product: '<S926>/Product1'
         *  Product: '<S926>/Product2'
         *  Sum: '<S926>/Subtraction1'
         *  Sum: '<S926>/Subtraction10'
         */
        rtb_Switch3_l0 = fminf(KeTHMR_dPct_IncHiTFuCellWaPmpPIDReq_C * 0.1F,
                               fmaxf(rtb_Switch3_l0 -
                                rtb_TmpSignalConversionAtVeTM_p,
                                KeTHMR_dPct_DecHiTFuCellWaPmpPIDReq_C * 0.1F)) +
            rtb_TmpSignalConversionAtVeTM_p;
    }

    /* End of Switch: '<S926>/Switch1' */

    /* Switch: '<S902>/Switch2' incorporates:
     *  Constant: '<S915>/Calib'
     *  Constant: '<S928>/Constant1'
     *  DataTypeConversion: '<S55>/Data Type Conversion'
     *  RelationalOperator: '<S928>/RelationalOperator4'
     *  SignalConversion generated from: '<S2>/VeFCPR_e_FCPS_HTCoolReq'
     */
    if (((float32)rtb_TmpSignalConversionAtVeFC_o) == 1.0F)
    {
        Switch1_e = rtb_Switch3_l0;
    }
    else
    {
        Switch1_e = KeTHMR_k_WaPmpFuCellDft_C;
    }

    /* End of Switch: '<S902>/Switch2' */

    /* Switch: '<S902>/Switch4' incorporates:
     *  Constant: '<S902>/Constant4'
     *  Constant: '<S907>/Calib'
     *  Constant: '<S914>/Calib'
     *  Logic: '<S902>/LogicalOperator5'
     *  RelationalOperator: '<S902>/RelationalOperator4'
     */
    if ((THMR_ac_B.RelationalOperator1) && (rtb_TmpSignalConversionAtVeHTIR >
            KeTHMR_P_HVWHFuCellPreHeatMinWaPmp_C))
    {
        rtb_Switch10 = KeTHMR_k_HiTFuCellWaPmpPreHeat_C;
    }
    else
    {
        rtb_Switch10 = 0.0F;
    }

    /* End of Switch: '<S902>/Switch4' */

    /* Switch: '<S902>/Switch5' incorporates:
     *  Constant: '<S902>/Constant5'
     *  Constant: '<S913>/Calib'
     */
    if (rtb_RelationalOperator5_o)
    {
        rtb_Sum_e = KeTHMR_k_HiTFuCellWaPmpExtOptCtl_C;
    }
    else
    {
        rtb_Sum_e = 0.0F;
    }

    /* End of Switch: '<S902>/Switch5' */

    /* MinMax: '<S902>/MinMax2' */
    VeTHMR_k_HiTFuCellWaPmpCtlReq = fmaxf(fmaxf(Switch1_e, rtb_Switch10),
        rtb_Sum_e);

    /* Update for UnitDelay: '<S928>/Unit Delay5' incorporates:
     *  Constant: '<S909>/Calib'
     *  RelationalOperator: '<S931>/Relational Operator'
     */
    THMR_ac_DW.UnitDelay5_DSTATE_c = (rtb_TmpSignalConversionAtVeTA_n <=
        KeTHMR_T_WaPmpFuCellPIDMin_C);

    /* Update for UnitDelay: '<S928>/Unit Delay4' incorporates:
     *  Constant: '<S908>/Calib'
     *  RelationalOperator: '<S931>/Relational Operator1'
     */
    THMR_ac_DW.UnitDelay4_DSTATE_d = (KeTHMR_T_WaPmpFuCellPIDMax_C <=
        rtb_TmpSignalConversionAtVeTA_n);

    /* Lookup_n-D: '<S961>/Vector' incorporates:
     *  MinMax: '<S945>/MinMax'
     */
    VeTHMR_k_ElVlv3WayReqLnr = look1_iflf_binlcapw(VeTHMR_k_ElVlv3WayFuCellPID,
        ((const float32 *)&(KxTHMR_k_ElVlv3WayFuCellPosnLnr_T[0])), ((const
        float32 *)&(KtTHMR_k_ElVlv3WayFuCellPosnLnr_T[0])), 17U);

    /* MinMax: '<S957>/MinMax' incorporates:
     *  UnitDelay: '<S957>/Unit Delay1'
     */
    VeTHMR_k_ElVlv3WayReqLnrMin_MP = fminf(VeTHMR_k_ElVlv3WayReqLnr,
        THMR_ac_DW.UnitDelay1_DSTATE_lf);

    /* Switch: '<S957>/Switch1' incorporates:
     *  UnitDelay: '<S957>/Unit Delay2'
     */
    if (THMR_ac_DW.UnitDelay2_DSTATE_jn)
    {
        /* Switch: '<S957>/Switch1' */
        rtb_TmpSignalConversionAtVeHTIR = VeTHMR_k_ElVlv3WayReqLnr;
    }
    else
    {
        /* Switch: '<S957>/Switch1' */
        rtb_TmpSignalConversionAtVeHTIR = VeTHMR_k_ElVlv3WayReqLnrMin_MP;
    }

    /* End of Switch: '<S957>/Switch1' */

    /* RelationalOperator: '<S957>/Relational Operator' incorporates:
     *  Constant: '<S959>/Calib'
     *  Sum: '<S957>/Sum2'
     */
    rtb_Gain_pg = ((VeTHMR_k_ElVlv3WayReqLnr - rtb_TmpSignalConversionAtVeHTIR) >
                   KeTHMR_k_ElVlv3WayDirDetMinHys_C);

    /* Outputs for Atomic SubSystem: '<S957>/EdgeRising' */
    /* Logic: '<S962>/AND' incorporates:
     *  Logic: '<S962>/OR1'
     *  UnitDelay: '<S962>/Unit Delay'
     */
    VeTHMR_b_ElVlv3WayReqDetInc = (rtb_Gain_pg &&
        (!THMR_ac_DW.UnitDelay_DSTATE_gkd));

    /* Update for UnitDelay: '<S962>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_gkd = rtb_Gain_pg;

    /* End of Outputs for SubSystem: '<S957>/EdgeRising' */

    /* MinMax: '<S958>/MinMax' incorporates:
     *  UnitDelay: '<S958>/Unit Delay1'
     */
    VeTHMR_k_ElVlv3WayReqLnrMax_MP = fmaxf(VeTHMR_k_ElVlv3WayReqLnr,
        THMR_ac_DW.UnitDelay1_DSTATE_e);

    /* Switch: '<S958>/Switch1' incorporates:
     *  UnitDelay: '<S958>/Unit Delay2'
     */
    if (THMR_ac_DW.UnitDelay2_DSTATE_ozu)
    {
        /* Switch: '<S958>/Switch1' */
        rtb_TmpSignalConversionAtVeTM_p = VeTHMR_k_ElVlv3WayReqLnr;
    }
    else
    {
        /* Switch: '<S958>/Switch1' */
        rtb_TmpSignalConversionAtVeTM_p = VeTHMR_k_ElVlv3WayReqLnrMax_MP;
    }

    /* End of Switch: '<S958>/Switch1' */

    /* RelationalOperator: '<S958>/Relational Operator' incorporates:
     *  Constant: '<S959>/Calib'
     *  Sum: '<S958>/Sum2'
     */
    rtb_Gain_pg = ((rtb_TmpSignalConversionAtVeTM_p - VeTHMR_k_ElVlv3WayReqLnr) >
                   KeTHMR_k_ElVlv3WayDirDetMinHys_C);

    /* Outputs for Atomic SubSystem: '<S958>/EdgeRising' */
    /* Logic: '<S963>/AND' incorporates:
     *  Logic: '<S963>/OR1'
     *  UnitDelay: '<S963>/Unit Delay'
     */
    VeTHMR_b_ElVlv3WayReqDetDec = (rtb_Gain_pg &&
        (!THMR_ac_DW.UnitDelay_DSTATE_nu));

    /* Update for UnitDelay: '<S963>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_nu = rtb_Gain_pg;

    /* End of Outputs for SubSystem: '<S958>/EdgeRising' */

    /* Switch: '<S946>/Switch1' incorporates:
     *  Switch: '<S946>/Switch2'
     */
    if (VeTHMR_b_ElVlv3WayReqDetInc)
    {
        /* Switch: '<S946>/Switch1' incorporates:
         *  Constant: '<S946>/Constant2'
         */
        Switch1_e = 0.0F;
    }
    else if (VeTHMR_b_ElVlv3WayReqDetDec)
    {
        /* Switch: '<S946>/Switch2' incorporates:
         *  Constant: '<S960>/Calib'
         *  Switch: '<S946>/Switch1'
         */
        Switch1_e = KeTHMR_k_ElVlv3WayTranCmpHys_C;
    }
    else
    {
        /* Switch: '<S946>/Switch1' incorporates:
         *  UnitDelay: '<S946>/Unit Delay1'
         */
        Switch1_e = THMR_ac_DW.UnitDelay1_DSTATE_jo;
    }

    /* End of Switch: '<S946>/Switch1' */

    /* Sum: '<S946>/Sum2' */
    VeTHMR_k_ElVlv3WayFuCellReqCtl = VeTHMR_k_ElVlv3WayReqLnr - Switch1_e;

    /* MinMax: '<S998>/MinMax' incorporates:
     *  Constant: '<S949>/Constant17'
     *  Constant: '<S949>/Constant18'
     *  MinMax: '<S998>/MinMax1'
     *  Sum: '<S949>/Sum11'
     */
    VeTHMR_T_DifWaOutRadFuCellOutHiT = fminf(200.0F, fmaxf
        (VeTHMR_T_WaOutRadHiTFil - VeTHMR_T_CoFuCellHiTOutFil, -200.0F));

    /* Switch: '<S1000>/Switch2' */
    if (rtb_Switch1_hj)
    {
        /* Update for UnitDelay: '<S1000>/Unit Delay' incorporates:
         *  Constant: '<S1025>/Calib'
         *  Switch: '<S1000>/Switch2'
         */
        THMR_ac_DW.UnitDelay_DSTATE_m0 =
            KeTHMR_Cnt_InitDlyTCoSenElVlv3WayFuCellCtl_C;
    }
    else
    {
        /* Update for UnitDelay: '<S1000>/Unit Delay' incorporates:
         *  Constant: '<S1000>/Constant1'
         *  Sum: '<S1000>/Sum1'
         *  Switch: '<S1000>/Switch2'
         */
        THMR_ac_DW.UnitDelay_DSTATE_m0++;
    }

    /* End of Switch: '<S1000>/Switch2' */

    /* Gain: '<S950>/Gain2' incorporates:
     *  DataTypeConversion: '<S950>/Data Type Conversion1'
     */
    VeTHMR_T_iFuCellPwrLimTh = 0.1F * ((float32)
        THMR_ac_B.VeTHMR_Cnt_FuCellPwrLimTh);

    /* Switch: '<S903>/Switch2' */
    if (rtb_Switch1_cys)
    {
        /* Switch: '<S903>/Switch2' incorporates:
         *  Constant: '<S954>/Calib'
         */
        VeTHMR_k_ElVlv3WayFuCellReqBf = KeTHMR_k_ElVlv3WayFuCellOffReq_C;
    }
    else
    {
        /* Switch: '<S903>/Switch2' */
        VeTHMR_k_ElVlv3WayFuCellReqBf = VeTHMR_k_ElVlv3WayFuCellReqCtl;
    }

    /* End of Switch: '<S903>/Switch2' */

    /* Switch: '<S1091>/Switch2' incorporates:
     *  UnitDelay: '<S1091>/Unit Delay1'
     */
    if (THMR_ac_DW.UnitDelay1_DSTATE_e0)
    {
        /* MinMax: '<S1093>/MinMax' incorporates:
         *  Constant: '<S1083>/Calib'
         *  Constant: '<S1091>/Constant1'
         *  Constant: '<S1091>/Constant2'
         *  MinMax: '<S1093>/MinMax1'
         */
        rtb_TmpSignalConversionAtVeTA_n = fminf(1.0F, fmaxf
            (KeTHMR_k_ElVlv3WayFanLpf_C, 0.0F));

        /* Switch: '<S1064>/Switch2' incorporates:
         *  Constant: '<S1064>/Constant1'
         *  Constant: '<S1064>/Constant2'
         *  Constant: '<S1064>/Constant3'
         *  Constant: '<S1082>/Calib'
         *  MinMax: '<S1080>/MinMax'
         *  MinMax: '<S1080>/MinMax1'
         *  RelationalOperator: '<S1064>/Relational Operator4'
         */
        if (VeTHMR_y_PwrFuCellMaxLimTh == 6)
        {
            rtb_Switch10 = KeTHMR_k_ElVlv3WayFanLpfInit_C;
        }
        else
        {
            rtb_Switch10 = fminf(100.0F, fmaxf(VeTHMR_k_ElVlv3WayFuCellPID, 0.0F));
        }

        /* End of Switch: '<S1064>/Switch2' */

        /* Switch: '<S1091>/Switch2' incorporates:
         *  Constant: '<S1091>/Constant3'
         *  Product: '<S1091>/Product'
         *  Product: '<S1091>/Product1'
         *  Sum: '<S1091>/Sum'
         *  Sum: '<S1091>/Sum1'
         *  UnitDelay: '<S1091>/Unit Delay2'
         */
        VeTHMR_k_ElVlv3WayFuCellPIDFlt = ((1.0F -
            rtb_TmpSignalConversionAtVeTA_n) * THMR_ac_DW.UnitDelay2_DSTATE_j) +
            (rtb_Switch10 * rtb_TmpSignalConversionAtVeTA_n);
    }
    else
    {
        /* Switch: '<S1091>/Switch2' incorporates:
         *  Constant: '<S1082>/Calib'
         */
        VeTHMR_k_ElVlv3WayFuCellPIDFlt = KeTHMR_k_ElVlv3WayFanLpfInit_C;
    }

    /* End of Switch: '<S1091>/Switch2' */

    /* RelationalOperator: '<S1064>/Relational Operator1' incorporates:
     *  Constant: '<S1084>/Calib'
     */
    rtb_Switch1_hj = (VeTHMR_k_ElVlv3WayFuCellPIDFlt >
                      KeTHMR_k_ElVlv3WayFanMinPosn_C);

    /* Outputs for Atomic SubSystem: '<S1064>/Turn On Delay Time' */
    /* Outputs for Atomic SubSystem: '<S1092>/EdgeRising' */
    /* Logic: '<S1094>/AND' incorporates:
     *  Logic: '<S1094>/OR1'
     *  UnitDelay: '<S1094>/Unit Delay'
     */
    rtb_Switch1_cys = (rtb_Switch1_hj && (!THMR_ac_DW.UnitDelay_DSTATE_f1k));

    /* Update for UnitDelay: '<S1094>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_f1k = rtb_Switch1_hj;

    /* End of Outputs for SubSystem: '<S1092>/EdgeRising' */

    /* Switch: '<S1092>/Switch1' incorporates:
     *  Logic: '<S1092>/OR'
     *  Logic: '<S1092>/OR1'
     */
    if ((!rtb_Switch1_hj) || rtb_Switch1_cys)
    {
        /* Switch: '<S1092>/Switch1' incorporates:
         *  Constant: '<S1092>/Constant Value1'
         */
        rtb_TmpSignalConversionAtVeTA_n = 0.0F;
    }
    else
    {
        /* Switch: '<S1092>/Switch1' incorporates:
         *  Constant: '<S1064>/Constant5'
         *  Constant: '<S1085>/Calib'
         *  MinMax: '<S1092>/Minimum'
         *  Sum: '<S1092>/Summation'
         *  UnitDelay: '<S1092>/Unit Delay'
         */
        rtb_TmpSignalConversionAtVeTA_n = fminf(KeTHMR_t_ElVlv3WayFanMinOffDly_C,
            THMR_ac_DW.UnitDelay_DSTATE_dye + 0.1F);
    }

    /* End of Switch: '<S1092>/Switch1' */

    /* Logic: '<S1092>/AND' incorporates:
     *  Constant: '<S1085>/Calib'
     *  RelationalOperator: '<S1092>/Greater  Than'
     */
    VeTHMR_b_FanReqOff = (rtb_Switch1_hj && (rtb_TmpSignalConversionAtVeTA_n >=
                           KeTHMR_t_ElVlv3WayFanMinOffDly_C));

    /* Update for UnitDelay: '<S1092>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_dye = rtb_TmpSignalConversionAtVeTA_n;

    /* End of Outputs for SubSystem: '<S1064>/Turn On Delay Time' */

    /* Sum: '<S1063>/Sum' */
    VeTHMR_T_CoFuCellHiTOutDelt = rtb_TmpSignalConversionAtVeF_n4 -
        rtb_TmpSignalConversionAtVeFC_k;

    /* UnitDelay: '<S1063>/Unit Delay2' */
    rtb_TmpSignalConversionAtVeF_n4 = THMR_ac_DW.UnitDelay2_DSTATE_gi;

    /* Switch: '<S1063>/Switch2' */
    if (VeTHMR_b_FanReqOff)
    {
        /* Switch: '<S1063>/Switch2' incorporates:
         *  Constant: '<S1063>/Constant7'
         */
        VeTHMR_n_AirHiTReq_MP = 0.0F;
    }
    else
    {
        /* Lookup_n-D: '<S1079>/Vector' incorporates:
         *  Product: '<S55>/Product1'
         *  SignalConversion generated from: '<S2>/OutAirTemp_Est_AftDial_Read'
         */
        rtb_TmpSignalConversionAtVeTA_n = look2_iflf_binlcapw
            (TmpSignalConversionAtOutAirTemp, rtb_TmpSignalConversionAtVeFCPR,
             ((const float32 *)&(KxTHMR_n_AirHiTNomReq_M[0])), ((const float32 *)
              &(KyTHMR_n_AirHiTNomReq_M[0])), ((const float32 *)
              &(KtTHMR_n_AirHiTNomReq_M[0])), THMR_ac_ConstP.pooled43, 8U);

        /* MinMax: '<S1063>/MinMax1' incorporates:
         *  Lookup_n-D: '<S1077>/Vector'
         *  Product: '<S1063>/Product'
         *  Sum: '<S1063>/Sum'
         */
        rtb_VeTHMR_Pct_FCHTRRadFanCmd = fmaxf(rtb_TmpSignalConversionAtVeTA_n *
            look1_iflf_binlcapw(VeTHMR_T_CoFuCellHiTOutDelt, ((const float32 *)
            &(KxTHMR_k_SpdAirHiTDown_T[0])), ((const float32 *)
            &(KtTHMR_k_SpdAirHiTDown_T[0])), 8U),
            rtb_TmpSignalConversionAtVeF_n4);

        /* Switch: '<S1063>/Switch1' incorporates:
         *  RelationalOperator: '<S1063>/Relational Operator2'
         */
        if (rtb_VeTHMR_Pct_FCHTRRadFanCmd < rtb_TmpSignalConversionAtVeF_n4)
        {
            /* Switch: '<S1063>/Switch2' incorporates:
             *  Switch: '<S1063>/Switch1'
             */
            VeTHMR_n_AirHiTReq_MP = rtb_VeTHMR_Pct_FCHTRRadFanCmd;
        }
        else
        {
            /* Switch: '<S1063>/Switch2' incorporates:
             *  Lookup_n-D: '<S1078>/Vector'
             *  MinMax: '<S1063>/MinMax'
             *  Product: '<S1063>/Product1'
             *  Sum: '<S1063>/Sum'
             *  Switch: '<S1063>/Switch1'
             */
            VeTHMR_n_AirHiTReq_MP = fmaxf(rtb_TmpSignalConversionAtVeF_n4,
                rtb_TmpSignalConversionAtVeTA_n * look1_iflf_binlcapw
                (VeTHMR_T_CoFuCellHiTOutDelt, ((const float32 *)
                &(KxTHMR_k_SpdAirHiTUp_T[0])), ((const float32 *)
                &(KtTHMR_k_SpdAirHiTUp_T[0])), 8U));
        }

        /* End of Switch: '<S1063>/Switch1' */
    }

    /* End of Switch: '<S1063>/Switch2' */

    /* Lookup_n-D: '<S1076>/Vector' incorporates:
     *  SignalConversion generated from: '<S2>/VeCSVR_v_VehSpd'
     *  Switch: '<S1063>/Switch2'
     */
    VeTHMR_k_HiTSpdAirBasReq = look2_iflf_binlcapw
        (rtb_TmpSignalConversionAtVeCSVR, VeTHMR_n_AirHiTReq_MP, ((const float32
           *)&(KxTHMR_k_HiTSpdFanReq_M[0])), ((const float32 *)
          &(KyTHMR_k_HiTSpdFanReq_M[0])), ((const float32 *)
          &(KtTHMR_k_HiTSpdFanReq_M[0])), THMR_ac_ConstP.pooled46, 7U);

    /* MinMax: '<S1064>/MinMax' incorporates:
     *  Lookup_n-D: '<S1086>/Vector'
     *  Product: '<S55>/Product1'
     *  SignalConversion generated from: '<S2>/VeCSVR_v_VehSpd'
     */
    VeTHMR_k_HiTSpdAirSysReqTrim = fmaxf(look2_iflf_binlcapw
        (rtb_TmpSignalConversionAtVeCSVR, rtb_TmpSignalConversionAtVeFCPR, ((
        const float32 *)&(KxTHMR_k_HiTSpdFanSysReqTrimMin_M[0])), ((const
        float32 *)&(KyTHMR_k_HiTSpdFanSysReqTrimMin_M[0])), ((const float32 *)
        &(KtTHMR_k_HiTSpdFanSysReqTrimMin_M[0])), THMR_ac_ConstP.pooled47, 7U),
        VeTHMR_k_HiTSpdAirBasReq);

    /* MinMax: '<S1081>/MinMax' incorporates:
     *  Constant: '<S1064>/Constant6'
     *  Constant: '<S1064>/Constant7'
     *  Lookup_n-D: '<S1089>/Vector'
     *  MinMax: '<S1081>/MinMax1'
     *  Product: '<S1064>/Product'
     *  Sum: '<S1064>/Sum'
     *  Switch: '<S1091>/Switch2'
     */
    VeTHMR_k_SpdAirHiTSysReq_MP = fminf(100.0F, fmaxf(look2_iflf_binlcapw
        (VeTHMR_k_ElVlv3WayFuCellPIDFlt, rtb_TmpSignalConversionAtVeFC_f -
         VeTHMR_T_CoFuCellHiTInSp, ((const float32 *)
        &(KxTHMR_k_SpdAirHiTSysReq_M[0])), ((const float32 *)
        &(KyTHMR_k_SpdAirHiTSysReq_M[0])), ((const float32 *)
        &(KtTHMR_k_SpdAirHiTSysReq_M[0])), THMR_ac_ConstP.pooled46, 7U) *
        VeTHMR_k_HiTSpdAirSysReqTrim, 0.0F));

    /* UnitDelay: '<S1090>/Unit Delay1' */
    rtb_TmpSignalConversionAtVeCSVR = THMR_ac_DW.UnitDelay1_DSTATE_at;

    /* Switch: '<S1090>/Switch2' incorporates:
     *  Logic: '<S1090>/Logical Operator1'
     *  Logic: '<S1090>/Logical Operator5'
     *  UnitDelay: '<S1090>/Unit Delay2'
     */
    if ((THMR_ac_DW.UnitDelay2_DSTATE_f) && (!VeTHMR_b_FanReqOff))
    {
        /* Switch: '<S1064>/Switch1' incorporates:
         *  Lookup_n-D: '<S1087>/Vector'
         *  Lookup_n-D: '<S1088>/Vector'
         *  RelationalOperator: '<S1064>/Relational Operator2'
         *  Switch: '<S1091>/Switch2'
         *  UnitDelay: '<S1064>/Unit Delay2'
         */
        if (VeTHMR_k_SpdAirHiTSysReq_MP > THMR_ac_DW.UnitDelay2_DSTATE_pg)
        {
            rtb_Switch10 = look1_iflf_binlcapw(VeTHMR_k_ElVlv3WayFuCellPIDFlt,
                ((const float32 *)&(KxTHMR_k_LpfSpdAirHiTSysReqInc_T[0])), ((
                const float32 *)&(KtTHMR_k_LpfSpdAirHiTSysReqInc_T[0])), 6U);
        }
        else
        {
            rtb_Switch10 = look1_iflf_binlcapw(VeTHMR_k_ElVlv3WayFuCellPIDFlt,
                ((const float32 *)&(KxTHMR_k_LpfSpdAirHiTSysReqDec_T[0])), ((
                const float32 *)&(KtTHMR_k_LpfSpdAirHiTSysReqDec_T[0])), 6U);
        }

        /* End of Switch: '<S1064>/Switch1' */

        /* Switch: '<S1090>/Switch2' incorporates:
         *  Constant: '<S1064>/Constant8'
         *  Product: '<S1090>/Divide'
         *  Product: '<S1090>/Product'
         *  Sum: '<S1090>/Sum1'
         *  Sum: '<S1090>/Sum2'
         *  Sum: '<S1090>/Sum3'
         */
        VeTHMR_k_SpdAirHiTSysReqFlt = rtb_TmpSignalConversionAtVeCSVR - ((0.1F /
            (rtb_Switch10 + 0.1F)) * (rtb_TmpSignalConversionAtVeCSVR -
            VeTHMR_k_SpdAirHiTSysReq_MP));
    }
    else
    {
        /* Switch: '<S1090>/Switch2' */
        VeTHMR_k_SpdAirHiTSysReqFlt = VeTHMR_k_SpdAirHiTSysReq_MP;
    }

    /* End of Switch: '<S1090>/Switch2' */

    /* MinMax: '<S904>/MinMax' incorporates:
     *  Lookup_n-D: '<S1074>/Vector'
     *  MinMax: '<S999>/MinMax'
     *  Sum: '<S904>/Sum'
     */
    VeTHMR_k_HiTSpdAirMinReq = fmaxf(VeTHMR_k_SpdAirHiTSysReqFlt +
        VeTHMR_k_HiTSpdAirBasReq, look1_iflf_binlcapw
        (VeTHMR_T_DifFuCellInSpWaOutRadHiT, ((const float32 *)
        &(KxTHMR_k_HiTSpdFanTRadOutMin_T[0])), ((const float32 *)
        &(KtTHMR_k_HiTSpdFanTRadOutMin_T[0])), 4U));

    /* Switch: '<S904>/Switch1' incorporates:
     *  Constant: '<S1068>/Calib'
     *  Constant: '<S904>/Constant7'
     */
    if (rtb_RelationalOperator5_o)
    {
        rtb_Sum_e = KeTHMR_k_HiTFuCellSpdAirMaxExtOptCtl_C;
    }
    else
    {
        rtb_Sum_e = 100.0F;
    }

    /* End of Switch: '<S904>/Switch1' */

    /* Switch: '<S904>/Switch2' incorporates:
     *  Constant: '<S904>/Constant7'
     *  Lookup_n-D: '<S1073>/Vector'
     *  MinMax: '<S998>/MinMax'
     */
    if (rtb_Switch1_p1)
    {
        rtb_TmpSignalConversionAtVeTA_n = 100.0F;
    }
    else
    {
        rtb_TmpSignalConversionAtVeTA_n = look1_iflf_binlcapw
            (VeTHMR_T_DifWaOutRadFuCellOutHiT, ((const float32 *)
              &(KxTHMR_k_HiTSpdFanTRadOutMax_T[0])), ((const float32 *)
              &(KtTHMR_k_HiTSpdFanTRadOutMax_T[0])), 4U);
    }

    /* End of Switch: '<S904>/Switch2' */

    /* MinMax: '<S904>/MinMax1' */
    VeTHMR_k_HiTSpdAirMaxReq = fminf(rtb_Sum_e, rtb_TmpSignalConversionAtVeTA_n);

    /* Switch: '<S1075>/Switch1' incorporates:
     *  Logic: '<S904>/Logical Operator'
     */
    if (!VeTHMR_b_FanReqOff)
    {
        /* Switch: '<S1096>/Init' incorporates:
         *  UnitDelay: '<S1096>/FixPt Unit Delay2'
         */
        if (((sint32)THMR_ac_DW.FixPtUnitDelay2_DSTATE_g) != 0)
        {
            /* Switch: '<S1096>/Init' incorporates:
             *  Constant: '<S904>/Constant1'
             */
            rtb_TmpSignalConversionAtVeCSVR = 0.0F;
        }
        else
        {
            /* Switch: '<S1096>/Init' incorporates:
             *  UnitDelay: '<S1096>/FixPt Unit Delay1'
             */
            rtb_TmpSignalConversionAtVeCSVR =
                THMR_ac_DW.FixPtUnitDelay1_DSTATE_b;
        }

        /* End of Switch: '<S1096>/Init' */

        /* Switch: '<S1075>/Switch1' incorporates:
         *  Constant: '<S1066>/Calib'
         *  Constant: '<S1067>/Calib'
         *  Constant: '<S904>/Constant2'
         *  MinMax: '<S1095>/MinMax'
         *  MinMax: '<S1095>/MinMax1'
         *  MinMax: '<S904>/MinMax2'
         *  Product: '<S1075>/Product1'
         *  Product: '<S1075>/Product2'
         *  Sum: '<S1075>/Subtraction1'
         *  Sum: '<S1075>/Subtraction10'
         */
        rtb_TmpSignalConversionAtVeCSVR += fminf(KeTHMR_dPct_HiTSpdAirReqInc_C *
            0.1F, fmaxf(fminf(VeTHMR_k_HiTSpdAirMinReq, VeTHMR_k_HiTSpdAirMaxReq)
                        - rtb_TmpSignalConversionAtVeCSVR,
                        KeTHMR_dPct_HiTSpdAirReqDec_C * 0.1F));
    }
    else
    {
        /* Switch: '<S1075>/Switch1' incorporates:
         *  Constant: '<S904>/Constant1'
         */
        rtb_TmpSignalConversionAtVeCSVR = 0.0F;
    }

    /* End of Switch: '<S1075>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S904>/Hysteresis' */
    /* Switch: '<S1065>/Switch1' incorporates:
     *  Constant: '<S1070>/Calib'
     *  RelationalOperator: '<S1065>/Greater  Than'
     */
    if (rtb_TmpSignalConversionAtVeCSVR > KeTHMR_k_HiTSpdAirReqHysMin_C)
    {
        /* Switch: '<S1065>/Switch1' incorporates:
         *  Constant: '<S1065>/Constant Value'
         */
        rtb_Switch1_p1 = true;
    }
    else
    {
        /* Switch: '<S1065>/Switch1' incorporates:
         *  Constant: '<S1069>/Calib'
         *  RelationalOperator: '<S1065>/Greater  Than1'
         *  Sum: '<S904>/Sum1'
         *  UnitDelay: '<S1065>/Unit Delay'
         */
        rtb_Switch1_p1 = ((rtb_TmpSignalConversionAtVeCSVR >=
                           (KeTHMR_k_HiTSpdAirReqHysMin_C -
                            KeTHMR_k_HiTSpdAirReqHysMinOfs_C)) &&
                          (THMR_ac_DW.UnitDelay_DSTATE_hr3));
    }

    /* End of Switch: '<S1065>/Switch1' */

    /* Update for UnitDelay: '<S1065>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_hr3 = rtb_Switch1_p1;

    /* End of Outputs for SubSystem: '<S904>/Hysteresis' */

    /* Switch: '<S904>/Switch3' incorporates:
     *  Constant: '<S1072>/Calib'
     *  Constant: '<S904>/Constant3'
     *  MinMax: '<S904>/MinMax3'
     */
    if (rtb_Switch1_p1)
    {
        rtb_TmpSignalConversionAtVeTA_n = fmaxf(rtb_TmpSignalConversionAtVeCSVR,
            KeTHMR_k_HiTSpdAirReqMin_C);
    }
    else
    {
        rtb_TmpSignalConversionAtVeTA_n = 0.0F;
    }

    /* End of Switch: '<S904>/Switch3' */

    /* MinMax: '<S904>/MinMax4' incorporates:
     *  Constant: '<S1071>/Calib'
     */
    VeTHMR_k_HiTSpdAirReq = fminf(rtb_TmpSignalConversionAtVeTA_n,
        KeTHMR_k_HiTSpdAirReqMax_C);

    /* Switch: '<S55>/Switch10' incorporates:
     *  Constant: '<S740>/Calib'
     *  Switch: '<S55>/Switch5'
     *  Switch: '<S55>/Switch6'
     *  Switch: '<S55>/Switch7'
     *  Switch: '<S55>/Switch8'
     *  Switch: '<S55>/Switch9'
     */
    if (KeTHMR_b_UseNucleusFCCntrls)
    {
        /* Switch: '<S55>/Switch10' */
        THMR_ac_B.Switch10 = THMR_ac_B.Switch4_a;

        /* Switch: '<S55>/Switch5' incorporates:
         *  Constant: '<S55>/Constant3'
         */
        THMR_ac_B.Switch5_k = 0.0F;

        /* Switch: '<S55>/Switch6' */
        THMR_ac_B.VeTHMR_Pct_FCCP_Cmd = VeTHMR_k_HiTFuCellWaPmpCtlReq;

        /* Switch: '<S55>/Switch7' */
        THMR_ac_B.Switch7_c = VeTHMR_k_ElVlv3WayFuCellReqBf;

        /* Switch: '<S55>/Switch8' incorporates:
         *  Constant: '<S55>/Constant4'
         */
        THMR_ac_B.Switch8_m = 0.0F;

        /* Switch: '<S55>/Switch9' */
        THMR_ac_B.VeTHMR_Pct_FCHTRRadFanCmd = VeTHMR_k_HiTSpdAirReq;
    }
    else
    {
        /* Switch: '<S55>/Switch10' */
        THMR_ac_B.Switch10 = VeTHMR_T_FC_HTCLTgt_Arb;

        /* Switch: '<S55>/Switch5' */
        THMR_ac_B.Switch5_k = rtb_Merge1;

        /* Switch: '<S55>/Switch6' incorporates:
         *  Constant: '<S55>/Constant3'
         */
        THMR_ac_B.VeTHMR_Pct_FCCP_Cmd = 0.0F;

        /* Switch: '<S55>/Switch7' */
        THMR_ac_B.Switch7_c = THMR_ac_B.Merge1_l;

        /* Switch: '<S55>/Switch8' */
        THMR_ac_B.Switch8_m = VeTHMR_dV_FC_HTR_AirFlow_Need;

        /* Switch: '<S55>/Switch9' incorporates:
         *  Constant: '<S55>/Constant4'
         */
        THMR_ac_B.VeTHMR_Pct_FCHTRRadFanCmd = 0.0F;
    }

    /* End of Switch: '<S55>/Switch10' */

    /* Update for UnitDelay: '<S784>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_hj = VeTHMR_Pct_FCVlv_Balancing;

    /* Update for UnitDelay: '<S55>/Unit Delay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_l = THMR_ac_B.Merge1_l;

    /* Update for Delay: '<S730>/Delay' incorporates:
     *  Logic: '<S730>/LogicalOperator'
     *  RelationalOperator: '<S730>/RelationalOperator'
     *  RelationalOperator: '<S730>/RelationalOperator1'
     */
    THMR_ac_DW.Delay_DSTATE_g = ((rtb_TmpSignalConversionAtVeFC_p >
        VeTHMR_dV_FC_HTR_AirFlow_Need) || (rtb_TmpSignalConversionAtVeFC_p <
        VeTHMR_dV_FC_HTR_AirFlow_Need));

    /* Update for UnitDelay: '<S791>/Unit Delay' incorporates:
     *  Logic: '<S791>/LogicalOperator1'
     *  RelationalOperator: '<S791>/RelationalOperator1'
     *  RelationalOperator: '<S791>/RelationalOperator2'
     */
    THMR_ac_DW.UnitDelay_DSTATE_h5 = ((rtb_TmpSignalConversionAtVeF_l2 >=
        rtb_TmpSignalConversionAtVePM_n) || (rtb_TmpSignalConversionAtVeF_l2 <=
        rtb_Switch_eu));

    /* Outputs for Atomic SubSystem: '<S816>/Timer Reset Enabled' */
    /* Update for UnitDelay: '<S816>/Unit Delay' incorporates:
     *  Constant: '<S838>/Constant Value2'
     *  RelationalOperator: '<S838>/Greater  Than1'
     */
    THMR_ac_DW.UnitDelay_DSTATE_nns = (rtb_TmpSignalConversionAtVeBTRR > 0.0F);

    /* End of Outputs for SubSystem: '<S816>/Timer Reset Enabled' */

    /* Update for UnitDelay: '<S950>/Unit Delay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_d = THMR_ac_B.VeTHMR_k_PwrFuCellMaxLimThStMch;

    /* Update for UnitDelay: '<S1034>/FixPt Unit Delay2' incorporates:
     *  Constant: '<S1034>/FixPt Constant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE = 0U;

    /* Update for UnitDelay: '<S1034>/FixPt Unit Delay1' */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE = VeTHMR_T_CoFuCellHiTOutSpPwrLimOfs;

    /* Update for UnitDelay: '<S903>/Unit Delay' incorporates:
     *  Constant: '<S903>/Constant1'
     *  DataTypeConversion: '<S55>/Data Type Conversion'
     *  Logic: '<S903>/Logical Operator2'
     *  RelationalOperator: '<S903>/Relational Operator'
     *  SignalConversion generated from: '<S2>/VeFCPR_e_FCPS_HTCoolReq'
     */
    THMR_ac_DW.UnitDelay_DSTATE_bx = ((((float32)rtb_TmpSignalConversionAtVeFC_o)
        == 0.0F) || rtb_RelationalOperator5_o);

    /* Update for UnitDelay: '<S1022>/Unit Delay2' */
    for (i = 0; i < 2; i++)
    {
        THMR_ac_DW.UnitDelay2_DSTATE_ek[i] = Switch3_h[i];
    }

    /* End of Update for UnitDelay: '<S1022>/Unit Delay2' */

    /* Update for UnitDelay: '<S1022>/Unit Delay1' incorporates:
     *  Constant: '<S1022>/Constant4'
     */
    THMR_ac_DW.UnitDelay1_DSTATE_a2 = true;

    /* Update for UnitDelay: '<S949>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_k = VeTHMR_T_CoFuCellHiTOutFil;

    /* Update for UnitDelay: '<S1021>/Unit Delay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_d3 = VeTHMR_T_CoFuCellHiTOutFil;

    /* Update for UnitDelay: '<S1021>/Unit Delay1' incorporates:
     *  Constant: '<S1021>/Constant4'
     */
    THMR_ac_DW.UnitDelay1_DSTATE_fjh = true;

    /* Update for UnitDelay: '<S949>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_j = VeTHMR_k_ElVlv3WayFuCellPID;

    /* Update for UnitDelay: '<S55>/Unit Delay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_b = VeTHMR_k_HiTFuCellWaPmpCtlReq;

    /* Update for UnitDelay: '<S1023>/Unit Delay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_n5 = VeTHMR_T_WaOutRadHiTEstim;

    /* Update for UnitDelay: '<S1023>/Unit Delay1' incorporates:
     *  Constant: '<S1023>/Constant4'
     */
    THMR_ac_DW.UnitDelay1_DSTATE_gl = true;

    /* Update for UnitDelay: '<S949>/Unit Delay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_aj = VeTHMR_T_WaOutRadHiTFil;

    /* Update for UnitDelay: '<S1024>/Unit Delay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_l = VeTHMR_T_WaOutRadHiTFil;

    /* Update for UnitDelay: '<S1024>/Unit Delay1' incorporates:
     *  Constant: '<S1024>/Constant4'
     */
    THMR_ac_DW.UnitDelay1_DSTATE_ds = true;

    /* Update for UnitDelay: '<S947>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_lr = VeTHMR_k_ElVlv3WayFuCellInt_MP;

    /* Update for UnitDelay: '<S965>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_jt = VeTHMR_k_ElVlv3WayFuCellReqBf;

    /* Update for UnitDelay: '<S55>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_a = VeTHMR_k_ElVlv3WayFuCellReqBf;

    /* Update for UnitDelay: '<S965>/Unit Delay1' incorporates:
     *  Constant: '<S955>/Calib'
     *  RelationalOperator: '<S945>/Relational Operator1'
     */
    THMR_ac_DW.UnitDelay1_DSTATE_ah = (KeTHMR_k_ElVlv3WayFuCellPIDMax_C <=
        rtb_MinMax7);

    /* Update for UnitDelay: '<S965>/Unit Delay2' incorporates:
     *  Constant: '<S956>/Calib'
     *  RelationalOperator: '<S945>/Relational Operator'
     */
    THMR_ac_DW.UnitDelay2_DSTATE_pd = (rtb_MinMax7 <=
        KeTHMR_k_ElVlv3WayFuCellPIDMin_C);

    /* Update for UnitDelay: '<S967>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_h = VeTHMR_T_CoFuCellHiTOutDelta;

    /* Update for UnitDelay: '<S967>/Unit Delay' incorporates:
     *  Constant: '<S967>/Constant1'
     */
    THMR_ac_DW.UnitDelay_DSTATE_kc = 1.0F;

    /* Update for UnitDelay: '<S968>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_ot = rtb_TmpSignalConversionAtVeT_ge;

    /* Update for UnitDelay: '<S968>/Unit Delay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_da = rtb_TmpSignalConversionAtVeP_jk;

    /* Update for UnitDelay: '<S968>/Unit Delay4' */
    THMR_ac_DW.UnitDelay4_DSTATE_o = rtb_TmpSignalConversionAtVeFCRR;

    /* Update for UnitDelay: '<S968>/Unit Delay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_mq = rtb_TmpSignalConversionAtVeTR_p;

    /* Update for UnitDelay: '<S968>/Unit Delay5' */
    THMR_ac_DW.UnitDelay5_DSTATE_o = rtb_TmpSignalConversionAtVePMIR;

    /* Update for UnitDelay: '<S968>/Unit Delay6' */
    THMR_ac_DW.UnitDelay6_DSTATE_i = rtb_TmpSignalConversionAtVeTRIR;

    /* Update for UnitDelay: '<S968>/Unit Delay7' */
    THMR_ac_DW.UnitDelay7_DSTATE = rtb_TmpSignalConversionAtVeTM_f;

    /* Update for UnitDelay: '<S968>/Unit Delay8' */
    THMR_ac_DW.UnitDelay8_DSTATE = rtb_TmpSignalConversionAtVeT_dg;

    /* Update for UnitDelay: '<S968>/Unit Delay9' */
    THMR_ac_DW.UnitDelay9_DSTATE = rtb_Product9;

    /* Update for UnitDelay: '<S968>/Unit Delay10' */
    THMR_ac_DW.UnitDelay10_DSTATE = rtb_UnitDelay9;

    /* Update for UnitDelay: '<S968>/Unit Delay12' */
    THMR_ac_DW.UnitDelay12_DSTATE = rtb_UnitDelay10;

    /* Update for UnitDelay: '<S968>/Unit Delay13' */
    THMR_ac_DW.UnitDelay13_DSTATE = rtb_UnitDelay12;

    /* Update for UnitDelay: '<S968>/Unit Delay11' */
    THMR_ac_DW.UnitDelay11_DSTATE = rtb_UnitDelay13;

    /* Update for UnitDelay: '<S968>/Unit Delay15' */
    THMR_ac_DW.UnitDelay15_DSTATE = rtb_UnitDelay11;

    /* Update for UnitDelay: '<S968>/Unit Delay16' */
    THMR_ac_DW.UnitDelay16_DSTATE = rtb_UnitDelay15;

    /* Update for UnitDelay: '<S968>/Unit Delay14' */
    THMR_ac_DW.UnitDelay14_DSTATE = rtb_TmpSignalConversionAtVeB_nb;

    /* Update for UnitDelay: '<S968>/Unit Delay18' */
    THMR_ac_DW.UnitDelay18_DSTATE = rtb_TmpSignalConversionAtVeCT_i;

    /* Update for UnitDelay: '<S968>/Unit Delay19' */
    THMR_ac_DW.UnitDelay19_DSTATE = rtb_TmpSignalConversionAtVeT_n0;

    /* Update for UnitDelay: '<S968>/Unit Delay17' */
    THMR_ac_DW.UnitDelay17_DSTATE = rtb_TmpSignalConversionAtVeBT_o;

    /* Update for UnitDelay: '<S981>/Unit Delay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_ec = VeTHMR_T_CoFuCellHiTInSpFil;

    /* Update for UnitDelay: '<S991>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_fp = rtb_TmpSignalConversionAtVePMPR;

    /* Update for UnitDelay: '<S991>/Unit Delay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_gx = rtb_TmpSignalConversionAtVeTAIR;

    /* Update for UnitDelay: '<S991>/Unit Delay4' */
    THMR_ac_DW.UnitDelay4_DSTATE_h = rtb_TmpSignalConversionAtVePM_l;

    /* Update for UnitDelay: '<S991>/Unit Delay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_j = rtb_Sum3;

    /* Update for UnitDelay: '<S991>/Unit Delay5' */
    THMR_ac_DW.UnitDelay5_DSTATE_h = rtb_Switch1_d;

    /* Update for UnitDelay: '<S991>/Unit Delay6' */
    THMR_ac_DW.UnitDelay6_DSTATE_h = Switch;

    /* Update for UnitDelay: '<S991>/Unit Delay7' */
    THMR_ac_DW.UnitDelay7_DSTATE_b = rtb_TmpSignalConversionAtVeTPDR;

    /* Update for UnitDelay: '<S991>/Unit Delay8' */
    THMR_ac_DW.UnitDelay8_DSTATE_j = rtb_TmpSignalConversionAtVeHT_h;

    /* Update for UnitDelay: '<S991>/Unit Delay9' */
    THMR_ac_DW.UnitDelay9_DSTATE_h = rtb_TmpSignalConversionAtVeT_j5;

    /* Update for UnitDelay: '<S991>/Unit Delay10' */
    THMR_ac_DW.UnitDelay10_DSTATE_l = rtb_Switch1_pi;

    /* Update for UnitDelay: '<S991>/Unit Delay12' */
    THMR_ac_DW.UnitDelay12_DSTATE_l = rtb_TmpSignalConversionAtVeHT_p;

    /* Update for UnitDelay: '<S991>/Unit Delay13' */
    THMR_ac_DW.UnitDelay13_DSTATE_n = rtb_TmpSignalConversionAtVeHT_o;

    /* Update for UnitDelay: '<S991>/Unit Delay11' */
    THMR_ac_DW.UnitDelay11_DSTATE_f = rtb_Switch1_giu;

    /* Update for UnitDelay: '<S991>/Unit Delay15' */
    THMR_ac_DW.UnitDelay15_DSTATE_l = rtb_Switch2_i1;

    /* Update for UnitDelay: '<S991>/Unit Delay16' */
    THMR_ac_DW.UnitDelay16_DSTATE_o = rtb_TmpSignalConversionAtVeHT_k;

    /* Update for UnitDelay: '<S991>/Unit Delay14' */
    THMR_ac_DW.UnitDelay14_DSTATE_i = Switch_o;

    /* Update for UnitDelay: '<S991>/Unit Delay18' */
    THMR_ac_DW.UnitDelay18_DSTATE_m = rtb_MinMax1_c;

    /* Update for UnitDelay: '<S991>/Unit Delay19' */
    THMR_ac_DW.UnitDelay19_DSTATE_d = rtb_Sum2_aq;

    /* Update for UnitDelay: '<S991>/Unit Delay17' */
    THMR_ac_DW.UnitDelay17_DSTATE_i = rtb_TmpSignalConversionAtVeTFTR;

    /* Update for UnitDelay: '<S950>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_j = rtb_TmpSignalConversionAtVeFC_k;

    /* Update for UnitDelay: '<S1057>/FixPt Unit Delay2' incorporates:
     *  Constant: '<S1057>/FixPt Constant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_p = 0U;

    /* Update for UnitDelay: '<S1057>/FixPt Unit Delay1' */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE_g = rtb_Product1_nd;

    /* Update for UnitDelay: '<S944>/Unit Delay6' */
    THMR_ac_DW.UnitDelay6_DSTATE_k = rtb_TmpSignalConversionAtVePMTR;

    /* Update for UnitDelay: '<S928>/Unit Delay' */
    THMR_ac_DW.UnitDelay_DSTATE_cs = rtb_TmpSignalConversionAtVeP_el;

    /* Update for UnitDelay: '<S928>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_hn = VeTHMR_k_WaPmpFuCellReq;

    /* Update for UnitDelay: '<S928>/Unit Delay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_a = VeTHMR_k_HiTFuCellWaPmpCtlReq;

    /* Update for UnitDelay: '<S928>/Unit Delay3' incorporates:
     *  Constant: '<S902>/Constant'
     *  Product: '<S902>/Product1'
     *  RelationalOperator: '<S902>/RelationalOperator2'
     */
    THMR_ac_DW.UnitDelay3_DSTATE_l2 = ((VeTHMR_T_WaFuCellPIDWaPmpRegRaw *
        rtb_TmpSignalConversionAtVeF_ob) > 0.0F);

    /* Update for UnitDelay: '<S930>/FixPt Unit Delay2' incorporates:
     *  Constant: '<S930>/FixPt Constant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_h = 0U;

    /* Update for UnitDelay: '<S930>/FixPt Unit Delay1' */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE_m = rtb_Switch3_l0;

    /* Update for UnitDelay: '<S957>/Unit Delay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_jn = VeTHMR_b_ElVlv3WayReqDetDec;

    /* Update for UnitDelay: '<S957>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_lf = rtb_TmpSignalConversionAtVeHTIR;

    /* Update for UnitDelay: '<S958>/Unit Delay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_ozu = VeTHMR_b_ElVlv3WayReqDetInc;

    /* Update for UnitDelay: '<S958>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_e = rtb_TmpSignalConversionAtVeTM_p;

    /* Update for UnitDelay: '<S946>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_jo = Switch1_e;

    /* Update for UnitDelay: '<S1091>/Unit Delay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_j = VeTHMR_k_ElVlv3WayFuCellPIDFlt;

    /* Update for UnitDelay: '<S1091>/Unit Delay1' incorporates:
     *  Constant: '<S1091>/Constant4'
     */
    THMR_ac_DW.UnitDelay1_DSTATE_e0 = true;

    /* Update for UnitDelay: '<S1063>/Unit Delay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_gi = VeTHMR_n_AirHiTReq_MP;

    /* Update for UnitDelay: '<S1064>/Unit Delay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_pg = VeTHMR_k_SpdAirHiTSysReqFlt;

    /* Update for UnitDelay: '<S1090>/Unit Delay2' incorporates:
     *  Constant: '<S1090>/Constant3'
     */
    THMR_ac_DW.UnitDelay2_DSTATE_f = true;

    /* Update for UnitDelay: '<S1090>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_at = VeTHMR_k_SpdAirHiTSysReqFlt;

    /* Update for UnitDelay: '<S1096>/FixPt Unit Delay2' incorporates:
     *  Constant: '<S1096>/FixPt Constant'
     */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_g = 0U;

    /* Update for UnitDelay: '<S1096>/FixPt Unit Delay1' */
    THMR_ac_DW.FixPtUnitDelay1_DSTATE_b = rtb_TmpSignalConversionAtVeCSVR;

    /* End of Outputs for SubSystem: '<S2>/FC_Loop' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
#endif

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Heater_Outputs'
     */
    /* Switch: '<S2202>/Switch1' incorporates:
     *  Constant: '<S2205>/Calib'
     *  Constant: '<S2208>/Calib'
     *  SignalConversion generated from: '<S2202>/VariantSource'
     *  Switch: '<S2201>/Switch1'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_ECH_ClntTempTgt_SelDial)
    {
        /* VariantMerge generated from: '<S2202>/VariantSource' incorporates:
         *  Constant: '<S2207>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_adzsu0cfjyeit0k =
            KeTHMR_T_ECH_ClntTempTgt_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S2202>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_adzsu0cfjyeit0k =
            THMR_ac_B.OutportBufferForECH_ClntTempTgt;
    }

    if (KeTHMR_b_ECH_HtrPwrTgt_SelDial)
    {
        /* VariantMerge generated from: '<S2201>/VariantSource' incorporates:
         *  Constant: '<S2203>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_d = KeTHMR_P_ECH_HtrPwrTgt_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S2201>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_d = THMR_ac_B.Merge1_g;
    }

#else

    /* VariantMerge generated from: '<S2202>/VariantSource' incorporates:
     *  Constant: '<S2206>/Calib'
     *  SignalConversion generated from: '<S2202>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_adzsu0cfjyeit0k =
        KeTHMR_Pct_HV_ElecClntHtr_Cmd_Dum4BSG;

#endif

    /* End of Switch: '<S2202>/Switch1' */

    /* Switch: '<S2215>/Switch1' incorporates:
     *  Constant: '<S2246>/Calib'
     *  SignalConversion generated from: '<S2201>/VariantSource'
     *  SignalConversion generated from: '<S2215>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_BattHtr_State_SelDial)
    {
        /* VariantMerge generated from: '<S2217>/VariantSource' incorporates:
         *  Constant: '<S2248>/Calib'
         */
        rtb_VariantMerge_For_Variant_ii = KeTHMR_e_BattHtr_StateDial;
    }
    else
    {
        /* VariantMerge generated from: '<S2217>/VariantSource' incorporates:
         *  DataTypeConversion: '<S4042>/DataTypeConversion'
         */
        rtb_VariantMerge_For_Variant_ii = VeTHMR_e_Htr1_State_B4SET;
    }

#else

    /* VariantMerge generated from: '<S2201>/VariantSource' incorporates:
     *  Constant: '<S2204>/Calib'
     *  SignalConversion generated from: '<S2201>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_d = KeTHMR_Pct_HV_ElecClntHtr_Sts_Dum4BSG;

    /* VariantMerge generated from: '<S2217>/VariantSource' incorporates:
     *  Constant: '<S2247>/Calib'
     *  SignalConversion generated from: '<S2215>/VariantSource'
     */
    rtb_VariantMerge_For_Variant_ii = KeTHMR_e_BattHtrState_Dum4BSG;

#endif

    /* End of Switch: '<S2215>/Switch1' */

    /* SignalConversion generated from: '<S2215>/VariantSource' incorporates:
     *  VariantMerge generated from: '<S2217>/VariantSource'
     */
    VeTHMR_e_Htr1_State = rtb_VariantMerge_For_Variant_ii;

    /* Switch: '<S2214>/Switch1' incorporates:
     *  Constant: '<S2243>/Calib'
     *  SignalConversion generated from: '<S2214>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_Htr2_State_SelDial)
    {
        /* VariantMerge generated from: '<S2217>/VariantSource' incorporates:
         *  Constant: '<S2245>/Calib'
         */
        rtb_VariantMerge_For_Variant_ii = KeTHMR_e_Htr2_StateDial;
    }
    else
    {
        /* VariantMerge generated from: '<S2217>/VariantSource' incorporates:
         *  DataTypeConversion: '<S4043>/DataTypeConversion'
         */
        rtb_VariantMerge_For_Variant_ii = VeTHMR_e_Htr2_State_B4SET;
    }

#else

    /* VariantMerge generated from: '<S2217>/VariantSource' incorporates:
     *  Constant: '<S2244>/Calib'
     *  SignalConversion generated from: '<S2214>/VariantSource'
     */
    rtb_VariantMerge_For_Variant_ii = KeTHMR_e_Htr2State_Dum4BSG;

#endif

    /* End of Switch: '<S2214>/Switch1' */

    /* SignalConversion generated from: '<S2214>/VariantSource' incorporates:
     *  VariantMerge generated from: '<S2217>/VariantSource'
     */
    VeTHMR_e_Htr2_State = rtb_VariantMerge_For_Variant_ii;

    /* Switch: '<S2228>/Switch1' incorporates:
     *  Constant: '<S2235>/Constant'
     *  RelationalOperator: '<S2231>/Comparison2'
     *  SignalConversion generated from: '<S2214>/VariantSource'
     */
    if (((uint32)VeTHMR_e_Htr2_State) == CeTHMR_e_HtrOn)
    {
        /* Switch: '<S2228>/Switch1' incorporates:
         *  Constant: '<S2241>/Constant'
         *  RelationalOperator: '<S2234>/Comparison2'
         *  S-Function (sfix_bitop): '<S2224>/FixPt Bitwise Operator1'
         *  SignalConversion generated from: '<S2215>/VariantSource'
         */
        iteration_count = (uint8)(((((uint32)VeTHMR_e_Htr1_State) ==
            CeTHMR_e_HtrOn) ? 1 : 0) | ((uint8)2));
    }
    else
    {
        /* Switch: '<S2228>/Switch1' incorporates:
         *  Constant: '<S2241>/Constant'
         *  RelationalOperator: '<S2234>/Comparison2'
         *  S-Function (sfix_bitop): '<S2220>/FixPt Bitwise Operator3'
         *  S-Function (sfix_bitop): '<S2220>/FixPt Bitwise Operator4'
         *  S-Function (sfix_bitop): '<S2220>/FixPt Bitwise Operator5'
         *  SignalConversion generated from: '<S2215>/VariantSource'
         */
        iteration_count = (uint8)(~((uint8)(((uint8)(~((uint8)((((uint32)
            VeTHMR_e_Htr1_State) == CeTHMR_e_HtrOn) ? 1 : 0)))) | ((uint8)2))));
    }

    /* End of Switch: '<S2228>/Switch1' */

    /* Switch: '<S2216>/Switch1' incorporates:
     *  Constant: '<S2249>/Calib'
     *  SignalConversion generated from: '<S2216>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_Htr3_State_SelDial)
    {
        /* VariantMerge generated from: '<S2217>/VariantSource' incorporates:
         *  Constant: '<S2251>/Calib'
         */
        rtb_VariantMerge_For_Variant_ii = KeTHMR_e_Htr3_StateDial;
    }
    else
    {
        /* VariantMerge generated from: '<S2217>/VariantSource' incorporates:
         *  DataTypeConversion: '<S4044>/DataTypeConversion'
         */
        rtb_VariantMerge_For_Variant_ii = VeTHMR_e_Htr3_State_B4SET;
    }

#else

    /* VariantMerge generated from: '<S2217>/VariantSource' incorporates:
     *  Constant: '<S2250>/Calib'
     *  SignalConversion generated from: '<S2216>/VariantSource'
     */
    rtb_VariantMerge_For_Variant_ii = KeTHMR_e_Htr3State_Dum4BSG;

#endif

    /* End of Switch: '<S2216>/Switch1' */

    /* SignalConversion generated from: '<S2216>/VariantSource' incorporates:
     *  VariantMerge generated from: '<S2217>/VariantSource'
     */
    VeTHMR_e_Htr3_State = rtb_VariantMerge_For_Variant_ii;

    /* Switch: '<S2229>/Switch1' incorporates:
     *  Constant: '<S2237>/Constant'
     *  RelationalOperator: '<S2232>/Comparison2'
     *  SignalConversion generated from: '<S2216>/VariantSource'
     */
    if (((uint32)VeTHMR_e_Htr3_State) == CeTHMR_e_HtrOn)
    {
        /* Switch: '<S2229>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S2225>/FixPt Bitwise Operator1'
         */
        iteration_count |= (uint8)4;
    }
    else
    {
        /* Switch: '<S2229>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S2221>/FixPt Bitwise Operator3'
         *  S-Function (sfix_bitop): '<S2221>/FixPt Bitwise Operator4'
         *  S-Function (sfix_bitop): '<S2221>/FixPt Bitwise Operator5'
         */
        iteration_count = (uint8)(~((uint8)(((uint8)(~iteration_count)) |
            ((uint8)4))));
    }

    /* End of Switch: '<S2229>/Switch1' */

    /* Switch: '<S2217>/Switch1' incorporates:
     *  Constant: '<S2252>/Calib'
     *  SignalConversion generated from: '<S2217>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_Htr4_State_SelDial)
    {
        /* VariantMerge generated from: '<S2217>/VariantSource' incorporates:
         *  Constant: '<S2254>/Calib'
         */
        rtb_VariantMerge_For_Variant_ii = KeTHMR_e_Htr4_StateDial;
    }
    else
    {
        /* VariantMerge generated from: '<S2217>/VariantSource' incorporates:
         *  DataTypeConversion: '<S4045>/DataTypeConversion'
         */
        rtb_VariantMerge_For_Variant_ii = VeTHMR_e_Htr4_State_B4SET;
    }

#else

    /* VariantMerge generated from: '<S2217>/VariantSource' incorporates:
     *  Constant: '<S2253>/Calib'
     *  SignalConversion generated from: '<S2217>/VariantSource'
     */
    rtb_VariantMerge_For_Variant_ii = KeTHMR_e_Htr4State_Dum4BSG;

#endif

    /* End of Switch: '<S2217>/Switch1' */

    /* SignalConversion generated from: '<S2217>/VariantSource' incorporates:
     *  VariantMerge generated from: '<S2217>/VariantSource'
     */
    VeTHMR_e_Htr4_State = rtb_VariantMerge_For_Variant_ii;

    /* Switch: '<S2230>/Switch1' incorporates:
     *  Constant: '<S2239>/Constant'
     *  RelationalOperator: '<S2233>/Comparison2'
     *  SignalConversion generated from: '<S2217>/VariantSource'
     */
    if (((uint32)VeTHMR_e_Htr4_State) == CeTHMR_e_HtrOn)
    {
        /* Switch: '<S2230>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S2226>/FixPt Bitwise Operator1'
         */
        iteration_count |= (uint8)8;
    }
    else
    {
        /* Switch: '<S2230>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S2222>/FixPt Bitwise Operator3'
         *  S-Function (sfix_bitop): '<S2222>/FixPt Bitwise Operator4'
         *  S-Function (sfix_bitop): '<S2222>/FixPt Bitwise Operator5'
         */
        iteration_count = (uint8)(~((uint8)(((uint8)(~iteration_count)) |
            ((uint8)8))));
    }

    /* End of Switch: '<S2230>/Switch1' */

    /* Switch: '<S2264>/Switch1' incorporates:
     *  Constant: '<S2210>/Calib'
     */
    if (KeTHMR_b_Htr2_Slctn_State)
    {
        /* Switch: '<S2264>/Switch1' incorporates:
         *  Constant: '<S2209>/Calib'
         *  S-Function (sfix_bitop): '<S2260>/FixPt Bitwise Operator1'
         *  Switch: '<S2263>/Switch1'
         */
        rtb_Switch1_ev = (uint8)((KeTHMR_b_Htr1_Slctn_State ? ((uint8)1) :
            ((uint8)0)) | ((uint8)2));
    }
    else
    {
        /* Switch: '<S2264>/Switch1' incorporates:
         *  Constant: '<S2209>/Calib'
         *  S-Function (sfix_bitop): '<S2256>/FixPt Bitwise Operator3'
         *  S-Function (sfix_bitop): '<S2256>/FixPt Bitwise Operator4'
         *  S-Function (sfix_bitop): '<S2256>/FixPt Bitwise Operator5'
         *  Switch: '<S2263>/Switch1'
         */
        rtb_Switch1_ev = (uint8)(~((uint8)(((uint8)(~((uint8)
            (KeTHMR_b_Htr1_Slctn_State ? ((uint8)1) : ((uint8)0))))) | ((uint8)2))));
    }

    /* End of Switch: '<S2264>/Switch1' */

    /* Switch: '<S2265>/Switch1' incorporates:
     *  Constant: '<S2211>/Calib'
     */
    if (KeTHMR_b_Htr3_Slctn_State)
    {
        /* Switch: '<S2265>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S2261>/FixPt Bitwise Operator1'
         */
        rtb_Switch1_ev |= (uint8)4;
    }
    else
    {
        /* Switch: '<S2265>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S2257>/FixPt Bitwise Operator3'
         *  S-Function (sfix_bitop): '<S2257>/FixPt Bitwise Operator4'
         *  S-Function (sfix_bitop): '<S2257>/FixPt Bitwise Operator5'
         */
        rtb_Switch1_ev = (uint8)(~((uint8)(((uint8)(~rtb_Switch1_ev)) | ((uint8)
            4))));
    }

    /* End of Switch: '<S2265>/Switch1' */

    /* Switch: '<S2266>/Switch1' incorporates:
     *  Constant: '<S2212>/Calib'
     */
    if (KeTHMR_b_Htr4_Slctn_State)
    {
        /* Switch: '<S2266>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S2262>/FixPt Bitwise Operator1'
         */
        rtb_Switch1_ev |= (uint8)8;
    }
    else
    {
        /* Switch: '<S2266>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S2258>/FixPt Bitwise Operator3'
         *  S-Function (sfix_bitop): '<S2258>/FixPt Bitwise Operator4'
         *  S-Function (sfix_bitop): '<S2258>/FixPt Bitwise Operator5'
         */
        rtb_Switch1_ev = (uint8)(~((uint8)(((uint8)(~rtb_Switch1_ev)) | ((uint8)
            8))));
    }

    /* End of Switch: '<S2266>/Switch1' */

    /* Switch: '<S2178>/Switch1' incorporates:
     *  Constant: '<S2181>/Calib'
     *  Constant: '<S2184>/Calib'
     *  SignalConversion generated from: '<S2178>/VariantSource'
     *  Switch: '<S2177>/Switch1'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_Htr2ClntTempTgt_SelDial)
    {
        /* VariantMerge generated from: '<S2178>/VariantSource' incorporates:
         *  Constant: '<S2183>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_a = KeTHMR_T_Htr2ClntTempTgt_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S2178>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_a = THMR_ac_B.OutportBufferForHtr2_ClntTempTg;
    }

    if (KeTHMR_b_Htr2PwrTgt_SelDial)
    {
        /* VariantMerge generated from: '<S2177>/VariantSource' incorporates:
         *  Constant: '<S2179>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_f = KeTHMR_P_Htr2PwrTgt_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S2177>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_f = THMR_ac_B.Merge1_b;
    }

#else

    /* VariantMerge generated from: '<S2178>/VariantSource' incorporates:
     *  Constant: '<S2182>/Calib'
     *  SignalConversion generated from: '<S2178>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_a = KeTHMR_Pct_HV_ElecClntHtr2_Cmd_Dum4BSG;

#endif

    /* End of Switch: '<S2178>/Switch1' */

    /* Switch: '<S2186>/Switch1' incorporates:
     *  Constant: '<S2192>/Calib'
     *  SignalConversion generated from: '<S2177>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_Htr3ClntTempTgt_SelDial)
    {
        /* VariantMerge generated from: '<S2186>/VariantSource' incorporates:
         *  Constant: '<S2191>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_j = KeTHMR_T_Htr3ClntTempTgt_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S2186>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_j = THMR_ac_B.OutportBufferForHtr3_ClntTempTg;
    }

#else

    /* VariantMerge generated from: '<S2177>/VariantSource' incorporates:
     *  Constant: '<S2180>/Calib'
     *  SignalConversion generated from: '<S2177>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_f = KeTHMR_Pct_HV_ElecClntHtr2_Sts_Dum4BSG;

#endif

    /* End of Switch: '<S2186>/Switch1' */

    /* Switch: '<S2185>/Switch1' incorporates:
     *  Constant: '<S2189>/Calib'
     *  SignalConversion generated from: '<S2186>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_Htr3PwrTgt_SelDial)
    {
        /* VariantMerge generated from: '<S2185>/VariantSource' incorporates:
         *  Constant: '<S2187>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_jk = KeTHMR_P_Htr3PwrTgt_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S2185>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_jk = THMR_ac_B.Merge1_c;
    }

#else

    /* VariantMerge generated from: '<S2186>/VariantSource' incorporates:
     *  Constant: '<S2190>/Calib'
     *  SignalConversion generated from: '<S2186>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_j = KeTHMR_Pct_HV_ElecClntHtr3_Cmd_Dum4BSG;

#endif

    /* End of Switch: '<S2185>/Switch1' */

    /* Switch: '<S2194>/Switch1' incorporates:
     *  Constant: '<S2200>/Calib'
     *  SignalConversion generated from: '<S2185>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_Htr4ClntTempTgt_SelDial)
    {
        /* VariantMerge generated from: '<S2194>/VariantSource' incorporates:
         *  Constant: '<S2199>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_o = KeTHMR_T_Htr4ClntTempTgt_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S2194>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_o = THMR_ac_B.OutportBufferForHtr4_ClntTempTg;
    }

#else

    /* VariantMerge generated from: '<S2185>/VariantSource' incorporates:
     *  Constant: '<S2188>/Calib'
     *  SignalConversion generated from: '<S2185>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_jk = KeTHMR_Pct_HV_ElecClntHtr3_Sts_Dum4BSG;

#endif

    /* End of Switch: '<S2194>/Switch1' */

    /* Switch: '<S2193>/Switch1' incorporates:
     *  Constant: '<S2197>/Calib'
     *  SignalConversion generated from: '<S2194>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_Htr4PwrTgt_SelDial)
    {
        /* VariantMerge generated from: '<S2193>/VariantSource' incorporates:
         *  Constant: '<S2195>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_b = KeTHMR_P_Htr4PwrTgt_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S2193>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_b = THMR_ac_B.Merge1_k;
    }

#else

    /* VariantMerge generated from: '<S2194>/VariantSource' incorporates:
     *  Constant: '<S2198>/Calib'
     *  SignalConversion generated from: '<S2194>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_o = KeTHMR_Pct_HV_ElecClntHtr4_Cmd_Dum4BSG;

#endif

    /* End of Switch: '<S2193>/Switch1' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Pump_Command'
     */
    /* Switch: '<S3667>/Switch1' incorporates:
     *  Constant: '<S3672>/Calib'
     *  SignalConversion generated from: '<S2193>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_LT_ActvPmpCmd_SelDial)
    {
        /* VariantMerge generated from: '<S3667>/VariantSource' incorporates:
         *  Constant: '<S3673>/Calib'
         */
        THMR_ac_B.VariantMerge_For_Var_adzsu0cfjy = KeTHMR_dV_LT_ActvPmpCmd_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S3667>/VariantSource' */
        THMR_ac_B.VariantMerge_For_Var_adzsu0cfjy =
            rtb_TmpSignalConversionAtVeTP_i;
    }

#else

    /* Outputs for Function Call SubSystem: '<S2>/Heater_Outputs' */
    /* VariantMerge generated from: '<S2193>/VariantSource' incorporates:
     *  Constant: '<S2196>/Calib'
     *  SignalConversion generated from: '<S2193>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_b = KeTHMR_Pct_HV_ElecClntHtr4_Sts_Dum4BSG;

#endif

    /* End of Switch: '<S3667>/Switch1' */

    /* Switch: '<S3679>/Switch1' incorporates:
     *  Constant: '<S3681>/Calib'
     *  SignalConversion generated from: '<S3667>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_LT_PsvPmpCmd_SelDial)
    {
        /* VariantMerge generated from: '<S3679>/VariantSource' incorporates:
         *  Constant: '<S3682>/Calib'
         */
        THMR_ac_B.VariantMerge_For_Va_adzsu0cfjye = KeTHMR_dV_LT_PsvPmpCmd_Dial;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S2>/LTCL' */
        /* VariantMerge generated from: '<S3679>/VariantSource' incorporates:
         *  Gain: '<S2923>/Gain'
         */
        THMR_ac_B.VariantMerge_For_Va_adzsu0cfjye = rtb_Switch1_muc;

        /* End of Outputs for SubSystem: '<S2>/LTCL' */
    }

#else

    /* VariantMerge generated from: '<S3667>/VariantSource' incorporates:
     *  Constant: '<S3674>/Calib'
     *  SignalConversion generated from: '<S3667>/VariantSource'
     */
    THMR_ac_B.VariantMerge_For_Var_adzsu0cfjy = KeTHMR_n_LT_ActvPmpCmd_Dum4BSG;

#endif

    /* End of Switch: '<S3679>/Switch1' */

    /* Switch: '<S3680>/Switch1' incorporates:
     *  Constant: '<S3684>/Calib'
     *  SignalConversion generated from: '<S3679>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_LT_PsvPmp2Cmd_SelDial)
    {
        /* VariantMerge generated from: '<S3680>/VariantSource' incorporates:
         *  Constant: '<S3685>/Calib'
         */
        THMR_ac_B.VariantMerge_For_V_adzsu0cfjyei = KeTHMR_dV_LT_PsvPmp2Cmd_Dial;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S2>/LTCL' */
        /* VariantMerge generated from: '<S3680>/VariantSource' incorporates:
         *  Gain: '<S2924>/Gain'
         */
        THMR_ac_B.VariantMerge_For_V_adzsu0cfjyei = rtb_Switch1_pm;

        /* End of Outputs for SubSystem: '<S2>/LTCL' */
    }

#else

    /* VariantMerge generated from: '<S3679>/VariantSource' incorporates:
     *  Constant: '<S3683>/Calib'
     *  SignalConversion generated from: '<S3679>/VariantSource'
     */
    THMR_ac_B.VariantMerge_For_Va_adzsu0cfjye = KeTHMR_n_LT_PsvPmpCmd_Dum4BSG;

#endif

    /* End of Switch: '<S3680>/Switch1' */

    /* Switch: '<S3675>/Switch1' incorporates:
     *  Constant: '<S3676>/Calib'
     *  SignalConversion generated from: '<S3680>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_HT_AuxPmpCmd_SelDial)
    {
        /* VariantMerge generated from: '<S3675>/VariantSource' incorporates:
         *  Constant: '<S3677>/Calib'
         */
        THMR_ac_B.VariantMerge_For__adzsu0cfjyeit = KeTHMR_dV_HT_AuxPmpCmd_Dial;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S2>/HTCL' */
        /* VariantMerge generated from: '<S3675>/VariantSource' incorporates:
         *  Gain: '<S1172>/Gain'
         */
        THMR_ac_B.VariantMerge_For__adzsu0cfjyeit =
            rtb_TmpSignalConversionAtVeTPCR;

        /* End of Outputs for SubSystem: '<S2>/HTCL' */
    }

#else

    /* VariantMerge generated from: '<S3680>/VariantSource' incorporates:
     *  Constant: '<S3686>/Calib'
     *  SignalConversion generated from: '<S3680>/VariantSource'
     */
    THMR_ac_B.VariantMerge_For_V_adzsu0cfjyei = KeTHMR_n_LT_PsvPmp2Cmd_Dum4BSG;

#endif

    /* End of Switch: '<S3675>/Switch1' */

    /* Switch: '<S3689>/Switch' incorporates:
     *  Constant: '<S3718>/Calib'
     *  SignalConversion generated from: '<S3675>/VariantSource'
     *  SignalConversion generated from: '<S3689>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_LTPsvPump_OprtngSt_SD)
    {
        /* VariantMerge generated from: '<S3692>/VariantSource' incorporates:
         *  Constant: '<S3719>/Calib'
         */
        rtb_VariantMerge_For_Variant__i = KeTHMR_e_LTPsvPump_OprtngSt_D;
    }
    else
    {
        /* VariantMerge generated from: '<S3692>/VariantSource' */
        rtb_VariantMerge_For_Variant__i = THMR_ac_B.VeTHMR_e_LTPsvPmp_OpState;
    }

#else

    /* VariantMerge generated from: '<S3675>/VariantSource' incorporates:
     *  Constant: '<S3678>/Calib'
     *  SignalConversion generated from: '<S3675>/VariantSource'
     */
    THMR_ac_B.VariantMerge_For__adzsu0cfjyeit = KeTHMR_n_HT_AuxPmpCmd_Dum4BSG;

    /* VariantMerge generated from: '<S3692>/VariantSource' incorporates:
     *  Constant: '<S3720>/Calib'
     *  SignalConversion generated from: '<S3689>/VariantSource'
     */
    rtb_VariantMerge_For_Variant__i = KeTHMR_e_LTPsvPump_OprtngSt_Dum4BSG;

#endif

    /* End of Switch: '<S3689>/Switch' */

    /* SignalConversion generated from: '<S3689>/VariantSource' incorporates:
     *  VariantMerge generated from: '<S3692>/VariantSource'
     */
    VeTHMR_e_LTPsvPmp_Op_State = rtb_VariantMerge_For_Variant__i;

    /* Switch: '<S3690>/Switch' incorporates:
     *  Constant: '<S3721>/Calib'
     *  SignalConversion generated from: '<S3690>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_LTPsvPump2_OprtngSt_SD)
    {
        /* VariantMerge generated from: '<S3692>/VariantSource' incorporates:
         *  Constant: '<S3722>/Calib'
         */
        rtb_VariantMerge_For_Variant__i = KeTHMR_e_LTPsvPump2_OprtngSt_D;
    }
    else
    {
        /* VariantMerge generated from: '<S3692>/VariantSource' */
        rtb_VariantMerge_For_Variant__i = THMR_ac_B.VeTHMR_e_LTPsvPmp2_OpState;
    }

#else

    /* VariantMerge generated from: '<S3692>/VariantSource' incorporates:
     *  Constant: '<S3723>/Calib'
     *  SignalConversion generated from: '<S3690>/VariantSource'
     */
    rtb_VariantMerge_For_Variant__i = KeTHMR_e_LTPsvPump2_OprtngSt_Dum4BSG;

#endif

    /* End of Switch: '<S3690>/Switch' */

    /* SignalConversion generated from: '<S3690>/VariantSource' incorporates:
     *  VariantMerge generated from: '<S3692>/VariantSource'
     */
    VeTHMR_e_LTPsvPmp2_Op_State = rtb_VariantMerge_For_Variant__i;

    /* Switch: '<S3691>/Switch' incorporates:
     *  Constant: '<S3724>/Calib'
     *  SignalConversion generated from: '<S3691>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_LTActPump_OprtngSt_SD)
    {
        /* VariantMerge generated from: '<S3692>/VariantSource' incorporates:
         *  Constant: '<S3726>/Calib'
         */
        rtb_VariantMerge_For_Variant__i = KeTHMR_e_LTActPump_OprtrngSt_D;
    }
    else
    {
        /* VariantMerge generated from: '<S3692>/VariantSource' */
        rtb_VariantMerge_For_Variant__i = THMR_ac_B.VeTHMR_e_LTActPmp_OpState;
    }

#else

    /* VariantMerge generated from: '<S3692>/VariantSource' incorporates:
     *  Constant: '<S3725>/Calib'
     *  SignalConversion generated from: '<S3691>/VariantSource'
     */
    rtb_VariantMerge_For_Variant__i = KeTHMR_e_LTActPump_OprtngSt_Dum4BSG;

#endif

    /* End of Switch: '<S3691>/Switch' */

    /* SignalConversion generated from: '<S3691>/VariantSource' incorporates:
     *  VariantMerge generated from: '<S3692>/VariantSource'
     */
    VeTHMR_e_LTActPmp_Op_State = rtb_VariantMerge_For_Variant__i;

    /* Switch: '<S3692>/Switch' incorporates:
     *  Constant: '<S3727>/Calib'
     *  SignalConversion generated from: '<S3692>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_HTAuxPump_OprtngSt_SD)
    {
        /* VariantMerge generated from: '<S3692>/VariantSource' incorporates:
         *  Constant: '<S3728>/Calib'
         */
        rtb_VariantMerge_For_Variant__i = KeTHMR_e_HTAuxPump_OprtngSt_D;
    }
    else
    {
        /* VariantMerge generated from: '<S3692>/VariantSource' */
        rtb_VariantMerge_For_Variant__i = THMR_ac_B.VeTHMR_e_HTAuxPmp_OpState;
    }

#else

    /* VariantMerge generated from: '<S3692>/VariantSource' incorporates:
     *  Constant: '<S3729>/Calib'
     *  SignalConversion generated from: '<S3692>/VariantSource'
     */
    rtb_VariantMerge_For_Variant__i = KeTHMR_e_HTAuxPump_OprtngSt_Dum4BSG;

#endif

    /* End of Switch: '<S3692>/Switch' */

    /* SignalConversion generated from: '<S3692>/VariantSource' incorporates:
     *  VariantMerge generated from: '<S3692>/VariantSource'
     */
    VeTHMR_e_HTAuxPmp_Op_State = rtb_VariantMerge_For_Variant__i;

    /* Switch: '<S3715>/Switch1' incorporates:
     *  Constant: '<S3700>/Constant'
     *  RelationalOperator: '<S3695>/Comparison4'
     *  SignalConversion generated from: '<S3690>/VariantSource'
     */
    if (((uint32)VeTHMR_e_LTPsvPmp2_Op_State) == CeTHMR_e_PumpOn)
    {
        /* Switch: '<S3715>/Switch1' incorporates:
         *  Constant: '<S3698>/Constant'
         *  RelationalOperator: '<S3694>/Comparison4'
         *  S-Function (sfix_bitop): '<S3711>/FixPt Bitwise Operator1'
         *  SignalConversion generated from: '<S3689>/VariantSource'
         */
        rtb_Switch1_cw = (uint8)(((((uint32)VeTHMR_e_LTPsvPmp_Op_State) ==
            CeTHMR_e_PumpOn) ? 1 : 0) | ((uint8)2));
    }
    else
    {
        /* Switch: '<S3715>/Switch1' incorporates:
         *  Constant: '<S3698>/Constant'
         *  RelationalOperator: '<S3694>/Comparison4'
         *  S-Function (sfix_bitop): '<S3707>/FixPt Bitwise Operator3'
         *  S-Function (sfix_bitop): '<S3707>/FixPt Bitwise Operator4'
         *  S-Function (sfix_bitop): '<S3707>/FixPt Bitwise Operator5'
         *  SignalConversion generated from: '<S3689>/VariantSource'
         */
        rtb_Switch1_cw = (uint8)(~((uint8)(((uint8)(~((uint8)((((uint32)
            VeTHMR_e_LTPsvPmp_Op_State) == CeTHMR_e_PumpOn) ? 1 : 0)))) |
            ((uint8)2))));
    }

    /* End of Switch: '<S3715>/Switch1' */

    /* Switch: '<S3716>/Switch1' incorporates:
     *  Constant: '<S3702>/Constant'
     *  RelationalOperator: '<S3696>/Comparison4'
     *  SignalConversion generated from: '<S3691>/VariantSource'
     */
    if (((uint32)VeTHMR_e_LTActPmp_Op_State) == CeTHMR_e_PumpOn)
    {
        /* Switch: '<S3716>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S3712>/FixPt Bitwise Operator1'
         */
        rtb_Switch1_cw |= (uint8)4;
    }
    else
    {
        /* Switch: '<S3716>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S3708>/FixPt Bitwise Operator3'
         *  S-Function (sfix_bitop): '<S3708>/FixPt Bitwise Operator4'
         *  S-Function (sfix_bitop): '<S3708>/FixPt Bitwise Operator5'
         */
        rtb_Switch1_cw = (uint8)(~((uint8)(((uint8)(~rtb_Switch1_cw)) | ((uint8)
            4))));
    }

    /* End of Switch: '<S3716>/Switch1' */

    /* Switch: '<S3717>/Switch1' incorporates:
     *  Constant: '<S3704>/Constant'
     *  RelationalOperator: '<S3697>/Comparison4'
     *  SignalConversion generated from: '<S3692>/VariantSource'
     */
    if (((uint32)VeTHMR_e_HTAuxPmp_Op_State) == CeTHMR_e_PumpOn)
    {
        /* Switch: '<S3717>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S3713>/FixPt Bitwise Operator1'
         */
        rtb_Switch1_cw |= (uint8)8;
    }
    else
    {
        /* Switch: '<S3717>/Switch1' incorporates:
         *  S-Function (sfix_bitop): '<S3709>/FixPt Bitwise Operator3'
         *  S-Function (sfix_bitop): '<S3709>/FixPt Bitwise Operator4'
         *  S-Function (sfix_bitop): '<S3709>/FixPt Bitwise Operator5'
         */
        rtb_Switch1_cw = (uint8)(~((uint8)(((uint8)(~rtb_Switch1_cw)) | ((uint8)
            8))));
    }

    /* End of Switch: '<S3717>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Valve_command'
     */
    /* Switch: '<S3731>/Switch' incorporates:
     *  Constant: '<S3732>/Calib'
     *  Constant: '<S5655>/Calib'
     *  SignalConversion generated from: '<S3731>/VariantSource'
     *  Switch: '<S1159>/Switch2'
     *  Switch: '<S5643>/Switch1'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_LTR_Flw_SD)
    {
        /* VariantMerge generated from: '<S3731>/VariantSource' incorporates:
         *  Constant: '<S3733>/Calib'
         */
        THMR_ac_B.VariantMerge_For_adzsu0cfjyeit0 = KeTHMR_dV_LTR_Flw_D;
    }
    else
    {
        /* VariantMerge generated from: '<S3731>/VariantSource' */
        THMR_ac_B.VariantMerge_For_adzsu0cfjyeit0 = rtb_Add4_m1;
    }

    if (KeTHMR_b_HT_CabVlvCmd_SelDial)
    {
        /* VariantMerge generated from: '<S5643>/VariantSource' incorporates:
         *  Constant: '<S5653>/Calib'
         */
        THMR_ac_B.VariantMerge_For_Varia_adzsu0cf = KeTHMR_Pct_HT_CabVlvCmd_Dial;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S2>/HTCL' */
        if (THMR_ac_B.Logical7_l)
        {
            /* Switch: '<S1159>/Switch2' incorporates:
             *  VariantMerge generated from: '<S5643>/VariantSource'
             */
            THMR_ac_B.VariantMerge_For_Varia_adzsu0cf = THMR_ac_B.HTCV_Pos;
        }
        else
        {
            /* VariantMerge generated from: '<S5643>/VariantSource' incorporates:
             *  Switch: '<S1159>/Switch2'
             */
            THMR_ac_B.VariantMerge_For_Varia_adzsu0cf =
                VeTHMR_Pct_ClntProp3WyVlv_Cmd_Raw;
        }

        /* End of Outputs for SubSystem: '<S2>/HTCL' */
    }

#else

    /* VariantMerge generated from: '<S3731>/VariantSource' incorporates:
     *  Constant: '<S3734>/Calib'
     *  SignalConversion generated from: '<S3731>/VariantSource'
     */
    THMR_ac_B.VariantMerge_For_adzsu0cfjyeit0 = KeTHMR_dV_LTR_Flw_Dum4BSG;

#endif

    /* End of Switch: '<S3731>/Switch' */

    /* Switch: '<S5644>/Switch1' incorporates:
     *  Constant: '<S5658>/Calib'
     *  SignalConversion generated from: '<S5643>/VariantSource'
     *  SignalConversion generated from: '<S5644>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_HT_Shtoff_VlvCmd_SelDial)
    {
        /* VariantMerge generated from: '<S5644>/VariantSource' incorporates:
         *  Constant: '<S5656>/Calib'
         */
        rtb_VariantMerge_For_Variant__o = KeTHMR_b_HT_Shtoff_VlvCmd_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S5644>/VariantSource' */
        rtb_VariantMerge_For_Variant__o = rtb_VariantMerge_For_Variant_ik;
    }

#else

    /* VariantMerge generated from: '<S5643>/VariantSource' incorporates:
     *  Constant: '<S5654>/Calib'
     *  SignalConversion generated from: '<S5643>/VariantSource'
     */
    THMR_ac_B.VariantMerge_For_Varia_adzsu0cf = KeTHMR_Pct_HT_CabVlvCmd_Dum4BSG;

    /* VariantMerge generated from: '<S5644>/VariantSource' incorporates:
     *  Constant: '<S5657>/Calib'
     *  SignalConversion generated from: '<S5644>/VariantSource'
     */
    rtb_VariantMerge_For_Variant__o = KeTHMR_b_HT_Shtoff_VlvCmd_Dum4BSG;

#endif

    /* End of Switch: '<S5644>/Switch1' */

    /* SignalConversion generated from: '<S5644>/VariantSource' */
    VeTHMR_b_HT_Shtoff_VlvCmd = rtb_VariantMerge_For_Variant__o;

    /* Switch: '<S5642>/Switch1' incorporates:
     *  Constant: '<S5650>/Calib'
     *  Constant: '<S5659>/Calib'
     *  SignalConversion generated from: '<S5642>/VariantSource'
     *  Switch: '<S5645>/Switch1'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_ClntNProp3WyVlv_State_SelDial)
    {
        /* VariantMerge generated from: '<S5642>/VariantSource' incorporates:
         *  Constant: '<S5651>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_pz = KeTHMR_e_ClntNProp3WyVlv_State_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S5642>/VariantSource' incorporates:
         *  Switch: '<S559>/Switch1'
         */
        THMR_ac_B.VariantMerge_Fo_pz = THMR_ac_B.Switch1_jj;
    }

    if (KeTHMR_b_ClntProp3WyVlv_State_SelDial)
    {
        /* VariantMerge generated from: '<S5645>/VariantSource' incorporates:
         *  Constant: '<S5660>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_aa = KeTHMR_e_ClntProp3WyVlv_State_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S5645>/VariantSource' incorporates:
         *  Switch: '<S584>/Switch1'
         */
        THMR_ac_B.VariantMerge_Fo_aa = THMR_ac_B.Switch1_bm;
    }

#else

    /* VariantMerge generated from: '<S5642>/VariantSource' incorporates:
     *  Constant: '<S5652>/Calib'
     *  SignalConversion generated from: '<S5642>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_pz = KeTHMR_e_ClntNProp3WyVlv_State_Dum4BSG;

#endif

    /* End of Switch: '<S5642>/Switch1' */

    /* Switch: '<S5647>/Switch1' incorporates:
     *  Constant: '<S5666>/Calib'
     *  SignalConversion generated from: '<S5645>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_LINPrplVlv_Cmd_SD)
    {
        /* VariantMerge generated from: '<S5647>/VariantSource' incorporates:
         *  Constant: '<S5664>/Calib'
         */
        THMR_ac_B.VariantMerge_For_Vari_adzsu0cfj = KeTHMR_Pct_LINPrplVlv_Cmd_D;
    }
    else
    {
        /* VariantMerge generated from: '<S5647>/VariantSource' */
        THMR_ac_B.VariantMerge_For_Vari_adzsu0cfj = VeTHMR_Pct_BattCPV_PosReq;
    }

#else

    /* VariantMerge generated from: '<S5645>/VariantSource' incorporates:
     *  Constant: '<S5661>/Calib'
     *  SignalConversion generated from: '<S5645>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_aa = KeTHMR_e_ClntProp3WyVlv_State_Dum4BSG;

#endif

    /* End of Switch: '<S5647>/Switch1' */

    /* Switch: '<S5648>/Switch1' incorporates:
     *  Constant: '<S5669>/Calib'
     *  SignalConversion generated from: '<S5647>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_LINPrplVlv_CalibReq_SD)
    {
        /* VariantMerge generated from: '<S5648>/VariantSource' incorporates:
         *  Constant: '<S5667>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_e = KeTHMR_b_LINPrplVlv_CalibReq_D;
    }
    else
    {
        /* VariantMerge generated from: '<S5648>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_e = THMR_ac_B.OutportBufferForLINVlvCalibr_Re;
    }

#else

    /* VariantMerge generated from: '<S5647>/VariantSource' incorporates:
     *  Constant: '<S5665>/Calib'
     *  SignalConversion generated from: '<S5647>/VariantSource'
     */
    THMR_ac_B.VariantMerge_For_Vari_adzsu0cfj =
        KeTHMR_Pct_LINPrplVlv_Cmd_Dum4BSG;

#endif

    /* End of Switch: '<S5648>/Switch1' */

    /* Switch: '<S5649>/Switch1' incorporates:
     *  Constant: '<S5672>/Calib'
     *  SignalConversion generated from: '<S5648>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_LINPrplVlv_SvReq_SD)
    {
        /* VariantMerge generated from: '<S5649>/VariantSource' incorporates:
         *  Constant: '<S5670>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_g = KeTHMR_b_LINPrplVlv_SvReq_D;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S2>/LTCL' */
        /* VariantMerge generated from: '<S5649>/VariantSource' incorporates:
         *  Constant: '<S2388>/Constant'
         *  Constant: '<S2389>/Calib'
         *  Logic: '<S2320>/Logical'
         *  Logic: '<S2320>/Logical1'
         *  Logic: '<S2320>/Logical2'
         *  RelationalOperator: '<S2320>/Comparison4'
         *  RelationalOperator: '<S2869>/RelationalOperator'
         *  Switch: '<S3945>/Switch'
         */
        THMR_ac_B.VariantMerge_Fo_g = (((((uint32)VeTHMR_e_SSDR_KeySts) ==
            CeSSDR_e_KeyOff) && (!THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i)) ||
            (KeTHMR_b_LINPrpVlv_SvCmndChk_Ovrd));

        /* End of Outputs for SubSystem: '<S2>/LTCL' */
    }

#else

    /* VariantMerge generated from: '<S5648>/VariantSource' incorporates:
     *  Constant: '<S5668>/Calib'
     *  SignalConversion generated from: '<S5648>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_e = KeTHMR_b_LINPrplVlv_CalibReq_Dum4BSG;

#endif

    /* End of Switch: '<S5649>/Switch1' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Fan_Shutt_Command'
     */
    /* Switch: '<S1135>/Switch1' incorporates:
     *  Constant: '<S1143>/Calib'
     *  SignalConversion generated from: '<S1135>/VariantSource'
     *  SignalConversion generated from: '<S5649>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_RadFan_State_SelDial)
    {
        /* VariantMerge generated from: '<S1135>/VariantSource' incorporates:
         *  Constant: '<S1144>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_kp = KeTHMR_e_RadFan_State_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S1135>/VariantSource' incorporates:
         *  DataTypeConversion: '<S4040>/DataTypeConversion'
         */
        THMR_ac_B.VariantMerge_Fo_kp = VeTHMR_e_RadFan_State_B4SET;
    }

#else

    /* Outputs for Function Call SubSystem: '<S2>/Valve_command' */
    /* VariantMerge generated from: '<S5649>/VariantSource' incorporates:
     *  Constant: '<S5671>/Calib'
     *  SignalConversion generated from: '<S5649>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_g = KeTHMR_b_LINPrplVlv_SvReq_Dum4BSG;

    /* VariantMerge generated from: '<S1135>/VariantSource' incorporates:
     *  Constant: '<S1145>/Calib'
     *  SignalConversion generated from: '<S1135>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_kp = KeTHMR_e_RadFan_State_Dum4BSG;

#endif

    /* End of Switch: '<S1135>/Switch1' */

    /* SignalConversion generated from: '<S56>/AGS_State_AD' incorporates:
     *  Constant: '<S1132>/Calib'
     */
    THMR_ac_B.VeTHMR_b_AGS_State = KeTHMR_b_AGS_State_Dial;

    /* SignalConversion generated from: '<S56>/HCP_AGS_Req_AD' incorporates:
     *  Constant: '<S1131>/Calib'
     */
    THMR_ac_B.VeTHMR_Pct_HCP_AGS_Req = KeTHMR_Pct_HCP_AGS_Req_Dial;

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Battery_Outputs'
     */
    /* Switch: '<S197>/Switch1' incorporates:
     *  Constant: '<S207>/Calib'
     *  Constant: '<S211>/Calib'
     *  Inport: '<Root>/VeBTRR_b_BattCondPlugin_Rq'
     *  Inport: '<Root>/VeTPCR_b_PeriodWup_Msg2'
     *  Logic: '<S208>/Logical'
     *  Logic: '<S208>/Logical1'
     *  Logic: '<S208>/Logical2'
     *  SignalConversion generated from: '<S197>/VariantSource'
     *  Switch: '<S196>/Switch1'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_CellOverTemp_SelDial)
    {
        /* VariantMerge generated from: '<S197>/VariantSource' incorporates:
         *  Constant: '<S212>/Calib'
         */
        THMR_ac_B.VariantMerge_For_Varian_adzsu0c = KeTHMR_dT_CellOverTemp_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S197>/VariantSource' */
        THMR_ac_B.VariantMerge_For_Varian_adzsu0c =
            rtb_TmpSignalConversionAtVeB_cl;
    }

    (void)Rte_Read_VeBTRR_b_BattCondPlugin_Rq_Value(&tmpRead_12);
    (void)Rte_Read_VeTPCR_b_PeriodWup_Msg2_Value(&tmpRead_z);

    /* Logic: '<S208>/Logical' incorporates:
     *  Constant: '<S209>/Calib'
     *  Constant: '<S210>/Calib'
     *  Constant: '<S211>/Calib'
     *  Inport: '<Root>/VeBTRR_b_BattCondPlugin_Rq'
     *  Inport: '<Root>/VeTPCR_b_PeriodWup_Msg2'
     */
    VeTHMR_b_BattCondPlugin_Rq_BD = ((tmpRead_12 &&
        (KeTHMR_b_BattCondPlugin_Rq_Enb)) || (tmpRead_z &&
        (KeTHMR_b_PeriodWup_Msg2_Enb)));
    if (KeTHMR_b_BattCondPlugin_Rq_SD)
    {
        /* VariantMerge generated from: '<S196>/VariantSource' incorporates:
         *  Constant: '<S205>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_n = KeTHMR_b_BattCondPlugin_RqDial;
    }
    else
    {
        /* VariantMerge generated from: '<S196>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_n = VeTHMR_b_BattCondPlugin_Rq_BD;
    }

#else

    /* VariantMerge generated from: '<S197>/VariantSource' incorporates:
     *  Constant: '<S213>/Calib'
     *  SignalConversion generated from: '<S197>/VariantSource'
     */
    THMR_ac_B.VariantMerge_For_Varian_adzsu0c = KeTHMR_dT_CellOverTemp_Dum4BSG;

#endif

    /* End of Switch: '<S197>/Switch1' */

    /* Switch: '<S198>/Switch1' incorporates:
     *  Constant: '<S215>/Calib'
     *  Inport: '<Root>/VeTPCR_b_RSA_BatCrit_Msg3'
     *  SignalConversion generated from: '<S196>/VariantSource'
     *  SignalConversion generated from: '<S198>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    (void)Rte_Read_VeTPCR_b_RSA_BatCrit_Msg3_Value(&tmpRead_10);
    if (KeTHMR_b_RSA_StrtVhclRq_SD)
    {
        /* VariantMerge generated from: '<S198>/VariantSource' incorporates:
         *  Constant: '<S216>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_l = KeTHMR_b_RmtStrtAbort_StrtVhclRq_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S198>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_l = tmpRead_10;
    }

#else

    /* VariantMerge generated from: '<S196>/VariantSource' incorporates:
     *  Constant: '<S206>/Calib'
     *  SignalConversion generated from: '<S196>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_n = KeTHMR_b_BattCondPlugin_Rq_Dum4BSG;

    /* VariantMerge generated from: '<S198>/VariantSource' incorporates:
     *  Constant: '<S214>/Calib'
     *  SignalConversion generated from: '<S198>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_l = KeTHMR_b_RSA_StrtVhclRq_Dum4BSG;

#endif

    /* End of Switch: '<S198>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeTPDR_P_Rat_EAC_PwrBdgt_Avail' */
    (void)Rte_Read_VeTPDR_P_Rat_EAC_PwrBdgt_Avail_Value(&tmpRead_1l);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Miscellaneous_Outputs'
     */
    /* Switch: '<S3367>/Switch1' incorporates:
     *  Constant: '<S3371>/Calib'
     *  Inport: '<Root>/VeTPCR_b_RdyForShtDwn'
     */
    if (KeTHMR_b_RdyForShtDwn_SD)
    {
        /* Switch: '<S3367>/Switch1' incorporates:
         *  Constant: '<S3370>/Calib'
         */
        rtb_VariantMerge_For_Variant__o = KeTHMR_b_RdyForShtDwn_D;
    }
    else
    {
        (void)Rte_Read_VeTPCR_b_RdyForShtDwn_Value(&tmpRead_11);

        /* Switch: '<S3367>/Switch3' incorporates:
         *  Constant: '<S3372>/Calib'
         *  Constant: '<S3373>/Calib'
         *  Inport: '<Root>/VeTPCR_b_RdyForShtDwn'
         */
        if (KeTHMR_b_thermalActivityCmplt_SD)
        {
            rtb_AND_fe = KeTHMR_b_thermalActivityCmplt_D;
        }
        else
        {
            rtb_AND_fe = VeTHMR_b_thermalActivityCmplt_SF;
        }

        /* End of Switch: '<S3367>/Switch3' */

        /* Switch: '<S3367>/Switch1' incorporates:
         *  Logic: '<S3367>/Logical1'
         */
        rtb_VariantMerge_For_Variant__o = (tmpRead_11 || rtb_AND_fe);
    }

    /* End of Switch: '<S3367>/Switch1' */

    /* SignalConversion generated from: '<S3347>/VariantSource' incorporates:
     *  Constant: '<S3345>/Calib'
     *  Constant: '<S3375>/ConstantValue1'
     *  Constant: '<S3375>/ConstantValue2'
     *  Constant: '<S3375>/ConstantValue3'
     *  RelationalOperator: '<S3375>/Comparison1'
     *  RelationalOperator: '<S3375>/Comparison2'
     *  RelationalOperator: '<S3375>/Comparison3'
     *  SignalConversion generated from: '<S3348>/VariantSource'
     *  Switch: '<S3380>/Switch1'
     *  Switch: '<S3381>/Switch1'
     *  Switch: '<S3382>/Switch1'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    /* VariantMerge generated from: '<S3347>/VariantSource' */
    THMR_ac_B.VariantMerge_Fo_am = rtb_VariantMerge_For_Variant__o;
    if (KeTHMR_y_ThrmSysShtDwnFlt_Dial == 0)
    {
        /* VariantMerge generated from: '<S3348>/VariantSource' incorporates:
         *  Constant: '<S3379>/Constant'
         */
        THMR_ac_B.VariantMerge_Fo_fr = CeSRAR_e_NoFlt;
    }
    else if (KeTHMR_y_ThrmSysShtDwnFlt_Dial == 1)
    {
        /* Switch: '<S3381>/Switch1' incorporates:
         *  Constant: '<S3376>/Constant'
         *  VariantMerge generated from: '<S3348>/VariantSource'
         */
        THMR_ac_B.VariantMerge_Fo_fr = CeSRAR_e_RecSysShtDwn;
    }
    else if (KeTHMR_y_ThrmSysShtDwnFlt_Dial == 2)
    {
        /* Switch: '<S3382>/Switch1' incorporates:
         *  Constant: '<S3377>/Constant'
         *  Switch: '<S3381>/Switch1'
         *  VariantMerge generated from: '<S3348>/VariantSource'
         */
        THMR_ac_B.VariantMerge_Fo_fr = CeSRAR_e_RetSysShtDwn;
    }
    else
    {
        /* VariantMerge generated from: '<S3348>/VariantSource' incorporates:
         *  Constant: '<S3378>/Constant'
         *  Switch: '<S3381>/Switch1'
         *  Switch: '<S3382>/Switch1'
         */
        THMR_ac_B.VariantMerge_Fo_fr = CeSRAR_e_NonRecSysShtDwn;
    }

#else

    /* VariantMerge generated from: '<S3347>/VariantSource' incorporates:
     *  Constant: '<S3365>/Calib'
     *  SignalConversion generated from: '<S3347>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_am = KeTHMR_b_RdyForShtDwn_Dum4BSG;

    /* VariantMerge generated from: '<S3348>/VariantSource' incorporates:
     *  Constant: '<S3374>/Constant'
     *  SignalConversion generated from: '<S3348>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_fr = CeSRAR_e_NoFlt;

#endif

    /* End of SignalConversion generated from: '<S3347>/VariantSource' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeTPCR_t_BatPerWU_ThrmlCond_Timer' */
    (void)Rte_Read_VeTPCR_t_BatPerWU_ThrmlCond_Timer_Value(&tmpRead_y);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Miscellaneous_Outputs'
     */
    /* SignalConversion generated from: '<S65>/StartVhcl_messg_AD' */
    THMR_ac_B.OutportBufferForStartVhcl_messg = false;

    /* Switch: '<S3350>/Switch' incorporates:
     *  Constant: '<S3385>/Calib'
     *  Inport: '<Root>/VeBTRR_b_KeyRun_OV_BattCrit'
     *  Inport: '<Root>/VePDTR_b_KeyRun_OV_BattCrit'
     */
    if (KeTHMR_b_LeaveKeyIn_RUN_SelDial)
    {
        /* Switch: '<S3350>/Switch' incorporates:
         *  Constant: '<S3384>/Calib'
         */
        VeTHMR_b_LeaveKeyIn_RUN = KeTHMR_b_LeaveKeyIn_RUN_Dial;
    }
    else
    {
        (void)Rte_Read_VeBTRR_b_KeyRun_OV_BattCrit_Value
            (&VeTHMR_b_LeaveKeyIn_RUN);
        (void)Rte_Read_VePDTR_b_KeyRun_OV_BattCrit_Value(&VeTHMR_b_SC_WkUpFlg);

        /* Switch: '<S3350>/Switch1' incorporates:
         *  Constant: '<S3383>/Calib'
         *  Inport: '<Root>/VeBTRR_b_KeyRun_OV_BattCrit'
         *  Inport: '<Root>/VePDTR_b_KeyRun_OV_BattCrit'
         */
        if (KeTHMR_b_KeyRunOVBattCrit_frm_PDTR)
        {
            /* Switch: '<S3350>/Switch' */
            VeTHMR_b_LeaveKeyIn_RUN = VeTHMR_b_SC_WkUpFlg;
        }

        /* End of Switch: '<S3350>/Switch1' */
    }

    /* End of Switch: '<S3350>/Switch' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Cals'
     */
    /* Switch: '<S309>/Switch1' incorporates:
     *  Constant: '<S318>/Calib'
     *  Inport: '<S46>/HtrCorClnt_TmpIn_AD'
     *  SignalConversion generated from: '<S309>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_BatThrmlSt_SelDial)
    {
        /* VariantMerge generated from: '<S309>/VariantSource' incorporates:
         *  Constant: '<S319>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_p3 = KeTHMR_e_BatThrmlSt;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S2>/Subsystem__Subsystem1' */
        /* VariantMerge generated from: '<S309>/VariantSource' incorporates:
         *  RelationalOperator: '<S4101>/Comparison8'
         *  Switch: '<S4586>/Switch1'
         */
        THMR_ac_B.VariantMerge_Fo_p3 = VeTHMR_e_BatThrmlSt_B4D;

        /* End of Outputs for SubSystem: '<S2>/Subsystem__Subsystem1' */
    }

    /* Outputs for Function Call SubSystem: '<S2>/HTCL' */
    /* VariantMerge generated from: '<S312>/VariantSource' incorporates:
     *  Constant: '<S318>/Calib'
     *  Inport: '<S57>/CTRR_T_HtrCorClnt_Tmp_In'
     */
    THMR_ac_B.VariantMerge_For_Variant_adzsu0 = VeTHMR_T_HtrCorClnt_Tmp_In_AD;

    /* End of Outputs for SubSystem: '<S2>/HTCL' */
#else

    /* VariantMerge generated from: '<S309>/VariantSource' incorporates:
     *  Constant: '<S320>/Calib'
     *  SignalConversion generated from: '<S309>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_p3 = KeTHMR_e_BatThrmlSt_Dum4BSG;

#endif

    /* End of Switch: '<S309>/Switch1' */

    /* Switch: '<S313>/Switch1' incorporates:
     *  Constant: '<S328>/Calib'
     *  SignalConversion generated from: '<S312>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_isCharging_SelDial)
    {
        /* VariantMerge generated from: '<S313>/VariantSource' incorporates:
         *  Constant: '<S326>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_pw = KeTHMR_b_isCharging_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S313>/VariantSource' */
        THMR_ac_B.VariantMerge_Fo_pw = THMR_ac_B.TmpSignalConversionAtVeBTRR_b_i;
    }

#else

    /* VariantMerge generated from: '<S312>/VariantSource' incorporates:
     *  Constant: '<S325>/Calib'
     *  SignalConversion generated from: '<S312>/VariantSource'
     */
    THMR_ac_B.VariantMerge_For_Variant_adzsu0 =
        KeTHMR_T_HtrCorClnt_TmpIn_Dum4BSG;

#endif

    /* End of Switch: '<S313>/Switch1' */

    /* Switch: '<S314>/Switch1' incorporates:
     *  Constant: '<S332>/Calib'
     *  SignalConversion generated from: '<S313>/VariantSource'
     *  SignalConversion generated from: '<S314>/VariantSource'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_CabinPreCondReqStat_SD)
    {
        /* VariantMerge generated from: '<S314>/VariantSource' incorporates:
         *  Constant: '<S336>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_ff = KeTHMR_e_CabinPreCondReqStat_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S314>/VariantSource' incorporates:
         *  SignalConversion generated from: '<S2>/VeTPCR_e_CabinPreCondReqStat'
         */
        THMR_ac_B.VariantMerge_Fo_ff = rtb_TmpSignalConversionAtVeTP_b;
    }

#else

    /* VariantMerge generated from: '<S313>/VariantSource' incorporates:
     *  Constant: '<S327>/Calib'
     *  SignalConversion generated from: '<S313>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_pw = KeTHMR_b_isCharging_Dial_Dum4BSG;

    /* VariantMerge generated from: '<S314>/VariantSource' incorporates:
     *  Constant: '<S337>/Calib'
     *  SignalConversion generated from: '<S314>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_ff = KeTHMR_e_CabinPrecondSts_Dial_Dum4BSG;

#endif

    /* End of Switch: '<S314>/Switch1' */

    /* DataTypeConversion: '<S314>/DataTypeConversion' incorporates:
     *  VariantMerge generated from: '<S314>/VariantSource'
     */
    s381_iter = (sint16)THMR_ac_B.VariantMerge_Fo_ff;

    /* Selector: '<S314>/Selector' incorporates:
     *  Constant: '<S329>/Calib'
     */
    VeTHMR_e_CabinPreCondReqStat_CAN = KaTHMR_e_CabPrecReqStMap[(s381_iter)];

    /* Switch: '<S314>/Switch2' incorporates:
     *  Constant: '<S330>/Calib'
     *  Constant: '<S333>/Calib'
     *  Switch: '<S314>/Switch3'
     */
    if (KeTHMR_b_CabinPreCondReqStCAN_SD)
    {
        /* Switch: '<S314>/Switch2' incorporates:
         *  Constant: '<S334>/Calib'
         */
        s381_iter = KeTHMR_e_CabinPreCondReqStCAN_D;
    }
    else
    {
        if (KeTHMR_b_SelOldCabPrecSt)
        {
            /* Switch: '<S314>/Switch3' incorporates:
             *  Switch: '<S314>/Switch2'
             */
            s381_iter = VeTHMR_e_CabinPreCondReqStat_CAN;
        }
    }

    /* End of Switch: '<S314>/Switch2' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeTPCR_e_CabReqSt_Msgs' */
    (void)Rte_Read_VeTPCR_e_CabReqSt_Msgs_Value(&tmpRead_1i);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Cals'
     */
    /* Switch: '<S315>/Switch1' incorporates:
     *  Constant: '<S338>/Calib'
     *  SignalConversion generated from: '<S315>/VariantSource'
     *  Switch: '<S348>/Switch1'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_Eng_Htr_HTSOV_Stat_SD)
    {
        /* VariantMerge generated from: '<S315>/VariantSource' incorporates:
         *  Constant: '<S339>/Calib'
         */
        THMR_ac_B.VariantMerge_Fo_i = KeTHMR_e_Eng_Htr_HTSOV_Stat_D;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S2>/HTCL' */
        /* VariantMerge generated from: '<S315>/VariantSource' incorporates:
         *  RelationalOperator: '<S1470>/Comparison3'
         *  Switch: '<S1576>/Switch1'
         */
        THMR_ac_B.VariantMerge_Fo_i = VeTHMR_e_EngHtr_HTSOV_State;

        /* End of Outputs for SubSystem: '<S2>/HTCL' */
    }

#else

    /* Outputs for Function Call SubSystem: '<S2>/Cals1' */
    /* VariantMerge generated from: '<S315>/VariantSource' incorporates:
     *  Constant: '<S340>/Calib'
     *  SignalConversion generated from: '<S315>/VariantSource'
     */
    THMR_ac_B.VariantMerge_Fo_i = KeTHMR_e_Eng_Htr_HTSOV_Stat_D_Dum4BSG;

    /* Switch: '<S348>/Switch1' incorporates:
     *  Constant: '<S353>/Calib'
     *  Constant: '<S354>/Calib'
     *  Constant: '<S355>/ConstantValue'
     *  Constant: '<S355>/ConstantValue1'
     *  Constant: '<S355>/ConstantValue2'
     *  Constant: '<S355>/ConstantValue3'
     *  Gain: '<S2923>/Gain'
     *  Logic: '<S355>/AND'
     *  RelationalOperator: '<S355>/GreaterThanorEqual'
     *  RelationalOperator: '<S355>/GreaterThanorEqual1'
     *  RelationalOperator: '<S355>/NotEqual'
     *  RelationalOperator: '<S355>/NotEqual1'
     *  Switch: '<S355>/Switch1'
     *  Switch: '<S355>/Switch2'
     *  Switch: '<S355>/Switch3'
     */
    if (KeTHMR_b_BSG_LTR_PmpFlwRq_SD)
    {
        /* VariantMerge generated from: '<S348>/VariantSource' incorporates:
         *  Constant: '<S351>/Calib'
         */
        THMR_ac_B.VariantMerge_For_Variant_So_adz =
            KeTHMR_Pct_BSG_LTR_PmpFlwRq_D;
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S348>/ProtectedDivision' */
        /* Outputs for Function Call SubSystem: '<S2>/LTCL' */
        if ((rtb_Switch1_muc != 0.0F) && (KeTHMR_dV_LT_ClntPmpFlw_Max != 0.0F))
        {
            /* Switch: '<S355>/Switch1' incorporates:
             *  Constant: '<S354>/Calib'
             *  Gain: '<S2923>/Gain'
             *  Product: '<S355>/Division'
             */
            rtb_TmpSignalConversionAtVeFC_k = rtb_Switch1_muc /
                KeTHMR_dV_LT_ClntPmpFlw_Max;
        }
        else if (rtb_Switch1_muc > 0.0F)
        {
            /* Switch: '<S355>/Switch2' incorporates:
             *  Constant: '<S355>/MAXFLOAT'
             *  Switch: '<S355>/Switch1'
             */
            rtb_TmpSignalConversionAtVeFC_k = 3.402823466E+38F;
        }
        else if (rtb_Switch1_muc < 0.0F)
        {
            /* Switch: '<S355>/Switch3' incorporates:
             *  Constant: '<S355>/MINFLOAT'
             *  Switch: '<S355>/Switch1'
             *  Switch: '<S355>/Switch2'
             */
            rtb_TmpSignalConversionAtVeFC_k = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S355>/Switch1' incorporates:
             *  Constant: '<S355>/ConstantValue4'
             *  Switch: '<S355>/Switch2'
             *  Switch: '<S355>/Switch3'
             */
            rtb_TmpSignalConversionAtVeFC_k = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S2>/LTCL' */
        /* End of Outputs for SubSystem: '<S348>/ProtectedDivision' */

        /* VariantMerge generated from: '<S348>/VariantSource' incorporates:
         *  Constant: '<S348>/ConstantValue1'
         *  Constant: '<S355>/ConstantValue2'
         *  Constant: '<S355>/ConstantValue3'
         *  Gain: '<S2923>/Gain'
         *  Product: '<S348>/Product'
         *  RelationalOperator: '<S355>/GreaterThanorEqual'
         *  RelationalOperator: '<S355>/GreaterThanorEqual1'
         *  Switch: '<S355>/Switch1'
         *  Switch: '<S355>/Switch2'
         *  Switch: '<S355>/Switch3'
         */
        THMR_ac_B.VariantMerge_For_Variant_So_adz =
            rtb_TmpSignalConversionAtVeFC_k * 100.0F;
    }

#endif

    /* End of Switch: '<S315>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeTPCR_b_CabPrecDny_BattCond' */
    (void)Rte_Read_VeTPCR_b_CabPrecDny_BattCond_Value(&tmpRead_1e);

    /* Inport: '<Root>/VeTPCR_t_SC_PrecTimer' */
    (void)Rte_Read_VeTPCR_t_SC_PrecTimer_Value(&tmpRead_1a);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Cals1'
     */
    /* Switch: '<S349>/Switch1' incorporates:
     *  Constant: '<S356>/Calib'
     *  SignalConversion generated from: '<S348>/VariantSource'
     */
#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_MGU_ClntPumpFlw_SD)
    {
        /* VariantMerge generated from: '<S349>/VariantSource' incorporates:
         *  Constant: '<S357>/Calib'
         */
        THMR_ac_B.VariantMerge_For_Variant_S_adzs = KeTHMR_dV_MGU_ClntPumpFlw_D;
    }
    else
    {
        /* VariantMerge generated from: '<S349>/VariantSource' */
        THMR_ac_B.VariantMerge_For_Variant_S_adzs =
            VeTHMR_dV_MGU_ClntPumpFlw_B4D;
    }

#else

    /* VariantMerge generated from: '<S348>/VariantSource' incorporates:
     *  Constant: '<S352>/Calib'
     *  SignalConversion generated from: '<S348>/VariantSource'
     */
    THMR_ac_B.VariantMerge_For_Variant_So_adz = KeTHMR_Pct_LTR_PmpFlwRq_RU_D;

#endif

    /* End of Switch: '<S349>/Switch1' */

    /* Switch: '<S350>/Switch1' incorporates:
     *  Constant: '<S359>/Calib'
     *  SignalConversion generated from: '<S349>/VariantSource'
     *  SignalConversion generated from: '<S350>/VariantSource'
     *  Switch: '<S3601>/Switch1'
     *  Switch: '<S3602>/Switch1'
     */
#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    if (KeTHMR_b_MGU_EngSpdInc_Req_SD)
    {
        /* VariantMerge generated from: '<S350>/VariantSource' incorporates:
         *  Constant: '<S361>/Calib'
         */
        THMR_ac_B.VariantMerge_For_Variant__adzsu = KeTHMR_n_MGU_EngSpdInc_Req_D;
    }
    else
    {
        /* VariantMerge generated from: '<S350>/VariantSource' */
        THMR_ac_B.VariantMerge_For_Variant__adzsu = VeTHMR_n_EngSpdInc_Req_BD;
    }

#else

    /* Outputs for Function Call SubSystem: '<S2>/Motor_Thermal' */
    /* VariantMerge generated from: '<S349>/VariantSource' incorporates:
     *  Constant: '<S358>/Calib'
     *  SignalConversion generated from: '<S349>/VariantSource'
     */
    THMR_ac_B.VariantMerge_For_Variant_S_adzs = KeTHMR_dV_MGU_ClntPumpFlw_RU_D;

    /* VariantMerge generated from: '<S350>/VariantSource' incorporates:
     *  Constant: '<S360>/Calib'
     *  SignalConversion generated from: '<S350>/VariantSource'
     */
    THMR_ac_B.VariantMerge_For_Variant__adzsu = KeTHMR_n_EngSpdInc_Req_Dum;

    /* Switch: '<S3601>/Switch1' incorporates:
     *  Constant: '<S3603>/Calib'
     */
    if (KeTHMR_b_Mtr1_CoolFlwCmd_SelDial)
    {
        /* VariantMerge generated from: '<S3601>/VariantSource' incorporates:
         *  Constant: '<S3604>/Calib'
         */
        THMR_ac_B.VariantMerge_For_Variant_Sour_a =
            KeTHMR_dV_Mtr1_CoolFlwCmd_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S3601>/VariantSource' */
        THMR_ac_B.VariantMerge_For_Variant_Sour_a =
            THMR_ac_B.LeTHMR_dV_MtrA_CoolFlwCmd;
    }

    /* Switch: '<S3602>/Switch1' incorporates:
     *  Constant: '<S3606>/Calib'
     */
    if (KeTHMR_b_Mtr2_CoolFlwCmd_SelDial)
    {
        /* VariantMerge generated from: '<S3602>/VariantSource' incorporates:
         *  Constant: '<S3607>/Calib'
         */
        THMR_ac_B.VariantMerge_For_Variant_Sou_ad =
            KeTHMR_dV_Mtr2_CoolFlwCmd_Dial;
    }
    else
    {
        /* VariantMerge generated from: '<S3602>/VariantSource' */
        THMR_ac_B.VariantMerge_For_Variant_Sou_ad = THMR_ac_B.Switch_a;
    }

#endif

    /* End of Switch: '<S350>/Switch1' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Motor_Thermal'
     */
    /* SignalConversion generated from: '<S3601>/VariantSource' incorporates:
     *  Inport: '<Root>/VeCSVR_b_WhlSpdLHF_FA'
     *  Inport: '<Root>/VeCSVR_b_WhlSpdLHR_FA'
     *  Inport: '<Root>/VeCSVR_b_WhlSpdRHF_FA'
     *  Inport: '<Root>/VeCSVR_b_WhlSpdRHR_FA'
     *  Inport: '<Root>/VeCSVR_n_WhlSpdLHF'
     *  Inport: '<Root>/VeCSVR_n_WhlSpdLHR'
     *  Inport: '<Root>/VeCSVR_n_WhlSpdRHF'
     *  Inport: '<Root>/VeCSVR_n_WhlSpdRHR'
     *  Inport: '<Root>/VeHCCR_dV_FlowLimiterPump1'
     *  Inport: '<Root>/VeHCCR_dV_FlowLimiterPump2'
     *  Inport: '<Root>/VeHCCR_dV_LubFlowPump1'
     *  Inport: '<Root>/VeHCCR_dV_LubFlowPump2'
     *  SignalConversion generated from: '<S3602>/VariantSource'
     */
#if !Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    /* VariantMerge generated from: '<S3601>/VariantSource' incorporates:
     *  Constant: '<S3605>/Calib'
     */
    THMR_ac_B.VariantMerge_For_Variant_Sour_a =
        KeTHMR_dV_Mtr1_CoolFlwCmd_Dum4BSG;

    /* VariantMerge generated from: '<S3602>/VariantSource' incorporates:
     *  Constant: '<S3608>/Calib'
     */
    THMR_ac_B.VariantMerge_For_Variant_Sou_ad =
        KeTHMR_dV_Mtr2_CoolFlwCmd_Dum4BSG;

#else

    (void)Rte_Read_VeCSVR_b_WhlSpdRHR_FA_Value(&rtb_Switch1_bkm);
    (void)Rte_Read_VeCSVR_b_WhlSpdRHF_FA_Value(&rtb_Switch1_abpr);
    (void)Rte_Read_VeCSVR_b_WhlSpdLHR_FA_Value(&rtb_Switch1_fao);
    (void)Rte_Read_VeCSVR_b_WhlSpdLHF_FA_Value(&rtb_Switch1_a2b);
    (void)Rte_Read_VeCSVR_n_WhlSpdRHR_Value(&rtb_Switch1_bhg);
    (void)Rte_Read_VeCSVR_n_WhlSpdRHF_Value(&rtb_Switch1_iui);
    (void)Rte_Read_VeCSVR_n_WhlSpdLHR_Value(&rtb_Switch1_bqc);
    (void)Rte_Read_VeCSVR_n_WhlSpdLHF_Value(&rtb_Switch1_ghr);
    (void)Rte_Read_VeHCCR_dV_FlowLimiterPump2_Value(&rtb_product1_p);
    (void)Rte_Read_VeHCCR_dV_LubFlowPump2_Value(&rtb_Switch1_eih);
    (void)Rte_Read_VeHCCR_dV_FlowLimiterPump1_Value(&rtb_Sum7_fy);
    (void)Rte_Read_VeHCCR_dV_LubFlowPump1_Value(&rtb_Sum7_l);

    /* Outputs for Function Call SubSystem: '<S2>/TriggeredSubsystem' */
    /* Switch: '<S85>/Switch2' incorporates:
     *  Constant: '<S5616>/Calib'
     *  Inport: '<Root>/VeCSVR_b_WhlSpdLHF_FA'
     *  Inport: '<Root>/VeCSVR_b_WhlSpdLHR_FA'
     *  Inport: '<Root>/VeCSVR_b_WhlSpdRHF_FA'
     *  Inport: '<Root>/VeCSVR_b_WhlSpdRHR_FA'
     *  Inport: '<Root>/VeCSVR_n_WhlSpdLHF'
     *  Inport: '<Root>/VeCSVR_n_WhlSpdLHR'
     *  Inport: '<Root>/VeCSVR_n_WhlSpdRHF'
     *  Inport: '<Root>/VeCSVR_n_WhlSpdRHR'
     *  Inport: '<Root>/VeHCCR_dV_FlowLimiterPump1'
     *  Inport: '<Root>/VeHCCR_dV_FlowLimiterPump2'
     *  Inport: '<Root>/VeHCCR_dV_LubFlowPump1'
     *  Inport: '<Root>/VeHCCR_dV_LubFlowPump2'
     */
    if (KeTHMR_b_MtrALubOilFlw_SD)
    {
        /* Switch: '<S85>/Switch2' incorporates:
         *  Constant: '<S5632>/Calib'
         */
        THMR_ac_B.Switch2_f = KeTHMR_dV_MtrALubOilFlw_D;
    }
    else
    {
        /* Switch: '<S85>/Switch2' */
        THMR_ac_B.Switch2_f = rtb_Sum7_l;
    }

    /* End of Switch: '<S85>/Switch2' */

    /* Switch: '<S85>/Switch1' incorporates:
     *  Constant: '<S5617>/Calib'
     */
    if (KeTHMR_b_MtrAOilFlwMaxLimit_SD)
    {
        /* Switch: '<S85>/Switch1' incorporates:
         *  Constant: '<S5633>/Calib'
         */
        THMR_ac_B.Switch1_fj = KeTHMR_dV_MtrAOilFlwMaxLimit_D;
    }
    else
    {
        /* Switch: '<S85>/Switch1' */
        THMR_ac_B.Switch1_fj = rtb_Sum7_fy;
    }

    /* End of Switch: '<S85>/Switch1' */

    /* Switch: '<S85>/Switch3' incorporates:
     *  Constant: '<S5618>/Calib'
     */
    if (KeTHMR_b_MtrBLubOilFlw_SD)
    {
        /* Switch: '<S85>/Switch3' incorporates:
         *  Constant: '<S5634>/Calib'
         */
        THMR_ac_B.Switch3_fg = KeTHMR_dV_MtrBLubOilFlw_D;
    }
    else
    {
        /* Switch: '<S85>/Switch3' */
        THMR_ac_B.Switch3_fg = rtb_Switch1_eih;
    }

    /* End of Switch: '<S85>/Switch3' */

    /* Switch: '<S85>/Switch4' incorporates:
     *  Constant: '<S5619>/Calib'
     */
    if (KeTHMR_b_MtrBOilFlwMaxLimit_SD)
    {
        /* Switch: '<S85>/Switch4' incorporates:
         *  Constant: '<S5635>/Calib'
         */
        THMR_ac_B.Switch4_h = KeTHMR_dV_MtrBOilFlwMaxLimit_D;
    }
    else
    {
        /* Switch: '<S85>/Switch4' */
        THMR_ac_B.Switch4_h = rtb_product1_p;
    }

    /* End of Switch: '<S85>/Switch4' */

    /* Switch: '<S85>/Switch6' incorporates:
     *  Constant: '<S5622>/Calib'
     */
    if (KeTHMR_b_WhlSpdLHF_SD)
    {
        /* Switch: '<S85>/Switch6' incorporates:
         *  Constant: '<S5636>/Calib'
         */
        THMR_ac_B.Switch6 = KeTHMR_n_WhlSpdLHF_D;
    }
    else
    {
        /* Switch: '<S85>/Switch6' */
        THMR_ac_B.Switch6 = rtb_Switch1_ghr;
    }

    /* End of Switch: '<S85>/Switch6' */

    /* Switch: '<S85>/Switch5' incorporates:
     *  Constant: '<S5625>/Calib'
     */
    if (KeTHMR_b_WhlSpdLHR_SD)
    {
        /* Switch: '<S85>/Switch5' incorporates:
         *  Constant: '<S5637>/Calib'
         */
        THMR_ac_B.Switch5 = KeTHMR_n_WhlSpdLHR_D;
    }
    else
    {
        /* Switch: '<S85>/Switch5' */
        THMR_ac_B.Switch5 = rtb_Switch1_bqc;
    }

    /* End of Switch: '<S85>/Switch5' */

    /* Switch: '<S85>/Switch7' incorporates:
     *  Constant: '<S5628>/Calib'
     */
    if (KeTHMR_b_WhlSpdRHF_SD)
    {
        /* Switch: '<S85>/Switch7' incorporates:
         *  Constant: '<S5638>/Calib'
         */
        THMR_ac_B.Switch7 = KeTHMR_n_WhlSpdRHF_D;
    }
    else
    {
        /* Switch: '<S85>/Switch7' */
        THMR_ac_B.Switch7 = rtb_Switch1_iui;
    }

    /* End of Switch: '<S85>/Switch7' */

    /* Switch: '<S85>/Switch8' incorporates:
     *  Constant: '<S5631>/Calib'
     */
    if (KeTHMR_b_WhlSpdRHR_SD)
    {
        /* Switch: '<S85>/Switch8' incorporates:
         *  Constant: '<S5639>/Calib'
         */
        THMR_ac_B.Switch8 = KeTHMR_n_WhlSpdRHR_D;
    }
    else
    {
        /* Switch: '<S85>/Switch8' */
        THMR_ac_B.Switch8 = rtb_Switch1_bhg;
    }

    /* End of Switch: '<S85>/Switch8' */

    /* Switch: '<S85>/Switch10' incorporates:
     *  Constant: '<S5621>/Calib'
     */
    if (KeTHMR_b_WhlSpdLHF_FA_SD)
    {
        /* Switch: '<S85>/Switch10' incorporates:
         *  Constant: '<S5620>/Calib'
         */
        THMR_ac_B.Switch10_n = KeTHMR_b_WhlSpdLHF_FA_D;
    }
    else
    {
        /* Switch: '<S85>/Switch10' */
        THMR_ac_B.Switch10_n = rtb_Switch1_a2b;
    }

    /* End of Switch: '<S85>/Switch10' */

    /* Switch: '<S85>/Switch9' incorporates:
     *  Constant: '<S5624>/Calib'
     */
    if (KeTHMR_b_WhlSpdLHR_FA_SD)
    {
        /* Switch: '<S85>/Switch9' incorporates:
         *  Constant: '<S5623>/Calib'
         */
        THMR_ac_B.Switch9 = KeTHMR_b_WhlSpdLHR_FA_D;
    }
    else
    {
        /* Switch: '<S85>/Switch9' */
        THMR_ac_B.Switch9 = rtb_Switch1_fao;
    }

    /* End of Switch: '<S85>/Switch9' */

    /* Switch: '<S85>/Switch11' incorporates:
     *  Constant: '<S5627>/Calib'
     */
    if (KeTHMR_b_WhlSpdRHF_FA_SD)
    {
        /* Switch: '<S85>/Switch11' incorporates:
         *  Constant: '<S5626>/Calib'
         */
        THMR_ac_B.Switch11_p = KeTHMR_b_WhlSpdRHF_FA_D;
    }
    else
    {
        /* Switch: '<S85>/Switch11' */
        THMR_ac_B.Switch11_p = rtb_Switch1_abpr;
    }

    /* End of Switch: '<S85>/Switch11' */

    /* Switch: '<S85>/Switch12' incorporates:
     *  Constant: '<S5630>/Calib'
     */
    if (KeTHMR_b_WhlSpdRHR_FA_SD)
    {
        /* Switch: '<S85>/Switch12' incorporates:
         *  Constant: '<S5629>/Calib'
         */
        THMR_ac_B.Switch12_l = KeTHMR_b_WhlSpdRHR_FA_D;
    }
    else
    {
        /* Switch: '<S85>/Switch12' */
        THMR_ac_B.Switch12_l = rtb_Switch1_bkm;
    }

    /* End of Switch: '<S85>/Switch12' */
    /* End of Outputs for SubSystem: '<S2>/TriggeredSubsystem' */
#endif

    /* End of SignalConversion generated from: '<S3601>/VariantSource' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

    /* Outputs for Function Call SubSystem: '<S2>/MotorA_Harness_Control' */
    /* Outputs for Atomic SubSystem: '<S3408>/Hysteresis_1' */
    /* Switch: '<S3410>/Switch1' incorporates:
     *  Constant: '<S3418>/Calib'
     *  RelationalOperator: '<S3410>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVaCT_e[0] >= KeTHMR_T_MtrAConCmpTempRSP1)
    {
        /* Switch: '<S3410>/Switch1' incorporates:
         *  Constant: '<S3410>/ConstantValue'
         */
        rtb_Switch1_bkm = true;
    }
    else
    {
        /* Switch: '<S3410>/Switch1' incorporates:
         *  Constant: '<S3414>/Calib'
         *  RelationalOperator: '<S3410>/GreaterThan1'
         *  UnitDelay: '<S3410>/UnitDelay'
         */
        rtb_Switch1_bkm = ((rtb_TmpSignalConversionAtVaCT_e[0] >
                            KeTHMR_T_MtrAConCmpTempLSP1) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_iro));
    }

    /* End of Switch: '<S3410>/Switch1' */

    /* Update for UnitDelay: '<S3410>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_iro = rtb_Switch1_bkm;

    /* End of Outputs for SubSystem: '<S3408>/Hysteresis_1' */

    /* Outputs for Atomic SubSystem: '<S3408>/Hysteresis_2' */
    /* Switch: '<S3411>/Switch1' incorporates:
     *  Constant: '<S3419>/Calib'
     *  RelationalOperator: '<S3411>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVaCT_e[1] >= KeTHMR_T_MtrAConCmpTempRSP2)
    {
        /* Switch: '<S3411>/Switch1' incorporates:
         *  Constant: '<S3411>/ConstantValue'
         */
        rtb_Switch1_abpr = true;
    }
    else
    {
        /* Switch: '<S3411>/Switch1' incorporates:
         *  Constant: '<S3415>/Calib'
         *  RelationalOperator: '<S3411>/GreaterThan1'
         *  UnitDelay: '<S3411>/UnitDelay'
         */
        rtb_Switch1_abpr = ((rtb_TmpSignalConversionAtVaCT_e[1] >
                             KeTHMR_T_MtrAConCmpTempLSP2) &&
                            (THMR_ac_DW.UnitDelay_DSTATE_et5));
    }

    /* End of Switch: '<S3411>/Switch1' */

    /* Update for UnitDelay: '<S3411>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_et5 = rtb_Switch1_abpr;

    /* End of Outputs for SubSystem: '<S3408>/Hysteresis_2' */

    /* Outputs for Atomic SubSystem: '<S3408>/Hysteresis_3' */
    /* Switch: '<S3412>/Switch1' incorporates:
     *  Constant: '<S3420>/Calib'
     *  RelationalOperator: '<S3412>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVaCT_e[2] >= KeTHMR_T_MtrAConCmpTempRSP3)
    {
        /* Switch: '<S3412>/Switch1' incorporates:
         *  Constant: '<S3412>/ConstantValue'
         */
        rtb_Switch1_fao = true;
    }
    else
    {
        /* Switch: '<S3412>/Switch1' incorporates:
         *  Constant: '<S3416>/Calib'
         *  RelationalOperator: '<S3412>/GreaterThan1'
         *  UnitDelay: '<S3412>/UnitDelay'
         */
        rtb_Switch1_fao = ((rtb_TmpSignalConversionAtVaCT_e[2] >
                            KeTHMR_T_MtrAConCmpTempLSP3) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_ho));
    }

    /* End of Switch: '<S3412>/Switch1' */

    /* Update for UnitDelay: '<S3412>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ho = rtb_Switch1_fao;

    /* End of Outputs for SubSystem: '<S3408>/Hysteresis_3' */

    /* Outputs for Atomic SubSystem: '<S3408>/Hysteresis_4' */
    /* Switch: '<S3413>/Switch1' incorporates:
     *  Constant: '<S3421>/Calib'
     *  RelationalOperator: '<S3413>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVaCT_e[3] >= KeTHMR_T_MtrAConCmpTempRSP4)
    {
        /* Switch: '<S3413>/Switch1' incorporates:
         *  Constant: '<S3413>/ConstantValue'
         */
        rtb_Switch1_a2b = true;
    }
    else
    {
        /* Switch: '<S3413>/Switch1' incorporates:
         *  Constant: '<S3417>/Calib'
         *  RelationalOperator: '<S3413>/GreaterThan1'
         *  UnitDelay: '<S3413>/UnitDelay'
         */
        rtb_Switch1_a2b = ((rtb_TmpSignalConversionAtVaCT_e[3] >
                            KeTHMR_T_MtrAConCmpTempLSP4) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_lp));
    }

    /* End of Switch: '<S3413>/Switch1' */

    /* Update for UnitDelay: '<S3413>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_lp = rtb_Switch1_a2b;

    /* End of Outputs for SubSystem: '<S3408>/Hysteresis_4' */

    /* Logic: '<S3408>/Logical2' */
    THMR_ac_B.VeTHMR_b_HvHrnMtrAPowerLimit = (((rtb_Switch1_bkm ||
        rtb_Switch1_abpr) || rtb_Switch1_fao) || rtb_Switch1_a2b);

    /* MinMax: '<S3422>/MinMax2' incorporates:
     *  Lookup_n-D: '<S3431>/Vector'
     *  Lookup_n-D: '<S3432>/Vector'
     *  Lookup_n-D: '<S3433>/Vector'
     *  Lookup_n-D: '<S3434>/Vector'
     *  MinMax: '<S3423>/MinMax2'
     *  MinMax: '<S3424>/MinMax2'
     */
    rtb_Switch1_bhg = fminf(fminf(fminf(look1_iflf_binlcapw
        (rtb_TmpSignalConversionAtVaCT_e[0], ((const float32 *)
        &(KxTHMR_K_MaxMtrAConTemp1[0])), ((const float32 *)
        &(KtTHMR_K_MaxMtrAConTemp1[0])), 6U), look1_iflf_binlcapw
        (rtb_TmpSignalConversionAtVaCT_e[1], ((const float32 *)
        &(KxTHMR_K_MaxMtrAConTemp2[0])), ((const float32 *)
        &(KtTHMR_K_MaxMtrAConTemp2[0])), 6U)), look1_iflf_binlcapw
        (rtb_TmpSignalConversionAtVaCT_e[2], ((const float32 *)
        &(KxTHMR_K_MaxMtrAConTemp3[0])), ((const float32 *)
        &(KtTHMR_K_MaxMtrAConTemp3[0])), 6U)), look1_iflf_binlcapw
                            (rtb_TmpSignalConversionAtVaCT_e[3], ((const float32
        *)&(KxTHMR_K_MaxMtrAConTemp4[0])), ((const float32 *)
        &(KtTHMR_K_MaxMtrAConTemp4[0])), 6U));

    /* MinMax: '<S3422>/MinMax4' incorporates:
     *  Lookup_n-D: '<S3435>/Vector'
     *  Lookup_n-D: '<S3436>/Vector'
     *  Lookup_n-D: '<S3437>/Vector'
     *  Lookup_n-D: '<S3438>/Vector'
     *  MinMax: '<S3423>/MinMax4'
     *  MinMax: '<S3424>/MinMax4'
     */
    rtb_Switch1_iui = fmaxf(fmaxf(fmaxf(look1_iflf_binlcapw
        (rtb_TmpSignalConversionAtVaCT_e[0], ((const float32 *)
        &(KxTHMR_K_MinMtrAConTemp1[0])), ((const float32 *)
        &(KtTHMR_K_MinMtrAConTemp1[0])), 6U), look1_iflf_binlcapw
        (rtb_TmpSignalConversionAtVaCT_e[1], ((const float32 *)
        &(KxTHMR_K_MinMtrAConTemp2[0])), ((const float32 *)
        &(KtTHMR_K_MinMtrAConTemp2[0])), 6U)), look1_iflf_binlcapw
        (rtb_TmpSignalConversionAtVaCT_e[2], ((const float32 *)
        &(KxTHMR_K_MinMtrAConTemp3[0])), ((const float32 *)
        &(KtTHMR_K_MinMtrAConTemp3[0])), 6U)), look1_iflf_binlcapw
                            (rtb_TmpSignalConversionAtVaCT_e[3], ((const float32
        *)&(KxTHMR_K_MinMtrAConTemp4[0])), ((const float32 *)
        &(KtTHMR_K_MinMtrAConTemp4[0])), 6U));

    /* MinMax: '<S3422>/MinMax1' incorporates:
     *  MinMax: '<S3423>/MinMax1'
     *  MinMax: '<S3424>/MinMax1'
     *  Sum: '<S3422>/Sum1'
     *  Sum: '<S3422>/Sum2'
     *  Sum: '<S3422>/Sum3'
     *  Sum: '<S3422>/Sum4'
     */
    rtb_Sum7_l = fmaxf(fmaxf(fmaxf(rtb_TmpSignalConversionAtVaCT_e[0] -
                         rtb_TmpSignalConversionAtVaCT_j[0],
                         rtb_TmpSignalConversionAtVaCT_e[1] -
                         rtb_TmpSignalConversionAtVaCT_j[1]),
                        rtb_TmpSignalConversionAtVaCT_e[2] -
                        rtb_TmpSignalConversionAtVaCT_j[2]),
                       rtb_TmpSignalConversionAtVaCT_e[3] -
                       rtb_TmpSignalConversionAtVaCT_j[3]);

    /* Switch: '<S3445>/Switch1' incorporates:
     *  Logic: '<S3440>/Logical1'
     *  Logic: '<S3440>/Logical3'
     *  RelationalOperator: '<S3440>/Comparison1'
     *  RelationalOperator: '<S3440>/Comparison2'
     *  Switch: '<S3442>/Switch1'
     *  UnitDelay: '<S3440>/UnitDelay'
     *  UnitDelay: '<S3440>/UnitDelay2'
     *  UnitDelay: '<S3440>/UnitDelay3'
     */
    if (!THMR_ac_B.VeTHMR_b_HvHrnMtrAPowerLimit)
    {
        /* Switch: '<S3445>/Switch1' incorporates:
         *  Constant: '<S3440>/ConstantValue4'
         */
        rtb_Switch1_bqc = 0.0F;
    }
    else
    {
        if ((THMR_ac_DW.UnitDelay_DSTATE_ks < THMR_ac_DW.UnitDelay3_DSTATE_a) ||
            (THMR_ac_DW.UnitDelay_DSTATE_ks >= THMR_ac_DW.UnitDelay2_DSTATE_ki))
        {
            /* Switch: '<S3442>/Switch1' incorporates:
             *  Constant: '<S3440>/ConstantValue'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S3442>/Switch1' incorporates:
             *  Lookup_n-D: '<S3443>/Vector'
             *  MinMax: '<S3422>/MinMax1'
             *  Product: '<S3440>/Multiplication1'
             */
            rtb_Switch10 = rtb_Sum7_l * look1_iflf_binlcapw(rtb_Sum7_l, ((const
                float32 *)&(KxTHMR_K_KiMtrACon[0])), ((const float32 *)
                &(KtTHMR_K_KiMtrACon[0])), 6U);
        }

        /* Switch: '<S3445>/Switch1' incorporates:
         *  Product: '<S3445>/Product1'
         *  Sum: '<S3445>/Summation'
         *  UnitDelay: '<S3445>/UnitDelay1'
         */
        rtb_Switch1_bqc = (rtb_Switch10 + THMR_ac_DW.UnitDelay1_DSTATE_fa) *
            0.05F;
    }

    /* End of Switch: '<S3445>/Switch1' */

    /* Switch: '<S3441>/Switch1' */
    if (THMR_ac_B.VeTHMR_b_HvHrnMtrAPowerLimit)
    {
        /* Switch: '<S3441>/Switch1' incorporates:
         *  Lookup_n-D: '<S3444>/Vector'
         *  MinMax: '<S3422>/MinMax1'
         *  Product: '<S3440>/proportional_term'
         *  Sum: '<S3440>/Sum//Sub1'
         */
        rtb_Switch1_ghr = (look1_iflf_binlcapw(rtb_Sum7_l, ((const float32 *)
                             &(KxTHMR_K_KpMtrACon[0])), ((const float32 *)
                             &(KtTHMR_K_KpMtrACon[0])), 6U) * rtb_Sum7_l) +
            rtb_Switch1_bqc;
    }
    else
    {
        /* Switch: '<S3441>/Switch1' incorporates:
         *  Constant: '<S3440>/ConstantValue3'
         */
        rtb_Switch1_ghr = 1.0F;
    }

    /* End of Switch: '<S3441>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S3446>/EdgeRising1' */
    /* Logic: '<S3459>/OR1' incorporates:
     *  UnitDelay: '<S3459>/UnitDelay'
     */
    rtb_Switch1_bkm = !THMR_ac_DW.UnitDelay_DSTATE_pt;

    /* Update for UnitDelay: '<S3459>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_pt = THMR_ac_B.VeTHMR_b_HvHrnMtrAPowerLimit;

    /* Switch: '<S3446>/Switch2' incorporates:
     *  Inport: '<Root>/VeINVR_I_MtrA_DC_Crnt'
     *  Inport: '<Root>/VeINVR_U_MtrA_DC_Volt'
     *  Logic: '<S3459>/AND'
     */
    if ((THMR_ac_B.VeTHMR_b_HvHrnMtrAPowerLimit) && rtb_Switch1_bkm)
    {
        (void)Rte_Read_VeINVR_I_MtrA_DC_Crnt_Value(&rtb_Switch2_m5d);
        (void)Rte_Read_VeINVR_U_MtrA_DC_Volt_Value(&rtb_product_e);

        /* Switch: '<S3446>/Switch2' incorporates:
         *  Abs: '<S3446>/Abs'
         *  Inport: '<Root>/VeINVR_I_MtrA_DC_Crnt'
         *  Inport: '<Root>/VeINVR_U_MtrA_DC_Volt'
         *  Product: '<S3423>/Product'
         */
        rtb_Switch2_m5d = fabsf(rtb_product_e * rtb_Switch2_m5d);
    }
    else
    {
        /* Switch: '<S3446>/Switch2' incorporates:
         *  UnitDelay: '<S3446>/UnitDelay'
         */
        rtb_Switch2_m5d = THMR_ac_DW.UnitDelay_DSTATE_p;
    }

    /* End of Switch: '<S3446>/Switch2' */
    /* End of Outputs for SubSystem: '<S3446>/EdgeRising1' */

    /* Product: '<S3423>/product' incorporates:
     *  Constant: '<S3447>/Calib'
     */
    rtb_product_e = rtb_Switch1_bhg * KeTHMR_P_MtrAPowerLimit;

    /* Product: '<S3423>/product1' incorporates:
     *  Constant: '<S3447>/Calib'
     */
    rtb_product1_p = rtb_Switch1_iui * KeTHMR_P_MtrAPowerLimit;

    /* Switch: '<S3464>/Switch1' incorporates:
     *  Logic: '<S3457>/Logical1'
     *  Logic: '<S3457>/Logical3'
     *  RelationalOperator: '<S3457>/Comparison1'
     *  RelationalOperator: '<S3457>/Comparison2'
     *  Switch: '<S3461>/Switch1'
     *  UnitDelay: '<S3457>/UnitDelay'
     *  UnitDelay: '<S3457>/UnitDelay2'
     *  UnitDelay: '<S3457>/UnitDelay3'
     */
    if (!THMR_ac_B.VeTHMR_b_HvHrnMtrAPowerLimit)
    {
        /* Switch: '<S3464>/Switch1' incorporates:
         *  Constant: '<S3457>/ConstantValue4'
         */
        rtb_Switch1_eih = 0.0F;
    }
    else
    {
        if ((THMR_ac_DW.UnitDelay_DSTATE_khi < THMR_ac_DW.UnitDelay3_DSTATE_pb) ||
            (THMR_ac_DW.UnitDelay_DSTATE_khi >= THMR_ac_DW.UnitDelay2_DSTATE_g))
        {
            /* Switch: '<S3461>/Switch1' incorporates:
             *  Constant: '<S3457>/ConstantValue'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S3461>/Switch1' incorporates:
             *  Lookup_n-D: '<S3462>/Vector'
             *  Product: '<S3457>/Multiplication1'
             */
            rtb_Switch10 = rtb_Sum7_l * look1_iflf_binlcapw(rtb_Sum7_l, ((const
                float32 *)&(KxTHMR_K_KiMtrACon[0])), ((const float32 *)
                &(KtTHMR_K_KiMtrACon[0])), 6U);
        }

        /* Switch: '<S3464>/Switch1' incorporates:
         *  Product: '<S3464>/Product1'
         *  Sum: '<S3464>/Summation'
         *  UnitDelay: '<S3464>/UnitDelay1'
         */
        rtb_Switch1_eih = (rtb_Switch10 + THMR_ac_DW.UnitDelay1_DSTATE_o) *
            0.05F;
    }

    /* End of Switch: '<S3464>/Switch1' */
    /* End of Outputs for SubSystem: '<S2>/MotorA_Harness_Control' */

    /* Inport: '<Root>/VeMTIR_M_MtrA_MinTorqRaw' */
    (void)Rte_Read_VeMTIR_M_MtrA_MinTorqRaw_Value(&rtb_Switch2_mkk);

    /* Inport: '<Root>/VeMTIR_M_MtrA_MaxTorqRaw' */
    (void)Rte_Read_VeMTIR_M_MtrA_MaxTorqRaw_Value(&rtb_product_k);

    /* Outputs for Function Call SubSystem: '<S2>/MotorA_Harness_Control' */
    /* Switch: '<S3460>/Switch1' incorporates:
     *  Constant: '<S3457>/ConstantValue3'
     *  Lookup_n-D: '<S3463>/Vector'
     *  Product: '<S3457>/proportional_term'
     *  Sum: '<S3457>/Sum//Sub1'
     */
    if (THMR_ac_B.VeTHMR_b_HvHrnMtrAPowerLimit)
    {
        rtb_Switch10 = (look1_iflf_binlcapw(rtb_Sum7_l, ((const float32 *)
                          &(KxTHMR_K_KpMtrACon[0])), ((const float32 *)
                          &(KtTHMR_K_KpMtrACon[0])), 6U) * rtb_Sum7_l) +
            rtb_Switch1_eih;
    }
    else
    {
        rtb_Switch10 = 0.0F;
    }

    /* End of Switch: '<S3460>/Switch1' */

    /* Sum: '<S3423>/Sum7' */
    rtb_Sum7_fy = rtb_Switch2_m5d - rtb_Switch10;

    /* Switch: '<S3466>/Switch1' incorporates:
     *  Constant: '<S3424>/ConstantValue2'
     *  RelationalOperator: '<S3424>/Comparison1'
     */
    if (VeTHMR_M_MtrA_TorqAchieved >= 0.0F)
    {
        rtb_Switch2_mkk = rtb_product_k;
    }

    /* End of Switch: '<S3466>/Switch1' */

    /* Abs: '<S3424>/Abs' */
    rtb_TmpSignalConversionAtVeFC_f = fabsf(rtb_Switch2_mkk);

    /* Outputs for Atomic SubSystem: '<S3465>/EdgeRising1' */
    /* Logic: '<S3478>/OR1' incorporates:
     *  UnitDelay: '<S3478>/UnitDelay'
     */
    rtb_Switch1_bkm = !THMR_ac_DW.UnitDelay_DSTATE_kh3;

    /* Update for UnitDelay: '<S3478>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kh3 = THMR_ac_B.VeTHMR_b_HvHrnMtrAPowerLimit;

    /* Switch: '<S3465>/Switch2' incorporates:
     *  Logic: '<S3478>/AND'
     */
    if ((THMR_ac_B.VeTHMR_b_HvHrnMtrAPowerLimit) && rtb_Switch1_bkm)
    {
        /* Switch: '<S3465>/Switch2' incorporates:
         *  Abs: '<S3465>/Abs'
         */
        rtb_Switch2_mkk = fabsf(VeTHMR_M_MtrA_TorqAchieved);
    }
    else
    {
        /* Switch: '<S3465>/Switch2' incorporates:
         *  UnitDelay: '<S3465>/UnitDelay'
         */
        rtb_Switch2_mkk = THMR_ac_DW.UnitDelay_DSTATE_au;
    }

    /* End of Switch: '<S3465>/Switch2' */
    /* End of Outputs for SubSystem: '<S3465>/EdgeRising1' */

    /* Product: '<S3424>/product' */
    rtb_product_k = rtb_Switch1_bhg * rtb_TmpSignalConversionAtVeFC_f;

    /* Product: '<S3424>/product1' */
    rtb_TmpSignalConversionAtVeFC_k = rtb_Switch1_iui *
        rtb_TmpSignalConversionAtVeFC_f;

    /* Switch: '<S3483>/Switch1' incorporates:
     *  Logic: '<S3476>/Logical1'
     *  Logic: '<S3476>/Logical3'
     *  RelationalOperator: '<S3476>/Comparison1'
     *  RelationalOperator: '<S3476>/Comparison2'
     *  Switch: '<S3480>/Switch1'
     *  UnitDelay: '<S3476>/UnitDelay'
     *  UnitDelay: '<S3476>/UnitDelay2'
     *  UnitDelay: '<S3476>/UnitDelay3'
     */
    if (!THMR_ac_B.VeTHMR_b_HvHrnMtrAPowerLimit)
    {
        /* Switch: '<S3483>/Switch1' incorporates:
         *  Constant: '<S3476>/ConstantValue4'
         */
        rtb_TmpSignalConversionAtVeCSVR = 0.0F;
    }
    else
    {
        if ((THMR_ac_DW.UnitDelay_DSTATE_im < THMR_ac_DW.UnitDelay3_DSTATE_e) ||
            (THMR_ac_DW.UnitDelay_DSTATE_im >= THMR_ac_DW.UnitDelay2_DSTATE_pi))
        {
            /* Switch: '<S3480>/Switch1' incorporates:
             *  Constant: '<S3476>/ConstantValue'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S3480>/Switch1' incorporates:
             *  Lookup_n-D: '<S3481>/Vector'
             *  Product: '<S3476>/Multiplication1'
             */
            rtb_Switch10 = rtb_Sum7_l * look1_iflf_binlcapw(rtb_Sum7_l, ((const
                float32 *)&(KxTHMR_K_KiMtrACon[0])), ((const float32 *)
                &(KtTHMR_K_KiMtrACon[0])), 6U);
        }

        /* Switch: '<S3483>/Switch1' incorporates:
         *  Product: '<S3483>/Product1'
         *  Sum: '<S3483>/Summation'
         *  UnitDelay: '<S3483>/UnitDelay1'
         */
        rtb_TmpSignalConversionAtVeCSVR = (rtb_Switch10 +
            THMR_ac_DW.UnitDelay1_DSTATE_gm) * 0.05F;
    }

    /* End of Switch: '<S3483>/Switch1' */

    /* Switch: '<S3479>/Switch1' incorporates:
     *  Constant: '<S3476>/ConstantValue3'
     *  Lookup_n-D: '<S3482>/Vector'
     *  Product: '<S3476>/proportional_term'
     *  Sum: '<S3476>/Sum//Sub1'
     */
    if (THMR_ac_B.VeTHMR_b_HvHrnMtrAPowerLimit)
    {
        rtb_Switch10 = (look1_iflf_binlcapw(rtb_Sum7_l, ((const float32 *)
                          &(KxTHMR_K_KpMtrACon[0])), ((const float32 *)
                          &(KtTHMR_K_KpMtrACon[0])), 6U) * rtb_Sum7_l) +
            rtb_TmpSignalConversionAtVeCSVR;
    }
    else
    {
        rtb_Switch10 = 0.0F;
    }

    /* End of Switch: '<S3479>/Switch1' */

    /* Sum: '<S3424>/Sum7' */
    rtb_Sum7_l = rtb_Switch2_mkk - rtb_Switch10;

    /* Switch: '<S3425>/Switch1' incorporates:
     *  Constant: '<S3428>/Calib'
     *  Constant: '<S3429>/Calib'
     *  Constant: '<S3430>/Calib'
     *  Switch: '<S3426>/Switch1'
     *  Switch: '<S3427>/Switch1'
     */
    if (KeTHMR_b_MtrAPwrDerate)
    {
        /* Switch: '<S3423>/Switch2' */
        if (THMR_ac_B.VeTHMR_b_HvHrnMtrAPowerLimit)
        {
            /* Outputs for Atomic SubSystem: '<S3423>/Limiter3' */
            /* Switch: '<S3456>/Switch1' incorporates:
             *  RelationalOperator: '<S3456>/RelationalOperator'
             */
            if (rtb_product_e < rtb_Sum7_fy)
            {
                /* Switch: '<S3456>/Switch1' */
                rtb_TmpSignalConversionAtVeFC_f = rtb_product_e;
            }
            else
            {
                /* Switch: '<S3456>/Switch1' */
                rtb_TmpSignalConversionAtVeFC_f = rtb_Sum7_fy;
            }

            /* End of Switch: '<S3456>/Switch1' */

            /* Switch: '<S3456>/Switch' incorporates:
             *  RelationalOperator: '<S3456>/RelationalOperator1'
             */
            if (rtb_TmpSignalConversionAtVeFC_f <= rtb_product1_p)
            {
                /* Switch: '<S3456>/Switch' */
                rtb_TmpSignalConversionAtVeFC_f = rtb_product1_p;
            }

            /* End of Switch: '<S3456>/Switch' */
            /* End of Outputs for SubSystem: '<S3423>/Limiter3' */

            /* Outputs for Atomic SubSystem: '<S3423>/ProtectedDivision' */
            /* Switch: '<S3458>/Switch1' incorporates:
             *  Constant: '<S3447>/Calib'
             *  Constant: '<S3458>/ConstantValue'
             *  Constant: '<S3458>/ConstantValue1'
             *  Constant: '<S3458>/ConstantValue2'
             *  Constant: '<S3458>/ConstantValue3'
             *  Logic: '<S3458>/AND'
             *  RelationalOperator: '<S3458>/GreaterThanorEqual'
             *  RelationalOperator: '<S3458>/GreaterThanorEqual1'
             *  RelationalOperator: '<S3458>/NotEqual'
             *  RelationalOperator: '<S3458>/NotEqual1'
             *  Switch: '<S3458>/Switch2'
             *  Switch: '<S3458>/Switch3'
             */
            if ((rtb_TmpSignalConversionAtVeFC_f != 0.0F) &&
                    (KeTHMR_P_MtrAPowerLimit != 0.0F))
            {
                /* Switch: '<S3425>/Switch1' incorporates:
                 *  Product: '<S3458>/Division'
                 *  Switch: '<S3458>/Switch1'
                 */
                THMR_ac_B.Switch1_f = rtb_TmpSignalConversionAtVeFC_f /
                    KeTHMR_P_MtrAPowerLimit;
            }
            else if (rtb_TmpSignalConversionAtVeFC_f > 0.0F)
            {
                /* Switch: '<S3458>/Switch2' incorporates:
                 *  Constant: '<S3458>/MAXFLOAT'
                 *  Switch: '<S3425>/Switch1'
                 *  Switch: '<S3458>/Switch1'
                 */
                THMR_ac_B.Switch1_f = 3.402823466E+38F;
            }
            else if (rtb_TmpSignalConversionAtVeFC_f < 0.0F)
            {
                /* Switch: '<S3458>/Switch3' incorporates:
                 *  Constant: '<S3458>/MINFLOAT'
                 *  Switch: '<S3425>/Switch1'
                 *  Switch: '<S3458>/Switch1'
                 *  Switch: '<S3458>/Switch2'
                 */
                THMR_ac_B.Switch1_f = -3.402823466E+38F;
            }
            else
            {
                /* Switch: '<S3425>/Switch1' incorporates:
                 *  Constant: '<S3458>/ConstantValue4'
                 *  Switch: '<S3458>/Switch1'
                 *  Switch: '<S3458>/Switch2'
                 *  Switch: '<S3458>/Switch3'
                 */
                THMR_ac_B.Switch1_f = 0.0F;
            }

            /* End of Switch: '<S3458>/Switch1' */
            /* End of Outputs for SubSystem: '<S3423>/ProtectedDivision' */
        }
        else
        {
            /* Switch: '<S3425>/Switch1' incorporates:
             *  Constant: '<S3423>/ConstantValue'
             *  Switch: '<S3423>/Switch2'
             */
            THMR_ac_B.Switch1_f = 1.0F;
        }

        /* End of Switch: '<S3423>/Switch2' */
    }
    else if (KeTHMR_b_MtrATorqueDerate)
    {
        /* Switch: '<S3424>/Switch2' incorporates:
         *  Switch: '<S3426>/Switch1'
         */
        if (THMR_ac_B.VeTHMR_b_HvHrnMtrAPowerLimit)
        {
            /* Outputs for Atomic SubSystem: '<S3424>/Limiter3' */
            /* Switch: '<S3475>/Switch1' incorporates:
             *  RelationalOperator: '<S3475>/RelationalOperator'
             */
            if (rtb_product_k < rtb_Sum7_l)
            {
                /* Switch: '<S3475>/Switch1' */
                rtb_TmpSignalConversionAtVeF_n4 = rtb_product_k;
            }
            else
            {
                /* Switch: '<S3475>/Switch1' */
                rtb_TmpSignalConversionAtVeF_n4 = rtb_Sum7_l;
            }

            /* End of Switch: '<S3475>/Switch1' */

            /* Switch: '<S3475>/Switch' incorporates:
             *  RelationalOperator: '<S3475>/RelationalOperator1'
             */
            if (rtb_TmpSignalConversionAtVeF_n4 <=
                    rtb_TmpSignalConversionAtVeFC_k)
            {
                /* Switch: '<S3475>/Switch' */
                rtb_TmpSignalConversionAtVeF_n4 =
                    rtb_TmpSignalConversionAtVeFC_k;
            }

            /* End of Switch: '<S3475>/Switch' */
            /* End of Outputs for SubSystem: '<S3424>/Limiter3' */

            /* Outputs for Atomic SubSystem: '<S3424>/ProtectedDivision' */
            /* Switch: '<S3477>/Switch1' incorporates:
             *  Constant: '<S3477>/ConstantValue'
             *  Constant: '<S3477>/ConstantValue1'
             *  Constant: '<S3477>/ConstantValue2'
             *  Constant: '<S3477>/ConstantValue3'
             *  Logic: '<S3477>/AND'
             *  RelationalOperator: '<S3477>/GreaterThanorEqual'
             *  RelationalOperator: '<S3477>/GreaterThanorEqual1'
             *  RelationalOperator: '<S3477>/NotEqual'
             *  RelationalOperator: '<S3477>/NotEqual1'
             *  Switch: '<S3477>/Switch2'
             *  Switch: '<S3477>/Switch3'
             */
            if ((rtb_TmpSignalConversionAtVeF_n4 != 0.0F) &&
                    (rtb_TmpSignalConversionAtVeFC_f != 0.0F))
            {
                /* Switch: '<S3425>/Switch1' incorporates:
                 *  Product: '<S3477>/Division'
                 *  Switch: '<S3477>/Switch1'
                 */
                THMR_ac_B.Switch1_f = rtb_TmpSignalConversionAtVeF_n4 /
                    rtb_TmpSignalConversionAtVeFC_f;
            }
            else if (rtb_TmpSignalConversionAtVeF_n4 > 0.0F)
            {
                /* Switch: '<S3477>/Switch2' incorporates:
                 *  Constant: '<S3477>/MAXFLOAT'
                 *  Switch: '<S3425>/Switch1'
                 *  Switch: '<S3477>/Switch1'
                 */
                THMR_ac_B.Switch1_f = 3.402823466E+38F;
            }
            else if (rtb_TmpSignalConversionAtVeF_n4 < 0.0F)
            {
                /* Switch: '<S3477>/Switch3' incorporates:
                 *  Constant: '<S3477>/MINFLOAT'
                 *  Switch: '<S3425>/Switch1'
                 *  Switch: '<S3477>/Switch1'
                 *  Switch: '<S3477>/Switch2'
                 */
                THMR_ac_B.Switch1_f = -3.402823466E+38F;
            }
            else
            {
                /* Switch: '<S3425>/Switch1' incorporates:
                 *  Constant: '<S3477>/ConstantValue4'
                 *  Switch: '<S3477>/Switch1'
                 *  Switch: '<S3477>/Switch2'
                 *  Switch: '<S3477>/Switch3'
                 */
                THMR_ac_B.Switch1_f = 0.0F;
            }

            /* End of Switch: '<S3477>/Switch1' */
            /* End of Outputs for SubSystem: '<S3424>/ProtectedDivision' */
        }
        else
        {
            /* Switch: '<S3425>/Switch1' incorporates:
             *  Constant: '<S3424>/ConstantValue'
             *  Switch: '<S3424>/Switch2'
             *  Switch: '<S3426>/Switch1'
             */
            THMR_ac_B.Switch1_f = 1.0F;
        }

        /* End of Switch: '<S3424>/Switch2' */
    }
    else if (KeTHMR_b_MtrAClassicDerate)
    {
        /* Switch: '<S3422>/Switch2' incorporates:
         *  Switch: '<S3426>/Switch1'
         *  Switch: '<S3427>/Switch1'
         */
        if (THMR_ac_B.VeTHMR_b_HvHrnMtrAPowerLimit)
        {
            /* Outputs for Atomic SubSystem: '<S3422>/Limiter3' */
            /* Switch: '<S3439>/Switch1' incorporates:
             *  MinMax: '<S3422>/MinMax2'
             *  RelationalOperator: '<S3439>/RelationalOperator'
             */
            if (rtb_Switch1_bhg < rtb_Switch1_ghr)
            {
                /* Switch: '<S3439>/Switch1' */
                rtb_TmpSignalConversionAtVeFC_f = rtb_Switch1_bhg;
            }
            else
            {
                /* Switch: '<S3439>/Switch1' */
                rtb_TmpSignalConversionAtVeFC_f = rtb_Switch1_ghr;
            }

            /* End of Switch: '<S3439>/Switch1' */

            /* Switch: '<S3439>/Switch' incorporates:
             *  MinMax: '<S3422>/MinMax4'
             *  RelationalOperator: '<S3439>/RelationalOperator1'
             */
            if (rtb_TmpSignalConversionAtVeFC_f > rtb_Switch1_iui)
            {
                /* Switch: '<S3425>/Switch1' incorporates:
                 *  Switch: '<S3422>/Switch2'
                 */
                THMR_ac_B.Switch1_f = rtb_TmpSignalConversionAtVeFC_f;
            }
            else
            {
                /* Switch: '<S3425>/Switch1' incorporates:
                 *  Switch: '<S3422>/Switch2'
                 */
                THMR_ac_B.Switch1_f = rtb_Switch1_iui;
            }

            /* End of Switch: '<S3439>/Switch' */
            /* End of Outputs for SubSystem: '<S3422>/Limiter3' */
        }
        else
        {
            /* Switch: '<S3425>/Switch1' incorporates:
             *  Constant: '<S3422>/ConstantValue'
             *  Switch: '<S3422>/Switch2'
             */
            THMR_ac_B.Switch1_f = 1.0F;
        }

        /* End of Switch: '<S3422>/Switch2' */
    }
    else
    {
        /* Switch: '<S3425>/Switch1' incorporates:
         *  Constant: '<S3409>/ConstantValue'
         *  Switch: '<S3426>/Switch1'
         *  Switch: '<S3427>/Switch1'
         */
        THMR_ac_B.Switch1_f = 1.0F;
    }

    /* End of Switch: '<S3425>/Switch1' */

    /* Update for UnitDelay: '<S3440>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ks = rtb_Switch1_ghr;

    /* Update for UnitDelay: '<S3440>/UnitDelay3' incorporates:
     *  MinMax: '<S3422>/MinMax4'
     */
    THMR_ac_DW.UnitDelay3_DSTATE_a = rtb_Switch1_iui;

    /* Update for UnitDelay: '<S3440>/UnitDelay2' incorporates:
     *  MinMax: '<S3422>/MinMax2'
     */
    THMR_ac_DW.UnitDelay2_DSTATE_ki = rtb_Switch1_bhg;

    /* Update for UnitDelay: '<S3445>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_fa = rtb_Switch1_bqc;

    /* Update for UnitDelay: '<S3446>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_p = rtb_Switch2_m5d;

    /* Update for UnitDelay: '<S3457>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_khi = rtb_Sum7_fy;

    /* Update for UnitDelay: '<S3457>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_pb = rtb_product1_p;

    /* Update for UnitDelay: '<S3457>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_g = rtb_product_e;

    /* Update for UnitDelay: '<S3464>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_o = rtb_Switch1_eih;

    /* Update for UnitDelay: '<S3465>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_au = rtb_Switch2_mkk;

    /* Update for UnitDelay: '<S3476>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_im = rtb_Sum7_l;

    /* Update for UnitDelay: '<S3476>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_e = rtb_TmpSignalConversionAtVeFC_k;

    /* Update for UnitDelay: '<S3476>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_pi = rtb_product_k;

    /* Update for UnitDelay: '<S3483>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_gm = rtb_TmpSignalConversionAtVeCSVR;

    /* End of Outputs for SubSystem: '<S2>/MotorA_Harness_Control' */
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

    /* Outputs for Function Call SubSystem: '<S2>/MotorB_Harness_Control' */
    /* Outputs for Atomic SubSystem: '<S3484>/Hysteresis_1' */
    /* Switch: '<S3486>/Switch1' incorporates:
     *  Constant: '<S3491>/Calib'
     *  RelationalOperator: '<S3486>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVaC_ls[0] >= KeTHMR_T_MtrBConCmpTempRSP2)
    {
        /* Switch: '<S3486>/Switch1' incorporates:
         *  Constant: '<S3486>/ConstantValue'
         */
        rtb_Switch1_bkm = true;
    }
    else
    {
        /* Switch: '<S3486>/Switch1' incorporates:
         *  Constant: '<S3489>/Calib'
         *  RelationalOperator: '<S3486>/GreaterThan1'
         *  UnitDelay: '<S3486>/UnitDelay'
         */
        rtb_Switch1_bkm = ((rtb_TmpSignalConversionAtVaC_ls[0] >
                            KeTHMR_T_MtrBConCmpTempLSP2) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_cow));
    }

    /* End of Switch: '<S3486>/Switch1' */

    /* Update for UnitDelay: '<S3486>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_cow = rtb_Switch1_bkm;

    /* End of Outputs for SubSystem: '<S3484>/Hysteresis_1' */

    /* Outputs for Atomic SubSystem: '<S3484>/Hysteresis_2' */
    /* Switch: '<S3487>/Switch1' incorporates:
     *  Constant: '<S3490>/Calib'
     *  RelationalOperator: '<S3487>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVaC_ls[1] >= KeTHMR_T_MtrBConCmpTempRSP1)
    {
        /* Switch: '<S3487>/Switch1' incorporates:
         *  Constant: '<S3487>/ConstantValue'
         */
        rtb_Switch1_abpr = true;
    }
    else
    {
        /* Switch: '<S3487>/Switch1' incorporates:
         *  Constant: '<S3488>/Calib'
         *  RelationalOperator: '<S3487>/GreaterThan1'
         *  UnitDelay: '<S3487>/UnitDelay'
         */
        rtb_Switch1_abpr = ((rtb_TmpSignalConversionAtVaC_ls[1] >
                             KeTHMR_T_MtrBConCmpTempLSP1) &&
                            (THMR_ac_DW.UnitDelay_DSTATE_eyd));
    }

    /* End of Switch: '<S3487>/Switch1' */

    /* Update for UnitDelay: '<S3487>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_eyd = rtb_Switch1_abpr;

    /* End of Outputs for SubSystem: '<S3484>/Hysteresis_2' */

    /* Logic: '<S3484>/Logical2' */
    THMR_ac_B.VeTHMR_b_HvHrnMtrBPowerLimit = (rtb_Switch1_bkm ||
        rtb_Switch1_abpr);

    /* MinMax: '<S3499>/MinMax2' incorporates:
     *  Lookup_n-D: '<S3514>/Vector'
     *  Lookup_n-D: '<S3515>/Vector'
     *  MinMax: '<S3498>/MinMax2'
     *  MinMax: '<S3500>/MinMax2'
     */
    rtb_Switch2_mkk = fminf(look1_iflf_binlcapw(rtb_TmpSignalConversionAtVaC_ls
        [0], ((const float32 *)&(KxTHMR_K_MaxMtrBConTemp2[0])), ((const float32 *)
        &(KtTHMR_K_MaxMtrBConTemp2[0])), 6U), look1_iflf_binlcapw
                            (rtb_TmpSignalConversionAtVaC_ls[1], ((const float32
        *)&(KxTHMR_K_MaxMtrBConTemp1[0])), ((const float32 *)
        &(KtTHMR_K_MaxMtrBConTemp1[0])), 6U));

    /* Product: '<S3499>/product' incorporates:
     *  Constant: '<S3513>/Calib'
     *  MinMax: '<S3499>/MinMax2'
     */
    rtb_product_k = rtb_Switch2_mkk * KeTHMR_P_MtrBPowerLimit;

    /* MinMax: '<S3499>/MinMax4' incorporates:
     *  Lookup_n-D: '<S3516>/Vector'
     *  Lookup_n-D: '<S3517>/Vector'
     *  MinMax: '<S3498>/MinMax4'
     *  MinMax: '<S3500>/MinMax4'
     */
    rtb_Switch2_m5d = fmaxf(look1_iflf_binlcapw(rtb_TmpSignalConversionAtVaC_ls
        [0], ((const float32 *)&(KxTHMR_K_MinMtrBConTemp2[0])), ((const float32 *)
        &(KtTHMR_K_MinMtrBConTemp2[0])), 6U), look1_iflf_binlcapw
                            (rtb_TmpSignalConversionAtVaC_ls[1], ((const float32
        *)&(KxTHMR_K_MinMtrBConTemp1[0])), ((const float32 *)
        &(KtTHMR_K_MinMtrBConTemp1[0])), 6U));

    /* Product: '<S3499>/product1' incorporates:
     *  Constant: '<S3513>/Calib'
     *  MinMax: '<S3499>/MinMax4'
     */
    rtb_product_e = rtb_Switch2_m5d * KeTHMR_P_MtrBPowerLimit;

    /* MinMax: '<S3499>/MinMax1' incorporates:
     *  MinMax: '<S3498>/MinMax1'
     *  MinMax: '<S3500>/MinMax1'
     *  Sum: '<S3499>/Sum1'
     *  Sum: '<S3499>/Sum4'
     */
    rtb_Switch1_iui = fmaxf(rtb_TmpSignalConversionAtVaC_ls[0] -
                            rtb_TmpSignalConversionAtVaCT_l[0],
                            rtb_TmpSignalConversionAtVaC_ls[1] -
                            rtb_TmpSignalConversionAtVaCT_l[1]);

    /* Switch: '<S3526>/Switch1' incorporates:
     *  Logic: '<S3519>/Logical1'
     *  Logic: '<S3519>/Logical3'
     *  RelationalOperator: '<S3519>/Comparison1'
     *  RelationalOperator: '<S3519>/Comparison2'
     *  Switch: '<S3523>/Switch1'
     *  UnitDelay: '<S3519>/UnitDelay'
     *  UnitDelay: '<S3519>/UnitDelay2'
     *  UnitDelay: '<S3519>/UnitDelay3'
     */
    if (!THMR_ac_B.VeTHMR_b_HvHrnMtrBPowerLimit)
    {
        /* Switch: '<S3526>/Switch1' incorporates:
         *  Constant: '<S3519>/ConstantValue4'
         */
        rtb_Switch1_bhg = 0.0F;
    }
    else
    {
        if ((THMR_ac_DW.UnitDelay_DSTATE_b4 < THMR_ac_DW.UnitDelay3_DSTATE_go) ||
            (THMR_ac_DW.UnitDelay_DSTATE_b4 >= THMR_ac_DW.UnitDelay2_DSTATE_e))
        {
            /* Switch: '<S3523>/Switch1' incorporates:
             *  Constant: '<S3519>/ConstantValue'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S3523>/Switch1' incorporates:
             *  Lookup_n-D: '<S3524>/Vector'
             *  MinMax: '<S3499>/MinMax1'
             *  Product: '<S3519>/Multiplication1'
             */
            rtb_Switch10 = rtb_Switch1_iui * look1_iflf_binlcapw(rtb_Switch1_iui,
                ((const float32 *)&(KxTHMR_K_KiMtrBCon[0])), ((const float32 *)
                &(KtTHMR_K_KiMtrBCon[0])), 6U);
        }

        /* Switch: '<S3526>/Switch1' incorporates:
         *  Product: '<S3526>/Product1'
         *  Sum: '<S3526>/Summation'
         *  UnitDelay: '<S3526>/UnitDelay1'
         */
        rtb_Switch1_bhg = (rtb_Switch10 + THMR_ac_DW.UnitDelay1_DSTATE_i) *
            0.05F;
    }

    /* End of Switch: '<S3526>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S3512>/EdgeRising1' */
    /* Logic: '<S3521>/OR1' incorporates:
     *  UnitDelay: '<S3521>/UnitDelay'
     */
    rtb_Switch1_bkm = !THMR_ac_DW.UnitDelay_DSTATE_kg;

    /* Update for UnitDelay: '<S3521>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kg = THMR_ac_B.VeTHMR_b_HvHrnMtrBPowerLimit;

    /* Switch: '<S3512>/Switch2' incorporates:
     *  Inport: '<Root>/VeINVR_I_MtrB_DC_Crnt'
     *  Inport: '<Root>/VeINVR_U_MtrB_DC_Volt'
     *  Logic: '<S3521>/AND'
     */
    if ((THMR_ac_B.VeTHMR_b_HvHrnMtrBPowerLimit) && rtb_Switch1_bkm)
    {
        (void)Rte_Read_VeINVR_I_MtrB_DC_Crnt_Value(&rtb_Switch2_kq);
        (void)Rte_Read_VeINVR_U_MtrB_DC_Volt_Value(&rtb_Sum7_f);

        /* Switch: '<S3512>/Switch2' incorporates:
         *  Abs: '<S3512>/Abs'
         *  Inport: '<Root>/VeINVR_I_MtrB_DC_Crnt'
         *  Inport: '<Root>/VeINVR_U_MtrB_DC_Volt'
         *  Product: '<S3499>/Product'
         */
        rtb_Switch2_kq = fabsf(rtb_Sum7_f * rtb_Switch2_kq);
    }
    else
    {
        /* Switch: '<S3512>/Switch2' incorporates:
         *  UnitDelay: '<S3512>/UnitDelay'
         */
        rtb_Switch2_kq = THMR_ac_DW.UnitDelay_DSTATE_hp;
    }

    /* End of Switch: '<S3512>/Switch2' */
    /* End of Outputs for SubSystem: '<S3512>/EdgeRising1' */
    /* End of Outputs for SubSystem: '<S2>/MotorB_Harness_Control' */

    /* Inport: '<Root>/VeMTIR_M_MtrB_MinTorqRaw' */
    (void)Rte_Read_VeMTIR_M_MtrB_MinTorqRaw_Value(&rtb_product_c);

    /* Inport: '<Root>/VeMTIR_M_MtrB_MaxTorqRaw' */
    (void)Rte_Read_VeMTIR_M_MtrB_MaxTorqRaw_Value(&rtb_product1_n);

    /* Outputs for Function Call SubSystem: '<S2>/MotorB_Harness_Control' */
    /* Switch: '<S3522>/Switch1' incorporates:
     *  Constant: '<S3519>/ConstantValue3'
     *  Lookup_n-D: '<S3525>/Vector'
     *  MinMax: '<S3499>/MinMax1'
     *  Product: '<S3519>/proportional_term'
     *  Sum: '<S3519>/Sum//Sub1'
     */
    if (THMR_ac_B.VeTHMR_b_HvHrnMtrBPowerLimit)
    {
        rtb_Switch10 = (look1_iflf_binlcapw(rtb_Switch1_iui, ((const float32 *)
                          &(KxTHMR_K_KpMtrBCon[0])), ((const float32 *)
                          &(KtTHMR_K_KpMtrBCon[0])), 6U) * rtb_Switch1_iui) +
            rtb_Switch1_bhg;
    }
    else
    {
        rtb_Switch10 = 0.0F;
    }

    /* End of Switch: '<S3522>/Switch1' */

    /* Sum: '<S3499>/Sum7' */
    rtb_Sum7_f = rtb_Switch2_kq - rtb_Switch10;

    /* Switch: '<S3528>/Switch1' incorporates:
     *  Constant: '<S3500>/ConstantValue2'
     *  RelationalOperator: '<S3500>/Comparison1'
     */
    if (VeTHMR_M_MtrB_TorqAchieved >= 0.0F)
    {
        rtb_product_c = rtb_product1_n;
    }

    /* End of Switch: '<S3528>/Switch1' */

    /* Abs: '<S3500>/Abs' */
    rtb_Switch1_eih = fabsf(rtb_product_c);

    /* Product: '<S3500>/product' */
    rtb_product_c = rtb_Switch2_mkk * rtb_Switch1_eih;

    /* Product: '<S3500>/product1' */
    rtb_product1_n = rtb_Switch2_m5d * rtb_Switch1_eih;

    /* Switch: '<S3541>/Switch1' incorporates:
     *  Logic: '<S3534>/Logical1'
     *  Logic: '<S3534>/Logical3'
     *  RelationalOperator: '<S3534>/Comparison1'
     *  RelationalOperator: '<S3534>/Comparison2'
     *  Switch: '<S3538>/Switch1'
     *  UnitDelay: '<S3534>/UnitDelay'
     *  UnitDelay: '<S3534>/UnitDelay2'
     *  UnitDelay: '<S3534>/UnitDelay3'
     */
    if (!THMR_ac_B.VeTHMR_b_HvHrnMtrBPowerLimit)
    {
        /* Switch: '<S3541>/Switch1' incorporates:
         *  Constant: '<S3534>/ConstantValue4'
         */
        rtb_Switch1_bqc = 0.0F;
    }
    else
    {
        if ((THMR_ac_DW.UnitDelay_DSTATE_f < THMR_ac_DW.UnitDelay3_DSTATE_p) ||
                (THMR_ac_DW.UnitDelay_DSTATE_f >= THMR_ac_DW.UnitDelay2_DSTATE_p))
        {
            /* Switch: '<S3538>/Switch1' incorporates:
             *  Constant: '<S3534>/ConstantValue'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S3538>/Switch1' incorporates:
             *  Lookup_n-D: '<S3539>/Vector'
             *  Product: '<S3534>/Multiplication1'
             */
            rtb_Switch10 = rtb_Switch1_iui * look1_iflf_binlcapw(rtb_Switch1_iui,
                ((const float32 *)&(KxTHMR_K_KiMtrBCon[0])), ((const float32 *)
                &(KtTHMR_K_KiMtrBCon[0])), 6U);
        }

        /* Switch: '<S3541>/Switch1' incorporates:
         *  Product: '<S3541>/Product1'
         *  Sum: '<S3541>/Summation'
         *  UnitDelay: '<S3541>/UnitDelay1'
         */
        rtb_Switch1_bqc = (rtb_Switch10 + THMR_ac_DW.UnitDelay1_DSTATE_b) *
            0.05F;
    }

    /* End of Switch: '<S3541>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S3527>/EdgeRising1' */
    /* Logic: '<S3536>/OR1' incorporates:
     *  UnitDelay: '<S3536>/UnitDelay'
     */
    rtb_Switch1_bkm = !THMR_ac_DW.UnitDelay_DSTATE_bf;

    /* Update for UnitDelay: '<S3536>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_bf = THMR_ac_B.VeTHMR_b_HvHrnMtrBPowerLimit;

    /* Switch: '<S3527>/Switch2' incorporates:
     *  Logic: '<S3536>/AND'
     */
    if ((THMR_ac_B.VeTHMR_b_HvHrnMtrBPowerLimit) && rtb_Switch1_bkm)
    {
        /* Switch: '<S3527>/Switch2' incorporates:
         *  Abs: '<S3527>/Abs'
         */
        rtb_Switch1_ghr = fabsf(VeTHMR_M_MtrB_TorqAchieved);
    }
    else
    {
        /* Switch: '<S3527>/Switch2' incorporates:
         *  UnitDelay: '<S3527>/UnitDelay'
         */
        rtb_Switch1_ghr = THMR_ac_DW.UnitDelay_DSTATE_ai;
    }

    /* End of Switch: '<S3527>/Switch2' */
    /* End of Outputs for SubSystem: '<S3527>/EdgeRising1' */

    /* Switch: '<S3537>/Switch1' incorporates:
     *  Constant: '<S3534>/ConstantValue3'
     *  Lookup_n-D: '<S3540>/Vector'
     *  Product: '<S3534>/proportional_term'
     *  Sum: '<S3534>/Sum//Sub1'
     */
    if (THMR_ac_B.VeTHMR_b_HvHrnMtrBPowerLimit)
    {
        rtb_Switch10 = (look1_iflf_binlcapw(rtb_Switch1_iui, ((const float32 *)
                          &(KxTHMR_K_KpMtrBCon[0])), ((const float32 *)
                          &(KtTHMR_K_KpMtrBCon[0])), 6U) * rtb_Switch1_iui) +
            rtb_Switch1_bqc;
    }
    else
    {
        rtb_Switch10 = 0.0F;
    }

    /* End of Switch: '<S3537>/Switch1' */

    /* Sum: '<S3500>/Sum7' */
    rtb_product1_p = rtb_Switch1_ghr - rtb_Switch10;

    /* Switch: '<S3511>/Switch1' incorporates:
     *  Logic: '<S3506>/Logical1'
     *  Logic: '<S3506>/Logical3'
     *  RelationalOperator: '<S3506>/Comparison1'
     *  RelationalOperator: '<S3506>/Comparison2'
     *  Switch: '<S3508>/Switch1'
     *  UnitDelay: '<S3506>/UnitDelay'
     *  UnitDelay: '<S3506>/UnitDelay2'
     *  UnitDelay: '<S3506>/UnitDelay3'
     */
    if (!THMR_ac_B.VeTHMR_b_HvHrnMtrBPowerLimit)
    {
        /* Switch: '<S3511>/Switch1' incorporates:
         *  Constant: '<S3506>/ConstantValue4'
         */
        rtb_Sum7_fy = 0.0F;
    }
    else
    {
        if ((THMR_ac_DW.UnitDelay_DSTATE_ej < THMR_ac_DW.UnitDelay3_DSTATE_k) ||
            (THMR_ac_DW.UnitDelay_DSTATE_ej >= THMR_ac_DW.UnitDelay2_DSTATE_h))
        {
            /* Switch: '<S3508>/Switch1' incorporates:
             *  Constant: '<S3506>/ConstantValue'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S3508>/Switch1' incorporates:
             *  Lookup_n-D: '<S3509>/Vector'
             *  Product: '<S3506>/Multiplication1'
             */
            rtb_Switch10 = rtb_Switch1_iui * look1_iflf_binlcapw(rtb_Switch1_iui,
                ((const float32 *)&(KxTHMR_K_KiMtrBCon[0])), ((const float32 *)
                &(KtTHMR_K_KiMtrBCon[0])), 6U);
        }

        /* Switch: '<S3511>/Switch1' incorporates:
         *  Product: '<S3511>/Product1'
         *  Sum: '<S3511>/Summation'
         *  UnitDelay: '<S3511>/UnitDelay1'
         */
        rtb_Sum7_fy = (rtb_Switch10 + THMR_ac_DW.UnitDelay1_DSTATE_d) * 0.05F;
    }

    /* End of Switch: '<S3511>/Switch1' */

    /* Switch: '<S3507>/Switch1' */
    if (THMR_ac_B.VeTHMR_b_HvHrnMtrBPowerLimit)
    {
        /* Switch: '<S3507>/Switch1' incorporates:
         *  Lookup_n-D: '<S3510>/Vector'
         *  Product: '<S3506>/proportional_term'
         *  Sum: '<S3506>/Sum//Sub1'
         */
        rtb_Switch1_iui = (look1_iflf_binlcapw(rtb_Switch1_iui, ((const float32 *)
                             &(KxTHMR_K_KpMtrBCon[0])), ((const float32 *)
                             &(KtTHMR_K_KpMtrBCon[0])), 6U) * rtb_Switch1_iui) +
            rtb_Sum7_fy;
    }
    else
    {
        /* Switch: '<S3507>/Switch1' incorporates:
         *  Constant: '<S3506>/ConstantValue3'
         */
        rtb_Switch1_iui = 1.0F;
    }

    /* End of Switch: '<S3507>/Switch1' */

    /* Switch: '<S3492>/Switch1' incorporates:
     *  Constant: '<S3495>/Calib'
     *  Constant: '<S3496>/Calib'
     *  Constant: '<S3497>/Calib'
     *  Switch: '<S3493>/Switch1'
     *  Switch: '<S3494>/Switch1'
     */
    if (KeTHMR_b_MtrBPwrDerate)
    {
        /* Switch: '<S3499>/Switch2' */
        if (THMR_ac_B.VeTHMR_b_HvHrnMtrBPowerLimit)
        {
            /* Outputs for Atomic SubSystem: '<S3499>/Limiter3' */
            /* Switch: '<S3518>/Switch1' incorporates:
             *  RelationalOperator: '<S3518>/RelationalOperator'
             */
            if (rtb_product_k < rtb_Sum7_f)
            {
                /* Switch: '<S3518>/Switch1' */
                rtb_Switch1_eih = rtb_product_k;
            }
            else
            {
                /* Switch: '<S3518>/Switch1' */
                rtb_Switch1_eih = rtb_Sum7_f;
            }

            /* End of Switch: '<S3518>/Switch1' */

            /* Switch: '<S3518>/Switch' incorporates:
             *  RelationalOperator: '<S3518>/RelationalOperator1'
             */
            if (rtb_Switch1_eih <= rtb_product_e)
            {
                /* Switch: '<S3518>/Switch' */
                rtb_Switch1_eih = rtb_product_e;
            }

            /* End of Switch: '<S3518>/Switch' */
            /* End of Outputs for SubSystem: '<S3499>/Limiter3' */

            /* Outputs for Atomic SubSystem: '<S3499>/ProtectedDivision' */
            /* Switch: '<S3520>/Switch1' incorporates:
             *  Constant: '<S3513>/Calib'
             *  Constant: '<S3520>/ConstantValue'
             *  Constant: '<S3520>/ConstantValue1'
             *  Constant: '<S3520>/ConstantValue2'
             *  Constant: '<S3520>/ConstantValue3'
             *  Logic: '<S3520>/AND'
             *  RelationalOperator: '<S3520>/GreaterThanorEqual'
             *  RelationalOperator: '<S3520>/GreaterThanorEqual1'
             *  RelationalOperator: '<S3520>/NotEqual'
             *  RelationalOperator: '<S3520>/NotEqual1'
             *  Switch: '<S3520>/Switch2'
             *  Switch: '<S3520>/Switch3'
             */
            if ((rtb_Switch1_eih != 0.0F) && (KeTHMR_P_MtrBPowerLimit != 0.0F))
            {
                /* Switch: '<S3492>/Switch1' incorporates:
                 *  Product: '<S3520>/Division'
                 *  Switch: '<S3520>/Switch1'
                 */
                THMR_ac_B.Switch1_a = rtb_Switch1_eih / KeTHMR_P_MtrBPowerLimit;
            }
            else if (rtb_Switch1_eih > 0.0F)
            {
                /* Switch: '<S3520>/Switch2' incorporates:
                 *  Constant: '<S3520>/MAXFLOAT'
                 *  Switch: '<S3492>/Switch1'
                 *  Switch: '<S3520>/Switch1'
                 */
                THMR_ac_B.Switch1_a = 3.402823466E+38F;
            }
            else if (rtb_Switch1_eih < 0.0F)
            {
                /* Switch: '<S3520>/Switch3' incorporates:
                 *  Constant: '<S3520>/MINFLOAT'
                 *  Switch: '<S3492>/Switch1'
                 *  Switch: '<S3520>/Switch1'
                 *  Switch: '<S3520>/Switch2'
                 */
                THMR_ac_B.Switch1_a = -3.402823466E+38F;
            }
            else
            {
                /* Switch: '<S3492>/Switch1' incorporates:
                 *  Constant: '<S3520>/ConstantValue4'
                 *  Switch: '<S3520>/Switch1'
                 *  Switch: '<S3520>/Switch2'
                 *  Switch: '<S3520>/Switch3'
                 */
                THMR_ac_B.Switch1_a = 0.0F;
            }

            /* End of Switch: '<S3520>/Switch1' */
            /* End of Outputs for SubSystem: '<S3499>/ProtectedDivision' */
        }
        else
        {
            /* Switch: '<S3492>/Switch1' incorporates:
             *  Constant: '<S3499>/ConstantValue'
             *  Switch: '<S3499>/Switch2'
             */
            THMR_ac_B.Switch1_a = 1.0F;
        }

        /* End of Switch: '<S3499>/Switch2' */
    }
    else if (KeTHMR_b_MtrBTorqueDerate)
    {
        /* Switch: '<S3500>/Switch2' incorporates:
         *  Switch: '<S3493>/Switch1'
         */
        if (THMR_ac_B.VeTHMR_b_HvHrnMtrBPowerLimit)
        {
            /* Outputs for Atomic SubSystem: '<S3500>/Limiter3' */
            /* Switch: '<S3533>/Switch1' incorporates:
             *  RelationalOperator: '<S3533>/RelationalOperator'
             */
            if (rtb_product_c < rtb_product1_p)
            {
                /* Switch: '<S3533>/Switch1' */
                rtb_Sum7_l = rtb_product_c;
            }
            else
            {
                /* Switch: '<S3533>/Switch1' */
                rtb_Sum7_l = rtb_product1_p;
            }

            /* End of Switch: '<S3533>/Switch1' */

            /* Switch: '<S3533>/Switch' incorporates:
             *  RelationalOperator: '<S3533>/RelationalOperator1'
             */
            if (rtb_Sum7_l <= rtb_product1_n)
            {
                /* Switch: '<S3533>/Switch' */
                rtb_Sum7_l = rtb_product1_n;
            }

            /* End of Switch: '<S3533>/Switch' */
            /* End of Outputs for SubSystem: '<S3500>/Limiter3' */

            /* Outputs for Atomic SubSystem: '<S3500>/ProtectedDivision' */
            /* Switch: '<S3535>/Switch1' incorporates:
             *  Constant: '<S3535>/ConstantValue'
             *  Constant: '<S3535>/ConstantValue1'
             *  Constant: '<S3535>/ConstantValue2'
             *  Constant: '<S3535>/ConstantValue3'
             *  Logic: '<S3535>/AND'
             *  RelationalOperator: '<S3535>/GreaterThanorEqual'
             *  RelationalOperator: '<S3535>/GreaterThanorEqual1'
             *  RelationalOperator: '<S3535>/NotEqual'
             *  RelationalOperator: '<S3535>/NotEqual1'
             *  Switch: '<S3535>/Switch2'
             *  Switch: '<S3535>/Switch3'
             */
            if ((rtb_Sum7_l != 0.0F) && (rtb_Switch1_eih != 0.0F))
            {
                /* Switch: '<S3492>/Switch1' incorporates:
                 *  Product: '<S3535>/Division'
                 *  Switch: '<S3535>/Switch1'
                 */
                THMR_ac_B.Switch1_a = rtb_Sum7_l / rtb_Switch1_eih;
            }
            else if (rtb_Sum7_l > 0.0F)
            {
                /* Switch: '<S3535>/Switch2' incorporates:
                 *  Constant: '<S3535>/MAXFLOAT'
                 *  Switch: '<S3492>/Switch1'
                 *  Switch: '<S3535>/Switch1'
                 */
                THMR_ac_B.Switch1_a = 3.402823466E+38F;
            }
            else if (rtb_Sum7_l < 0.0F)
            {
                /* Switch: '<S3535>/Switch3' incorporates:
                 *  Constant: '<S3535>/MINFLOAT'
                 *  Switch: '<S3492>/Switch1'
                 *  Switch: '<S3535>/Switch1'
                 *  Switch: '<S3535>/Switch2'
                 */
                THMR_ac_B.Switch1_a = -3.402823466E+38F;
            }
            else
            {
                /* Switch: '<S3492>/Switch1' incorporates:
                 *  Constant: '<S3535>/ConstantValue4'
                 *  Switch: '<S3535>/Switch1'
                 *  Switch: '<S3535>/Switch2'
                 *  Switch: '<S3535>/Switch3'
                 */
                THMR_ac_B.Switch1_a = 0.0F;
            }

            /* End of Switch: '<S3535>/Switch1' */
            /* End of Outputs for SubSystem: '<S3500>/ProtectedDivision' */
        }
        else
        {
            /* Switch: '<S3492>/Switch1' incorporates:
             *  Constant: '<S3500>/ConstantValue'
             *  Switch: '<S3493>/Switch1'
             *  Switch: '<S3500>/Switch2'
             */
            THMR_ac_B.Switch1_a = 1.0F;
        }

        /* End of Switch: '<S3500>/Switch2' */
    }
    else if (KeTHMR_b_MtrBClassicDerate)
    {
        /* Switch: '<S3498>/Switch2' incorporates:
         *  Switch: '<S3493>/Switch1'
         *  Switch: '<S3494>/Switch1'
         */
        if (THMR_ac_B.VeTHMR_b_HvHrnMtrBPowerLimit)
        {
            /* Outputs for Atomic SubSystem: '<S3498>/Limiter3' */
            /* Switch: '<S3505>/Switch1' incorporates:
             *  RelationalOperator: '<S3505>/RelationalOperator'
             */
            if (rtb_Switch2_mkk < rtb_Switch1_iui)
            {
                /* Switch: '<S3505>/Switch1' */
                rtb_Switch1_eih = rtb_Switch2_mkk;
            }
            else
            {
                /* Switch: '<S3505>/Switch1' */
                rtb_Switch1_eih = rtb_Switch1_iui;
            }

            /* End of Switch: '<S3505>/Switch1' */

            /* Switch: '<S3505>/Switch' incorporates:
             *  RelationalOperator: '<S3505>/RelationalOperator1'
             */
            if (rtb_Switch1_eih > rtb_Switch2_m5d)
            {
                /* Switch: '<S3492>/Switch1' incorporates:
                 *  Switch: '<S3498>/Switch2'
                 */
                THMR_ac_B.Switch1_a = rtb_Switch1_eih;
            }
            else
            {
                /* Switch: '<S3492>/Switch1' incorporates:
                 *  Switch: '<S3498>/Switch2'
                 */
                THMR_ac_B.Switch1_a = rtb_Switch2_m5d;
            }

            /* End of Switch: '<S3505>/Switch' */
            /* End of Outputs for SubSystem: '<S3498>/Limiter3' */
        }
        else
        {
            /* Switch: '<S3492>/Switch1' incorporates:
             *  Constant: '<S3498>/ConstantValue'
             *  Switch: '<S3498>/Switch2'
             */
            THMR_ac_B.Switch1_a = 1.0F;
        }

        /* End of Switch: '<S3498>/Switch2' */
    }
    else
    {
        /* Switch: '<S3492>/Switch1' incorporates:
         *  Constant: '<S3485>/ConstantValue'
         *  Switch: '<S3493>/Switch1'
         *  Switch: '<S3494>/Switch1'
         */
        THMR_ac_B.Switch1_a = 1.0F;
    }

    /* End of Switch: '<S3492>/Switch1' */

    /* Update for UnitDelay: '<S3519>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_b4 = rtb_Sum7_f;

    /* Update for UnitDelay: '<S3519>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_go = rtb_product_e;

    /* Update for UnitDelay: '<S3519>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_e = rtb_product_k;

    /* Update for UnitDelay: '<S3526>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_i = rtb_Switch1_bhg;

    /* Update for UnitDelay: '<S3512>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_hp = rtb_Switch2_kq;

    /* Update for UnitDelay: '<S3534>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_f = rtb_product1_p;

    /* Update for UnitDelay: '<S3534>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_p = rtb_product1_n;

    /* Update for UnitDelay: '<S3534>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_p = rtb_product_c;

    /* Update for UnitDelay: '<S3541>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_b = rtb_Switch1_bqc;

    /* Update for UnitDelay: '<S3527>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ai = rtb_Switch1_ghr;

    /* Update for UnitDelay: '<S3506>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ej = rtb_Switch1_iui;

    /* Update for UnitDelay: '<S3506>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_k = rtb_Switch2_m5d;

    /* Update for UnitDelay: '<S3506>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_h = rtb_Switch2_mkk;

    /* Update for UnitDelay: '<S3511>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_d = rtb_Sum7_fy;

    /* End of Outputs for SubSystem: '<S2>/MotorB_Harness_Control' */
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    /* Outputs for Function Call SubSystem: '<S2>/MotorC_Harness_Control' */
    /* Outputs for Atomic SubSystem: '<S3542>/Hysteresis_1' */
    /* Switch: '<S3544>/Switch1' incorporates:
     *  Constant: '<S3549>/Calib'
     *  RelationalOperator: '<S3544>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVaCTMR[0] >= KeTHMR_T_MtrCConCmpTempRSP2)
    {
        /* Switch: '<S3544>/Switch1' incorporates:
         *  Constant: '<S3544>/ConstantValue'
         */
        rtb_Switch1_bkm = true;
    }
    else
    {
        /* Switch: '<S3544>/Switch1' incorporates:
         *  Constant: '<S3547>/Calib'
         *  RelationalOperator: '<S3544>/GreaterThan1'
         *  UnitDelay: '<S3544>/UnitDelay'
         */
        rtb_Switch1_bkm = ((rtb_TmpSignalConversionAtVaCTMR[0] >
                            KeTHMR_T_MtrCConCmpTempLSP2) &&
                           (THMR_ac_DW.UnitDelay_DSTATE_io));
    }

    /* End of Switch: '<S3544>/Switch1' */

    /* Update for UnitDelay: '<S3544>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_io = rtb_Switch1_bkm;

    /* End of Outputs for SubSystem: '<S3542>/Hysteresis_1' */

    /* Outputs for Atomic SubSystem: '<S3542>/Hysteresis_2' */
    /* Switch: '<S3545>/Switch1' incorporates:
     *  Constant: '<S3548>/Calib'
     *  RelationalOperator: '<S3545>/GreaterThan'
     */
    if (rtb_TmpSignalConversionAtVaCTMR[1] >= KeTHMR_T_MtrCConCmpTempRSP1)
    {
        /* Switch: '<S3545>/Switch1' incorporates:
         *  Constant: '<S3545>/ConstantValue'
         */
        rtb_Switch1_abpr = true;
    }
    else
    {
        /* Switch: '<S3545>/Switch1' incorporates:
         *  Constant: '<S3546>/Calib'
         *  RelationalOperator: '<S3545>/GreaterThan1'
         *  UnitDelay: '<S3545>/UnitDelay'
         */
        rtb_Switch1_abpr = ((rtb_TmpSignalConversionAtVaCTMR[1] >
                             KeTHMR_T_MtrCConCmpTempLSP1) &&
                            (THMR_ac_DW.UnitDelay_DSTATE_msa));
    }

    /* End of Switch: '<S3545>/Switch1' */

    /* Update for UnitDelay: '<S3545>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_msa = rtb_Switch1_abpr;

    /* End of Outputs for SubSystem: '<S3542>/Hysteresis_2' */

    /* Logic: '<S3542>/Logical2' */
    THMR_ac_B.VeTHMR_b_HvHrnMtrCPowerLimit = (rtb_Switch1_bkm ||
        rtb_Switch1_abpr);

    /* MinMax: '<S3558>/MinMax2' incorporates:
     *  Lookup_n-D: '<S3587>/Vector'
     *  Lookup_n-D: '<S3588>/Vector'
     *  MinMax: '<S3556>/MinMax2'
     *  MinMax: '<S3557>/MinMax2'
     */
    rtb_product_c = fminf(look1_iflf_binlcapw(rtb_TmpSignalConversionAtVaCTMR[0],
                           ((const float32 *)&(KxTHMR_K_MaxMtrCConTemp2[0])), ((
        const float32 *)&(KtTHMR_K_MaxMtrCConTemp2[0])), 6U),
                          look1_iflf_binlcapw(rtb_TmpSignalConversionAtVaCTMR[1],
                           ((const float32 *)&(KxTHMR_K_MaxMtrCConTemp1[0])), ((
        const float32 *)&(KtTHMR_K_MaxMtrCConTemp1[0])), 6U));

    /* Product: '<S3558>/product' incorporates:
     *  Constant: '<S3586>/Calib'
     *  MinMax: '<S3558>/MinMax2'
     */
    rtb_product1_n = rtb_product_c * KeTHMR_P_MtrCPowerLimit;

    /* MinMax: '<S3558>/MinMax4' incorporates:
     *  Lookup_n-D: '<S3589>/Vector'
     *  Lookup_n-D: '<S3590>/Vector'
     *  MinMax: '<S3556>/MinMax4'
     *  MinMax: '<S3557>/MinMax4'
     */
    rtb_Switch2_kq = fmaxf(look1_iflf_binlcapw(rtb_TmpSignalConversionAtVaCTMR[0],
                            ((const float32 *)&(KxTHMR_K_MinMtrCConTemp2[0])),
                            ((const float32 *)&(KtTHMR_K_MinMtrCConTemp2[0])),
                            6U), look1_iflf_binlcapw
                           (rtb_TmpSignalConversionAtVaCTMR[1], ((const float32 *)
        &(KxTHMR_K_MinMtrCConTemp1[0])), ((const float32 *)
        &(KtTHMR_K_MinMtrCConTemp1[0])), 6U));

    /* Product: '<S3558>/product1' incorporates:
     *  Constant: '<S3586>/Calib'
     *  MinMax: '<S3558>/MinMax4'
     */
    rtb_Sum7_f = rtb_Switch2_kq * KeTHMR_P_MtrCPowerLimit;

    /* MinMax: '<S3558>/MinMax1' incorporates:
     *  MinMax: '<S3556>/MinMax1'
     *  MinMax: '<S3557>/MinMax1'
     *  Sum: '<S3558>/Sum1'
     *  Sum: '<S3558>/Sum4'
     */
    rtb_product_k = fmaxf(rtb_TmpSignalConversionAtVaCTMR[0] -
                          rtb_TmpSignalConversionAtVaCT_o[0],
                          rtb_TmpSignalConversionAtVaCTMR[1] -
                          rtb_TmpSignalConversionAtVaCT_o[1]);

    /* Switch: '<S3599>/Switch1' incorporates:
     *  Logic: '<S3592>/Logical1'
     *  Logic: '<S3592>/Logical3'
     *  RelationalOperator: '<S3592>/Comparison1'
     *  RelationalOperator: '<S3592>/Comparison2'
     *  Switch: '<S3596>/Switch1'
     *  UnitDelay: '<S3592>/UnitDelay'
     *  UnitDelay: '<S3592>/UnitDelay2'
     *  UnitDelay: '<S3592>/UnitDelay3'
     */
    if (!THMR_ac_B.VeTHMR_b_HvHrnMtrCPowerLimit)
    {
        /* Switch: '<S3599>/Switch1' incorporates:
         *  Constant: '<S3592>/ConstantValue4'
         */
        rtb_Switch2_mkk = 0.0F;
    }
    else
    {
        if ((THMR_ac_DW.UnitDelay_DSTATE_n < THMR_ac_DW.UnitDelay3_DSTATE_b) ||
                (THMR_ac_DW.UnitDelay_DSTATE_n >= THMR_ac_DW.UnitDelay2_DSTATE_k))
        {
            /* Switch: '<S3596>/Switch1' incorporates:
             *  Constant: '<S3592>/ConstantValue'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S3596>/Switch1' incorporates:
             *  Lookup_n-D: '<S3597>/Vector'
             *  MinMax: '<S3558>/MinMax1'
             *  Product: '<S3592>/Multiplication1'
             */
            rtb_Switch10 = rtb_product_k * look1_iflf_binlcapw(rtb_product_k, ((
                const float32 *)&(KxTHMR_K_KiMtrCCon[0])), ((const float32 *)
                &(KtTHMR_K_KiMtrCCon[0])), 6U);
        }

        /* Switch: '<S3599>/Switch1' incorporates:
         *  Product: '<S3599>/Product1'
         *  Sum: '<S3599>/Summation'
         *  UnitDelay: '<S3599>/UnitDelay1'
         */
        rtb_Switch2_mkk = (rtb_Switch10 + THMR_ac_DW.UnitDelay1_DSTATE_f) *
            0.05F;
    }

    /* End of Switch: '<S3599>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S3585>/EdgeRising1' */
    /* Logic: '<S3594>/OR1' incorporates:
     *  UnitDelay: '<S3594>/UnitDelay'
     */
    rtb_Switch1_bkm = !THMR_ac_DW.UnitDelay_DSTATE_dq;

    /* Update for UnitDelay: '<S3594>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_dq = THMR_ac_B.VeTHMR_b_HvHrnMtrCPowerLimit;

    /* Switch: '<S3585>/Switch2' incorporates:
     *  Inport: '<Root>/VeINVR_I_MtrC_DC_Crnt'
     *  Inport: '<Root>/VeINVR_U_MtrC_DC_Volt'
     *  Logic: '<S3594>/AND'
     */
    if ((THMR_ac_B.VeTHMR_b_HvHrnMtrCPowerLimit) && rtb_Switch1_bkm)
    {
        (void)Rte_Read_VeINVR_I_MtrC_DC_Crnt_Value(&rtb_Switch2);
        (void)Rte_Read_VeINVR_U_MtrC_DC_Volt_Value(&rtb_Sum7);

        /* Switch: '<S3585>/Switch2' incorporates:
         *  Abs: '<S3585>/Abs'
         *  Inport: '<Root>/VeINVR_I_MtrC_DC_Crnt'
         *  Inport: '<Root>/VeINVR_U_MtrC_DC_Volt'
         *  Product: '<S3558>/Product'
         */
        rtb_Switch2 = fabsf(rtb_Sum7 * rtb_Switch2);
    }
    else
    {
        /* Switch: '<S3585>/Switch2' incorporates:
         *  UnitDelay: '<S3585>/UnitDelay'
         */
        rtb_Switch2 = THMR_ac_DW.UnitDelay_DSTATE_hd;
    }

    /* End of Switch: '<S3585>/Switch2' */
    /* End of Outputs for SubSystem: '<S3585>/EdgeRising1' */
    /* End of Outputs for SubSystem: '<S2>/MotorC_Harness_Control' */

    /* Inport: '<Root>/VeMTIR_M_MtrC_MinTorqRaw' */
    (void)Rte_Read_VeMTIR_M_MtrC_MinTorqRaw_Value(&rtb_product_ft);

    /* Inport: '<Root>/VeMTIR_M_MtrC_MaxTorqRaw' */
    (void)Rte_Read_VeMTIR_M_MtrC_MaxTorqRaw_Value(&rtb_product1_i);

    /* Outputs for Function Call SubSystem: '<S2>/MotorC_Harness_Control' */
    /* Switch: '<S3595>/Switch1' incorporates:
     *  Constant: '<S3592>/ConstantValue3'
     *  Lookup_n-D: '<S3598>/Vector'
     *  MinMax: '<S3558>/MinMax1'
     *  Product: '<S3592>/proportional_term'
     *  Sum: '<S3592>/Sum//Sub1'
     */
    if (THMR_ac_B.VeTHMR_b_HvHrnMtrCPowerLimit)
    {
        rtb_Switch10 = (look1_iflf_binlcapw(rtb_product_k, ((const float32 *)
                          &(KxTHMR_K_KpMtrCCon[0])), ((const float32 *)
                          &(KtTHMR_K_KpMtrCCon[0])), 6U) * rtb_product_k) +
            rtb_Switch2_mkk;
    }
    else
    {
        rtb_Switch10 = 0.0F;
    }

    /* End of Switch: '<S3595>/Switch1' */

    /* Sum: '<S3558>/Sum7' */
    rtb_Sum7 = rtb_Switch2 - rtb_Switch10;

    /* Switch: '<S3560>/Switch1' incorporates:
     *  Constant: '<S3556>/ConstantValue2'
     *  RelationalOperator: '<S3556>/Comparison1'
     */
    if (rtb_TmpSignalConversionAtVeTHMR >= 0.0F)
    {
        rtb_product_ft = rtb_product1_i;
    }

    /* End of Switch: '<S3560>/Switch1' */

    /* Abs: '<S3556>/Abs' */
    rtb_product_e = fabsf(rtb_product_ft);

    /* Product: '<S3556>/product' */
    rtb_product_ft = rtb_product_c * rtb_product_e;

    /* Product: '<S3556>/product1' */
    rtb_product1_i = rtb_Switch2_kq * rtb_product_e;

    /* Switch: '<S3573>/Switch1' incorporates:
     *  Logic: '<S3566>/Logical1'
     *  Logic: '<S3566>/Logical3'
     *  RelationalOperator: '<S3566>/Comparison1'
     *  RelationalOperator: '<S3566>/Comparison2'
     *  Switch: '<S3570>/Switch1'
     *  UnitDelay: '<S3566>/UnitDelay'
     *  UnitDelay: '<S3566>/UnitDelay2'
     *  UnitDelay: '<S3566>/UnitDelay3'
     */
    if (!THMR_ac_B.VeTHMR_b_HvHrnMtrCPowerLimit)
    {
        /* Switch: '<S3573>/Switch1' incorporates:
         *  Constant: '<S3566>/ConstantValue4'
         */
        rtb_Switch2_m5d = 0.0F;
    }
    else
    {
        if ((THMR_ac_DW.UnitDelay_DSTATE_ha < THMR_ac_DW.UnitDelay3_DSTATE_g) ||
            (THMR_ac_DW.UnitDelay_DSTATE_ha >= THMR_ac_DW.UnitDelay2_DSTATE_c))
        {
            /* Switch: '<S3570>/Switch1' incorporates:
             *  Constant: '<S3566>/ConstantValue'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S3570>/Switch1' incorporates:
             *  Lookup_n-D: '<S3571>/Vector'
             *  Product: '<S3566>/Multiplication1'
             */
            rtb_Switch10 = rtb_product_k * look1_iflf_binlcapw(rtb_product_k, ((
                const float32 *)&(KxTHMR_K_KiMtrCCon[0])), ((const float32 *)
                &(KtTHMR_K_KiMtrCCon[0])), 6U);
        }

        /* Switch: '<S3573>/Switch1' incorporates:
         *  Product: '<S3573>/Product1'
         *  Sum: '<S3573>/Summation'
         *  UnitDelay: '<S3573>/UnitDelay1'
         */
        rtb_Switch2_m5d = (rtb_Switch10 + THMR_ac_DW.UnitDelay1_DSTATE_g) *
            0.05F;
    }

    /* End of Switch: '<S3573>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S3559>/EdgeRising1' */
    /* Logic: '<S3568>/OR1' incorporates:
     *  UnitDelay: '<S3568>/UnitDelay'
     */
    rtb_Switch1_bkm = !THMR_ac_DW.UnitDelay_DSTATE_bi;

    /* Update for UnitDelay: '<S3568>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_bi = THMR_ac_B.VeTHMR_b_HvHrnMtrCPowerLimit;

    /* Switch: '<S3559>/Switch2' incorporates:
     *  Logic: '<S3568>/AND'
     */
    if ((THMR_ac_B.VeTHMR_b_HvHrnMtrCPowerLimit) && rtb_Switch1_bkm)
    {
        /* Switch: '<S3559>/Switch2' incorporates:
         *  Abs: '<S3556>/Abs1'
         */
        rtb_TmpSignalConversionAtVeTHMR = fabsf(rtb_TmpSignalConversionAtVeTHMR);
    }
    else
    {
        /* Switch: '<S3559>/Switch2' incorporates:
         *  UnitDelay: '<S3559>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeTHMR = THMR_ac_DW.UnitDelay_DSTATE_nm;
    }

    /* End of Switch: '<S3559>/Switch2' */
    /* End of Outputs for SubSystem: '<S3559>/EdgeRising1' */

    /* Switch: '<S3569>/Switch1' incorporates:
     *  Constant: '<S3566>/ConstantValue3'
     *  Lookup_n-D: '<S3572>/Vector'
     *  Product: '<S3566>/proportional_term'
     *  Sum: '<S3566>/Sum//Sub1'
     */
    if (THMR_ac_B.VeTHMR_b_HvHrnMtrCPowerLimit)
    {
        rtb_Switch10 = (look1_iflf_binlcapw(rtb_product_k, ((const float32 *)
                          &(KxTHMR_K_KpMtrCCon[0])), ((const float32 *)
                          &(KtTHMR_K_KpMtrCCon[0])), 6U) * rtb_product_k) +
            rtb_Switch2_m5d;
    }
    else
    {
        rtb_Switch10 = 0.0F;
    }

    /* End of Switch: '<S3569>/Switch1' */

    /* Sum: '<S3556>/Sum7' */
    rtb_Switch1_bhg = rtb_TmpSignalConversionAtVeTHMR - rtb_Switch10;

    /* Switch: '<S3584>/Switch1' incorporates:
     *  Logic: '<S3579>/Logical1'
     *  Logic: '<S3579>/Logical3'
     *  RelationalOperator: '<S3579>/Comparison1'
     *  RelationalOperator: '<S3579>/Comparison2'
     *  Switch: '<S3581>/Switch1'
     *  UnitDelay: '<S3579>/UnitDelay'
     *  UnitDelay: '<S3579>/UnitDelay2'
     *  UnitDelay: '<S3579>/UnitDelay3'
     */
    if (!THMR_ac_B.VeTHMR_b_HvHrnMtrCPowerLimit)
    {
        /* Switch: '<S3584>/Switch1' incorporates:
         *  Constant: '<S3579>/ConstantValue4'
         */
        rtb_Switch1_iui = 0.0F;
    }
    else
    {
        if ((THMR_ac_DW.UnitDelay_DSTATE_ir < THMR_ac_DW.UnitDelay3_DSTATE_m) ||
            (THMR_ac_DW.UnitDelay_DSTATE_ir >= THMR_ac_DW.UnitDelay2_DSTATE_o))
        {
            /* Switch: '<S3581>/Switch1' incorporates:
             *  Constant: '<S3579>/ConstantValue'
             */
            rtb_Switch10 = 0.0F;
        }
        else
        {
            /* Switch: '<S3581>/Switch1' incorporates:
             *  Lookup_n-D: '<S3582>/Vector'
             *  Product: '<S3579>/Multiplication1'
             */
            rtb_Switch10 = rtb_product_k * look1_iflf_binlcapw(rtb_product_k, ((
                const float32 *)&(KxTHMR_K_KiMtrCCon[0])), ((const float32 *)
                &(KtTHMR_K_KiMtrCCon[0])), 6U);
        }

        /* Switch: '<S3584>/Switch1' incorporates:
         *  Product: '<S3584>/Product1'
         *  Sum: '<S3584>/Summation'
         *  UnitDelay: '<S3584>/UnitDelay1'
         */
        rtb_Switch1_iui = (rtb_Switch10 + THMR_ac_DW.UnitDelay1_DSTATE_l) *
            0.05F;
    }

    /* End of Switch: '<S3584>/Switch1' */

    /* Switch: '<S3580>/Switch1' */
    if (THMR_ac_B.VeTHMR_b_HvHrnMtrCPowerLimit)
    {
        /* Switch: '<S3580>/Switch1' incorporates:
         *  Lookup_n-D: '<S3583>/Vector'
         *  Product: '<S3579>/proportional_term'
         *  Sum: '<S3579>/Sum//Sub1'
         */
        rtb_product_k = (look1_iflf_binlcapw(rtb_product_k, ((const float32 *)
                           &(KxTHMR_K_KpMtrCCon[0])), ((const float32 *)
                           &(KtTHMR_K_KpMtrCCon[0])), 6U) * rtb_product_k) +
            rtb_Switch1_iui;
    }
    else
    {
        /* Switch: '<S3580>/Switch1' incorporates:
         *  Constant: '<S3579>/ConstantValue3'
         */
        rtb_product_k = 1.0F;
    }

    /* End of Switch: '<S3580>/Switch1' */

    /* Switch: '<S3550>/Switch1' incorporates:
     *  Constant: '<S3553>/Calib'
     *  Constant: '<S3554>/Calib'
     *  Constant: '<S3555>/Calib'
     *  Switch: '<S3551>/Switch1'
     *  Switch: '<S3552>/Switch1'
     */
    if (KeTHMR_b_MtrCPwrDerate)
    {
        /* Switch: '<S3558>/Switch2' */
        if (THMR_ac_B.VeTHMR_b_HvHrnMtrCPowerLimit)
        {
            /* Outputs for Atomic SubSystem: '<S3558>/Limiter3' */
            /* Switch: '<S3591>/Switch1' incorporates:
             *  RelationalOperator: '<S3591>/RelationalOperator'
             */
            if (rtb_product1_n < rtb_Sum7)
            {
                /* Switch: '<S3591>/Switch1' */
                rtb_product_e = rtb_product1_n;
            }
            else
            {
                /* Switch: '<S3591>/Switch1' */
                rtb_product_e = rtb_Sum7;
            }

            /* End of Switch: '<S3591>/Switch1' */

            /* Switch: '<S3591>/Switch' incorporates:
             *  RelationalOperator: '<S3591>/RelationalOperator1'
             */
            if (rtb_product_e <= rtb_Sum7_f)
            {
                /* Switch: '<S3591>/Switch' */
                rtb_product_e = rtb_Sum7_f;
            }

            /* End of Switch: '<S3591>/Switch' */
            /* End of Outputs for SubSystem: '<S3558>/Limiter3' */

            /* Outputs for Atomic SubSystem: '<S3558>/ProtectedDivision' */
            /* Switch: '<S3593>/Switch1' incorporates:
             *  Constant: '<S3586>/Calib'
             *  Constant: '<S3593>/ConstantValue'
             *  Constant: '<S3593>/ConstantValue1'
             *  Constant: '<S3593>/ConstantValue2'
             *  Constant: '<S3593>/ConstantValue3'
             *  Logic: '<S3593>/AND'
             *  RelationalOperator: '<S3593>/GreaterThanorEqual'
             *  RelationalOperator: '<S3593>/GreaterThanorEqual1'
             *  RelationalOperator: '<S3593>/NotEqual'
             *  RelationalOperator: '<S3593>/NotEqual1'
             *  Switch: '<S3593>/Switch2'
             *  Switch: '<S3593>/Switch3'
             */
            if ((rtb_product_e != 0.0F) && (KeTHMR_P_MtrCPowerLimit != 0.0F))
            {
                /* Switch: '<S3550>/Switch1' incorporates:
                 *  Product: '<S3593>/Division'
                 *  Switch: '<S3593>/Switch1'
                 */
                THMR_ac_B.Switch1 = rtb_product_e / KeTHMR_P_MtrCPowerLimit;
            }
            else if (rtb_product_e > 0.0F)
            {
                /* Switch: '<S3593>/Switch2' incorporates:
                 *  Constant: '<S3593>/MAXFLOAT'
                 *  Switch: '<S3550>/Switch1'
                 *  Switch: '<S3593>/Switch1'
                 */
                THMR_ac_B.Switch1 = 3.402823466E+38F;
            }
            else if (rtb_product_e < 0.0F)
            {
                /* Switch: '<S3593>/Switch3' incorporates:
                 *  Constant: '<S3593>/MINFLOAT'
                 *  Switch: '<S3550>/Switch1'
                 *  Switch: '<S3593>/Switch1'
                 *  Switch: '<S3593>/Switch2'
                 */
                THMR_ac_B.Switch1 = -3.402823466E+38F;
            }
            else
            {
                /* Switch: '<S3550>/Switch1' incorporates:
                 *  Constant: '<S3593>/ConstantValue4'
                 *  Switch: '<S3593>/Switch1'
                 *  Switch: '<S3593>/Switch2'
                 *  Switch: '<S3593>/Switch3'
                 */
                THMR_ac_B.Switch1 = 0.0F;
            }

            /* End of Switch: '<S3593>/Switch1' */
            /* End of Outputs for SubSystem: '<S3558>/ProtectedDivision' */
        }
        else
        {
            /* Switch: '<S3550>/Switch1' incorporates:
             *  Constant: '<S3558>/ConstantValue'
             *  Switch: '<S3558>/Switch2'
             */
            THMR_ac_B.Switch1 = 1.0F;
        }

        /* End of Switch: '<S3558>/Switch2' */
    }
    else if (KeTHMR_b_MtrCTorqueDerate)
    {
        /* Switch: '<S3556>/Switch2' incorporates:
         *  Switch: '<S3551>/Switch1'
         */
        if (THMR_ac_B.VeTHMR_b_HvHrnMtrCPowerLimit)
        {
            /* Outputs for Atomic SubSystem: '<S3556>/Limiter3' */
            /* Switch: '<S3565>/Switch1' incorporates:
             *  RelationalOperator: '<S3565>/RelationalOperator'
             */
            if (rtb_product_ft < rtb_Switch1_bhg)
            {
                /* Switch: '<S3565>/Switch1' */
                rtb_Switch1_bqc = rtb_product_ft;
            }
            else
            {
                /* Switch: '<S3565>/Switch1' */
                rtb_Switch1_bqc = rtb_Switch1_bhg;
            }

            /* End of Switch: '<S3565>/Switch1' */

            /* Switch: '<S3565>/Switch' incorporates:
             *  RelationalOperator: '<S3565>/RelationalOperator1'
             */
            if (rtb_Switch1_bqc <= rtb_product1_i)
            {
                /* Switch: '<S3565>/Switch' */
                rtb_Switch1_bqc = rtb_product1_i;
            }

            /* End of Switch: '<S3565>/Switch' */
            /* End of Outputs for SubSystem: '<S3556>/Limiter3' */

            /* Outputs for Atomic SubSystem: '<S3556>/ProtectedDivision' */
            /* Switch: '<S3567>/Switch1' incorporates:
             *  Constant: '<S3567>/ConstantValue'
             *  Constant: '<S3567>/ConstantValue1'
             *  Constant: '<S3567>/ConstantValue2'
             *  Constant: '<S3567>/ConstantValue3'
             *  Logic: '<S3567>/AND'
             *  RelationalOperator: '<S3567>/GreaterThanorEqual'
             *  RelationalOperator: '<S3567>/GreaterThanorEqual1'
             *  RelationalOperator: '<S3567>/NotEqual'
             *  RelationalOperator: '<S3567>/NotEqual1'
             *  Switch: '<S3567>/Switch2'
             *  Switch: '<S3567>/Switch3'
             */
            if ((rtb_Switch1_bqc != 0.0F) && (rtb_product_e != 0.0F))
            {
                /* Switch: '<S3550>/Switch1' incorporates:
                 *  Product: '<S3567>/Division'
                 *  Switch: '<S3567>/Switch1'
                 */
                THMR_ac_B.Switch1 = rtb_Switch1_bqc / rtb_product_e;
            }
            else if (rtb_Switch1_bqc > 0.0F)
            {
                /* Switch: '<S3567>/Switch2' incorporates:
                 *  Constant: '<S3567>/MAXFLOAT'
                 *  Switch: '<S3550>/Switch1'
                 *  Switch: '<S3567>/Switch1'
                 */
                THMR_ac_B.Switch1 = 3.402823466E+38F;
            }
            else if (rtb_Switch1_bqc < 0.0F)
            {
                /* Switch: '<S3567>/Switch3' incorporates:
                 *  Constant: '<S3567>/MINFLOAT'
                 *  Switch: '<S3550>/Switch1'
                 *  Switch: '<S3567>/Switch1'
                 *  Switch: '<S3567>/Switch2'
                 */
                THMR_ac_B.Switch1 = -3.402823466E+38F;
            }
            else
            {
                /* Switch: '<S3550>/Switch1' incorporates:
                 *  Constant: '<S3567>/ConstantValue4'
                 *  Switch: '<S3567>/Switch1'
                 *  Switch: '<S3567>/Switch2'
                 *  Switch: '<S3567>/Switch3'
                 */
                THMR_ac_B.Switch1 = 0.0F;
            }

            /* End of Switch: '<S3567>/Switch1' */
            /* End of Outputs for SubSystem: '<S3556>/ProtectedDivision' */
        }
        else
        {
            /* Switch: '<S3550>/Switch1' incorporates:
             *  Constant: '<S3556>/ConstantValue'
             *  Switch: '<S3551>/Switch1'
             *  Switch: '<S3556>/Switch2'
             */
            THMR_ac_B.Switch1 = 1.0F;
        }

        /* End of Switch: '<S3556>/Switch2' */
    }
    else if (KeTHMR_b_MtrCClassicDerate)
    {
        /* Switch: '<S3557>/Switch2' incorporates:
         *  Switch: '<S3551>/Switch1'
         *  Switch: '<S3552>/Switch1'
         */
        if (THMR_ac_B.VeTHMR_b_HvHrnMtrCPowerLimit)
        {
            /* Outputs for Atomic SubSystem: '<S3557>/Limiter3' */
            /* Switch: '<S3578>/Switch1' incorporates:
             *  RelationalOperator: '<S3578>/RelationalOperator'
             */
            if (rtb_product_c < rtb_product_k)
            {
                /* Switch: '<S3578>/Switch1' */
                rtb_product_e = rtb_product_c;
            }
            else
            {
                /* Switch: '<S3578>/Switch1' */
                rtb_product_e = rtb_product_k;
            }

            /* End of Switch: '<S3578>/Switch1' */

            /* Switch: '<S3578>/Switch' incorporates:
             *  RelationalOperator: '<S3578>/RelationalOperator1'
             */
            if (rtb_product_e > rtb_Switch2_kq)
            {
                /* Switch: '<S3550>/Switch1' incorporates:
                 *  Switch: '<S3557>/Switch2'
                 */
                THMR_ac_B.Switch1 = rtb_product_e;
            }
            else
            {
                /* Switch: '<S3550>/Switch1' incorporates:
                 *  Switch: '<S3557>/Switch2'
                 */
                THMR_ac_B.Switch1 = rtb_Switch2_kq;
            }

            /* End of Switch: '<S3578>/Switch' */
            /* End of Outputs for SubSystem: '<S3557>/Limiter3' */
        }
        else
        {
            /* Switch: '<S3550>/Switch1' incorporates:
             *  Constant: '<S3557>/ConstantValue'
             *  Switch: '<S3557>/Switch2'
             */
            THMR_ac_B.Switch1 = 1.0F;
        }

        /* End of Switch: '<S3557>/Switch2' */
    }
    else
    {
        /* Switch: '<S3550>/Switch1' incorporates:
         *  Constant: '<S3543>/ConstantValue'
         *  Switch: '<S3551>/Switch1'
         *  Switch: '<S3552>/Switch1'
         */
        THMR_ac_B.Switch1 = 1.0F;
    }

    /* End of Switch: '<S3550>/Switch1' */

    /* Update for UnitDelay: '<S3592>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_n = rtb_Sum7;

    /* Update for UnitDelay: '<S3592>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_b = rtb_Sum7_f;

    /* Update for UnitDelay: '<S3592>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_k = rtb_product1_n;

    /* Update for UnitDelay: '<S3599>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_f = rtb_Switch2_mkk;

    /* Update for UnitDelay: '<S3585>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_hd = rtb_Switch2;

    /* Update for UnitDelay: '<S3566>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ha = rtb_Switch1_bhg;

    /* Update for UnitDelay: '<S3566>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_g = rtb_product1_i;

    /* Update for UnitDelay: '<S3566>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_c = rtb_product_ft;

    /* Update for UnitDelay: '<S3573>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_g = rtb_Switch2_m5d;

    /* Update for UnitDelay: '<S3559>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_nm = rtb_TmpSignalConversionAtVeTHMR;

    /* Update for UnitDelay: '<S3579>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ir = rtb_product_k;

    /* Update for UnitDelay: '<S3579>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE_m = rtb_Switch2_kq;

    /* Update for UnitDelay: '<S3579>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_o = rtb_product_c;

    /* Update for UnitDelay: '<S3584>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_l = rtb_Switch1_iui;

    /* End of Outputs for SubSystem: '<S2>/MotorC_Harness_Control' */
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_MBCHTLLTL_EnblCodeGen1

    /* Outputs for Function Call SubSystem: '<S2>/MBC_HTL_LTCL' */
    /* Outputs for Function Call SubSystem: '<S2>/Subsystem__Subsystem1' */
    /* Logic: '<S64>/Logical1' incorporates:
     *  Constant: '<S3220>/Constant'
     *  Constant: '<S3221>/Constant'
     *  Constant: '<S3222>/Constant'
     *  Constant: '<S3223>/Constant'
     *  Constant: '<S3224>/Constant'
     *  Constant: '<S3225>/Constant'
     *  Constant: '<S3226>/Constant'
     *  Constant: '<S3227>/Constant'
     *  Constant: '<S3228>/Constant'
     *  Constant: '<S3229>/Constant'
     *  Constant: '<S3235>/Calib'
     *  Constant: '<S3236>/Calib'
     *  Logic: '<S64>/LogicalOperator'
     *  Logic: '<S64>/LogicalOperator1'
     *  Logic: '<S64>/LogicalOperator3'
     *  Merge: '<S4575>/Merge1'
     *  RelationalOperator: '<S4101>/Comparison8'
     *  RelationalOperator: '<S64>/Comparison1'
     *  RelationalOperator: '<S64>/Comparison10'
     *  RelationalOperator: '<S64>/Comparison2'
     *  RelationalOperator: '<S64>/Comparison3'
     *  RelationalOperator: '<S64>/Comparison4'
     *  RelationalOperator: '<S64>/Comparison5'
     *  RelationalOperator: '<S64>/Comparison6'
     *  RelationalOperator: '<S64>/Comparison7'
     *  RelationalOperator: '<S64>/Comparison8'
     *  RelationalOperator: '<S64>/Comparison9'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     *  Switch: '<S4586>/Switch1'
     */
    THMR_ac_B.Logical1 = (((((((KeTHMR_b_HTLLTCLMBCEnbl) &&
        (CeTHMR_e_CabinActivePassiveHeating == ((uint32)rtb_Switch1_o0g))) &&
        (CeTHMR_e_LTCLActvPsvHeating != ((uint32)
        THMR_ac_B.VeTHMR_e_LTCLThrmlMode))) && (((uint32)VeTHMR_e_BatThrmlSt_B4D)
        != CeTHMR_e_ActvPsvHeating)) && (((uint32)VeTHMR_e_BatThrmlSt_B4D) !=
        CeTHMR_e_PassiveCooling)) && (((uint32)VeTHMR_e_BatThrmlSt_B4D) !=
                            CeTHMR_e_PassiveHeating)) && ((((((((uint32)
        rtb_TmpSignalConversionAtVePD_l) != CePDTR_e_Dischrg_CabReqInOV) &&
        (((uint32)rtb_TmpSignalConversionAtVePD_l) !=
         CePDTR_e_Dischrg_AmbTempLow)) && (((uint32)
        rtb_TmpSignalConversionAtVePD_l) != CePDTR_e_Dischrg_CabReqPrsnt)) &&
        (((uint32)rtb_TmpSignalConversionAtVePD_l) !=
         CePDTR_e_Dischrg_BatAndCab_Cndtn)) && (((uint32)
        rtb_TmpSignalConversionAtVePD_l) != CePDTR_e_NoValidReq)) ||
                           (KeTHMR_b_UseHTLLTCLMBCforOV)));

    /* End of Outputs for SubSystem: '<S2>/Subsystem__Subsystem1' */

    /* Switch: '<S3313>/Switch1' incorporates:
     *  SignalConversion generated from: '<S3232>/Product'
     */
    rtb_TmpSignalConversionAtVaCT_o[0] = VeTHMR_T_HCCTISArb;
    rtb_TmpSignalConversionAtVaCT_o[1] = rtb_TmpSignalConversionAtVeT_jp;

    /* Switch: '<S3314>/Switch1' incorporates:
     *  SignalConversion generated from: '<S3232>/Product'
     *  Sum: '<S64>/Add4'
     */
    rtb_TmpSignalConversionAtVaCT_l[0] = rtb_TmpSignalConversionAtVeT_je;
    rtb_TmpSignalConversionAtVaCT_l[1] = VeTHMR_T_PPCTISTgt_Fan -
        rtb_TmpSignalConversionAtVeT_jp;

    /* SignalConversion generated from: '<S3340>/Product' incorporates:
     *  UnitDelay: '<S3232>/UnitDelay'
     *  UnitDelay: '<S3311>/UnitDelay'
     */
    for (i = 0; i < 3; i++)
    {
        rtb_TmpSignalConversionAtVeT_ex[i] = THMR_ac_DW.UnitDelay_DSTATE[i];
    }

    for (i = 0; i < 2; i++)
    {
        rtb_TmpSignalConversionAtVeT_ex[i + 3] = THMR_ac_DW.UnitDelay_DSTATE_e[i];
    }

    /* End of SignalConversion generated from: '<S3340>/Product' */

    /* Product: '<S3340>/Product' incorporates:
     *  Constant: '<S3319>/Calib'
     *  Gain: '<S3237>/Gain1'
     */
    rtb_Switch10 = 0.0F;
    for (i = 0; i < 5; i++)
    {
        rtb_Switch10 += (-KaTHMR_k_KLQGPECP1_MBCHTLLTL[(i)]) *
            rtb_TmpSignalConversionAtVeT_ex[i];
    }

    /* Product: '<S3340>/Product' */
    VeTHMR_n_LQGPECP1_MBCHTLLTL_BfGrdLim = rtb_Switch10;

    /* Outputs for Atomic SubSystem: '<S3230>/Limiter1' */
    /* Switch: '<S3282>/Switch1' incorporates:
     *  Constant: '<S3273>/Calib'
     *  RelationalOperator: '<S3282>/RelationalOperator'
     */
    if (KeTHMR_n_MaxLimitPECP1_MBCHTLLTL < VeTHMR_n_LQGPECP1_MBCHTLLTL_BfGrdLim)
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_n_MaxLimitPECP1_MBCHTLLTL;
    }
    else
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = VeTHMR_n_LQGPECP1_MBCHTLLTL_BfGrdLim;
    }

    /* End of Switch: '<S3282>/Switch1' */
    /* End of Outputs for SubSystem: '<S3230>/Limiter1' */

    /* Outputs for Atomic SubSystem: '<S3230>/GradientLimiter1' */
    /* Switch: '<S3295>/Switch1' incorporates:
     *  UnitDelay: '<S3244>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeT_jp = THMR_ac_DW.UnitDelay_DSTATE_b;

    /* End of Outputs for SubSystem: '<S3230>/GradientLimiter1' */

    /* Outputs for Atomic SubSystem: '<S3230>/Limiter1' */
    /* Switch: '<S3282>/Switch' incorporates:
     *  Constant: '<S3276>/Calib'
     *  RelationalOperator: '<S3282>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTHMR <= KeTHMR_n_MinLimitPECP1_MBCHTLLTL)
    {
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_n_MinLimitPECP1_MBCHTLLTL;
    }

    /* End of Switch: '<S3282>/Switch' */
    /* End of Outputs for SubSystem: '<S3230>/Limiter1' */

    /* Outputs for Atomic SubSystem: '<S3230>/GradientLimiter1' */
    /* Sum: '<S3244>/Sum2' */
    rtb_TmpSignalConversionAtVeTHMR -= rtb_TmpSignalConversionAtVeT_jp;

    /* Outputs for Atomic SubSystem: '<S3244>/Limiter' */
    /* Switch: '<S3289>/Switch1' incorporates:
     *  Constant: '<S3279>/Calib'
     *  RelationalOperator: '<S3289>/RelationalOperator'
     */
    if (KeTHMR_n_UGrdLimitPECP1_MBCHTLLTL < rtb_TmpSignalConversionAtVeTHMR)
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_n_UGrdLimitPECP1_MBCHTLLTL;
    }

    /* End of Switch: '<S3289>/Switch1' */

    /* Switch: '<S3289>/Switch' incorporates:
     *  Constant: '<S3270>/Calib'
     *  RelationalOperator: '<S3289>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTHMR <= KeTHMR_n_DGrdLimitPECP1_MBCHTLLTL)
    {
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_n_DGrdLimitPECP1_MBCHTLLTL;
    }

    /* End of Switch: '<S3289>/Switch' */
    /* End of Outputs for SubSystem: '<S3244>/Limiter' */

    /* Sum: '<S3244>/Sum3' */
    VeTHMR_n_LQGPECP1_MBCHTLLTL = rtb_TmpSignalConversionAtVeTHMR +
        rtb_TmpSignalConversionAtVeT_jp;

    /* Update for UnitDelay: '<S3244>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_b = VeTHMR_n_LQGPECP1_MBCHTLLTL;

    /* End of Outputs for SubSystem: '<S3230>/GradientLimiter1' */

    /* SignalConversion generated from: '<S3341>/Product' incorporates:
     *  UnitDelay: '<S3232>/UnitDelay'
     *  UnitDelay: '<S3312>/UnitDelay'
     */
    for (i = 0; i < 3; i++)
    {
        rtb_TmpSignalConversionAtVeT_ex[i] = THMR_ac_DW.UnitDelay_DSTATE[i];
    }

    for (i = 0; i < 2; i++)
    {
        rtb_TmpSignalConversionAtVeT_ex[i + 3] = THMR_ac_DW.UnitDelay_DSTATE_i[i];
    }

    /* End of SignalConversion generated from: '<S3341>/Product' */

    /* Product: '<S3341>/Product' incorporates:
     *  Constant: '<S3320>/Calib'
     *  Gain: '<S3237>/Gain'
     */
    rtb_Switch10 = 0.0F;
    for (i = 0; i < 5; i++)
    {
        rtb_Switch10 += (-KaTHMR_k_KLQGPECP2_MBCHTLLTL[(i)]) *
            rtb_TmpSignalConversionAtVeT_ex[i];
    }

    /* Product: '<S3341>/Product' */
    VeTHMR_n_LQGPECP2_MBCHTLLTL_BfGrdLim = rtb_Switch10;

    /* Outputs for Atomic SubSystem: '<S3230>/Limiter2' */
    /* Switch: '<S3283>/Switch1' incorporates:
     *  Constant: '<S3274>/Calib'
     *  RelationalOperator: '<S3283>/RelationalOperator'
     */
    if (KeTHMR_n_MaxLimitPECP2_MBCHTLLTL < VeTHMR_n_LQGPECP2_MBCHTLLTL_BfGrdLim)
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_n_MaxLimitPECP2_MBCHTLLTL;
    }
    else
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = VeTHMR_n_LQGPECP2_MBCHTLLTL_BfGrdLim;
    }

    /* End of Switch: '<S3283>/Switch1' */
    /* End of Outputs for SubSystem: '<S3230>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S3230>/GradientLimiter2' */
    /* Switch: '<S3295>/Switch1' incorporates:
     *  UnitDelay: '<S3245>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeT_jp = THMR_ac_DW.UnitDelay_DSTATE_e2;

    /* End of Outputs for SubSystem: '<S3230>/GradientLimiter2' */

    /* Outputs for Atomic SubSystem: '<S3230>/Limiter2' */
    /* Switch: '<S3283>/Switch' incorporates:
     *  Constant: '<S3277>/Calib'
     *  RelationalOperator: '<S3283>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTHMR <= KeTHMR_n_MinLimitPECP2_MBCHTLLTL)
    {
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_n_MinLimitPECP2_MBCHTLLTL;
    }

    /* End of Switch: '<S3283>/Switch' */
    /* End of Outputs for SubSystem: '<S3230>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S3230>/GradientLimiter2' */
    /* Sum: '<S3245>/Sum2' */
    rtb_TmpSignalConversionAtVeTHMR -= rtb_TmpSignalConversionAtVeT_jp;

    /* Outputs for Atomic SubSystem: '<S3245>/Limiter' */
    /* Switch: '<S3290>/Switch1' incorporates:
     *  Constant: '<S3280>/Calib'
     *  RelationalOperator: '<S3290>/RelationalOperator'
     */
    if (KeTHMR_n_UGrdLimitPECP2_MBCHTLLTL < rtb_TmpSignalConversionAtVeTHMR)
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_n_UGrdLimitPECP2_MBCHTLLTL;
    }

    /* End of Switch: '<S3290>/Switch1' */

    /* Switch: '<S3290>/Switch' incorporates:
     *  Constant: '<S3271>/Calib'
     *  RelationalOperator: '<S3290>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTHMR <= KeTHMR_n_DGrdLimitPECP2_MBCHTLLTL)
    {
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_n_DGrdLimitPECP2_MBCHTLLTL;
    }

    /* End of Switch: '<S3290>/Switch' */
    /* End of Outputs for SubSystem: '<S3245>/Limiter' */

    /* Sum: '<S3245>/Sum3' */
    VeTHMR_n_LQGPECP2_MBCHTLLTL = rtb_TmpSignalConversionAtVeTHMR +
        rtb_TmpSignalConversionAtVeT_jp;

    /* Update for UnitDelay: '<S3245>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_e2 = VeTHMR_n_LQGPECP2_MBCHTLLTL;

    /* End of Outputs for SubSystem: '<S3230>/GradientLimiter2' */

    /* SignalConversion generated from: '<S3339>/Product' incorporates:
     *  UnitDelay: '<S3232>/UnitDelay'
     *  UnitDelay: '<S3313>/UnitDelay'
     */
    for (i = 0; i < 3; i++)
    {
        rtb_TmpSignalConversionAtVeT_ex[i] = THMR_ac_DW.UnitDelay_DSTATE[i];
    }

    for (i = 0; i < 2; i++)
    {
        rtb_TmpSignalConversionAtVeT_ex[i + 3] = THMR_ac_DW.UnitDelay_DSTATE_k[i];
    }

    /* End of SignalConversion generated from: '<S3339>/Product' */

    /* Product: '<S3339>/Product' incorporates:
     *  Constant: '<S3318>/Calib'
     *  Gain: '<S3237>/Gain4'
     */
    rtb_Switch10 = 0.0F;
    for (i = 0; i < 5; i++)
    {
        rtb_Switch10 += (-KaTHMR_k_KLQGLTRVlv_MBCHTLLTL[(i)]) *
            rtb_TmpSignalConversionAtVeT_ex[i];
    }

    /* Product: '<S3339>/Product' */
    VeTHMR_Pct_LQGLTRVlv_MBCHTLLTL_BfGrdLim = rtb_Switch10;

    /* Product: '<S3307>/Product' incorporates:
     *  Constant: '<S3302>/Calib'
     *  Constant: '<S3303>/Calib'
     *  Constant: '<S3304>/Calib'
     *  Constant: '<S3305>/Calib'
     *  Product: '<S3306>/Product1'
     *  Sum: '<S3306>/Sum2'
     *  Sum: '<S3307>/Sum1'
     */
    rtb_TmpSignalConversionAtVeT_jp = (((VeTHMR_Pct_LQGLTRVlv_MBCHTLLTL_BfGrdLim
        * KeTHMR_k_LTRVlv_LinearInv) - KeTHMR_Pct_LTRVlv_LinearInv) -
        KeTHMR_Pct_LTRVlv_Nrmlztn) * KeTHMR_k_LTRVlv_Nrmlztn;

    /* Outputs for Atomic SubSystem: '<S3230>/Limiter3' */
    /* Switch: '<S3284>/Switch1' incorporates:
     *  Constant: '<S3259>/Calib'
     *  RelationalOperator: '<S3284>/RelationalOperator'
     */
    if (KeTHMR_Pct_MaxLimitLTRVlv_MBCHTLLTL < rtb_TmpSignalConversionAtVeT_jp)
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_Pct_MaxLimitLTRVlv_MBCHTLLTL;
    }
    else
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = rtb_TmpSignalConversionAtVeT_jp;
    }

    /* End of Switch: '<S3284>/Switch1' */
    /* End of Outputs for SubSystem: '<S3230>/Limiter3' */

    /* Outputs for Atomic SubSystem: '<S3230>/GradientLimiter3' */
    /* Switch: '<S3295>/Switch1' incorporates:
     *  UnitDelay: '<S3246>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeT_jp = THMR_ac_DW.UnitDelay_DSTATE_l;

    /* End of Outputs for SubSystem: '<S3230>/GradientLimiter3' */

    /* Outputs for Atomic SubSystem: '<S3230>/Limiter3' */
    /* Switch: '<S3284>/Switch' incorporates:
     *  Constant: '<S3261>/Calib'
     *  RelationalOperator: '<S3284>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTHMR <= KeTHMR_Pct_MinLimitLTRVlv_MBCHTLLTL)
    {
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_Pct_MinLimitLTRVlv_MBCHTLLTL;
    }

    /* End of Switch: '<S3284>/Switch' */
    /* End of Outputs for SubSystem: '<S3230>/Limiter3' */

    /* Outputs for Atomic SubSystem: '<S3230>/GradientLimiter3' */
    /* Sum: '<S3246>/Sum2' */
    rtb_TmpSignalConversionAtVeTHMR -= rtb_TmpSignalConversionAtVeT_jp;

    /* Outputs for Atomic SubSystem: '<S3246>/Limiter' */
    /* Switch: '<S3291>/Switch1' incorporates:
     *  Constant: '<S3263>/Calib'
     *  RelationalOperator: '<S3291>/RelationalOperator'
     */
    if (KeTHMR_Pct_UGrdLimitLTRVlv_MBCHTLLTL < rtb_TmpSignalConversionAtVeTHMR)
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_Pct_UGrdLimitLTRVlv_MBCHTLLTL;
    }

    /* End of Switch: '<S3291>/Switch1' */

    /* Switch: '<S3291>/Switch' incorporates:
     *  Constant: '<S3257>/Calib'
     *  RelationalOperator: '<S3291>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTHMR <= KeTHMR_Pct_DGrdLimitLTRVlv_MBCHTLLTL)
    {
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_Pct_DGrdLimitLTRVlv_MBCHTLLTL;
    }

    /* End of Switch: '<S3291>/Switch' */
    /* End of Outputs for SubSystem: '<S3246>/Limiter' */

    /* Sum: '<S3246>/Sum3' */
    VeTHMR_Pct_LQGLTRVlv_MBCHTLLTL = rtb_TmpSignalConversionAtVeTHMR +
        rtb_TmpSignalConversionAtVeT_jp;

    /* Update for UnitDelay: '<S3246>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_l = VeTHMR_Pct_LQGLTRVlv_MBCHTLLTL;

    /* End of Outputs for SubSystem: '<S3230>/GradientLimiter3' */

    /* SignalConversion generated from: '<S3337>/Product' incorporates:
     *  UnitDelay: '<S3232>/UnitDelay'
     *  UnitDelay: '<S3314>/UnitDelay'
     */
    for (i = 0; i < 3; i++)
    {
        rtb_TmpSignalConversionAtVeT_ex[i] = THMR_ac_DW.UnitDelay_DSTATE[i];
    }

    for (i = 0; i < 2; i++)
    {
        rtb_TmpSignalConversionAtVeT_ex[i + 3] = THMR_ac_DW.UnitDelay_DSTATE_h[i];
    }

    /* End of SignalConversion generated from: '<S3337>/Product' */

    /* Product: '<S3337>/Product' incorporates:
     *  Constant: '<S3316>/Calib'
     *  Gain: '<S3237>/Gain2'
     */
    rtb_Switch10 = 0.0F;
    for (i = 0; i < 5; i++)
    {
        rtb_Switch10 += (-KaTHMR_k_KLQGFan_MBCHTLLTL[(i)]) *
            rtb_TmpSignalConversionAtVeT_ex[i];
    }

    /* Product: '<S3337>/Product' */
    VeTHMR_dV_LQGFan_MBCHTLLTL_BfGrdLim = rtb_Switch10;

    /* Product: '<S3230>/Product' incorporates:
     *  Constant: '<S3252>/Calib'
     */
    rtb_TmpSignalConversionAtVeT_jp = VeTHMR_dV_LQGFan_MBCHTLLTL_BfGrdLim *
        KeTHMR_Cf_FanAFCnvsn_MBCHTLLTL;

    /* Outputs for Atomic SubSystem: '<S3230>/Limiter4' */
    /* Switch: '<S3285>/Switch1' incorporates:
     *  Constant: '<S3266>/Calib'
     *  RelationalOperator: '<S3285>/RelationalOperator'
     */
    if (KeTHMR_dV_MaxLimitFan_MBCHTLLTL < rtb_TmpSignalConversionAtVeT_jp)
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_dV_MaxLimitFan_MBCHTLLTL;
    }
    else
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = rtb_TmpSignalConversionAtVeT_jp;
    }

    /* End of Switch: '<S3285>/Switch1' */
    /* End of Outputs for SubSystem: '<S3230>/Limiter4' */

    /* Outputs for Atomic SubSystem: '<S3230>/GradientLimiter4' */
    /* Switch: '<S3295>/Switch1' incorporates:
     *  UnitDelay: '<S3247>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeT_jp = THMR_ac_DW.UnitDelay_DSTATE_c;

    /* End of Outputs for SubSystem: '<S3230>/GradientLimiter4' */

    /* Outputs for Atomic SubSystem: '<S3230>/Limiter4' */
    /* Switch: '<S3285>/Switch' incorporates:
     *  Constant: '<S3267>/Calib'
     *  RelationalOperator: '<S3285>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTHMR <= KeTHMR_dV_MinLimitFan_MBCHTLLTL)
    {
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_dV_MinLimitFan_MBCHTLLTL;
    }

    /* End of Switch: '<S3285>/Switch' */
    /* End of Outputs for SubSystem: '<S3230>/Limiter4' */

    /* Outputs for Atomic SubSystem: '<S3230>/GradientLimiter4' */
    /* Sum: '<S3247>/Sum2' */
    rtb_TmpSignalConversionAtVeTHMR -= rtb_TmpSignalConversionAtVeT_jp;

    /* Outputs for Atomic SubSystem: '<S3247>/Limiter' */
    /* Switch: '<S3292>/Switch1' incorporates:
     *  Constant: '<S3268>/Calib'
     *  RelationalOperator: '<S3292>/RelationalOperator'
     */
    if (KeTHMR_dV_UGrdLimitFan_MBCHTLLTL < rtb_TmpSignalConversionAtVeTHMR)
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_dV_UGrdLimitFan_MBCHTLLTL;
    }

    /* End of Switch: '<S3292>/Switch1' */

    /* Switch: '<S3292>/Switch' incorporates:
     *  Constant: '<S3265>/Calib'
     *  RelationalOperator: '<S3292>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTHMR <= KeTHMR_dV_DGrdLimitFan_MBCHTLLTL)
    {
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_dV_DGrdLimitFan_MBCHTLLTL;
    }

    /* End of Switch: '<S3292>/Switch' */
    /* End of Outputs for SubSystem: '<S3247>/Limiter' */

    /* Sum: '<S3247>/Sum3' */
    VeTHMR_dV_LQGFan_MBCHTLLTL = rtb_TmpSignalConversionAtVeTHMR +
        rtb_TmpSignalConversionAtVeT_jp;

    /* Update for UnitDelay: '<S3247>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_c = VeTHMR_dV_LQGFan_MBCHTLLTL;

    /* End of Outputs for SubSystem: '<S3230>/GradientLimiter4' */

    /* SignalConversion generated from: '<S3338>/Product' incorporates:
     *  UnitDelay: '<S3232>/UnitDelay'
     *  UnitDelay: '<S3309>/UnitDelay'
     */
    for (i = 0; i < 3; i++)
    {
        rtb_TmpSignalConversionAtVeT_ex[i] = THMR_ac_DW.UnitDelay_DSTATE[i];
    }

    for (i = 0; i < 2; i++)
    {
        rtb_TmpSignalConversionAtVeT_ex[i + 3] = THMR_ac_DW.UnitDelay_DSTATE_d[i];
    }

    /* End of SignalConversion generated from: '<S3338>/Product' */

    /* Product: '<S3338>/Product' incorporates:
     *  Constant: '<S3317>/Calib'
     *  Gain: '<S3237>/Gain3'
     */
    rtb_Switch10 = 0.0F;
    for (i = 0; i < 5; i++)
    {
        rtb_Switch10 += (-KaTHMR_k_KLQGHCP_MBCHTLLTL[(i)]) *
            rtb_TmpSignalConversionAtVeT_ex[i];
    }

    /* Product: '<S3338>/Product' */
    VeTHMR_n_LQGHCP_MBCHTLLTL_BfGrdLim = rtb_Switch10;

    /* Outputs for Atomic SubSystem: '<S3230>/Limiter5' */
    /* Switch: '<S3286>/Switch1' incorporates:
     *  Constant: '<S3272>/Calib'
     *  RelationalOperator: '<S3286>/RelationalOperator'
     */
    if (KeTHMR_n_MaxLimitHCP_MBCHTLLTL < VeTHMR_n_LQGHCP_MBCHTLLTL_BfGrdLim)
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_n_MaxLimitHCP_MBCHTLLTL;
    }
    else
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = VeTHMR_n_LQGHCP_MBCHTLLTL_BfGrdLim;
    }

    /* End of Switch: '<S3286>/Switch1' */
    /* End of Outputs for SubSystem: '<S3230>/Limiter5' */

    /* Outputs for Atomic SubSystem: '<S3230>/GradientLimiter5' */
    /* Switch: '<S3295>/Switch1' incorporates:
     *  UnitDelay: '<S3248>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeT_jp = THMR_ac_DW.UnitDelay_DSTATE_kh;

    /* End of Outputs for SubSystem: '<S3230>/GradientLimiter5' */

    /* Outputs for Atomic SubSystem: '<S3230>/Limiter5' */
    /* Switch: '<S3286>/Switch' incorporates:
     *  Constant: '<S3275>/Calib'
     *  RelationalOperator: '<S3286>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTHMR <= KeTHMR_n_MinLimitHCP_MBCHTLLTL)
    {
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_n_MinLimitHCP_MBCHTLLTL;
    }

    /* End of Switch: '<S3286>/Switch' */
    /* End of Outputs for SubSystem: '<S3230>/Limiter5' */

    /* Outputs for Atomic SubSystem: '<S3230>/GradientLimiter5' */
    /* Sum: '<S3248>/Sum2' */
    rtb_TmpSignalConversionAtVeTHMR -= rtb_TmpSignalConversionAtVeT_jp;

    /* Outputs for Atomic SubSystem: '<S3248>/Limiter' */
    /* Switch: '<S3293>/Switch1' incorporates:
     *  Constant: '<S3278>/Calib'
     *  RelationalOperator: '<S3293>/RelationalOperator'
     */
    if (KeTHMR_n_UGrdLimitHCP_MBCHTLLTL < rtb_TmpSignalConversionAtVeTHMR)
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_n_UGrdLimitHCP_MBCHTLLTL;
    }

    /* End of Switch: '<S3293>/Switch1' */

    /* Switch: '<S3293>/Switch' incorporates:
     *  Constant: '<S3269>/Calib'
     *  RelationalOperator: '<S3293>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTHMR <= KeTHMR_n_DGrdLimitHCP_MBCHTLLTL)
    {
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_n_DGrdLimitHCP_MBCHTLLTL;
    }

    /* End of Switch: '<S3293>/Switch' */
    /* End of Outputs for SubSystem: '<S3248>/Limiter' */

    /* Sum: '<S3248>/Sum3' */
    VeTHMR_n_LQGHCP_MBCHTLLTL = rtb_TmpSignalConversionAtVeTHMR +
        rtb_TmpSignalConversionAtVeT_jp;

    /* Update for UnitDelay: '<S3248>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kh = VeTHMR_n_LQGHCP_MBCHTLLTL;

    /* End of Outputs for SubSystem: '<S3230>/GradientLimiter5' */

    /* SignalConversion generated from: '<S3336>/Product' incorporates:
     *  UnitDelay: '<S3232>/UnitDelay'
     *  UnitDelay: '<S3308>/UnitDelay'
     */
    for (i = 0; i < 3; i++)
    {
        rtb_TmpSignalConversionAtVeT_ex[i] = THMR_ac_DW.UnitDelay_DSTATE[i];
    }

    for (i = 0; i < 2; i++)
    {
        rtb_TmpSignalConversionAtVeT_ex[i + 3] =
            THMR_ac_DW.UnitDelay_DSTATE_is[i];
    }

    /* End of SignalConversion generated from: '<S3336>/Product' */

    /* Product: '<S3336>/Product' incorporates:
     *  Constant: '<S3315>/Calib'
     *  Gain: '<S3237>/Gain5'
     */
    rtb_Switch10 = 0.0F;
    for (i = 0; i < 5; i++)
    {
        rtb_Switch10 += (-KaTHMR_k_KLQGECH_MBCHTLLTL[(i)]) *
            rtb_TmpSignalConversionAtVeT_ex[i];
    }

    /* Product: '<S3336>/Product' */
    VeTHMR_P_LQGECH_MBCHTLLTL_BfGrdLim = rtb_Switch10;

    /* Outputs for Atomic SubSystem: '<S3230>/Limiter6' */
    /* Switch: '<S3287>/Switch1' incorporates:
     *  Constant: '<S3254>/Calib'
     *  RelationalOperator: '<S3287>/RelationalOperator'
     */
    if (KeTHMR_P_MaxLimitECH_MBCHTLLTL < VeTHMR_P_LQGECH_MBCHTLLTL_BfGrdLim)
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_P_MaxLimitECH_MBCHTLLTL;
    }
    else
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = VeTHMR_P_LQGECH_MBCHTLLTL_BfGrdLim;
    }

    /* End of Switch: '<S3287>/Switch1' */
    /* End of Outputs for SubSystem: '<S3230>/Limiter6' */

    /* Outputs for Atomic SubSystem: '<S3230>/GradientLimiter6' */
    /* Switch: '<S3295>/Switch1' incorporates:
     *  UnitDelay: '<S3249>/UnitDelay'
     */
    rtb_TmpSignalConversionAtVeT_jp = THMR_ac_DW.UnitDelay_DSTATE_kd;

    /* End of Outputs for SubSystem: '<S3230>/GradientLimiter6' */

    /* Outputs for Atomic SubSystem: '<S3230>/Limiter6' */
    /* Switch: '<S3287>/Switch' incorporates:
     *  Constant: '<S3255>/Calib'
     *  RelationalOperator: '<S3287>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTHMR <= KeTHMR_P_MinLimitECH_MBCHTLLTL)
    {
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_P_MinLimitECH_MBCHTLLTL;
    }

    /* End of Switch: '<S3287>/Switch' */
    /* End of Outputs for SubSystem: '<S3230>/Limiter6' */

    /* Outputs for Atomic SubSystem: '<S3230>/GradientLimiter6' */
    /* Sum: '<S3249>/Sum2' */
    rtb_TmpSignalConversionAtVeTHMR -= rtb_TmpSignalConversionAtVeT_jp;

    /* Outputs for Atomic SubSystem: '<S3249>/Limiter' */
    /* Switch: '<S3294>/Switch1' incorporates:
     *  Constant: '<S3256>/Calib'
     *  RelationalOperator: '<S3294>/RelationalOperator'
     */
    if (KeTHMR_P_UGrdLimitECH_MBCHTLLTL < rtb_TmpSignalConversionAtVeTHMR)
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_P_UGrdLimitECH_MBCHTLLTL;
    }

    /* End of Switch: '<S3294>/Switch1' */

    /* Switch: '<S3294>/Switch' incorporates:
     *  Constant: '<S3253>/Calib'
     *  RelationalOperator: '<S3294>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTHMR <= KeTHMR_P_DGrdLimitECH_MBCHTLLTL)
    {
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_P_DGrdLimitECH_MBCHTLLTL;
    }

    /* End of Switch: '<S3294>/Switch' */
    /* End of Outputs for SubSystem: '<S3249>/Limiter' */

    /* Sum: '<S3249>/Sum3' */
    VeTHMR_P_LQGECH_MBCHTLLTL = rtb_TmpSignalConversionAtVeTHMR +
        rtb_TmpSignalConversionAtVeT_jp;

    /* Update for UnitDelay: '<S3249>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kd = VeTHMR_P_LQGECH_MBCHTLLTL;

    /* End of Outputs for SubSystem: '<S3230>/GradientLimiter6' */

    /* SignalConversion generated from: '<S3342>/Product' incorporates:
     *  UnitDelay: '<S3232>/UnitDelay'
     *  UnitDelay: '<S3310>/UnitDelay'
     */
    for (i = 0; i < 3; i++)
    {
        rtb_TmpSignalConversionAtVeT_ex[i] = THMR_ac_DW.UnitDelay_DSTATE[i];
    }

    for (i = 0; i < 2; i++)
    {
        rtb_TmpSignalConversionAtVeT_ex[i + 3] = THMR_ac_DW.UnitDelay_DSTATE_a[i];
    }

    /* End of SignalConversion generated from: '<S3342>/Product' */

    /* Product: '<S3342>/Product' incorporates:
     *  Constant: '<S3321>/Calib'
     *  Gain: '<S3237>/Gain6'
     */
    rtb_Switch10 = 0.0F;
    for (i = 0; i < 5; i++)
    {
        rtb_Switch10 += (-KaTHMR_k_KLQGVHTL_MBCHTLLTL[(i)]) *
            rtb_TmpSignalConversionAtVeT_ex[i];
    }

    /* Product: '<S3342>/Product' */
    VeTHMR_Pct_LQGVHTL_MBCHTLLTL_BfGrdLim = rtb_Switch10;

    /* Product: '<S3301>/Product' incorporates:
     *  Constant: '<S3296>/Calib'
     *  Constant: '<S3297>/Calib'
     *  Constant: '<S3298>/Calib'
     *  Constant: '<S3299>/Calib'
     *  Product: '<S3300>/Product1'
     *  Sum: '<S3300>/Sum2'
     *  Sum: '<S3301>/Sum1'
     */
    rtb_TmpSignalConversionAtVeT_jp = (((VeTHMR_Pct_LQGVHTL_MBCHTLLTL_BfGrdLim *
        KeTHMR_k_VHTL_LinearInv) - KeTHMR_Pct_VHTL_LinearInv) -
        KeTHMR_Pct_VHTL_Nrmlztn) * KeTHMR_k_VHTL_Nrmlztn;

    /* Outputs for Atomic SubSystem: '<S3230>/Limiter7' */
    /* Switch: '<S3288>/Switch1' incorporates:
     *  Constant: '<S3260>/Calib'
     *  RelationalOperator: '<S3288>/RelationalOperator'
     */
    if (KeTHMR_Pct_MaxLimitVHTL_MBCHTLLTL < rtb_TmpSignalConversionAtVeT_jp)
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = KeTHMR_Pct_MaxLimitVHTL_MBCHTLLTL;
    }
    else
    {
        /* UnitDelay: '<S3250>/UnitDelay' */
        rtb_TmpSignalConversionAtVeTHMR = rtb_TmpSignalConversionAtVeT_jp;
    }

    /* End of Switch: '<S3288>/Switch1' */

    /* Switch: '<S3288>/Switch' incorporates:
     *  Constant: '<S3262>/Calib'
     *  RelationalOperator: '<S3288>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeTHMR > KeTHMR_Pct_MinLimitVHTL_MBCHTLLTL)
    {
        /* Switch: '<S3288>/Switch' */
        rtb_TmpSignalConversionAtVeT_jp = rtb_TmpSignalConversionAtVeTHMR;
    }
    else
    {
        /* Switch: '<S3288>/Switch' */
        rtb_TmpSignalConversionAtVeT_jp = KeTHMR_Pct_MinLimitVHTL_MBCHTLLTL;
    }

    /* End of Switch: '<S3288>/Switch' */
    /* End of Outputs for SubSystem: '<S3230>/Limiter7' */

    /* Outputs for Atomic SubSystem: '<S3230>/GradientLimiter7' */
    /* UnitDelay: '<S3250>/UnitDelay' */
    rtb_TmpSignalConversionAtVeTHMR = THMR_ac_DW.UnitDelay_DSTATE_kq;

    /* Sum: '<S3250>/Sum2' */
    rtb_TmpSignalConversionAtVeT_jp -= rtb_TmpSignalConversionAtVeTHMR;

    /* Outputs for Atomic SubSystem: '<S3250>/Limiter' */
    /* Switch: '<S3295>/Switch1' incorporates:
     *  Constant: '<S3264>/Calib'
     *  RelationalOperator: '<S3295>/RelationalOperator'
     */
    if (KeTHMR_Pct_UGrdLimitVHTL_MBCHTLLTL < rtb_TmpSignalConversionAtVeT_jp)
    {
        /* Switch: '<S3295>/Switch1' */
        rtb_TmpSignalConversionAtVeT_jp = KeTHMR_Pct_UGrdLimitVHTL_MBCHTLLTL;
    }

    /* End of Switch: '<S3295>/Switch1' */

    /* Switch: '<S3295>/Switch' incorporates:
     *  Constant: '<S3258>/Calib'
     *  RelationalOperator: '<S3295>/RelationalOperator1'
     */
    if (rtb_TmpSignalConversionAtVeT_jp <= KeTHMR_Pct_DGrdLimitVHTL_MBCHTLLTL)
    {
        rtb_TmpSignalConversionAtVeT_jp = KeTHMR_Pct_DGrdLimitVHTL_MBCHTLLTL;
    }

    /* End of Switch: '<S3295>/Switch' */
    /* End of Outputs for SubSystem: '<S3250>/Limiter' */

    /* Sum: '<S3250>/Sum3' */
    VeTHMR_Pct_LQGVHTL_MBCHTLLTL = rtb_TmpSignalConversionAtVeT_jp +
        rtb_TmpSignalConversionAtVeTHMR;

    /* Update for UnitDelay: '<S3250>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_kq = VeTHMR_Pct_LQGVHTL_MBCHTLLTL;

    /* End of Outputs for SubSystem: '<S3230>/GradientLimiter7' */
    for (i = 0; i < 3; i++)
    {
        /* Product: '<S3232>/Product' incorporates:
         *  Constant: '<S3231>/Calib'
         */
        rtb_Selector_c[i] = 0.0F;
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 2;
                rtb_DataTypeConversion2++)
        {
            rtb_Selector_c[i] += KaTHMR_k_Lkalman_MBCHTLLTL[(3 *
                rtb_DataTypeConversion2) + i] *
                rtb_TmpSignalConversionAtVaCT_o[rtb_DataTypeConversion2];
        }

        /* End of Product: '<S3232>/Product' */
    }

    /* RelationalOperator: '<S3308>/Comparison2' incorporates:
     *  Constant: '<S3322>/Calib'
     *  UnitDelay: '<S3237>/UnitDelay4'
     */
    rtb_Switch1_bkm = (THMR_ac_DW.UnitDelay4_DSTATE >=
                       KeTHMR_P_MaxAntWdECH_MBCHTLLTL);

    /* RelationalOperator: '<S3308>/Comparison3' incorporates:
     *  Constant: '<S3323>/Calib'
     *  UnitDelay: '<S3237>/UnitDelay4'
     */
    rtb_Switch1_abpr = (THMR_ac_DW.UnitDelay4_DSTATE <=
                        KeTHMR_P_MinAntWdECH_MBCHTLLTL);
    for (i = 0; i < 2; i++)
    {
        /* RelationalOperator: '<S3308>/Comparison' */
        rtb_TmpSignalConversionAtVeBTRR = rtb_TmpSignalConversionAtVaCT_l[i];

        /* Logic: '<S3308>/Logical1' incorporates:
         *  Constant: '<S3308>/ConstantValue1'
         *  Constant: '<S3308>/ConstantValue2'
         *  Logic: '<S3308>/Logical'
         *  Logic: '<S3308>/Logical2'
         *  RelationalOperator: '<S3308>/Comparison'
         *  RelationalOperator: '<S3308>/Comparison1'
         */
        rtb_Comparison5_l2[i] = (((rtb_TmpSignalConversionAtVeBTRR > 0.0F) &&
            rtb_Switch1_bkm) || ((rtb_TmpSignalConversionAtVeBTRR < 0.0F) &&
            rtb_Switch1_abpr));

        /* Product: '<S3308>/Product1' incorporates:
         *  Constant: '<S3308>/ConstantValue'
         *  Product: '<S3309>/Product1'
         *  Product: '<S3310>/Product1'
         *  Product: '<S3311>/Product1'
         *  Product: '<S3312>/Product1'
         */
        Switch3_h[i] = 0.1F * rtb_TmpSignalConversionAtVeBTRR;
    }

    /* RelationalOperator: '<S3309>/Comparison2' incorporates:
     *  Constant: '<S3330>/Calib'
     *  UnitDelay: '<S3237>/UnitDelay5'
     */
    rtb_Switch1_bkm = (THMR_ac_DW.UnitDelay5_DSTATE >=
                       KeTHMR_n_MaxAntWdHCP_MBCHTLLTL);

    /* RelationalOperator: '<S3309>/Comparison3' incorporates:
     *  Constant: '<S3333>/Calib'
     *  UnitDelay: '<S3237>/UnitDelay5'
     */
    rtb_Switch1_abpr = (THMR_ac_DW.UnitDelay5_DSTATE <=
                        KeTHMR_n_MinAntWdHCP_MBCHTLLTL);
    for (i = 0; i < 2; i++)
    {
        /* RelationalOperator: '<S3309>/Comparison' */
        rtb_TmpSignalConversionAtVeBTRR = rtb_TmpSignalConversionAtVaCT_l[i];

        /* Logic: '<S3309>/Logical1' incorporates:
         *  Constant: '<S3309>/ConstantValue1'
         *  Constant: '<S3309>/ConstantValue2'
         *  Logic: '<S3309>/Logical'
         *  Logic: '<S3309>/Logical2'
         *  RelationalOperator: '<S3309>/Comparison'
         *  RelationalOperator: '<S3309>/Comparison1'
         */
        rtb_Logical1_k3[i] = (((rtb_TmpSignalConversionAtVeBTRR < 0.0F) &&
                               rtb_Switch1_bkm) ||
                              ((rtb_TmpSignalConversionAtVeBTRR > 0.0F) &&
                               rtb_Switch1_abpr));
    }

    /* RelationalOperator: '<S3310>/Comparison2' incorporates:
     *  Constant: '<S3325>/Calib'
     *  UnitDelay: '<S3237>/UnitDelay6'
     */
    rtb_Switch1_bkm = (THMR_ac_DW.UnitDelay6_DSTATE >=
                       KeTHMR_Pct_MaxAntWdVHTL_MBCHTLLTL);

    /* RelationalOperator: '<S3310>/Comparison3' incorporates:
     *  Constant: '<S3327>/Calib'
     *  UnitDelay: '<S3237>/UnitDelay6'
     */
    rtb_Switch1_abpr = (THMR_ac_DW.UnitDelay6_DSTATE <=
                        KeTHMR_Pct_MinAntWdVHTL_MBCHTLLTL);
    for (i = 0; i < 2; i++)
    {
        /* RelationalOperator: '<S3310>/Comparison' */
        rtb_TmpSignalConversionAtVeBTRR = rtb_TmpSignalConversionAtVaCT_l[i];

        /* Logic: '<S3310>/Logical1' incorporates:
         *  Constant: '<S3310>/ConstantValue1'
         *  Constant: '<S3310>/ConstantValue2'
         *  Logic: '<S3310>/Logical'
         *  Logic: '<S3310>/Logical2'
         *  RelationalOperator: '<S3310>/Comparison'
         *  RelationalOperator: '<S3310>/Comparison1'
         */
        rtb_Logical1_oz[i] = (((rtb_TmpSignalConversionAtVeBTRR > 0.0F) &&
                               rtb_Switch1_bkm) ||
                              ((rtb_TmpSignalConversionAtVeBTRR < 0.0F) &&
                               rtb_Switch1_abpr));
    }

    /* RelationalOperator: '<S3311>/Comparison2' incorporates:
     *  Constant: '<S3331>/Calib'
     *  UnitDelay: '<S3237>/UnitDelay1'
     */
    rtb_Switch1_bkm = (THMR_ac_DW.UnitDelay1_DSTATE >=
                       KeTHMR_n_MaxAntWdPECP1_MBCHTLLTL);

    /* RelationalOperator: '<S3311>/Comparison3' incorporates:
     *  Constant: '<S3334>/Calib'
     *  UnitDelay: '<S3237>/UnitDelay1'
     */
    rtb_Switch1_abpr = (THMR_ac_DW.UnitDelay1_DSTATE <=
                        KeTHMR_n_MinAntWdPECP1_MBCHTLLTL);
    for (i = 0; i < 2; i++)
    {
        /* RelationalOperator: '<S3311>/Comparison' */
        rtb_TmpSignalConversionAtVeBTRR = rtb_TmpSignalConversionAtVaCT_l[i];

        /* Logic: '<S3311>/Logical1' incorporates:
         *  Constant: '<S3311>/ConstantValue1'
         *  Constant: '<S3311>/ConstantValue2'
         *  Logic: '<S3311>/Logical'
         *  Logic: '<S3311>/Logical2'
         *  RelationalOperator: '<S3311>/Comparison'
         *  RelationalOperator: '<S3311>/Comparison1'
         */
        rtb_Logical1_bwd[i] = (((rtb_TmpSignalConversionAtVeBTRR < 0.0F) &&
                                rtb_Switch1_bkm) ||
                               ((rtb_TmpSignalConversionAtVeBTRR > 0.0F) &&
                                rtb_Switch1_abpr));
    }

    /* RelationalOperator: '<S3312>/Comparison2' incorporates:
     *  Constant: '<S3332>/Calib'
     *  UnitDelay: '<S3237>/UnitDelay'
     */
    rtb_Switch1_bkm = (THMR_ac_DW.UnitDelay_DSTATE_m >=
                       KeTHMR_n_MaxAntWdPECP2_MBCHTLLTL);

    /* RelationalOperator: '<S3312>/Comparison3' incorporates:
     *  Constant: '<S3335>/Calib'
     *  UnitDelay: '<S3237>/UnitDelay'
     */
    rtb_Switch1_abpr = (THMR_ac_DW.UnitDelay_DSTATE_m <=
                        KeTHMR_n_MinAntWdPECP2_MBCHTLLTL);
    for (i = 0; i < 2; i++)
    {
        /* RelationalOperator: '<S3312>/Comparison' */
        rtb_TmpSignalConversionAtVeBTRR = rtb_TmpSignalConversionAtVaCT_l[i];

        /* Logic: '<S3312>/Logical1' incorporates:
         *  Constant: '<S3312>/ConstantValue1'
         *  Constant: '<S3312>/ConstantValue2'
         *  Logic: '<S3312>/Logical'
         *  Logic: '<S3312>/Logical2'
         *  RelationalOperator: '<S3312>/Comparison'
         *  RelationalOperator: '<S3312>/Comparison1'
         */
        rtb_Logical1_nb[i] = (((rtb_TmpSignalConversionAtVeBTRR < 0.0F) &&
                               rtb_Switch1_bkm) ||
                              ((rtb_TmpSignalConversionAtVeBTRR > 0.0F) &&
                               rtb_Switch1_abpr));
    }

    /* RelationalOperator: '<S3313>/Comparison2' incorporates:
     *  Constant: '<S3324>/Calib'
     *  UnitDelay: '<S3237>/UnitDelay2'
     */
    rtb_Switch1_bkm = (THMR_ac_DW.UnitDelay2_DSTATE >=
                       KeTHMR_Pct_MaxAntWdLTRVlv_MBCHTLLTL);

    /* RelationalOperator: '<S3313>/Comparison3' incorporates:
     *  Constant: '<S3326>/Calib'
     *  UnitDelay: '<S3237>/UnitDelay2'
     */
    rtb_Switch1_abpr = (THMR_ac_DW.UnitDelay2_DSTATE <=
                        KeTHMR_Pct_MinAntWdLTRVlv_MBCHTLLTL);
    for (i = 0; i < 2; i++)
    {
        /* RelationalOperator: '<S3313>/Comparison' */
        rtb_TmpSignalConversionAtVeBTRR = rtb_TmpSignalConversionAtVaCT_l[i];

        /* Switch: '<S3313>/Switch1' incorporates:
         *  Constant: '<S3313>/ConstantValue1'
         *  Constant: '<S3313>/ConstantValue2'
         *  Logic: '<S3313>/Logical'
         *  Logic: '<S3313>/Logical1'
         *  Logic: '<S3313>/Logical2'
         *  RelationalOperator: '<S3313>/Comparison'
         *  RelationalOperator: '<S3313>/Comparison1'
         */
        if (((rtb_TmpSignalConversionAtVeBTRR > 0.0F) && rtb_Switch1_bkm) ||
                ((rtb_TmpSignalConversionAtVeBTRR < 0.0F) && rtb_Switch1_abpr))
        {
            /* Switch: '<S3313>/Switch1' incorporates:
             *  Constant: '<S3313>/ConstantValue3'
             */
            rtb_TmpSignalConversionAtVaCT_o[i] = 0.0F;
        }
        else
        {
            /* Switch: '<S3313>/Switch1' incorporates:
             *  Constant: '<S3313>/ConstantValue'
             *  Product: '<S3313>/Product1'
             */
            rtb_TmpSignalConversionAtVaCT_o[i] = 0.1F *
                rtb_TmpSignalConversionAtVeBTRR;
        }

        /* End of Switch: '<S3313>/Switch1' */
    }

    /* RelationalOperator: '<S3314>/Comparison2' incorporates:
     *  Constant: '<S3328>/Calib'
     *  UnitDelay: '<S3237>/UnitDelay3'
     */
    rtb_Switch1_bkm = (THMR_ac_DW.UnitDelay3_DSTATE >=
                       KeTHMR_dV_MaxAntWdFan_MBCHTLLTL);

    /* RelationalOperator: '<S3314>/Comparison3' incorporates:
     *  Constant: '<S3329>/Calib'
     *  UnitDelay: '<S3237>/UnitDelay3'
     */
    rtb_Switch1_abpr = (THMR_ac_DW.UnitDelay3_DSTATE <=
                        KeTHMR_dV_MinAntWdFan_MBCHTLLTL);
    for (i = 0; i < 2; i++)
    {
        /* RelationalOperator: '<S3314>/Comparison' */
        rtb_TmpSignalConversionAtVeBTRR = rtb_TmpSignalConversionAtVaCT_l[i];

        /* Switch: '<S3314>/Switch1' incorporates:
         *  Constant: '<S3314>/ConstantValue1'
         *  Constant: '<S3314>/ConstantValue2'
         *  Logic: '<S3314>/Logical'
         *  Logic: '<S3314>/Logical1'
         *  Logic: '<S3314>/Logical2'
         *  RelationalOperator: '<S3314>/Comparison'
         *  RelationalOperator: '<S3314>/Comparison1'
         */
        if (((rtb_TmpSignalConversionAtVeBTRR < 0.0F) && rtb_Switch1_bkm) ||
                ((rtb_TmpSignalConversionAtVeBTRR > 0.0F) && rtb_Switch1_abpr))
        {
            /* Switch: '<S3314>/Switch1' incorporates:
             *  Constant: '<S3314>/ConstantValue3'
             */
            rtb_TmpSignalConversionAtVeBTRR = 0.0F;
        }
        else
        {
            /* Switch: '<S3314>/Switch1' incorporates:
             *  Constant: '<S3314>/ConstantValue'
             *  Product: '<S3314>/Product1'
             */
            rtb_TmpSignalConversionAtVeBTRR *= 0.1F;
        }

        /* End of Switch: '<S3314>/Switch1' */

        /* Switch: '<S3314>/Switch1' incorporates:
         *  RelationalOperator: '<S3314>/Comparison'
         */
        rtb_TmpSignalConversionAtVaCT_l[i] = rtb_TmpSignalConversionAtVeBTRR;
    }

    /* Product: '<S64>/Product' incorporates:
     *  Constant: '<S3233>/Calib'
     */
    THMR_ac_B.Product = KeTHMR_Cf_HtrPwrCnvsn_MBCHTLLTL *
        VeTHMR_P_LQGECH_MBCHTLLTL;

    /* Gain: '<S3238>/Gain' */
    THMR_ac_B.Gain = VeTHMR_Pct_LQGVHTL_MBCHTLLTL;

    /* Gain: '<S3239>/Gain' */
    THMR_ac_B.Gain_c = VeTHMR_n_LQGPECP1_MBCHTLLTL;

    /* Gain: '<S3240>/Gain' */
    THMR_ac_B.Gain_o = VeTHMR_n_LQGPECP2_MBCHTLLTL;

    /* Gain: '<S3241>/Gain' */
    THMR_ac_B.Gain_l = VeTHMR_dV_LQGFan_MBCHTLLTL;

    /* Gain: '<S3242>/Gain' */
    THMR_ac_B.Gain_p = VeTHMR_Pct_LQGLTRVlv_MBCHTLLTL;

    /* Gain: '<S3243>/Gain' */
    THMR_ac_B.Gain_i = VeTHMR_n_LQGHCP_MBCHTLLTL;

    /* SignalConversion generated from: '<S3232>/Gain1' incorporates:
     *  Constant: '<S3234>/Calib'
     *  Product: '<S64>/Product1'
     */
    tmp_8[0] = VeTHMR_P_LQGECH_MBCHTLLTL_BfGrdLim;
    tmp_8[1] = VeTHMR_n_LQGHCP_MBCHTLLTL_BfGrdLim;
    tmp_8[2] = VeTHMR_Pct_LQGVHTL_MBCHTLLTL_BfGrdLim;
    tmp_8[3] = VeTHMR_n_LQGPECP1_MBCHTLLTL_BfGrdLim;
    tmp_8[4] = VeTHMR_n_LQGPECP2_MBCHTLLTL_BfGrdLim;
    tmp_8[5] = VeTHMR_Pct_LQGLTRVlv_MBCHTLLTL_BfGrdLim;
    tmp_8[6] = VeTHMR_dV_LQGFan_MBCHTLLTL_BfGrdLim;
    tmp_8[7] = VeTHMR_v_Vehicle * KeTHMR_Cf_VehSpdCnvsn_MBCHTLLTL;
    tmp_8[8] = VeTHMR_T_HCCTOSArb;
    tmp_8[9] = THMR_ac_B.VariantMerge_Fo_p;
    for (i = 0; i < 3; i++)
    {
        /* Sum: '<S3232>/Add1' incorporates:
         *  Constant: '<S3231>/Calib'
         *  Constant: '<S3232>/Constant'
         *  Gain: '<S3232>/Gain2'
         */
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 3;
                rtb_DataTypeConversion2++)
        {
            rtb_Switch10 = 0.0F;
            for (i_0 = 0; i_0 < 2; i_0++)
            {
                rtb_Switch10 += KaTHMR_k_Lkalman_MBCHTLLTL[(3 * i_0) + i] *
                    KaTHMR_k_Ckalman_MBCHTLLTL[(rtb_DataTypeConversion2 * 2) +
                    i_0];
            }

            i_0 = (3 * rtb_DataTypeConversion2) + i;
            tmp_3[i_0] = KaTHMR_k_Akalman_MBCHTLLTL[(i_0)] - rtb_Switch10;
        }

        /* End of Sum: '<S3232>/Add1' */

        /* Sum: '<S3232>/Add' incorporates:
         *  Gain: '<S3232>/Gain1'
         */
        rtb_Switch10 = 0.0F;
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 10;
                rtb_DataTypeConversion2++)
        {
            rtb_Switch10 += KaTHMR_k_Bkalman_MBCHTLLTL[(3 *
                rtb_DataTypeConversion2) + i] * tmp_8[rtb_DataTypeConversion2];
        }

        tmp[i] = rtb_Switch10 + rtb_Selector_c[i];

        /* Product: '<S3232>/Product1' incorporates:
         *  UnitDelay: '<S3232>/UnitDelay'
         */
        tmp_0[i] = 0.0F;
        for (rtb_DataTypeConversion2 = 0; rtb_DataTypeConversion2 < 3;
                rtb_DataTypeConversion2++)
        {
            tmp_0[i] += tmp_3[(3 * rtb_DataTypeConversion2) + i] *
                THMR_ac_DW.UnitDelay_DSTATE[rtb_DataTypeConversion2];
        }

        /* End of Product: '<S3232>/Product1' */
    }

    /* Update for UnitDelay: '<S3232>/UnitDelay' incorporates:
     *  Sum: '<S3232>/Add'
     */
    for (i = 0; i < 3; i++)
    {
        THMR_ac_DW.UnitDelay_DSTATE[i] = tmp[i] + tmp_0[i];
    }

    /* End of Update for UnitDelay: '<S3232>/UnitDelay' */
    for (i = 0; i < 2; i++)
    {
        /* Product: '<S3311>/Product1' incorporates:
         *  UnitDelay: '<S3311>/UnitDelay'
         */
        rtb_TmpSignalConversionAtVeBTRR = Switch3_h[i];

        /* Switch: '<S3311>/Switch1' incorporates:
         *  Constant: '<S3311>/ConstantValue3'
         *  UnitDelay: '<S3311>/UnitDelay'
         */
        if (rtb_Logical1_bwd[i])
        {
            rtb_TmpSignalConversionAtVeT_jp = 0.0F;
        }
        else
        {
            rtb_TmpSignalConversionAtVeT_jp = rtb_TmpSignalConversionAtVeBTRR;
        }

        /* End of Switch: '<S3311>/Switch1' */

        /* Update for UnitDelay: '<S3311>/UnitDelay' incorporates:
         *  Sum: '<S3311>/Sum'
         */
        THMR_ac_DW.UnitDelay_DSTATE_e[i] += rtb_TmpSignalConversionAtVeT_jp;

        /* Switch: '<S3312>/Switch1' incorporates:
         *  Constant: '<S3312>/ConstantValue3'
         *  UnitDelay: '<S3312>/UnitDelay'
         */
        if (rtb_Logical1_nb[i])
        {
            rtb_TmpSignalConversionAtVeT_jp = 0.0F;
        }
        else
        {
            rtb_TmpSignalConversionAtVeT_jp = rtb_TmpSignalConversionAtVeBTRR;
        }

        /* End of Switch: '<S3312>/Switch1' */

        /* Update for UnitDelay: '<S3312>/UnitDelay' incorporates:
         *  Sum: '<S3312>/Sum'
         */
        THMR_ac_DW.UnitDelay_DSTATE_i[i] += rtb_TmpSignalConversionAtVeT_jp;

        /* Update for UnitDelay: '<S3313>/UnitDelay' incorporates:
         *  Sum: '<S3313>/Sum'
         */
        THMR_ac_DW.UnitDelay_DSTATE_k[i] += rtb_TmpSignalConversionAtVaCT_o[i];

        /* Update for UnitDelay: '<S3314>/UnitDelay' incorporates:
         *  Sum: '<S3314>/Sum'
         */
        THMR_ac_DW.UnitDelay_DSTATE_h[i] += rtb_TmpSignalConversionAtVaCT_l[i];

        /* Switch: '<S3309>/Switch1' incorporates:
         *  Constant: '<S3309>/ConstantValue3'
         *  UnitDelay: '<S3309>/UnitDelay'
         */
        if (rtb_Logical1_k3[i])
        {
            rtb_TmpSignalConversionAtVeT_jp = 0.0F;
        }
        else
        {
            rtb_TmpSignalConversionAtVeT_jp = rtb_TmpSignalConversionAtVeBTRR;
        }

        /* End of Switch: '<S3309>/Switch1' */

        /* Update for UnitDelay: '<S3309>/UnitDelay' incorporates:
         *  Sum: '<S3309>/Sum'
         */
        THMR_ac_DW.UnitDelay_DSTATE_d[i] += rtb_TmpSignalConversionAtVeT_jp;

        /* Switch: '<S3308>/Switch1' incorporates:
         *  Constant: '<S3308>/ConstantValue3'
         *  UnitDelay: '<S3308>/UnitDelay'
         */
        if (rtb_Comparison5_l2[i])
        {
            rtb_TmpSignalConversionAtVeT_jp = 0.0F;
        }
        else
        {
            rtb_TmpSignalConversionAtVeT_jp = rtb_TmpSignalConversionAtVeBTRR;
        }

        /* End of Switch: '<S3308>/Switch1' */

        /* Update for UnitDelay: '<S3308>/UnitDelay' incorporates:
         *  Sum: '<S3308>/Sum'
         */
        THMR_ac_DW.UnitDelay_DSTATE_is[i] += rtb_TmpSignalConversionAtVeT_jp;

        /* Switch: '<S3310>/Switch1' incorporates:
         *  Constant: '<S3310>/ConstantValue3'
         *  UnitDelay: '<S3310>/UnitDelay'
         */
        if (rtb_Logical1_oz[i])
        {
            rtb_TmpSignalConversionAtVeBTRR = 0.0F;
        }

        /* End of Switch: '<S3310>/Switch1' */

        /* Update for UnitDelay: '<S3310>/UnitDelay' incorporates:
         *  Sum: '<S3310>/Sum'
         */
        THMR_ac_DW.UnitDelay_DSTATE_a[i] += rtb_TmpSignalConversionAtVeBTRR;
    }

    /* Update for UnitDelay: '<S3237>/UnitDelay4' */
    THMR_ac_DW.UnitDelay4_DSTATE = VeTHMR_P_LQGECH_MBCHTLLTL_BfGrdLim;

    /* Update for UnitDelay: '<S3237>/UnitDelay5' */
    THMR_ac_DW.UnitDelay5_DSTATE = VeTHMR_n_LQGHCP_MBCHTLLTL_BfGrdLim;

    /* Update for UnitDelay: '<S3237>/UnitDelay6' */
    THMR_ac_DW.UnitDelay6_DSTATE = VeTHMR_Pct_LQGVHTL_MBCHTLLTL_BfGrdLim;

    /* Update for UnitDelay: '<S3237>/UnitDelay1' */
    THMR_ac_DW.UnitDelay1_DSTATE = VeTHMR_n_LQGPECP1_MBCHTLLTL_BfGrdLim;

    /* Update for UnitDelay: '<S3237>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_m = VeTHMR_n_LQGPECP2_MBCHTLLTL_BfGrdLim;

    /* Update for UnitDelay: '<S3237>/UnitDelay2' */
    THMR_ac_DW.UnitDelay2_DSTATE = VeTHMR_Pct_LQGLTRVlv_MBCHTLLTL_BfGrdLim;

    /* Update for UnitDelay: '<S3237>/UnitDelay3' */
    THMR_ac_DW.UnitDelay3_DSTATE = VeTHMR_dV_LQGFan_MBCHTLLTL_BfGrdLim;

    /* End of Outputs for SubSystem: '<S2>/MBC_HTL_LTCL' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
#endif

    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* Inport: '<Root>/VeINVR_b_BstCnvtrUpprIGBT_TmpFltdFA' */
    (void)Rte_Read_VeINVR_b_BstCnvtrUpprIGBT_TmpFltdFA_Value(&tmpRead_1z);

    /* Inport: '<Root>/VeINVR_T_BstCnvtrUpprIGBT_TmpFltd' */
    (void)Rte_Read_VeINVR_T_BstCnvtrUpprIGBT_TmpFltd_Value(&tmpRead_1y);

    /* Inport: '<Root>/VeINVR_b_BstCnvtrReactorTmpFA' */
    (void)Rte_Read_VeINVR_b_BstCnvtrReactorTmpFA_Value(&tmpRead_1x);

    /* Inport: '<Root>/VeINVR_T_BstCnvtrReactorTmp' */
    (void)Rte_Read_VeINVR_T_BstCnvtrReactorTmp_Value(&tmpRead_1w);

    /* Inport: '<Root>/VeINVR_b_BstCnvtrLwrIGBT_TmpFltdFA' */
    (void)Rte_Read_VeINVR_b_BstCnvtrLwrIGBT_TmpFltdFA_Value(&tmpRead_1v);

    /* Inport: '<Root>/VeINVR_T_BstCnvtrLwrIGBT_TmpFltd' */
    (void)Rte_Read_VeINVR_T_BstCnvtrLwrIGBT_TmpFltd_Value(&tmpRead_1u);

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/INVRInputTriggered'
     */
    /* Switch: '<S61>/Switch2' incorporates:
     *  Constant: '<S2268>/Calib'
     */
    if (KeTHMR_T_BstCnvtrLwrIGBT_TmpFltd_SD)
    {
        /* Switch: '<S61>/Switch2' incorporates:
         *  Constant: '<S2267>/Calib'
         */
        THMR_ac_B.Switch2 = KeTHMR_T_BstCnvtrLwrIGBT_TmpFltd_D;
    }
    else
    {
        /* Switch: '<S61>/Switch2' */
        THMR_ac_B.Switch2 = tmpRead_1u;
    }

    /* End of Switch: '<S61>/Switch2' */

    /* Switch: '<S61>/Switch1' incorporates:
     *  Constant: '<S2274>/Calib'
     */
    if (KeTHMR_b_BstCnvtrLwrIGBT_TmpFltdFA_SD)
    {
        /* Switch: '<S61>/Switch1' incorporates:
         *  Constant: '<S2273>/Calib'
         */
        THMR_ac_B.Switch1_o = KeTHMR_b_BstCnvtrLwrIGBT_TmpFltdFA_D;
    }
    else
    {
        /* Switch: '<S61>/Switch1' */
        THMR_ac_B.Switch1_o = tmpRead_1v;
    }

    /* End of Switch: '<S61>/Switch1' */

    /* Switch: '<S61>/Switch3' incorporates:
     *  Constant: '<S2270>/Calib'
     */
    if (KeTHMR_T_BstCnvtrReactorTmp_SD)
    {
        /* Switch: '<S61>/Switch3' incorporates:
         *  Constant: '<S2269>/Calib'
         */
        THMR_ac_B.Switch3 = KeTHMR_T_BstCnvtrReactorTmp_D;
    }
    else
    {
        /* Switch: '<S61>/Switch3' */
        THMR_ac_B.Switch3 = tmpRead_1w;
    }

    /* End of Switch: '<S61>/Switch3' */

    /* Switch: '<S61>/Switch5' incorporates:
     *  Constant: '<S2276>/Calib'
     */
    if (KeTHMR_b_BstCnvtrReactorTmpFA_SD)
    {
        /* Switch: '<S61>/Switch5' incorporates:
         *  Constant: '<S2275>/Calib'
         */
        THMR_ac_B.Switch5_c = KeTHMR_b_BstCnvtrReactorTmpFA_D;
    }
    else
    {
        /* Switch: '<S61>/Switch5' */
        THMR_ac_B.Switch5_c = tmpRead_1x;
    }

    /* End of Switch: '<S61>/Switch5' */

    /* Switch: '<S61>/Switch4' incorporates:
     *  Constant: '<S2272>/Calib'
     */
    if (KeTHMR_T_BstCnvtrUpprIGBT_TmpFltd_SD)
    {
        /* Switch: '<S61>/Switch4' incorporates:
         *  Constant: '<S2271>/Calib'
         */
        THMR_ac_B.Switch4 = KeTHMR_T_BstCnvtrUpprIGBT_TmpFltd_D;
    }
    else
    {
        /* Switch: '<S61>/Switch4' */
        THMR_ac_B.Switch4 = tmpRead_1y;
    }

    /* End of Switch: '<S61>/Switch4' */

    /* Switch: '<S61>/Switch6' incorporates:
     *  Constant: '<S2278>/Calib'
     */
    if (KeTHMR_b_BstCnvtrUpprIGBT_TmpFltdFA_SD)
    {
        /* Switch: '<S61>/Switch6' incorporates:
         *  Constant: '<S2277>/Calib'
         */
        THMR_ac_B.Switch6_g = KeTHMR_b_BstCnvtrUpprIGBT_TmpFltdFA_D;
    }
    else
    {
        /* Switch: '<S61>/Switch6' */
        THMR_ac_B.Switch6_g = tmpRead_1z;
    }

    /* End of Switch: '<S61>/Switch6' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/ActiveAirDam_Output_Ovrd'
     */
    /* SignalConversion generated from: '<S36>/AAD_RetrctReq_B4D' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

    /* Outputs for Function Call SubSystem: '<S2>/ActiveAirDam_ThermalRequest' */
    /* Outputs for Function Call SubSystem: '<S2>/LTCL' */
    /* Logic: '<S37>/Logical4' incorporates:
     *  Constant: '<S100>/Calib'
     *  Constant: '<S101>/Calib'
     *  Constant: '<S102>/Calib'
     *  Constant: '<S90>/Constant'
     *  Constant: '<S91>/Calib'
     *  Constant: '<S92>/Calib'
     *  Constant: '<S93>/Calib'
     *  Constant: '<S94>/Calib'
     *  Constant: '<S95>/Calib'
     *  Constant: '<S96>/Calib'
     *  Constant: '<S97>/Calib'
     *  Constant: '<S98>/Calib'
     *  Constant: '<S99>/Calib'
     *  Inport: '<S2741>/In1'
     *  Logic: '<S37>/Logical2'
     *  Logic: '<S37>/Logical5'
     *  RelationalOperator: '<S2928>/Relational Operator6'
     *  RelationalOperator: '<S37>/Comparison1'
     *  RelationalOperator: '<S37>/Comparison10'
     *  RelationalOperator: '<S37>/Comparison11'
     *  RelationalOperator: '<S37>/Comparison12'
     *  RelationalOperator: '<S37>/Comparison13'
     *  RelationalOperator: '<S37>/Comparison2'
     *  RelationalOperator: '<S37>/Comparison3'
     *  RelationalOperator: '<S37>/Comparison4'
     *  RelationalOperator: '<S37>/Comparison5'
     *  RelationalOperator: '<S37>/Comparison6'
     *  RelationalOperator: '<S37>/Comparison7'
     *  RelationalOperator: '<S37>/Comparison8'
     *  RelationalOperator: '<S37>/Comparison9'
     */
    VeTHMR_b_AAD_RetrctArb = ((((TmpSignalConversionAtOutAirTemp <=
        KeTHMR_T_AAD_AmbMinTemp) || (((uint32)VeTHMR_e_EmrgcyFanRq_Lvl_B4D) !=
        CeTHMR_e_No_EmrgcyFanRq)) || ((rtb_TmpSignalConversionAtVeB_cl >=
        KeTHMR_T_AAD_CellOverTemp) && (TmpSignalConversionAtOutAirTemp <=
        KeTHMR_T_AAD_AmbMaxTemp))) || (((((((((rtb_TmpSignalConversionAtVaCT_e[0]
        >= KeTHMR_T_AAD_GenConClmp_Max) || (rtb_TmpSignalConversionAtVaCT_e[1] >=
        KeTHMR_T_AAD_ACConClmp_Max)) || (rtb_TmpSignalConversionAtVaCT_e[2] >=
        KeTHMR_T_AAD_DCConClmp_Max)) || (rtb_TmpSignalConversionAtVaCT_e[3] >=
        KeTHMR_T_AAD_REEVConClmp_Max)) || (rtb_TmpSignalConversionAtVaC_ls[0] >=
        KeTHMR_T_AAD_REDMConClmp_Max)) || (rtb_TmpSignalConversionAtVaC_ls[1] >=
        KeTHMR_T_AAD_HVBP_REDMConClmp_Max)) || (rtb_TmpSignalConversionAtVaCTMR
        [0] >= KeTHMR_T_AAD_FEDMConClmp_Max)) ||
        (rtb_TmpSignalConversionAtVaCTMR[1] >= KeTHMR_T_AAD_HVBP_FEDMConClmp_Max))
        || (VeTHMR_T_PDCSurfTemp >= KeTHMR_T_AAD_PDCSurfTemp_Max)));

    /* End of Outputs for SubSystem: '<S2>/LTCL' */

    /* Outputs for Atomic SubSystem: '<S37>/CountDownResetEnabled' */
    /* Switch: '<S89>/Switch1' incorporates:
     *  Constant: '<S89>/ConstantValue'
     *  Logic: '<S37>/Logical8'
     *  Logic: '<S89>/AND'
     *  RelationalOperator: '<S89>/GreaterThan'
     *  Switch: '<S89>/Switch2'
     *  UnitDelay: '<S89>/UnitDelay'
     */
    if (!VeTHMR_b_AAD_RetrctArb)
    {
        /* Switch: '<S89>/Switch1' incorporates:
         *  Constant: '<S103>/Calib'
         */
        rtb_Switch_i3 = KeTHMR_t_AAD_RetrctDbncTime;
    }
    else if ((VeTHMR_b_AAD_RetrctArb) && (((sint32)
               THMR_ac_DW.UnitDelay_DSTATE_oe) > 0))
    {
        /* Switch: '<S89>/Switch2' incorporates:
         *  Constant: '<S89>/ConstantValue1'
         *  Sum: '<S89>/Subtraction'
         *  Switch: '<S89>/Switch1'
         *  UnitDelay: '<S89>/UnitDelay'
         */
        rtb_Switch_i3 = (uint16)((sint32)(((sint32)
            THMR_ac_DW.UnitDelay_DSTATE_oe) - 1));
    }
    else
    {
        /* Switch: '<S89>/Switch1' incorporates:
         *  Switch: '<S89>/Switch2'
         *  UnitDelay: '<S89>/UnitDelay'
         */
        rtb_Switch_i3 = THMR_ac_DW.UnitDelay_DSTATE_oe;
    }

    /* End of Switch: '<S89>/Switch1' */

    /* Update for UnitDelay: '<S89>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_oe = rtb_Switch_i3;

    /* Logic: '<S37>/Logical1' incorporates:
     *  Constant: '<S89>/ConstantValue2'
     *  RelationalOperator: '<S89>/GreaterThan1'
     */
    VeTHMR_b_AAD_RetrctReq_B4D = (((sint32)rtb_Switch_i3) <= 0);

    /* End of Outputs for SubSystem: '<S37>/CountDownResetEnabled' */
    /* End of Outputs for SubSystem: '<S2>/ActiveAirDam_ThermalRequest' */

    /* VariantMerge generated from: '<S36>/AAD_RetrctReq_B4D' */
    rtb_VeTHMR_b_AAD_RetrctReq_B4D = VeTHMR_b_AAD_RetrctReq_B4D;

#else

    /* VariantMerge generated from: '<S36>/AAD_RetrctReq_B4D' incorporates:
     *  SignalConversion generated from: '<S36>/AAD_RetrctReq_B4D'
     */
    rtb_VeTHMR_b_AAD_RetrctReq_B4D = false;

#endif

    /* End of SignalConversion generated from: '<S36>/AAD_RetrctReq_B4D' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_ActiveAirDam

    /* Inport: '<Root>/VeCTMR_T_PDCSurfTemp' */
    (void)Rte_Read_VeCTMR_T_PDCSurfTemp_Value(&tmpRead_20);

    /* Outputs for Function Call SubSystem: '<S2>/CTMR_Input_Override' */
    /* Switch: '<S44>/Switch2' incorporates:
     *  Constant: '<S260>/Calib'
     */
    if (KeTHMR_b_PDCSurfTemp_SD)
    {
        /* Switch: '<S44>/Switch2' incorporates:
         *  Constant: '<S259>/Calib'
         */
        VeTHMR_T_PDCSurfTemp = KeTHMR_T_PDCSurfTemp_D;
    }
    else
    {
        /* Switch: '<S44>/Switch2' */
        VeTHMR_T_PDCSurfTemp = tmpRead_20;
    }

    /* End of Switch: '<S44>/Switch2' */
    /* End of Outputs for SubSystem: '<S2>/CTMR_Input_Override' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
#endif

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/RacePrep_Current_Limiter'
     */
    /* Switch: '<S73>/Switch2' incorporates:
     *  Constant: '<S3737>/Calib'
     *  Inport: '<Root>/VeTPCR_I_RacePrepCurrentLim'
     *  SignalConversion generated from: '<S73>/VariantSource3'
     * */
#if Rte_SysCon_Variant_THMR_FUNC_RU_RacePrepCrrntLim

    (void)Rte_Read_VeTPCR_I_RacePrepCurrentLim_Value(&tmpRead_21);
    if (KeTHMR_b_EnblRacePrepChargeCntrl)
    {
        /* Switch: '<S73>/Switch2' incorporates:
         *  Constant: '<S3736>/Calib'
         */
        VeTHMR_I_RacePrepCurrentLim = KeTHMR_I_RacePrepMaxCurrentOvrd;
    }
    else
    {
        /* Switch: '<S73>/Switch2' */
        VeTHMR_I_RacePrepCurrentLim = tmpRead_21;
    }

    /* VariantMerge generated from: '<S73>/VariantSource3' incorporates:
     *  Constant: '<S3737>/Calib'
     *  Inport: '<Root>/VeTPCR_I_RacePrepCurrentLim'
     */
    THMR_ac_B.VariantMerge_For_Variant_Source = VeTHMR_I_RacePrepCurrentLim;

#else

    /* VariantMerge generated from: '<S73>/VariantSource3' incorporates:
     *  Constant: '<S3735>/Calib'
     *  SignalConversion generated from: '<S73>/VariantSource3'
     */
    THMR_ac_B.VariantMerge_For_Variant_Source = KeTHMR_I_ChargeCurrentLim_NF;

#endif

    /* End of Switch: '<S73>/Switch2' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/ActiveAirDam_Output_Ovrd'
     */
    /* Switch: '<S36>/Switch1' incorporates:
     *  Constant: '<S88>/Calib'
     */
    if (KeTHMR_b_AAD_RetrctReq_SD)
    {
        /* Outport: '<Root>/VeTHMR_b_AAD_RetrctReq' incorporates:
         *  Constant: '<S87>/Calib'
         *  SignalConversion generated from: '<S2>/AAD_RetrctReq'
         */
        (void)Rte_Write_VeTHMR_b_AAD_RetrctReq_Value(KeTHMR_b_AAD_RetrctReq_D);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_b_AAD_RetrctReq' incorporates:
         *  SignalConversion generated from: '<S2>/AAD_RetrctReq'
         */
        (void)Rte_Write_VeTHMR_b_AAD_RetrctReq_Value
            (rtb_VeTHMR_b_AAD_RetrctReq_B4D);
    }

    /* End of Switch: '<S36>/Switch1' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Cals'
     */
    /* Outport: '<Root>/VeTHMR_e_AC_CompState' incorporates:
     *  DataTypeConversion: '<S306>/DataTypeConversion'
     *  SignalConversion generated from: '<S2>/AC_CompState'
     */
    (void)Rte_Write_VeTHMR_e_AC_CompState_Value(THMR_ac_B.VeTHMR_e_ACComp);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Fan_Shutt_Command'
     */
    /* Switch: '<S1133>/Switch2' incorporates:
     *  Constant: '<S1139>/Calib'
     */
    if (KeTHMR_b_AGS2_PosReq_SD)
    {
        /* Outport: '<Root>/VeTHMR_Pct_AGS2_PosReq' incorporates:
         *  Constant: '<S1137>/Calib'
         *  SignalConversion generated from: '<S2>/AGS2_PosReq_AD'
         */
        (void)Rte_Write_VeTHMR_Pct_AGS2_PosReq_Value(KeTHMR_Pct_AGS2_PosReq_D);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_Pct_AGS2_PosReq' incorporates:
         *  SignalConversion generated from: '<S2>/AGS2_PosReq_AD'
         */
        (void)Rte_Write_VeTHMR_Pct_AGS2_PosReq_Value
            (rtb_TmpSignalConversionAtVeT_jm);
    }

    /* End of Switch: '<S1133>/Switch2' */

    /* Switch: '<S1133>/Switch1' incorporates:
     *  Constant: '<S1140>/Calib'
     */
    if (KeTHMR_b_AGS_PosReq_SD)
    {
        /* Outport: '<Root>/VeTHMR_Pct_AGS_PosReq' incorporates:
         *  Constant: '<S1138>/Calib'
         *  SignalConversion generated from: '<S2>/AGS_PosReq_AD'
         */
        (void)Rte_Write_VeTHMR_Pct_AGS_PosReq_Value(KeTHMR_Pct_AGS_PosReq_D);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_Pct_AGS_PosReq' incorporates:
         *  SignalConversion generated from: '<S2>/AGS_PosReq_AD'
         */
        (void)Rte_Write_VeTHMR_Pct_AGS_PosReq_Value
            (rtb_TmpSignalConversionAtVeTMIR);
    }

    /* End of Switch: '<S1133>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_b_AGS_State' incorporates:
     *  SignalConversion generated from: '<S2>/AGS_State_AD'
     */
    (void)Rte_Write_VeTHMR_b_AGS_State_Value(THMR_ac_B.VeTHMR_b_AGS_State);

    /* Outport: '<Root>/VeTHMR_T_AHPInletTempArb' incorporates:
     *  SignalConversion generated from: '<S2>/AHPInletTempArb'
     */
    (void)Rte_Write_VeTHMR_T_AHPInletTempArb_Value
        (rtb_TmpSignalConversionAtVeT_ms);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Cals'
     */
    /* Outport: '<Root>/VeTHMR_b_ActRemCompDecision' incorporates:
     *  Constant: '<S307>/Calib'
     *  Gain: '<S308>/Gain'
     *  SignalConversion generated from: '<S2>/ActRemCompDecision'
     */
    (void)Rte_Write_VeTHMR_b_ActRemCompDecision_Value
        (KeTHMR_b_ActRemCompDecision_Dial);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Fan_Shutt_Command'
     */
    /* Switch: '<S1134>/Switch1' incorporates:
     *  Constant: '<S1142>/Calib'
     */
    if (KeTHMR_b_AirFlowReq_SelDial)
    {
        /* Outport: '<Root>/VeTHMR_Pct_AirFlowReq' incorporates:
         *  Constant: '<S1141>/Calib'
         *  SignalConversion generated from: '<S2>/AirFlowReq_AftDial'
         */
        (void)Rte_Write_VeTHMR_Pct_AirFlowReq_Value(KeTHMR_Pct_AirFlowReq);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_Pct_AirFlowReq' incorporates:
         *  SignalConversion generated from: '<S2>/AirFlowReq_AftDial'
         */
        (void)Rte_Write_VeTHMR_Pct_AirFlowReq_Value(rtb_SumSub1_ni);
    }

    /* End of Switch: '<S1134>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_y_Htr_Slctn_State' incorporates:
     *  SignalConversion generated from: '<S2>/All_Htr_Slctn_State'
     */
    (void)Rte_Write_VeTHMR_y_Htr_Slctn_State_Value(rtb_Switch1_ev);

    /* Outport: '<Root>/VeTHMR_y_Htr_Oprtn_State' incorporates:
     *  SignalConversion generated from: '<S2>/All_Htr_State'
     */
    (void)Rte_Write_VeTHMR_y_Htr_Oprtn_State_Value(iteration_count);

    /* Outport: '<Root>/VeTHMR_Pct_BSG_LTR_PmpFlwRq' incorporates:
     *  SignalConversion generated from: '<S2>/BSG_LTR_PmpFlwRq'
     */
    (void)Rte_Write_VeTHMR_Pct_BSG_LTR_PmpFlwRq_Value
        (THMR_ac_B.VariantMerge_For_Variant_So_adz);

    /* Outport: '<Root>/VeTHMR_dV_MGU_ClntPumpFlw' incorporates:
     *  SignalConversion generated from: '<S2>/BSG_MGU_ClntPumpFlw'
     */
    (void)Rte_Write_VeTHMR_dV_MGU_ClntPumpFlw_Value
        (THMR_ac_B.VariantMerge_For_Variant_S_adzs);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LT_Batt_Loop'
     */
    /* S-Function (fcgen): '<S63>/Function-CallGenerator' incorporates:
     *  SubSystem: '<S63>/FcnCallFcnGen'
     */
    /* S-Function (fcgen): '<S3103>/Function-CallGenerator' incorporates:
     *  SubSystem: '<S63>/MBC_BTL'
     */
    /* Outport: '<Root>/VeTHMR_n_BTLPumpMBCReq' incorporates:
     *  Gain: '<S3141>/Gain'
     *  SignalConversion generated from: '<S2>/BTLPumpMBCReq'
     */
    (void)Rte_Write_VeTHMR_n_BTLPumpMBCReq_Value(VeTHMR_n_BTLPumpMBC);

    /* End of Outputs for S-Function (fcgen): '<S3103>/Function-CallGenerator' */
    /* End of Outputs for S-Function (fcgen): '<S63>/Function-CallGenerator' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Miscellaneous_Outputs'
     */
    /* Switch: '<S3353>/Switch' incorporates:
     *  Constant: '<S3390>/Calib'
     */
    if (KeTHMR_b_BatPerWU_ThrmlCond_Timer_SD)
    {
        /* Outport: '<Root>/VeTHMR_t_BatPerWU_ThrmlCond_Timer' incorporates:
         *  Constant: '<S3391>/Calib'
         *  SignalConversion generated from: '<S2>/BatPerWup_Timer'
         */
        (void)Rte_Write_VeTHMR_t_BatPerWU_ThrmlCond_Timer_Value
            (KeTHMR_t_BatPerWU_ThrmlCond_Timer_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_t_BatPerWU_ThrmlCond_Timer' incorporates:
         *  SignalConversion generated from: '<S2>/BatPerWup_Timer'
         */
        (void)Rte_Write_VeTHMR_t_BatPerWU_ThrmlCond_Timer_Value(tmpRead_y);
    }

    /* End of Switch: '<S3353>/Switch' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_e_BatThrmlSt' incorporates:
     *  SignalConversion generated from: '<S2>/BatThrmlSt1'
     *  VariantMerge generated from: '<S309>/VariantSource'
     */
    (void)Rte_Write_VeTHMR_e_BatThrmlSt_Value(THMR_ac_B.VariantMerge_Fo_p3);

    /* Outport: '<Root>/VeTHMR_b_BattSharedHeaterAllowed' incorporates:
     *  SignalConversion generated from: '<S2>/BattAllowed_SharedHtr'
     */
    (void)Rte_Write_VeTHMR_b_BattSharedHeaterAllowed_Value
        (THMR_ac_B.VariantMerge_Fo_at);

    /* Outport: '<Root>/VeTHMR_b_BattCondPlugin_Rq' incorporates:
     *  SignalConversion generated from: '<S2>/BattCondPlugin_Rq_AD'
     */
    (void)Rte_Write_VeTHMR_b_BattCondPlugin_Rq_Value(THMR_ac_B.VariantMerge_Fo_n);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Battery_Outputs'
     */
    /* Outport: '<Root>/VeTHMR_b_BattAllowed' incorporates:
     *  Gain: '<S192>/Gain'
     *  SignalConversion generated from: '<S2>/BattCooling_Allowed'
     */
    (void)Rte_Write_VeTHMR_b_BattAllowed_Value(THMR_ac_B.Switch1_h);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Branch_Flw_Output_Ovrd'
     */
    /* Switch: '<S42>/Switch2' incorporates:
     *  Constant: '<S251>/Calib'
     */
    if (KeTHMR_b_Branch_1_Flw_SD)
    {
        /* Outport: '<Root>/VeTHMR_dV_Branch_1_Flw' incorporates:
         *  Constant: '<S254>/Calib'
         *  SignalConversion generated from: '<S2>/Branch_1_Flw_AftDial'
         */
        (void)Rte_Write_VeTHMR_dV_Branch_1_Flw_Value(KeTHMR_dV_Branch_1_Flw_D);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_dV_Branch_1_Flw' incorporates:
         *  SignalConversion generated from: '<S2>/Branch_1_Flw_AftDial'
         */
        (void)Rte_Write_VeTHMR_dV_Branch_1_Flw_Value
            (rtb_VariantMerge_For_Variant_So);
    }

    /* End of Switch: '<S42>/Switch2' */

    /* Switch: '<S42>/Switch1' incorporates:
     *  Constant: '<S252>/Calib'
     */
    if (KeTHMR_b_Branch_2_Flw_SD)
    {
        /* Outport: '<Root>/VeTHMR_dV_Branch_2_Flw' incorporates:
         *  Constant: '<S255>/Calib'
         *  SignalConversion generated from: '<S2>/Branch_2_Flw_AftDial'
         */
        (void)Rte_Write_VeTHMR_dV_Branch_2_Flw_Value(KeTHMR_dV_Branch_2_Flw_D);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_dV_Branch_2_Flw' incorporates:
         *  SignalConversion generated from: '<S2>/Branch_2_Flw_AftDial'
         */
        (void)Rte_Write_VeTHMR_dV_Branch_2_Flw_Value
            (rtb_TmpSignalConversionAtVeT_fy);
    }

    /* End of Switch: '<S42>/Switch1' */

    /* Switch: '<S42>/Switch3' incorporates:
     *  Constant: '<S253>/Calib'
     */
    if (KeTHMR_b_Branch_3_Flw_SD)
    {
        /* Outport: '<Root>/VeTHMR_dV_Branch_3_Flw' incorporates:
         *  Constant: '<S256>/Calib'
         *  SignalConversion generated from: '<S2>/Branch_3_Flw_AftDial'
         */
        (void)Rte_Write_VeTHMR_dV_Branch_3_Flw_Value(KeTHMR_dV_Branch_3_Flw_D);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_dV_Branch_3_Flw' incorporates:
         *  SignalConversion generated from: '<S2>/Branch_3_Flw_AftDial'
         */
        (void)Rte_Write_VeTHMR_dV_Branch_3_Flw_Value
            (rtb_TmpSignalConversionAtVeTM_n);
    }

    /* End of Switch: '<S42>/Switch3' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_e_CabCoolThermalState' incorporates:
     *  Merge: '<S4570>/Merge2'
     *  SignalConversion generated from: '<S2>/CabCoolThermalState'
     */
    (void)Rte_Write_VeTHMR_e_CabCoolThermalState_Value
        (VeTHMR_e_CabCoolThermalState);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Comp_Outputs'
     */
    /* Outport: '<Root>/VeTHMR_b_CabAllowed' incorporates:
     *  Gain: '<S656>/Gain'
     *  SignalConversion generated from: '<S2>/CabCooling_Allowed'
     */
    (void)Rte_Write_VeTHMR_b_CabAllowed_Value(THMR_ac_B.Switch1_az);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_e_CabHeatThermalMode' incorporates:
     *  Merge: '<S4570>/Merge3'
     *  SignalConversion generated from: '<S2>/CabHeatThermalMode'
     */
    (void)Rte_Write_VeTHMR_e_CabHeatThermalMode_Value
        (THMR_ac_B.VeTHMR_e_CabHeatThermalMode);

    /* Outport: '<Root>/VeTHMR_e_CabHeatThermalState' incorporates:
     *  Merge: '<S4570>/Merge1'
     *  SignalConversion generated from: '<S2>/CabHeatThermalState'
     */
    (void)Rte_Write_VeTHMR_e_CabHeatThermalState_Value
        (THMR_ac_B.VeTHMR_e_CabHeatThermalState);

    /* Outport: '<Root>/VeTHMR_e_CabPrecondReqSt' incorporates:
     *  SignalConversion generated from: '<S2>/CabPrecondReqSt'
     *  VariantMerge generated from: '<S314>/VariantSource'
     */
    (void)Rte_Write_VeTHMR_e_CabPrecondReqSt_Value(THMR_ac_B.VariantMerge_Fo_ff);

    /* Outport: '<Root>/VeTHMR_e_CabThermalMode' incorporates:
     *  Merge: '<S4570>/Merge'
     *  SignalConversion generated from: '<S2>/CabThermalMode'
     */
    (void)Rte_Write_VeTHMR_e_CabThermalMode_Value(VeTHMR_e_CabThermalMode);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Comp_Outputs'
     */
    /* Outport: '<Root>/VeTHMR_b_CabReq_NotAllow' incorporates:
     *  Gain: '<S655>/Gain'
     *  SignalConversion generated from: '<S2>/Cab_Not_Allow_AS'
     */
    (void)Rte_Write_VeTHMR_b_CabReq_NotAllow_Value
        (THMR_ac_B.VeTHMR_b_CabReq_NotAllow_BS);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Cals'
     */
    /* Switch: '<S314>/Switch4' incorporates:
     *  Constant: '<S331>/Calib'
     *  Constant: '<S335>/Calib'
     *  Inport: '<Root>/VeTPCR_e_CabReqSt_Msgs'
     */
    if (KeTHMR_b_CabinPreCondReqStMsg_SD)
    {
        rtb_TmpSignalConversionAtVeTP_b = KeTHMR_e_CabinPreCondReqStMsg_D;
    }
    else
    {
        rtb_TmpSignalConversionAtVeTP_b = tmpRead_1i;
    }

    /* End of Switch: '<S314>/Switch4' */

    /* Outport: '<Root>/VeTHMR_e_CabinPreCondReqMsg' incorporates:
     *  DataTypeConversion: '<S314>/DataTypeConversion1'
     *  SignalConversion generated from: '<S2>/CabinPreCondReqMsg'
     */
    (void)Rte_Write_VeTHMR_e_CabinPreCondReqMsg_Value((sint16)
        rtb_TmpSignalConversionAtVeTP_b);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_e_CabinPreCondReqStat' incorporates:
     *  SignalConversion generated from: '<S2>/CabinPreCondReqStat'
     */
    (void)Rte_Write_VeTHMR_e_CabinPreCondReqStat_Value(s381_iter);

    /* Outport: '<Root>/VeTHMR_b_CabPrecond' incorporates:
     *  SignalConversion generated from: '<S2>/CabinPreCondReqStat_2'
     */
    (void)Rte_Write_VeTHMR_b_CabPrecond_Value(rtb_Switch_hql);

    /* Outport: '<Root>/VeTHMR_P_CabHeatPwrNeed' incorporates:
     *  SignalConversion generated from: '<S2>/CabinPwrNeeded_RawLimtd'
     */
    (void)Rte_Write_VeTHMR_P_CabHeatPwrNeed_Value(rtb_Switch1_dnd);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Cals'
     */
    /* Switch: '<S316>/Switch' incorporates:
     *  Constant: '<S341>/Calib'
     *  Constant: '<S342>/Calib'
     */
    if (KeTHMR_b_PPCTIS_OT_SD)
    {
        rtb_Logical15_j_tmp = KeTHMR_e_PPCTIS_OT_D;
    }

    /* Outport: '<Root>/VeTHMR_e_PPCTIS_OT' incorporates:
     *  SignalConversion generated from: '<S2>/Cals__PPCTIS_OT'
     *  Switch: '<S316>/Switch'
     */
    (void)Rte_Write_VeTHMR_e_PPCTIS_OT_Value(rtb_Logical15_j_tmp);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_dT_CellOverTemp' incorporates:
     *  SignalConversion generated from: '<S2>/CellOverTemp_AftDial'
     */
    (void)Rte_Write_VeTHMR_dT_CellOverTemp_Value
        (THMR_ac_B.VariantMerge_For_Varian_adzsu0c);

    /* Outport: '<Root>/VeTHMR_T_MaxBattAllow' incorporates:
     *  SignalConversion generated from: '<S2>/CellTempMaxAllowed'
     */
    (void)Rte_Write_VeTHMR_T_MaxBattAllow_Value(rtb_Add_h);

    /* Outport: '<Root>/VeTHMR_T_MaxBattAllowPsv' incorporates:
     *  SignalConversion generated from: '<S2>/CellTempMaxAllowedPsv'
     */
    (void)Rte_Write_VeTHMR_T_MaxBattAllowPsv_Value(rtb_Switch1_l3);

    /* Outport: '<Root>/VeTHMR_T_MinBattAllow' incorporates:
     *  SignalConversion generated from: '<S2>/CellTempMinAllowed'
     */
    (void)Rte_Write_VeTHMR_T_MinBattAllow_Value(VeTHMR_T_MinBattAllow);

    /* Outport: '<Root>/VeTHMR_T_MinBattAllowPsv' incorporates:
     *  SignalConversion generated from: '<S2>/CellTempMinAllowedPsv'
     */
    (void)Rte_Write_VeTHMR_T_MinBattAllowPsv_Value(rtb_UnitDelay_kww);

    /* Outport: '<Root>/VeTHMR_e_ClntNProp3WyVlv_State' incorporates:
     *  SignalConversion generated from: '<S2>/ClntNProp3WyVlv_State'
     *  VariantMerge generated from: '<S5642>/VariantSource'
     */
    (void)Rte_Write_VeTHMR_e_ClntNProp3WyVlv_State_Value
        (THMR_ac_B.VariantMerge_Fo_pz);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Clnt_Pmp_State_Determination'
     */
    /* RelationalOperator: '<S51>/Comparison4' */
    rtb_AND_fe = !THMR_ac_B.Comparison69;

    /* RelationalOperator: '<S51>/Comparison7' */
    rtb_TmpSignalConversionAtVePD_i = !THMR_ac_B.Comparison2;

    /* RelationalOperator: '<S51>/Comparison6' */
    rtb_TmpSignalConversionAtVePD_p = !THMR_ac_B.Comparison3;

    /* RelationalOperator: '<S51>/Comparison' */
    rtb_AND_de = !THMR_ac_B.Comparison1;

    /* Logic: '<S51>/Logical' incorporates:
     *  Logic: '<S51>/Logical4'
     *  Logic: '<S51>/Logical9'
     *  Switch: '<S619>/Switch1'
     *  Switch: '<S628>/Switch1'
     *  Switch: '<S629>/Switch1'
     *  Switch: '<S630>/Switch1'
     *  Switch: '<S631>/Switch1'
     *  Switch: '<S632>/Switch1'
     *  Switch: '<S633>/Switch1'
     *  Switch: '<S634>/Switch1'
     */
    rtb_LogicalOperator_aa = (rtb_AND_de && rtb_AND_fe);
    rtb_UnitDelay3_ff = (rtb_LogicalOperator_aa &&
                         rtb_TmpSignalConversionAtVePD_i);

    /* Switch: '<S619>/Switch1' incorporates:
     *  Constant: '<S610>/Constant'
     *  Logic: '<S51>/Logical'
     */
    if (rtb_UnitDelay3_ff && rtb_TmpSignalConversionAtVePD_p)
    {
        tmp_9 = CeTHMR_e_NoPump_On;
    }
    else
    {
        /* Logic: '<S51>/Logical1' incorporates:
         *  Logic: '<S51>/Logical16'
         *  Logic: '<S51>/Logical5'
         *  RelationalOperator: '<S51>/Comparison8'
         *  Switch: '<S628>/Switch1'
         *  Switch: '<S629>/Switch1'
         *  Switch: '<S630>/Switch1'
         *  Switch: '<S631>/Switch1'
         *  Switch: '<S632>/Switch1'
         *  Switch: '<S633>/Switch1'
         *  Switch: '<S634>/Switch1'
         *  Switch: '<S635>/Switch1'
         */
        rtb_AND_fe = ((THMR_ac_B.Comparison1) && rtb_AND_fe);
        rtb_TmpSignalConversionAtVeTR_k = (rtb_AND_fe &&
            rtb_TmpSignalConversionAtVePD_i);

        /* Switch: '<S628>/Switch1' incorporates:
         *  Constant: '<S614>/Constant'
         *  Logic: '<S51>/Logical1'
         */
        if (rtb_TmpSignalConversionAtVeTR_k && rtb_TmpSignalConversionAtVePD_p)
        {
            tmp_9 = CeTHMR_e_LTPP1_On;
        }
        else
        {
            /* Logic: '<S51>/Logical2' incorporates:
             *  Logic: '<S51>/Logical10'
             *  Logic: '<S51>/Logical6'
             *  RelationalOperator: '<S51>/Comparison11'
             *  Switch: '<S620>/Switch1'
             *  Switch: '<S629>/Switch1'
             *  Switch: '<S630>/Switch1'
             *  Switch: '<S631>/Switch1'
             *  Switch: '<S632>/Switch1'
             *  Switch: '<S633>/Switch1'
             *  Switch: '<S634>/Switch1'
             *  Switch: '<S635>/Switch1'
             */
            rtb_AND_de = (rtb_AND_de && (THMR_ac_B.Comparison69));
            rtb_VariantMerge_For_Variant__j = (rtb_AND_de &&
                rtb_TmpSignalConversionAtVePD_i);

            /* Switch: '<S629>/Switch1' incorporates:
             *  Constant: '<S611>/Constant'
             *  Logic: '<S51>/Logical2'
             */
            if (rtb_VariantMerge_For_Variant__j &&
                    rtb_TmpSignalConversionAtVePD_p)
            {
                tmp_9 = CeTHMR_e_LTPP2_On;
            }
            else
            {
                /* Logic: '<S51>/Logical3' incorporates:
                 *  Logic: '<S51>/Logical11'
                 *  Logic: '<S51>/Logical7'
                 *  RelationalOperator: '<S51>/Comparison14'
                 *  RelationalOperator: '<S51>/Comparison15'
                 *  Switch: '<S620>/Switch1'
                 *  Switch: '<S621>/Switch1'
                 *  Switch: '<S630>/Switch1'
                 *  Switch: '<S631>/Switch1'
                 *  Switch: '<S632>/Switch1'
                 *  Switch: '<S633>/Switch1'
                 *  Switch: '<S634>/Switch1'
                 *  Switch: '<S635>/Switch1'
                 */
                rtb_OR1_k3 = ((THMR_ac_B.Comparison1) && (THMR_ac_B.Comparison69));
                rtb_TmpSignalConversionAtVePD_i = (rtb_OR1_k3 &&
                    rtb_TmpSignalConversionAtVePD_i);

                /* Switch: '<S630>/Switch1' incorporates:
                 *  Constant: '<S613>/Constant'
                 *  Logic: '<S51>/Logical3'
                 */
                if (rtb_TmpSignalConversionAtVePD_i &&
                        rtb_TmpSignalConversionAtVePD_p)
                {
                    tmp_9 = CeTHMR_e_LTPP12_On;
                }
                else
                {
                    /* Logic: '<S51>/Logical4' incorporates:
                     *  Logic: '<S51>/Logical12'
                     *  RelationalOperator: '<S51>/Comparison21'
                     *  Switch: '<S620>/Switch1'
                     *  Switch: '<S621>/Switch1'
                     *  Switch: '<S622>/Switch1'
                     *  Switch: '<S631>/Switch1'
                     *  Switch: '<S632>/Switch1'
                     *  Switch: '<S633>/Switch1'
                     *  Switch: '<S634>/Switch1'
                     *  Switch: '<S635>/Switch1'
                     */
                    rtb_LogicalOperator_aa = (rtb_LogicalOperator_aa &&
                        (THMR_ac_B.Comparison2));

                    /* Switch: '<S631>/Switch1' incorporates:
                     *  Constant: '<S612>/Constant'
                     *  Logic: '<S51>/Logical4'
                     */
                    if (rtb_LogicalOperator_aa &&
                            rtb_TmpSignalConversionAtVePD_p)
                    {
                        tmp_9 = CeTHMR_e_LTAP_On;
                    }
                    else
                    {
                        /* Logic: '<S51>/Logical5' incorporates:
                         *  Logic: '<S51>/Logical13'
                         *  RelationalOperator: '<S51>/Comparison25'
                         *  Switch: '<S620>/Switch1'
                         *  Switch: '<S621>/Switch1'
                         *  Switch: '<S622>/Switch1'
                         *  Switch: '<S623>/Switch1'
                         *  Switch: '<S632>/Switch1'
                         *  Switch: '<S633>/Switch1'
                         *  Switch: '<S634>/Switch1'
                         *  Switch: '<S635>/Switch1'
                         */
                        rtb_AND_fe = (rtb_AND_fe && (THMR_ac_B.Comparison2));

                        /* Switch: '<S632>/Switch1' incorporates:
                         *  Constant: '<S615>/Constant'
                         *  Logic: '<S51>/Logical5'
                         */
                        if (rtb_AND_fe && rtb_TmpSignalConversionAtVePD_p)
                        {
                            tmp_9 = CeTHMR_e_LTPP1_LTAP_On;
                        }
                        else
                        {
                            /* Logic: '<S51>/Logical6' incorporates:
                             *  Logic: '<S51>/Logical14'
                             *  RelationalOperator: '<S51>/Comparison30'
                             *  Switch: '<S620>/Switch1'
                             *  Switch: '<S621>/Switch1'
                             *  Switch: '<S622>/Switch1'
                             *  Switch: '<S623>/Switch1'
                             *  Switch: '<S624>/Switch1'
                             *  Switch: '<S633>/Switch1'
                             *  Switch: '<S634>/Switch1'
                             *  Switch: '<S635>/Switch1'
                             */
                            rtb_AND_de = (rtb_AND_de && (THMR_ac_B.Comparison2));

                            /* Switch: '<S633>/Switch1' incorporates:
                             *  Constant: '<S607>/Constant'
                             *  Constant: '<S616>/Constant'
                             *  Logic: '<S51>/Logical10'
                             *  Logic: '<S51>/Logical11'
                             *  Logic: '<S51>/Logical12'
                             *  Logic: '<S51>/Logical13'
                             *  Logic: '<S51>/Logical14'
                             *  Logic: '<S51>/Logical16'
                             *  Logic: '<S51>/Logical6'
                             *  Logic: '<S51>/Logical7'
                             *  Logic: '<S51>/Logical9'
                             *  RelationalOperator: '<S51>/Comparison34'
                             *  RelationalOperator: '<S51>/Comparison37'
                             *  RelationalOperator: '<S51>/Comparison41'
                             *  RelationalOperator: '<S51>/Comparison45'
                             *  RelationalOperator: '<S51>/Comparison49'
                             *  RelationalOperator: '<S51>/Comparison53'
                             *  RelationalOperator: '<S51>/Comparison57'
                             *  RelationalOperator: '<S51>/Comparison61'
                             *  Switch: '<S620>/Switch1'
                             *  Switch: '<S621>/Switch1'
                             *  Switch: '<S622>/Switch1'
                             *  Switch: '<S623>/Switch1'
                             *  Switch: '<S624>/Switch1'
                             *  Switch: '<S625>/Switch1'
                             *  Switch: '<S626>/Switch1'
                             *  Switch: '<S634>/Switch1'
                             *  Switch: '<S635>/Switch1'
                             */
                            if (rtb_AND_de && rtb_TmpSignalConversionAtVePD_p)
                            {
                                tmp_9 = CeTHMR_e_LTPP2_LTAP_On;
                            }
                            else if ((rtb_OR1_k3 && (THMR_ac_B.Comparison2)) &&
                                     rtb_TmpSignalConversionAtVePD_p)
                            {
                                /* Switch: '<S634>/Switch1' incorporates:
                                 *  Constant: '<S617>/Constant'
                                 */
                                tmp_9 = CeTHMR_e_LTPP12_LTAP_On;
                            }
                            else if (rtb_UnitDelay3_ff && (THMR_ac_B.Comparison3))
                            {
                                /* Switch: '<S635>/Switch1' incorporates:
                                 *  Constant: '<S600>/Constant'
                                 *  Switch: '<S634>/Switch1'
                                 */
                                tmp_9 = CeTHMR_e_HTAP_On;
                            }
                            else if (rtb_TmpSignalConversionAtVeTR_k &&
                                     (THMR_ac_B.Comparison3))
                            {
                                /* Switch: '<S620>/Switch1' incorporates:
                                 *  Constant: '<S601>/Constant'
                                 *  Switch: '<S634>/Switch1'
                                 *  Switch: '<S635>/Switch1'
                                 */
                                tmp_9 = CeTHMR_e_LTPP1_HTAP_On;
                            }
                            else if (rtb_VariantMerge_For_Variant__j &&
                                     (THMR_ac_B.Comparison3))
                            {
                                /* Switch: '<S621>/Switch1' incorporates:
                                 *  Constant: '<S602>/Constant'
                                 *  Switch: '<S620>/Switch1'
                                 *  Switch: '<S634>/Switch1'
                                 *  Switch: '<S635>/Switch1'
                                 */
                                tmp_9 = CeTHMR_e_LTPP2_HTAP_On;
                            }
                            else if (rtb_TmpSignalConversionAtVePD_i &&
                                     (THMR_ac_B.Comparison3))
                            {
                                /* Switch: '<S622>/Switch1' incorporates:
                                 *  Constant: '<S603>/Constant'
                                 *  Switch: '<S620>/Switch1'
                                 *  Switch: '<S621>/Switch1'
                                 *  Switch: '<S634>/Switch1'
                                 *  Switch: '<S635>/Switch1'
                                 */
                                tmp_9 = CeTHMR_e_LTPP12_HTAP_On;
                            }
                            else if (rtb_LogicalOperator_aa &&
                                     (THMR_ac_B.Comparison3))
                            {
                                /* Switch: '<S623>/Switch1' incorporates:
                                 *  Constant: '<S604>/Constant'
                                 *  Switch: '<S620>/Switch1'
                                 *  Switch: '<S621>/Switch1'
                                 *  Switch: '<S622>/Switch1'
                                 *  Switch: '<S634>/Switch1'
                                 *  Switch: '<S635>/Switch1'
                                 */
                                tmp_9 = CeTHMR_e_LTAP_HTAP_On;
                            }
                            else if (rtb_AND_fe && (THMR_ac_B.Comparison3))
                            {
                                /* Switch: '<S624>/Switch1' incorporates:
                                 *  Constant: '<S605>/Constant'
                                 *  Switch: '<S620>/Switch1'
                                 *  Switch: '<S621>/Switch1'
                                 *  Switch: '<S622>/Switch1'
                                 *  Switch: '<S623>/Switch1'
                                 *  Switch: '<S634>/Switch1'
                                 *  Switch: '<S635>/Switch1'
                                 */
                                tmp_9 = CeTHMR_e_LTPP1_LTAP_HTAP_On;
                            }
                            else if (rtb_AND_de && (THMR_ac_B.Comparison3))
                            {
                                /* Switch: '<S625>/Switch1' incorporates:
                                 *  Constant: '<S606>/Constant'
                                 *  Switch: '<S620>/Switch1'
                                 *  Switch: '<S621>/Switch1'
                                 *  Switch: '<S622>/Switch1'
                                 *  Switch: '<S623>/Switch1'
                                 *  Switch: '<S624>/Switch1'
                                 *  Switch: '<S634>/Switch1'
                                 *  Switch: '<S635>/Switch1'
                                 */
                                tmp_9 = CeTHMR_e_LTPP2_LTAP_HTAP_On;
                            }
                            else
                            {
                                tmp_9 = CeTHMR_e_All_Pumps_On;
                            }
                        }
                    }
                }
            }
        }
    }

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_e_ClntPmpState' incorporates:
     *  SignalConversion generated from: '<S2>/ClntPmpState'
     */
    (void)Rte_Write_VeTHMR_e_ClntPmpState_Value(tmp_9);

    /* Outport: '<Root>/VeTHMR_y_ClntPump_Oprtng_State' incorporates:
     *  SignalConversion generated from: '<S2>/ClntPmp_OprtngSt'
     */
    (void)Rte_Write_VeTHMR_y_ClntPump_Oprtng_State_Value(rtb_Switch1_cw);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Pump_Command'
     */
    /* Outport: '<Root>/VeTHMR_y_ClntPump_Slctd_State' incorporates:
     *  Gain: '<S3730>/Gain'
     *  SignalConversion generated from: '<S2>/ClntPmp_SlctdSt'
     */
    (void)Rte_Write_VeTHMR_y_ClntPump_Slctd_State_Value
        (rtb_TmpSignalConversionAtVePRXR);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_e_ClntProp3WyVlv_State' incorporates:
     *  SignalConversion generated from: '<S2>/ClntProp3WyVlv_State'
     *  VariantMerge generated from: '<S5645>/VariantSource'
     */
    (void)Rte_Write_VeTHMR_e_ClntProp3WyVlv_State_Value
        (THMR_ac_B.VariantMerge_Fo_aa);

    /* Outport: '<Root>/VeTHMR_T_BattClntMinTgt' incorporates:
     *  SignalConversion generated from: '<S2>/CoolantTargetCellMinUsed'
     */
    (void)Rte_Write_VeTHMR_T_BattClntMinTgt_Value(THMR_ac_B.Vector_h);

    /* Outport: '<Root>/VeTHMR_b_DeiceActv' incorporates:
     *  SignalConversion generated from: '<S2>/DeIcingEnbl_HeatPump'
     */
    (void)Rte_Write_VeTHMR_b_DeiceActv_Value(THMR_ac_B.AND_j);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Miscellaneous_Outputs'
     */
    /* Switch: '<S3352>/Switch' incorporates:
     *  Constant: '<S3388>/Calib'
     *  Constant: '<S3389>/Calib'
     *  Switch: '<S4492>/Switch1'
     */
    if (KeTHMR_b_DisblFunc_Msg_10_SD)
    {
        rtb_AND_fe = KeTHMR_b_DisblFunc_Msg_10_D;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S2>/Subsystem__Subsystem1' */
        rtb_AND_fe = ((!rtb_VariantMerge_For_Variant__p) && tmpRead_17);

        /* End of Outputs for SubSystem: '<S2>/Subsystem__Subsystem1' */
    }

    /* End of Switch: '<S3352>/Switch' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_b_DisblFunc_Msg_10' incorporates:
     *  SignalConversion generated from: '<S2>/DisblFunc_Msg_10_AD'
     */
    (void)Rte_Write_VeTHMR_b_DisblFunc_Msg_10_Value(rtb_AND_fe);

    /* Outport: '<Root>/VeTHMR_b_DrvDrAjar' incorporates:
     *  SignalConversion generated from: '<S2>/DrvDrAjar_AD'
     */
    (void)Rte_Write_VeTHMR_b_DrvDrAjar_Value(VeTHMR_b_DrvDrAjar);

    /* Outport: '<Root>/VeTHMR_T_ECH_ClntTempTgt' incorporates:
     *  SignalConversion generated from: '<S2>/ECH_ClntTempTgt'
     */
    (void)Rte_Write_VeTHMR_T_ECH_ClntTempTgt_Value
        (THMR_ac_B.VariantMerge_Fo_adzsu0cfjyeit0k);

    /* Outport: '<Root>/VeTHMR_P_ECH_HtrPwrTgt' incorporates:
     *  SignalConversion generated from: '<S2>/ECH_HtrPwrTgt'
     */
    (void)Rte_Write_VeTHMR_P_ECH_HtrPwrTgt_Value(THMR_ac_B.VariantMerge_Fo_d);

    /* Outport: '<Root>/VeTHMR_P_EDU_Heat_Battery_Available' incorporates:
     *  SignalConversion generated from: '<S2>/EDU_Heat_Batt_Assist'
     */
    (void)Rte_Write_VeTHMR_P_EDU_Heat_Battery_Available_Value
        (rtb_TmpSignalConversionAtVeFSCR);

    /* Outport: '<Root>/VeTHMR_P_EDU_Heat_Cabin_Available' incorporates:
     *  SignalConversion generated from: '<S2>/EDU_Heat_Cabin_Assist'
     */
    (void)Rte_Write_VeTHMR_P_EDU_Heat_Cabin_Available_Value
        (rtb_TmpSignalConversionAtVeT_gg);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/EOP_Emergency_Cooling_State'
     */
    /* Switch: '<S716>/Switch1' incorporates:
     *  Constant: '<S2567>/Constant'
     *  Constant: '<S718>/Calib'
     *  Constant: '<S719>/Calib'
     *  Switch: '<S2570>/Switch1'
     */
    if (KeTHMR_b_EOP_A_EmrgCool_SD)
    {
        tmp_a = KeTHMR_e_EOP_A_EmrgCool_D;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S2>/LTCL' */
        if (rtb_TmpSignalConversionAtVeT_c0)
        {
            /* Switch: '<S2570>/Switch1' incorporates:
             *  Constant: '<S2566>/Constant'
             */
            tmp_a = CeTHMR_e_OilPumpEmrgCool_ON;
        }
        else
        {
            tmp_a = CeTHMR_e_OilPumpEmrgCool_OFF;
        }

        /* End of Outputs for SubSystem: '<S2>/LTCL' */
    }

    /* Outport: '<Root>/VeTHMR_e_EOP_A_EmrgCoolState' incorporates:
     *  SignalConversion generated from: '<S2>/EOP_A_EmrgCool_AftDial'
     *  Switch: '<S716>/Switch1'
     */
    (void)Rte_Write_VeTHMR_e_EOP_A_EmrgCoolState_Value(tmp_a);

    /* Switch: '<S717>/Switch1' incorporates:
     *  Constant: '<S2565>/Constant'
     *  Constant: '<S720>/Calib'
     *  Constant: '<S721>/Calib'
     *  Switch: '<S2569>/Switch1'
     */
    if (KeTHMR_b_EOP_B_EmrgCool_SD)
    {
        tmp_a = KeTHMR_e_EOP_B_EmrgCool_D;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S2>/LTCL' */
        if (rtb_Logical4_iq)
        {
            /* Switch: '<S2569>/Switch1' incorporates:
             *  Constant: '<S2564>/Constant'
             */
            tmp_a = CeTHMR_e_OilPumpEmrgCool_ON;
        }
        else
        {
            tmp_a = CeTHMR_e_OilPumpEmrgCool_OFF;
        }

        /* End of Outputs for SubSystem: '<S2>/LTCL' */
    }

    /* Outport: '<Root>/VeTHMR_e_EOP_B_EmrgCoolState' incorporates:
     *  SignalConversion generated from: '<S2>/EOP_B_EmrgCool_AftDial'
     *  Switch: '<S717>/Switch1'
     */
    (void)Rte_Write_VeTHMR_e_EOP_B_EmrgCoolState_Value(tmp_a);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Fan_Shutt_Command'
     */
    /* Switch: '<S1136>/Switch1' incorporates:
     *  Constant: '<S1146>/Calib'
     *  Constant: '<S1147>/Calib'
     */
    if (KeTHMR_b_EmrgcyFanRq_Lvl_SD)
    {
        rtb_VariantMerge_For__adzsu0cfj = KeTHMR_e_EmrgcyFanRq_Lvl_D;
    }

    /* Outport: '<Root>/VeTHMR_e_EmrgcyFanRq_Lvl' incorporates:
     *  SignalConversion generated from: '<S2>/EmrgcyFanRq_AD'
     *  Switch: '<S1136>/Switch1'
     */
    (void)Rte_Write_VeTHMR_e_EmrgcyFanRq_Lvl_Value
        (rtb_VariantMerge_For__adzsu0cfj);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_n_EngSpdInc_Req' incorporates:
     *  SignalConversion generated from: '<S2>/EngSpdInc_Req'
     */
    (void)Rte_Write_VeTHMR_n_EngSpdInc_Req_Value
        (THMR_ac_B.VariantMerge_For_Variant__adzsu);

    /* Outport: '<Root>/VeTHMR_e_Eng_Htr_HTSOV_Stat' incorporates:
     *  SignalConversion generated from: '<S2>/Eng_HTSOV_Htr_State_AD'
     *  VariantMerge generated from: '<S315>/VariantSource'
     */
    (void)Rte_Write_VeTHMR_e_Eng_Htr_HTSOV_Stat_Value
        (THMR_ac_B.VariantMerge_Fo_i);

    /* Outport: '<Root>/VeTHMR_P_EnginePwr_Available' incorporates:
     *  SignalConversion generated from: '<S2>/EnginePwr_Available'
     */
    (void)Rte_Write_VeTHMR_P_EnginePwr_Available_Value
        (rtb_TmpSignalConversionAtVeTA_b);

    /* SignalConversion generated from: '<S2>/FCCP_Pct_Cmd' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* Outport: '<Root>/VeTHMR_Pct_FCCP_Req' */
    (void)Rte_Write_VeTHMR_Pct_FCCP_Req_Value(THMR_ac_B.VeTHMR_Pct_FCCP_Cmd);

#endif

    /* End of SignalConversion generated from: '<S2>/FCCP_Pct_Cmd' */

    /* Outport: '<Root>/VeTHMR_b_FCHeatAllwd' incorporates:
     *  SignalConversion generated from: '<S2>/FCHeatAllowed'
     */
    (void)Rte_Write_VeTHMR_b_FCHeatAllwd_Value(THMR_ac_B.VeTHMR_b_FCHeatAllwd);

    /* SignalConversion generated from: '<S2>/FCPS_PowerLimMax' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* Outport: '<Root>/VeTHMR_P_FCPSThrmlPwr_MaxAllwd' */
    (void)Rte_Write_VeTHMR_P_FCPSThrmlPwr_MaxAllwd_Value(THMR_ac_B.MinMax);

#endif

    /* End of SignalConversion generated from: '<S2>/FCPS_PowerLimMax' */

    /* Outport: '<Root>/VeTHMR_b_FC_CondAllwd' incorporates:
     *  SignalConversion generated from: '<S2>/FC_CondAllwd'
     */
    (void)Rte_Write_VeTHMR_b_FC_CondAllwd_Value(rtb_TmpSignalConversionAtPropSy);

    /* SignalConversion generated from: '<S2>/FC_Flow_Tgt' incorporates:
     *  SignalConversion generated from: '<S2>/FC_Pct_Fan_Req'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* Outport: '<Root>/VeTHMR_dV_FCL_ClntFlowTgt' */
    (void)Rte_Write_VeTHMR_dV_FCL_ClntFlowTgt_Value(THMR_ac_B.Switch5_k);

    /* Outport: '<Root>/VeTHMR_Pct_FCHTRRadFanReq' */
    (void)Rte_Write_VeTHMR_Pct_FCHTRRadFanReq_Value
        (THMR_ac_B.VeTHMR_Pct_FCHTRRadFanCmd);

#endif

    /* End of SignalConversion generated from: '<S2>/FC_Flow_Tgt' */

    /* Outport: '<Root>/VeTHMR_e_FCThrmlState' incorporates:
     *  Merge: '<S4573>/Merge2'
     *  SignalConversion generated from: '<S2>/FC_ThrmlState'
     */
    (void)Rte_Write_VeTHMR_e_FCThrmlState_Value(THMR_ac_B.VeTHMR_e_FCThrmlState);

    /* SignalConversion generated from: '<S2>/FC_Valve_Pos_Req' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* Outport: '<Root>/VeTHMR_Pct_FC_Vlv_Cmd' */
    (void)Rte_Write_VeTHMR_Pct_FC_Vlv_Cmd_Value(THMR_ac_B.Switch7_c);

#endif

    /* End of SignalConversion generated from: '<S2>/FC_Valve_Pos_Req' */

    /* Outport: '<Root>/VeTHMR_Pct_HCP_AGS_Req' incorporates:
     *  SignalConversion generated from: '<S2>/HCP_AGS_Req_AD'
     */
    (void)Rte_Write_VeTHMR_Pct_HCP_AGS_Req_Value
        (THMR_ac_B.VeTHMR_Pct_HCP_AGS_Req);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Pump_Command'
     */
    /* Outport: '<Root>/VeTHMR_b_HTAuxPmp_ClntWarmUp' incorporates:
     *  Constant: '<S3658>/Calib'
     *  Gain: '<S3665>/Gain'
     *  SignalConversion generated from: '<S2>/HTAuxPmp_ClntWarmUp'
     */
    (void)Rte_Write_VeTHMR_b_HTAuxPmp_ClntWarmUp_Value
        (KeTHMR_b_HTAuxPmp_ClntWarmUp);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/New_THMR_Op'
     */
    /* Outport: '<Root>/VeTHMR_e_HTCL_Heat_Distrib' incorporates:
     *  DataTypeConversion: '<S1842>/DataTypeConversion'
     *  DataTypeConversion: '<S3609>/DataTypeConversion'
     *  SignalConversion generated from: '<S2>/HTCL_Heat_Distrib_Out'
     */
    (void)Rte_Write_VeTHMR_e_HTCL_Heat_Distrib_Value
        (THMR_ac_B.DataTypeConversion_i);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_Pct_HTL_BypsVlv_Cmd' incorporates:
     *  SignalConversion generated from: '<S2>/HTCL_Vlv_Pos_rqst'
     */
    (void)Rte_Write_VeTHMR_Pct_HTL_BypsVlv_Cmd_Value
        (THMR_ac_B.VeTHMR_Pct_HTL_BypsVlv_Cmd);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Valve_command'
     */
    /* Switch: '<S5646>/Switch' incorporates:
     *  Constant: '<S5663>/Calib'
     */
    if (KeTHMR_b_HTCV_LearnEnbl_SD)
    {
        /* Outport: '<Root>/VeTHMR_b_HTCV_LearnEnb' incorporates:
         *  Constant: '<S5662>/Calib'
         *  SignalConversion generated from: '<S2>/HTCV_LearnEnb_AD'
         */
        (void)Rte_Write_VeTHMR_b_HTCV_LearnEnb_Value(KeTHMR_b_HTCV_LearnEnbl_D);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_b_HTCV_LearnEnb' incorporates:
         *  SignalConversion generated from: '<S2>/HTCV_LearnEnb_AD'
         */
        (void)Rte_Write_VeTHMR_b_HTCV_LearnEnb_Value(Merge3);
    }

    /* End of Switch: '<S5646>/Switch' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* Outport: '<Root>/VeTHMR_b_HTCV_RAEnbl_BattTmpHi' incorporates:
     *  Logic: '<S1160>/LogicalOperator'
     *  SignalConversion generated from: '<S2>/HTCV_RA_Enbl_BattTmpHi_out'
     */
    (void)Rte_Write_VeTHMR_b_HTCV_RAEnbl_BattTmpHi_Value((THMR_ac_B.Logical2_o) &&
        (THMR_ac_B.Logical7_l));

    /* Switch: '<S57>/Switch' */
    if (rtb_VM_Conditional_Signal_Use_c)
    {
        /* Outport: '<Root>/VeTHMR_n_HTLPumpMBCReq' incorporates:
         *  SignalConversion generated from: '<S2>/HTLPumpMBCReq'
         */
        (void)Rte_Write_VeTHMR_n_HTLPumpMBCReq_Value
            (rtb_VM_Conditional_Signal_HTLPu);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_n_HTLPumpMBCReq' incorporates:
         *  SignalConversion generated from: '<S2>/HTLPumpMBCReq'
         */
        (void)Rte_Write_VeTHMR_n_HTLPumpMBCReq_Value(VeTHMR_n_HTLPump_MBCReq);
    }

    /* End of Switch: '<S57>/Switch' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_dV_HT_AuxPmpFlow' incorporates:
     *  SignalConversion generated from: '<S2>/HT_AuxPmpCmd'
     */
    (void)Rte_Write_VeTHMR_dV_HT_AuxPmpFlow_Value
        (THMR_ac_B.VariantMerge_For__adzsu0cfjyeit);

    /* Outport: '<Root>/VeTHMR_Pct_ClntProp3WyVlv_Cmd' incorporates:
     *  SignalConversion generated from: '<S2>/HT_CabVlvCmd'
     */
    (void)Rte_Write_VeTHMR_Pct_ClntProp3WyVlv_Cmd_Value
        (THMR_ac_B.VariantMerge_For_Varia_adzsu0cf);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Miscellaneous_Outputs'
     */
    /* Switch: '<S3359>/Switch1' incorporates:
     *  Constant: '<S3403>/Calib'
     */
    if (KeTHMR_b_HVAC_HeatReq_SelDial)
    {
        /* Outport: '<Root>/VeTHMR_b_HVAC_HeatReq' incorporates:
         *  Constant: '<S3402>/Calib'
         *  SignalConversion generated from: '<S2>/HVAC_HeatReq_AD'
         */
        (void)Rte_Write_VeTHMR_b_HVAC_HeatReq_Value(KeTHMR_b_HVAC_HeatReq_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_b_HVAC_HeatReq' incorporates:
         *  SignalConversion generated from: '<S2>/HVAC_HeatReq_AD'
         */
        (void)Rte_Write_VeTHMR_b_HVAC_HeatReq_Value
            (rtb_TmpSignalConversionAtVeCT_o);
    }

    /* End of Switch: '<S3359>/Switch1' */

    /* Switch: '<S3356>/Switch' incorporates:
     *  Constant: '<S3396>/Calib'
     *  Constant: '<S3397>/Calib'
     *  Switch: '<S4286>/Switch1'
     */
    if (KeTHMR_b_HVAC_RdPerfModeFlg_SD)
    {
        tmp_b = KeTHMR_e_HVAC_RdPerfModeFlg_D;
    }
    else
    {
        tmp_b = VeTHMR_e_HVACPerf_Mode;
    }

    /* Outport: '<Root>/VeTHMR_e_HVAC_PerfModeFlg' incorporates:
     *  SignalConversion generated from: '<S2>/HVAC_PerfModeFlg_AD'
     *  Switch: '<S3356>/Switch'
     */
    (void)Rte_Write_VeTHMR_e_HVAC_PerfModeFlg_Value(tmp_b);

    /* Switch: '<S3361>/Switch1' incorporates:
     *  Constant: '<S3407>/Calib'
     */
    if (KeTHMR_b_HVAC_turnedOff_SelDial)
    {
        /* Outport: '<Root>/VeTHMR_b_HVAC_turnedOff' incorporates:
         *  Constant: '<S3406>/Calib'
         *  SignalConversion generated from: '<S2>/HVAC_turnedOff_Messg_AD'
         */
        (void)Rte_Write_VeTHMR_b_HVAC_turnedOff_Value
            (KeTHMR_b_HVAC_turnedOff_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_b_HVAC_turnedOff' incorporates:
         *  SignalConversion generated from: '<S2>/HVAC_turnedOff_Messg_AD'
         */
        (void)Rte_Write_VeTHMR_b_HVAC_turnedOff_Value
            (VeTHMR_b_HVAC_turnedOff_B4D);
    }

    /* End of Switch: '<S3361>/Switch1' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/New_THMR_Op'
     */
    /* Outport: '<Root>/VeTHMR_b_HVBR_UsgEnb' incorporates:
     *  Gain: '<S3612>/Gain'
     *  SignalConversion generated from: '<S2>/HVBR_UsgEnb_Out'
     */
    (void)Rte_Write_VeTHMR_b_HVBR_UsgEnb_Value(rtb_TmpSignalConversionAtVeCT_d);

    /* Outport: '<Root>/VeTHMR_b_HV_BatRdyLocal_True' incorporates:
     *  Gain: '<S3613>/Gain'
     *  SignalConversion generated from: '<S2>/HV_BatRdyLocal_True_Out'
     */
    (void)Rte_Write_VeTHMR_b_HV_BatRdyLocal_True_Value
        (THMR_ac_B.VeTHMR_b_HV_BatRdyLocal_True_B4);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Miscellaneous_Outputs'
     */
    /* Switch: '<S3358>/Switch1' incorporates:
     *  Constant: '<S3401>/Calib'
     *  Constant: '<S4298>/Calib'
     *  Switch: '<S4254>/Switch1'
     */
    if (KeTHMR_b_HV_BatTempCrit_Cond_SelDial)
    {
        /* Outport: '<Root>/VeTHMR_b_HV_BatTempCrit_Cond' incorporates:
         *  Constant: '<S3400>/Calib'
         *  SignalConversion generated from: '<S2>/HV_BatTempCrit_Cond_AD'
         */
        (void)Rte_Write_VeTHMR_b_HV_BatTempCrit_Cond_Value
            (KeTHMR_b_HV_BatTempCrit_Cond_Dial);
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S2>/Subsystem__Subsystem1' */
        if (KeTHMR_b_SelBattCrit_HVACFlag)
        {
            /* Outport: '<Root>/VeTHMR_b_HV_BatTempCrit_Cond' incorporates:
             *  SignalConversion generated from: '<S2>/HV_BatTempCrit_Cond_AD'
             *  Switch: '<S4254>/Switch1'
             */
            (void)Rte_Write_VeTHMR_b_HV_BatTempCrit_Cond_Value
                (rtb_TmpSignalConversionAtVeB_cu);
        }
        else
        {
            /* Outport: '<Root>/VeTHMR_b_HV_BatTempCrit_Cond' incorporates:
             *  SignalConversion generated from: '<S2>/HV_BatTempCrit_Cond_AD'
             *  Switch: '<S4254>/Switch1'
             */
            (void)Rte_Write_VeTHMR_b_HV_BatTempCrit_Cond_Value
                (VeTHMR_b_CabRejFlag);
        }

        /* End of Outputs for SubSystem: '<S2>/Subsystem__Subsystem1' */
    }

    /* End of Switch: '<S3358>/Switch1' */

    /* Switch: '<S3351>/Switch15' incorporates:
     *  Constant: '<S3386>/Calib'
     *  Constant: '<S3387>/Calib'
     */
    if (KeTHMR_b_HV_Bat_CltLvlLo_SD)
    {
        rtb_TmpSignalConversionAtVeBRDR = KeTHMR_e_HV_Bat_CltLvlLo_Dial;
    }

    /* Outport: '<Root>/VeTHMR_e_HV_Bat_CltLvlLo' incorporates:
     *  SignalConversion generated from: '<S2>/HV_Bat_CltLvlLo_AD'
     *  Switch: '<S3351>/Switch15'
     */
    (void)Rte_Write_VeTHMR_e_HV_Bat_CltLvlLo_Value
        (rtb_TmpSignalConversionAtVeBRDR);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_T_Htr2ClntTempTgt' incorporates:
     *  SignalConversion generated from: '<S2>/Htr2ClntTempTgt'
     */
    (void)Rte_Write_VeTHMR_T_Htr2ClntTempTgt_Value(THMR_ac_B.VariantMerge_Fo_a);

    /* Outport: '<Root>/VeTHMR_P_Htr2PwrTgt' incorporates:
     *  SignalConversion generated from: '<S2>/Htr2PwrTgt'
     */
    (void)Rte_Write_VeTHMR_P_Htr2PwrTgt_Value(THMR_ac_B.VariantMerge_Fo_f);

    /* Outport: '<Root>/VeTHMR_T_Htr3ClntTempTgt' incorporates:
     *  SignalConversion generated from: '<S2>/Htr3ClntTempTgt'
     */
    (void)Rte_Write_VeTHMR_T_Htr3ClntTempTgt_Value(THMR_ac_B.VariantMerge_Fo_j);

    /* Outport: '<Root>/VeTHMR_P_Htr3PwrTgt' incorporates:
     *  SignalConversion generated from: '<S2>/Htr3PwrTgt'
     */
    (void)Rte_Write_VeTHMR_P_Htr3PwrTgt_Value(THMR_ac_B.VariantMerge_Fo_jk);

    /* Outport: '<Root>/VeTHMR_T_Htr4ClntTempTgt' incorporates:
     *  SignalConversion generated from: '<S2>/Htr4ClntTempTgt'
     */
    (void)Rte_Write_VeTHMR_T_Htr4ClntTempTgt_Value(THMR_ac_B.VariantMerge_Fo_o);

    /* Outport: '<Root>/VeTHMR_P_Htr4PwrTgt' incorporates:
     *  SignalConversion generated from: '<S2>/Htr4PwrTgt'
     */
    (void)Rte_Write_VeTHMR_P_Htr4PwrTgt_Value(THMR_ac_B.VariantMerge_Fo_b);

    /* Outport: '<Root>/VeTHMR_T_HtrCorClnt_TmpIn' incorporates:
     *  SignalConversion generated from: '<S2>/HtrCorClnt_TmpIn'
     */
    (void)Rte_Write_VeTHMR_T_HtrCorClnt_TmpIn_Value
        (THMR_ac_B.VariantMerge_For_Variant_adzsu0);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Miscellaneous_Outputs'
     */
    /* Switch: '<S3354>/Switch1' incorporates:
     *  Constant: '<S3393>/Calib'
     */
    if (KeTHMR_b_HtrCorClnt_Tmp_InFA_SelDial)
    {
        /* Outport: '<Root>/VeTHMR_b_HtrCorClnt_Tmp_InFA' incorporates:
         *  Constant: '<S3392>/Calib'
         *  SignalConversion generated from: '<S2>/HtrCorClnt_Tmp_InFA_AD'
         */
        (void)Rte_Write_VeTHMR_b_HtrCorClnt_Tmp_InFA_Value
            (KeTHMR_b_HtrCorClnt_Tmp_InFA_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_b_HtrCorClnt_Tmp_InFA' incorporates:
         *  SignalConversion generated from: '<S2>/HtrCorClnt_Tmp_InFA_AD'
         */
        (void)Rte_Write_VeTHMR_b_HtrCorClnt_Tmp_InFA_Value
            (VeTHMR_b_HtrCorClnt_Tmp_In_FA_AD);
    }

    /* End of Switch: '<S3354>/Switch1' */

    /* Switch: '<S3357>/Switch' incorporates:
     *  Constant: '<S3399>/Calib'
     */
    if (KeTHMR_b_KeyInOFF_Pstn_SD)
    {
        /* Outport: '<Root>/VeTHMR_b_KeyXstnOFF' incorporates:
         *  Constant: '<S3398>/Calib'
         *  SignalConversion generated from: '<S2>/KeyOffPstn_AD'
         */
        (void)Rte_Write_VeTHMR_b_KeyXstnOFF_Value(KeTHMR_b_KeyInOFF_Pstn_D);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_b_KeyXstnOFF' incorporates:
         *  SignalConversion generated from: '<S2>/KeyOffPstn_AD'
         */
        (void)Rte_Write_VeTHMR_b_KeyXstnOFF_Value(VeTHMR_b_KeyXstnOffThisCycle);
    }

    /* End of Switch: '<S3357>/Switch' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_b_LINPrpVlv_CalibReq' incorporates:
     *  SignalConversion generated from: '<S2>/LINVlvCalibr_Req_AD'
     */
    (void)Rte_Write_VeTHMR_b_LINPrpVlv_CalibReq_Value
        (THMR_ac_B.VariantMerge_Fo_e);

    /* Outport: '<Root>/VeTHMR_Pct_LINPrpVlv_Cmd' incorporates:
     *  SignalConversion generated from: '<S2>/LINVlvCmd_AD'
     */
    (void)Rte_Write_VeTHMR_Pct_LINPrpVlv_Cmd_Value
        (THMR_ac_B.VariantMerge_For_Vari_adzsu0cfj);

    /* Outport: '<Root>/VeTHMR_b_LINPrpVlv_SvReq' incorporates:
     *  SignalConversion generated from: '<S2>/LINVlvSv_Req_AD'
     */
    (void)Rte_Write_VeTHMR_b_LINPrpVlv_SvReq_Value(THMR_ac_B.VariantMerge_Fo_g);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Battery_Outputs'
     */
    /* Outport: '<Root>/VeTHMR_b_LTAP_ExpctdOff' incorporates:
     *  Gain: '<S193>/Gain'
     *  SignalConversion generated from: '<S2>/LTAP_ExpctdOff'
     */
    (void)Rte_Write_VeTHMR_b_LTAP_ExpctdOff_Value(VeTHMR_b_LTActPmp_ExpctdOff);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Pump_Command'
     */
    /* Outport: '<Root>/VeTHMR_b_LTActvPmp_ClntWarmUp' incorporates:
     *  Constant: '<S3659>/Calib'
     *  Gain: '<S3664>/Gain'
     *  SignalConversion generated from: '<S2>/LTActvPmp_ClntWarmUp'
     */
    (void)Rte_Write_VeTHMR_b_LTActvPmp_ClntWarmUp_Value
        (KeTHMR_b_LTActvPmp_ClntWarmUp);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_e_LTCLThrmlMode' incorporates:
     *  Merge: '<S4575>/Merge1'
     *  SignalConversion generated from: '<S2>/LTCLThermalMode'
     */
    (void)Rte_Write_VeTHMR_e_LTCLThrmlMode_Value
        (THMR_ac_B.VeTHMR_e_LTCLThrmlMode);

    /* Outport: '<Root>/VeTHMR_e_LTCLRadVlvState' incorporates:
     *  Merge: '<S4575>/Merge'
     *  SignalConversion generated from: '<S2>/LTCL_VlvThermalState'
     */
    (void)Rte_Write_VeTHMR_e_LTCLRadVlvState_Value
        (THMR_ac_B.VeTHMR_e_LTCLRadVlvState);

    /* Outport: '<Root>/VeTHMR_Pct_LTL_Vlv_Cmd' incorporates:
     *  SignalConversion generated from: '<S2>/LTCL_Vlv_Pos_Cmd'
     */
    (void)Rte_Write_VeTHMR_Pct_LTL_Vlv_Cmd_Value
        (THMR_ac_B.VeTHMR_Pct_LTL_Vlv_Cmd);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Switch: '<S62>/Switch2' */
    if (rtb_VM_Conditional_Signal_Use_M)
    {
        /* Outport: '<Root>/VeTHMR_n_LTLPECP1MBC' incorporates:
         *  SignalConversion generated from: '<S2>/LTL_PECP1_MBC'
         */
        (void)Rte_Write_VeTHMR_n_LTLPECP1MBC_Value
            (rtb_VM_Conditional_Signal_PECP1);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_n_LTLPECP1MBC' incorporates:
         *  SignalConversion generated from: '<S2>/LTL_PECP1_MBC'
         */
        (void)Rte_Write_VeTHMR_n_LTLPECP1MBC_Value(VeTHMR_n_LTLPECP1_MBC);
    }

    /* End of Switch: '<S62>/Switch2' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Pump_Command'
     */
    /* Outport: '<Root>/VeTHMR_b_LTPsvPmp2_ClntWarmUp' incorporates:
     *  Constant: '<S3660>/Calib'
     *  Gain: '<S3662>/Gain'
     *  SignalConversion generated from: '<S2>/LTPsvPmp2_ClntWarmUp'
     */
    (void)Rte_Write_VeTHMR_b_LTPsvPmp2_ClntWarmUp_Value
        (KeTHMR_b_LTPsvPmp2_ClntWarmUp);

    /* Outport: '<Root>/VeTHMR_b_LTPsvPmp_ClntWarmUp' incorporates:
     *  Constant: '<S3661>/Calib'
     *  Gain: '<S3663>/Gain'
     *  SignalConversion generated from: '<S2>/LTPsvPmp_ClntWarmUp'
     */
    (void)Rte_Write_VeTHMR_b_LTPsvPmp_ClntWarmUp_Value
        (KeTHMR_b_LTPsvPmp_ClntWarmUp);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_dV_LTR_Flw_Tgt' incorporates:
     *  SignalConversion generated from: '<S2>/LTR_Flw'
     */
    (void)Rte_Write_VeTHMR_dV_LTR_Flw_Tgt_Value
        (THMR_ac_B.VariantMerge_For_adzsu0cfjyeit0);

    /* Outport: '<Root>/VeTHMR_dV_LT_ActvPmpFlow' incorporates:
     *  SignalConversion generated from: '<S2>/LT_ActvPmpCmd'
     */
    (void)Rte_Write_VeTHMR_dV_LT_ActvPmpFlow_Value
        (THMR_ac_B.VariantMerge_For_Var_adzsu0cfjy);

    /* Outport: '<Root>/VeTHMR_dV_LT_PsvPmp2Flow' incorporates:
     *  SignalConversion generated from: '<S2>/LT_PsvPmp2Flow'
     */
    (void)Rte_Write_VeTHMR_dV_LT_PsvPmp2Flow_Value
        (THMR_ac_B.VariantMerge_For_V_adzsu0cfjyei);

    /* Outport: '<Root>/VeTHMR_dV_LT_PsvPmpFlow' incorporates:
     *  SignalConversion generated from: '<S2>/LT_PsvPmpFlow'
     */
    (void)Rte_Write_VeTHMR_dV_LT_PsvPmpFlow_Value
        (THMR_ac_B.VariantMerge_For_Va_adzsu0cfjye);

    /* Outport: '<Root>/VeTHMR_b_LatcdImpct' incorporates:
     *  SignalConversion generated from: '<S2>/Latcd_Impct'
     */
    (void)Rte_Write_VeTHMR_b_LatcdImpct_Value(THMR_ac_B.OR1);

    /* Outport: '<Root>/VeTHMR_b_LeaveKeyIn_RUN' incorporates:
     *  SignalConversion generated from: '<S2>/Leave_KeyIn_RUN_AD'
     */
    (void)Rte_Write_VeTHMR_b_LeaveKeyIn_RUN_Value(VeTHMR_b_LeaveKeyIn_RUN);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Miscellaneous_Outputs'
     */
    /* Switch: '<S3367>/Switch2' incorporates:
     *  Constant: '<S3369>/Calib'
     */
    if (KeTHMR_b_HCP_LTP_FanAftRun_Rq_SD)
    {
        /* Outport: '<Root>/VeTHMR_b_HCP_LTP_FanAftRun_Rq' incorporates:
         *  Constant: '<S3368>/Calib'
         *  SignalConversion generated from: '<S2>/Miscellaneous_Outputs__VeTHMR_b_HCP_LTP_FanAftRun_Rq'
         */
        (void)Rte_Write_VeTHMR_b_HCP_LTP_FanAftRun_Rq_Value
            (KeTHMR_b_HCP_LTP_FanAftRun_Rq_D);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_b_HCP_LTP_FanAftRun_Rq' incorporates:
         *  SignalConversion generated from: '<S2>/Miscellaneous_Outputs__VeTHMR_b_HCP_LTP_FanAftRun_Rq'
         */
        (void)Rte_Write_VeTHMR_b_HCP_LTP_FanAftRun_Rq_Value
            (VeTHMR_b_HCP_LTP_FanAftRun_Rq_BD_SF);
    }

    /* End of Switch: '<S3367>/Switch2' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_i_ModeIndex' incorporates:
     *  SignalConversion generated from: '<S2>/Mode_Index'
     */
    (void)Rte_Write_VeTHMR_i_ModeIndex_Value(THMR_ac_B.Switch1_m);

    /* Outport: '<Root>/VeTHMR_dV_MtrA_CoolFlwCmd' incorporates:
     *  SignalConversion generated from: '<S2>/MtrA_CoolFlwCmd_AftDial'
     */
    (void)Rte_Write_VeTHMR_dV_MtrA_CoolFlwCmd_Value
        (THMR_ac_B.VariantMerge_For_Variant_Sour_a);

    /* Outport: '<Root>/VeTHMR_dV_MtrB_CoolFlwCmd' incorporates:
     *  SignalConversion generated from: '<S2>/MtrB_CoolFlwCmd_AftDial'
     */
    (void)Rte_Write_VeTHMR_dV_MtrB_CoolFlwCmd_Value
        (THMR_ac_B.VariantMerge_For_Variant_Sou_ad);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Battery_Outputs'
     */
    /* Outport: '<Root>/VeTHMR_e_EngOrBattPwrDschg_State' incorporates:
     *  DataTypeConversion: '<S191>/DataTypeConversion'
     *  SignalConversion generated from: '<S2>/OV_BattDischg_State'
     *  SignalConversion generated from: '<S2>/VePDTR_e_EngOrBattPwrDschg_State'
     */
    (void)Rte_Write_VeTHMR_e_EngOrBattPwrDschg_State_Value
        (rtb_TmpSignalConversionAtVePD_l);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_T_PPCTIS_Arb' incorporates:
     *  SignalConversion generated from: '<S2>/PPCTIS_Arb'
     */
    (void)Rte_Write_VeTHMR_T_PPCTIS_Arb_Value(THMR_ac_B.Switch1_j);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/New_THMR_Op'
     */
    /* Outport: '<Root>/VeTHMR_b_RS_N_Or_NrmlPerWp' incorporates:
     *  Gain: '<S3611>/Gain'
     *  SignalConversion generated from: '<S2>/PerWupStatus_Out'
     */
    (void)Rte_Write_VeTHMR_b_RS_N_Or_NrmlPerWp_Value
        (THMR_ac_B.VeTHMR_b_RS_N_Or_NrmlPerWp_0);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* Outport: '<Root>/VeTHMR_P_PerWup_EngHeatNeed' incorporates:
     *  Gain: '<S1954>/Gain'
     *  SignalConversion generated from: '<S2>/PerWup_EngHeatNeed'
     */
    (void)Rte_Write_VeTHMR_P_PerWup_EngHeatNeed_Value(VeTHMR_P_EngHeatngPwr);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_b_PerWup_EngtoCond' incorporates:
     *  SignalConversion generated from: '<S2>/PerWup_EngtoCond'
     */
    (void)Rte_Write_VeTHMR_b_PerWup_EngtoCond_Value(THMR_ac_B.VariantMerge_Fo_jp);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Calibrations'
     */
    /* Switch: '<S45>/Switch1' incorporates:
     *  Constant: '<S264>/Constant'
     *  Constant: '<S271>/Calib'
     *  Constant: '<S272>/Calib'
     *  Logic: '<S45>/Logical2'
     *  RelationalOperator: '<S45>/Comparison1'
     */
    if (KeTHMR_b_PeriodicWup_SD)
    {
        rtb_AND_fe = KeTHMR_b_PeriodicWup_Dial;
    }
    else
    {
        rtb_AND_fe = (((uint32)rtb_TmpSignalConversionAtVeTP_k) !=
                      CeTPCR_e_NoneOfEngBatt_Cond);
    }

    /* End of Switch: '<S45>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_b_PerWup' incorporates:
     *  SignalConversion generated from: '<S2>/Period_Wup_2'
     */
    (void)Rte_Write_VeTHMR_b_PerWup_Value(rtb_AND_fe);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Pump_Command'
     */
    /* Outport: '<Root>/VeTHMR_y_PumpEnbl' incorporates:
     *  DataStoreRead: '<S72>/DataStoreRead'
     *  SignalConversion generated from: '<S2>/PumpEnbl'
     */
    (void)Rte_Write_VeTHMR_y_PumpEnbl_Value(VeTHMR_y_PumpEnbl_DS);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Battery_Outputs'
     */
    /* Switch: '<S194>/Switch1' incorporates:
     *  Constant: '<S202>/Calib'
     */
    if (KeTHMR_P_PwrBdgt_PwrLimitAvail_SD)
    {
        /* Outport: '<Root>/VeTHMR_P_PwrBdgt_PwrLimitAvail' incorporates:
         *  Constant: '<S201>/Calib'
         *  SignalConversion generated from: '<S2>/PwrBdgt_PwrLimitAvail'
         */
        (void)Rte_Write_VeTHMR_P_PwrBdgt_PwrLimitAvail_Value
            (KeTHMR_P_PwrBdgt_PwrLimitAvail_D);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_P_PwrBdgt_PwrLimitAvail' incorporates:
         *  SignalConversion generated from: '<S2>/PwrBdgt_PwrLimitAvail'
         */
        (void)Rte_Write_VeTHMR_P_PwrBdgt_PwrLimitAvail_Value
            (VeTHMR_P_PwrBdgt_PwrLimitAvail_BD);
    }

    /* End of Switch: '<S194>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_e_RadFan_State' incorporates:
     *  SignalConversion generated from: '<S2>/RadFan_State_AD'
     *  VariantMerge generated from: '<S1135>/VariantSource'
     */
    (void)Rte_Write_VeTHMR_e_RadFan_State_Value(THMR_ac_B.VariantMerge_Fo_kp);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Battery_Outputs'
     */
    /* Switch: '<S195>/Switch1' incorporates:
     *  Constant: '<S204>/Calib'
     */
    if (KeTHMR_b_RatEAC_PwrBdgt_Avail_SD)
    {
        /* Outport: '<Root>/VeTHMR_P_Rat_EAC_PwrBdgt_Avail' incorporates:
         *  Constant: '<S203>/Calib'
         *  SignalConversion generated from: '<S2>/RatEAC_PwrBdgt_Avail'
         */
        (void)Rte_Write_VeTHMR_P_Rat_EAC_PwrBdgt_Avail_Value
            (KeTHMR_P_RatEAC_PwrBdgt_Avail_D);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_P_Rat_EAC_PwrBdgt_Avail' incorporates:
         *  SignalConversion generated from: '<S2>/RatEAC_PwrBdgt_Avail'
         */
        (void)Rte_Write_VeTHMR_P_Rat_EAC_PwrBdgt_Avail_Value(tmpRead_1l);
    }

    /* End of Switch: '<S195>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_b_RdyForShtDwn' incorporates:
     *  SignalConversion generated from: '<S2>/RdyForShtDwn_AftDial'
     */
    (void)Rte_Write_VeTHMR_b_RdyForShtDwn_Value(THMR_ac_B.VariantMerge_Fo_am);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* Outport: '<Root>/VeTHMR_e_RefShtoffVlv_State' incorporates:
     *  DataTypeConversion: '<S4041>/DataTypeConversion'
     *  SignalConversion generated from: '<S2>/RefShtoffVlv_State'
     */
    (void)Rte_Write_VeTHMR_e_RefShtoffVlv_State_Value(THMR_ac_B.VeTHMR_e_RSV);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_b_RmtStrtAbort_StrtVhclRq' incorporates:
     *  SignalConversion generated from: '<S2>/RmtStrtAbort_StrtVhclRq'
     */
    (void)Rte_Write_VeTHMR_b_RmtStrtAbort_StrtVhclRq_Value
        (THMR_ac_B.VariantMerge_Fo_l);

    /* Outport: '<Root>/VeTHMR_b_StartVhcl_ToMaintain12Vlt' incorporates:
     *  SignalConversion generated from: '<S2>/StartVhcl_messg_AD'
     */
    (void)Rte_Write_VeTHMR_b_StartVhcl_ToMaintain12Vlt_Value
        (THMR_ac_B.OutportBufferForStartVhcl_messg);

    /* Outport: '<Root>/VeTHMR_e_VehThermSt' incorporates:
     *  DataTypeConversion: '<S450>/DataTypeConversion'
     *  SignalConversion generated from: '<S2>/TempAllowMode'
     */
    (void)Rte_Write_VeTHMR_e_VehThermSt_Value(rtb_Switch1_d1t);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Miscellaneous_Outputs'
     */
    /* Switch: '<S3360>/Switch1' incorporates:
     *  Constant: '<S3405>/Calib'
     */
    if (KeTHMR_b_ThermSystEng_Req_SelDial)
    {
        /* Outport: '<Root>/VeTHMR_b_ThermSystEng_Req' incorporates:
         *  Constant: '<S3404>/Calib'
         *  SignalConversion generated from: '<S2>/ThermSystEng_Req_AD'
         */
        (void)Rte_Write_VeTHMR_b_ThermSystEng_Req_Value
            (KeTHMR_b_ThermSystEng_Req_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_b_ThermSystEng_Req' incorporates:
         *  SignalConversion generated from: '<S2>/ThermSystEng_Req_AD'
         */
        (void)Rte_Write_VeTHMR_b_ThermSystEng_Req_Value
            (rtb_TmpSignalConversionAtVeT_ej);
    }

    /* End of Switch: '<S3360>/Switch1' */

    /* Switch: '<S3355>/Switch' incorporates:
     *  Constant: '<S3395>/Calib'
     */
    if (KeTHMR_b_Hybrid_Altrntr_ModeRq_SD)
    {
        /* Outport: '<Root>/VeTHMR_b_ThermalHybAltMode_Rq' incorporates:
         *  Constant: '<S3394>/Calib'
         *  SignalConversion generated from: '<S2>/ThermalHybAltModeRq_AD'
         */
        (void)Rte_Write_VeTHMR_b_ThermalHybAltMode_Rq_Value
            (KeTHMR_b_Hybrid_Altrntr_ModeRq_D);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_b_ThermalHybAltMode_Rq' incorporates:
         *  SignalConversion generated from: '<S2>/ThermalHybAltModeRq_AD'
         */
        (void)Rte_Write_VeTHMR_b_ThermalHybAltMode_Rq_Value
            (rtb_TmpSignalConversionAtVeBT_e);
    }

    /* End of Switch: '<S3355>/Switch' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_e_ThrmSysShtDwnFlt' incorporates:
     *  SignalConversion generated from: '<S2>/ThrmSysShtDwnFlt'
     *  VariantMerge generated from: '<S3348>/VariantSource'
     */
    (void)Rte_Write_VeTHMR_e_ThrmSysShtDwnFlt_Value(THMR_ac_B.VariantMerge_Fo_fr);

    /* Outport: '<Root>/VeTHMR_I_ChargeCurrentLim' incorporates:
     *  SignalConversion generated from: '<S2>/VeTHMR_I_ChargeCurrentLim'
     */
    (void)Rte_Write_VeTHMR_I_ChargeCurrentLim_Value
        (THMR_ac_B.VariantMerge_For_Variant_Source);

    /* Outport: '<Root>/VeTHMR_P_WCondCabHeat_Avail' incorporates:
     *  SignalConversion generated from: '<S2>/VeTHMR_P_WCondCabHeat_Avail'
     */
    (void)Rte_Write_VeTHMR_P_WCondCabHeat_Avail_Value(rtb_Merge2_l);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/ThermalAirflow_Arb'
     */
    /* Outport: '<Root>/VeTHMR_Pct_BTRSolitaryAGS_PosReq' incorporates:
     *  MinMax: '<S5389>/MinMax10'
     *  SignalConversion generated from: '<S2>/VeTHMR_Pct_BTRSolitaryAGS_PosReq'
     */
    (void)Rte_Write_VeTHMR_Pct_BTRSolitaryAGS_PosReq_Value(rtb_Switch1_ofq);

    /* Outport: '<Root>/VeTHMR_Pct_BTR_AirFlowReq' incorporates:
     *  Gain: '<S5395>/Gain'
     *  SignalConversion generated from: '<S2>/VeTHMR_Pct_BTR_AirFlowReq'
     */
    (void)Rte_Write_VeTHMR_Pct_BTR_AirFlowReq_Value(rtb_Vector_h00);

    /* Outport: '<Root>/VeTHMR_Pct_HTRSolitaryAGS_PosReq' incorporates:
     *  MinMax: '<S5389>/MinMax8'
     *  SignalConversion generated from: '<S2>/VeTHMR_Pct_HTRSolitaryAGS_PosReq'
     */
    (void)Rte_Write_VeTHMR_Pct_HTRSolitaryAGS_PosReq_Value(rtb_MinMax3_h);

    /* Outport: '<Root>/VeTHMR_Pct_HTR_AirFlowReq' incorporates:
     *  Gain: '<S5394>/Gain'
     *  SignalConversion generated from: '<S2>/VeTHMR_Pct_HTR_AirFlowReq'
     */
    (void)Rte_Write_VeTHMR_Pct_HTR_AirFlowReq_Value(rtb_Switch3_cr);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_Pct_HtrCoreBypssVlv' incorporates:
     *  SignalConversion generated from: '<S2>/VeTHMR_Pct_HtrCoreBypssVlv'
     */
    (void)Rte_Write_VeTHMR_Pct_HtrCoreBypssVlv_Value(THMR_ac_B.Merge1_h);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/ThermalAirflow_Arb'
     */
    /* Outport: '<Root>/VeTHMR_Pct_LTRSolitaryAGS_PosReq' incorporates:
     *  MinMax: '<S5389>/MinMax7'
     *  SignalConversion generated from: '<S2>/VeTHMR_Pct_LTRSolitaryAGS_PosReq'
     */
    (void)Rte_Write_VeTHMR_Pct_LTRSolitaryAGS_PosReq_Value(rtb_MinMax8);

    /* Outport: '<Root>/VeTHMR_Pct_LTR_AirFlowReq' incorporates:
     *  Gain: '<S5393>/Gain'
     *  SignalConversion generated from: '<S2>/VeTHMR_Pct_LTR_AirFlowReq'
     */
    (void)Rte_Write_VeTHMR_Pct_LTR_AirFlowReq_Value(rtb_Switch2_pg);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Battery_Outputs'
     */
    /* Switch: '<S200>/Switch1' incorporates:
     *  Constant: '<S220>/Calib'
     */
    if (KeTHMR_b_LTCLTgt_BattActvPsvHeating_SD)
    {
        /* Outport: '<Root>/VeTHMR_T_LTCLTgt_BattActvPsvHeating' incorporates:
         *  Constant: '<S219>/Calib'
         *  SignalConversion generated from: '<S2>/VeTHMR_T_LTCLTgt_BattActvPsvHeating'
         */
        (void)Rte_Write_VeTHMR_T_LTCLTgt_BattActvPsvHeating_Value
            (KeTHMR_T_LTCLTgt_BattActvPsvHeating_D);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_T_LTCLTgt_BattActvPsvHeating' incorporates:
         *  SignalConversion generated from: '<S2>/VeTHMR_T_LTCLTgt_BattActvPsvHeating'
         */
        (void)Rte_Write_VeTHMR_T_LTCLTgt_BattActvPsvHeating_Value
            (VeTHMR_T_LTCLTgt_BattActvPsvHeating_B4D);
    }

    /* End of Switch: '<S200>/Switch1' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Miscellaneous_Outputs'
     */
    /* Switch: '<S3347>/Switch3' incorporates:
     *  Constant: '<S3363>/Calib'
     */
    if (KeTHMR_b_AftrRunFanRqst_SD)
    {
        /* Outport: '<Root>/VeTHMR_b_AftrRunFanRqst' incorporates:
         *  Constant: '<S3362>/Calib'
         *  SignalConversion generated from: '<S2>/VeTHMR_b_AftrRunFanRqst'
         */
        (void)Rte_Write_VeTHMR_b_AftrRunFanRqst_Value
            (KeTHMR_b_AftrRunFanRqst_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_b_AftrRunFanRqst' incorporates:
         *  SignalConversion generated from: '<S2>/VeTHMR_b_AftrRunFanRqst'
         */
        (void)Rte_Write_VeTHMR_b_AftrRunFanRqst_Value(VeTHMR_b_AftrRunFanRq_SF);
    }

    /* End of Switch: '<S3347>/Switch3' */

    /* Outport: '<Root>/VeTHMR_b_BattOVFailure' incorporates:
     *  Logic: '<S3343>/AND'
     *  SignalConversion generated from: '<S2>/VeTHMR_b_BattOVFailure'
     */
    (void)Rte_Write_VeTHMR_b_BattOVFailure_Value(rtb_TmpSignalConversionAtVePDTR);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Cals'
     */
    /* Switch: '<S311>/Switch1' incorporates:
     *  Constant: '<S324>/Calib'
     */
    if (KeTHMR_b_CabPrecDny_BattCond_SD)
    {
        /* Outport: '<Root>/VeTHMR_b_CabPrecDny_BattCond' incorporates:
         *  Constant: '<S323>/Calib'
         *  SignalConversion generated from: '<S2>/VeTHMR_b_CabPrecDny_BattCond'
         */
        (void)Rte_Write_VeTHMR_b_CabPrecDny_BattCond_Value
            (KeTHMR_b_CabPrecDny_BattCond_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_b_CabPrecDny_BattCond' incorporates:
         *  SignalConversion generated from: '<S2>/VeTHMR_b_CabPrecDny_BattCond'
         */
        (void)Rte_Write_VeTHMR_b_CabPrecDny_BattCond_Value(tmpRead_1e);
    }

    /* End of Switch: '<S311>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* SignalConversion generated from: '<S2>/VeTHMR_b_HvHrnMtrAPowerLimit' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

    /* Outport: '<Root>/VeTHMR_b_HvHrnMtrAPowerLimit' */
    (void)Rte_Write_VeTHMR_b_HvHrnMtrAPowerLimit_Value
        (THMR_ac_B.VeTHMR_b_HvHrnMtrAPowerLimit);

#endif

    /* End of SignalConversion generated from: '<S2>/VeTHMR_b_HvHrnMtrAPowerLimit' */

    /* SignalConversion generated from: '<S2>/VeTHMR_b_HvHrnMtrBPowerLimit' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

    /* Outport: '<Root>/VeTHMR_b_HvHrnMtrBPowerLimit' */
    (void)Rte_Write_VeTHMR_b_HvHrnMtrBPowerLimit_Value
        (THMR_ac_B.VeTHMR_b_HvHrnMtrBPowerLimit);

#endif

    /* End of SignalConversion generated from: '<S2>/VeTHMR_b_HvHrnMtrBPowerLimit' */

    /* SignalConversion generated from: '<S2>/VeTHMR_b_HvHrnMtrCPowerLimit' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    /* Outport: '<Root>/VeTHMR_b_HvHrnMtrCPowerLimit' */
    (void)Rte_Write_VeTHMR_b_HvHrnMtrCPowerLimit_Value
        (THMR_ac_B.VeTHMR_b_HvHrnMtrCPowerLimit);

#endif

    /* End of SignalConversion generated from: '<S2>/VeTHMR_b_HvHrnMtrCPowerLimit' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Cals'
     */
    /* Switch: '<S317>/Switch2' incorporates:
     *  Constant: '<S343>/Constant'
     *  Constant: '<S344>/Calib'
     *  Constant: '<S345>/Calib'
     *  RelationalOperator: '<S317>/Comparison15'
     *  SignalConversion generated from: '<S2>/VeTPCR_e_SC_WakeUp'
     */
    if (KeTHMR_b_SC_WkUpFlg_SD)
    {
        rtb_AND_fe = KeTHMR_b_SC_WkUpFlg_Dial;
    }
    else
    {
        rtb_AND_fe = (((uint32)rtb_TmpSignalConversionAtVeTP_a) ==
                      CeTPCR_e_SC_WakeUp);
    }

    /* End of Switch: '<S317>/Switch2' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_b_SC_WkUpFlg' incorporates:
     *  SignalConversion generated from: '<S2>/VeTHMR_b_SC_WkUpFlg'
     */
    (void)Rte_Write_VeTHMR_b_SC_WkUpFlg_Value(rtb_AND_fe);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Miscellaneous_Outputs'
     */
    /* Switch: '<S3347>/Switch2' incorporates:
     *  Constant: '<S3364>/Calib'
     *  Constant: '<S3366>/Calib'
     */
    if (KeTHMR_b_HCP_LTP_FanAftRunRq_SD)
    {
        rtb_RelationalOperator_kg_tmp = KeTHMR_e_HCP_LTP_FanAftRunRq_D;
    }

    /* Outport: '<Root>/VeTHMR_e_HCP_LTP_FanAftRun_Rq' incorporates:
     *  SignalConversion generated from: '<S2>/VeTHMR_e_HCP_LTP_FanAftRunRq'
     *  Switch: '<S3347>/Switch2'
     */
    (void)Rte_Write_VeTHMR_e_HCP_LTP_FanAftRun_Rq_Value
        (rtb_RelationalOperator_kg_tmp);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Cals'
     */
    /* Switch: '<S317>/Switch1' incorporates:
     *  Constant: '<S346>/Calib'
     *  Constant: '<S347>/Calib'
     */
    if (KeTHMR_b_SC_WkUp_SD)
    {
        rtb_TmpSignalConversionAtVeTP_a = KeTHMR_e_SC_WkUp_Dial;
    }

    /* Outport: '<Root>/VeTHMR_e_SC_WkUp' incorporates:
     *  SignalConversion generated from: '<S2>/VeTHMR_e_SC_WkUp'
     *  Switch: '<S317>/Switch1'
     */
    (void)Rte_Write_VeTHMR_e_SC_WkUp_Value(rtb_TmpSignalConversionAtVeTP_a);

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Battery_Outputs'
     */
    /* Switch: '<S199>/Switch1' incorporates:
     *  Constant: '<S217>/Calib'
     */
    if (KeTHMR_b_BattCabPriority_SD)
    {
        /* Outport: '<Root>/VeTHMR_r_BattCabPriority_Ratio' incorporates:
         *  Constant: '<S218>/Calib'
         *  SignalConversion generated from: '<S2>/VeTHMR_r_BattCabPriority_Ratio'
         */
        (void)Rte_Write_VeTHMR_r_BattCabPriority_Ratio_Value
            (KeTHMR_r_BattCabPriority_D);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_r_BattCabPriority_Ratio' incorporates:
         *  SignalConversion generated from: '<S2>/VeTHMR_r_BattCabPriority_Ratio'
         */
        (void)Rte_Write_VeTHMR_r_BattCabPriority_Ratio_Value
            (VeTHMR_r_BattCabPriorityRatio_Fin);
    }

    /* End of Switch: '<S199>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* SignalConversion generated from: '<S2>/VeTHMR_r_HvHrnMtrAPowerLimit' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

    /* Outport: '<Root>/VeTHMR_r_HvHrnMtrAPowerLimit' */
    (void)Rte_Write_VeTHMR_r_HvHrnMtrAPowerLimit_Value(THMR_ac_B.Switch1_f);

#endif

    /* End of SignalConversion generated from: '<S2>/VeTHMR_r_HvHrnMtrAPowerLimit' */

    /* SignalConversion generated from: '<S2>/VeTHMR_r_HvHrnMtrBPowerLimit' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

    /* Outport: '<Root>/VeTHMR_r_HvHrnMtrBPowerLimit' */
    (void)Rte_Write_VeTHMR_r_HvHrnMtrBPowerLimit_Value(THMR_ac_B.Switch1_a);

#endif

    /* End of SignalConversion generated from: '<S2>/VeTHMR_r_HvHrnMtrBPowerLimit' */

    /* SignalConversion generated from: '<S2>/VeTHMR_r_HvHrnMtrCPowerLimit' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    /* Outport: '<Root>/VeTHMR_r_HvHrnMtrCPowerLimit' */
    (void)Rte_Write_VeTHMR_r_HvHrnMtrCPowerLimit_Value(THMR_ac_B.Switch1);

#endif

    /* End of SignalConversion generated from: '<S2>/VeTHMR_r_HvHrnMtrCPowerLimit' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Cals'
     */
    /* Switch: '<S310>/Switch1' incorporates:
     *  Constant: '<S321>/Calib'
     */
    if (KeTHMR_b_SC_PrecTimer_SD)
    {
        /* Outport: '<Root>/VeTHMR_t_SC_PrecTimer' incorporates:
         *  Constant: '<S322>/Calib'
         *  SignalConversion generated from: '<S2>/VeTHMR_t_SC_PrecTimer'
         */
        (void)Rte_Write_VeTHMR_t_SC_PrecTimer_Value(KeTHMR_t_SC_PrecTimer_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTHMR_t_SC_PrecTimer' incorporates:
         *  SignalConversion generated from: '<S2>/VeTHMR_t_SC_PrecTimer'
         */
        (void)Rte_Write_VeTHMR_t_SC_PrecTimer_Value(tmpRead_1a);
    }

    /* End of Switch: '<S310>/Switch1' */

    /* S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Miscellaneous_Outputs'
     */
    /* Outport: '<Root>/VeTHMR_b_VhclStatus' incorporates:
     *  Constant: '<S3344>/Calib'
     *  Gain: '<S3346>/Gain'
     *  SignalConversion generated from: '<S2>/VhclStatus'
     */
    (void)Rte_Write_VeTHMR_b_VhclStatus_Value(KeTHMR_b_VhclStatus);

    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_b_isCharging' incorporates:
     *  SignalConversion generated from: '<S2>/isCharging'
     */
    (void)Rte_Write_VeTHMR_b_isCharging_Value(THMR_ac_B.VariantMerge_Fo_pw);

    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */
}

/* Output function */
FUNC(void, THMR_CODE) THMR_PwrOff(void)
{
    /* RootInportFunctionCallGenerator generated from: '<Root>/PwrOff' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_PwrOff'
     */
    /* Outport: '<Root>/NeTMIR_e_HCP_LTP_FanAftRun_Rq_PM_Out' incorporates:
     *  DataStoreRead: '<S3>/NeTMIR_e_HCP_LTP_FanAftRun_Rq'
     */
    (void)Rte_Write_NeTMIR_e_HCP_LTP_FanAftRun_Rq_NeTMIR_e_HCP_LTP_FanAftRun_Rq
        (THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq);

    /* Outport: '<Root>/NeTHMR_t_PumpRunTmr_PM_Out' incorporates:
     *  DataStoreRead: '<S3>/NeTHMR_t_PumpRunTmr'
     */
    (void)Rte_Write_NeTHMR_t_PumpRunTmr_NeTHMR_t_PumpRunTmr
        (THMR_ac_DW.NeTHMR_t_PumpRunTmr);

    /* Outport: '<Root>/NeTHMR_t_PumpStrtTimeT1_PM_Out' incorporates:
     *  DataStoreRead: '<S3>/NeTHMR_t_PumpStrtTimeT1'
     */
    (void)Rte_Write_NeTHMR_t_PumpStrtTimeT1_NeTHMR_t_PumpStrtTimeT1
        (THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1);

    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/PwrOff' */
}

/* Output function */
FUNC(void, THMR_CODE) THMR_PwrOn(void)
{
    /* RootInportFunctionCallGenerator generated from: '<Root>/PwrOn' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_PwrOn'
     */
    /* S-Function (fcgen): '<S4>/FcnCallGen' incorporates:
     *  SubSystem: '<S4>/DSM_Init'
     */
    /* DataStoreWrite: '<S5674>/NeTHMR_t_PumpStrtTimeT1' incorporates:
     *  Inport: '<Root>/NeTHMR_t_PumpStrtTimeT1_PM_In'
     */
    (void)Rte_Read_NeTHMR_t_PumpStrtTimeT1_Rx_NeTHMR_t_PumpStrtTimeT1
        (&THMR_ac_DW.NeTHMR_t_PumpStrtTimeT1);

    /* DataStoreWrite: '<S5674>/NeTHMR_t_PumpRunTmr' incorporates:
     *  Inport: '<Root>/NeTHMR_t_PumpRunTmr_PM_In'
     */
    (void)Rte_Read_NeTHMR_t_PumpRunTmr_Rx_NeTHMR_t_PumpRunTmr
        (&THMR_ac_DW.NeTHMR_t_PumpRunTmr);

    /* DataStoreWrite: '<S5674>/NeTMIR_e_HCP_LTP_FanAftRun_Rq' incorporates:
     *  Inport: '<Root>/NeTMIR_e_HCP_LTP_FanAftRun_Rq_PM_In'
     */
    (void)
        Rte_Read_NeTMIR_e_HCP_LTP_FanAftRun_Rq_Rx_NeTMIR_e_HCP_LTP_FanAftRun_Rq(
        &THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq);

    /* S-Function (fcgen): '<S4>/FcnCallGen' incorporates:
     *  SubSystem: '<S4>/Sub_Out_Init'
     */
    /* SignalConversion generated from: '<S5679>/VeTHMR_T_ECH_ClntTempTgt_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_T_ECH_Cl = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_P_ECH_HtrPwrTgt_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_P_ECH_Ht = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_y_Htr_Oprtn_State_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_y_Htr_Op = 0U;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_CabReq_NotAllow_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_CabReq = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_CabAllowed_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_CabAll = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_dV_LT_ActvPmpFlow_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_dV_LT_Ac = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_dV_LT_PsvPmpFlow_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_dV_LT_Ps = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_dV_HT_AuxPmpFlow_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_dV_HT_Au = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_ClntPmpState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const9'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_ClntPm = THMR_ac_ConstB.Const9;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_LTPsvPmp_ClntWarmUp_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_LTPsvP = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_LTActvPmp_ClntWarmUp_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_LTActv = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_HTAuxPmp_ClntWarmUp_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_HTAuxP = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_ClntProp3WyVlv_Cmd_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_Clnt = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_ClntNProp3WyVlv_State_Out_Init' incorporates:
     *  Constant: '<S5679>/Const14'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_ClntNP = THMR_ac_ConstB.Const14;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_ClntProp3WyVlv_State_Out_Init' incorporates:
     *  Constant: '<S5679>/Const15'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_ClntPr = THMR_ac_ConstB.Const15;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_HTCV_LearnEnb_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_HTCV_L = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_RefShtoffVlv_State_Out_Init' incorporates:
     *  Constant: '<S5679>/Const17'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_RefSht = THMR_ac_ConstB.Const17;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_AirFlowReq_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_AirF = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_RadFan_State_Out_Init' incorporates:
     *  Constant: '<S5679>/Const19'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_RadFan = THMR_ac_ConstB.Const19;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_AGS_State_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_AGS_St = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_EmrgcyFanRq_Lvl_Out_Init' incorporates:
     *  Constant: '<S5679>/Const21'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_Emrgcy = THMR_ac_ConstB.Const21;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_HCP_AGS_Req_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_HCP_ = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_dT_CellOverTemp_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_dT_CellO = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_BattCondPlugin_Rq_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_BattCo = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_RmtStrtAbort_StrtVhclRq_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_RmtStr = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_EngOrBattPwrDschg_State_Out_Init' incorporates:
     *  Constant: '<S5679>/Const26'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_EngOrB = THMR_ac_ConstB.Const26;

    /* SignalConversion generated from: '<S5679>/VeTHMR_P_PwrBdgt_PwrLimitAvail_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_P_PwrBdg = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_P_Rat_EAC_PwrBdgt_Avail_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_P_Rat_EA = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_BattAllowed_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_BattAl = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_RdyForShtDwn_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_RdyFor = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_ThrmSysShtDwnFlt_Out_Init' incorporates:
     *  Constant: '<S5679>/Const31'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_ThrmSy = THMR_ac_ConstB.Const31;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_HV_BatTempCrit_Cond_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_HV_Bat = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_HVAC_HeatReq_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_HVAC_H = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_ThermSystEng_Req_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_ThermS = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_VhclStatus_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_VhclSt = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_t_BatPerWU_ThrmlCond_Timer_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_t_BatPer = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_HVAC_turnedOff_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_HVAC_t = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_StartVhcl_ToMaintain12Vlt_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_StartV = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_LeaveKeyIn_RUN_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_LeaveK = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_HV_Bat_CltLvlLo_Out_Init' incorporates:
     *  Constant: '<S5679>/Const40'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_HV_Bat = THMR_ac_ConstB.Const40;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_BatThrmlSt_Out_Init' incorporates:
     *  Constant: '<S5679>/Const41'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_BatThr = THMR_ac_ConstB.Const41;

    /* SignalConversion generated from: '<S5679>/VeTHMR_T_HtrCorClnt_TmpIn_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_T_HtrCor = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_isCharging_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_isChar = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_CabinPreCondReqStat_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_e_CabinP = 0;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_AC_CompState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const45'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_AC_Com = THMR_ac_ConstB.Const45;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_ActRemCompDecision_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_ActRem = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_Eng_Htr_HTSOV_Stat_Out_Init' incorporates:
     *  Constant: '<S5679>/Const47'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_Eng_Ht = THMR_ac_ConstB.Const47;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_PPCTIS_OT_Out_Init' incorporates:
     *  Constant: '<S5679>/Const48'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_PPCTIS = THMR_ac_ConstB.Const48;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_BSG_LTR_PmpFlwRq_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_BSG_ = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_dV_MGU_ClntPumpFlw_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_dV_MGU_C = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_n_EngSpdInc_Req_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_n_EngSpd = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_dV_MtrA_CoolFlwCmd_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_dV_MtrA_ = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_dV_MtrB_CoolFlwCmd_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_dV_MtrB_ = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_HVBR_OvrdReq_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_HVBR_O = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_VehThermSt_Out_Init' incorporates:
     *  Constant: '<S5679>/Const55'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_VehThe = THMR_ac_ConstB.Const55;

    /* SignalConversion generated from: '<S5679>/VeTHMR_T_MinBattAllow_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_T_MinBat = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_T_MaxBattAllow_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_T_MaxBat = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_HtrCorClnt_Tmp_InFA_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_HtrCor = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_HV_BatRdyLocal_True_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_HV_B_f = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_HVBR_UsgEnb_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_HVBR_U = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_RS_N_Or_NrmlPerWp_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_RS_N_O = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_HTCL_Heat_Distrib_Out_Init' incorporates:
     *  Constant: '<S5679>/Const62'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_HTCL_H = THMR_ac_ConstB.Const62;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_HCP_LTP_FanAftRun_Rq_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_HCP_LT = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_dV_LT_PsvPmp2Flow_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_dV_LT__i = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_LTPsvPmp2_ClntWarmUp_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_LTPs_n = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_BattOVFailure_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_BattOV = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_T_Htr2ClntTempTgt_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_T_Htr2Cl = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_P_Htr2PwrTgt_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_P_Htr2Pw = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_T_Htr3ClntTempTgt_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_T_Htr3Cl = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_P_Htr3PwrTgt_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_P_Htr3Pw = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_T_Htr4ClntTempTgt_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_T_Htr4Cl = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_P_Htr4PwrTgt_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_P_Htr4Pw = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_y_Htr_Slctn_State_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_y_Htr_Sl = 0U;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_AftrRunFanRqst_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_AftrRu = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_DisblFunc_Msg_10_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_DisblF = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_y_ClntPump_Slctd_State_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_y_ClntPu = 0U;

    /* SignalConversion generated from: '<S5679>/VeTHMR_y_ClntPump_Oprtng_State_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_y_Clnt_d = 0U;

    /* SignalConversion generated from: '<S5679>/VeTHMR_dV_Branch_1_Flw_Tgt_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_dV_Branc = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_dV_Branch_2_Flw_Tgt_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_dV_Bra_n = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_dV_LTR_Flw_Tgt_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_dV_LTR_F = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_T_MaxBattAllowPsv_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_T_MaxB_e = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_LINPrpVlv_Cmd_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_LINP = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_LINPrpVlv_CalibReq_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_LINPrp = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_HVAC_PerfModeFlg_Out_Init' incorporates:
     *  Constant: '<S5679>/Const84'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_HVAC_P = THMR_ac_ConstB.Const84;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_ThermalHybAltMode_Rq_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_Therma = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_KeyXstnOFF_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_KeyXst = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_t_SC_PrecTimer_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_t_SC_Pre = 0;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_SC_WkUp_Out_Init' incorporates:
     *  Constant: '<S5679>/Const88'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_SC_WkU = THMR_ac_ConstB.Const88;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_CabPrecondReqSt_Out_Init' incorporates:
     *  Constant: '<S5679>/Const89'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_CabPre = THMR_ac_ConstB.Const89;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_LTAP_ExpctdOff_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_LTAP_E = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_DrvDrAjar_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_DrvDrA = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_CabPrecDny_BattCond_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_CabPre = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_r_BattCabPriority_Ratio_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_r_BattCa = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_LINPrpVlv_SvReq_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_LINP_k = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_HTCV_RAEnbl_BattTmpHi_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_HTCV_R = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_CabinPreCondReqMsg_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_e_Cabi_c = 0;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_CabPrecond_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_CabP_f = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_PerWup_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_PerWup = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_LatcdImpct_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_LatcdI = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_SC_WkUpFlg_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_SC_WkU = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_T_MinBattAllowPsv_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_T_MinB_h = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_PerWup_EngtoCond_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_PerW_e = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_BattSharedHeaterAllowed_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_BattSh = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_P_PerWup_EngHeatNeed_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_P_PerWup = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_P_EDU_Heat_Cabin_Available_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_P_EDU_He = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_P_EDU_Heat_Battery_Available_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_P_EDU__c = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_P_EnginePwr_Available_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_P_Engine = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_CabThermalMode_Out_Init' incorporates:
     *  Constant: '<S5679>/Const108'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_CabThe = THMR_ac_ConstB.Const108;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_CabHeatThermalState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const109'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_CabHea = THMR_ac_ConstB.Const109;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_CabCoolThermalState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const110'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_CabCoo = THMR_ac_ConstB.Const110;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_LTCLRadVlvState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const111'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_LTCLRa = THMR_ac_ConstB.Const111;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_LTCLThrmlMode_Out_Init' incorporates:
     *  Constant: '<S5679>/Const112'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_LTCLTh = THMR_ac_ConstB.Const112;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_HTL_BypsVlv_Cmd_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_HTL_ = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_LTL_Vlv_Cmd_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_LTL_ = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_n_HTLPumpMBCReq_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_n_HTLPum = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_n_LTLPECP1MBC_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_n_LTLPEC = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_n_LTLPECP2MBC_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_n_LTLP_p = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_y_PumpEnbl_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_y_PumpEn = 0U;

    /* SignalConversion generated from: '<S5679>/VeTHMR_T_AHPInletTempArb_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_T_AHPInl = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_T_PPCTIS_Arb_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_T_PPCTIS = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_P_WCondCabHeat_Avail_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_P_WCondC = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_dV_Branch_3_Flw_Tgt_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_dV_Bra_m = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_EOP_A_EmrgCoolState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const124'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_EOP_A_ = THMR_ac_ConstB.Const124;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_EOP_B_EmrgCoolState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const125'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_EOP_B_ = THMR_ac_ConstB.Const125;

    /* SignalConversion generated from: '<S5679>/VeTHMR_r_HvHrnMtrAPowerLimit_Out_Init' incorporates:
     *  Constant: '<S5702>/Calib'
     */
    THMR_ac_B.OutportBufferForVeTHMR_r_HvHrnM = KeTHMR_r_HvHrnMtrAPowerLimit_NF;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_HvHrnMtrAPowerLimit_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_HvHrnM = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_r_HvHrnMtrBPowerLimit_Out_Init' incorporates:
     *  Constant: '<S5703>/Calib'
     */
    THMR_ac_B.OutportBufferForVeTHMR_r_HvHr_k = KeTHMR_r_HvHrnMtrBPowerLimit_NF;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_HvHrnMtrBPowerLimit_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_HvHr_o = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_r_HvHrnMtrCPowerLimit_Out_Init' incorporates:
     *  Constant: '<S5704>/Calib'
     */
    THMR_ac_B.OutportBufferForVeTHMR_r_HvHr_p = KeTHMR_r_HvHrnMtrCPowerLimit_NF;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_HvHrnMtrCPowerLimit_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_HvHr_i = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_DeiceActv_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_DeiceA = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_CabHeatThermalMode_Out_Init' incorporates:
     *  Constant: '<S5679>/Const133'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_CabH_a = THMR_ac_ConstB.Const133;

    /* SignalConversion generated from: '<S5679>/VeTHMR_i_ModeIndex_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_i_ModeIn = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_n_BTLPumpMBCReq_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_n_BTLPum = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_T_BattClntMinTgt_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_T_BattCl = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_AGS_PosReq_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_AGS_ = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_AGS2_PosReq_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_AGS2 = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_FC_CondAllwd_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_FC_Con = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_e_FCThrmlState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const140'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_FCThrm = THMR_ac_ConstB.Const140;

    /* SignalConversion generated from: '<S5679>/VeTHMR_P_CabHeatPwrNeed_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_P_CabHea = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_FCHeatAllwd_Out_Init' */
    THMR_ac_B.OutportBufferForVeTHMR_b_FCHeat = false;

    /* SignalConversion generated from: '<S5679>/OutAirTemp_Est_AftDial_write' */
    THMR_ac_B.OutportBufferForOutAirTemp_Est_ = 0.0F;

    /* SignalConversion generated from: '<S5679>/PropSysActv_AftDial_write' */
    THMR_ac_B.OutportBufferForPropSysActv_Aft = false;

    /* SignalConversion generated from: '<S5679>/OutAirTemp_EstV_AftDial_write' */
    THMR_ac_B.OutportBufferForOutAirTemp_EstV = false;

    /* SignalConversion generated from: '<S5679>/BattCntctrOpenPndg_AD_write' */
    THMR_ac_B.OutportBufferForBattCntctrOpenP = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_AAD_RetrctReq_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_b_AAD_Re = false;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_REDMHeatEstm_SNAflag_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_b_REDMHe = true;

    /* SignalConversion generated from: '<S5679>/VeTHMR_b_FEDMHeatEstm_SNAflag_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_b_FEDMHe = true;

    /* SignalConversion generated from: '<S5679>/VeTHMR_T_LTCLTgt_BattActvPsvHeating_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_T_LTCLTg = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_I_ChargeCurrentLim_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_I_Charge = 99999.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_HtrCoreBypssVlv_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_HtrC = 100.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_FCCP_Req_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_FCCP = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_FCHTRRadFanReq_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_FCHT = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_P_FCPSThrmlPwr_MaxAllwd_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_P_FCPSTh = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_LTRSolitaryAGS_PosReq_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_LTRS = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_HTRSolitaryAGS_PosReq_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_HTRS = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_BTRSolitaryAGS_PosReq_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_BTRS = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_LTR_AirFlowReq_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_LTR_ = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_HTR_AirFlowReq_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_HTR_ = 0.0F;

    /* SignalConversion generated from: '<S5679>/VeTHMR_Pct_BTR_AirFlowReq_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_BTR_ = 0.0F;

    /* SignalConversion generated from: '<S4>/FlowTgt_NF' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

    /* Outputs for Function Call SubSystem: '<S4>/FC_Loop_NF' */
    /* SignalConversion generated from: '<S5675>/FlowTgt_NF' incorporates:
     *  Constant: '<S5683>/Calib'
     */
    THMR_ac_B.OutportBufferForFlowTgt_NF = KeTHMR_dV_FC_ClntFlwtgt_NF;

    /* SignalConversion generated from: '<S5675>/Vlv_Pos_NF' incorporates:
     *  Constant: '<S5680>/Calib'
     */
    THMR_ac_B.OutportBufferForVlv_Pos_NF = KeTHMR_Pct_FC_VlvPosReq_NF;

    /* End of Outputs for SubSystem: '<S4>/FC_Loop_NF' */

    /* Outport: '<Root>/VeTHMR_dV_FCL_ClntFlowTgt' */
    (void)Rte_Write_VeTHMR_dV_FCL_ClntFlowTgt_Value
        (THMR_ac_B.OutportBufferForFlowTgt_NF);

    /* End of Outputs for S-Function (fcgen): '<S4>/FcnCallGen' */
#endif

    /* End of SignalConversion generated from: '<S4>/FlowTgt_NF' */

    /* S-Function (fcgen): '<S4>/FcnCallGen' incorporates:
     *  SubSystem: '<S4>/INIT_Output_Block'
     */
    /* Outport: '<Root>/VeTHMR_e_HCP_LTP_FanAftRun_Rq' incorporates:
     *  DataStoreRead: '<S5676>/DataStoreRead'
     *  SignalConversion generated from: '<S4>/HCP_LTP_FanAftRun_Rq_init'
     */
    (void)Rte_Write_VeTHMR_e_HCP_LTP_FanAftRun_Rq_Value
        (THMR_ac_DW.NeTMIR_e_HCP_LTP_FanAftRun_Rq);

    /* End of Outputs for S-Function (fcgen): '<S4>/FcnCallGen' */

    /* Outport: '<Root>/VeTHMR_I_ChargeCurrentLim' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_I_ChargeCurrentLim_OutInit'
     */
    (void)Rte_Write_VeTHMR_I_ChargeCurrentLim_Value
        (THMR_ac_B.OutportBufferForVeTHMR_I_Charge);

    /* Outport: '<Root>/VeTHMR_P_CabHeatPwrNeed' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_P_CabHeatPwrNeed_Out_Init'
     */
    (void)Rte_Write_VeTHMR_P_CabHeatPwrNeed_Value
        (THMR_ac_B.OutportBufferForVeTHMR_P_CabHea);

    /* Outport: '<Root>/VeTHMR_P_ECH_HtrPwrTgt' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_P_ECH_HtrPwrTgt_Out_Init'
     */
    (void)Rte_Write_VeTHMR_P_ECH_HtrPwrTgt_Value
        (THMR_ac_B.OutportBufferForVeTHMR_P_ECH_Ht);

    /* Outport: '<Root>/VeTHMR_P_EDU_Heat_Battery_Available' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_P_EDU_Heat_Battery_Available_Out_Init'
     */
    (void)Rte_Write_VeTHMR_P_EDU_Heat_Battery_Available_Value
        (THMR_ac_B.OutportBufferForVeTHMR_P_EDU__c);

    /* Outport: '<Root>/VeTHMR_P_EDU_Heat_Cabin_Available' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_P_EDU_Heat_Cabin_Available_Out_Init'
     */
    (void)Rte_Write_VeTHMR_P_EDU_Heat_Cabin_Available_Value
        (THMR_ac_B.OutportBufferForVeTHMR_P_EDU_He);

    /* Outport: '<Root>/VeTHMR_P_EnginePwr_Available' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_P_EnginePwr_Available_Out_Init'
     */
    (void)Rte_Write_VeTHMR_P_EnginePwr_Available_Value
        (THMR_ac_B.OutportBufferForVeTHMR_P_Engine);

    /* Outport: '<Root>/VeTHMR_P_FCPSThrmlPwr_MaxAllwd' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_P_FCPSThrmlPwr_MaxAllwd_OutInit'
     */
    (void)Rte_Write_VeTHMR_P_FCPSThrmlPwr_MaxAllwd_Value
        (THMR_ac_B.OutportBufferForVeTHMR_P_FCPSTh);

    /* Outport: '<Root>/VeTHMR_P_Htr2PwrTgt' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_P_Htr2PwrTgt_Out_Init'
     */
    (void)Rte_Write_VeTHMR_P_Htr2PwrTgt_Value
        (THMR_ac_B.OutportBufferForVeTHMR_P_Htr2Pw);

    /* Outport: '<Root>/VeTHMR_P_Htr3PwrTgt' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_P_Htr3PwrTgt_Out_Init'
     */
    (void)Rte_Write_VeTHMR_P_Htr3PwrTgt_Value
        (THMR_ac_B.OutportBufferForVeTHMR_P_Htr3Pw);

    /* Outport: '<Root>/VeTHMR_P_Htr4PwrTgt' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_P_Htr4PwrTgt_Out_Init'
     */
    (void)Rte_Write_VeTHMR_P_Htr4PwrTgt_Value
        (THMR_ac_B.OutportBufferForVeTHMR_P_Htr4Pw);

    /* Outport: '<Root>/VeTHMR_P_PerWup_EngHeatNeed' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_P_PerWup_EngHeatNeed_Out_Init'
     */
    (void)Rte_Write_VeTHMR_P_PerWup_EngHeatNeed_Value
        (THMR_ac_B.OutportBufferForVeTHMR_P_PerWup);

    /* Outport: '<Root>/VeTHMR_P_PwrBdgt_PwrLimitAvail' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_P_PwrBdgt_PwrLimitAvail_Out_Init'
     */
    (void)Rte_Write_VeTHMR_P_PwrBdgt_PwrLimitAvail_Value
        (THMR_ac_B.OutportBufferForVeTHMR_P_PwrBdg);

    /* Outport: '<Root>/VeTHMR_P_Rat_EAC_PwrBdgt_Avail' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_P_Rat_EAC_PwrBdgt_Avail_Out_Init'
     */
    (void)Rte_Write_VeTHMR_P_Rat_EAC_PwrBdgt_Avail_Value
        (THMR_ac_B.OutportBufferForVeTHMR_P_Rat_EA);

    /* Outport: '<Root>/VeTHMR_P_WCondCabHeat_Avail' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_P_WCondCabHeat_Avail_Out_Init'
     */
    (void)Rte_Write_VeTHMR_P_WCondCabHeat_Avail_Value
        (THMR_ac_B.OutportBufferForVeTHMR_P_WCondC);

    /* Outport: '<Root>/VeTHMR_Pct_AGS2_PosReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_AGS2_PosReq_Out_Init'
     */
    (void)Rte_Write_VeTHMR_Pct_AGS2_PosReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_AGS2);

    /* Outport: '<Root>/VeTHMR_Pct_AGS_PosReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_AGS_PosReq_Out_Init'
     */
    (void)Rte_Write_VeTHMR_Pct_AGS_PosReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_AGS_);

    /* Outport: '<Root>/VeTHMR_Pct_AirFlowReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_AirFlowReq_Out_Init'
     */
    (void)Rte_Write_VeTHMR_Pct_AirFlowReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_AirF);

    /* Outport: '<Root>/VeTHMR_Pct_BSG_LTR_PmpFlwRq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_BSG_LTR_PmpFlwRq_Out_Init'
     */
    (void)Rte_Write_VeTHMR_Pct_BSG_LTR_PmpFlwRq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_BSG_);

    /* Outport: '<Root>/VeTHMR_Pct_BTRSolitaryAGS_PosReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_BTRSolitaryAGS_PosReq_OutInit'
     */
    (void)Rte_Write_VeTHMR_Pct_BTRSolitaryAGS_PosReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_BTRS);

    /* Outport: '<Root>/VeTHMR_Pct_BTR_AirFlowReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_BTR_AirFlowReq_OutInit'
     */
    (void)Rte_Write_VeTHMR_Pct_BTR_AirFlowReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_BTR_);

    /* Outport: '<Root>/VeTHMR_Pct_ClntProp3WyVlv_Cmd' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_ClntProp3WyVlv_Cmd_Out_Init'
     */
    (void)Rte_Write_VeTHMR_Pct_ClntProp3WyVlv_Cmd_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_Clnt);

    /* Outport: '<Root>/VeTHMR_Pct_FCCP_Req' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_FCCP_Req_OutInit'
     */
    (void)Rte_Write_VeTHMR_Pct_FCCP_Req_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_FCCP);

    /* Outport: '<Root>/VeTHMR_Pct_FCHTRRadFanReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_FCHTRRadFanReq_OutInit'
     */
    (void)Rte_Write_VeTHMR_Pct_FCHTRRadFanReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_FCHT);

    /* Outport: '<Root>/VeTHMR_Pct_HCP_AGS_Req' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_HCP_AGS_Req_Out_Init'
     */
    (void)Rte_Write_VeTHMR_Pct_HCP_AGS_Req_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_HCP_);

    /* Outport: '<Root>/VeTHMR_Pct_HTL_BypsVlv_Cmd' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_HTL_BypsVlv_Cmd_Out_Init'
     */
    (void)Rte_Write_VeTHMR_Pct_HTL_BypsVlv_Cmd_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_HTL_);

    /* Outport: '<Root>/VeTHMR_Pct_HTRSolitaryAGS_PosReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_HTRSolitaryAGS_PosReq_OutInit'
     */
    (void)Rte_Write_VeTHMR_Pct_HTRSolitaryAGS_PosReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_HTRS);

    /* Outport: '<Root>/VeTHMR_Pct_HTR_AirFlowReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_HTR_AirFlowReq_OutInit'
     */
    (void)Rte_Write_VeTHMR_Pct_HTR_AirFlowReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_HTR_);

    /* Outport: '<Root>/VeTHMR_Pct_HtrCoreBypssVlv' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_HtrCoreBypssVlv_OutInit'
     */
    (void)Rte_Write_VeTHMR_Pct_HtrCoreBypssVlv_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_HtrC);

    /* Outport: '<Root>/VeTHMR_Pct_LINPrpVlv_Cmd' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_LINPrpVlv_Cmd_Out_Init'
     */
    (void)Rte_Write_VeTHMR_Pct_LINPrpVlv_Cmd_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_LINP);

    /* Outport: '<Root>/VeTHMR_Pct_LTL_Vlv_Cmd' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_LTL_Vlv_Cmd_Out_Init'
     */
    (void)Rte_Write_VeTHMR_Pct_LTL_Vlv_Cmd_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_LTL_);

    /* Outport: '<Root>/VeTHMR_Pct_LTRSolitaryAGS_PosReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_LTRSolitaryAGS_PosReq_OutInit'
     */
    (void)Rte_Write_VeTHMR_Pct_LTRSolitaryAGS_PosReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_LTRS);

    /* Outport: '<Root>/VeTHMR_Pct_LTR_AirFlowReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_Pct_LTR_AirFlowReq_OutInit'
     */
    (void)Rte_Write_VeTHMR_Pct_LTR_AirFlowReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_Pct_LTR_);

    /* Outport: '<Root>/VeTHMR_T_AHPInletTempArb' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_T_AHPInletTempArb_Out_Init'
     */
    (void)Rte_Write_VeTHMR_T_AHPInletTempArb_Value
        (THMR_ac_B.OutportBufferForVeTHMR_T_AHPInl);

    /* Outport: '<Root>/VeTHMR_T_BattClntMinTgt' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_T_BattClntMinTgt_Out_Init'
     */
    (void)Rte_Write_VeTHMR_T_BattClntMinTgt_Value
        (THMR_ac_B.OutportBufferForVeTHMR_T_BattCl);

    /* Outport: '<Root>/VeTHMR_T_ECH_ClntTempTgt' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_T_ECH_ClntTempTgt_Out_Init'
     */
    (void)Rte_Write_VeTHMR_T_ECH_ClntTempTgt_Value
        (THMR_ac_B.OutportBufferForVeTHMR_T_ECH_Cl);

    /* Outport: '<Root>/VeTHMR_T_Htr2ClntTempTgt' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_T_Htr2ClntTempTgt_Out_Init'
     */
    (void)Rte_Write_VeTHMR_T_Htr2ClntTempTgt_Value
        (THMR_ac_B.OutportBufferForVeTHMR_T_Htr2Cl);

    /* Outport: '<Root>/VeTHMR_T_Htr3ClntTempTgt' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_T_Htr3ClntTempTgt_Out_Init'
     */
    (void)Rte_Write_VeTHMR_T_Htr3ClntTempTgt_Value
        (THMR_ac_B.OutportBufferForVeTHMR_T_Htr3Cl);

    /* Outport: '<Root>/VeTHMR_T_Htr4ClntTempTgt' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_T_Htr4ClntTempTgt_Out_Init'
     */
    (void)Rte_Write_VeTHMR_T_Htr4ClntTempTgt_Value
        (THMR_ac_B.OutportBufferForVeTHMR_T_Htr4Cl);

    /* Outport: '<Root>/VeTHMR_T_HtrCorClnt_TmpIn' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_T_HtrCorClnt_TmpIn_Out_Init'
     */
    (void)Rte_Write_VeTHMR_T_HtrCorClnt_TmpIn_Value
        (THMR_ac_B.OutportBufferForVeTHMR_T_HtrCor);

    /* Outport: '<Root>/VeTHMR_T_LTCLTgt_BattActvPsvHeating' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_T_LTCLTgt_BattActvPsvHeating_OutInit'
     */
    (void)Rte_Write_VeTHMR_T_LTCLTgt_BattActvPsvHeating_Value
        (THMR_ac_B.OutportBufferForVeTHMR_T_LTCLTg);

    /* Outport: '<Root>/VeTHMR_T_MaxBattAllowPsv' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_T_MaxBattAllowPsv_Out_Init'
     */
    (void)Rte_Write_VeTHMR_T_MaxBattAllowPsv_Value
        (THMR_ac_B.OutportBufferForVeTHMR_T_MaxB_e);

    /* Outport: '<Root>/VeTHMR_T_MaxBattAllow' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_T_MaxBattAllow_Out_Init'
     */
    (void)Rte_Write_VeTHMR_T_MaxBattAllow_Value
        (THMR_ac_B.OutportBufferForVeTHMR_T_MaxBat);

    /* Outport: '<Root>/VeTHMR_T_MinBattAllowPsv' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_T_MinBattAllowPsv_Out_Init'
     */
    (void)Rte_Write_VeTHMR_T_MinBattAllowPsv_Value
        (THMR_ac_B.OutportBufferForVeTHMR_T_MinB_h);

    /* Outport: '<Root>/VeTHMR_T_MinBattAllow' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_T_MinBattAllow_Out_Init'
     */
    (void)Rte_Write_VeTHMR_T_MinBattAllow_Value
        (THMR_ac_B.OutportBufferForVeTHMR_T_MinBat);

    /* Outport: '<Root>/VeTHMR_T_PPCTIS_Arb' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_T_PPCTIS_Arb_Out_Init'
     */
    (void)Rte_Write_VeTHMR_T_PPCTIS_Arb_Value
        (THMR_ac_B.OutportBufferForVeTHMR_T_PPCTIS);

    /* Outport: '<Root>/VeTHMR_b_AAD_RetrctReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_AAD_RetrctReq_OutInit'
     */
    (void)Rte_Write_VeTHMR_b_AAD_RetrctReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_AAD_Re);

    /* Outport: '<Root>/VeTHMR_b_AGS_State' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_AGS_State_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_AGS_State_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_AGS_St);

    /* Outport: '<Root>/VeTHMR_b_ActRemCompDecision' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_ActRemCompDecision_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_ActRemCompDecision_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_ActRem);

    /* Outport: '<Root>/VeTHMR_b_AftrRunFanRqst' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_AftrRunFanRqst_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_AftrRunFanRqst_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_AftrRu);

    /* Outport: '<Root>/VeTHMR_b_BattAllowed' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_BattAllowed_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_BattAllowed_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_BattAl);

    /* Outport: '<Root>/VeTHMR_b_BattCondPlugin_Rq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_BattCondPlugin_Rq_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_BattCondPlugin_Rq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_BattCo);

    /* Outport: '<Root>/VeTHMR_b_BattOVFailure' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_BattOVFailure_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_BattOVFailure_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_BattOV);

    /* Outport: '<Root>/VeTHMR_b_BattSharedHeaterAllowed' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_BattSharedHeaterAllowed_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_BattSharedHeaterAllowed_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_BattSh);

    /* Outport: '<Root>/VeTHMR_b_CabAllowed' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_CabAllowed_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_CabAllowed_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_CabAll);

    /* Outport: '<Root>/VeTHMR_b_CabPrecDny_BattCond' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_CabPrecDny_BattCond_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_CabPrecDny_BattCond_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_CabPre);

    /* Outport: '<Root>/VeTHMR_b_CabPrecond' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_CabPrecond_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_CabPrecond_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_CabP_f);

    /* Outport: '<Root>/VeTHMR_b_CabReq_NotAllow' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_CabReq_NotAllow_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_CabReq_NotAllow_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_CabReq);

    /* Outport: '<Root>/VeTHMR_b_DeiceActv' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_DeiceActv_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_DeiceActv_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_DeiceA);

    /* Outport: '<Root>/VeTHMR_b_DisblFunc_Msg_10' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_DisblFunc_Msg_10_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_DisblFunc_Msg_10_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_DisblF);

    /* Outport: '<Root>/VeTHMR_b_DrvDrAjar' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_DrvDrAjar_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_DrvDrAjar_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_DrvDrA);

    /* Outport: '<Root>/VeTHMR_b_FCHeatAllwd' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_FCHeatAllwd_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_FCHeatAllwd_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_FCHeat);

    /* Outport: '<Root>/VeTHMR_b_FC_CondAllwd' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_FC_CondAllwd_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_FC_CondAllwd_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_FC_Con);

    /* Outport: '<Root>/VeTHMR_b_FEDMHeatEstm_SNAflag' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_FEDMHeatEstm_SNAflag_OutInit'
     */
    (void)Rte_Write_VeTHMR_b_FEDMHeatEstm_SNAflag_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_FEDMHe);

    /* Outport: '<Root>/VeTHMR_b_HCP_LTP_FanAftRun_Rq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_HCP_LTP_FanAftRun_Rq_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_HCP_LTP_FanAftRun_Rq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_HCP_LT);

    /* Outport: '<Root>/VeTHMR_b_HTAuxPmp_ClntWarmUp' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_HTAuxPmp_ClntWarmUp_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_HTAuxPmp_ClntWarmUp_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_HTAuxP);

    /* Outport: '<Root>/VeTHMR_b_HTCV_LearnEnb' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_HTCV_LearnEnb_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_HTCV_LearnEnb_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_HTCV_L);

    /* Outport: '<Root>/VeTHMR_b_HTCV_RAEnbl_BattTmpHi' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_HTCV_RAEnbl_BattTmpHi_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_HTCV_RAEnbl_BattTmpHi_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_HTCV_R);

    /* Outport: '<Root>/VeTHMR_b_HVAC_HeatReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_HVAC_HeatReq_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_HVAC_HeatReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_HVAC_H);

    /* Outport: '<Root>/VeTHMR_b_HVAC_turnedOff' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_HVAC_turnedOff_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_HVAC_turnedOff_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_HVAC_t);

    /* Outport: '<Root>/VeTHMR_b_HVBR_OvrdReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_HVBR_OvrdReq_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_HVBR_OvrdReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_HVBR_O);

    /* Outport: '<Root>/VeTHMR_b_HVBR_UsgEnb' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_HVBR_UsgEnb_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_HVBR_UsgEnb_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_HVBR_U);

    /* Outport: '<Root>/VeTHMR_b_HV_BatRdyLocal_True' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_HV_BatRdyLocal_True_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_HV_BatRdyLocal_True_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_HV_B_f);

    /* Outport: '<Root>/VeTHMR_b_HV_BatTempCrit_Cond' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_HV_BatTempCrit_Cond_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_HV_BatTempCrit_Cond_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_HV_Bat);

    /* Outport: '<Root>/VeTHMR_b_HtrCorClnt_Tmp_InFA' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_HtrCorClnt_Tmp_InFA_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_HtrCorClnt_Tmp_InFA_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_HtrCor);

    /* Outport: '<Root>/VeTHMR_b_HvHrnMtrAPowerLimit' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_HvHrnMtrAPowerLimit_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_HvHrnMtrAPowerLimit_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_HvHrnM);

    /* Outport: '<Root>/VeTHMR_b_HvHrnMtrBPowerLimit' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_HvHrnMtrBPowerLimit_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_HvHrnMtrBPowerLimit_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_HvHr_o);

    /* Outport: '<Root>/VeTHMR_b_HvHrnMtrCPowerLimit' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_HvHrnMtrCPowerLimit_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_HvHrnMtrCPowerLimit_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_HvHr_i);

    /* Outport: '<Root>/VeTHMR_b_KeyXstnOFF' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_KeyXstnOFF_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_KeyXstnOFF_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_KeyXst);

    /* Outport: '<Root>/VeTHMR_b_LINPrpVlv_CalibReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_LINPrpVlv_CalibReq_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_LINPrpVlv_CalibReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_LINPrp);

    /* Outport: '<Root>/VeTHMR_b_LINPrpVlv_SvReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_LINPrpVlv_SvReq_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_LINPrpVlv_SvReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_LINP_k);

    /* Outport: '<Root>/VeTHMR_b_LTAP_ExpctdOff' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_LTAP_ExpctdOff_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_LTAP_ExpctdOff_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_LTAP_E);

    /* Outport: '<Root>/VeTHMR_b_LTActvPmp_ClntWarmUp' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_LTActvPmp_ClntWarmUp_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_LTActvPmp_ClntWarmUp_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_LTActv);

    /* Outport: '<Root>/VeTHMR_b_LTPsvPmp2_ClntWarmUp' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_LTPsvPmp2_ClntWarmUp_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_LTPsvPmp2_ClntWarmUp_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_LTPs_n);

    /* Outport: '<Root>/VeTHMR_b_LTPsvPmp_ClntWarmUp' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_LTPsvPmp_ClntWarmUp_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_LTPsvPmp_ClntWarmUp_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_LTPsvP);

    /* Outport: '<Root>/VeTHMR_b_LatcdImpct' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_LatcdImpct_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_LatcdImpct_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_LatcdI);

    /* Outport: '<Root>/VeTHMR_b_LeaveKeyIn_RUN' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_LeaveKeyIn_RUN_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_LeaveKeyIn_RUN_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_LeaveK);

    /* Outport: '<Root>/VeTHMR_b_PerWup_EngtoCond' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_PerWup_EngtoCond_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_PerWup_EngtoCond_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_PerW_e);

    /* Outport: '<Root>/VeTHMR_b_PerWup' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_PerWup_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_PerWup_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_PerWup);

    /* Outport: '<Root>/VeTHMR_b_REDMHeatEstm_SNAflag' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_REDMHeatEstm_SNAflag_OutInit'
     */
    (void)Rte_Write_VeTHMR_b_REDMHeatEstm_SNAflag_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_REDMHe);

    /* Outport: '<Root>/VeTHMR_b_RS_N_Or_NrmlPerWp' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_RS_N_Or_NrmlPerWp_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_RS_N_Or_NrmlPerWp_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_RS_N_O);

    /* Outport: '<Root>/VeTHMR_b_RdyForShtDwn' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_RdyForShtDwn_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_RdyForShtDwn_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_RdyFor);

    /* Outport: '<Root>/VeTHMR_b_RmtStrtAbort_StrtVhclRq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_RmtStrtAbort_StrtVhclRq_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_RmtStrtAbort_StrtVhclRq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_RmtStr);

    /* Outport: '<Root>/VeTHMR_b_SC_WkUpFlg' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_SC_WkUpFlg_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_SC_WkUpFlg_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_SC_WkU);

    /* Outport: '<Root>/VeTHMR_b_StartVhcl_ToMaintain12Vlt' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_StartVhcl_ToMaintain12Vlt_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_StartVhcl_ToMaintain12Vlt_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_StartV);

    /* Outport: '<Root>/VeTHMR_b_ThermSystEng_Req' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_ThermSystEng_Req_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_ThermSystEng_Req_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_ThermS);

    /* Outport: '<Root>/VeTHMR_b_ThermalHybAltMode_Rq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_ThermalHybAltMode_Rq_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_ThermalHybAltMode_Rq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_Therma);

    /* Outport: '<Root>/VeTHMR_b_VhclStatus' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_VhclStatus_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_VhclStatus_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_VhclSt);

    /* Outport: '<Root>/VeTHMR_b_isCharging' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_b_isCharging_Out_Init'
     */
    (void)Rte_Write_VeTHMR_b_isCharging_Value
        (THMR_ac_B.OutportBufferForVeTHMR_b_isChar);

    /* Outport: '<Root>/VeTHMR_dT_CellOverTemp' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_dT_CellOverTemp_Out_Init'
     */
    (void)Rte_Write_VeTHMR_dT_CellOverTemp_Value
        (THMR_ac_B.OutportBufferForVeTHMR_dT_CellO);

    /* Outport: '<Root>/VeTHMR_dV_Branch_1_Flw' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_dV_Branch_1_Flw_Tgt_OutInit'
     */
    (void)Rte_Write_VeTHMR_dV_Branch_1_Flw_Value
        (THMR_ac_B.OutportBufferForVeTHMR_dV_Branc);

    /* Outport: '<Root>/VeTHMR_dV_Branch_2_Flw' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_dV_Branch_2_Flw_Tgt_OutInit'
     */
    (void)Rte_Write_VeTHMR_dV_Branch_2_Flw_Value
        (THMR_ac_B.OutportBufferForVeTHMR_dV_Bra_n);

    /* Outport: '<Root>/VeTHMR_dV_Branch_3_Flw' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_dV_Branch_3_Flw_Tgt_OutInit'
     */
    (void)Rte_Write_VeTHMR_dV_Branch_3_Flw_Value
        (THMR_ac_B.OutportBufferForVeTHMR_dV_Bra_m);

    /* Outport: '<Root>/VeTHMR_dV_HT_AuxPmpFlow' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_dV_HT_AuxPmpFlow_Out_Init'
     */
    (void)Rte_Write_VeTHMR_dV_HT_AuxPmpFlow_Value
        (THMR_ac_B.OutportBufferForVeTHMR_dV_HT_Au);

    /* Outport: '<Root>/VeTHMR_dV_LTR_Flw_Tgt' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_dV_LTR_Flw_Tgt_Out_Init'
     */
    (void)Rte_Write_VeTHMR_dV_LTR_Flw_Tgt_Value
        (THMR_ac_B.OutportBufferForVeTHMR_dV_LTR_F);

    /* Outport: '<Root>/VeTHMR_dV_LT_ActvPmpFlow' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_dV_LT_ActvPmpFlow_Out_Init'
     */
    (void)Rte_Write_VeTHMR_dV_LT_ActvPmpFlow_Value
        (THMR_ac_B.OutportBufferForVeTHMR_dV_LT_Ac);

    /* Outport: '<Root>/VeTHMR_dV_LT_PsvPmp2Flow' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_dV_LT_PsvPmp2Flow_Out_Init'
     */
    (void)Rte_Write_VeTHMR_dV_LT_PsvPmp2Flow_Value
        (THMR_ac_B.OutportBufferForVeTHMR_dV_LT__i);

    /* Outport: '<Root>/VeTHMR_dV_LT_PsvPmpFlow' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_dV_LT_PsvPmpFlow_Out_Init'
     */
    (void)Rte_Write_VeTHMR_dV_LT_PsvPmpFlow_Value
        (THMR_ac_B.OutportBufferForVeTHMR_dV_LT_Ps);

    /* Outport: '<Root>/VeTHMR_dV_MGU_ClntPumpFlw' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_dV_MGU_ClntPumpFlw_Out_Init'
     */
    (void)Rte_Write_VeTHMR_dV_MGU_ClntPumpFlw_Value
        (THMR_ac_B.OutportBufferForVeTHMR_dV_MGU_C);

    /* Outport: '<Root>/VeTHMR_dV_MtrA_CoolFlwCmd' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_dV_MtrA_CoolFlwCmd_Out_Init'
     */
    (void)Rte_Write_VeTHMR_dV_MtrA_CoolFlwCmd_Value
        (THMR_ac_B.OutportBufferForVeTHMR_dV_MtrA_);

    /* Outport: '<Root>/VeTHMR_dV_MtrB_CoolFlwCmd' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_dV_MtrB_CoolFlwCmd_Out_Init'
     */
    (void)Rte_Write_VeTHMR_dV_MtrB_CoolFlwCmd_Value
        (THMR_ac_B.OutportBufferForVeTHMR_dV_MtrB_);

    /* Outport: '<Root>/VeTHMR_e_AC_CompState' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_AC_CompState_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_AC_CompState_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_AC_CompState_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_AC_Com);

    /* Outport: '<Root>/VeTHMR_e_BatThrmlSt' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_BatThrmlSt_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_BatThrmlSt_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_BatThrmlSt_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_BatThr);

    /* Outport: '<Root>/VeTHMR_e_CabCoolThermalState' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_CabCoolThermalState_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_CabCoolThermalState_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_CabCoolThermalState_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_CabCoo);

    /* Outport: '<Root>/VeTHMR_e_CabHeatThermalMode' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_CabHeatThermalMode_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_CabHeatThermalMode_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_CabHeatThermalMode_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_CabH_a);

    /* Outport: '<Root>/VeTHMR_e_CabHeatThermalState' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_CabHeatThermalState_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_CabHeatThermalState_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_CabHeatThermalState_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_CabHea);

    /* Outport: '<Root>/VeTHMR_e_CabPrecondReqSt' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_CabPrecondReqSt_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_CabPrecondReqSt_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_CabPrecondReqSt_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_CabPre);

    /* Outport: '<Root>/VeTHMR_e_CabThermalMode' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_CabThermalMode_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_CabThermalMode_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_CabThermalMode_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_CabThe);

    /* Outport: '<Root>/VeTHMR_e_CabinPreCondReqMsg' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_CabinPreCondReqMsg_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_CabinPreCondReqMsg_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_Cabi_c);

    /* Outport: '<Root>/VeTHMR_e_CabinPreCondReqStat' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_CabinPreCondReqStat_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_CabinPreCondReqStat_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_CabinP);

    /* Outport: '<Root>/VeTHMR_e_ClntNProp3WyVlv_State' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_ClntNProp3WyVlv_State_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_ClntNProp3WyVlv_State_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_ClntNProp3WyVlv_State_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_ClntNP);

    /* Outport: '<Root>/VeTHMR_e_ClntPmpState' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_ClntPmpState_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_ClntPmpState_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_ClntPmpState_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_ClntPm);

    /* Outport: '<Root>/VeTHMR_e_ClntProp3WyVlv_State' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_ClntProp3WyVlv_State_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_ClntProp3WyVlv_State_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_ClntProp3WyVlv_State_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_ClntPr);

    /* Outport: '<Root>/VeTHMR_e_EOP_A_EmrgCoolState' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_EOP_A_EmrgCoolState_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_EOP_A_EmrgCoolState_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_EOP_A_EmrgCoolState_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_EOP_A_);

    /* Outport: '<Root>/VeTHMR_e_EOP_B_EmrgCoolState' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_EOP_B_EmrgCoolState_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_EOP_B_EmrgCoolState_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_EOP_B_EmrgCoolState_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_EOP_B_);

    /* Outport: '<Root>/VeTHMR_e_EmrgcyFanRq_Lvl' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_EmrgcyFanRq_Lvl_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_EmrgcyFanRq_Lvl_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_EmrgcyFanRq_Lvl_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_Emrgcy);

    /* Outport: '<Root>/VeTHMR_e_EngOrBattPwrDschg_State' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_EngOrBattPwrDschg_State_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_EngOrBattPwrDschg_State_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_EngOrBattPwrDschg_State_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_EngOrB);

    /* Outport: '<Root>/VeTHMR_e_Eng_Htr_HTSOV_Stat' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_Eng_Htr_HTSOV_Stat_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_Eng_Htr_HTSOV_Stat_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_Eng_Htr_HTSOV_Stat_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_Eng_Ht);

    /* Outport: '<Root>/VeTHMR_e_FCThrmlState' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_FCThrmlState_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_FCThrmlState_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_FCThrmlState_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_FCThrm);

    /* Outport: '<Root>/VeTHMR_e_HTCL_Heat_Distrib' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_HTCL_Heat_Distrib_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_HTCL_Heat_Distrib_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_HTCL_Heat_Distrib_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_HTCL_H);

    /* Outport: '<Root>/VeTHMR_e_HVAC_PerfModeFlg' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_HVAC_PerfModeFlg_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_HVAC_PerfModeFlg_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_HVAC_PerfModeFlg_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_HVAC_P);

    /* Outport: '<Root>/VeTHMR_e_HV_Bat_CltLvlLo' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_HV_Bat_CltLvlLo_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_HV_Bat_CltLvlLo_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_HV_Bat_CltLvlLo_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_HV_Bat);

    /* Outport: '<Root>/VeTHMR_e_LTCLRadVlvState' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_LTCLRadVlvState_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_LTCLRadVlvState_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_LTCLRadVlvState_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_LTCLRa);

    /* Outport: '<Root>/VeTHMR_e_LTCLThrmlMode' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_LTCLThrmlMode_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_LTCLThrmlMode_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_LTCLThrmlMode_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_LTCLTh);

    /* Outport: '<Root>/VeTHMR_e_PPCTIS_OT' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_PPCTIS_OT_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_PPCTIS_OT_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_PPCTIS_OT_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_PPCTIS);

    /* Outport: '<Root>/VeTHMR_e_RadFan_State' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_RadFan_State_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_RadFan_State_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_RadFan_State_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_RadFan);

    /* Outport: '<Root>/VeTHMR_e_RefShtoffVlv_State' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_RefShtoffVlv_State_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_RefShtoffVlv_State_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_RefShtoffVlv_State_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_RefSht);

    /* Outport: '<Root>/VeTHMR_e_SC_WkUp' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_SC_WkUp_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_SC_WkUp_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_SC_WkUp_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_SC_WkU);

    /* Outport: '<Root>/VeTHMR_e_ThrmSysShtDwnFlt' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_ThrmSysShtDwnFlt_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_ThrmSysShtDwnFlt_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_ThrmSysShtDwnFlt_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_ThrmSy);

    /* Outport: '<Root>/VeTHMR_e_VehThermSt' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_e_VehThermSt_Out_Init'
     *  SignalConversion generated from: '<S5679>/VeTHMR_e_VehThermSt_Out_Init'
     */
    (void)Rte_Write_VeTHMR_e_VehThermSt_Value
        (THMR_ac_B.OutportBufferForVeTHMR_e_VehThe);

    /* Outport: '<Root>/VeTHMR_i_ModeIndex' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_i_ModeIndex_Out_Init'
     */
    (void)Rte_Write_VeTHMR_i_ModeIndex_Value
        (THMR_ac_B.OutportBufferForVeTHMR_i_ModeIn);

    /* Outport: '<Root>/VeTHMR_n_BTLPumpMBCReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_n_BTLPumpMBCReq_Out_Init'
     */
    (void)Rte_Write_VeTHMR_n_BTLPumpMBCReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_n_BTLPum);

    /* Outport: '<Root>/VeTHMR_n_EngSpdInc_Req' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_n_EngSpdInc_Req_Out_Init'
     */
    (void)Rte_Write_VeTHMR_n_EngSpdInc_Req_Value
        (THMR_ac_B.OutportBufferForVeTHMR_n_EngSpd);

    /* Outport: '<Root>/VeTHMR_n_HTLPumpMBCReq' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_n_HTLPumpMBCReq_Out_Init'
     */
    (void)Rte_Write_VeTHMR_n_HTLPumpMBCReq_Value
        (THMR_ac_B.OutportBufferForVeTHMR_n_HTLPum);

    /* Outport: '<Root>/VeTHMR_n_LTLPECP1MBC' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_n_LTLPECP1MBC_Out_Init'
     */
    (void)Rte_Write_VeTHMR_n_LTLPECP1MBC_Value
        (THMR_ac_B.OutportBufferForVeTHMR_n_LTLPEC);

    /* Outport: '<Root>/VeTHMR_n_LTLPECP2MBC' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_n_LTLPECP2MBC_Out_Init'
     */
    (void)Rte_Write_VeTHMR_n_LTLPECP2MBC_Value
        (THMR_ac_B.OutportBufferForVeTHMR_n_LTLP_p);

    /* Outport: '<Root>/VeTHMR_r_BattCabPriority_Ratio' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_r_BattCabPriority_Ratio_Out_Init'
     */
    (void)Rte_Write_VeTHMR_r_BattCabPriority_Ratio_Value
        (THMR_ac_B.OutportBufferForVeTHMR_r_BattCa);

    /* Outport: '<Root>/VeTHMR_r_HvHrnMtrAPowerLimit' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_r_HvHrnMtrAPowerLimit_Out_Init'
     */
    (void)Rte_Write_VeTHMR_r_HvHrnMtrAPowerLimit_Value
        (THMR_ac_B.OutportBufferForVeTHMR_r_HvHrnM);

    /* Outport: '<Root>/VeTHMR_r_HvHrnMtrBPowerLimit' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_r_HvHrnMtrBPowerLimit_Out_Init'
     */
    (void)Rte_Write_VeTHMR_r_HvHrnMtrBPowerLimit_Value
        (THMR_ac_B.OutportBufferForVeTHMR_r_HvHr_k);

    /* Outport: '<Root>/VeTHMR_r_HvHrnMtrCPowerLimit' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_r_HvHrnMtrCPowerLimit_Out_Init'
     */
    (void)Rte_Write_VeTHMR_r_HvHrnMtrCPowerLimit_Value
        (THMR_ac_B.OutportBufferForVeTHMR_r_HvHr_p);

    /* Outport: '<Root>/VeTHMR_t_BatPerWU_ThrmlCond_Timer' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_t_BatPerWU_ThrmlCond_Timer_Out_Init'
     */
    (void)Rte_Write_VeTHMR_t_BatPerWU_ThrmlCond_Timer_Value
        (THMR_ac_B.OutportBufferForVeTHMR_t_BatPer);

    /* Outport: '<Root>/VeTHMR_t_SC_PrecTimer' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_t_SC_PrecTimer_Out_Init'
     */
    (void)Rte_Write_VeTHMR_t_SC_PrecTimer_Value
        (THMR_ac_B.OutportBufferForVeTHMR_t_SC_Pre);

    /* Outport: '<Root>/VeTHMR_y_ClntPump_Oprtng_State' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_y_ClntPump_Oprtng_State_Out_Init'
     */
    (void)Rte_Write_VeTHMR_y_ClntPump_Oprtng_State_Value
        (THMR_ac_B.OutportBufferForVeTHMR_y_Clnt_d);

    /* Outport: '<Root>/VeTHMR_y_ClntPump_Slctd_State' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_y_ClntPump_Slctd_State_Out_Init'
     */
    (void)Rte_Write_VeTHMR_y_ClntPump_Slctd_State_Value
        (THMR_ac_B.OutportBufferForVeTHMR_y_ClntPu);

    /* Outport: '<Root>/VeTHMR_y_Htr_Oprtn_State' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_y_Htr_Oprtn_State_Out_Init'
     */
    (void)Rte_Write_VeTHMR_y_Htr_Oprtn_State_Value
        (THMR_ac_B.OutportBufferForVeTHMR_y_Htr_Op);

    /* Outport: '<Root>/VeTHMR_y_Htr_Slctn_State' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_y_Htr_Slctn_State_Out_Init'
     */
    (void)Rte_Write_VeTHMR_y_Htr_Slctn_State_Value
        (THMR_ac_B.OutportBufferForVeTHMR_y_Htr_Sl);

    /* Outport: '<Root>/VeTHMR_y_PumpEnbl' incorporates:
     *  SignalConversion generated from: '<S4>/VeTHMR_y_PumpEnbl_Out_Init'
     */
    (void)Rte_Write_VeTHMR_y_PumpEnbl_Value
        (THMR_ac_B.OutportBufferForVeTHMR_y_PumpEn);

    /* SignalConversion generated from: '<S4>/Vlv_Pos_NF' */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

    /* Outport: '<Root>/VeTHMR_Pct_FC_Vlv_Cmd' */
    (void)Rte_Write_VeTHMR_Pct_FC_Vlv_Cmd_Value
        (THMR_ac_B.OutportBufferForVlv_Pos_NF);

#endif

    /* End of SignalConversion generated from: '<S4>/Vlv_Pos_NF' */

    /* Merge: '<Root>/BattCntctrOpenPndg_AD_IRV_Merge' incorporates:
     *  SignalConversion generated from: '<S4>/BattCntctrOpenPndg_AD_write'
     * */
    Rte_IrvWrite_THMR_PwrOn_BattCntctrOpenPndg_AD_write_IRV
        (THMR_ac_B.OutportBufferForBattCntctrOpenP);

    /* Merge: '<Root>/OutAirTemp_EstV_AftDial_IRV_Merge' incorporates:
     *  SignalConversion generated from: '<S4>/OutAirTemp_EstV_AftDial_write'
     * */
    Rte_IrvWrite_THMR_PwrOn_OutAirTemp_EstV_AftDial_write_IRV
        (THMR_ac_B.OutportBufferForOutAirTemp_EstV);

    /* Merge: '<Root>/OutAirTemp_Est_AftDial_IRV_Merge' incorporates:
     *  SignalConversion generated from: '<S4>/OutAirTemp_Est_AftDial_write'
     * */
    Rte_IrvWrite_THMR_PwrOn_OutAirTemp_Est_AftDial_write_IRV
        (THMR_ac_B.OutportBufferForOutAirTemp_Est_);

    /* Merge: '<Root>/PropSysActv_AftDial_IRV_Merge' incorporates:
     *  SignalConversion generated from: '<S4>/PropSysActv_AftDial_write'
     * */
    Rte_IrvWrite_THMR_PwrOn_PropSysActv_THMR_AftDial_write_IRV
        (THMR_ac_B.OutportBufferForPropSysActv_Aft);

    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/PwrOn' */
}

/* Model initialize function */
FUNC(void, THMR_CODE) THMR_ac_Init(void)
{
    /* Registration code */

    /* block I/O */
    {
        THMR_ac_B.OutportBufferForVeTHMR_e_LTCLTh = CeTHMR_e_LTCLBalancing;
        THMR_ac_B.VeTHMR_e_LTCLThrmlMode = CeTHMR_e_LTCLBalancing;
    }

    /* custom signals */
    VeTHMR_e_PwrLevSet_AD = CeOBCR_e_PwrLimReq_SNA;

    /* SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/PwrOn' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_PwrOn'
     */
    /* SystemInitialize for S-Function (fcgen): '<S4>/FcnCallGen' incorporates:
     *  SubSystem: '<S4>/InitHPCC'
     */
#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent

    /* SystemInitialize for Function Call SubSystem: '<S4>/FC_Loop_NF' */
    /* SystemInitialize for SignalConversion generated from: '<S5675>/FlowTgt_NF' incorporates:
     *  Constant: '<S5683>/Calib'
     */
    THMR_ac_B.OutportBufferForFlowTgt_NF = KeTHMR_dV_FC_ClntFlwtgt_NF;

    /* SystemInitialize for SignalConversion generated from: '<S5675>/Vlv_Pos_NF' incorporates:
     *  Constant: '<S5680>/Calib'
     */
    THMR_ac_B.OutportBufferForVlv_Pos_NF = KeTHMR_Pct_FC_VlvPosReq_NF;

    /* End of SystemInitialize for SubSystem: '<S4>/FC_Loop_NF' */
    /* End of SystemInitialize for S-Function (fcgen): '<S4>/FcnCallGen' */
#endif

    /* SystemInitialize for S-Function (fcgen): '<S4>/FcnCallGen' incorporates:
     *  SubSystem: '<S4>/Sub_Out_Init'
     */
    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_ClntPmpState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const9'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_ClntPm = THMR_ac_ConstB.Const9;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_ClntNProp3WyVlv_State_Out_Init' incorporates:
     *  Constant: '<S5679>/Const14'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_ClntNP = THMR_ac_ConstB.Const14;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_ClntProp3WyVlv_State_Out_Init' incorporates:
     *  Constant: '<S5679>/Const15'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_ClntPr = THMR_ac_ConstB.Const15;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_RefShtoffVlv_State_Out_Init' incorporates:
     *  Constant: '<S5679>/Const17'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_RefSht = THMR_ac_ConstB.Const17;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_RadFan_State_Out_Init' incorporates:
     *  Constant: '<S5679>/Const19'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_RadFan = THMR_ac_ConstB.Const19;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_EmrgcyFanRq_Lvl_Out_Init' incorporates:
     *  Constant: '<S5679>/Const21'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_Emrgcy = THMR_ac_ConstB.Const21;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_EngOrBattPwrDschg_State_Out_Init' incorporates:
     *  Constant: '<S5679>/Const26'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_EngOrB = THMR_ac_ConstB.Const26;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_ThrmSysShtDwnFlt_Out_Init' incorporates:
     *  Constant: '<S5679>/Const31'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_ThrmSy = THMR_ac_ConstB.Const31;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_HV_Bat_CltLvlLo_Out_Init' incorporates:
     *  Constant: '<S5679>/Const40'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_HV_Bat = THMR_ac_ConstB.Const40;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_BatThrmlSt_Out_Init' incorporates:
     *  Constant: '<S5679>/Const41'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_BatThr = THMR_ac_ConstB.Const41;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_AC_CompState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const45'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_AC_Com = THMR_ac_ConstB.Const45;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_Eng_Htr_HTSOV_Stat_Out_Init' incorporates:
     *  Constant: '<S5679>/Const47'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_Eng_Ht = THMR_ac_ConstB.Const47;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_PPCTIS_OT_Out_Init' incorporates:
     *  Constant: '<S5679>/Const48'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_PPCTIS = THMR_ac_ConstB.Const48;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_VehThermSt_Out_Init' incorporates:
     *  Constant: '<S5679>/Const55'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_VehThe = THMR_ac_ConstB.Const55;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_HTCL_Heat_Distrib_Out_Init' incorporates:
     *  Constant: '<S5679>/Const62'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_HTCL_H = THMR_ac_ConstB.Const62;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_HVAC_PerfModeFlg_Out_Init' incorporates:
     *  Constant: '<S5679>/Const84'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_HVAC_P = THMR_ac_ConstB.Const84;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_SC_WkUp_Out_Init' incorporates:
     *  Constant: '<S5679>/Const88'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_SC_WkU = THMR_ac_ConstB.Const88;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_CabPrecondReqSt_Out_Init' incorporates:
     *  Constant: '<S5679>/Const89'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_CabPre = THMR_ac_ConstB.Const89;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_CabThermalMode_Out_Init' incorporates:
     *  Constant: '<S5679>/Const108'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_CabThe = THMR_ac_ConstB.Const108;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_CabHeatThermalState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const109'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_CabHea = THMR_ac_ConstB.Const109;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_CabCoolThermalState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const110'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_CabCoo = THMR_ac_ConstB.Const110;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_LTCLRadVlvState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const111'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_LTCLRa = THMR_ac_ConstB.Const111;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_LTCLThrmlMode_Out_Init' incorporates:
     *  Constant: '<S5679>/Const112'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_LTCLTh = THMR_ac_ConstB.Const112;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_EOP_A_EmrgCoolState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const124'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_EOP_A_ = THMR_ac_ConstB.Const124;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_EOP_B_EmrgCoolState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const125'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_EOP_B_ = THMR_ac_ConstB.Const125;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_r_HvHrnMtrAPowerLimit_Out_Init' incorporates:
     *  Constant: '<S5702>/Calib'
     */
    THMR_ac_B.OutportBufferForVeTHMR_r_HvHrnM = KeTHMR_r_HvHrnMtrAPowerLimit_NF;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_r_HvHrnMtrBPowerLimit_Out_Init' incorporates:
     *  Constant: '<S5703>/Calib'
     */
    THMR_ac_B.OutportBufferForVeTHMR_r_HvHr_k = KeTHMR_r_HvHrnMtrBPowerLimit_NF;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_r_HvHrnMtrCPowerLimit_Out_Init' incorporates:
     *  Constant: '<S5704>/Calib'
     */
    THMR_ac_B.OutportBufferForVeTHMR_r_HvHr_p = KeTHMR_r_HvHrnMtrCPowerLimit_NF;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_CabHeatThermalMode_Out_Init' incorporates:
     *  Constant: '<S5679>/Const133'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_CabH_a = THMR_ac_ConstB.Const133;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_e_FCThrmlState_Out_Init' incorporates:
     *  Constant: '<S5679>/Const140'
     */
    THMR_ac_B.OutportBufferForVeTHMR_e_FCThrm = THMR_ac_ConstB.Const140;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_b_REDMHeatEstm_SNAflag_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_b_REDMHe = true;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_b_FEDMHeatEstm_SNAflag_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_b_FEDMHe = true;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_I_ChargeCurrentLim_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_I_Charge = 99999.0F;

    /* SystemInitialize for SignalConversion generated from: '<S5679>/VeTHMR_Pct_HtrCoreBypssVlv_OutInit' */
    THMR_ac_B.OutportBufferForVeTHMR_Pct_HtrC = 100.0F;

    /* End of SystemInitialize for S-Function (fcgen): '<S4>/FcnCallGen' */
    /* End of SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/PwrOn' */

    /* SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/FastTEF' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_FastTEF'
     */
    /* SystemInitialize for S-Function (fcgen): '<S1>/FcnCallGen' incorporates:
     *  SubSystem: '<S1>/Subsystem2'
     */
    /* SystemInitialize for Enabled SubSystem: '<S20>/Subsystem2' */
    /* SystemInitialize for SignalConversion generated from: '<S30>/Out1' incorporates:
     *  Outport: '<S30>/Out1'
     */
    THMR_ac_B.OutportBufferForOut1_b = true;

    /* SystemInitialize for Gain: '<S31>/Gain' incorporates:
     *  Outport: '<S30>/Out2'
     */
    VeTHMR_T_EstAmbAirTemp_Raw_B4D = 25.0F;

    /* End of SystemInitialize for SubSystem: '<S20>/Subsystem2' */
    /* End of SystemInitialize for S-Function (fcgen): '<S1>/FcnCallGen' */
    /* End of SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/FastTEF' */

    /* SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' incorporates:
     *  SubSystem: '<Root>/THMR_FUNC_RU_MedTEH'
     */
    /* SystemInitialize for S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Charging_inputsignals'
     */
    /* SystemInitialize for Switch: '<S49>/Switch2' incorporates:
     *  Outport: '<S49>/PwrLevSet_AD'
     */
    VeTHMR_e_PwrLevSet_AD = CeOBCR_e_PwrLimReq_SNA;

    /* SystemInitialize for S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Cell_Min_Max_Temp_Used'
     */
    /* Start for If: '<S403>/If1' */
    THMR_ac_DW.If1_ActiveSubsystem = -1;

#if Rte_SysCon_Variant_THMR_FUNC_RU_Program_Selctd

    /* End of SystemInitialize for S-Function (fcgen): '<S2>/FcnCallGen' */
#endif

    /* SystemInitialize for S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Calibrations'
     */
    /* SystemInitialize for SignalConversion generated from: '<S45>/Out3' incorporates:
     *  Constant: '<S273>/Calib'
     */
    THMR_ac_B.OutportBufferForOut3 = KeTHMR_b_ThreeW_N_Prop_Valve2_Dial;

    /* SystemInitialize for SignalConversion generated from: '<S45>/Out4' incorporates:
     *  Constant: '<S274>/Calib'
     */
    THMR_ac_B.OutportBufferForOut4 = KeTHMR_b_ThreeW_N_Prop_Valve3_Dial;

    /* SystemInitialize for SignalConversion generated from: '<S45>/Out5' incorporates:
     *  Constant: '<S275>/Calib'
     */
    THMR_ac_B.VeTHMR_b_ThreeW_Prop_Valve2_Enb = KeTHMR_b_ThreeW_Prop_Valve2_Dial;

    /* SystemInitialize for SignalConversion generated from: '<S45>/Out6' incorporates:
     *  Constant: '<S276>/Calib'
     */
    THMR_ac_B.VeTHMR_b_ThreeW_Prop_Valve3_Enb = KeTHMR_b_ThreeW_Prop_Valve3_Dial;

    /* SystemInitialize for S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/LTCL'
     */
    /* Start for If: '<S2281>/LTCL_Valve_Pos1' */
    THMR_ac_DW.LTCL_Valve_Pos1_ActiveSubsystem = -1;

    /* Start for If: '<S2293>/LTCL_Valve_Pos_Dflt' */
    THMR_ac_DW.LTCL_Valve_Pos_Dflt_ActiveSubsy = -1;

    /* InitializeConditions for UnitDelay: '<S2281>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_jx = CeTHMR_e_LTCLBalancing;

    /* SystemInitialize for S-Function (fcgen): '<S62>/Function-CallGenerator' incorporates:
     *  SubSystem: '<S62>/FunctionCall'
     */
    /* SystemInitialize for S-Function (fcgen): '<S2288>/Function-CallGenerator1' incorporates:
     *  SubSystem: '<S62>/MBC_LTCL'
     */
    /* SystemInitialize for SignalConversion generated from: '<S2295>/LTCLFBLEnbl' incorporates:
     *  Constant: '<S3022>/Calib'
     */
    THMR_ac_B.OutportBufferForLTCLFBLEnbl = KeTHMR_b_LTCLFBLEnbl;

    /* End of SystemInitialize for S-Function (fcgen): '<S2288>/Function-CallGenerator1' */
    /* End of SystemInitialize for S-Function (fcgen): '<S62>/Function-CallGenerator' */

    /* SystemInitialize for SignalConversion generated from: '<S62>/LINVlvCalibr_Req' incorporates:
     *  Constant: '<S2313>/Calib'
     */
    THMR_ac_B.OutportBufferForLINVlvCalibr_Re = KeTHMR_b_LINPrplVlv_CalibReqOvrd;

    /* SystemInitialize for S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/HTCL'
     */
    /* Start for If: '<S1212>/If' */
    THMR_ac_DW.If_ActiveSubsystem = -1;

    /* Start for If: '<S1164>/CabinHeat_Rqst_and_CPV3_Position' */
    THMR_ac_DW.CabinHeat_Rqst_and_CPV3_Positio = -1;

    /* Start for If: '<S1470>/If' */
    THMR_ac_DW.If_ActiveSubsystem_c = -1;

    /* Start for If: '<S1163>/CabinHeat_Rqst_and_CPV3_Position' */
    THMR_ac_DW.CabinHeat_Rqst_and_CPV3_Posit_p = -1;

    /* SystemInitialize for IfAction SubSystem: '<S1470>/a' */
    /* Start for If: '<S1593>/If' */
    THMR_ac_DW.If_ActiveSubsystem_pu = -1;

    /* End of SystemInitialize for SubSystem: '<S1470>/a' */

    /* SystemInitialize for IfAction SubSystem: '<S1470>/b' */
    /* Start for If: '<S1600>/If' */
    THMR_ac_DW.If_ActiveSubsystem_cq = -1;

    /* End of SystemInitialize for SubSystem: '<S1470>/b' */

    /* SystemInitialize for IfAction SubSystem: '<S1470>/c' */
    /* Start for If: '<S1607>/If' */
    THMR_ac_DW.If_ActiveSubsystem_a = -1;

    /* End of SystemInitialize for SubSystem: '<S1470>/c' */

    /* SystemInitialize for IfAction SubSystem: '<S1470>/d' */
    /* Start for If: '<S1614>/If' */
    THMR_ac_DW.If_ActiveSubsystem_n = -1;

    /* End of SystemInitialize for SubSystem: '<S1470>/d' */

    /* SystemInitialize for IfAction SubSystem: '<S1470>/f' */
    /* Start for If: '<S1647>/If' */
    THMR_ac_DW.If_ActiveSubsystem_o = -1;

    /* End of SystemInitialize for SubSystem: '<S1470>/f' */

    /* SystemInitialize for IfAction SubSystem: '<S1470>/g' */
    /* Start for If: '<S1655>/If' */
    THMR_ac_DW.If_ActiveSubsystem_l = -1;

    /* End of SystemInitialize for SubSystem: '<S1470>/g' */

    /* SystemInitialize for IfAction SubSystem: '<S1470>/h' */
    /* Start for If: '<S1662>/If' */
    THMR_ac_DW.If_ActiveSubsystem_i = -1;

    /* End of SystemInitialize for SubSystem: '<S1470>/h' */

    /* SystemInitialize for IfAction SubSystem: '<S1164>/HTR_nd_Vlv_fr_ActvPsv_Heating' */
    /* Start for If: '<S1997>/If' */
    THMR_ac_DW.If_ActiveSubsystem_d = -1;

    /* End of SystemInitialize for SubSystem: '<S1164>/HTR_nd_Vlv_fr_ActvPsv_Heating' */

    /* SystemInitialize for IfAction SubSystem: '<S1164>/HTR_nd_Vlv_fr_Actv_Heating' */
    /* Start for If: '<S2005>/If' */
    THMR_ac_DW.If_ActiveSubsystem_p = -1;

    /* End of SystemInitialize for SubSystem: '<S1164>/HTR_nd_Vlv_fr_Actv_Heating' */

    /* SystemInitialize for S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Subsystem__Subsystem1'
     */
    /* InitializeConditions for UnitDelay: '<S4709>/FixPt Unit Delay2' */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_l = 1U;

    /* InitializeConditions for UnitDelay: '<S4118>/UnitDelay7' */
    THMR_ac_DW.UnitDelay7_DSTATE_f = CeTHMR_e_LTCLBalancing;

    /* SystemInitialize for Merge: '<S4575>/Merge1' */
    THMR_ac_B.VeTHMR_e_LTCLThrmlMode = CeTHMR_e_LTCLBalancing;

#if Rte_SysCon_Variant_THMR_FUNC_RU_FCS_Absent0

    /* SystemInitialize for Function Call SubSystem: '<S2>/FC_Loop' */
    /* InitializeConditions for UnitDelay: '<S1034>/FixPt Unit Delay2' */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE = 1U;

    /* InitializeConditions for UnitDelay: '<S981>/Unit Delay2' */
    THMR_ac_DW.UnitDelay2_DSTATE_ec = 20.0F;

    /* InitializeConditions for UnitDelay: '<S1057>/FixPt Unit Delay2' */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_p = 1U;

    /* InitializeConditions for UnitDelay: '<S930>/FixPt Unit Delay2' */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_h = 1U;

    /* InitializeConditions for UnitDelay: '<S957>/Unit Delay1' */
    THMR_ac_DW.UnitDelay1_DSTATE_lf = 200.0F;

    /* InitializeConditions for UnitDelay: '<S1096>/FixPt Unit Delay2' */
    THMR_ac_DW.FixPtUnitDelay2_DSTATE_g = 1U;

    /* SystemInitialize for Enabled SubSystem: '<S816>/DeratePwr' */
    /* SystemInitialize for Outport: '<S833>/Output_Parameter' incorporates:
     *  Inport: '<S833>/Input_Parameter'
     */
    THMR_ac_B.Input_Parameter = 9000.0F;

    /* End of SystemInitialize for SubSystem: '<S816>/DeratePwr' */
    /* End of SystemInitialize for SubSystem: '<S2>/FC_Loop' */
    /* End of SystemInitialize for S-Function (fcgen): '<S2>/FcnCallGen' */
#endif

    /* SystemInitialize for S-Function (fcgen): '<S2>/FcnCallGen' incorporates:
     *  SubSystem: '<S2>/Fan_Shutt_Command'
     */
    /* SystemInitialize for SignalConversion generated from: '<S56>/AGS_State_AD' incorporates:
     *  Constant: '<S1132>/Calib'
     */
    THMR_ac_B.VeTHMR_b_AGS_State = KeTHMR_b_AGS_State_Dial;

    /* SystemInitialize for SignalConversion generated from: '<S56>/HCP_AGS_Req_AD' incorporates:
     *  Constant: '<S1131>/Calib'
     */
    THMR_ac_B.VeTHMR_Pct_HCP_AGS_Req = KeTHMR_Pct_HCP_AGS_Req_Dial;

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrAPI

    /* SystemInitialize for Function Call SubSystem: '<S2>/MotorA_Harness_Control' */
    /* InitializeConditions for UnitDelay: '<S3446>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_p = 1.0F;

    /* InitializeConditions for UnitDelay: '<S3465>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_au = 1.0F;

    /* End of SystemInitialize for SubSystem: '<S2>/MotorA_Harness_Control' */
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrBPI

    /* SystemInitialize for Function Call SubSystem: '<S2>/MotorB_Harness_Control' */
    /* InitializeConditions for UnitDelay: '<S3512>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_hp = 1.0F;

    /* InitializeConditions for UnitDelay: '<S3527>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_ai = 1.0F;

    /* End of SystemInitialize for SubSystem: '<S2>/MotorB_Harness_Control' */
#endif

#if Rte_SysCon_Variant_THMR_FUNC_RU_EnblMtrCPI

    /* SystemInitialize for Function Call SubSystem: '<S2>/MotorC_Harness_Control' */
    /* InitializeConditions for UnitDelay: '<S3585>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_hd = 1.0F;

    /* InitializeConditions for UnitDelay: '<S3559>/UnitDelay' */
    THMR_ac_DW.UnitDelay_DSTATE_nm = 1.0F;

    /* End of SystemInitialize for SubSystem: '<S2>/MotorC_Harness_Control' */
    /* End of SystemInitialize for S-Function (fcgen): '<S2>/FcnCallGen' */
#endif

    /* End of SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_ClntPmpState' incorporates:
     *  Merge: '<Root>/Merge_Outport_9'
     */
    (void)Rte_Write_VeTHMR_e_ClntPmpState_Value(CeTHMR_e_NoPump_On);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_ClntNProp3WyVlv_State' incorporates:
     *  Merge: '<Root>/Merge_Outport_14'
     */
    (void)Rte_Write_VeTHMR_e_ClntNProp3WyVlv_State_Value(CeTHMR_e_NoVlvPwrd);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_ClntProp3WyVlv_State' incorporates:
     *  Merge: '<Root>/Merge_Outport_15'
     */
    (void)Rte_Write_VeTHMR_e_ClntProp3WyVlv_State_Value(CeTHMR_e_NoVlvPwrd);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_RefShtoffVlv_State' incorporates:
     *  Merge: '<Root>/Merge_Outport_17'
     */
    (void)Rte_Write_VeTHMR_e_RefShtoffVlv_State_Value(CeTHMR_e_AllOpen);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_RadFan_State' incorporates:
     *  Merge: '<Root>/Merge_Outport_19'
     */
    (void)Rte_Write_VeTHMR_e_RadFan_State_Value(CeFSCR_e_RadFan_OFF);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_EmrgcyFanRq_Lvl' incorporates:
     *  Merge: '<Root>/Merge_Outport_21'
     */
    (void)Rte_Write_VeTHMR_e_EmrgcyFanRq_Lvl_Value(CeTHMR_e_No_EmrgcyFanRq);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_EngOrBattPwrDschg_State' incorporates:
     *  Merge: '<Root>/Merge_Outport_26'
     */
    (void)Rte_Write_VeTHMR_e_EngOrBattPwrDschg_State_Value(CePDTR_e_No_Dischrg);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_ThrmSysShtDwnFlt' incorporates:
     *  Merge: '<Root>/Merge_Outport_31'
     */
    (void)Rte_Write_VeTHMR_e_ThrmSysShtDwnFlt_Value(CeSRAR_e_NoFlt);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_HV_Bat_CltLvlLo' incorporates:
     *  Merge: '<Root>/Merge_Outport_40'
     */
    (void)Rte_Write_VeTHMR_e_HV_Bat_CltLvlLo_Value(CeBRDR_e_BatCltLvlNotLo);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_BatThrmlSt' incorporates:
     *  Merge: '<Root>/Merge_Outport_41'
     */
    (void)Rte_Write_VeTHMR_e_BatThrmlSt_Value(CeTHMR_e_NoConditioning);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_AC_CompState' incorporates:
     *  Merge: '<Root>/Merge_Outport_45'
     */
    (void)Rte_Write_VeTHMR_e_AC_CompState_Value(CeTHMR_e_ACOff);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_Eng_Htr_HTSOV_Stat' incorporates:
     *  Merge: '<Root>/Merge_Outport_47'
     */
    (void)Rte_Write_VeTHMR_e_Eng_Htr_HTSOV_Stat_Value(CeTHMR_e_NoStateSlctd);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_PPCTIS_OT' incorporates:
     *  Merge: '<Root>/Merge_Outport_48'
     */
    (void)Rte_Write_VeTHMR_e_PPCTIS_OT_Value(CeTHMR_e_EmergencyLevel4);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_VehThermSt' incorporates:
     *  Merge: '<Root>/Merge_Outport_55'
     */
    (void)Rte_Write_VeTHMR_e_VehThermSt_Value(CeTHMR_e_TempAllowNormalDrive);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_HTCL_Heat_Distrib' incorporates:
     *  Merge: '<Root>/Merge_Outport_62'
     */
    (void)Rte_Write_VeTHMR_e_HTCL_Heat_Distrib_Value(CeTHMR_e_NoHeating);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_HCP_LTP_FanAftRun_Rq' incorporates:
     *  Merge: '<Root>/Merge_15'
     */
    (void)Rte_Write_VeTHMR_e_HCP_LTP_FanAftRun_Rq_Value
        (CeTMIR_e_No_AftRunRequest);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_HVAC_PerfModeFlg' incorporates:
     *  Merge: '<Root>/Merge_Outport_85'
     */
    (void)Rte_Write_VeTHMR_e_HVAC_PerfModeFlg_Value(CeTHMR_e_NormalMode);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_SC_WkUp' incorporates:
     *  Merge: '<Root>/Merge_Outport_89'
     */
    (void)Rte_Write_VeTHMR_e_SC_WkUp_Value(CeTPCR_e_SC_NotAwake);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_CabPrecondReqSt' incorporates:
     *  Merge: '<Root>/Merge_Outport_90'
     */
    (void)Rte_Write_VeTHMR_e_CabPrecondReqSt_Value(CeTPCR_e_CabinPrec_Dflt);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_CabThermalMode' incorporates:
     *  Merge: '<Root>/Merge_Outport_109'
     */
    (void)Rte_Write_VeTHMR_e_CabThermalMode_Value(CeTHMR_e_Cab_NoConditioning);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_CabHeatThermalState' incorporates:
     *  Merge: '<Root>/Merge_Outport_110'
     */
    (void)Rte_Write_VeTHMR_e_CabHeatThermalState_Value(CeTHMR_e_NoCabinHeating);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_CabCoolThermalState' incorporates:
     *  Merge: '<Root>/Merge_Outport_111'
     */
    (void)Rte_Write_VeTHMR_e_CabCoolThermalState_Value(CeTHMR_e_NoCabinCooling);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_LTCLRadVlvState' incorporates:
     *  Merge: '<Root>/Merge_Outport_112'
     */
    (void)Rte_Write_VeTHMR_e_LTCLRadVlvState_Value(CeTHMR_e_Balancing_LTCLVlvSt);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_LTCLThrmlMode' incorporates:
     *  Merge: '<Root>/Merge_Outport_113'
     */
    (void)Rte_Write_VeTHMR_e_LTCLThrmlMode_Value(CeTHMR_e_LTCLBalancing);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_EOP_A_EmrgCoolState' incorporates:
     *  Merge: '<Root>/Merge_Outport_125'
     */
    (void)Rte_Write_VeTHMR_e_EOP_A_EmrgCoolState_Value
        (CeTHMR_e_OilPumpEmrgCool_OFF);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_EOP_B_EmrgCoolState' incorporates:
     *  Merge: '<Root>/Merge_Outport_126'
     */
    (void)Rte_Write_VeTHMR_e_EOP_B_EmrgCoolState_Value
        (CeTHMR_e_OilPumpEmrgCool_OFF);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_CabHeatThermalMode' incorporates:
     *  Merge: '<Root>/Merge_Outport_134'
     */
    (void)Rte_Write_VeTHMR_e_CabHeatThermalMode_Value(CeTHMR_e_NoActvHeat);

    /* SystemInitialize for Outport: '<Root>/VeTHMR_e_FCThrmlState' incorporates:
     *  Merge: '<Root>/Merge_Outport_141'
     */
    (void)Rte_Write_VeTHMR_e_FCThrmlState_Value(CeTHMR_e_FCCondOff);
}

/*
 * File trailer for generated code.
 *
 * [EOF]
 */
