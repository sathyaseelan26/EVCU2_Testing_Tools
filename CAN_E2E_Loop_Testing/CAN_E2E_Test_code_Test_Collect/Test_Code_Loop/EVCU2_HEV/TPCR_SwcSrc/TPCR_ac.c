/*
 * File: TPCR_ac.c
 *
 * Code generated for Simulink model 'TPCR_ac'.
 *
 * Model version                  : 9.502
 * Simulink Coder version         : 9.4 (R2020b) 29-Jul-2020
 * C/C++ source code generated on : Fri Apr  5 19:50:18 2024
 *
 * Target selection: autosar.tlc
 * Embedded hardware selection: Freescale->MPC55xx
 * Emulation hardware selection:
 *    Differs from embedded hardware (Generic->MATLAB Host Computer)
 * Code generation objectives: Unspecified
 * Validation result: Not run
 */

#include "TPCR_ac.h"
#include "look1_iflf_binlcapw.h"
#include "look2_iflf_binlcapw.h"

/* user code (top of source file) */
/*
   PRODUCTION CONFIGURATION
 */

/* Exported data definition */
#define START_SEC_CALIB_UNSPECIFIED_TPCR
#include "MemMap.h"

/* Definition for custom storage class: FCALocalParameter */
#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeTPCR_e_CabinPreCondReqStat, TPCR_VAR_INIT)
    KaTPCR_e_CabPrecReqStMap[16] =
{
    CeTPCR_e_CabinPrec_Dflt, CeTPCR_e_NoCabPrec_HV_BatCondStop,
    CeTPCR_e_NoCabPrec_HV_BatCondCmplt, CeTPCR_e_NoCabPrec_NotPlugged,
    CeTPCR_e_NoCabPrec_SOC, CeTPCR_e_OkCabinPrec, CeTPCR_e_CabinPrec_SP_Reached,
    CeTPCR_e_CabinPrec_Off, CeTPCR_e_NoCabPrec_Flts,
    CeTPCR_e_NoCabPrec_HV_BatCrit, CeTPCR_e_CabinPrec_Dflt,
    CeTPCR_e_CabinPrec_Dflt, CeTPCR_e_CabinPrec_Dflt, CeTPCR_e_CabinPrec_Dflt,
    CeTPCR_e_CabinPrec_Dflt, CeTPCR_e_NoCabPrec_SNA
};                                     /* Referenced by: '<S502>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint16, TPCR_VAR_INIT) KeTPCR_Cnt_PerWupDsblDly = 2U;/* Referenced by: '<S1497>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint16, TPCR_VAR_INIT) KeTPCR_Cnt_SCWakeUp_Dly = 1U;/* Referenced by: '<S875>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint16, TPCR_VAR_INIT) KeTPCR_Cnt_SOCRej_DlyVal = 3U;/* Referenced by: '<S1180>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint16, TPCR_VAR_INIT) KeTPCR_Cnt_WakeUpChk_Dly = 5U;/* Referenced by: '<S1181>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint16, TPCR_VAR_INIT) KeTPCR_Cnt_Wp_ThrmlCond_Dflt = 10U;/* Referenced by:
                                                                      * '<S1034>/Calib'
                                                                      * '<S1465>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_E_BatteryCapacity =
    388800.0F;                         /* Referenced by: '<S811>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_I_RacePrepCurrentReq_D =
    0.0F;                              /* Referenced by: '<S1935>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_I_RacePrep_DefaultCurrent =
    300.0F;                            /* Referenced by: '<S788>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_I_RacePrep_MaxCurrent =
    700.0F;                            /* Referenced by: '<S789>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_I_RacePrep_MinCurrent =
    0.0F;                              /* Referenced by: '<S790>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_I_RacePrep_NoLimitCurrent =
    999.0F;                            /* Referenced by: '<S760>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_K_RacePrep_BattResistanceTemp = 0.0013F;/* Referenced by: '<S761>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_K_RacePrep_BatteryChargeCoeff = 0.000212F;/* Referenced by:
                                                      * '<S762>/Calib'
                                                      * '<S791>/Calib'
                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_K_RacePrep_BatteryDischargeCoeff = 0.000212F;/* Referenced by: '<S812>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_K_RacePrep_BatteryThermalCoeff = 362320.0F;/* Referenced by:
                                                       * '<S763>/Calib'
                                                       * '<S792>/Calib'
                                                       */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_K_RacePrep_HeatTransferCoeff = 210.0F;/* Referenced by:
                                                  * '<S778>/Calib'
                                                  * '<S826>/Calib'
                                                  */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_P_DCChargingStation = 50.0F;/* Referenced by: '<S725>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_P_LowPwrBdgt_BattCond =
    0.0F;                              /* Referenced by:
                                        * '<S30>/Calib'
                                        * '<S1703>/Calib'
                                        * '<S1577>/Calib'
                                        * '<S1675>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_P_LowPwrBdgt_PCC_CabCond =
    0.0F;                              /* Referenced by: '<S560>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_P_NoChargingStation =
    630.0F;                            /* Referenced by: '<S726>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_P_NoPlugIn_PwrBdgtAllowCabCond_Max = 1500.0F;/* Referenced by: '<S939>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_P_NoPlugIn_PwrBdgtAllowCabCond_Min = 1000.0F;/* Referenced by: '<S940>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_P_PlugIn_PwrBdgtAllowCabCond_Max = 1500.0F;/* Referenced by: '<S942>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_P_PlugIn_PwrBdgtAllowCabCond_Min = 1000.0F;/* Referenced by: '<S943>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_P_PwrBdgtAvail_D = 0.0F;/* Referenced by: '<S1818>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_P_PwrBdgtMax = 200.0F;/* Referenced by: '<S963>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_P_PwrBdgtMin = 200.0F;/* Referenced by: '<S964>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_P_RacePrep_HeatPowerMax =
    -2000.0F;                          /* Referenced by: '<S827>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_P_RacePrep_HeatPowerMin =
    -10000.0F;                         /* Referenced by: '<S828>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_P_ThrmlPwrBdgtAvail_D =
    0.0F;                              /* Referenced by: '<S1819>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_BattPriority_SOCMax =
    50.0F;                             /* Referenced by: '<S948>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_BattPriority_SOCMin =
    45.0F;                             /* Referenced by: '<S949>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_CmftEnbl_SOCMax = 20.0F;/* Referenced by: '<S561>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_CmftEnbl_SOCMin = 20.0F;/* Referenced by: '<S562>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_HV_BatSOC_D = 0.0F;/* Referenced by: '<S1807>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_HotEnbl_SOCMax = 20.0F;/* Referenced by: '<S563>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_HotEnbl_SOCMin = 20.0F;/* Referenced by: '<S564>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_KHC_SOCMax = 60.0F;/* Referenced by: '<S565>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_KHC_SOCMin = 50.0F;/* Referenced by: '<S566>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_PerWup_SOCMax = 60.0F;/* Referenced by: '<S997>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_PerWup_SOCMin = 50.0F;/* Referenced by: '<S998>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_PlugLvl1BattCondSOCHys =
    2.0F;                              /* Referenced by: '<S911>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_Pct_PlugLvl1BattCondSOCThrshd = 35.0F;/* Referenced by: '<S912>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_PlugLvl1SOCHys = 2.0F;/* Referenced by: '<S919>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_PlugLvl1SOCThrshd =
    20.0F;                             /* Referenced by: '<S920>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_PlugLvl2BattCondSOCHys =
    2.0F;                              /* Referenced by: '<S927>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_Pct_PlugLvl2BattCondSOCThrshd = 35.0F;/* Referenced by: '<S928>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_PlugLvl2SOCHys = 2.0F;/* Referenced by: '<S935>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_PlugLvl2SOCThrshd =
    20.0F;                             /* Referenced by: '<S936>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_Pct_PreCond_CabNoPlugInSOC_Max = 5.0F;/* Referenced by: '<S899>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_Pct_PreCond_CabNoPlugInSOC_Min = 1.0F;/* Referenced by: '<S900>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_Pct_PreCond_CabPlugInSOC_Max = 5.0F;/* Referenced by: '<S903>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_Pct_PreCond_CabPlugInSOC_Min = 1.0F;/* Referenced by: '<S904>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_RacePrep_SOCTrgt_Dial =
    0.0F;                              /* Referenced by: '<S1923>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_SOCMax = 20.0F;/* Referenced by: '<S965>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_SOCMin = 20.0F;/* Referenced by: '<S966>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_TrackSOCHys = 2.0F;/* Referenced by: '<S862>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_TrackSOCTgt = 90.0F;/* Referenced by:
                                                                      * '<S764>/Calib'
                                                                      * '<S793>/Calib'
                                                                      * '<S863>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_UnplugBattCondSOCHys =
    2.0F;                              /* Referenced by: '<S972>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_UnplugBattCondSOCThrshd
    = 35.0F;                           /* Referenced by: '<S973>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_UnplugSOCTh = 20.0F;/* Referenced by: '<S978>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_Pct_UnplugSOCTh_Hys = 2.0F;/* Referenced by: '<S979>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_R_RacePrep_BattResistanceParam = 0.0904F;/* Referenced by:
                                                     * '<S765>/Calib'
                                                     * '<S794>/Calib'
                                                     */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_BatThrmlCond_HighAmbTemp =
    40.0F;                             /* Referenced by: '<S999>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_BatThrmlCond_LowAmbTemp =
    1.0F;                              /* Referenced by: '<S1000>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_BattCritThMax = 25.0F;/* Referenced by:
                                                                      * '<S1483>/Calib'
                                                                      * '<S1742>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_BattCritThMax_CabPrecOff =
    25.0F;                             /* Referenced by: '<S248>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_BattCritThMin = 23.0F;/* Referenced by:
                                                                      * '<S1484>/Calib'
                                                                      * '<S1743>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_BattCritThMin_CabPrecOff =
    26.0F;                             /* Referenced by: '<S249>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_CabTemp_SetPt_Dial = 0.0F;/* Referenced by: '<S1931>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_CabTemp_SetPt_NFDial =
    0.0F;                              /* Referenced by: '<S1952>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_CabinSP_D = 22.0F;/* Referenced by: '<S1813>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_CellMaxAllwd_Dial = 0.0F;/* Referenced by: '<S1850>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_ColdAmbTh_PerWkup = 0.0F;/* Referenced by: '<S1512>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_DsblEngCond_EngTmpTgt =
    -99.0F;                            /* Referenced by: '<S1650>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_EngClntTmp_Out_Dial =
    0.0F;                              /* Referenced by: '<S1783>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_HotAmbTh_PerWkup = 35.0F;/* Referenced by: '<S1513>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_MaxAmb_Thrshld_RacePrep =
    32.0F;                             /* Referenced by: '<S836>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_MinAmb_Thrshld_RacePrep =
    0.0F;                              /* Referenced by: '<S837>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_PerWpCond_BatTempFin =
    -20.0F;                            /* Referenced by: '<S1598>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_PerWpCond_BatTempFinHot =
    40.0F;                             /* Referenced by: '<S1535>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_PerWpCond_BatTmpErr_Dial =
    0.0F;                              /* Referenced by: '<S1892>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_PerWpCond_EngTempFin =
    -25.0F;                            /* Referenced by: '<S1599>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_PerWpCond_EngTmpErr_Dial =
    0.0F;                              /* Referenced by: '<S1890>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_PerWp_BatTmpTgt_Dflt =
    -99.0F;                            /* Referenced by: '<S1600>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_PerWp_Bat_OOO_TmpMax =
    65.0F;                             /* Referenced by: '<S1536>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_PerWp_Bat_OOO_TmpMin =
    -40.0F;                            /* Referenced by: '<S1601>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_PerWp_EngTmpTgt_Dflt =
    -99.0F;                            /* Referenced by: '<S1602>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_PerWp_Eng_OOO_TmpMin =
    -40.0F;                            /* Referenced by: '<S1603>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_PerWup_AmbTempThrsld =
    -2.0F;                             /* Referenced by: '<S1001>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_PerWup_AmbTempThrsldHot =
    35.0F;                             /* Referenced by: '<S1002>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_ProactiveCoolSPR_Max =
    31.0F;                             /* Referenced by: '<S727>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_ProactiveCoolSPR_Min =
    29.0F;                             /* Referenced by: '<S728>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_ProactiveHeatSPR_Max =
    26.0F;                             /* Referenced by: '<S729>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_ProactiveHeatSPR_Min =
    24.0F;                             /* Referenced by: '<S730>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_RPM_TrgtBattCoolntDiff =
    -18.0F;                            /* Referenced by: '<S829>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_T_RSDniedWkUp_TimeOutCellTmp = -28.0F;/* Referenced by: '<S1704>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_T_RSDniedWkUp_TimeOutCellTmpHot = 54.0F;/* Referenced by: '<S1705>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_RS_BCC_CellTemp_Min =
    -23.0F;                            /* Referenced by: '<S76>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_T_RacePrep_CurrentLim_NFdial = 0.0F;/* Referenced by: '<S1953>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_RacePrep_DragCoolingHys =
    2.0F;                              /* Referenced by: '<S813>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_RacePrep_DragHeatingHys =
    2.0F;                              /* Referenced by: '<S814>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_RacePrep_DragThrmlTgt =
    18.0F;                             /* Referenced by: '<S815>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_T_RacePrep_MinBatteryCoolantDiff = 5.0F;/* Referenced by: '<S779>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_T_RacePrep_ModulOverTmp_NFdial = 0.0F;/* Referenced by: '<S1954>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_T_RacePrep_ModulUnderTmp_NFdial = 0.0F;/* Referenced by: '<S1955>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_RacePrep_OverTmp_Dial =
    0.0F;                              /* Referenced by: '<S1919>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_RacePrep_SOCTrgt_NFdial =
    0.0F;                              /* Referenced by: '<S1956>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_RacePrep_ThrmlTrgt_Dial =
    0.0F;                              /* Referenced by: '<S1929>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_RacePrep_ThrmlTrgt_NFdial
    = 0.0F;                            /* Referenced by: '<S1957>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_RacePrep_TrackCoolingHys =
    2.0F;                              /* Referenced by: '<S864>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_RacePrep_TrackHeatingHys =
    2.0F;                              /* Referenced by: '<S865>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_RacePrep_TrackThrmlTgt =
    10.0F;                             /* Referenced by:
                                        * '<S766>/Calib'
                                        * '<S795>/Calib'
                                        * '<S866>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_RacePrep_UnderTmp_Dial =
    0.0F;                              /* Referenced by: '<S1921>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_ThrmlWkUp_TimeOutCellTmp =
    -28.0F;                            /* Referenced by: '<S1676>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_T_ThrmlWkUp_TimeOutCellTmpHot = 54.0F;/* Referenced by: '<S1578>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_T_ThrmlWkUp_TimeOutECTTmp =
    -28.0F;                            /* Referenced by: '<S1677>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_12VPWup_D = 0;/* Referenced by: '<S1842>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_12VPWup_SD = 0;/* Referenced by: '<S1843>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_AmbTempCheck_D = 0;/* Referenced by: '<S1917>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_AmbTempCheck_NFdial = 0;/* Referenced by: '<S1958>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_AmbTempCheck_SD = 0;/* Referenced by: '<S1918>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_AmbTmpFAChk_NoWUpFrstTmrSet = 1;/* Referenced by: '<S1047>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_AmbTmpFAChk_ShipDfltTimr =
    1;                                 /* Referenced by: '<S1073>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_AmbTmpFAChk_WUpWaitBatCond = 1;/* Referenced by: '<S1485>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_BCMPreCondCabReq_SD = 0;/* Referenced by: '<S1805>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_BCMPreCondCabinReq_Dial =
    0;                                 /* Referenced by: '<S1790>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_BCMPreCondCabinReq_SelDial = 0;/* Referenced by: '<S1791>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_BEV_BattCondCheck = 0;/* Referenced by: '<S77>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_BatCntctrStat_SelDial = 0;/* Referenced by: '<S1824>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_BatCritMsg3_NFdial = 0;/* Referenced by: '<S1959>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_BatPerWU_ThrmlCond_Timer_SD = 0;/* Referenced by: '<S1898>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_BattHtrLOC_FA_D = 0;/* Referenced by: '<S1832>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_BattHtrLOC_FA_SD = 0;/* Referenced by: '<S1833>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_BattHtr_LOC_SD = 0;/* Referenced by: '<S1834>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_BattPrioritySOCRejct = 0;/* Referenced by: '<S883>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_CabPrecDny_BattCond_Dial =
    0;                                 /* Referenced by: '<S1904>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_CabPrecDny_BattCond_NFdial = 0;/* Referenced by: '<S1960>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_CabPrecDny_BattCond_SD =
    0;                                 /* Referenced by: '<S1905>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_CabPrecondAny_Fault = 0;/* Referenced by: '<S392>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_CabPrecondAny_Flt_SD = 0;/* Referenced by: '<S393>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_CabReqMsg_SD = 0;/* Referenced by: '<S1913>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_CabTemp_SetPt_SD = 0;/* Referenced by: '<S1932>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_CabinPreCondReqStat_SD =
    0;                                 /* Referenced by: '<S1939>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_CabinSPSlct = 0;/* Referenced by: '<S1814>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_CabinSP_SD = 1;/* Referenced by: '<S1815>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_CellMaxAllwd_SelDial = 0;/* Referenced by: '<S1851>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ChargingSts_SD = 0;/* Referenced by: '<S1809>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ChrgFltDisPerWup_Dsbl = 1;/* Referenced by: '<S1003>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ChrgSysFlt_Dial = 0;/* Referenced by: '<S1822>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ChrgSysFlt_SelDial = 0;/* Referenced by: '<S1823>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ClimateFail_D = 0;/* Referenced by: '<S1908>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ClimateFail_NFdial = 0;/* Referenced by: '<S1961>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ClimateFail_SD = 0;/* Referenced by: '<S1909>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ClimateScheduleOption_SD =
    0;                                 /* Referenced by: '<S1840>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ComfEnbl_KeyChk = 1;/* Referenced by: '<S527>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblBattCondChk = 1;/* Referenced by:
                                                                      * '<S913>/Calib'
                                                                      * '<S921>/Calib'
                                                                      * '<S929>/Calib'
                                                                      * '<S937>/Calib'
                                                                      * '<S974>/Calib'
                                                                      * '<S980>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblBattCritChk_ComfEnb =
    0;                                 /* Referenced by: '<S528>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblChrgSysFlt_BattCond =
    0;                                 /* Referenced by: '<S31>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblEngCond_PerWup = 0;/* Referenced by:
                                                                      * '<S1658>/Calib'
                                                                      * '<S1651>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblFltChk_ComfEnb = 0;/* Referenced by: '<S529>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblFltsChk_CabPrecNoPlug
    = 1;                               /* Referenced by: '<S168>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblFltsChk_CabPrecSOC =
    1;                                 /* Referenced by: '<S157>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblKeyChk_CabOff = 0;/* Referenced by: '<S218>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblKeyChk_PerWkUp = 0;/* Referenced by: '<S1486>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblKeyChk_RSDnyPerWkUp =
    1;                                 /* Referenced by: '<S1744>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_DsblPerWkUpChkRSDny_FirstTmr = 1;/* Referenced by: '<S1048>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblPerWkUpChk_FirstTmr =
    0;                                 /* Referenced by: '<S1049>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblPlugInChk_CabPrecSOC =
    1;                                 /* Referenced by: '<S158>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblPlugIn_PwrBdgtChk = 0;/* Referenced by: '<S944>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblPlugIn_SOCChk = 0;/* Referenced by: '<S905>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblRmtStrt_V2L = 1;/* Referenced by: '<S503>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblSOCChk_ComfEnb = 0;/* Referenced by: '<S530>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DsblScWkUp_BattPrio = 0;/* Referenced by: '<S950>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_AmbFA_PlugIn = 0;/* Referenced by: '<S1158>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_AmbFA_ShortTmr = 0;/* Referenced by: '<S1141>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Dsbl_BattCondChk_RSBattCmplt = 0;/* Referenced by: '<S180>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Dsbl_BattCondChk_RSBattCrit = 1;/* Referenced by: '<S133>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_BattCondChk_RSOK = 1;/* Referenced by: '<S112>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_BattCondChk_RSOff =
    1;                                 /* Referenced by: '<S188>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_BattCondChk_RSSPR =
    1;                                 /* Referenced by: '<S117>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_ClmSchOptn_LngTmr =
    1;                                 /* Referenced by: '<S1127>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_ClmSchOptn_ShtTmr =
    1;                                 /* Referenced by: '<S1142>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Dsbl_ClmSchOptn_ShtTmrPlugIn = 1;/* Referenced by: '<S1159>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_DepTmNoZero_PlugIn =
    0;                                 /* Referenced by: '<S1160>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_DepTmNoZero_ShrtTmr =
    0;                                 /* Referenced by: '<S1143>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_KeyStsChkPrec_LngTmr
    = 0;                               /* Referenced by: '<S1128>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_KeyStsChkPrec_PlugIn
    = 0;                               /* Referenced by: '<S1161>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Dsbl_KeyStsChkPrec_PrecNotSup = 0;/* Referenced by: '<S1182>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Dsbl_KeyStsChkPrec_ShrtTmr = 0;/* Referenced by: '<S1144>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_NotPlug_RSThrmlFlts =
    0;                                 /* Referenced by: '<S121>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_PrecMsg_DepTmChk = 0;/* Referenced by: '<S1183>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_RSReq_LngTmr = 0;/* Referenced by: '<S1129>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_RSReq_PlugIn = 0;/* Referenced by: '<S1162>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_RSReq_SOCNotOK = 0;/* Referenced by: '<S1184>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_RSReq_ShortTmr = 0;/* Referenced by: '<S1145>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_RSSNA_RSThrmlFlts =
    0;                                 /* Referenced by: '<S122>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_RdntBPCM_LOC = 1;/* Referenced by: '<S1363>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_RdntePTBusOff_Flt =
    1;                                 /* Referenced by:
                                        * '<S458>/Calib'
                                        * '<S1364>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_SCChk_LongTmr = 1;/* Referenced by: '<S1130>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_SCWkUp_LngTmr = 0;/* Referenced by: '<S1131>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_SCWkUp_PlugIn = 0;/* Referenced by: '<S1163>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_SCWkUp_SOCNotOK = 0;/* Referenced by: '<S1185>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_SCWkUp_ShortTmr = 0;/* Referenced by: '<S1146>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_SOCChk_PlugIn = 0;/* Referenced by: '<S1164>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_SOCChk_RSThrmlFlts =
    0;                                 /* Referenced by: '<S123>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Dsbl_SOCChk_ShortTmr = 0;/* Referenced by: '<S1147>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Dsbl_ShtDwnCmdChkPrec_LngTmr = 1;/* Referenced by: '<S1132>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Dsbl_ShtDwnCmdChkPrec_ShrtTmr = 0;/* Referenced by: '<S1148>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_DschrgSysSts_SD = 0;/* Referenced by: '<S1844>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ECT_Sgnl_Rcvd_D = 0;/* Referenced by: '<S1784>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ECT_Sgnl_Rcvd_SD = 0;/* Referenced by: '<S1785>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblAmbChk_ForBatTgtHot =
    1;                                 /* Referenced by: '<S1559>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_EnblAmbChk_ForBattEngCondSt = 0;/* Referenced by: '<S1645>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblAmbChk_ForBattTgt = 1;/* Referenced by: '<S1655>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblAmbChk_ForEngTgt = 1;/* Referenced by: '<S1652>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblAmbFA_SC = 0;/* Referenced by: '<S1118>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblBEV_SOCCond = 0;/* Referenced by: '<S884>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblBatSOC_PerWkUp = 1;/* Referenced by: '<S1004>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblBattCrit_KHC = 1;/* Referenced by: '<S618>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblBattPriority = 0;/* Referenced by: '<S951>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblCBCDropAbort = 1;/* Referenced by: '<S219>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblCabPrecStsChk_SCWkUp =
    1;                                 /* Referenced by: '<S876>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblCellOTChk_ShtDwnHot =
    0;                                 /* Referenced by: '<S1579>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblChngInDepTm_PlugIn =
    1;                                 /* Referenced by: '<S1186>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_EnblClmSchOptn_RstPrecNotSup = 1;/* Referenced by: '<S1187>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblContSCWkUp_BattCond =
    1;                                 /* Referenced by: '<S32>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblCoolFlts_BattCond = 0;/* Referenced by: '<S33>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_EnblDoorAjar_CabPrecOffChk = 0;/* Referenced by: '<S220>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblDoorAjar_KHC = 1;/* Referenced by: '<S624>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblECHTIS_AtPerWup = 1;/* Referenced by: '<S1694>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblEdge_CabPrecOff = 0;/* Referenced by: '<S189>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblFlts_BattCond = 0;/* Referenced by: '<S34>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblHVBatPWup_RSDnd = 1;/* Referenced by: '<S1083>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblHdAjar_BattCond = 1;/* Referenced by: '<S35>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_EnblHoodAjar_CabPrecOffChk = 1;/* Referenced by: '<S221>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblHoodAjar_KHC = 1;/* Referenced by: '<S632>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblKeyChk_BattCond = 1;/* Referenced by: '<S36>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblKeyOnChk_PlugIn = 1;/* Referenced by: '<S1188>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblKeyOnChk_ShortTmr = 1;/* Referenced by: '<S1149>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_EnblLongTmr_RstPrecFailLtch = 0;/* Referenced by: '<S1329>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblLowBattery_KHC = 1;/* Referenced by: '<S636>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblMsg3_RSBattCrit = 1;/* Referenced by: '<S275>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblNoPlugIn_SOCChk = 1;/* Referenced by: '<S901>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblOnUnavailable_KHC = 1;/* Referenced by: '<S696>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_EnblPlugIn_RstPrecFailLtch = 0;/* Referenced by: '<S1330>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblPlugIn_RstPrecNotSup =
    0;                                 /* Referenced by: '<S1189>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblPreCond_LongTmr = 1;/* Referenced by: '<S1133>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblPreCond_ShortTmr = 1;/* Referenced by: '<S1150>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_EnblPreCond_ShortTmrPlugIn = 0;/* Referenced by: '<S1165>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblProCond = 0;/* Referenced by: '<S731>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblRSCheck_FrstTmrRst =
    0;                                 /* Referenced by: '<S1050>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblRSCheck_FrstTmrSet =
    1;                                 /* Referenced by: '<S1051>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblRSCheck_PlugIn = 1;/* Referenced by: '<S1190>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblRSCheck_ShipDfltTimr =
    1;                                 /* Referenced by: '<S1074>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_EnblRSCheck_ShipDfltTimrRst = 0;/* Referenced by: '<S1075>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblRSCheck_ShortTmr = 1;/* Referenced by: '<S1151>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblRSDnd_PerWUp = 0;/* Referenced by: '<S1084>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblRSReq_BattCond = 0;/* Referenced by: '<S37>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblRSReq_PerWkup = 0;/* Referenced by:
                                                                      * '<S1487>/Calib'
                                                                      * '<S1498>/Calib'
                                                                      * '<S1745>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblRSTmr_AftrSC = 1;/* Referenced by: '<S256>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblRstDly = 1;/* Referenced by: '<S967>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblRstTrigMsg = 1;/* Referenced by: '<S504>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblSCCOvrlap = 1;/* Referenced by: '<S257>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblSCWkUp_PrecOff = 0;/* Referenced by: '<S222>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblSCWkUp_PrecOffRst = 1;/* Referenced by: '<S223>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_EnblShtDwnCheck_FrstTmrRst = 1;/* Referenced by: '<S1052>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblShtDwnCheck_PlugIn =
    1;                                 /* Referenced by: '<S1191>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_EnblShtDwnCheck_ShipDfltTimrRst = 1;/* Referenced by: '<S1076>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblShtDwnCheck_ShortTmr =
    1;                                 /* Referenced by: '<S1152>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblShtDwnChk = 0;/* Referenced by: '<S990>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblShtDwnChk_PerWupDsbl =
    1;                                 /* Referenced by: '<S1499>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblShtDwnChk_PlugInSOC =
    1;                                 /* Referenced by: '<S1166>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblShtDwnPerWupEnblBit =
    0;                                 /* Referenced by:
                                        * '<S1706>/Calib'
                                        * '<S1678>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_EnblShtDwnPerWupEnblBitHot = 0;/* Referenced by: '<S1580>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblTmOut_RSDniedWkUp = 1;/* Referenced by: '<S1707>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblTmOut_ThrmlWkUp = 1;/* Referenced by: '<S1679>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblTmrChk_CabPrecOff = 1;/* Referenced by: '<S258>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblTmrExp_SCWkUp = 0;/* Referenced by: '<S877>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblTrunkAjar_KHC = 1;/* Referenced by: '<S641>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EnblV2L_SCCRS_CabPrecOff =
    1;                                 /* Referenced by: '<S224>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_EnblWkUpTrig_RstPrecFailLtch = 0;/* Referenced by: '<S1331>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_12VPWup_LngTmr = 1;/* Referenced by: '<S1134>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_12VPWup_PlugIn = 1;/* Referenced by: '<S1167>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_12VPWup_ShrtTmr = 0;/* Referenced by: '<S1153>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_BCMPrecSNA = 0;/* Referenced by: '<S151>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_BHOS_Flt = 1;/* Referenced by: '<S1365>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_BTIS_Flt = 1;/* Referenced by: '<S1458>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_BTOS_Flt = 1;/* Referenced by: '<S1459>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_BattCond_RSOff = 1;/* Referenced by: '<S250>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_BattCool_Flt = 1;/* Referenced by: '<S1366>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_BattTmpCrit_Chk = 1;/* Referenced by:
                                                                      * '<S567>/Calib'
                                                                      * '<S594>/Calib'
                                                                      * '<S108>/Calib'
                                                                      * '<S619>/Calib'
                                                                      * '<S142>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_BtlClntLvlLo_Flt = 0;/* Referenced by: '<S1460>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_BtlSnsr_SG = 0;/* Referenced by: '<S1461>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_CANCOff_SNA = 0;/* Referenced by: '<S152>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_CEXV_LIN1BusFlt = 0;/* Referenced by: '<S403>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_CEXV_LIN2BusFlt = 0;/* Referenced by: '<S404>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_CEXV_LIN3BusFlt = 0;/* Referenced by: '<S405>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_CEXV_LOCRefFlt_CabPrec = 0;/* Referenced by: '<S406>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_CPV_ValveStuckClosed
    = 1;                               /* Referenced by: '<S1449>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_CPV_ValveStuckOpen =
    1;                                 /* Referenced by: '<S1450>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_CPV_ValveStuckOpenBypass = 1;/* Referenced by: '<S1451>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_CPV_ValveStuckOpen_HotSide = 1;/* Referenced by: '<S1452>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_CPV_ValveStuckSNA =
    1;                                 /* Referenced by: '<S1453>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_CabPrecAbortStore =
    0;                                 /* Referenced by: '<S1332>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_CabPrecDny_BattCond =
    1;                                 /* Referenced by: '<S1005>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_CabPrec_BattCondCmplt = 0;/* Referenced by: '<S181>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_CabPrec_BattCondStop
    = 0;                               /* Referenced by: '<S185>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_CabPrec_Off = 1;/* Referenced by: '<S190>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_ClmSchOptn_PrecNotSup = 0;/* Referenced by: '<S1192>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_CntctrOpen_CabPrecOff = 1;/* Referenced by: '<S225>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_CntctrOpen_KeyOffCabCond = 1;/* Referenced by: '<S568>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_ComfEnbl = 1;/* Referenced by: '<S531>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_CoolFlts_PerWkUpCondShtDwn = 1;/* Referenced by: '<S1581>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_DepTmSetChk_PrecDsbld = 0;/* Referenced by: '<S1193>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_ECHIn_Flt = 1;/* Referenced by: '<S1381>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_ECHOut_Flt = 1;/* Referenced by: '<S1382>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_ECHTIS_Flt = 1;/* Referenced by: '<S1383>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_ECH_CHtrPrfFlt_CabPrec = 0;/* Referenced by: '<S360>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_ECH_LIN1BusFlt_CabPrec = 0;/* Referenced by: '<S361>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_ECH_LIN1BusFlt_PerWup = 1;/* Referenced by: '<S1384>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_ECH_LIN2BusFlt_CabPrec = 0;/* Referenced by: '<S362>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_ECH_LIN2BusFlt_PerWup = 1;/* Referenced by: '<S1385>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_ECH_LIN3BusFlt_CabPrec = 0;/* Referenced by: '<S363>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_ECH_LIN3BusFlt_PerWup = 1;/* Referenced by: '<S1386>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_ECH_PerfFlt = 1;/* Referenced by: '<S1387>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_ECTChk_PerWkUpCondShtDwn = 1;/* Referenced by: '<S1680>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_EEXV_LIN1BusFlt = 0;/* Referenced by: '<S420>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_EEXV_LIN2BusFlt = 0;/* Referenced by: '<S421>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_EEXV_LIN3BusFlt = 0;/* Referenced by: '<S422>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_EEXV_LOC_ACRefVlvFlt
    = 0;                               /* Referenced by: '<S423>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_EEXV_LOC_Ref_TmpSnrFlt = 0;/* Referenced by: '<S424>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_EEXV_PressElctr_Flts
    = 0;                               /* Referenced by: '<S425>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_EEXV_PressSens_Flts =
    0;                                 /* Referenced by: '<S426>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_EEXV_TempElctr_Flts =
    0;                                 /* Referenced by: '<S427>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_EEXV_TempSens_Flts =
    0;                                 /* Referenced by: '<S428>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_EXV_PerfDiag_Flt = 0;/* Referenced by: '<S407>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_EXV_PressElctrFlt =
    0;                                 /* Referenced by: '<S1395>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_EXV_PressSensFlt = 0;/* Referenced by: '<S1396>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_EXV_TempElctrFlt = 0;/* Referenced by: '<S1397>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_EXV_TempSensFlt = 0;/* Referenced by: '<S1398>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_FOTA_CabPrecOff = 1;/* Referenced by: '<S226>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_FRSOV_STG = 1;/* Referenced by: '<S437>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_Flts_PerWkUpCondShtDwn = 0;/* Referenced by: '<S1681>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_HCBV_Stuck_Flt = 1;/* Referenced by: '<S373>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_HTAPDryRunFA_CabPrec
    = 1;                               /* Referenced by: '<S378>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_HTAPDryRunFA_Flt = 1;/* Referenced by: '<S1403>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_HTAPDryRun_Flt = 1;/* Referenced by: '<S1404>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_HTAPDryRun_FltCabPrec = 1;/* Referenced by: '<S379>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_HTAP_PerfFlt = 1;/* Referenced by: '<S1405>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_HTAP_PerfFlt_CabPrec
    = 1;                               /* Referenced by: '<S380>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_HTAP_TmpFlt = 1;/* Referenced by: '<S1388>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_HTAP_TmpFlt_CabPrec =
    1;                                 /* Referenced by: '<S364>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_HTCV_PinFlts = 0;/* Referenced by: '<S1416>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_HTCV_StckFlt = 0;/* Referenced by: '<S1417>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_HTLBV_Stuck_Open_PerWup = 1;/* Referenced by: '<S1421>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_HTLBV_Stuck_PerWup =
    1;                                 /* Referenced by: '<S1422>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_HTSOV_CabinPrec_StckFlts = 1;/* Referenced by: '<S365>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_HTSOV_PerWup_PinFlts
    = 1;                               /* Referenced by: '<S1423>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_HTSOV_PerWup_StckFlts = 1;/* Referenced by: '<S1424>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_HTSOV_PinFlts = 1;/* Referenced by: '<S1389>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_HTSOV_StkClose = 1;/* Referenced by: '<S1390>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_HotEnblReq = 0;/* Referenced by: '<S595>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_KeySt_SNA = 0;/* Referenced by: '<S153>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_LIN1BusOff_AC_CabPrec = 1;/* Referenced by: '<S415>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_LIN1BusOff_Flt_CabPrec = 1;/* Referenced by: '<S381>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_LIN1BusOff_Flt_PerWup = 1;/* Referenced by: '<S1406>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_LIN2BusOff_AC_CabPrec = 1;/* Referenced by: '<S416>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_LIN2BusOff_Flt = 1;/* Referenced by: '<S1407>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_LIN2BusOff_Flt_CabPrec = 1;/* Referenced by: '<S382>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_LIN3BusOff_AC_CabPrec = 1;/* Referenced by: '<S417>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_LIN3BusOff_Flt_CabPrec = 1;/* Referenced by: '<S383>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_LIN3BusOff_Flt_PerWup = 1;/* Referenced by: '<S1408>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_LOCBCM_SNA = 0;/* Referenced by: '<S154>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_LOC_ECH = 1;/* Referenced by: '<S1391>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_LOC_HTAP = 1;/* Referenced by: '<S1409>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_LOC_HTAP_CabPrec = 1;/* Referenced by: '<S384>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_LTAP_ClPmpFlt = 1;/* Referenced by: '<S1434>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_LTAP_LIN1BusFlt = 0;/* Referenced by: '<S1435>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_LTAP_LIN2BusFlt = 0;/* Referenced by: '<S1436>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_LTAP_LIN3BusFlt = 0;/* Referenced by: '<S1437>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_LTAP_OvSpFlt = 1;/* Referenced by: '<S1438>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_LTAP_PerfFlt = 1;/* Referenced by: '<S1439>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_LTAP_TmpFlt = 1;/* Referenced by: '<S1440>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_LoadShed_CabPrecOff =
    1;                                 /* Referenced by: '<S227>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_LoadShed_KeyOffCabCond = 1;/* Referenced by: '<S569>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_NoCabPrec_BattCrit =
    1;                                 /* Referenced by: '<S134>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_NoCabPrec_Flt = 1;/* Referenced by: '<S124>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_NoCabPrec_NoPlugIn =
    0;                                 /* Referenced by: '<S169>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_NoCabPrec_SOC = 1;/* Referenced by: '<S159>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_OEXV_LIN1BusFlt = 0;/* Referenced by: '<S438>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_OEXV_LIN2BusFlt = 0;/* Referenced by: '<S439>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_OEXV_LIN3BusFlt = 0;/* Referenced by: '<S440>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_OEXV_LOC_ACRefVlvFlt
    = 0;                               /* Referenced by: '<S441>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_OEXV_LOC_AC_TempSnr4Flt = 0;/* Referenced by: '<S442>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_OEXV_LOC_AC_TempSnr5Flt = 0;/* Referenced by: '<S443>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_OEXV_PressDiag_Flts =
    0;                                 /* Referenced by: '<S444>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_OEXV_PressElect_Flts
    = 0;                               /* Referenced by: '<S445>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_OEXV_PressSens_Flts =
    0;                                 /* Referenced by: '<S446>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_OkToPreCond_RS = 1;/* Referenced by:
                                                                      * '<S113>/Calib'
                                                                      * '<S118>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_PerWupThrml_RSOff =
    0;                                 /* Referenced by: '<S251>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_PlugInChkPrec_BattPrio = 1;/* Referenced by: '<S952>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_PlugInChkPrec_LngTmr
    = 1;                               /* Referenced by: '<S1135>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_PlugInChkPrec_NotSupp = 1;/* Referenced by: '<S1194>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_PrecDsbld = 1;/* Referenced by: '<S1195>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_PrecMsg_RSPlugInChk =
    1;                                 /* Referenced by: '<S170>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_PrecMsg_RSSOCChk = 1;/* Referenced by: '<S160>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_PrecMsg_WakeUpChk =
    1;                                 /* Referenced by: '<S1203>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_SCCActv = 1;/* Referenced by:
                                                                      * '<S11>/Calib'
                                                                      * '<S63>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_SCWkUp_RSDsbld = 0;/* Referenced by: '<S335>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_SCWkUp_RSDsbld_CabPrecOff = 1;/* Referenced by: '<S228>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_SCWkup_BattCrit = 0;/* Referenced by: '<S276>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_SOCCond = 1;/* Referenced by: '<S885>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_SOCCond_New = 1;/* Referenced by: '<S886>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_ShtDwnCmdChkPrec_NotSupp = 1;/* Referenced by: '<S1196>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_ShtDwnCmdChk_PlugIn =
    1;                                 /* Referenced by: '<S1168>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_ShtDwnCmd_BattPrio =
    1;                                 /* Referenced by: '<S953>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_Tgt_TfbChkPerWkupHot
    = 0;                               /* Referenced by: '<S1555>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_TurTlMd_CabPrecOff =
    0;                                 /* Referenced by: '<S229>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_Enbl_TurtleMd_KeyOffCabCond = 1;/* Referenced by: '<S570>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_VehOnBattCond = 1;/* Referenced by: '<S38>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Enbl_VehOnBattCond_SC = 1;/* Referenced by: '<S39>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EngClntTmp_Out_SelDial =
    0;                                 /* Referenced by: '<S1786>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EngCoolantTemp_FA_D = 0;/* Referenced by: '<S1787>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EngCoolantTemp_FA_SD = 0;/* Referenced by: '<S1788>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_EngOutOfFuelChk = 0;/* Referenced by: '<S945>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Engcnd_DisDebnc_RST = 1;/* Referenced by: '<S1659>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Engcnd_DisDebnc_RSTHot =
    1;                                 /* Referenced by: '<S1562>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_FOTAInstallType_SD = 0;/* Referenced by: '<S1802>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_FOTAMsgSlct = 1;/* Referenced by: '<S505>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_FOTAPerWup_Dsbl = 0;/* Referenced by: '<S1006>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_HCPShtDwnChk_WUpWaitBatCond = 0;/* Referenced by: '<S1488>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_HCPShutDwnCmd_D = 0;/* Referenced by: '<S1816>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_HCPShutDwnCmd_SD = 0;/* Referenced by: '<S1817>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_HVC_Heater2_Flt_D = 0;/* Referenced by: '<S1797>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_HVC_Heater2_Flt_SD = 0;/* Referenced by: '<S1798>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_HVC_Heater_Flt_D = 0;/* Referenced by: '<S1799>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_HVC_Heater_Flt_SD = 0;/* Referenced by: '<S1800>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_HV_BatSOC_SD = 0;/* Referenced by: '<S1808>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_HoodAjarDisPerWup_Enbl =
    0;                                 /* Referenced by: '<S1007>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_HotEnbl_KeyChk = 1;/* Referenced by: '<S596>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_HtrOrEAC_FltRawPrst_Dial =
    0;                                 /* Referenced by: '<S1894>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_HtrOrEAC_FltRawPrst_NFdial = 0;/* Referenced by: '<S1962>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_HtrOrEAC_FltRawPrst_SD =
    0;                                 /* Referenced by: '<S1895>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_KeepHotColdHMI_SD = 0;/* Referenced by: '<S1937>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_KeepHotColdSts_SD = 0;/* Referenced by: '<S1933>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_KeyOffCabCond_D = 0;/* Referenced by: '<S1946>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_KeyOffCabCond_NFdial = 0;/* Referenced by: '<S1963>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_KeyOffCabCond_SD = 0;/* Referenced by: '<S1947>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_LTAPLOC_FA_D = 0;/* Referenced by: '<S1836>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_LTAPLOC_FA_SD = 0;/* Referenced by: '<S1837>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_LTAP_LOC_SD = 0;/* Referenced by: '<S1838>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_NARmtStart_DsblSocChk = 0;/* Referenced by: '<S946>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_NoPrecMsg = 1;/* Referenced by: '<S1302>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_NoWUpHVBatPWup_FrstTmrSet
    = 1;                               /* Referenced by: '<S1053>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_NoWpBattCrit_ThrmlFltsChk
    = 1;                               /* Referenced by: '<S1085>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_NoWp_CabPrecBatCrit_S = 1;/* Referenced by: '<S1054>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_NoWp_Dflt_Msg2 = 0;/* Referenced by: '<S1035>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_NoWp_FirstTimSet_Msg2 = 1;/* Referenced by: '<S1058>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_NoWp_Ship_Msg2 = 0;/* Referenced by: '<S1088>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_NoWp_ShrtTim_Msg2 = 1;/* Referenced by: '<S1094>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_NoWp_ThrmlFltsChk = 1;/* Referenced by: '<S1055>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_NormalWp_Msg2 = 1;/* Referenced by:
                                                                      * '<S1521>/Calib'
                                                                      * '<S1543>/Calib'
                                                                      * '<S1612>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_OkayToPreCondCab_D = 0;/* Referenced by: '<S1811>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_OkayToPreCondCab_SD = 0;/* Referenced by: '<S1812>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_PMM_PowerMode_SD = 0;/* Referenced by: '<S1793>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_PerWpCond_BatTmpErr_SD =
    0;                                 /* Referenced by: '<S1893>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_PerWpCond_EngTmpErr_SD =
    0;                                 /* Referenced by: '<S1891>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_PerWupDsbl = 1;/* Referenced by: '<S1500>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_PerWupDsbl_Msg2 = 0;/* Referenced by: '<S1466>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_PerWupEnblChk_InPerWupDsbl = 1;/* Referenced by: '<S1501>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_PerWup_BatPlugShip = 0;/* Referenced by: '<S1077>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_PerWup_BattEngCond_St_SD =
    0;                                 /* Referenced by: '<S1944>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_PerWup_RdyForShtDwn = 1;/* Referenced by: '<S1008>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_PeriodWup_Msg2_Dial = 0;/* Referenced by: '<S1888>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_PeriodWup_Msg2_NFdial = 0;/* Referenced by: '<S1964>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_PeriodWup_Msg2_SD = 0;/* Referenced by: '<S1889>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_PrecTimer_SD = 0;/* Referenced by: '<S1896>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ProCondBattAllChk = 1;/* Referenced by: '<S732>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ProCondFAChkDsbl = 0;/* Referenced by: '<S733>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ProactiveCondMode_SD = 0;/* Referenced by: '<S1906>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ProactiveCondStat_SD = 0;/* Referenced by: '<S1948>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_PwrBdgtAvail_SD = 0;/* Referenced by: '<S1820>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RPMEVSystemStatus_D = 0;/* Referenced by: '<S1927>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RPMEVSystemStatus_NFDial =
    0;                                 /* Referenced by: '<S1965>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RPMEVSystemStatus_SD = 0;/* Referenced by: '<S1928>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RSA_BatCrit_Msg3_Dial = 0;/* Referenced by: '<S1910>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RSA_BatCrit_Msg3_SD = 0;/* Referenced by: '<S1911>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RSA_StrtVhclRq_Dum4BSG =
    0;                                 /* Referenced by: '<S1912>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RS_BCC_CellUnderTmpChk =
    1;                                 /* Referenced by: '<S78>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RS_BCC_EnblCellTmpMin = 0;/* Referenced by: '<S79>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RS_EnblBCCTmrChk = 1;/* Referenced by: '<S80>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RS_EnblBCS = 0;/* Referenced by: '<S81>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RU_Program_Selctd = 1;/* Referenced by: '<S1853>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RacePrepCurrentReq_SD = 0;/* Referenced by: '<S1936>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RacePrepState_SD = 0;/* Referenced by: '<S1915>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RacePrepSts_SD = 0;/* Referenced by: '<S1846>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RacePrep_CellTempAvgUsed =
    1;                                 /* Referenced by: '<S767>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RacePrep_DeacTime_SD = 0;/* Referenced by:
                                                                      * '<S1926>/Calib'
                                                                      * '<S1930>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RacePrep_MovingAvgPcool =
    0;                                 /* Referenced by:
                                        * '<S780>/Calib'
                                        * '<S830>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RacePrep_OverTmp_SD = 0;/* Referenced by: '<S1920>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RacePrep_PrecondEnable =
    1;                                 /* Referenced by: '<S768>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RacePrep_SD = 0;/* Referenced by: '<S1847>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RacePrep_SOCTrgt_SD = 0;/* Referenced by: '<S1924>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RacePrep_SOC_CurrentUsed =
    1;                                 /* Referenced by: '<S816>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RacePrep_UnderTmp_SD = 0;/* Referenced by: '<S1922>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RdyForShtDwnChk_SCWkUp =
    0;                                 /* Referenced by: '<S878>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RdyForShtDwn_D = 0;/* Referenced by: '<S1885>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RdyForShtDwn_Dum4BSG = 0;/* Referenced by: '<S1886>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RdyForShtDwn_NFdial = 0;/* Referenced by: '<S1966>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RdyForShtDwn_NoPrec = 1;/* Referenced by: '<S1303>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RdyForShtDwn_PerWUpDsbl =
    1;                                 /* Referenced by: '<S1467>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RdyForShtDwn_PrecDflt = 0;/* Referenced by: '<S1295>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RdyForShtDwn_PrecLongTmr =
    1;                                 /* Referenced by: '<S1213>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RdyForShtDwn_PrecShortTmr
    = 1;                               /* Referenced by: '<S1224>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_RdyForShtDwn_PrecShortTmr_PlugIn = 0;/* Referenced by: '<S1254>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_RdyForShtDwn_SD = 0;/* Referenced by: '<S1887>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_SCWakeUp_SD = 0;/* Referenced by: '<S1900>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_SelHtr3Sts_PerWkup = 1;/* Referenced by: '<S1795>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_SelOldCompFlts = 1;/* Referenced by: '<S399>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_SelOldHtrFlts = 1;/* Referenced by: '<S347>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_SelOldHtrSts = 0;/* Referenced by: '<S1796>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Sel_AmbTmpFirstTmr = 1;/* Referenced by: '<S1059>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Sel_AmbTmpFirstTmr_Hot =
    1;                                 /* Referenced by: '<S1060>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Sel_OldHeater_Flt = 0;/* Referenced by: '<S1801>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ShippingMode_SD = 0;/* Referenced by: '<S1830>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_ThrRdyShtdwn_CabPrecBatCmplt = 1;/* Referenced by: '<S306>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_ThrRdyShtdwn_CabPrecBatCrit = 0;/* Referenced by: '<S294>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ThrRdyShtdwn_CabPrecDflt =
    0;                                 /* Referenced by: '<S323>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ThrRdyShtdwn_CabPrecFail =
    1;                                 /* Referenced by: '<S302>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_ThrRdyShtdwn_CabPrecNoPlug = 1;/* Referenced by: '<S329>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ThrRdyShtdwn_CabPrecOff =
    1;                                 /* Referenced by: '<S314>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ThrRdyShtdwn_CabPrecOk =
    0;                                 /* Referenced by: '<S292>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ThrRdyShtdwn_CabPrecSNA =
    1;                                 /* Referenced by: '<S319>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ThrRdyShtdwn_CabPrecSOC =
    1;                                 /* Referenced by: '<S325>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ThrRdyShtdwn_CabPrecSPR =
    0;                                 /* Referenced by: '<S298>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ThrRdyShtdwn_CabPrecStp =
    1;                                 /* Referenced by: '<S310>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ThrmLoad_Shed_Dial = 0;/* Referenced by: '<S1826>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ThrmLoad_Shed_SelDial = 0;/* Referenced by: '<S1827>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ThrmPerWup_St_SD = 0;/* Referenced by: '<S1942>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_ThrmlPwrBdgtAvail_SD = 0;/* Referenced by: '<S1821>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_TimeToDeparture_SD = 0;/* Referenced by: '<S1902>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_TmpTgt_SelRaw = 1;/* Referenced by: '<S1627>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Use_RSActv = 0;/* Referenced by: '<S259>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_WpWaitBatCond_CabPrecBatCrit = 0;/* Referenced by: '<S1708>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_WpWaitBatCond_CabPrec_Dflt = 0;/* Referenced by: '<S1709>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_WpWaitBatCond_CabPrec_Off
    = 0;                               /* Referenced by: '<S1710>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT)
    KeTPCR_b_WpWaitBatCond_CellUnderTmpLess = 1;/* Referenced by: '<S1711>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Wp_CabPrecBatCrit_S = 1;/* Referenced by: '<S1086>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(boolean, TPCR_VAR_INIT) KeTPCR_b_Wp_RS_Msg2 = 0;/* Referenced by: '<S1727>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_cmp_BatTmpDecad_rate =
    0.005F;                            /* Referenced by: '<S1656>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_cmp_BatTmpDecad_rateHot =
    -0.005F;                           /* Referenced by: '<S1560>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_cmp_EngTmpDecad_rate =
    0.01F;                             /* Referenced by: '<S1653>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_cmp_VehSoakRate = 0.05F;/* Referenced by:
                                                                      * '<S1232>/Calib'
                                                                      * '<S1273>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_dT_BattCond_CellOT_Min =
    6.0F;                              /* Referenced by: '<S40>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_dT_BattCond_CellUnderTemp_Min = 18.0F;/* Referenced by: '<S41>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_dT_CabCondCellOT_BattCond =
    11.0F;                             /* Referenced by: '<S42>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_dT_CabCondCellTmp_BattCond =
    18.0F;                             /* Referenced by: '<S43>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_dT_DsblEngCond_EngTmpErr =
    0.0F;                              /* Referenced by: '<S1660>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_dT_PerWkUpBattErr = 0.0F;/* Referenced by:
                                                                      * '<S1036>/Calib'
                                                                      * '<S1061>/Calib'
                                                                      * '<S1095>/Calib'
                                                                      * '<S1468>/Calib'
                                                                      * '<S1712>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_dT_PerWpCond_BatTmpErr =
    1.0F;                              /* Referenced by: '<S1661>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_dT_PerWpCond_BatTmpErrHot =
    1.0F;                              /* Referenced by: '<S1563>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_dT_PerWpCond_BatTmpErr_NFdial = 0.0F;/* Referenced by: '<S1967>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_dT_PerWpCond_EngTmpErr =
    1.0F;                              /* Referenced by: '<S1662>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_dT_PerWpCond_EngTmpErr_NFdial = 0.0F;/* Referenced by: '<S1968>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_dT_PerWup_CellOverTemp_Min =
    0.0F;                              /* Referenced by: '<S1009>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_dT_PerWup_CellUnderTemp_Min
    = 0.0F;                            /* Referenced by: '<S1010>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_dT_RS_BCC_CellUnderTemp_Min
    = 18.0F;                           /* Referenced by: '<S82>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_dT_TimeOutCellOT_BattCond =
    17.0F;                             /* Referenced by: '<S44>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_dT_TimeOutCellTmp_BattCond =
    23.0F;                             /* Referenced by: '<S45>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_dT_WupWaitBatCond_CellOvrTemp_Min = 13.0F;/* Referenced by: '<S1713>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_dT_WupWaitBatCond_CellUnderTemp_Min = 18.0F;/* Referenced by: '<S1714>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TePLTR_e_BCMPreCondCabinReq, TPCR_VAR_INIT)
    KeTPCR_e_BCMPreCondCabReq_D = CePLTR_e_CPCDefault;/* Referenced by: '<S1806>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeHVTR_e_HV_BatCntctrStat, TPCR_VAR_INIT)
    KeTPCR_e_BatCntctrStat_Dial = CeHVTR_e_Closed;/* Referenced by: '<S1825>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeBPCR_e_LOC_BatClntHtr, TPCR_VAR_INIT)
    KeTPCR_e_BattHtr_LOC_D = CeBPCR_e_LOC_BatClntHtr_False;/* Referenced by: '<S1835>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeTPCR_e_CabinPreCondReqStat, TPCR_VAR_INIT)
    KeTPCR_e_CabReqMsg_Dial = CeTPCR_e_CabinPrec_Dflt;/* Referenced by: '<S1914>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(TeTPCR_e_CabinPreCondReqStat, TPCR_VAR_INIT)
    KeTPCR_e_CabReqSt_Msgs_NFDial = CeTPCR_e_CabinPrec_Dflt;/* Referenced by: '<S1969>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeTPCR_e_CabinPreCondReqStat, TPCR_VAR_INIT)
    KeTPCR_e_CabinPreCondReqStat_Dial = CeTPCR_e_CabinPrec_Dflt;/* Referenced by: '<S1940>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(TeTPCR_e_CabinPreCondReqStat, TPCR_VAR_INIT)
    KeTPCR_e_CabinPreCondReqStat_NFdial = CeTPCR_e_CabinPrec_Dflt;/* Referenced by: '<S1970>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeTPCR_e_CabinPreCondReqStat, TPCR_VAR_INIT)
    KeTPCR_e_CabinPrecondSts_Dial_Dum4BSG = CeTPCR_e_CabinPrec_Dflt;/* Referenced by: '<S1941>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeOBCR_e_ChargingSystemSts, TPCR_VAR_INIT)
    KeTPCR_e_ChargingSts_D = CeOBCR_e_NotCharging;/* Referenced by: '<S1810>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeCITR_e_SchAllow, TPCR_VAR_INIT)
    KeTPCR_e_ClimateScheduleOption_D = CeCITR_e_AnyTime;/* Referenced by: '<S1841>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeVTLR_e_DschrgSysSts, TPCR_VAR_INIT)
    KeTPCR_e_DschrgSysSts_D = CeVTLR_e_DschrgInactv;/* Referenced by: '<S1845>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeCITR_e_FOTA_Install_Type, TPCR_VAR_INIT)
    KeTPCR_e_FOTAInstallType_D = CeCITR_e_NoFOTA;/* Referenced by: '<S1803>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeTPCR_e_KeepHotCold, TPCR_VAR_INIT)
    KeTPCR_e_KeepHotColdHMI_D = CeTPCR_e_NoRequest;/* Referenced by: '<S1938>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(TeTPCR_e_KeepHotCold, TPCR_VAR_INIT)
    KeTPCR_e_KeepHotColdHMI_NFdial = CeTPCR_e_NoRequest;/* Referenced by: '<S1971>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeTPCR_e_KeepHotColdStatus, TPCR_VAR_INIT)
    KeTPCR_e_KeepHotColdSts_D = CeTPCR_e_NotActive;/* Referenced by: '<S1934>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(TeTPCR_e_KeepHotColdStatus, TPCR_VAR_INIT)
    KeTPCR_e_KeepHotColdSts_NFdial = CeTPCR_e_NotActive;/* Referenced by: '<S1972>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeBPCR_e_LOC_BCP, TPCR_VAR_INIT) KeTPCR_e_LTAP_LOC_D =
    CeBPCR_e_LOC_BCP_False;            /* Referenced by: '<S1839>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeSSDR_e_KeySts, TPCR_VAR_INIT)
    KeTPCR_e_PMM_PowerMode_Dial = CeSSDR_e_KeyOff;/* Referenced by: '<S1794>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(TeTPCR_e_PerWup_BattEngCond, TPCR_VAR_INIT)
    KeTPCR_e_PerWup_BattEngCondSt_NFdial = CeTPCR_e_NoneOfEngBatt_Cond;/* Referenced by: '<S1973>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeTPCR_e_PerWup_BattEngCond, TPCR_VAR_INIT)
    KeTPCR_e_PerWup_BattEngCond_St_Dial = CeTPCR_e_NoneOfEngBatt_Cond;/* Referenced by: '<S1945>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeTPCR_e_ProactiveCondMode, TPCR_VAR_INIT)
    KeTPCR_e_ProactiveCondMode_D = CeTPCR_e_NoProactiveCond;/* Referenced by: '<S1907>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(TeTPCR_e_ProactiveCondMode, TPCR_VAR_INIT)
    KeTPCR_e_ProactiveCondMode_NFdial = CeTPCR_e_NoProactiveCond;/* Referenced by: '<S1974>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeTPCR_e_ProactiveCondStatus, TPCR_VAR_INIT)
    KeTPCR_e_ProactiveCondStat_D = CeTPCR_e_ProactiveCondOff;/* Referenced by: '<S1949>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(TeTPCR_e_ProactiveCondStatus, TPCR_VAR_INIT)
    KeTPCR_e_ProactiveCondStat_NFdial = CeTPCR_e_ProactiveCondOff;/* Referenced by: '<S1975>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeTPCR_e_RacePrepState, TPCR_VAR_INIT)
    KeTPCR_e_RacePrepState_D = CeTPCR_e_NotRacePrep;/* Referenced by: '<S1916>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(TeTPCR_e_RacePrepState, TPCR_VAR_INIT)
    KeTPCR_e_RacePrepState_NFdial = CeTPCR_e_NotRacePrep;/* Referenced by: '<S1976>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeTIMR_e_RaceTypeSts, TPCR_VAR_INIT)
    KeTPCR_e_RacePrepSts_D = CeTIMR_e_RaceType_Drag;/* Referenced by: '<S1848>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeTIMR_e_RacePrep, TPCR_VAR_INIT) KeTPCR_e_RacePrep_D =
    CeTIMR_e_RacePrep_Off;             /* Referenced by: '<S1849>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeTPCR_e_SC_WakeUpSt, TPCR_VAR_INIT)
    KeTPCR_e_SCWakeUp_Dial = CeTPCR_e_SC_NotAwake;/* Referenced by: '<S1901>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(TeTPCR_e_SC_WakeUpSt, TPCR_VAR_INIT)
    KeTPCR_e_SCWakeUp_NFDial = CeTPCR_e_SC_NotAwake;/* Referenced by: '<S1977>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TePLTR_e_ShipingMode, TPCR_VAR_INIT)
    KeTPCR_e_ShippingMode_D = CePLTR_e_ShipingMode_SHIP_MD;/* Referenced by: '<S1831>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(TeTPCR_e_ThrmPerWup_State, TPCR_VAR_INIT)
    KeTPCR_e_ThrmPerWupState_NFdial = CeTPCR_e_NoWup_Set_ShortTim_RS_Denied;/* Referenced by: '<S1978>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(TeTPCR_e_ThrmPerWup_State, TPCR_VAR_INIT)
    KeTPCR_e_ThrmPerWup_St_Dial = CeTPCR_e_NoWup_Set_ShortTim_RS_Denied;/* Referenced by: '<S1943>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_k_SCCTimerCalcErr = 0.01F;/* Referenced by:
                                                                      * '<S1233>/Calib'
                                                                      * '<S1274>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_k_SCCTimerCalcIter = 20.0F;/* Referenced by:
                                                                      * '<S1234>/Calib'
                                                                      * '<S1275>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_l_ProCondRngTol = 15.0F;/* Referenced by: '<S734>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(uint16, TPCR_VAR_INIT)
    KeTPCR_t_BatPerWU_ThrmlCondTmr_NFdial = 0U;/* Referenced by: '<S1979>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_t_BatPerWU_ThrmlCond_Timer_Dial = 0.0F;/* Referenced by: '<S1899>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_BatThrmlCond_HCP_Timer =
    180.0F;                            /* Referenced by: '<S1011>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_t_BatThrmlCond_HCP_TimerDflt = 1440.0F;/* Referenced by:
                                                   * '<S1012>/Calib'
                                                   * '<S1522>/Calib'
                                                   */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_t_BatThrmlCond_HCP_TimerShort = 5.0F;/* Referenced by: '<S1096>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_BattCond_MaxTm = 20000.0F;/* Referenced by: '<S46>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_CabPrecOff_DepTmTh = 30;/* Referenced by: '<S260>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_CellMinTh_WkUp = -30.0F;/* Referenced by: '<S1754>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint16, TPCR_VAR_INIT) KeTPCR_t_CellOTTmOut_PerWkupHot =
    10U;                               /* Referenced by: '<S1582>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_ChngInDepTmTh = 5;/* Referenced by:
                                                                      * '<S1197>/Calib'
                                                                      * '<S1333>/Calib'
                                                                      * '<S1268>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_ClmSchOpt_Dbnc = 0.5F;/* Referenced by: '<S1198>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_ClmSchOpt_dT = 0.1F;/* Referenced by: '<S1199>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_CntctrOpen_CabPrecOffDbnc
    = 5.0F;                            /* Referenced by: '<S230>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_CntctrOpen_KeyOffCabCond =
    1.0F;                              /* Referenced by: '<S571>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_DeacTime_NFDial = 0.0F;/* Referenced by: '<S1980>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_DebInit_DepTm = 1.0F;/* Referenced by: '<S1334>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_DebounceBattCondCmplt =
    28.0F;                             /* Referenced by: '<S83>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_DebounceBattCondOn =
    28.0F;                             /* Referenced by: '<S84>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_Dflt_SCTimer = 0;/* Referenced by:
                                                                      * '<S1296>/Calib'
                                                                      * '<S1335>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_DoorAjarTmr_CabPrecOff =
    300.0F;                            /* Referenced by: '<S231>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_DoorAjarTmr_HotEnblReq =
    10.0F;                             /* Referenced by: '<S597>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_DoorAjarTmr_KHC = 10.0F;/* Referenced by: '<S625>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_DragTimerUnit = 0.01F;/* Referenced by:
                                                                      * '<S799>/Calib'
                                                                      * '<S853>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_FOTARunTm = 40;/* Referenced by:
                                                                      * '<S1235>/Calib'
                                                                      * '<S1276>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_HdAjarDbnc_BattCond =
    2.0F;                              /* Referenced by: '<S47>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_HoodAjarTmr_CabPrecOff =
    10.0F;                             /* Referenced by: '<S232>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_HoodAjarTmr_HotEnblReq =
    0.0F;                              /* Referenced by: '<S598>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_HoodAjarTmr_KHC = 0.0F;/* Referenced by: '<S633>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_KHCActiveTmr = 900.0F;/* Referenced by: '<S699>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_LoPwrBdgtDbnc = 900.0F;/* Referenced by:
                                                                      * '<S48>/Calib'
                                                                      * '<S1715>/Calib'
                                                                      * '<S1583>/Calib'
                                                                      * '<S1682>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_LoadShed_CabPrecOffDbnc =
    2.0F;                              /* Referenced by: '<S233>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_LoadShed_KeyOffCabCond =
    10.0F;                             /* Referenced by: '<S572>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_LtchRSSt_ForETM = 0.5F;/* Referenced by:
                                                                      * '<S125>/Calib'
                                                                      * '<S135>/Calib'
                                                                      * '<S161>/Calib'
                                                                      * '<S171>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_LtchRSSt_ForETM_PrecOff =
    3.0F;                              /* Referenced by: '<S191>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_MinSchPrecTime = 1;/* Referenced by:
                                                                      * '<S1236>/Calib'
                                                                      * '<S1277>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_OverSpdDebounceTime =
    300.0F;                            /* Referenced by: '<S838>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_OverSpdDebounceUnitTime =
    0.01F;                             /* Referenced by: '<S839>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_PCC_CabPrec_dT = 0.1F;/* Referenced by: '<S573>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_PCC_LoPwrBdgtDbnc = 1.0F;/* Referenced by: '<S574>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_PerWupCond_dT = 0.1F;/* Referenced by:
                                                                      * '<S49>/Calib'
                                                                      * '<S1716>/Calib'
                                                                      * '<S1584>/Calib'
                                                                      * '<S1683>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_PerWupEnblDbnc = 5.0F;/* Referenced by:
                                                                      * '<S1717>/Calib'
                                                                      * '<S1585>/Calib'
                                                                      * '<S1684>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_PerWup_dT = 1.0F;/* Referenced by:
                                                                      * '<S50>/Calib'
                                                                      * '<S1013>/Calib'
                                                                      * '<S1502>/Calib'
                                                                      * '<S1718>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_PerWup_delayTime = 5.0F;/* Referenced by: '<S1014>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_t_PerWup_delayTime_PerWkupDsbl = 20.0F;/* Referenced by: '<S1503>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_PlugInDepTmChk = 15;/* Referenced by:
                                                                      * '<S1200>/Calib'
                                                                      * '<S1336>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_PluginDepTm_ZeroChk =
    0.0F;                              /* Referenced by: '<S1201>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_PrecMsgDepTmChk = 15.0F;/* Referenced by: '<S1202>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_PrecOffTm_AfterSC =
    900.0F;                            /* Referenced by: '<S261>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_PrecOffTm_AfterSC_RstLtch
    = 901.0F;                          /* Referenced by: '<S262>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_PrecTimer_Dial = 0;/* Referenced by: '<S1897>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_PrecTimer_NFDial = 0;/* Referenced by: '<S1981>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_PrecTmr_LongDT = 30;/* Referenced by: '<S1214>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_PrecTmr_MinTh = 0;/* Referenced by: '<S1215>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_PrecTmr_MinWkUpTmr = 0;/* Referenced by: '<S1216>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint8, TPCR_VAR_INIT) KeTPCR_t_ProActvCoolTmDiff = 5U;/* Referenced by: '<S735>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint8, TPCR_VAR_INIT) KeTPCR_t_ProActvHeatTmDiff = 5U;/* Referenced by: '<S736>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint8, TPCR_VAR_INIT) KeTPCR_t_ProPsvCoolTmDiff = 10U;/* Referenced by: '<S737>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint8, TPCR_VAR_INIT) KeTPCR_t_ProPsvHeatTmDiff = 10U;/* Referenced by: '<S738>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_RSOn_AftrTmrExprDbnc =
    0.5F;                              /* Referenced by: '<S263>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint16, TPCR_VAR_INIT) KeTPCR_t_RS_BCCTim_Expired = 65535U;/* Referenced by: '<S85>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_RS_CabPrecOff_DlyTm =
    0.5F;                              /* Referenced by: '<S315>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_RS_CabPrec_dT = 0.1F;/* Referenced by:
                                                                      * '<S86>/Calib'
                                                                      * '<S289>/Calib'
                                                                      * '<S336>/Calib'
                                                                      * '<S126>/Calib'
                                                                      * '<S136>/Calib'
                                                                      * '<S162>/Calib'
                                                                      * '<S172>/Calib'
                                                                      * '<S192>/Calib'
                                                                      * '<S1217>/Calib'
                                                                      * '<S1225>/Calib'
                                                                      * '<S1255>/Calib'
                                                                      * '<S1297>/Calib'
                                                                      * '<S1304>/Calib'
                                                                      * '<S1337>/Calib'
                                                                      * '<S234>/Calib'
                                                                      * '<S264>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_RS_CabPrec_delayTime =
    0.5F;                              /* Referenced by: '<S290>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint16, TPCR_VAR_INIT) KeTPCR_t_RS_LogicWaitTim = 25U;/* Referenced by: '<S272>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_RS_NotEnbldDbnc = 1.0F;/* Referenced by:
                                                                      * '<S337>/Calib'
                                                                      * '<S235>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_RacePrepTimerDiff = 1.0F;/* Referenced by:
                                                                      * '<S800>/Calib'
                                                                      * '<S852>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_RacePrep_DeacTime_Dial =
    0.0F;                              /* Referenced by: '<S1925>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_RdyForShtDwn_PreCondDly =
    0.5F;                              /* Referenced by:
                                        * '<S1218>/Calib'
                                        * '<S1298>/Calib'
                                        * '<S1305>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_t_RdyForShtDwn_PrecShrtTmrDly = 0.5F;/* Referenced by: '<S1226>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_t_RdyForShtDwn_PrecShrtTmrDly_PlugIn = 0.5F;/* Referenced by: '<S1256>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_SCCFOTARejectTmr = -1;/* Referenced by:
                                                                      * '<S1237>/Calib'
                                                                      * '<S1278>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_SCCRejectionDfltTmr = 0;/* Referenced by:
                                                                      * '<S1238>/Calib'
                                                                      * '<S1279>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_SCCTmrMaxInterval = 45;/* Referenced by:
                                                                      * '<S1239>/Calib'
                                                                      * '<S1280>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_SCCTmrMinInterval = 0;/* Referenced by:
                                                                      * '<S1240>/Calib'
                                                                      * '<S1281>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_SCDfltTime = 30;/* Referenced by:
                                                                      * '<S1241>/Calib'
                                                                      * '<S1282>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_SOCNotOK_SCTimer = 0;/* Referenced by: '<S1306>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_SOCRej_DepTmTh = 20;/* Referenced by: '<S1169>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_ShortPreCondTmr = 480;/* Referenced by:
                                                                      * '<S1136>/Calib'
                                                                      * '<S1154>/Calib'
                                                                      * '<S1170>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_ShtDwnDbnc_BattCond =
    0.5F;                              /* Referenced by: '<S51>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_ThrmlWUp_CondTimeOut =
    18000.0F;                          /* Referenced by: '<S1685>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_ThrmlWUp_CondTimeOutHot =
    5400.0F;                           /* Referenced by: '<S1586>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_TimeAtDestination = 0.0F;/* Referenced by: '<S739>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_TimeToDeparture_Dial = 0;/* Referenced by: '<S1903>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_4

static volatile CONST(sint16, TPCR_VAR_INIT) KeTPCR_t_TimeToDeparture_NFDial = 0;/* Referenced by: '<S1982>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_TrunkAjarTmr_HotEnblReq =
    10.0F;                             /* Referenced by: '<S599>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_TrunkAjarTmr_KHC = 10.0F;/* Referenced by: '<S642>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint16, TPCR_VAR_INIT) KeTPCR_t_WpThrml_BatEngCond_TimOut =
    200U;                              /* Referenced by: '<S1686>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint16, TPCR_VAR_INIT)
    KeTPCR_t_WpThrml_BatEngCond_TimOutHot = 200U;/* Referenced by: '<S1587>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint16, TPCR_VAR_INIT) KeTPCR_t_Wp_Norml_Abrtd_Tim = 5U;/* Referenced by: '<S1489>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(uint16, TPCR_VAR_INIT) KeTPCR_t_Wp_RS_Abrtd_Tim = 5U;/* Referenced by: '<S1746>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_Wp_WaitBatCond_Tim =
    5400.0F;                           /* Referenced by: '<S1719>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_t_isStillCondEngBat_DebTim =
    5.0F;                              /* Referenced by: '<S1663>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KeTPCR_t_isStillCondEngBat_DebTimHot = 5.0F;/* Referenced by: '<S1564>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KeTPCR_v_DragMaxSpd = 50.0F;/* Referenced by: '<S840>/Calib' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KtTPCR_K_RacePrep_CoolPowerCorrection[6] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S781>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_P_DragCoolPwrNeed[25] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.2F, 0.2F, 0.3F, 0.4F, 0.45F, 0.3F, 0.3F,
    0.3F, 0.4F, 0.5F, 0.4F, 0.4F, 0.4F, 0.4F, 0.55F, 0.4F, 0.45F, 0.5F, 0.6F,
    0.6F
} ;                                    /* Referenced by: '<S821>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_P_DragHotPwrNeed[6] =
{
    0.1F, 0.1F, 0.1F, 0.1F, 0.1F, 0.1F
} ;                                    /* Referenced by: '<S824>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_P_RacePrep_CoolPowerMax[2] =
{
    6500.0F, 4500.0F
} ;                                    /* Referenced by: '<S782>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_cmp_CabCond_SPRt[56] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by:
                                        * '<S1242>/Vector'
                                        * '<S1283>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_k_ACDragCorr[30] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S817>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_k_HtDragCorr[30] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S818>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_t_MinTimetoCoolDrag[35] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1500.0F, 1600.0F, 1700.0F, 1800.0F, 1900.0F,
    1600.0F, 1800.0F, 2000.0F, 2280.0F, 2400.0F, 1800.0F, 2100.0F, 2400.0F,
    2760.0F, 3000.0F, 2200.0F, 2500.0F, 2800.0F, 3120.0F, 3300.0F, 1650.0F,
    3040.0F, 3440.0F, 3480.0F, 3700.0F, 3000.0F, 3400.0F, 3800.0F, 4200.0F,
    4600.0F
} ;                                    /* Referenced by: '<S822>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_t_PerWkup_AmbCellMinTmr[56]
    =
{
    15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F,
    15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F,
    15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F,
    15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F,
    15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F,
    15.0F
} ;                                    /* Referenced by: '<S1062>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_t_PerWkup_AmbCellMinTmrHot
    [56] =
{
    15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F,
    15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F,
    15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F,
    15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F,
    15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F, 15.0F,
    15.0F
} ;                                    /* Referenced by: '<S1063>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_t_ProactiveActvCoolTime[56]
    =
{
    0.0F, 4.0F, 10.0F, 16.0F, 20.0F, 30.0F, 40.0F, 0.0F, 4.0F, 10.0F, 16.0F,
    20.0F, 30.0F, 40.0F, 0.0F, 4.0F, 10.0F, 16.0F, 20.0F, 30.0F, 40.0F, 0.0F,
    4.0F, 10.0F, 16.0F, 20.0F, 30.0F, 40.0F, 0.0F, 6.0F, 15.0F, 24.0F, 30.0F,
    45.0F, 60.0F, 0.0F, 6.0F, 15.0F, 24.0F, 30.0F, 45.0F, 60.0F, 0.0F, 8.0F,
    20.0F, 32.0F, 40.0F, 60.0F, 80.0F, 0.0F, 8.0F, 20.0F, 32.0F, 40.0F, 60.0F,
    80.0F
} ;                                    /* Referenced by: '<S740>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_t_ProactiveActvHeatTime[56]
    =
{
    180.0F, 140.0F, 100.0F, 60.0F, 20.0F, 12.0F, 0.0F, 180.0F, 140.0F, 100.0F,
    60.0F, 20.0F, 12.0F, 0.0F, 135.0F, 115.0F, 75.0F, 45.0F, 15.0F, 9.0F, 0.0F,
    135.0F, 115.0F, 75.0F, 45.0F, 15.0F, 9.0F, 0.0F, 135.0F, 115.0F, 75.0F,
    45.0F, 15.0F, 9.0F, 0.0F, 90.0F, 70.0F, 50.0F, 30.0F, 10.0F, 6.0F, 0.0F,
    90.0F, 70.0F, 50.0F, 30.0F, 10.0F, 6.0F, 0.0F, 90.0F, 70.0F, 50.0F, 30.0F,
    10.0F, 6.0F, 0.0F
} ;                                    /* Referenced by: '<S741>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_t_ProactivePsvCoolTime[56] =
{
    0.0F, 8.0F, 20.0F, 32.0F, 40.0F, 60.0F, 80.0F, 0.0F, 8.0F, 20.0F, 32.0F,
    40.0F, 60.0F, 80.0F, 0.0F, 8.0F, 20.0F, 32.0F, 40.0F, 60.0F, 80.0F, 0.0F,
    8.0F, 20.0F, 32.0F, 40.0F, 60.0F, 80.0F, 0.0F, 12.0F, 30.0F, 48.0F, 60.0F,
    90.0F, 120.0F, 0.0F, 12.0F, 30.0F, 48.0F, 60.0F, 90.0F, 120.0F, 0.0F, 16.0F,
    40.0F, 64.0F, 80.0F, 120.0F, 160.0F, 0.0F, 16.0F, 40.0F, 64.0F, 80.0F,
    120.0F, 160.0F
} ;                                    /* Referenced by: '<S742>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_t_ProactivePsvHeatTime[56] =
{
    210.0F, 150.0F, 130.0F, 85.0F, 35.0F, 18.0F, 0.0F, 210.0F, 150.0F, 130.0F,
    85.0F, 35.0F, 18.0F, 0.0F, 190.0F, 145.0F, 110.0F, 65.0F, 25.0F, 15.0F, 0.0F,
    190.0F, 145.0F, 110.0F, 65.0F, 25.0F, 15.0F, 0.0F, 190.0F, 145.0F, 110.0F,
    65.0F, 25.0F, 15.0F, 0.0F, 145.0F, 110.0F, 65.0F, 48.0F, 16.0F, 10.0F, 0.0F,
    145.0F, 110.0F, 65.0F, 48.0F, 16.0F, 10.0F, 0.0F, 145.0F, 110.0F, 65.0F,
    48.0F, 16.0F, 10.0F, 0.0F
} ;                                    /* Referenced by: '<S743>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KtTPCR_t_ThrmPerWp_BattEngCond_Tim[8] =
{
    70.0F, 85.0F, 105.0F, 140.0F, 220.0F, 545.0F, 720.0F, 1200.0F
} ;                                    /* Referenced by: '<S1646>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KtTPCR_t_ThrmPerWp_BattEngCond_TimHot[8] =
{
    70.0F, 85.0F, 105.0F, 140.0F, 220.0F, 545.0F, 720.0F, 1200.0F
} ;                                    /* Referenced by: '<S1556>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_t_ThrmPerWp_FirstTmr[8] =
{
    70.0F, 85.0F, 105.0F, 140.0F, 220.0F, 545.0F, 720.0F, 1200.0F
} ;                                    /* Referenced by: '<S1064>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_t_ThrmPerWp_FirstTmrHot[8] =
{
    70.0F, 85.0F, 105.0F, 140.0F, 220.0F, 545.0F, 720.0F, 1200.0F
} ;                                    /* Referenced by: '<S1065>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_t_TimetoCool_Drag[49] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1000.0F, 1000.0F, 1000.0F, 1000.0F,
    1000.0F, 1000.0F, 1000.0F, 2000.0F, 2000.0F, 2000.0F, 2000.0F, 2000.0F,
    2000.0F, 2000.0F, 3000.0F, 3000.0F, 3000.0F, 3000.0F, 3000.0F, 3000.0F,
    3000.0F, 4000.0F, 4000.0F, 4000.0F, 4000.0F, 4000.0F, 4000.0F, 4000.0F,
    5000.0F, 5000.0F, 5000.0F, 5000.0F, 5000.0F, 5000.0F, 5000.0F, 6000.0F,
    6000.0F, 6000.0F, 6000.0F, 6000.0F, 6000.0F, 6000.0F
} ;                                    /* Referenced by: '<S823>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KtTPCR_t_TimetoWarm_Drag[48] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 360.0F, 360.0F, 312.0F,
    288.0F, 264.0F, 240.0F, 240.0F, 240.0F, 720.0F, 720.0F, 624.0F, 576.0F,
    528.0F, 480.0F, 480.0F, 480.0F, 1080.0F, 1080.0F, 936.0F, 864.0F, 792.0F,
    720.0F, 720.0F, 720.0F, 1440.0F, 1440.0F, 1248.0F, 1152.0F, 1056.0F, 960.0F,
    960.0F, 960.0F, 1800.0F, 1800.0F, 1560.0F, 1440.0F, 1320.0F, 1200.0F,
    1200.0F, 1200.0F
} ;                                    /* Referenced by: '<S825>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KxTPCR_K_RacePrep_CoolPowerCorrection[6] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F, 50.0F
} ;                                    /* Referenced by: '<S781>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_P_RacePrep_CoolPowerMax[2] =
{
    25.0F, 45.0F
} ;                                    /* Referenced by: '<S782>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_Pct_ACDragCorr[6] =
{
    0.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S817>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_Pct_HtrDragCorr[6] =
{
    0.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by: '<S818>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_T_DragCoolPwrNeed[5] =
{
    0.0F, 10.0F, 20.0F, 30.0F, 40.0F
} ;                                    /* Referenced by: '<S821>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_T_DragHotPwrNeed[6] =
{
    0.0F, 2.0F, 4.0F, 6.0F, 8.0F, 10.0F
} ;                                    /* Referenced by: '<S824>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_T_MinTimetoCoolDrag[7] =
{
    0.0F, 10.0F, 15.0F, 20.0F, 25.0F, 30.0F, 35.0F
} ;                                    /* Referenced by: '<S822>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_cmp_CabCond_SPRt[7] =
{
    10.0F, 1000.0F, 2000.0F, 3000.0F, 4000.0F, 5000.0F, 6000.0F
} ;                                    /* Referenced by:
                                        * '<S1242>/Vector'
                                        * '<S1283>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_t_PerWkup_AmbCellMinTmr[7] =
{
    -35.0F, -25.0F, -20.0F, -15.0F, 10.0F, 20.0F, 30.0F
} ;                                    /* Referenced by: '<S1062>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_t_PerWkup_AmbCellMinTmrHot
    [7] =
{
    -35.0F, -25.0F, -20.0F, -15.0F, 10.0F, 20.0F, 30.0F
} ;                                    /* Referenced by: '<S1063>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_t_ProactiveActvCoolTime[7] =
{
    30.0F, 32.0F, 35.0F, 38.0F, 40.0F, 45.0F, 50.0F
} ;                                    /* Referenced by: '<S740>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_t_ProactiveActvHeatTime[7] =
{
    -20.0F, -10.0F, 0.0F, 10.0F, 20.0F, 22.0F, 25.0F
} ;                                    /* Referenced by: '<S741>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_t_ProactivePsvCoolTime[7] =
{
    30.0F, 32.0F, 35.0F, 38.0F, 40.0F, 45.0F, 50.0F
} ;                                    /* Referenced by: '<S742>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_t_ProactivePsvHeatTime[7] =
{
    -20.0F, -10.0F, 0.0F, 10.0F, 20.0F, 22.0F, 25.0F
} ;                                    /* Referenced by: '<S743>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KxTPCR_t_ThrmPerWp_BattEngCond_Tim[8] =
{
    -45.0F, -40.0F, -35.0F, -30.0F, -25.0F, -20.0F, -15.0F, -5.0F
} ;                                    /* Referenced by: '<S1646>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT)
    KxTPCR_t_ThrmPerWp_BattEngCond_TimHot[8] =
{
    -45.0F, -40.0F, -35.0F, -30.0F, -25.0F, -20.0F, -15.0F, -5.0F
} ;                                    /* Referenced by: '<S1556>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_t_ThrmPerWp_FirstTmr[8] =
{
    -45.0F, -40.0F, -35.0F, -30.0F, -25.0F, -20.0F, -15.0F, -5.0F
} ;                                    /* Referenced by: '<S1064>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_t_ThrmPerWp_FirstTmrHot[8] =
{
    -45.0F, -40.0F, -35.0F, -30.0F, -25.0F, -20.0F, -15.0F, -5.0F
} ;                                    /* Referenced by: '<S1065>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_t_TimetoCool_Drag[7] =
{
    0.0F, 1000.0F, 2000.0F, 3000.0F, 4000.0F, 5000.0F, 6000.0F
} ;                                    /* Referenced by: '<S823>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KxTPCR_t_TimetoWarm_Drag[6] =
{
    0.0F, 2.0F, 4.0F, 6.0F, 8.0F, 10.0F
} ;                                    /* Referenced by: '<S825>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KyTPCR_P_TimetoCool_Drag[7] =
{
    2.0F, 4.0F, 6.0F, 8.0F, 10.0F, 12.0F, 14.0F
} ;                                    /* Referenced by: '<S823>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KyTPCR_T_ACDragCorr[5] =
{
    10.0F, 20.0F, 30.0F, 40.0F, 45.0F
} ;                                    /* Referenced by: '<S817>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KyTPCR_T_DragCoolPwrNeed[5] =
{
    10.0F, 20.0F, 30.0F, 40.0F, 50.0F
} ;                                    /* Referenced by: '<S821>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KyTPCR_T_HtrDragCorr[5] =
{
    10.0F, 20.0F, 30.0F, 40.0F, 45.0F
} ;                                    /* Referenced by: '<S818>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KyTPCR_T_MinTimetoCoolDrag[5] =
{
    10.0F, 20.0F, 30.0F, 40.0F, 45.0F
} ;                                    /* Referenced by: '<S822>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KyTPCR_cmp_CabCond_SPRt[8] =
{
    -30.0F, -10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F
} ;                                    /* Referenced by:
                                        * '<S1242>/Vector'
                                        * '<S1283>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KyTPCR_t_PerWkup_AmbCellMinTmr[8] =
{
    -30.0F, -10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F
} ;                                    /* Referenced by: '<S1062>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KyTPCR_t_PerWkup_AmbCellMinTmrHot
    [8] =
{
    -30.0F, -10.0F, 20.0F, 30.0F, 40.0F, 50.0F, 60.0F, 70.0F
} ;                                    /* Referenced by: '<S1063>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KyTPCR_t_ProactiveActvCoolTime[8] =
{
    -35.0F, -25.0F, -10.0F, 0.0F, 15.0F, 30.0F, 40.0F, 50.0F
} ;                                    /* Referenced by: '<S740>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KyTPCR_t_ProactiveActvHeatTime[8] =
{
    0.0F, 1000.0F, 3000.0F, 5000.0F, 6000.0F, 7000.0F, 9000.0F, 10000.0F
} ;                                    /* Referenced by: '<S741>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KyTPCR_t_ProactivePsvCoolTime[8] =
{
    -35.0F, -25.0F, -10.0F, 0.0F, 15.0F, 30.0F, 40.0F, 50.0F
} ;                                    /* Referenced by: '<S742>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KyTPCR_t_ProactivePsvHeatTime[8] =
{
    -20.0F, -10.0F, 0.0F, 20.0F, 40.0F, 50.0F, 60.0F, 70.0F
} ;                                    /* Referenced by: '<S743>/Vector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static volatile CONST(float32, TPCR_VAR_INIT) KyTPCR_t_TimetoWarm_Drag[8] =
{
    1.0F, 2.0F, 4.0F, 6.0F, 8.0F, 10.0F, 12.0F, 14.0F
} ;                                    /* Referenced by: '<S825>/Vector' */

#endif

#define STOP_SEC_CALIB_UNSPECIFIED_TPCR
#include "MemMap.h"
#define START_SEC_VAR_CLEARED_UNSPECIFIED_TPCR
#include "MemMap.h"

/* Definition for custom storage class: FCALocalSignal */
static VAR(sint16, TPCR_VAR_INIT) EeTPCR_e_HoldClusterMsg;/* '<Root>/DSM_3' */
static VAR(sint16, TPCR_VAR_INIT) EeTPCR_e_HoldClusterMsg_KHC;/* '<Root>/DSM_4' */

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeTIMR_e_RaceTypeSts, TPCR_VAR_INIT) VeTIMR_e_RacePrepRaceTypeSts_AD;/* '<S1781>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeTIMR_e_RacePrep, TPCR_VAR_INIT) VeTIMR_e_RacePrep_AD;/* '<S1781>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCC_T_BatTmpTgt_Tob;/* '<S1606>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCC_T_BatTmpTgt_Tob_0;/* '<S1606>/Merge1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCC_T_ECT_ECHTIS_Tmp;/* '<S1611>/Switch2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCC_T_EngTmpTgt_Toe;/* '<S1606>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCC_T_EngTmpTgt_Toe_0;/* '<S1606>/Merge' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_BatPerWU_ThrmlCond_Dflt;/* '<S1040>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_CabPrecondAny_Flt;/* '<S339>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_EAC_BatThrmlFlt_Prst;/* '<S340>/Comparison11' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_EAC_OrPresFlt_Prst;/* '<S340>/Logical4' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_HtrStsFlty_Prst;/* '<S338>/Logical4' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_HtrStsFlty_RawPrst;/* '<S346>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_Htr_EAC_RawFlt;/* '<S68>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_NoWup_RS_DendShrtTimr;/* '<S1087>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_NormalWp_Msg2;/* '<S1616>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_NormalWp_Msg2Hot;/* '<S1547>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_NrmlPerWup_ShutDwnReq_New;/* '<S1618>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_NrmlPerWup_ShutDwnReq_NewHot;/* '<S1549>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_NrmlPerWup_ShutDwnReq_Old;/* '<S1528>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_OutTimer_N_ShutDwn_Enb;/* '<S1688>/OR2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_OutTimer_N_ShutDwn_EnbHot;/* '<S1589>/OR2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_PerWupDsbl_ThrmlCond_Dflt;/* '<S1472>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_PerWup_RdyShtDwn_BD;/* '<S19>/Merge1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_PeriodWup_Msg2;/* '<S19>/Merge2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_RS_NoCabPrecond_Flt;/* '<S97>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_RS_NoCabPrecond_FltLtch;/* '<S127>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_RS_NoCabPrecond_NoPlug;/* '<S101>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_RS_NoCabPrecond_NoPlugLtch;/* '<S173>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_RS_NoCabPrecond_SNA;/* '<S99>/Logical4' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_RS_NoCabPrecond_SOC;/* '<S100>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_RS_NoCabPrecond_SOCLtch;/* '<S163>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_RS_ThrmlRdyShtDwn_AftMrg;/* '<S67>/Merge1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_RS_WUpNVRAM;/* '<S1015>/Logical' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_RS_WUpNVRAM_Rst;/* '<S1015>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_VhclPlgdIn;/* '<S17>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_WpWaitBatCond_PerWpTimr;/* '<S1490>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_WpWaitBatCond_RS_DndDftTimr;/* '<S1747>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_Wp_PerWupDsbld;/* '<S1504>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_isStillCondEng_Bat_B4Deb;/* '<S1609>/Logical' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCC_b_isStillCondEng_Bat_B4DebHot;/* '<S1541>/Comparison4' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeTPCR_e_ThrmPerWup_State, TPCR_VAR_INIT) VeTPCC_e_ThrmPerWup_State;/* '<S1109>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD;/* '<S19>/Merge' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCC_t_NormlPerWup_TimrOld;/* '<S1527>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_Cnt_SCTimer_Iteration;/* '<S1251>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_Cnt_SCTimer_Iteration_PlugIn;/* '<S1292>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(sint16, TPCR_VAR_INIT) VeTPCR_Cnt_WupTimerDbg_PlugIn;/* '<S1291>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(sint16, TPCR_VAR_INIT) VeTPCR_Cnt_WupTimer_Dbg;/* '<S1250>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_P_CoolPowerAvgRaw;/* '<S753>/Product2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_P_PwrBdgtAvail;/* '<S1770>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_P_PwrBdgtAvailLtch;/* '<S1265>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_P_RP_HeatPowerAvgRaw;/* '<S758>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_P_RacePrepPower;/* '<S14>/Merge4' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_P_ThrmlPwrBdgt;/* '<S1770>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_Pct_DragSOCTgt_CurrentMethod;/* '<S757>/Subtraction6' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_Pct_DragSOCTgt_EnergyMethod;/* '<S757>/Subtraction2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_Pct_HVBatSOC;/* '<S1765>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_T_BatTmpTgt_AftrAmbChkHot;/* '<S1557>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_T_BatTmpTgt_AftrAmbChkHotRaw;/* '<S1557>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_T_BatTmpTgt_Tob;/* '<S1648>/Subtraction1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_T_BatTmpTgt_TobHot;/* '<S1557>/Subtraction2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_T_CabSP;/* '<S1768>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_T_CabSPLtch;/* '<S1264>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_T_CellTmpMaxAllwd;/* '<S1782>/Switch3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_T_EngCoolantTemp;/* '<S1757>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_T_EngTmpTgt_Toe;/* '<S1647>/Subtraction1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_T_EngTmpTgt_ToeAftrAmbChk;/* '<S1647>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_12VPwup;/* '<S1779>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_AmbHiTimer;/* '<S1017>/Comparison1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_AmbLowTimer;/* '<S1017>/Comparison' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_AmbOptimalNoTmr;/* '<S1066>/LogicalOperator' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ArbRdyForShtDwn;/* '<S18>/Logical4' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ArbSCWkUpReq;/* '<S874>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BCC_CellUnderTmpChk;/* '<S60>/Logical' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BCC_CellUnderTmpChkDbnc;/* '<S89>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BCC_TmrExpired;/* '<S60>/Logical4' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BCMPrecReq_SNA;/* '<S99>/Logical2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BHOSFlt;/* '<S1340>/Logical8' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BPCMLOC;/* '<S1340>/Logical21' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BTISFlt;/* '<S1350>/Logical7' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BTOSFlt;/* '<S1350>/Logical8' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BattCondCmplt;/* '<S60>/Logical7' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BattCondOn;/* '<S88>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BattCondStop;/* '<S60>/Logical5' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BattCondStopLtch;/* '<S87>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BattHeatFlt;
                              /* '<S1340>/SigConvForSigProp_VariantSource2_0' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BattHeaterFlts;/* '<S1340>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BattHtrPerf_Flt;
                               /* '<S1340>/SigConvForSigProp_VariantSource_0' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BattHtr_LOC_FA;/* '<S1776>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BattThrmlSt_Cond;/* '<S60>/Logical6' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BigDepTmChng;/* '<S241>/Comparison6' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BothCondWkUps;/* '<S18>/Logical2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BothRdyForShtDwn;/* '<S18>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BtlClntLvlLo_Flt;/* '<S1350>/Logical20' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_BtlSnsr_SG_Flt;/* '<S1350>/Logical21' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CANCOff_SNA;/* '<S99>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabCond_DsblBattCond_NormPerWkUp;/* '<S1026>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabCond_DsblBattCond_NormPerWkUpTrig;/* '<S1476>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabCond_DsblBattCond_PerWkUpDsbl;/* '<S1027>/Logical10' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabCond_DsblBattCond_PerWkUpDsblTrig;/* '<S1495>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabCond_DsblBattCond_RSDnyPerWkUp;/* '<S1030>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT)
    VeTPCR_b_CabCond_DsblBattCond_RSDnyPerWkUpTrig;/* '<S1735>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabPrecDnyRaw_BattCond;/* '<S7>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabPrecDny_BattCondLtch;/* '<S53>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabPrecFail;/* '<S68>/Logical2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabPrecFailLtch_CondTmr;/* '<S1338>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabPrecFailLtch_DfltTmr;/* '<S1124>/Switch2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabPrecNotOk;/* '<S15>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabPrecOffCond;/* '<S194>/Logical13' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabPrecOff_CBC;/* '<S241>/Logical4' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabPrecOff_CBCDbnc;/* '<S241>/Logical10' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabReqStBattCrit_Msg;/* '<S506>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabReqStFail_Msg;/* '<S512>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabReqStLoSOC_Msg;/* '<S511>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabReqStNoPlugIn_Msg;/* '<S510>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabReq_Default;/* '<S517>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabWkUp_LowTemp;/* '<S7>/Logical14' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabWkUp_LowTemps;/* '<S1026>/Logical9' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CabWkUp_LowTemps_RSDnyPerWkUp;/* '<S1030>/Logical9' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CellTmpCrit;/* '<S20>/Comparison1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CellUTMet_BattCond;/* '<S7>/Logical' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ChngInDepTm;/* '<S1258>/Comparison3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ChngInDepTm_RstLtch;/* '<S1124>/Comparison7' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ChrgSysFlt;/* '<S1771>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ChrgSysFlt_BattCond;/* '<S7>/Logical7' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CmftEnblReq_ClimateFail;/* '<S520>/Logical28' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CmftEnbl_PwrBdgt_SOC;/* '<S519>/Logical19' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CmftEnbl_SOCLimit;/* '<S519>/Logical18' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ComfortEnable;/* '<S518>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ComfortEnable_KeyChk;/* '<S526>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CondWakeUp;/* '<S20>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_CondWakeUpLtch;/* '<S1755>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_DebDepTm_RstLtchCabFail;/* '<S1124>/Logical10' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_DepTimeBigChng;/* '<S241>/Logical13' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_DepTimeBigChngLtch;/* '<S266>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_DepTimeZero;/* '<S241>/Logical11' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_DepTimeZeroLtch;/* '<S265>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_DepTmTrig;/* '<S1258>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_DoorAjarEnbl;/* '<S194>/Logical18' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_DoorAjarEnblLtch;/* '<S238>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_DoorAjarEnblLtch_KHC;/* '<S626>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_DoorAjarEnblLtch_Rst;/* '<S194>/Logical9' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_DoorAjarTime_CabPrec;/* '<S194>/Logical8' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_DoorOpenTrig;/* '<S1318>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_DoorOpen_CabPrecOffSt;/* '<S194>/Logical17' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_DragCooling;/* '<S809>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_DragHeating;/* '<S757>/NOT' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_EAC_LOC;
                                /* '<S395>/SigConvForSigProp_VariantSource_0' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_EAC_PerfFlt;
                               /* '<S395>/SigConvForSigProp_VariantSource1_0' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ECHTIS_PinDiag;/* '<S1342>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ECH_InFlt;/* '<S1342>/Logical4' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ECH_OutFlt;/* '<S1342>/Logical6' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ECH_PerfFlt;/* '<S1342>/Logical5' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ECT_Sgnl_Rcvd;/* '<S1757>/Switch2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_EngCoolantTemp_FA;/* '<S1757>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_FOTAReject_AftrMrg;/* '<S1023>/Merge1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_FRSOVHi_Flt;
                               /* '<S398>/SigConvForSigProp_VariantSource1_0' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_FRSOVLo_Flt;/* '<S398>/Logical9' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_FRSOV_Flts;/* '<S398>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_FRSOV_Perf_Flt;
                                /* '<S398>/SigConvForSigProp_VariantSource_0' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_FinRdyForShtDwn;/* '<S18>/Logical6' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HCPShutDwnCmd;/* '<S1769>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HTAP_PerfFlt;/* '<S1344>/Logical20' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HTAP_TmpFlt;/* '<S1342>/Logical7' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HTCV_PinFlts;/* '<S1345>/Logical20' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HTCV_StckFlt;/* '<S1345>/Logical5' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HTSOV_PinFlts;/* '<S1342>/Logical9' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HTSOV_StckFlt;/* '<S1342>/Logical8' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HVBatPerWkUp;/* '<S20>/Merge2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HVC_Heater2_Flt;/* '<S1762>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HVC_Heater_Flt;/* '<S1762>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HVC_Heater_Flt_AS;/* '<S1762>/Switch2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HeatingElmntFlt;
                              /* '<S1340>/SigConvForSigProp_VariantSource3_0' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HoodAjarEnbl;/* '<S194>/Logical15' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HoodAjarEnblLtch;/* '<S239>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HoodAjarEnblLtch_KHC;/* '<S634>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HoodAjarEnblLtch_Rst;/* '<S194>/Logical21' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HoodAjarTime_CabPrec;/* '<S194>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HoodAjar_BattCond;/* '<S7>/Logical9' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HoodOpen_CabPrecOffSt;/* '<S194>/Logical14' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HotEnableRequest;/* '<S520>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HotEnblReq_ClimateFail;/* '<S520>/Logical27' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HotEnbl_KeyChk;/* '<S593>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HotEnbl_PwrBdgt_SOC;/* '<S519>/Logical17' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_HotEnbl_SOCLimit;/* '<S519>/Logical15' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_KHCRdyForShtDwn;/* '<S695>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_KHC_PwrBdgt_SOC;/* '<S519>/Logical14' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_KHC_SOCLimit;/* '<S519>/Logical13' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_KeyCheck;/* '<S516>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_KeyOffCabCondThrmlFlts;/* '<S519>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_KeyRunCheck;/* '<S9>/Comparison14' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_KeyRunoffCheck;/* '<S9>/Comparison9' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_KeySts_SNA;/* '<S99>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_KeyoffCheck;/* '<S9>/Comparison15' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_LIN2BusOff_AC;/* '<S395>/Logical4' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_LIN2_BusOff;/* '<S1344>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_LOCBCM_SNA;/* '<S99>/Logical5' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_LOC_ECH;/* '<S1342>/Logical20' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_LOC_HTAP;/* '<S1344>/Logical5' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_LTAP_Flts;/* '<S1348>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_LTAP_LOC_FA;/* '<S1777>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_LTAP_PerfFlt;/* '<S1348>/Logical20' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_LTAP_TmpSnsrFlt;/* '<S1348>/Logical5' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_LtchRS_BattCrit;/* '<S98>/Logical4' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_MaxTime_BattCond;/* '<S7>/Logical2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_NoRS_SCWkUp;/* '<S68>/Logical8' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_NoRS_SCWkUp_CabPrecOff;/* '<S194>/Logical25' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_NoRS_SCWkUp_CabPrecOff_Msg;/* '<S513>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_NoWup_FrstPerTimrSet;/* '<S1056>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_NoWup_ShipDfltTimr;/* '<S1078>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_NonZeroDepTm;/* '<S1258>/Comparison1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_NonZeroDepTm_Trig;/* '<S1267>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_OkayToPreCondCabin;/* '<S1767>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_OutOfBattCrit;/* '<S182>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PCC_PwrBdgtChk;/* '<S519>/Logical25' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PerWupCond_TmOut;/* '<S1610>/Logical11' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PerWupCond_TmOutHot;/* '<S1542>/Logical11' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PerWup_Enbl;/* '<S19>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PlugLv1_BattCond_SOC;/* '<S887>/Logical21' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PlugLv1_NoBattCond_SOC;/* '<S888>/Logical16' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PlugLv2_BattCond_SOC;/* '<S889>/Logical29' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PlugLv2_NoBattCond_SOC;/* '<S890>/Logical25' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PostCabinCond;/* '<S522>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PrecRdyForShtDwn_AftrMrg;/* '<S1023>/Merge3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PrecSt_FailTrig;/* '<S1124>/Logical9' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PrecWarningMsg_AftrMrg;/* '<S1023>/Merge2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PressSnsrHi_Flt;
                                /* '<S401>/SigConvForSigProp_VariantSource_0' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PressSnsrLo_Flt;
                               /* '<S401>/SigConvForSigProp_VariantSource1_0' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PressSnsr_Flts;/* '<S401>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PressSnsr_Perf_Flt;
                               /* '<S401>/SigConvForSigProp_VariantSource2_0' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PwrBdgtLimit;/* '<S960>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PwrBdgtRejectionLimit_NoPlugIn;/* '<S891>/Logical5' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_PwrBdgtRejectionLimit_PlugIn;/* '<S892>/Logical5' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RSDsbld_PerWupTmOut;/* '<S1029>/Logical13' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RSOffLtch;/* '<S236>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RSReq_BattCond;/* '<S60>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RSStDsbl_App1;/* '<S271>/GreaterThan1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RSStEnbl_App1;/* '<S65>/Logical2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RS_BattCondCmplt;/* '<S102>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RS_BattCondStop;/* '<S103>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RS_CabPrecondOk;/* '<S95>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RS_CabPrecondSPR;/* '<S96>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RS_NoCabPrecond_BattCrit;/* '<S98>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RS_NoCabPrecond_BattCritLtch;/* '<S137>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RS_NoCabPrecond_CabPrecOff;/* '<S104>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RS_NoCabPrecond_CabPrecOffLtch;/* '<S193>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RdyForShtDwnDbnc_BattCond;/* '<S56>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RdyForShtDwnRaw_BattCond;/* '<S7>/Logical15' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RdyForShtDwn_AtShortDepTm;/* '<S1227>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RdyForShtDwn_Dflt;/* '<S1299>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RdyForShtDwn_LongWkUp;/* '<S1220>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RdyForShtDwn_PlugIn;/* '<S1260>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RdyForShtDwn_SOCReject;/* '<S1307>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ResetBattCond;/* '<S7>/Logical6' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ResetClusterMsg;/* '<S9>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_Rly_EnblCmnd_AD;
                               /* '<S1758>/SigConvForSigProp_VariantSource_0' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RmtStartDsbleSCCMsg;/* '<S507>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RmtStartReqDrop;/* '<S237>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RmtStrtAbort_StrtVhclRq_BD;/* '<S66>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RmtVehStartReq;/* '<S1759>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RstLtch_CabPrecFail;/* '<S1124>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_RstMsg;/* '<S469>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SCCCancelledFOTA_Msg;/* '<S508>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SCC_Off_WhileCond_Msg;/* '<S515>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SCNotSupp_SOCReject;/* '<S1117>/Logical5' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SCNotSupp_SOCReject_Ltch;/* '<S1205>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SCNotSupp_SOCReject_Rst;/* '<S1117>/Logical12' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SCWkUp_NoRSTm;/* '<S68>/Logical5' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SCWkUp_NoRSTmCabPrecOff;/* '<S194>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SC_WakeUpReq;/* '<S20>/Merge1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCChk_InhibitRS;/* '<S16>/Logical2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCFlt_BEVRS;/* '<S16>/Logical' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCInLimit_PlugIn;/* '<S902>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCLimit;/* '<S961>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCLimit_BattPrio;/* '<S947>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCNoRejection;/* '<S898>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCReject_BattPrio;/* '<S894>/Logical10' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCReject_PrecTmr_PlugIn;/* '<S1116>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCRejected;/* '<S16>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCRejected_AS;/* '<S16>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCRejection;/* '<S881>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCRejectionLimit_PlugIn;/* '<S882>/Logical4' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCRejection_BattPrio;/* '<S894>/Logical13' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCRejection_SOC_NoPlugIn;/* '<S881>/Logical8' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCRejection_SOC_PlugIn;/* '<S882>/Logical11' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCRejection_SOC_PwrBdgt_NoPlugIn;/* '<S891>/Logical11' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SOCRejection_SOC_PwrBdgt_PlugIn;/* '<S892>/Logical11' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SchCabPrecDnyRaw_BattCond;/* '<S7>/Logical8' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SchCond_WakeUp;/* '<S879>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SetLongTimerCond;/* '<S1114>/Logical5' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SetShortTmrCond;/* '<S1115>/Logical5' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SetShortTmrCond_Ltch;/* '<S1155>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SetShortTmrCond_PlugIn;/* '<S1116>/Logical5' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_SetShortTmrCond_Rst;/* '<S1115>/Logical12' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ThermalFltsPerWkUp;/* '<S1024>/Logical3' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ThrmLoad_Shed;/* '<S1773>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_TmrExpiredAfterDepTim;/* '<S241>/Logical6' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_TmrExpiredAfterDepTim_Msg;/* '<S514>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_TrackCharging;/* '<S775>/NOT1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_TrackCooling;/* '<S859>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_TrackHeating;/* '<S775>/NOT' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_TrigTm_PlugIn;/* '<S1266>/AND' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_TrunkAjarEnblLtch_KHC;/* '<S643>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_UnplugBattCond_SOC;/* '<S896>/Logical9' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_UnplugNoBattCond_SOC;/* '<S897>/Logical2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_V2LActv_SCCRSDsbl;/* '<S194>/Logical43' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_V2L_SCCRSDsbl_Msg;/* '<S509>/OR1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_WUpWaitBatCond_RSDndPrev;/* '<S1029>/Logical5' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_ePTBUSOff;/* '<S1340>/Logical1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(boolean, TPCR_VAR_INIT) VeTPCR_b_isStillCondEng_BatHot;/* '<S1569>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TePLTR_e_BCMPreCondCabinReq, TPCR_VAR_INIT)
    VeTPCR_e_BCMPreCondCabinReq;       /* '<S1764>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeHVTR_e_HV_BatCntctrStat, TPCR_VAR_INIT) VeTPCR_e_BatCntctrStat;/* '<S1772>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeBPCR_e_LOC_BatClntHtr, TPCR_VAR_INIT) VeTPCR_e_BattHtr_LOC;/* '<S1776>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeTPCR_e_CabinPreCondReqStat, TPCR_VAR_INIT)
    VeTPCR_e_CabReqSt_MsgAftrMap;      /* '<S9>/Selector' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeTPCR_e_CabinPreCondReqStat, TPCR_VAR_INIT)
    VeTPCR_e_CabReqSt_MsgBfrMap;       /* '<S501>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeOBCR_e_ChargingSystemSts, TPCR_VAR_INIT) VeTPCR_e_ChargingSystemSts;/* '<S1766>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeCITR_e_SchAllow, TPCR_VAR_INIT) VeTPCR_e_ClimateScheduleOption;/* '<S1778>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeTPCR_e_CabinPreCondReqStat, TPCR_VAR_INIT)
    VeTPCR_e_ClusterMsgFrmMemory;      /* '<S9>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeVTLR_e_DschrgSysSts, TPCR_VAR_INIT) VeTPCR_e_DschrgSysSts_AD;/* '<S1780>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeCITR_e_FOTA_Install_Type, TPCR_VAR_INIT) VeTPCR_e_FOTAInstallType;/* '<S1763>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeHTIR_e_HVC_HtrSts, TPCR_VAR_INIT) VeTPCR_e_HVC_HtrSts_AS;/* '<S1761>/Switch2' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeTPCR_e_KeepHotCold, TPCR_VAR_INIT) VeTPCR_e_KHCClusterMsg;/* '<S662>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeTPCR_e_KeepHotColdStatus, TPCR_VAR_INIT) VeTPCR_e_KHCStatus;/* '<S612>/UnitDelay4' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeBPCR_e_LOC_BCP, TPCR_VAR_INIT) VeTPCR_e_LTAP_LOC;/* '<S1777>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeSSDR_e_KeySts, TPCR_VAR_INIT) VeTPCR_e_PMM_PowerMode_AD;/* '<S1760>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeTPCR_e_SC_WakeUpSt, TPCR_VAR_INIT) VeTPCR_e_SchCond_WakeUp;/* '<S15>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TePLTR_e_ShipingMode, TPCR_VAR_INIT) VeTPCR_e_ShippingMode_AD;/* '<S1775>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(TeDMDR_e_TurtleMdSts, TPCR_VAR_INIT) VeTPCR_e_TurtleMd;/* '<S1774>/Switch' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(sint16, TPCR_VAR_INIT) VeTPCR_t_CondTime_AtShortDepTm;/* '<S1230>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(sint16, TPCR_VAR_INIT) VeTPCR_t_CondTime_AtShortDepTm_PlugIn;/* '<S1271>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(sint16, TPCR_VAR_INIT) VeTPCR_t_CondTime_ShortDepTm_SF;/* '<S1248>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(sint16, TPCR_VAR_INIT) VeTPCR_t_CondTime_ShortDepTm_SF_PlugIn;/* '<S1289>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(sint16, TPCR_VAR_INIT) VeTPCR_t_Long_PrecWkUpTmr_B4Sw;/* '<S1119>/Sum1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(sint16, TPCR_VAR_INIT) VeTPCR_t_PrecTmr_AftrMrg;/* '<S1023>/Merge' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(sint16, TPCR_VAR_INIT) VeTPCR_t_SchPrecTimer;/* '<S1328>/Switch1' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_t_WupTimer_PlugIn;/* '<S1288>/Gain' */

#endif

#if Rte_SysCon_Variant_TPCR_1

static VAR(float32, TPCR_VAR_INIT) VeTPCR_t_WupTimer_Short;/* '<S1247>/Gain' */

#endif

#define STOP_SEC_VAR_CLEARED_UNSPECIFIED_TPCR
#include "MemMap.h"

/* Constant parameters (default storage) */
#define START_SEC_CONST_UNSPECIFIED_TPCR
#include "MemMap.h"

CONST(ConstP_TPCR_ac_T, TPCR_VAR_INIT) TPCR_ac_ConstP =
{

#if Rte_SysCon_Variant_TPCR_1

    /* Computed Parameter: Vector_maxIndex
     * Referenced by: '<S821>/Vector'
     */
    {
        4U, 4U
    },

#endif

#if Rte_SysCon_Variant_TPCR_1

    /* Computed Parameter: Vector_maxIndex_e
     * Referenced by: '<S822>/Vector'
     */
    {
        4U, 6U
    },

#endif

#if Rte_SysCon_Variant_TPCR_1

    /* Computed Parameter: Vector_maxIndex_o
     * Referenced by: '<S823>/Vector'
     */
    {
        6U, 6U
    },

#endif

#if Rte_SysCon_Variant_TPCR_1

    /* Computed Parameter: Vector_maxIndex_f
     * Referenced by: '<S825>/Vector'
     */
    {
        7U, 5U
    },

#endif

#if Rte_SysCon_Variant_TPCR_1

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S817>/Vector'
     *   '<S818>/Vector'
     */
    {
        4U, 5U
    },

#endif

#if Rte_SysCon_Variant_TPCR_1

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S740>/Vector'
     *   '<S741>/Vector'
     *   '<S742>/Vector'
     *   '<S743>/Vector'
     *   '<S1062>/Vector'
     *   '<S1063>/Vector'
     *   '<S1242>/Vector'
     *   '<S1283>/Vector'
     */
    {
        6U, 7U
    },

#endif

#ifndef CONSTP_TPCR_AC_T_VARIANT_EXISTS

    0
#endif
};

#define STOP_SEC_CONST_UNSPECIFIED_TPCR
#include "MemMap.h"

/* Block signals (default storage) */
#define START_SEC_VAR_CLEARED_UNSPECIFIED_TPCR
#include "MemMap.h"

VAR(B_TPCR_ac_T, TPCR_VAR_INIT) TPCR_ac_B;

#define STOP_SEC_VAR_CLEARED_UNSPECIFIED_TPCR
#include "MemMap.h"

/* Block states (default storage) */
#define START_SEC_VAR_CLEARED_UNSPECIFIED_TPCR
#include "MemMap.h"

VAR(DW_TPCR_ac_T, TPCR_VAR_INIT) TPCR_ac_DW;

#define STOP_SEC_VAR_CLEARED_UNSPECIFIED_TPCR
#include "MemMap.h"
#if Rte_SysCon_Variant_TPCR_1

static FUNC(void, TPCR_CODE_LOCAL) TPCR_ac_MATLABFunction(VAR(sint16, AUTOMATIC)
    rtu_t_departure, VAR(float32, AUTOMATIC) rtu_T_ambient, VAR(float32,
    AUTOMATIC) rtu_T_oc, VAR(float32, AUTOMATIC) rtu_T_dc, VAR(float32,
    AUTOMATIC) rtu_R_Soak, VAR(float32, AUTOMATIC) rtu_R_Cond, VAR(sint16,
    AUTOMATIC) rtu_Dflt_Wup_Time, VAR(float32, AUTOMATIC)
    rtu_KeTPCR_k_SCCTimerCalcErr, VAR(float32, AUTOMATIC)
    rtu_KeTPCR_k_SCCTimerCalcIter, P2VAR(B_MATLABFunction_TPCR_ac_T, AUTOMATIC,
    TPCR_VAR_INIT) localB);

#endif

/*
 * Output and update for atomic system:
 *    '<S1223>/MATLABFunction'
 *    '<S1259>/MATLABFunction'
 */
#if Rte_SysCon_Variant_TPCR_1

static FUNC(void, TPCR_CODE_LOCAL) TPCR_ac_MATLABFunction(VAR(sint16, AUTOMATIC)
    rtu_t_departure, VAR(float32, AUTOMATIC) rtu_T_ambient, VAR(float32,
    AUTOMATIC) rtu_T_oc, VAR(float32, AUTOMATIC) rtu_T_dc, VAR(float32,
    AUTOMATIC) rtu_R_Soak, VAR(float32, AUTOMATIC) rtu_R_Cond, VAR(sint16,
    AUTOMATIC) rtu_Dflt_Wup_Time, VAR(float32, AUTOMATIC)
    rtu_KeTPCR_k_SCCTimerCalcErr, VAR(float32, AUTOMATIC)
    rtu_KeTPCR_k_SCCTimerCalcIter, P2VAR(B_MATLABFunction_TPCR_ac_T, AUTOMATIC,
    TPCR_VAR_INIT) localB)
{
    float32 Error;
    float32 Iteration;
    float32 LeTPCR_T_A;
    float32 LeTPCR_T_B;
    float32 LeTPCR_T_Cabin_Temp_dlt;
    float32 LeTPCR_t_depart;
    float32 R_Cond;
    float32 tc_scaled;
    sint16 LeTPCR_e_Debug_TmrSrc;
    boolean guard1 = false;

    /* MATLAB Function 'TPCR_MedTEH/TPCC_Controls/Timer_PerWkup_CabCond/ScheduledPreCondition_Controls/PreCond_ShortTmr_NMWup/EnblCond_PreCondShortTmr/MATLABFunction': '<S1244>:1' */
    /* '<S1244>:1:3' */
    LeTPCR_t_depart = ((float32)rtu_t_departure) * 60.0F;

    /* '<S1244>:1:4' */
    localB->LeTPCR_e_Debug_TmrSrc = 0;
    if (rtu_T_ambient <= rtu_T_dc)
    {
        /* '<S1244>:1:8' */
        /* '<S1244>:1:9' */
        R_Cond = rtu_R_Cond;
    }
    else
    {
        /* '<S1244>:1:11' */
        R_Cond = -rtu_R_Cond;
    }

    /* '<S1244>:1:15' */
    LeTPCR_T_A = (rtu_T_dc - (R_Cond * LeTPCR_t_depart)) - rtu_T_ambient;

    /* '<S1244>:1:16' */
    LeTPCR_T_B = rtu_T_oc - rtu_T_ambient;

    /* '<S1244>:1:17' */
    Iteration = 1.0F;
    if (LeTPCR_t_depart != 0.0F)
    {
        /* '<S1244>:1:18' */
        guard1 = false;
        if (((rtu_T_ambient <= rtu_T_oc) && (rtu_T_ambient <= rtu_T_dc)) ||
                ((rtu_T_ambient >= rtu_T_oc) && (rtu_T_ambient >= rtu_T_dc)))
        {
            /* '<S1244>:1:19' */
            /* '<S1244>:1:21' */
            tc_scaled = 1200.0F;

            /* '<S1244>:1:27' */
            Error = 1.0F;

            /* '<S1244>:1:28' */
            while ((Error > rtu_KeTPCR_k_SCCTimerCalcErr) && (Iteration <
                    rtu_KeTPCR_k_SCCTimerCalcIter))
            {
                /* '<S1244>:1:30' */
                /* '<S1244>:1:31' */
                LeTPCR_T_Cabin_Temp_dlt = expf((-rtu_R_Soak) * tc_scaled);
                Error = ((R_Cond * tc_scaled) + LeTPCR_T_A) - (LeTPCR_T_B *
                    LeTPCR_T_Cabin_Temp_dlt);

                /* '<S1244>:1:32' */
                LeTPCR_T_Cabin_Temp_dlt = ((LeTPCR_T_B * rtu_R_Soak) *
                    LeTPCR_T_Cabin_Temp_dlt) + R_Cond;

                /* '<S1244>:1:33' */
                Error /= LeTPCR_T_Cabin_Temp_dlt;
                tc_scaled -= Error;

                /* '<S1244>:1:34' */
                Error = fabsf(Error);

                /* '<S1244>:1:35' */
                Iteration++;
            }

            /* '<S1244>:1:37' */
            /* '<S1244>:1:38' */
            R_Cond = roundf((LeTPCR_t_depart - tc_scaled) / 60.0F);
            if (R_Cond < 32768.0F)
            {
                if (R_Cond >= -32768.0F)
                {
                    LeTPCR_e_Debug_TmrSrc = (sint16)R_Cond;
                }
                else
                {
                    LeTPCR_e_Debug_TmrSrc = MIN_int16_T;
                }
            }
            else
            {
                LeTPCR_e_Debug_TmrSrc = MAX_int16_T;
            }

            if (LeTPCR_e_Debug_TmrSrc <= 0)
            {
                /* '<S1244>:1:40' */
                /* '<S1244>:1:41' */
                localB->LeTPCR_e_Debug_TmrSrc = 2;

                /* '<S1244>:1:51' */
                /* '<S1244>:1:52' */
                localB->Cond_Time = (sint16)roundf(fminf((float32)
                    rtu_Dflt_Wup_Time, LeTPCR_t_depart) / 60.0F);
            }
            else if (((sint32)LeTPCR_e_Debug_TmrSrc) >= ((sint32)roundf
                      (LeTPCR_t_depart / 60.0F)))
            {
                /* '<S1244>:1:40' */
                /* '<S1244>:1:41' */
                localB->LeTPCR_e_Debug_TmrSrc = 2;

                /* '<S1244>:1:51' */
                /* '<S1244>:1:52' */
                localB->Cond_Time = (sint16)roundf(fminf((float32)
                    rtu_Dflt_Wup_Time, LeTPCR_t_depart) / 60.0F);
            }
            else
            {
                /* '<S1244>:1:43' */
                localB->LeTPCR_e_Debug_TmrSrc = 1;
                guard1 = true;
            }
        }
        else
        {
            /* '<S1244>:1:47' */
            localB->LeTPCR_e_Debug_TmrSrc = 3;

            /* '<S1244>:1:48' */
            tc_scaled = LeTPCR_t_depart - fminf(LeTPCR_t_depart, (float32)
                rtu_Dflt_Wup_Time);
            guard1 = true;
        }

        if (guard1)
        {
            /* '<S1244>:1:54' */
            R_Cond = roundf((LeTPCR_t_depart - tc_scaled) / 60.0F);
            if (R_Cond < 32768.0F)
            {
                if (R_Cond >= -32768.0F)
                {
                    localB->Cond_Time = (sint16)R_Cond;
                }
                else
                {
                    localB->Cond_Time = MIN_int16_T;
                }
            }
            else
            {
                localB->Cond_Time = MAX_int16_T;
            }
        }
    }
    else
    {
        /* '<S1244>:1:58' */
        tc_scaled = 0.0F;

        /* '<S1244>:1:59' */
        localB->Cond_Time = 0;
    }

    localB->Wup_Timer = tc_scaled;
    localB->Iteration = Iteration;
}

#endif

/* Model step function for TID1 */
#if Rte_SysCon_Variant_TPCR_1

FUNC(void, TPCR_CODE) TPCR_MedTEH(void) /* Explicit Task: MedTEH */
{

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_LogicalOperator_h0;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_LogicalOperator_bpb;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_LogicalOperator1_c;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_VariantMerge_For_Variant__n;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_Gain_g;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_Switch1_eo;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_Switch3_c2;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_Switch2_nq;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_Switch_e;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_Switch_a5;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_VariantMerge_For_Variant_So;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_VariantMerge_For_Variant__i;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_Comparison5;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_RelationalOperator1_dfl;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_UnitDelay_l3;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_Comparison1_pa;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_AND_gq3;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_NotEqual_p;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_LogicalOperator_gy;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_UnitDelay4_k;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_Switch2_du;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_RelationalOperator_k;

#endif

#if Rte_SysCon_Variant_TPCR_1

    sint16 rtb_Abs_o;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_Switch1_im;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_Switch3_o;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_OR1_d5;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_UnitDelay_jk;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_Switch1_mw;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_Switch1_cs;

#endif

#if Rte_SysCon_Variant_TPCR_1

    float32 rtb_Sum4_l;

#endif

#if Rte_SysCon_Variant_TPCR_1

    float32 rtb_Switch1_l4;

#endif

#if Rte_SysCon_Variant_TPCR_1

    float32 rtb_Switch1_ml1;

#endif

#if Rte_SysCon_Variant_TPCR_1

    uint16 rtb_Switch1_g1;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_OR1_ksz;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_OR1_lo;

#endif

#if Rte_SysCon_Variant_TPCR_1

    sint8 rtPrevAction;

#endif

#if Rte_SysCon_Variant_TPCR_1

    sint8 rtAction;

#endif

#if Rte_SysCon_Variant_TPCR_1

    float32 rtb_Switch1_jb;

#endif

#if Rte_SysCon_Variant_TPCR_1

    float32 rtb_Switch1_kc2;

#endif

#if Rte_SysCon_Variant_TPCR_1

    float32 rtb_Switch1;

#endif

#if Rte_SysCon_Variant_TPCR_1

    float32 rtb_Switch1_ox;

#endif

#if Rte_SysCon_Variant_TPCR_1

    float32 rtb_Product1_d;

#endif

#if Rte_SysCon_Variant_TPCR_1

    float32 rtb_Subtraction_p;

#endif

#if Rte_SysCon_Variant_TPCR_1

    float32 rtb_Vector_ap;

#endif

#if Rte_SysCon_Variant_TPCR_1

    float32 rtb_Switch1_g;

#endif

#if Rte_SysCon_Variant_TPCR_1

    float32 rtb_Switch1_ko;

#endif

#if Rte_SysCon_Variant_TPCR_1

    float32 rtb_Switch1_e4x;

#endif

#if Rte_SysCon_Variant_TPCR_1

    uint16 rtb_Switch1_a;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeTPCR_e_KeepHotColdStatus rtb_Switch1_dk;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeTPCR_e_PerWup_BattEngCond rtb_Switch1_io;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean Gain_fm;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeHTIR_e_HVC_HtrSts Switch1_e;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeTPCR_e_ProactiveCondMode Switch1_d;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeTPCR_e_CabinPreCondReqStat Switch_cl;

#endif

#if Rte_SysCon_Variant_TPCR_1

    sint32 tmp;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeTPCR_e_ThrmPerWup_State tmp_0;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeTPCR_e_SC_WakeUpSt tmp_1;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeTPCR_e_KeepHotCold tmp_2;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeTPCR_e_ProactiveCondMode tmp_3;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeTPCR_e_ProactiveCondStatus tmp_4;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeTPCR_e_RacePrepState tmp_5;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeBTRR_e_BatCritCondSt rtb_Switch3_dh_tmp;

#endif

#if Rte_SysCon_Variant_TPCR_1

    uint32 rtb_Switch_cw_tmp;

#endif

#if Rte_SysCon_Variant_TPCR_1

    uint32 rtb_Switch_cw_tmp_0;

#endif

#if Rte_SysCon_Variant_TPCR_1

    uint32 rtb_Switch_cw_tmp_1;

#endif

#if Rte_SysCon_Variant_TPCR_1

    uint32 rtb_Switch_cw_tmp_2;

#endif

#if Rte_SysCon_Variant_TPCR_1

    uint32 rtb_Switch_cw_tmp_3;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeRCVR_e_Valve_Stuck_Status rtb_Switch_cw_tmp_4;

#endif

#if Rte_SysCon_Variant_TPCR_1

    sint32 rtb_Switch_cw_tmp_5;

#endif

#if Rte_SysCon_Variant_TPCR_1

    uint32 rtb_Switch_cw_tmp_6;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeTPCR_e_KeepHotColdStatus rtb_VariantMerge_For_Variant__1;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_VariantMerge_For_Variant__2;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_VariantMerge_For_Variant__3;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_VariantMerge_For_Variant__4;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeTHMR_e_BatThrmlSt VeTPCR_b_BattThrmlSt_Cond_tmp;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeOBCR_e_ChargingLevel VeTPCC_b_VhclPlgdIn_tmp;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_LogicalOperator1_kl_tmp;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean VeTPCR_b_UnplugNoBattCond_SOC_t;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean VeTPCR_b_BCC_CellUnderTmpChk_tm;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean VeTPCR_b_SetLongTimerCond_tmp;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean VeTPCR_b_DoorAjarEnblLtch_Rst_t;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean VeTPCC_b_RS_NoCabPrecond_NoPl_0;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean VeTPCC_b_RS_NoCabPrecond_NoPl_1;

#endif

#if Rte_SysCon_Variant_TPCR_1

    boolean rtb_UnitDelay_gcx_tmp;

#endif

#if Rte_SysCon_Variant_TPCR_1

    sint32 rtb_Switch_cw_tmp_7;

#endif

#if Rte_SysCon_Variant_TPCR_1

    uint32 rtb_Switch_cw_tmp_8;

#endif

#if Rte_SysCon_Variant_TPCR_1

    sint32 rtb_Switch_cw_tmp_9;

#endif

#if Rte_SysCon_Variant_TPCR_1

    uint32 rtb_Switch_cw_tmp_a;

#endif

#if Rte_SysCon_Variant_TPCR_1

    uint32 rtb_Switch_cw_tmp_b;

#endif

#if Rte_SysCon_Variant_TPCR_1

    sint32 rtb_Switch_cw_tmp_c;

#endif

#if Rte_SysCon_Variant_TPCR_1

    uint32 rtb_Switch_cw_tmp_d;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TePMPR_e_FTSNA rtb_Switch_cw_tmp_e;

#endif

#if Rte_SysCon_Variant_TPCR_1

    uint32 rtb_Switch_cw_tmp_f;

#endif

#if Rte_SysCon_Variant_TPCR_1

    uint32 rtb_Switch_cw_tmp_g;

#endif

#if Rte_SysCon_Variant_TPCR_1

    TeRCVR_e_Valve_Stuck_Status rtb_RelationalOperator1_ol_tmp;

#endif

#if Rte_SysCon_Variant_TPCR_1

    float32 rtb_Sum4_a_tmp;

#endif

#if Rte_SysCon_Variant_TPCR_1

    float32 rtb_Switch1_bv_tmp;

#endif

#if Rte_SysCon_Variant_TPCR_1

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */
    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeSSDR_b_PrepareToShtdwn'
     */
    (void)Rte_Read_VeSSDR_b_PrepareToShtdwn_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lo);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VePLTR_e_ShippingMode'
     */
    (void)Rte_Read_VePLTR_e_ShippingMode_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_go);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeENGR_T_EngCoolantTemp'
     */
    (void)Rte_Read_VeENGR_T_EngCoolantTemp_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_FcnC);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeENGR_b_ECT_SnsrFA'
     */
    (void)Rte_Read_VeENGR_b_ECT_SnsrFA_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_oh);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeENGR_b_ECT_Sgnl_Rcvd'
     */
    (void)Rte_Read_VeENGR_b_ECT_Sgnl_Rcvd_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_e5);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VePLTR_b_RmtVehStartReq'
     */
    (void)Rte_Read_VePLTR_b_RmtVehStartReq_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_m2);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeSSDR_e_KeySts'
     */
    (void)Rte_Read_VeSSDR_e_KeySts_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kw);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeHTIR_e_HV_ElecClntHtr_Sts'
     */
    (void)Rte_Read_VeHTIR_e_HV_ElecClntHtr_Sts_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ka);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBPCR_Pct_HV_BatPackSOC_Arb'
     */
    (void)Rte_Read_VeBPCR_Pct_HV_BatPackSOC_Arb_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_l);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeOBCR_e_ChargingSystemSts'
     */
    (void)Rte_Read_VeOBCR_e_ChargingSystemSts_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ic);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeOBCR_P_Est_PowerBudget'
     */
    (void)Rte_Read_VeOBCR_P_Est_PowerBudget_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_k);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeHTIR_e_HV_ElecClntHtr2_Sts'
     */
    (void)Rte_Read_VeHTIR_e_HV_ElecClntHtr2_Sts_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ow);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeOBCR_b_ChrgSysFault'
     */
    (void)Rte_Read_VeOBCR_b_ChrgSysFault_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ov);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTHMR_T_MaxBattAllow'
     */
    (void)Rte_Read_VeTHMR_T_MaxBattAllow_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_n);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBPCR_e_HV_BatCntctrStat'
     */
    (void)Rte_Read_VeBPCR_e_HV_BatCntctrStat_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_fw);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeSRAR_b_ThmlLoadShdActv'
     */
    (void)Rte_Read_VeSRAR_b_ThmlLoadShdActv_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM__ovl);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMDR_e_TurtleMdSts'
     */
    (void)Rte_Read_VeDMDR_e_TurtleMdSts_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM__af1);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTRIR_b_SCCActv'
     */
    (void)Rte_Read_VeTRIR_b_SCCActv_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_f);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBPCR_e_BPCM_LOC_BCP'
     */
    (void)Rte_Read_VeBPCR_e_BPCM_LOC_BCP_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ae);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBPCR_e_BPCM_LOC_BatClntHtr'
     */
    (void)Rte_Read_VeBPCR_e_BPCM_LOC_BatClntHtr_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM__esi);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBPCR_b_BPCM_LOC_BCP_FA'
     */
    (void)Rte_Read_VeBPCR_b_BPCM_LOC_BCP_FA_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ar);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBPCR_b_BPCM_LOC_BatClntHtr_FA'
     */
    (void)Rte_Read_VeBPCR_b_BPCM_LOC_BatClntHtr_FA_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ft);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeOBCR_P_AvalPwrForThmr'
     */
    (void)Rte_Read_VeOBCR_P_AvalPwrForThmr_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_c);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeHTIR_e_HV_ElecClntHtr3_Sts'
     */
    (void)Rte_Read_VeHTIR_e_HV_ElecClntHtr3_Sts_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_o3);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeHTIR_e_HV_ElecClntHtr4_Sts'
     */
    (void)Rte_Read_VeHTIR_e_HV_ElecClntHtr4_Sts_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nr);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeHCDR_b_HVC_Heater_FltDtct'
     */
    (void)Rte_Read_VeHCDR_b_HVC_Heater_FltDtct_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_oc);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeHCDR_b_HV_Heater2_FltDtct'
     */
    (void)Rte_Read_VeHCDR_b_HV_Heater2_FltDtct_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pv);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeSCPR_T_CabinTempSetPt'
     */
    (void)Rte_Read_VeSCPR_T_CabinTempSetPt_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_n0);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeSCPR_e_SchCP_Allow'
     */
    (void)Rte_Read_VeSCPR_e_SchCP_Allow_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ne);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeSSDR_b_HVBatPerWU12VChrg'
     */
    (void)Rte_Read_VeSSDR_b_HVBatPerWU12VChrg_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pr);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' */
#if !Rte_SysCon_Variant_TPCR_3 && Rte_SysCon_Variant_TPCR_1

    /* VariantMerge generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTMIR_b_MainRly_CmdReq'
     */
    (void)Rte_Read_VeTMIR_b_MainRly_CmdReq_Value
        (&TPCR_ac_B.VM_Conditional_Signal_TmpVM_Fcn);

#elif !(!Rte_SysCon_Variant_TPCR_3) && Rte_SysCon_Variant_TPCR_1

    /* VariantMerge generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' */
    TPCR_ac_B.VM_Conditional_Signal_TmpVM_Fcn = false;

#endif

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' */
#if Rte_SysCon_Variant_TPCR_1 && Rte_SysCon_Variant_TPCR_3

    /* VariantMerge generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VePMTR_b_ThrmlSystRly_EnblCmnd'
     */
    (void)Rte_Read_VePMTR_b_ThrmlSystRly_EnblCmnd_Value
        (&TPCR_ac_B.VM_Conditional_Signal_TmpVM_F_m);

#endif

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeCITR_e_FOTA_Install_Type'
     */
    (void)Rte_Read_VeCITR_e_FOTA_Install_Type_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_j5);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' */
#if !Rte_SysCon_Variant_TPCR_3 && Rte_SysCon_Variant_TPCR_1

    /* VariantMerge generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' */
    TPCR_ac_B.VM_Conditional_Signal_TmpVM_F_m = false;

    /* VariantMerge generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBSWR_b_VehDynaCMPwrRlyCktShotoGnd'
     */
    (void)Rte_Read_VeBSWR_b_VehDynaCMPwrRlyCktShotoGnd_Value
        (&TPCR_ac_B.VM_Conditional_Signal_TmpVM__mv);

    /* VariantMerge generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBSWR_b_VehDynaCMPwrRlyCktShotoBatt'
     */
    (void)Rte_Read_VeBSWR_b_VehDynaCMPwrRlyCktShotoBatt_Value
        (&TPCR_ac_B.VM_Conditional_Signal_TmpVM_F_e);

#elif !(!Rte_SysCon_Variant_TPCR_3) && Rte_SysCon_Variant_TPCR_1

    /* VariantMerge generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' */
    TPCR_ac_B.VM_Conditional_Signal_TmpVM__mv = false;

#endif

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' */
#if !Rte_SysCon_Variant_TPCR_3 && Rte_SysCon_Variant_TPCR_1

    /* VariantMerge generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBSWR_b_VehDynaCMPwrRlyCktHi'
     */
    (void)Rte_Read_VeBSWR_b_VehDynaCMPwrRlyCktHi_Value
        (&TPCR_ac_B.VM_Conditional_Signal_TmpVM_F_p);

#elif !(!Rte_SysCon_Variant_TPCR_3) && Rte_SysCon_Variant_TPCR_1

    /* VariantMerge generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' */
    TPCR_ac_B.VM_Conditional_Signal_TmpVM_F_e = false;

#endif

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' */
#if !Rte_SysCon_Variant_TPCR_3 && Rte_SysCon_Variant_TPCR_1

    /* VariantMerge generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBSWR_b_VehDynaCMPwrRlyCktLo'
     */
    (void)Rte_Read_VeBSWR_b_VehDynaCMPwrRlyCktLo_Value
        (&TPCR_ac_B.VM_Conditional_Signal_TmpVM_F_a);

#elif !(!Rte_SysCon_Variant_TPCR_3) && Rte_SysCon_Variant_TPCR_1

    /* VariantMerge generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' */
    TPCR_ac_B.VM_Conditional_Signal_TmpVM_F_p = false;

    /* VariantMerge generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' */
    TPCR_ac_B.VM_Conditional_Signal_TmpVM_F_a = false;

#endif

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeVTLR_e_DschrgSysSts'
     */
    (void)Rte_Read_VeVTLR_e_DschrgSysSts_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM__fta);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeSSDR_b_HVBatPerWUThermal'
     */
    (void)Rte_Read_VeSSDR_b_HVBatPerWUThermal_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_dc);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeHCDR_e_BatteryThermalFault'
     */
    (void)Rte_Read_VeHCDR_e_BatteryThermalFault_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_fo);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeOBCR_e_ChargingLevel'
     */
    (void)Rte_Read_VeOBCR_e_ChargingLevel_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lm);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeAATR_T_EstAmbAirTemp'
     */
    (void)Rte_Read_VeAATR_T_EstAmbAirTemp_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBTRR_dT_CellUnderTemp'
     */
    (void)Rte_Read_VeBTRR_dT_CellUnderTemp_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBTRR_T_CellTempMinUsed'
     */
    (void)Rte_Read_VeBTRR_T_CellTempMinUsed_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lp);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTMIR_T_ElecClntHtr_TmpIn'
     */
    (void)Rte_Read_VeTMIR_T_ElecClntHtr_TmpIn_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_h);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTMIR_b_ElecClntHtr_TmpIn_FA'
     */
    (void)Rte_Read_VeTMIR_b_ElecClntHtr_TmpIn_FA_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_l0);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBTRR_e_HV_BatTempCrit_CondState_New'
     */
    (void)Rte_Read_VeBTRR_e_HV_BatTempCrit_CondState_New_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM__gr1);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeCTRR_b_HVAC_HeatReq'
     */
    (void)Rte_Read_VeCTRR_b_HVAC_HeatReq_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ba);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTAIR_b_ACCompReq'
     */
    (void)Rte_Read_VeTAIR_b_ACCompReq_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM__mj3);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTRIR_b_HtrCorClnt_TmpIn_FA'
     */
    (void)Rte_Read_VeTRIR_b_HtrCorClnt_TmpIn_FA_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_hb);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeAATR_b_EstAmbAirTempFA'
     */
    (void)Rte_Read_VeAATR_b_EstAmbAirTempFA_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_a0);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTHMR_e_BatThrmlSt'
     */
    (void)Rte_Read_VeTHMR_e_BatThrmlSt_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ih);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeFSCR_b_HVFuncRejHdAjar'
     */
    (void)Rte_Read_VeFSCR_b_HVFuncRejHdAjar_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gr);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeSCPR_t_TimeToDeparture'
     */
    (void)Rte_Read_VeSCPR_t_TimeToDeparture_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeSSDR_b_HV_PerWU_CabinPre'
     */
    (void)Rte_Read_VeSSDR_b_HV_PerWU_CabinPre_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM__l25);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTAIR_T_VhIntTmp'
     */
    (void)Rte_Read_VeTAIR_T_VhIntTmp_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_b);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTRIR_e_HVACSt'
     */
    (void)Rte_Read_VeTRIR_e_HVACSt_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM__ate);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTHMR_b_DrvDrAjar'
     */
    (void)Rte_Read_VeTHMR_b_DrvDrAjar_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_md);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeSCPR_b_BattCabinPriority'
     */
    (void)Rte_Read_VeSCPR_b_BattCabinPriority_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gt);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTAIR_b_VhIntTmp_FA'
     */
    (void)Rte_Read_VeTAIR_b_VhIntTmp_FA_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_m3);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeHPMR_b_PropSysActv'
     */
    (void)Rte_Read_VeHPMR_b_PropSysActv_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM__cvk);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBTRR_dT_CellOverTemp'
     */
    (void)Rte_Read_VeBTRR_dT_CellOverTemp_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_g);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBTRR_T_CellTempMaxUsed'
     */
    (void)Rte_Read_VeBTRR_T_CellTempMaxUsed_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_du);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VePMIR_e_LTActvPumpDryRun'
     */
    (void)Rte_Read_VePMIR_e_LTActvPumpDryRun_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ag);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VePMIR_b_LTActvPumpDryRun_FA'
     */
    (void)Rte_Read_VePMIR_b_LTActvPumpDryRun_FA_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ci);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VePMIR_e_HTAuxPumpDryRun'
     */
    (void)Rte_Read_VePMIR_e_HTAuxPumpDryRun_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ec);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VePMIR_b_HTAuxPumpDryRun_FA'
     */
    (void)Rte_Read_VePMIR_b_HTAuxPumpDryRun_FA_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_fi);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' */
#if Rte_SysCon_Variant_TPCR_1 && Rte_SysCon_Variant_TPCR_26

    /* VariantMerge generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeFSCR_b_RadFan_FltDtct'
     */
    (void)Rte_Read_VeFSCR_b_RadFan_FltDtct_Value
        (&TPCR_ac_B.VM_Conditional_Signal_TmpVM__a4);

#elif !Rte_SysCon_Variant_TPCR_26 && Rte_SysCon_Variant_TPCR_1

    /* VariantMerge generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' */
    TPCR_ac_B.VM_Conditional_Signal_TmpVM__a4 = false;

#endif

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTRIR_b_Comfort_EnblAct'
     */
    (void)Rte_Read_VeTRIR_b_Comfort_EnblAct_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_hl);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTRIR_b_KeepHotColdButtonStatus'
     */
    (void)Rte_Read_VeTRIR_b_KeepHotColdButtonStatus_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_en);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTRIR_b_TrunkStatus'
     */
    (void)Rte_Read_VeTRIR_b_TrunkStatus_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_fa);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTRIR_b_LoadShed'
     */
    (void)Rte_Read_VeTRIR_b_LoadShed_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM__m2t);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeCITR_P_ChargingDestinationPwr'
     */
    (void)Rte_Read_VeCITR_P_ChargingDestinationPwr_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_a);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeCITR_t_TimeToCharge'
     */
    (void)Rte_Read_VeCITR_t_TimeToCharge_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_b4);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeCITR_l_DistanceToCharge'
     */
    (void)Rte_Read_VeCITR_l_DistanceToCharge_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_l2);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeERER_l_EstRange'
     */
    (void)Rte_Read_VeERER_l_EstRange_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_i);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTHMR_b_BattAllowed'
     */
    (void)Rte_Read_VeTHMR_b_BattAllowed_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ok);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTHMR_T_PPCTIS_Arb'
     */
    (void)Rte_Read_VeTHMR_T_PPCTIS_Arb_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_p);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeCITR_b_ChargingDestinationPwr_FA'
     */
    (void)Rte_Read_VeCITR_b_ChargingDestinationPwr_FA_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_c5);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeCITR_b_TimeToCharge_FA'
     */
    (void)Rte_Read_VeCITR_b_TimeToCharge_FA_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_iz);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeCITR_b_DistanceToCharge_FA'
     */
    (void)Rte_Read_VeCITR_b_DistanceToCharge_FA_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_h3);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeENGR_b_EngSysLowFuel'
     */
    (void)Rte_Read_VeENGR_b_EngSysLowFuel_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_hq);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VePLTR_b_HotEnablerReq'
     */
    (void)Rte_Read_VePLTR_b_HotEnablerReq_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nw);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_HiSpdCANCommBus'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_HiSpdCANCommBus_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_da);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommBCM'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommBCM_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lj);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CT2_SnsrCktHi'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CT2_SnsrCktHi_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_iv);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CT2_SnsrCktLo'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CT2_SnsrCktLo_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_j);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CT2_SnsrPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CT2_SnsrPerf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_l1);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolPmpATempSnsrPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolPmpATempSnsrPerf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_jv);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantVlvB_CktHi'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantVlvB_CktHi_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_e);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantVlvB_CktLo'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantVlvB_CktLo_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_m);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantVlvB_Ckt'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantVlvB_Ckt_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_cv);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantVlvB_StkClsd'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantVlvB_StkClsd_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_cm);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_ECH_TempIn'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_ECH_TempIn_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_dz);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_ECH_TempOut'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_ECH_TempOut_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_jp);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommCoolHtrA'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommCoolHtrA_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ai);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommHighVolCabinAirHtr'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommHighVolCabinAirHtr_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_n1);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolPmpACtrlCktPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolPmpACtrlCktPerf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_is);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LIN2_BusOff'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LIN2_BusOff_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_im);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommCoolPmpA'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommCoolPmpA_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ho);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolHeaterAPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolHeaterAPerf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lw);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_HighVolCabinAirHtrperf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_HighVolCabinAirHtrperf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nc);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_EACPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_EACPerf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_mx);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommEAC'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommEAC_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_al);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_EvapRefriShutoffCtrlCktFlt'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_EvapRefriShutoffCtrlCktFlt_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ee);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_EvapRefriShutoffCtrlshrtBattFlt'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_EvapRefriShutoffCtrlshrtBattFlt_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_af);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_EvapRefrishutoffCtrlShrtGndFlt'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_EvapRefrishutoffCtrlShrtGndFlt_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gh);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigPresSnsrAHi'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigPresSnsrAHi_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ch);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigPresSnsrALo'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigPresSnsrALo_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_dg);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigPresSnsrAPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigPresSnsrAPerf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_mu);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CommBusOff'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CommBusOff_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nm);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CommBus_B_Off'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CommBus_B_Off_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lf);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_BattCoolPmpHtrBTempSnsrPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_BattCoolPmpHtrBTempSnsrPerf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kt);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_BattHeat'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_BattHeat_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM__lwp);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantHeaterBPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantHeaterBPerf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_es);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_HeatingElmntPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_HeatingElmntPerf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_o);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LosCommBECM_A_CANC11'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LosCommBECM_A_CANC11_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_p1);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LosCommBECM_A'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LosCommBECM_A_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_dq);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantVlvA_CktHi'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantVlvA_CktHi_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_dr);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantVlvA_CktLo'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantVlvA_CktLo_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_mj);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantVlvA_Ckt'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantVlvA_Ckt_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_a2);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantVlvA_Perf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantVlvA_Perf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ey);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_BattCoolPmpATempSnsrPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_BattCoolPmpATempSnsrPerf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ha);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_BattCoolPmpPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_BattCoolPmpPerf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_at);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_BattCoolLvlLow'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_BattCoolLvlLow_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_m1);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_BattCoolLvlSnsCkt'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_BattCoolLvlSnsCkt_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_jm);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolOutTempSnsCkt'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolOutTempSnsCkt_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ao);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_HB_CT_SnsrPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_HB_CT_SnsrPerf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gb);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_ThrmlRlyCtrlCkt'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_ThrmlRlyCtrlCkt_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_et);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTIMR_e_RacePrep'
     */
    (void)Rte_Read_VeTIMR_e_RacePrep_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_op);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTIMR_e_RacePrepRaceTypeSts'
     */
    (void)Rte_Read_VeTIMR_e_RacePrepRaceTypeSts_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_l4);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeHMIR_e_HEV_LMP_RQ'
     */
    (void)Rte_Read_VeHMIR_e_HEV_LMP_RQ_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_iq);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeSRAR_b_Disable_RaceStart'
     */
    (void)Rte_Read_VeSRAR_b_Disable_RaceStart_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gq);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeCSVR_v_VehSpd'
     */
    (void)Rte_Read_VeCSVR_v_VehSpd_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_p5);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTHMR_e_CabHeatThermalState'
     */
    (void)Rte_Read_VeTHMR_e_CabHeatThermalState_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_il);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTHMR_e_CabCoolThermalState'
     */
    (void)Rte_Read_VeTHMR_e_CabCoolThermalState_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_fy);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeTAIR_Pct_FrtBlwrCmd'
     */
    (void)Rte_Read_VeTAIR_Pct_FrtBlwrCmd_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_k0);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeHVTR_I_HV_BattCurrent'
     */
    (void)Rte_Read_VeHVTR_I_HV_BattCurrent_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lh);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBTRR_T_BTISBTIS2_Max'
     */
    (void)Rte_Read_VeBTRR_T_BTISBTIS2_Max_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_b1);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeBTRR_T_CellTempAvgUsed'
     */
    (void)Rte_Read_VeBTRR_T_CellTempAvgUsed_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pm);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LIN3_BusOff'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LIN3_BusOff_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pq);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LIN1_BusOff'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LIN1_BusOff_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_bi);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommHB_CoolPmp'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommHB_CoolPmp_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ad);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_BattCoolPmpOveSpd'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_BattCoolPmpOveSpd_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM__a24);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_BattCool'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_BattCool_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_oi);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_CoolantVlvB_StkOpn'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_CoolantVlvB_StkOpn_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gm);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommACRefrigExpVlvActA'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommACRefrigExpVlvActA_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ds);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeVLDR_b_EXV_PerfDiag_FltDtct'
     */
    (void)Rte_Read_VeVLDR_b_EXV_PerfDiag_FltDtct_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pe);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeVLDR_b_EXV_TempElctrFlt_FltDtct'
     */
    (void)Rte_Read_VeVLDR_b_EXV_TempElctrFlt_FltDtct_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_hw);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeVLDR_b_EXV_PressElctrFlt_FltDtct'
     */
    (void)Rte_Read_VeVLDR_b_EXV_PressElctrFlt_FltDtct_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gf);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeVLDR_b_EXV_PressSens_FltDtct'
     */
    (void)Rte_Read_VeVLDR_b_EXV_PressSens_FltDtct_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_dd);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeVLDR_b_EXV_TempSens_FltDtct'
     */
    (void)Rte_Read_VeVLDR_b_EXV_TempSens_FltDtct_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_mc);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeRCVR_e_CPV_Valve_Stuck_State'
     */
    (void)Rte_Read_VeRCVR_e_CPV_Valve_Stuck_State_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lq);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigTempSnsrCPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigTempSnsrCPerf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_jf);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommACRefrigExpVlvActC'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommACRefrigExpVlvActC_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_oo);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeVLDR_b_EEXV_TempElctrFlt_FltDtct'
     */
    (void)Rte_Read_VeVLDR_b_EEXV_TempElctrFlt_FltDtct_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ln);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeVLDR_b_EEXV_PressElctrFlt_FltDtct'
     */
    (void)Rte_Read_VeVLDR_b_EEXV_PressElctrFlt_FltDtct_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_om);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeVLDR_b_EEXV_PressSens_FltDtct'
     */
    (void)Rte_Read_VeVLDR_b_EEXV_PressSens_FltDtct_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pg);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeVLDR_b_EEXV_PerfDiag_FltDtct'
     */
    (void)Rte_Read_VeVLDR_b_EEXV_PerfDiag_FltDtct_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_hi);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_LostCommACRefrigExpVlvActD'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_LostCommACRefrigExpVlvActD_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_og);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigTempSnsr4CktPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigTempSnsr4CktPerf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM__knr);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeDMAB_y_StatusByte_AC_RefrigTempSnsr5CktPerf'
     */
    (void)Rte_Read_VeDMAB_y_StatusByte_AC_RefrigTempSnsr5CktPerf_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM__mu4);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeVLDR_b_OEXV_PressElctrFlt_FltDtct'
     */
    (void)Rte_Read_VeVLDR_b_OEXV_PressElctrFlt_FltDtct_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_mo);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeVLDR_b_OEXV_PressSens_FltDtct'
     */
    (void)Rte_Read_VeVLDR_b_OEXV_PressSens_FltDtct_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_i3);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeVLDR_b_OEXV_PerfDiag_FltDtct'
     */
    (void)Rte_Read_VeVLDR_b_OEXV_PerfDiag_FltDtct_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_mr);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeRCVR_e_HTL_Valve_Stuck_State'
     */
    (void)Rte_Read_VeRCVR_e_HTL_Valve_Stuck_State_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_px);

    /* SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168' incorporates:
     *  Inport: '<Root>/VeRCVR_e_HtrCoreBypVlv_Stuck_State'
     */
    (void)Rte_Read_VeRCVR_e_HtrCoreBypVlv_Stuck_State_Value
        (&TPCR_ac_B.TmpSignalConversionAtTmpVM_F_io);

    /* Outputs for Function Call SubSystem: '<Root>/TPCR_MedTEH' */
    /* DataStoreWrite: '<S1>/DSW_StatusByte_HiSpdCANCommBus' */
    TPCR_ac_DW.StatusByte_HiSpdCANCommBus =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_da;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_LostCommBCM' */
    TPCR_ac_DW.StatusByte_LostCommBCM =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lj;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CT2_SnsrCktHi' */
    TPCR_ac_DW.StatusByte_CT2_SnsrCktHi =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_iv;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CT2_SnsrCktLo' */
    TPCR_ac_DW.StatusByte_CT2_SnsrCktLo =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_j;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CT2_SnsrPerf' */
    TPCR_ac_DW.StatusByte_CT2_SnsrPerf =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_l1;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CoolPmpATempSnsrPerf' */
    TPCR_ac_DW.StatusByte_CoolPmpATempSnsrPerf =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_jv;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CoolantVlvB_CktHi' */
    TPCR_ac_DW.StatusByte_CoolantVlvB_CktHi =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_e;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CoolantVlvB_CktLo' */
    TPCR_ac_DW.StatusByte_CoolantVlvB_CktLo =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_m;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CoolantVlvB_Ckt' */
    TPCR_ac_DW.StatusByte_CoolantVlvB_Ckt =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_cv;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CoolantVlvB_StkClsd' */
    TPCR_ac_DW.StatusByte_CoolantVlvB_StkClsd =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_cm;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_ECH_TempIn' */
    TPCR_ac_DW.StatusByte_ECH_TempIn = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_dz;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_ECH_TempOut' */
    TPCR_ac_DW.StatusByte_ECH_TempOut =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_jp;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_LostCommCoolHtrA' */
    TPCR_ac_DW.StatusByte_LostCommCoolHtrA =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ai;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_LostCommHighVolCabinAirHtr' */
    TPCR_ac_DW.StatusByte_LostCommHighVolCabin =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_n1;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CoolPmpACtrlCktPerf' */
    TPCR_ac_DW.StatusByte_CoolPmpACtrlCktPerf =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_is;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_LIN2_BusOff' */
    TPCR_ac_DW.StatusByte_LIN2_BusOff =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_im;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_LostCommCoolPmpA' */
    TPCR_ac_DW.StatusByte_LostCommCoolPmpA =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ho;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CoolHeaterAPerf' */
    TPCR_ac_DW.StatusByte_CoolHeaterAPerf =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lw;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_HighVolCabinAirHtrperf' */
    TPCR_ac_DW.StatusByte_HighVolCabinAirHtrpe =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nc;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_EACPerf' */
    TPCR_ac_DW.StatusByte_EACPerf = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_mx;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_LostCommEAC' */
    TPCR_ac_DW.StatusByte_LostCommEAC =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_al;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_EvapRefriShutoffCtrlCktFlt' */
    TPCR_ac_DW.StatusByte_EvapRefriShutoffCtrl =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ee;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_EvapRefriShutoffCtrlshrtBattFlt' */
    TPCR_ac_DW.StatusByte_EvapRefriShutoffCt_d =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_af;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_EvapRefrishutoffCtrlShrtGndFlt' */
    TPCR_ac_DW.StatusByte_EvapRefrishutoffCtrl =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gh;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_AC_RefrigPresSnsrAHi' */
    TPCR_ac_DW.StatusByte_AC_RefrigPresSnsrAHi =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ch;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_AC_RefrigPresSnsrALo' */
    TPCR_ac_DW.StatusByte_AC_RefrigPresSnsrALo =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_dg;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_AC_RefrigPresSnsrAPerf' */
    TPCR_ac_DW.StatusByte_AC_RefrigPresSnsrAPe =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_mu;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CommBusOff' */
    TPCR_ac_DW.StatusByte_CommBusOff = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nm;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CommBus_B_Off' */
    TPCR_ac_DW.StatusByte_CommBus_B_Off =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lf;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_BattCoolPmpHtrBTempSnsrPerf' */
    TPCR_ac_DW.StatusByte_BattCoolPmpHtrBTempS =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kt;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_BattHeat' */
    TPCR_ac_DW.StatusByte_BattHeat = TPCR_ac_B.TmpSignalConversionAtTmpVM__lwp;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CoolantHeaterBPerf' */
    TPCR_ac_DW.StatusByte_CoolantHeaterBPerf =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_es;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_HeatingElmntPerf' */
    TPCR_ac_DW.StatusByte_HeatingElmntPerf =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_o;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_LosCommBECM_A_CANC11' */
    TPCR_ac_DW.StatusByte_LosCommBECM_A_CANC11 =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_p1;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_LosCommBECM_A' */
    TPCR_ac_DW.StatusByte_LosCommBECM_A =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_dq;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CoolantVlvA_CktHi' */
    TPCR_ac_DW.StatusByte_CoolantVlvA_CktHi =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_dr;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CoolantVlvA_CktLo' */
    TPCR_ac_DW.StatusByte_CoolantVlvA_CktLo =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_mj;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CoolantVlvA_Ckt' */
    TPCR_ac_DW.StatusByte_CoolantVlvA_Ckt =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_a2;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CoolantVlvA_Perf' */
    TPCR_ac_DW.StatusByte_CoolantVlvA_Perf =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ey;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_BattCoolPmpATempSnsrPerf' */
    TPCR_ac_DW.StatusByte_BattCoolPmpATempSnsr =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ha;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_BattCoolPmpPerf' */
    TPCR_ac_DW.StatusByte_BattCoolPmpPerf =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_at;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_BattCoolLvlLow' */
    TPCR_ac_DW.StatusByte_BattCoolLvlLow =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_m1;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_BattCoolLvlSnsCkt' */
    TPCR_ac_DW.StatusByte_BattCoolLvlSnsCkt =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_jm;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CoolOutTempSnsCkt' */
    TPCR_ac_DW.StatusByte_CoolOutTempSnsCkt =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ao;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_HB_CT_SnsrPerf' */
    TPCR_ac_DW.StatusByte_HB_CT_SnsrPerf =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gb;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_ThrmlRlyCtrlCkt' */
    TPCR_ac_DW.StatusByte_ThrmlRlyCtrlCkt =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_et;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_LIN3_BusOff' */
    TPCR_ac_DW.StatusByte_LIN3_BusOff =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pq;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_LIN1_BusOff' */
    TPCR_ac_DW.StatusByte_LIN1_BusOff =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_bi;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_LostCommHB_CoolPmp' */
    TPCR_ac_DW.StatusByte_LostCommHB_CoolPmp =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ad;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_LostCommHB_CoolPmp1' */
    TPCR_ac_DW.StatusByte_BattCoolPmpOveSpd =
        TPCR_ac_B.TmpSignalConversionAtTmpVM__a24;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_BattCool' */
    TPCR_ac_DW.StatusByte_BattCool = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_oi;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CoolantVlvB_StkOpn' */
    TPCR_ac_DW.StatusByte_CoolantVlvB_StkOpn =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gm;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_CoolantVlvB_StkOpn1' */
    TPCR_ac_DW.StatusByte_LostCommACRefrigExpV =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ds;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_AC_RefrigTempSnsrCPerf' */
    TPCR_ac_DW.StatusByte_AC_RefrigTempSnsrCPe =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_jf;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_LostCommACRefrigExpVlvActC' */
    TPCR_ac_DW.StatusByte_LostCommACRefrigEx_m =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_oo;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_LostCommACRefrigExpVlvActD' */
    TPCR_ac_DW.StatusByte_LostCommACRefrigEx_h =
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_og;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_AC_RefrigTempSnsr4CktPerf' */
    TPCR_ac_DW.StatusByte_AC_RefrigTempSnsr4Ck =
        TPCR_ac_B.TmpSignalConversionAtTmpVM__knr;

    /* DataStoreWrite: '<S1>/DSW_StatusByte_AC_RefrigTempSnsr5CktPerf' */
    TPCR_ac_DW.StatusByte_AC_RefrigTempSnsr5Ck =
        TPCR_ac_B.TmpSignalConversionAtTmpVM__mu4;

    /* S-Function (fcgen): '<S1>/FcnCallGen' incorporates:
     *  SubSystem: '<S1>/TPCI_ProcessInternalInputs'
     */
    /* Switch: '<S1769>/Switch' incorporates:
     *  Constant: '<S1817>/Calib'
     */
    if (KeTPCR_b_HCPShutDwnCmd_SD)
    {
        /* Switch: '<S1769>/Switch' incorporates:
         *  Constant: '<S1816>/Calib'
         */
        VeTPCR_b_HCPShutDwnCmd = KeTPCR_b_HCPShutDwnCmd_D;
    }
    else
    {
        /* Switch: '<S1769>/Switch' */
        VeTPCR_b_HCPShutDwnCmd = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lo;
    }

    /* End of Switch: '<S1769>/Switch' */

    /* Switch: '<S1775>/Switch' incorporates:
     *  Constant: '<S1830>/Calib'
     */
    if (KeTPCR_b_ShippingMode_SD)
    {
        /* Switch: '<S1775>/Switch' incorporates:
         *  Constant: '<S1831>/Calib'
         */
        VeTPCR_e_ShippingMode_AD = KeTPCR_e_ShippingMode_D;
    }
    else
    {
        /* Switch: '<S1775>/Switch' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        VeTPCR_e_ShippingMode_AD = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_go;
    }

    /* End of Switch: '<S1775>/Switch' */

    /* Switch: '<S1757>/Switch' incorporates:
     *  Constant: '<S1786>/Calib'
     */
    if (KeTPCR_b_EngClntTmp_Out_SelDial)
    {
        /* Switch: '<S1757>/Switch' incorporates:
         *  Constant: '<S1783>/Calib'
         */
        VeTPCR_T_EngCoolantTemp = KeTPCR_T_EngClntTmp_Out_Dial;
    }
    else
    {
        /* Switch: '<S1757>/Switch' */
        VeTPCR_T_EngCoolantTemp = TPCR_ac_B.TmpSignalConversionAtTmpVM_FcnC;
    }

    /* End of Switch: '<S1757>/Switch' */

    /* Switch: '<S1757>/Switch1' incorporates:
     *  Constant: '<S1788>/Calib'
     */
    if (KeTPCR_b_EngCoolantTemp_FA_SD)
    {
        /* Switch: '<S1757>/Switch1' incorporates:
         *  Constant: '<S1787>/Calib'
         */
        VeTPCR_b_EngCoolantTemp_FA = KeTPCR_b_EngCoolantTemp_FA_D;
    }
    else
    {
        /* Switch: '<S1757>/Switch1' */
        VeTPCR_b_EngCoolantTemp_FA = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_oh;
    }

    /* End of Switch: '<S1757>/Switch1' */

    /* Switch: '<S1757>/Switch2' incorporates:
     *  Constant: '<S1785>/Calib'
     */
    if (KeTPCR_b_ECT_Sgnl_Rcvd_SD)
    {
        /* Switch: '<S1757>/Switch2' incorporates:
         *  Constant: '<S1784>/Calib'
         */
        VeTPCR_b_ECT_Sgnl_Rcvd = KeTPCR_b_ECT_Sgnl_Rcvd_D;
    }
    else
    {
        /* Switch: '<S1757>/Switch2' */
        VeTPCR_b_ECT_Sgnl_Rcvd = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_e5;
    }

    /* End of Switch: '<S1757>/Switch2' */

    /* Switch: '<S1759>/Switch' incorporates:
     *  Constant: '<S1791>/Calib'
     */
    if (KeTPCR_b_BCMPreCondCabinReq_SelDial)
    {
        /* Switch: '<S1759>/Switch' incorporates:
         *  Constant: '<S1790>/Calib'
         */
        VeTPCR_b_RmtVehStartReq = KeTPCR_b_BCMPreCondCabinReq_Dial;
    }
    else
    {
        /* Switch: '<S1759>/Switch' */
        VeTPCR_b_RmtVehStartReq = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_m2;
    }

    /* End of Switch: '<S1759>/Switch' */

    /* Switch: '<S1760>/Switch' incorporates:
     *  Constant: '<S1793>/Calib'
     */
    if (KeTPCR_b_PMM_PowerMode_SD)
    {
        /* Switch: '<S1760>/Switch' incorporates:
         *  Constant: '<S1794>/Calib'
         */
        VeTPCR_e_PMM_PowerMode_AD = KeTPCR_e_PMM_PowerMode_Dial;
    }
    else
    {
        /* Switch: '<S1760>/Switch' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        VeTPCR_e_PMM_PowerMode_AD = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kw;
    }

    /* End of Switch: '<S1760>/Switch' */

    /* Switch: '<S1761>/Switch2' incorporates:
     *  Constant: '<S1796>/Calib'
     */
    if (KeTPCR_b_SelOldHtrSts)
    {
        /* Switch: '<S1761>/Switch2' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        VeTPCR_e_HVC_HtrSts_AS = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ka;
    }
    else
    {
        /* Switch: '<S1761>/Switch2' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        VeTPCR_e_HVC_HtrSts_AS = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ow;
    }

    /* End of Switch: '<S1761>/Switch2' */

    /* Switch: '<S1761>/Switch1' incorporates:
     *  Constant: '<S1795>/Calib'
     */
    if (KeTPCR_b_SelHtr3Sts_PerWkup)
    {
        /* Switch: '<S1761>/Switch1' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        Switch1_e = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_o3;
    }
    else
    {
        /* Switch: '<S1761>/Switch1' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        Switch1_e = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nr;
    }

    /* End of Switch: '<S1761>/Switch1' */

    /* Switch: '<S1762>/Switch' incorporates:
     *  Constant: '<S1800>/Calib'
     */
    if (KeTPCR_b_HVC_Heater_Flt_SD)
    {
        /* Switch: '<S1762>/Switch' incorporates:
         *  Constant: '<S1799>/Calib'
         */
        VeTPCR_b_HVC_Heater_Flt = KeTPCR_b_HVC_Heater_Flt_D;
    }
    else
    {
        /* Switch: '<S1762>/Switch' */
        VeTPCR_b_HVC_Heater_Flt = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_oc;
    }

    /* End of Switch: '<S1762>/Switch' */

    /* Switch: '<S1762>/Switch1' incorporates:
     *  Constant: '<S1798>/Calib'
     */
    if (KeTPCR_b_HVC_Heater2_Flt_SD)
    {
        /* Switch: '<S1762>/Switch1' incorporates:
         *  Constant: '<S1797>/Calib'
         */
        VeTPCR_b_HVC_Heater2_Flt = KeTPCR_b_HVC_Heater2_Flt_D;
    }
    else
    {
        /* Switch: '<S1762>/Switch1' */
        VeTPCR_b_HVC_Heater2_Flt = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pv;
    }

    /* End of Switch: '<S1762>/Switch1' */

    /* Switch: '<S1762>/Switch2' incorporates:
     *  Constant: '<S1801>/Calib'
     */
    if (KeTPCR_b_Sel_OldHeater_Flt)
    {
        /* Switch: '<S1762>/Switch2' */
        VeTPCR_b_HVC_Heater_Flt_AS = VeTPCR_b_HVC_Heater_Flt;
    }
    else
    {
        /* Switch: '<S1762>/Switch2' */
        VeTPCR_b_HVC_Heater_Flt_AS = VeTPCR_b_HVC_Heater2_Flt;
    }

    /* End of Switch: '<S1762>/Switch2' */

    /* Switch: '<S1764>/Switch' incorporates:
     *  Constant: '<S1805>/Calib'
     */
    if (KeTPCR_b_BCMPreCondCabReq_SD)
    {
        /* Switch: '<S1764>/Switch' incorporates:
         *  Constant: '<S1806>/Calib'
         */
        VeTPCR_e_BCMPreCondCabinReq = KeTPCR_e_BCMPreCondCabReq_D;
    }
    else
    {
        /* Switch: '<S1764>/Switch' incorporates:
         *  Constant: '<S1804>/Constant'
         */
        VeTPCR_e_BCMPreCondCabinReq = CePLTR_e_CPCDefault;
    }

    /* End of Switch: '<S1764>/Switch' */

    /* Switch: '<S1765>/Switch' incorporates:
     *  Constant: '<S1808>/Calib'
     */
    if (KeTPCR_b_HV_BatSOC_SD)
    {
        /* Switch: '<S1765>/Switch' incorporates:
         *  Constant: '<S1807>/Calib'
         */
        VeTPCR_Pct_HVBatSOC = KeTPCR_Pct_HV_BatSOC_D;
    }
    else
    {
        /* Switch: '<S1765>/Switch' */
        VeTPCR_Pct_HVBatSOC = TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_l;
    }

    /* End of Switch: '<S1765>/Switch' */

    /* Switch: '<S1766>/Switch' incorporates:
     *  Constant: '<S1809>/Calib'
     */
    if (KeTPCR_b_ChargingSts_SD)
    {
        /* Switch: '<S1766>/Switch' incorporates:
         *  Constant: '<S1810>/Calib'
         */
        VeTPCR_e_ChargingSystemSts = KeTPCR_e_ChargingSts_D;
    }
    else
    {
        /* Switch: '<S1766>/Switch' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        VeTPCR_e_ChargingSystemSts = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ic;
    }

    /* End of Switch: '<S1766>/Switch' */

    /* Switch: '<S1767>/Switch' incorporates:
     *  Constant: '<S1811>/Calib'
     *  Constant: '<S1812>/Calib'
     */
    VeTPCR_b_OkayToPreCondCabin = ((!KeTPCR_b_OkayToPreCondCab_SD) ||
        (KeTPCR_b_OkayToPreCondCab_D));

    /* Switch: '<S1768>/Switch' incorporates:
     *  Constant: '<S1814>/Calib'
     *  Constant: '<S1815>/Calib'
     *  Switch: '<S1768>/Switch1'
     */
    if (KeTPCR_b_CabinSP_SD)
    {
        /* Switch: '<S1768>/Switch' incorporates:
         *  Constant: '<S1813>/Calib'
         */
        VeTPCR_T_CabSP = KeTPCR_T_CabinSP_D;
    }
    else if (KeTPCR_b_CabinSPSlct)
    {
        /* Switch: '<S1768>/Switch1' incorporates:
         *  Constant: '<S5>/ConstantValue2'
         *  Switch: '<S1768>/Switch'
         */
        VeTPCR_T_CabSP = 25.0F;
    }
    else
    {
        /* Switch: '<S1768>/Switch' incorporates:
         *  Switch: '<S1768>/Switch1'
         */
        VeTPCR_T_CabSP = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_n0;
    }

    /* End of Switch: '<S1768>/Switch' */

    /* Switch: '<S1770>/Switch' incorporates:
     *  Constant: '<S1820>/Calib'
     */
    if (KeTPCR_b_PwrBdgtAvail_SD)
    {
        /* Switch: '<S1770>/Switch' incorporates:
         *  Constant: '<S1818>/Calib'
         */
        VeTPCR_P_PwrBdgtAvail = KeTPCR_P_PwrBdgtAvail_D;
    }
    else
    {
        /* Switch: '<S1770>/Switch' */
        VeTPCR_P_PwrBdgtAvail = TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_k;
    }

    /* End of Switch: '<S1770>/Switch' */

    /* Switch: '<S1770>/Switch1' incorporates:
     *  Constant: '<S1821>/Calib'
     */
    if (KeTPCR_b_ThrmlPwrBdgtAvail_SD)
    {
        /* Switch: '<S1770>/Switch1' incorporates:
         *  Constant: '<S1819>/Calib'
         */
        VeTPCR_P_ThrmlPwrBdgt = KeTPCR_P_ThrmlPwrBdgtAvail_D;
    }
    else
    {
        /* Switch: '<S1770>/Switch1' */
        VeTPCR_P_ThrmlPwrBdgt = TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_c;
    }

    /* End of Switch: '<S1770>/Switch1' */

    /* Switch: '<S1771>/Switch1' incorporates:
     *  Constant: '<S1823>/Calib'
     */
    if (KeTPCR_b_ChrgSysFlt_SelDial)
    {
        /* Switch: '<S1771>/Switch1' incorporates:
         *  Constant: '<S1822>/Calib'
         */
        VeTPCR_b_ChrgSysFlt = KeTPCR_b_ChrgSysFlt_Dial;
    }
    else
    {
        /* Switch: '<S1771>/Switch1' */
        VeTPCR_b_ChrgSysFlt = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ov;
    }

    /* End of Switch: '<S1771>/Switch1' */

    /* Switch: '<S1782>/Switch3' incorporates:
     *  Constant: '<S1851>/Calib'
     */
    if (KeTPCR_b_CellMaxAllwd_SelDial)
    {
        /* Switch: '<S1782>/Switch3' incorporates:
         *  Constant: '<S1850>/Calib'
         */
        VeTPCR_T_CellTmpMaxAllwd = KeTPCR_T_CellMaxAllwd_Dial;
    }
    else
    {
        /* Switch: '<S1782>/Switch3' */
        VeTPCR_T_CellTmpMaxAllwd = TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_n;
    }

    /* End of Switch: '<S1782>/Switch3' */

    /* Switch: '<S1772>/Switch' incorporates:
     *  Constant: '<S1824>/Calib'
     */
    if (KeTPCR_b_BatCntctrStat_SelDial)
    {
        /* Switch: '<S1772>/Switch' incorporates:
         *  Constant: '<S1825>/Calib'
         */
        VeTPCR_e_BatCntctrStat = KeTPCR_e_BatCntctrStat_Dial;
    }
    else
    {
        /* Switch: '<S1772>/Switch' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        VeTPCR_e_BatCntctrStat = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_fw;
    }

    /* End of Switch: '<S1772>/Switch' */

    /* Switch: '<S1773>/Switch1' incorporates:
     *  Constant: '<S1827>/Calib'
     */
    if (KeTPCR_b_ThrmLoad_Shed_SelDial)
    {
        /* Switch: '<S1773>/Switch1' incorporates:
         *  Constant: '<S1826>/Calib'
         */
        VeTPCR_b_ThrmLoad_Shed = KeTPCR_b_ThrmLoad_Shed_Dial;
    }
    else
    {
        /* Switch: '<S1773>/Switch1' */
        VeTPCR_b_ThrmLoad_Shed = TPCR_ac_B.TmpSignalConversionAtTmpVM__ovl;
    }

    /* End of Switch: '<S1773>/Switch1' */

    /* Switch: '<S1774>/Switch' incorporates:
     *  Constant: '<S1828>/Calib'
     */
    if (Rte_Prm_KeTHMR_b_TurtleMd_SelDial_KeTHMR_b_TurtleMd_SelDial())
    {
        /* Switch: '<S1774>/Switch' incorporates:
         *  Constant: '<S1829>/Calib'
         */
        VeTPCR_e_TurtleMd =
            Rte_Prm_KeTHMR_e_TurtleMd_Dial_KeTHMR_e_TurtleMd_Dial();
    }
    else
    {
        /* Switch: '<S1774>/Switch' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        VeTPCR_e_TurtleMd = TPCR_ac_B.TmpSignalConversionAtTmpVM__af1;
    }

    /* End of Switch: '<S1774>/Switch' */

    /* Switch: '<S1777>/Switch' incorporates:
     *  Constant: '<S1838>/Calib'
     */
    if (KeTPCR_b_LTAP_LOC_SD)
    {
        /* Switch: '<S1777>/Switch' incorporates:
         *  Constant: '<S1839>/Calib'
         */
        VeTPCR_e_LTAP_LOC = KeTPCR_e_LTAP_LOC_D;
    }
    else
    {
        /* Switch: '<S1777>/Switch' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        VeTPCR_e_LTAP_LOC = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ae;
    }

    /* End of Switch: '<S1777>/Switch' */

    /* Switch: '<S1777>/Switch1' incorporates:
     *  Constant: '<S1837>/Calib'
     */
    if (KeTPCR_b_LTAPLOC_FA_SD)
    {
        /* Switch: '<S1777>/Switch1' incorporates:
         *  Constant: '<S1836>/Calib'
         */
        VeTPCR_b_LTAP_LOC_FA = KeTPCR_b_LTAPLOC_FA_D;
    }
    else
    {
        /* Switch: '<S1777>/Switch1' */
        VeTPCR_b_LTAP_LOC_FA = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ar;
    }

    /* End of Switch: '<S1777>/Switch1' */

    /* Switch: '<S1776>/Switch' incorporates:
     *  Constant: '<S1834>/Calib'
     */
    if (KeTPCR_b_BattHtr_LOC_SD)
    {
        /* Switch: '<S1776>/Switch' incorporates:
         *  Constant: '<S1835>/Calib'
         */
        VeTPCR_e_BattHtr_LOC = KeTPCR_e_BattHtr_LOC_D;
    }
    else
    {
        /* Switch: '<S1776>/Switch' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        VeTPCR_e_BattHtr_LOC = TPCR_ac_B.TmpSignalConversionAtTmpVM__esi;
    }

    /* End of Switch: '<S1776>/Switch' */

    /* Switch: '<S1776>/Switch1' incorporates:
     *  Constant: '<S1833>/Calib'
     */
    if (KeTPCR_b_BattHtrLOC_FA_SD)
    {
        /* Switch: '<S1776>/Switch1' incorporates:
         *  Constant: '<S1832>/Calib'
         */
        VeTPCR_b_BattHtr_LOC_FA = KeTPCR_b_BattHtrLOC_FA_D;
    }
    else
    {
        /* Switch: '<S1776>/Switch1' */
        VeTPCR_b_BattHtr_LOC_FA = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ft;
    }

    /* End of Switch: '<S1776>/Switch1' */

    /* Switch: '<S1778>/Switch1' incorporates:
     *  Constant: '<S1840>/Calib'
     */
    if (KeTPCR_b_ClimateScheduleOption_SD)
    {
        /* Switch: '<S1778>/Switch1' incorporates:
         *  Constant: '<S1841>/Calib'
         */
        VeTPCR_e_ClimateScheduleOption = KeTPCR_e_ClimateScheduleOption_D;
    }
    else
    {
        /* Switch: '<S1778>/Switch1' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        VeTPCR_e_ClimateScheduleOption =
            TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ne;
    }

    /* End of Switch: '<S1778>/Switch1' */

    /* Switch: '<S1779>/Switch1' incorporates:
     *  Constant: '<S1843>/Calib'
     */
    if (KeTPCR_b_12VPWup_SD)
    {
        /* Switch: '<S1779>/Switch1' incorporates:
         *  Constant: '<S1842>/Calib'
         */
        VeTPCR_b_12VPwup = KeTPCR_b_12VPWup_D;
    }
    else
    {
        /* Switch: '<S1779>/Switch1' */
        VeTPCR_b_12VPwup = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pr;
    }

    /* End of Switch: '<S1779>/Switch1' */

    /* S-Function (sfix_bitop): '<S1789>/BitwiseOperator1' incorporates:
     *  Logic: '<S1758>/LogicalOperator'
     *  Logic: '<S1758>/LogicalOperator1'
     *  Logic: '<S1758>/LogicalOperator2'
     *  Logic: '<S1758>/LogicalOperator3'
     *  Logic: '<S1758>/LogicalOperator4'
     *  Logic: '<S1758>/LogicalOperator5'
     *  Logic: '<S1789>/LogicalOperator'
     *  RelationalOperator: '<S1789>/RelationalOperator1'
     *  RelationalOperator: '<S1789>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1789>/BitwiseOperator2'
     */
#if Rte_SysCon_Variant_TPCR_3

    /* Logic: '<S1789>/LogicalOperator' incorporates:
     *  Constant: '<S1789>/Constant1'
     *  Constant: '<S1789>/Constant2'
     *  DataStoreRead: '<S1789>/StatusByte_ThrmlRlyCtrlCkt'
     */
    rtb_LogicalOperator_h0 = (((((sint32)TPCR_ac_DW.StatusByte_ThrmlRlyCtrlCkt)
        & 1) > 0) && ((((uint32)TPCR_ac_DW.StatusByte_ThrmlRlyCtrlCkt) & 64U) ==
                      0U));

    /* Logic: '<S1758>/LogicalOperator1' */
    rtb_LogicalOperator1_c = !rtb_LogicalOperator_h0;

#else

    /* Logic: '<S1758>/LogicalOperator' */
    rtb_LogicalOperator_bpb = !TPCR_ac_B.VM_Conditional_Signal_TmpVM_F_a;

    /* VariantMerge generated from: '<S1758>/VariantSource' incorporates:
     *  Logic: '<S1758>/LogicalOperator2'
     *  Logic: '<S1758>/LogicalOperator3'
     *  Logic: '<S1758>/LogicalOperator4'
     *  Logic: '<S1758>/LogicalOperator5'
     */
    rtb_VariantMerge_For_Variant__n =
        (((((!TPCR_ac_B.VM_Conditional_Signal_TmpVM__mv) &&
            (!TPCR_ac_B.VM_Conditional_Signal_TmpVM_F_e)) &&
           (!TPCR_ac_B.VM_Conditional_Signal_TmpVM_F_p)) &&
          rtb_LogicalOperator_bpb) && (TPCR_ac_B.VM_Conditional_Signal_TmpVM_Fcn));

#endif

    /* End of S-Function (sfix_bitop): '<S1789>/BitwiseOperator1' */

    /* Logic: '<S1758>/LogicalOperator6' */
#if Rte_SysCon_Variant_TPCR_3

    /* VariantMerge generated from: '<S1758>/VariantSource' */
    rtb_VariantMerge_For_Variant__n =
        ((TPCR_ac_B.VM_Conditional_Signal_TmpVM_F_m) && rtb_LogicalOperator1_c);

#endif

    /* End of Logic: '<S1758>/LogicalOperator6' */

    /* SignalConversion generated from: '<S1758>/VariantSource' */
    VeTPCR_b_Rly_EnblCmnd_AD = rtb_VariantMerge_For_Variant__n;

    /* Switch: '<S1763>/Switch1' incorporates:
     *  Constant: '<S1802>/Calib'
     */
    if (KeTPCR_b_FOTAInstallType_SD)
    {
        /* Switch: '<S1763>/Switch1' incorporates:
         *  Constant: '<S1803>/Calib'
         */
        VeTPCR_e_FOTAInstallType = KeTPCR_e_FOTAInstallType_D;
    }
    else
    {
        /* Switch: '<S1763>/Switch1' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        VeTPCR_e_FOTAInstallType = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_j5;
    }

    /* End of Switch: '<S1763>/Switch1' */

    /* Switch: '<S1780>/Switch' incorporates:
     *  Constant: '<S1844>/Calib'
     */
    if (KeTPCR_b_DschrgSysSts_SD)
    {
        /* Switch: '<S1780>/Switch' incorporates:
         *  Constant: '<S1845>/Calib'
         */
        VeTPCR_e_DschrgSysSts_AD = KeTPCR_e_DschrgSysSts_D;
    }
    else
    {
        /* Switch: '<S1780>/Switch' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        VeTPCR_e_DschrgSysSts_AD = TPCR_ac_B.TmpSignalConversionAtTmpVM__fta;
    }

    /* End of Switch: '<S1780>/Switch' */

    /* Switch: '<S1781>/Switch' incorporates:
     *  Constant: '<S1847>/Calib'
     */
    if (KeTPCR_b_RacePrep_SD)
    {
        /* Switch: '<S1781>/Switch' incorporates:
         *  Constant: '<S1849>/Calib'
         */
        VeTIMR_e_RacePrep_AD = KeTPCR_e_RacePrep_D;
    }
    else
    {
        /* Switch: '<S1781>/Switch' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        VeTIMR_e_RacePrep_AD = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_op;
    }

    /* End of Switch: '<S1781>/Switch' */

    /* Switch: '<S1781>/Switch1' incorporates:
     *  Constant: '<S1846>/Calib'
     */
    if (KeTPCR_b_RacePrepSts_SD)
    {
        /* Switch: '<S1781>/Switch1' incorporates:
         *  Constant: '<S1848>/Calib'
         */
        VeTIMR_e_RacePrepRaceTypeSts_AD = KeTPCR_e_RacePrepSts_D;
    }
    else
    {
        /* Switch: '<S1781>/Switch1' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        VeTIMR_e_RacePrepRaceTypeSts_AD =
            TPCR_ac_B.TmpSignalConversionAtTmpVM_F_l4;
    }

    /* End of Switch: '<S1781>/Switch1' */
    /* End of Outputs for S-Function (fcgen): '<S1>/FcnCallGen' */

    /* S-Function (fcgen): '<S1>/FcnCallGen' incorporates:
     *  SubSystem: '<S1>/TPCC_Controls'
     */
    /* Logic: '<S8>/Logical1' incorporates:
     *  Constant: '<S63>/Calib'
     *  Gain: '<S1792>/Gain'
     *  Logic: '<S4>/Logical6'
     *  Logic: '<S8>/Logical7'
     */
    rtb_LogicalOperator_h0 = ((VeTPCR_b_RmtVehStartReq) ||
        ((TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_f) && (KeTPCR_b_Enbl_SCCActv)));

    /* Switch: '<S93>/Switch1' incorporates:
     *  Constant: '<S108>/Calib'
     */
    if (KeTPCR_b_Enbl_BattTmpCrit_Chk)
    {
        /* RelationalOperator: '<S93>/Comparison4' incorporates:
         *  RelationalOperator: '<S93>/Comparison3'
         *  RelationalOperator: '<S93>/Comparison6'
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        rtb_Switch3_dh_tmp = TPCR_ac_B.TmpSignalConversionAtTmpVM__gr1;

        /* Switch: '<S1026>/Switch3' incorporates:
         *  Constant: '<S105>/Constant'
         *  Constant: '<S106>/Constant'
         *  Constant: '<S107>/Constant'
         *  Logic: '<S93>/Logical2'
         *  RelationalOperator: '<S93>/Comparison3'
         *  RelationalOperator: '<S93>/Comparison4'
         *  RelationalOperator: '<S93>/Comparison6'
         */
        rtb_Switch3_o = (((((uint32)rtb_Switch3_dh_tmp) != CeBTRR_e_BatOutOfRng)
                          && (((uint32)rtb_Switch3_dh_tmp) != CeBTRR_e_BatCrit))
                         && (((uint32)rtb_Switch3_dh_tmp) !=
                             CeBTRR_e_BatCritErrSt));
    }
    else
    {
        /* Switch: '<S1026>/Switch3' incorporates:
         *  Constant: '<S93>/TRUEConstant'
         */
        rtb_Switch3_o = true;
    }

    /* End of Switch: '<S93>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S20>/EdgeRising1' */
    /* Logic: '<S1749>/OR1' incorporates:
     *  UnitDelay: '<S1749>/UnitDelay'
     */
    rtb_LogicalOperator_bpb = !TPCR_ac_DW.UnitDelay_DSTATE_f4;

    /* Update for UnitDelay: '<S1749>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_f4 = TPCR_ac_B.TmpSignalConversionAtTmpVM__l25;

    /* End of Outputs for SubSystem: '<S20>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S20>/EdgeRising2' */
    /* Logic: '<S1750>/OR1' incorporates:
     *  UnitDelay: '<S1750>/UnitDelay'
     */
    rtb_LogicalOperator1_c = !TPCR_ac_DW.UnitDelay_DSTATE_ka;

    /* Update for UnitDelay: '<S1750>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ka = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_dc;

    /* End of Outputs for SubSystem: '<S20>/EdgeRising2' */

    /* RelationalOperator: '<S20>/Comparison1' incorporates:
     *  Constant: '<S1754>/Calib'
     */
    VeTPCR_b_CellTmpCrit = (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lp >
                            KeTPCR_t_CellMinTh_WkUp);

    /* Outputs for Atomic SubSystem: '<S20>/EdgeRising1' */
    /* Outputs for Atomic SubSystem: '<S20>/EdgeRising2' */
    /* Logic: '<S20>/Logical3' incorporates:
     *  Logic: '<S1749>/AND'
     *  Logic: '<S1750>/AND'
     */
    VeTPCR_b_CondWakeUp = ((((TPCR_ac_B.TmpSignalConversionAtTmpVM__l25) &&
        rtb_LogicalOperator_bpb) && ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_dc)
        && rtb_LogicalOperator1_c)) && (VeTPCR_b_CellTmpCrit));

    /* End of Outputs for SubSystem: '<S20>/EdgeRising2' */
    /* End of Outputs for SubSystem: '<S20>/EdgeRising1' */

    /* UnitDelay: '<S4>/UnitDelay1' */
    rtb_LogicalOperator_bpb = TPCR_ac_DW.UnitDelay1_DSTATE_b;

    /* Outputs for Atomic SubSystem: '<S20>/EdgeRising3' */
    /* Logic: '<S1751>/OR1' incorporates:
     *  UnitDelay: '<S1751>/UnitDelay'
     */
    rtb_LogicalOperator1_c = !TPCR_ac_DW.UnitDelay_DSTATE_bh;

    /* Update for UnitDelay: '<S1751>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_bh = rtb_LogicalOperator_bpb;

    /* Outputs for Atomic SubSystem: '<S20>/SignalLatchOnWithReset' */
    /* Logic: '<S1755>/OR1' incorporates:
     *  Logic: '<S1751>/AND'
     *  Logic: '<S1755>/NOT'
     *  Logic: '<S1755>/OR'
     *  UnitDelay: '<S1755>/UnitDelay'
     */
    VeTPCR_b_CondWakeUpLtch = ((VeTPCR_b_CondWakeUp) ||
        (((!rtb_LogicalOperator_bpb) || (!rtb_LogicalOperator1_c)) &&
         (TPCR_ac_DW.UnitDelay_DSTATE_i3q)));

    /* End of Outputs for SubSystem: '<S20>/EdgeRising3' */

    /* Update for UnitDelay: '<S1755>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_i3q = VeTPCR_b_CondWakeUpLtch;

    /* End of Outputs for SubSystem: '<S20>/SignalLatchOnWithReset' */

    /* If: '<S20>/If' */
    if (VeTPCR_b_CondWakeUpLtch)
    {
        /* Outputs for IfAction SubSystem: '<S20>/IfActionSubsystem' incorporates:
         *  ActionPort: '<S1752>/ActionPort'
         */
        /* Merge: '<S20>/Merge1' incorporates:
         *  Constant: '<S1752>/TRUEConstant'
         *  SignalConversion generated from: '<S1752>/Out1'
         */
        VeTPCR_b_SC_WakeUpReq = true;

        /* Merge: '<S20>/Merge2' incorporates:
         *  Constant: '<S1752>/FALSEConstant'
         *  SignalConversion generated from: '<S1752>/Out2'
         */
        VeTPCR_b_HVBatPerWkUp = false;

        /* End of Outputs for SubSystem: '<S20>/IfActionSubsystem' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S20>/IfActionSubsystem1' incorporates:
         *  ActionPort: '<S1753>/ActionPort'
         */
        /* Merge: '<S20>/Merge1' incorporates:
         *  Inport: '<S1753>/In1'
         */
        VeTPCR_b_SC_WakeUpReq = TPCR_ac_B.TmpSignalConversionAtTmpVM__l25;

        /* Merge: '<S20>/Merge2' incorporates:
         *  Inport: '<S1753>/In2'
         */
        VeTPCR_b_HVBatPerWkUp = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_dc;

        /* End of Outputs for SubSystem: '<S20>/IfActionSubsystem1' */
    }

    /* End of If: '<S20>/If' */

    /* SignalConversion generated from: '<S346>/VariantSource' incorporates:
     *  Logic: '<S390>/LogicalOperator'
     *  RelationalOperator: '<S390>/RelationalOperator1'
     *  RelationalOperator: '<S390>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S390>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S390>/BitwiseOperator2'
     */
#if Rte_SysCon_Variant_TPCR_18

    /* Gain: '<S1042>/Gain' incorporates:
     *  Constant: '<S346>/Constant'
     */
    rtb_Gain_g = false;

#else

    /* Gain: '<S1042>/Gain' incorporates:
     *  Constant: '<S390>/Constant1'
     *  Constant: '<S390>/Constant2'
     *  DataStoreRead: '<S390>/StatusByte_CoolHeaterAPerf'
     *  Logic: '<S390>/LogicalOperator'
     *  RelationalOperator: '<S390>/RelationalOperator1'
     *  RelationalOperator: '<S390>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S390>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S390>/BitwiseOperator2'
     */
    rtb_Gain_g = (((((sint32)TPCR_ac_DW.StatusByte_CoolHeaterAPerf) & 1) > 0) &&
                  ((((uint32)TPCR_ac_DW.StatusByte_CoolHeaterAPerf) & 64U) == 0U));

#endif

    /* End of SignalConversion generated from: '<S346>/VariantSource' */

    /* SignalConversion generated from: '<S346>/VariantSource1' incorporates:
     *  Logic: '<S391>/LogicalOperator'
     *  RelationalOperator: '<S391>/RelationalOperator1'
     *  RelationalOperator: '<S391>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S391>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S391>/BitwiseOperator2'
     */
#if Rte_SysCon_Variant_TPCR_19

    /* Switch: '<S1016>/Switch1' incorporates:
     *  Constant: '<S346>/Constant1'
     */
    rtb_Switch1_eo = false;

#else

    /* Switch: '<S1016>/Switch1' incorporates:
     *  Constant: '<S391>/Constant1'
     *  Constant: '<S391>/Constant2'
     *  DataStoreRead: '<S391>/StatusByte_HighVolCabinAirHtrperf'
     *  Logic: '<S391>/LogicalOperator'
     *  RelationalOperator: '<S391>/RelationalOperator1'
     *  RelationalOperator: '<S391>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S391>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S391>/BitwiseOperator2'
     */
    rtb_Switch1_eo = (((((sint32)TPCR_ac_DW.StatusByte_HighVolCabinAirHtrpe) & 1)
                       > 0) && ((((uint32)
                         TPCR_ac_DW.StatusByte_HighVolCabinAirHtrpe) & 64U) ==
                       0U));

#endif

    /* End of SignalConversion generated from: '<S346>/VariantSource1' */

    /* SignalConversion generated from: '<S346>/VariantSource2' */
#if Rte_SysCon_Variant_TPCR_21

    /* Switch: '<S1016>/Switch3' incorporates:
     *  Constant: '<S346>/Constant2'
     */
    rtb_Switch3_c2 = false;

#else

    /* Switch: '<S1016>/Switch3' incorporates:
     *  SignalConversion generated from: '<S346>/VariantSource2'
     */
    rtb_Switch3_c2 = VeTPCR_b_HVC_Heater_Flt_AS;

#endif

    /* End of SignalConversion generated from: '<S346>/VariantSource2' */

    /* Logic: '<S346>/Logical3' incorporates:
     *  Constant: '<S387>/Constant'
     *  Constant: '<S388>/Constant'
     *  Constant: '<S389>/Constant'
     *  RelationalOperator: '<S346>/Comparison1'
     *  RelationalOperator: '<S346>/Comparison11'
     *  RelationalOperator: '<S346>/Comparison2'
     *  Switch: '<S1761>/Switch2'
     */
    VeTPCC_b_HtrStsFlty_RawPrst = ((((((((uint32)VeTPCR_e_HVC_HtrSts_AS) ==
        CeHTIR_e_HtrSts_LockedUntilNextStart) || (((uint32)
        VeTPCR_e_HVC_HtrSts_AS) == CeHTIR_e_HtrSts_LockedUntilService)) ||
        (((uint32)VeTPCR_e_HVC_HtrSts_AS) == CeHTIR_e_HtrSts_LockedPermanent)) ||
        rtb_Gain_g) || rtb_Switch1_eo) || rtb_Switch3_c2);

    /* SignalConversion generated from: '<S343>/VariantSource5' incorporates:
     *  Logic: '<S343>/Logical5'
     *  Logic: '<S358>/LogicalOperator'
     *  Logic: '<S359>/LogicalOperator'
     *  RelationalOperator: '<S358>/RelationalOperator1'
     *  RelationalOperator: '<S358>/RelationalOperator2'
     *  RelationalOperator: '<S359>/RelationalOperator1'
     *  RelationalOperator: '<S359>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S358>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S358>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S359>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S359>/BitwiseOperator2'
     */
#if Rte_SysCon_Variant_TPCR_22

    /* Switch: '<S1016>/Switch3' incorporates:
     *  Constant: '<S343>/Constant5'
     */
    rtb_Switch3_c2 = false;

#else

    /* Switch: '<S1016>/Switch3' incorporates:
     *  Constant: '<S358>/Constant1'
     *  Constant: '<S358>/Constant2'
     *  Constant: '<S359>/Constant1'
     *  Constant: '<S359>/Constant2'
     *  DataStoreRead: '<S358>/StatusByte_LostCommCoolHtrA'
     *  DataStoreRead: '<S359>/StatusByte_LostCommHighVolCabinAirHtr'
     *  Logic: '<S343>/Logical5'
     *  Logic: '<S358>/LogicalOperator'
     *  Logic: '<S359>/LogicalOperator'
     *  RelationalOperator: '<S358>/RelationalOperator1'
     *  RelationalOperator: '<S358>/RelationalOperator2'
     *  RelationalOperator: '<S359>/RelationalOperator1'
     *  RelationalOperator: '<S359>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S358>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S358>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S359>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S359>/BitwiseOperator2'
     */
    rtb_Switch3_c2 = ((((((sint32)TPCR_ac_DW.StatusByte_LostCommCoolHtrA) & 1) >
                        0) && ((((uint32)TPCR_ac_DW.StatusByte_LostCommCoolHtrA)
                         & 64U) == 0U)) || (((((sint32)
                          TPCR_ac_DW.StatusByte_LostCommHighVolCabin) & 1) > 0) &&
                       ((((uint32)TPCR_ac_DW.StatusByte_LostCommHighVolCabin) &
                         64U) == 0U)));

#endif

    /* End of SignalConversion generated from: '<S343>/VariantSource5' */

    /* SignalConversion generated from: '<S343>/VariantSource2' incorporates:
     *  Logic: '<S343>/Logical2'
     *  Logic: '<S348>/LogicalOperator'
     *  Logic: '<S349>/LogicalOperator'
     *  Logic: '<S350>/LogicalOperator'
     *  RelationalOperator: '<S348>/RelationalOperator1'
     *  RelationalOperator: '<S348>/RelationalOperator2'
     *  RelationalOperator: '<S349>/RelationalOperator1'
     *  RelationalOperator: '<S349>/RelationalOperator2'
     *  RelationalOperator: '<S350>/RelationalOperator1'
     *  RelationalOperator: '<S350>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S348>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S348>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S349>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S349>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S350>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S350>/BitwiseOperator2'
     */
#if Rte_SysCon_Variant_TPCR_12

    /* Switch: '<S1016>/Switch1' incorporates:
     *  Constant: '<S343>/Constant2'
     */
    rtb_Switch1_eo = false;

#else

    /* Switch: '<S1016>/Switch1' incorporates:
     *  Constant: '<S348>/Constant1'
     *  Constant: '<S348>/Constant2'
     *  Constant: '<S349>/Constant1'
     *  Constant: '<S349>/Constant2'
     *  Constant: '<S350>/Constant1'
     *  Constant: '<S350>/Constant2'
     *  DataStoreRead: '<S348>/StatusByte_CT2_SnsrCktHi'
     *  DataStoreRead: '<S349>/StatusByte_CT2_SnsrCktLo'
     *  DataStoreRead: '<S350>/StatusByte_CT2_SnsrPerf'
     *  Logic: '<S343>/Logical2'
     *  Logic: '<S348>/LogicalOperator'
     *  Logic: '<S349>/LogicalOperator'
     *  Logic: '<S350>/LogicalOperator'
     *  RelationalOperator: '<S348>/RelationalOperator1'
     *  RelationalOperator: '<S348>/RelationalOperator2'
     *  RelationalOperator: '<S349>/RelationalOperator1'
     *  RelationalOperator: '<S349>/RelationalOperator2'
     *  RelationalOperator: '<S350>/RelationalOperator1'
     *  RelationalOperator: '<S350>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S348>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S348>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S349>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S349>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S350>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S350>/BitwiseOperator2'
     */
    rtb_Switch1_eo = (((((((sint32)TPCR_ac_DW.StatusByte_CT2_SnsrCktLo) & 1) > 0)
                        && ((((uint32)TPCR_ac_DW.StatusByte_CT2_SnsrCktLo) & 64U)
                            == 0U)) || (((((sint32)
                           TPCR_ac_DW.StatusByte_CT2_SnsrCktHi) & 1) > 0) &&
                        ((((uint32)TPCR_ac_DW.StatusByte_CT2_SnsrCktHi) & 64U) ==
                         0U))) || (((((sint32)TPCR_ac_DW.StatusByte_CT2_SnsrPerf)
                         & 1) > 0) && ((((uint32)
                          TPCR_ac_DW.StatusByte_CT2_SnsrPerf) & 64U) == 0U)));

#endif

    /* End of SignalConversion generated from: '<S343>/VariantSource2' */

    /* SignalConversion generated from: '<S343>/VariantSource' incorporates:
     *  Logic: '<S356>/LogicalOperator'
     *  RelationalOperator: '<S356>/RelationalOperator1'
     *  RelationalOperator: '<S356>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S356>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S356>/BitwiseOperator2'
     */
#if Rte_SysCon_Variant_TPCR_10

    /* Gain: '<S1042>/Gain' incorporates:
     *  Constant: '<S343>/Constant'
     */
    rtb_Gain_g = false;

#else

    /* Gain: '<S1042>/Gain' incorporates:
     *  Constant: '<S356>/Constant1'
     *  Constant: '<S356>/Constant2'
     *  DataStoreRead: '<S356>/StatusByte_ECH_TempIn'
     *  Logic: '<S356>/LogicalOperator'
     *  RelationalOperator: '<S356>/RelationalOperator1'
     *  RelationalOperator: '<S356>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S356>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S356>/BitwiseOperator2'
     */
    rtb_Gain_g = (((((sint32)TPCR_ac_DW.StatusByte_ECH_TempIn) & 1) > 0) &&
                  ((((uint32)TPCR_ac_DW.StatusByte_ECH_TempIn) & 64U) == 0U));

#endif

    /* End of SignalConversion generated from: '<S343>/VariantSource' */

    /* SignalConversion generated from: '<S343>/VariantSource1' incorporates:
     *  Logic: '<S357>/LogicalOperator'
     *  RelationalOperator: '<S357>/RelationalOperator1'
     *  RelationalOperator: '<S357>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S357>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S357>/BitwiseOperator2'
     */
#if Rte_SysCon_Variant_TPCR_11

    /* Switch: '<S1016>/Switch2' incorporates:
     *  Constant: '<S343>/Constant1'
     */
    rtb_Switch2_nq = false;

#else

    /* Switch: '<S1016>/Switch2' incorporates:
     *  Constant: '<S357>/Constant1'
     *  Constant: '<S357>/Constant2'
     *  DataStoreRead: '<S357>/StatusByte_ECH_TempOut'
     *  Logic: '<S357>/LogicalOperator'
     *  RelationalOperator: '<S357>/RelationalOperator1'
     *  RelationalOperator: '<S357>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S357>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S357>/BitwiseOperator2'
     */
    rtb_Switch2_nq = (((((sint32)TPCR_ac_DW.StatusByte_ECH_TempOut) & 1) > 0) &&
                      ((((uint32)TPCR_ac_DW.StatusByte_ECH_TempOut) & 64U) == 0U));

#endif

    /* End of SignalConversion generated from: '<S343>/VariantSource1' */

    /* SignalConversion generated from: '<S343>/VariantSource4' incorporates:
     *  Logic: '<S355>/LogicalOperator'
     *  RelationalOperator: '<S355>/RelationalOperator1'
     *  RelationalOperator: '<S355>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S355>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S355>/BitwiseOperator2'
     */
#if Rte_SysCon_Variant_TPCR_16

    /* Switch: '<S340>/Switch' incorporates:
     *  Constant: '<S343>/Constant4'
     */
    rtb_Switch_e = false;

#else

    /* Switch: '<S340>/Switch' incorporates:
     *  Constant: '<S355>/Constant1'
     *  Constant: '<S355>/Constant2'
     *  DataStoreRead: '<S355>/StatusByte_CoolantVlvB_StkClsd'
     *  Logic: '<S355>/LogicalOperator'
     *  RelationalOperator: '<S355>/RelationalOperator1'
     *  RelationalOperator: '<S355>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S355>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S355>/BitwiseOperator2'
     */
    rtb_Switch_e = (((((sint32)TPCR_ac_DW.StatusByte_CoolantVlvB_StkClsd) & 1) >
                     0) && ((((uint32)TPCR_ac_DW.StatusByte_CoolantVlvB_StkClsd)
                      & 64U) == 0U));

#endif

    /* End of SignalConversion generated from: '<S343>/VariantSource4' */

    /* SignalConversion generated from: '<S343>/VariantSource3' incorporates:
     *  Logic: '<S343>/Logical10'
     *  Logic: '<S352>/LogicalOperator'
     *  Logic: '<S353>/LogicalOperator'
     *  Logic: '<S354>/LogicalOperator'
     *  RelationalOperator: '<S352>/RelationalOperator1'
     *  RelationalOperator: '<S352>/RelationalOperator2'
     *  RelationalOperator: '<S353>/RelationalOperator1'
     *  RelationalOperator: '<S353>/RelationalOperator2'
     *  RelationalOperator: '<S354>/RelationalOperator1'
     *  RelationalOperator: '<S354>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S352>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S352>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S353>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S353>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S354>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S354>/BitwiseOperator2'
     */
#if Rte_SysCon_Variant_TPCR_15

    /* Switch: '<S338>/Switch' incorporates:
     *  Constant: '<S343>/Constant3'
     */
    rtb_Switch_a5 = false;

#else

    /* Switch: '<S338>/Switch' incorporates:
     *  Constant: '<S352>/Constant1'
     *  Constant: '<S352>/Constant2'
     *  Constant: '<S353>/Constant1'
     *  Constant: '<S353>/Constant2'
     *  Constant: '<S354>/Constant1'
     *  Constant: '<S354>/Constant2'
     *  DataStoreRead: '<S352>/StatusByte_CoolantVlvB_CktHi'
     *  DataStoreRead: '<S353>/StatusByte_CoolantVlvB_CktLo'
     *  DataStoreRead: '<S354>/StatusByte_CoolantVlvB_Ckt'
     *  Logic: '<S343>/Logical10'
     *  Logic: '<S352>/LogicalOperator'
     *  Logic: '<S353>/LogicalOperator'
     *  Logic: '<S354>/LogicalOperator'
     *  RelationalOperator: '<S352>/RelationalOperator1'
     *  RelationalOperator: '<S352>/RelationalOperator2'
     *  RelationalOperator: '<S353>/RelationalOperator1'
     *  RelationalOperator: '<S353>/RelationalOperator2'
     *  RelationalOperator: '<S354>/RelationalOperator1'
     *  RelationalOperator: '<S354>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S352>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S352>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S353>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S353>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S354>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S354>/BitwiseOperator2'
     */
    rtb_Switch_a5 = (((((((sint32)TPCR_ac_DW.StatusByte_CoolantVlvB_Ckt) & 1) >
                        0) && ((((uint32)TPCR_ac_DW.StatusByte_CoolantVlvB_Ckt)
                         & 64U) == 0U)) || (((((sint32)
                          TPCR_ac_DW.StatusByte_CoolantVlvB_CktLo) & 1) > 0) &&
                       ((((uint32)TPCR_ac_DW.StatusByte_CoolantVlvB_CktLo) & 64U)
                        == 0U))) || (((((sint32)
                         TPCR_ac_DW.StatusByte_CoolantVlvB_CktHi) & 1) > 0) &&
                      ((((uint32)TPCR_ac_DW.StatusByte_CoolantVlvB_CktHi) & 64U)
                       == 0U)));

#endif

    /* End of SignalConversion generated from: '<S343>/VariantSource3' */

    /* S-Function (sfix_bitop): '<S368>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S368>/StatusByte_LIN2_BusOff'
     *  S-Function (sfix_bitop): '<S1393>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1401>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1442>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S376>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S408>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S413>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S429>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S447>/Bitwise Operator1'
     */
    rtb_Switch_cw_tmp = ((uint32)TPCR_ac_DW.StatusByte_LIN2_BusOff) & 64U;

    /* S-Function (sfix_bitop): '<S367>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S367>/StatusByte_LIN1_BusOff'
     *  S-Function (sfix_bitop): '<S1392>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1410>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1441>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S385>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S410>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S418>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S431>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S449>/Bitwise Operator2'
     */
    rtb_Switch_cw_tmp_0 = ((uint32)TPCR_ac_DW.StatusByte_LIN1_BusOff) & 1U;

    /* S-Function (sfix_bitop): '<S367>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S367>/StatusByte_LIN1_BusOff'
     *  S-Function (sfix_bitop): '<S1392>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1410>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1441>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S385>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S410>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S418>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S431>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S449>/Bitwise Operator1'
     */
    rtb_Switch_cw_tmp_1 = ((uint32)TPCR_ac_DW.StatusByte_LIN1_BusOff) & 64U;

    /* S-Function (sfix_bitop): '<S369>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S369>/StatusByte_LIN3_BusOff'
     *  S-Function (sfix_bitop): '<S1394>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1411>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1443>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S386>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S409>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S419>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S430>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S448>/Bitwise Operator2'
     */
    rtb_Switch_cw_tmp_2 = ((uint32)TPCR_ac_DW.StatusByte_LIN3_BusOff) & 1U;

    /* S-Function (sfix_bitop): '<S369>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S369>/StatusByte_LIN3_BusOff'
     *  S-Function (sfix_bitop): '<S1394>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1411>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1443>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S386>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S409>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S419>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S430>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S448>/Bitwise Operator1'
     */
    rtb_Switch_cw_tmp_3 = ((uint32)TPCR_ac_DW.StatusByte_LIN3_BusOff) & 64U;

    /* RelationalOperator: '<S344>/Relational Operator' incorporates:
     *  RelationalOperator: '<S344>/Relational Operator1'
     *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
     */
    rtb_Switch_cw_tmp_4 = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_io;

    /* S-Function (sfix_bitop): '<S376>/BitwiseOperator2' incorporates:
     *  DataStoreRead: '<S376>/StatusByte_LIN2_BusOff'
     *  S-Function (sfix_bitop): '<S1401>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S413>/BitwiseOperator2'
     */
    rtb_Switch_cw_tmp_5 = ((sint32)TPCR_ac_DW.StatusByte_LIN2_BusOff) & 1;

    /* S-Function (sfix_bitop): '<S368>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S368>/StatusByte_LIN2_BusOff'
     *  S-Function (sfix_bitop): '<S1393>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1442>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S408>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S429>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S447>/Bitwise Operator2'
     */
    rtb_Switch_cw_tmp_6 = ((uint32)TPCR_ac_DW.StatusByte_LIN2_BusOff) & 1U;

    /* S-Function (sfix_bitop): '<S375>/BitwiseOperator2' incorporates:
     *  DataStoreRead: '<S375>/StatusByte_CoolPmpACtrlCktPerf'
     *  S-Function (sfix_bitop): '<S1400>/BitwiseOperator2'
     */
    rtb_Switch_cw_tmp_7 = ((sint32)TPCR_ac_DW.StatusByte_CoolPmpACtrlCktPerf) &
        1;

    /* S-Function (sfix_bitop): '<S375>/BitwiseOperator1' incorporates:
     *  DataStoreRead: '<S375>/StatusByte_CoolPmpACtrlCktPerf'
     *  S-Function (sfix_bitop): '<S1400>/BitwiseOperator1'
     */
    rtb_Switch_cw_tmp_8 = ((uint32)TPCR_ac_DW.StatusByte_CoolPmpACtrlCktPerf) &
        64U;

    /* S-Function (sfix_bitop): '<S377>/BitwiseOperator2' incorporates:
     *  DataStoreRead: '<S377>/StatusByte_LostCommCoolPmpA'
     *  S-Function (sfix_bitop): '<S1402>/BitwiseOperator2'
     */
    rtb_Switch_cw_tmp_9 = ((sint32)TPCR_ac_DW.StatusByte_LostCommCoolPmpA) & 1;

    /* S-Function (sfix_bitop): '<S377>/BitwiseOperator1' incorporates:
     *  DataStoreRead: '<S377>/StatusByte_LostCommCoolPmpA'
     *  S-Function (sfix_bitop): '<S1402>/BitwiseOperator1'
     */
    rtb_Switch_cw_tmp_a = ((uint32)TPCR_ac_DW.StatusByte_LostCommCoolPmpA) & 64U;

    /* S-Function (sfix_bitop): '<S366>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S366>/StatusByte_CoolHeaterAPerf'
     *  S-Function (sfix_bitop): '<S1371>/BitwiseOperator1'
     */
    rtb_Switch_cw_tmp_b = ((uint32)TPCR_ac_DW.StatusByte_CoolHeaterAPerf) & 64U;

    /* S-Function (sfix_bitop): '<S351>/BitwiseOperator2' incorporates:
     *  DataStoreRead: '<S351>/StatusByte_CoolPmpATempSnsrPerf'
     *  S-Function (sfix_bitop): '<S1372>/BitwiseOperator2'
     */
    rtb_Switch_cw_tmp_c = ((sint32)TPCR_ac_DW.StatusByte_CoolPmpATempSnsrPerf) &
        1;

    /* S-Function (sfix_bitop): '<S351>/BitwiseOperator1' incorporates:
     *  DataStoreRead: '<S351>/StatusByte_CoolPmpATempSnsrPerf'
     *  S-Function (sfix_bitop): '<S1372>/BitwiseOperator1'
     */
    rtb_Switch_cw_tmp_d = ((uint32)TPCR_ac_DW.StatusByte_CoolPmpATempSnsrPerf) &
        64U;

    /* RelationalOperator: '<S345>/Comparison4' incorporates:
     *  RelationalOperator: '<S1344>/Comparison4'
     *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
     */
    rtb_Switch_cw_tmp_e = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ec;

    /* S-Function (sfix_bitop): '<S370>/Bitwise Operator2' incorporates:
     *  DataStoreRead: '<S370>/StatusByte_CoolantVlvB_StkOpn'
     *  S-Function (sfix_bitop): '<S1428>/Bitwise Operator2'
     */
    rtb_Switch_cw_tmp_f = ((uint32)TPCR_ac_DW.StatusByte_CoolantVlvB_StkOpn) &
        1U;

    /* S-Function (sfix_bitop): '<S370>/Bitwise Operator1' incorporates:
     *  DataStoreRead: '<S370>/StatusByte_CoolantVlvB_StkOpn'
     *  S-Function (sfix_bitop): '<S1428>/Bitwise Operator1'
     */
    rtb_Switch_cw_tmp_g = ((uint32)TPCR_ac_DW.StatusByte_CoolantVlvB_StkOpn) &
        64U;

    /* Switch: '<S338>/Switch' incorporates:
     *  Constant: '<S351>/Constant1'
     *  Constant: '<S351>/Constant2'
     *  Constant: '<S360>/Calib'
     *  Constant: '<S361>/Calib'
     *  Constant: '<S362>/Calib'
     *  Constant: '<S363>/Calib'
     *  Constant: '<S364>/Calib'
     *  Constant: '<S365>/Calib'
     *  Constant: '<S366>/Constant1'
     *  Constant: '<S366>/Constant2'
     *  Constant: '<S367>/Constant1'
     *  Constant: '<S367>/Constant2'
     *  Constant: '<S368>/Constant1'
     *  Constant: '<S368>/Constant2'
     *  Constant: '<S369>/Constant1'
     *  Constant: '<S369>/Constant2'
     *  Constant: '<S370>/Constant1'
     *  Constant: '<S370>/Constant2'
     *  Constant: '<S371>/Constant'
     *  Constant: '<S372>/Constant'
     *  Constant: '<S373>/Calib'
     *  Constant: '<S374>/Constant'
     *  Constant: '<S375>/Constant1'
     *  Constant: '<S375>/Constant2'
     *  Constant: '<S376>/Constant1'
     *  Constant: '<S376>/Constant2'
     *  Constant: '<S377>/Constant1'
     *  Constant: '<S377>/Constant2'
     *  Constant: '<S378>/Calib'
     *  Constant: '<S379>/Calib'
     *  Constant: '<S380>/Calib'
     *  Constant: '<S381>/Calib'
     *  Constant: '<S382>/Calib'
     *  Constant: '<S383>/Calib'
     *  Constant: '<S384>/Calib'
     *  Constant: '<S385>/Constant1'
     *  Constant: '<S385>/Constant2'
     *  Constant: '<S386>/Constant1'
     *  Constant: '<S386>/Constant2'
     *  DataStoreRead: '<S366>/StatusByte_CoolHeaterAPerf'
     *  Logic: '<S338>/Logical6'
     *  Logic: '<S343>/Logical1'
     *  Logic: '<S343>/Logical3'
     *  Logic: '<S343>/Logical4'
     *  Logic: '<S343>/Logical6'
     *  Logic: '<S343>/Logical7'
     *  Logic: '<S343>/Logical8'
     *  Logic: '<S343>/Logical9'
     *  Logic: '<S344>/Logical1'
     *  Logic: '<S344>/Logical4'
     *  Logic: '<S345>/Logical1'
     *  Logic: '<S345>/Logical2'
     *  Logic: '<S345>/Logical20'
     *  Logic: '<S345>/Logical3'
     *  Logic: '<S345>/Logical4'
     *  Logic: '<S345>/Logical5'
     *  Logic: '<S345>/Logical6'
     *  Logic: '<S345>/Logical7'
     *  Logic: '<S351>/LogicalOperator'
     *  Logic: '<S366>/Logical Operator'
     *  Logic: '<S367>/Logical Operator'
     *  Logic: '<S368>/Logical Operator'
     *  Logic: '<S369>/Logical Operator'
     *  Logic: '<S370>/Logical Operator'
     *  Logic: '<S375>/LogicalOperator'
     *  Logic: '<S376>/LogicalOperator'
     *  Logic: '<S377>/LogicalOperator'
     *  Logic: '<S385>/Logical Operator'
     *  Logic: '<S386>/Logical Operator'
     *  RelationalOperator: '<S344>/Relational Operator'
     *  RelationalOperator: '<S344>/Relational Operator1'
     *  RelationalOperator: '<S345>/Comparison4'
     *  RelationalOperator: '<S351>/RelationalOperator1'
     *  RelationalOperator: '<S351>/RelationalOperator2'
     *  RelationalOperator: '<S366>/Relational Operator1'
     *  RelationalOperator: '<S366>/Relational Operator2'
     *  RelationalOperator: '<S367>/Relational Operator1'
     *  RelationalOperator: '<S367>/Relational Operator2'
     *  RelationalOperator: '<S368>/Relational Operator1'
     *  RelationalOperator: '<S368>/Relational Operator2'
     *  RelationalOperator: '<S369>/Relational Operator1'
     *  RelationalOperator: '<S369>/Relational Operator2'
     *  RelationalOperator: '<S370>/Relational Operator1'
     *  RelationalOperator: '<S370>/Relational Operator2'
     *  RelationalOperator: '<S375>/RelationalOperator1'
     *  RelationalOperator: '<S375>/RelationalOperator2'
     *  RelationalOperator: '<S376>/RelationalOperator1'
     *  RelationalOperator: '<S376>/RelationalOperator2'
     *  RelationalOperator: '<S377>/RelationalOperator1'
     *  RelationalOperator: '<S377>/RelationalOperator2'
     *  RelationalOperator: '<S385>/Relational Operator1'
     *  RelationalOperator: '<S385>/Relational Operator2'
     *  RelationalOperator: '<S386>/Relational Operator1'
     *  RelationalOperator: '<S386>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S351>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S351>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S366>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S366>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S367>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S367>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S368>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S368>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S369>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S369>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S370>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S370>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S375>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S375>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S376>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S377>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S377>/BitwiseOperator2'
     */
    rtb_Switch_a5 = ((((VeTPCC_b_HtrStsFlty_RawPrst) ||
                       (((((((((((rtb_Switch3_c2 || rtb_Switch1_eo) ||
        rtb_Gain_g) || rtb_Switch2_nq) || (((rtb_Switch_cw_tmp_c > 0) &&
        (rtb_Switch_cw_tmp_d == 0U)) && (KeTPCR_b_Enbl_HTAP_TmpFlt_CabPrec))) ||
        rtb_Switch_e) || rtb_Switch_a5) || ((((((uint32)
        TPCR_ac_DW.StatusByte_CoolHeaterAPerf) & 1U) != 0U) &&
        (rtb_Switch_cw_tmp_b == 0U)) && (KeTPCR_b_Enbl_ECH_CHtrPrfFlt_CabPrec)))
                           || (((rtb_Switch_cw_tmp_0 != 0U) &&
        (rtb_Switch_cw_tmp_1 == 0U)) && (KeTPCR_b_Enbl_ECH_LIN1BusFlt_CabPrec)))
                          || (((rtb_Switch_cw_tmp_6 != 0U) && (rtb_Switch_cw_tmp
        == 0U)) && (KeTPCR_b_Enbl_ECH_LIN2BusFlt_CabPrec))) ||
                         (((rtb_Switch_cw_tmp_2 != 0U) && (rtb_Switch_cw_tmp_3 ==
                            0U)) && (KeTPCR_b_Enbl_ECH_LIN3BusFlt_CabPrec))) ||
                        (((rtb_Switch_cw_tmp_f != 0U) && (rtb_Switch_cw_tmp_g ==
                           0U)) && (KeTPCR_b_Enbl_HTSOV_CabinPrec_StckFlts)))) ||
                      (((((((((rtb_Switch_cw_tmp_7 > 0) && (rtb_Switch_cw_tmp_8 ==
        0U)) && (KeTPCR_b_Enbl_HTAP_PerfFlt_CabPrec)) || (((rtb_Switch_cw_tmp_9 >
        0) && (rtb_Switch_cw_tmp_a == 0U)) && (KeTPCR_b_Enbl_LOC_HTAP_CabPrec)))
                           || (((rtb_Switch_cw_tmp_5 > 0) && (rtb_Switch_cw_tmp ==
        0U)) && (KeTPCR_b_Enbl_LIN2BusOff_Flt_CabPrec))) ||
                          ((CePMPR_e_FTSNA_False != ((uint32)rtb_Switch_cw_tmp_e))
                           && (KeTPCR_b_Enbl_HTAPDryRun_FltCabPrec))) ||
                         ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_fi) &&
                          (KeTPCR_b_Enbl_HTAPDryRunFA_CabPrec))) ||
                        (((rtb_Switch_cw_tmp_0 != 0U) && (rtb_Switch_cw_tmp_1 ==
                           0U)) && (KeTPCR_b_Enbl_LIN1BusOff_Flt_CabPrec))) ||
                       (((rtb_Switch_cw_tmp_2 != 0U) && (rtb_Switch_cw_tmp_3 ==
                          0U)) && (KeTPCR_b_Enbl_LIN3BusOff_Flt_CabPrec)))) ||
                     (((((uint32)rtb_Switch_cw_tmp_4) == CeRCVR_e_Open) ||
                       (((uint32)rtb_Switch_cw_tmp_4) == CeRCVR_e_SNA)) &&
                      (KeTPCR_b_Enbl_HCBV_Stuck_Flt)));

    /* Logic: '<S338>/Logical4' incorporates:
     *  Logic: '<S338>/Logical1'
     *  Logic: '<S338>/Logical7'
     *  Logic: '<S8>/Logical1'
     */
    VeTPCC_b_HtrStsFlty_Prst = (((rtb_LogicalOperator_h0 &&
        (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ba)) || (VeTPCR_b_SC_WakeUpReq))
        && rtb_Switch_a5);

    /* RelationalOperator: '<S340>/Comparison11' incorporates:
     *  Constant: '<S397>/Constant'
     *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
     */
    VeTPCC_b_EAC_BatThrmlFlt_Prst = (((uint32)
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_fo) ==
        CeHCDR_e_BattThermalCompFault);

    /* S-Function (sfix_bitop): '<S414>/BitwiseOperator2' incorporates:
     *  Logic: '<S414>/LogicalOperator'
     *  RelationalOperator: '<S414>/RelationalOperator1'
     *  RelationalOperator: '<S414>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S414>/BitwiseOperator1'
     *  SignalConversion generated from: '<S395>/VariantSource'
     */
#if Rte_SysCon_Variant_TPCR_8

    /* Switch: '<S340>/Switch' incorporates:
     *  Constant: '<S414>/Constant1'
     *  Constant: '<S414>/Constant2'
     *  DataStoreRead: '<S414>/StatusByte_LostCommEAC'
     */
    rtb_Switch_e = (((((sint32)TPCR_ac_DW.StatusByte_LostCommEAC) & 1) > 0) &&
                    ((((uint32)TPCR_ac_DW.StatusByte_LostCommEAC) & 64U) == 0U));

#else

    /* Switch: '<S340>/Switch' incorporates:
     *  Constant: '<S395>/Constant'
     *  SignalConversion generated from: '<S395>/VariantSource'
     */
    rtb_Switch_e = false;

#endif

    /* End of S-Function (sfix_bitop): '<S414>/BitwiseOperator2' */

    /* SignalConversion generated from: '<S395>/VariantSource' */
    VeTPCR_b_EAC_LOC = rtb_Switch_e;

    /* S-Function (sfix_bitop): '<S412>/BitwiseOperator2' incorporates:
     *  Logic: '<S412>/LogicalOperator'
     *  RelationalOperator: '<S412>/RelationalOperator1'
     *  RelationalOperator: '<S412>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S412>/BitwiseOperator1'
     *  SignalConversion generated from: '<S395>/VariantSource1'
     */
#if Rte_SysCon_Variant_TPCR_9

    /* Switch: '<S340>/Switch' incorporates:
     *  Constant: '<S412>/Constant1'
     *  Constant: '<S412>/Constant2'
     *  DataStoreRead: '<S412>/StatusByte_EACPerf'
     */
    rtb_Switch_e = (((((sint32)TPCR_ac_DW.StatusByte_EACPerf) & 1) > 0) &&
                    ((((uint32)TPCR_ac_DW.StatusByte_EACPerf) & 64U) == 0U));

#else

    /* Switch: '<S340>/Switch' incorporates:
     *  Constant: '<S395>/Constant1'
     *  SignalConversion generated from: '<S395>/VariantSource1'
     */
    rtb_Switch_e = false;

#endif

    /* End of S-Function (sfix_bitop): '<S412>/BitwiseOperator2' */

    /* SignalConversion generated from: '<S395>/VariantSource1' */
    VeTPCR_b_EAC_PerfFlt = rtb_Switch_e;

    /* Logic: '<S395>/Logical4' incorporates:
     *  Constant: '<S413>/Constant1'
     *  Constant: '<S413>/Constant2'
     *  Constant: '<S416>/Calib'
     *  Logic: '<S413>/LogicalOperator'
     *  RelationalOperator: '<S413>/RelationalOperator1'
     *  RelationalOperator: '<S413>/RelationalOperator2'
     */
    VeTPCR_b_LIN2BusOff_AC = (((rtb_Switch_cw_tmp_5 > 0) && (rtb_Switch_cw_tmp ==
        0U)) && (KeTPCR_b_Enbl_LIN2BusOff_AC_CabPrec));

    /* SignalConversion generated from: '<S402>/VariantSource' */
#if Rte_SysCon_Variant_TPCR_26

    /* Switch: '<S340>/Switch' */
    rtb_Switch_e = TPCR_ac_B.VM_Conditional_Signal_TmpVM__a4;

#else

    /* Switch: '<S340>/Switch' incorporates:
     *  Constant: '<S402>/Constant'
     *  SignalConversion generated from: '<S402>/VariantSource'
     */
    rtb_Switch_e = false;

#endif

    /* End of SignalConversion generated from: '<S402>/VariantSource' */

    /* S-Function (sfix_bitop): '<S455>/BitwiseOperator2' incorporates:
     *  Logic: '<S455>/LogicalOperator'
     *  RelationalOperator: '<S455>/RelationalOperator1'
     *  RelationalOperator: '<S455>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S455>/BitwiseOperator1'
     *  SignalConversion generated from: '<S401>/VariantSource2'
     */
#if Rte_SysCon_Variant_TPCR_25

    /* Switch: '<S1016>/Switch2' incorporates:
     *  Constant: '<S455>/Constant1'
     *  Constant: '<S455>/Constant2'
     *  DataStoreRead: '<S455>/StatusByte_AC_RefrigPresSnsrAPerf'
     */
    rtb_Switch2_nq = (((((sint32)TPCR_ac_DW.StatusByte_AC_RefrigPresSnsrAPe) & 1)
                       > 0) && ((((uint32)
                         TPCR_ac_DW.StatusByte_AC_RefrigPresSnsrAPe) & 64U) ==
                       0U));

#else

    /* Switch: '<S1016>/Switch2' incorporates:
     *  Constant: '<S401>/Constant2'
     *  SignalConversion generated from: '<S401>/VariantSource2'
     */
    rtb_Switch2_nq = false;

#endif

    /* End of S-Function (sfix_bitop): '<S455>/BitwiseOperator2' */

    /* SignalConversion generated from: '<S401>/VariantSource2' */
    VeTPCR_b_PressSnsr_Perf_Flt = rtb_Switch2_nq;

    /* S-Function (sfix_bitop): '<S454>/BitwiseOperator2' incorporates:
     *  Logic: '<S454>/LogicalOperator'
     *  RelationalOperator: '<S454>/RelationalOperator1'
     *  RelationalOperator: '<S454>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S454>/BitwiseOperator1'
     *  SignalConversion generated from: '<S401>/VariantSource1'
     */
#if Rte_SysCon_Variant_TPCR_24

    /* Switch: '<S1016>/Switch2' incorporates:
     *  Constant: '<S454>/Constant1'
     *  Constant: '<S454>/Constant2'
     *  DataStoreRead: '<S454>/StatusByte_AC_RefrigPresSnsrALo'
     */
    rtb_Switch2_nq = (((((sint32)TPCR_ac_DW.StatusByte_AC_RefrigPresSnsrALo) & 1)
                       > 0) && ((((uint32)
                         TPCR_ac_DW.StatusByte_AC_RefrigPresSnsrALo) & 64U) ==
                       0U));

#else

    /* Switch: '<S1016>/Switch2' incorporates:
     *  Constant: '<S401>/Constant1'
     *  SignalConversion generated from: '<S401>/VariantSource1'
     */
    rtb_Switch2_nq = false;

#endif

    /* End of S-Function (sfix_bitop): '<S454>/BitwiseOperator2' */

    /* SignalConversion generated from: '<S401>/VariantSource1' */
    VeTPCR_b_PressSnsrLo_Flt = rtb_Switch2_nq;

    /* S-Function (sfix_bitop): '<S453>/BitwiseOperator2' incorporates:
     *  Logic: '<S453>/LogicalOperator'
     *  RelationalOperator: '<S453>/RelationalOperator1'
     *  RelationalOperator: '<S453>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S453>/BitwiseOperator1'
     *  SignalConversion generated from: '<S401>/VariantSource'
     */
#if Rte_SysCon_Variant_TPCR_23

    /* Switch: '<S1016>/Switch2' incorporates:
     *  Constant: '<S453>/Constant1'
     *  Constant: '<S453>/Constant2'
     *  DataStoreRead: '<S453>/StatusByte_AC_RefrigPresSnsrAHi'
     */
    rtb_Switch2_nq = (((((sint32)TPCR_ac_DW.StatusByte_AC_RefrigPresSnsrAHi) & 1)
                       > 0) && ((((uint32)
                         TPCR_ac_DW.StatusByte_AC_RefrigPresSnsrAHi) & 64U) ==
                       0U));

#else

    /* Switch: '<S1016>/Switch2' incorporates:
     *  Constant: '<S401>/Constant'
     *  SignalConversion generated from: '<S401>/VariantSource'
     */
    rtb_Switch2_nq = false;

#endif

    /* End of S-Function (sfix_bitop): '<S453>/BitwiseOperator2' */

    /* SignalConversion generated from: '<S401>/VariantSource' */
    VeTPCR_b_PressSnsrHi_Flt = rtb_Switch2_nq;

    /* Logic: '<S401>/Logical1' */
    VeTPCR_b_PressSnsr_Flts = (((VeTPCR_b_PressSnsr_Perf_Flt) ||
        (VeTPCR_b_PressSnsrLo_Flt)) || (VeTPCR_b_PressSnsrHi_Flt));

    /* S-Function (sfix_bitop): '<S434>/BitwiseOperator2' incorporates:
     *  Logic: '<S434>/LogicalOperator'
     *  RelationalOperator: '<S434>/RelationalOperator1'
     *  RelationalOperator: '<S434>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S434>/BitwiseOperator1'
     *  SignalConversion generated from: '<S398>/VariantSource'
     */
#if Rte_SysCon_Variant_TPCR_13

    /* Switch: '<S1016>/Switch2' incorporates:
     *  Constant: '<S434>/Constant1'
     *  Constant: '<S434>/Constant2'
     *  DataStoreRead: '<S434>/StatusByte_EvapRefriShutoffCtrlCktFlt'
     */
    rtb_Switch2_nq = (((((sint32)TPCR_ac_DW.StatusByte_EvapRefriShutoffCtrl) & 1)
                       > 0) && ((((uint32)
                         TPCR_ac_DW.StatusByte_EvapRefriShutoffCtrl) & 64U) ==
                       0U));

#else

    /* Switch: '<S1016>/Switch2' incorporates:
     *  Constant: '<S398>/Constant'
     *  SignalConversion generated from: '<S398>/VariantSource'
     */
    rtb_Switch2_nq = false;

#endif

    /* End of S-Function (sfix_bitop): '<S434>/BitwiseOperator2' */

    /* SignalConversion generated from: '<S398>/VariantSource' */
    VeTPCR_b_FRSOV_Perf_Flt = rtb_Switch2_nq;

    /* Logic: '<S398>/Logical9' incorporates:
     *  Constant: '<S436>/Constant1'
     *  Constant: '<S436>/Constant2'
     *  Constant: '<S437>/Calib'
     *  DataStoreRead: '<S436>/StatusByte_EvapRefrishutoffCtrlShrtGndFlt'
     *  Logic: '<S436>/LogicalOperator'
     *  RelationalOperator: '<S436>/RelationalOperator1'
     *  RelationalOperator: '<S436>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S436>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S436>/BitwiseOperator2'
     */
    VeTPCR_b_FRSOVLo_Flt = ((((((sint32)
        TPCR_ac_DW.StatusByte_EvapRefrishutoffCtrl) & 1) > 0) && ((((uint32)
        TPCR_ac_DW.StatusByte_EvapRefrishutoffCtrl) & 64U) == 0U)) &&
                            (KeTPCR_b_Enbl_FRSOV_STG));

    /* S-Function (sfix_bitop): '<S435>/BitwiseOperator2' incorporates:
     *  Logic: '<S435>/LogicalOperator'
     *  RelationalOperator: '<S435>/RelationalOperator1'
     *  RelationalOperator: '<S435>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S435>/BitwiseOperator1'
     *  SignalConversion generated from: '<S398>/VariantSource1'
     */
#if Rte_SysCon_Variant_TPCR_14

    /* Switch: '<S1016>/Switch2' incorporates:
     *  Constant: '<S435>/Constant1'
     *  Constant: '<S435>/Constant2'
     *  DataStoreRead: '<S435>/StatusByte_EvapRefriShutoffCtrlshrtBattFlt'
     */
    rtb_Switch2_nq = (((((sint32)TPCR_ac_DW.StatusByte_EvapRefriShutoffCt_d) & 1)
                       > 0) && ((((uint32)
                         TPCR_ac_DW.StatusByte_EvapRefriShutoffCt_d) & 64U) ==
                       0U));

#else

    /* Switch: '<S1016>/Switch2' incorporates:
     *  Constant: '<S398>/Constant1'
     *  SignalConversion generated from: '<S398>/VariantSource1'
     */
    rtb_Switch2_nq = false;

#endif

    /* End of S-Function (sfix_bitop): '<S435>/BitwiseOperator2' */

    /* SignalConversion generated from: '<S398>/VariantSource1' */
    VeTPCR_b_FRSOVHi_Flt = rtb_Switch2_nq;

    /* Logic: '<S398>/Logical1' */
    VeTPCR_b_FRSOV_Flts = (((VeTPCR_b_FRSOV_Perf_Flt) || (VeTPCR_b_FRSOVLo_Flt))
                           || (VeTPCR_b_FRSOVHi_Flt));

    /* Switch: '<S340>/Switch' incorporates:
     *  Constant: '<S403>/Calib'
     *  Constant: '<S404>/Calib'
     *  Constant: '<S405>/Calib'
     *  Constant: '<S406>/Calib'
     *  Constant: '<S407>/Calib'
     *  Constant: '<S408>/Constant1'
     *  Constant: '<S408>/Constant2'
     *  Constant: '<S409>/Constant1'
     *  Constant: '<S409>/Constant2'
     *  Constant: '<S410>/Constant1'
     *  Constant: '<S410>/Constant2'
     *  Constant: '<S411>/Constant1'
     *  Constant: '<S411>/Constant2'
     *  Constant: '<S415>/Calib'
     *  Constant: '<S417>/Calib'
     *  Constant: '<S418>/Constant1'
     *  Constant: '<S418>/Constant2'
     *  Constant: '<S419>/Constant1'
     *  Constant: '<S419>/Constant2'
     *  DataStoreRead: '<S411>/StatusByte_LostCommACRefrigExpVlvActA'
     *  Logic: '<S340>/Logical2'
     *  Logic: '<S394>/Logical Operator'
     *  Logic: '<S394>/Logical Operator1'
     *  Logic: '<S394>/Logical Operator2'
     *  Logic: '<S394>/Logical Operator3'
     *  Logic: '<S394>/Logical Operator4'
     *  Logic: '<S394>/Logical Operator5'
     *  Logic: '<S394>/Logical Operator6'
     *  Logic: '<S395>/Logical Operator'
     *  Logic: '<S395>/Logical Operator1'
     *  Logic: '<S395>/Logical3'
     *  Logic: '<S408>/Logical Operator'
     *  Logic: '<S409>/Logical Operator'
     *  Logic: '<S410>/Logical Operator'
     *  Logic: '<S411>/Logical Operator'
     *  Logic: '<S418>/Logical Operator'
     *  Logic: '<S419>/Logical Operator'
     *  RelationalOperator: '<S408>/Relational Operator1'
     *  RelationalOperator: '<S408>/Relational Operator2'
     *  RelationalOperator: '<S409>/Relational Operator1'
     *  RelationalOperator: '<S409>/Relational Operator2'
     *  RelationalOperator: '<S410>/Relational Operator1'
     *  RelationalOperator: '<S410>/Relational Operator2'
     *  RelationalOperator: '<S411>/Relational Operator1'
     *  RelationalOperator: '<S411>/Relational Operator2'
     *  RelationalOperator: '<S418>/Relational Operator1'
     *  RelationalOperator: '<S418>/Relational Operator2'
     *  RelationalOperator: '<S419>/Relational Operator1'
     *  RelationalOperator: '<S419>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S411>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S411>/Bitwise Operator2'
     */
    rtb_Switch_e = ((((((VeTPCC_b_EAC_BatThrmlFlt_Prst) || (((((VeTPCR_b_EAC_LOC)
                            || (VeTPCR_b_EAC_PerfFlt)) ||
                           (VeTPCR_b_LIN2BusOff_AC)) || (((rtb_Switch_cw_tmp_0
        != 0U) && (rtb_Switch_cw_tmp_1 == 0U)) &&
                           (KeTPCR_b_Enbl_LIN1BusOff_AC_CabPrec))) ||
                         (((rtb_Switch_cw_tmp_2 != 0U) && (rtb_Switch_cw_tmp_3 ==
                            0U)) && (KeTPCR_b_Enbl_LIN3BusOff_AC_CabPrec)))) ||
                       rtb_Switch_e) || (VeTPCR_b_PressSnsr_Flts)) ||
                     (VeTPCR_b_FRSOV_Flts)) || ((((((((uint32)
                           TPCR_ac_DW.StatusByte_LostCommACRefrigExpV) & 1U) !=
                         0U) && ((((uint32)
                           TPCR_ac_DW.StatusByte_LostCommACRefrigExpV) & 64U) ==
                         0U)) && (KeTPCR_b_Enbl_CEXV_LOCRefFlt_CabPrec)) ||
                      (((((rtb_Switch_cw_tmp_0 != 0U) && (rtb_Switch_cw_tmp_1 ==
                           0U)) && (KeTPCR_b_Enbl_CEXV_LIN1BusFlt)) ||
                        (((rtb_Switch_cw_tmp_6 != 0U) && (rtb_Switch_cw_tmp ==
                           0U)) && (KeTPCR_b_Enbl_CEXV_LIN2BusFlt))) ||
                       (((rtb_Switch_cw_tmp_2 != 0U) && (rtb_Switch_cw_tmp_3 ==
                          0U)) && (KeTPCR_b_Enbl_CEXV_LIN3BusFlt)))) ||
                     ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pe) &&
                      (KeTPCR_b_Enbl_EXV_PerfDiag_Flt))));

    /* Logic: '<S340>/Logical4' incorporates:
     *  Constant: '<S420>/Calib'
     *  Constant: '<S421>/Calib'
     *  Constant: '<S422>/Calib'
     *  Constant: '<S423>/Calib'
     *  Constant: '<S424>/Calib'
     *  Constant: '<S425>/Calib'
     *  Constant: '<S426>/Calib'
     *  Constant: '<S427>/Calib'
     *  Constant: '<S428>/Calib'
     *  Constant: '<S429>/Constant1'
     *  Constant: '<S429>/Constant2'
     *  Constant: '<S430>/Constant1'
     *  Constant: '<S430>/Constant2'
     *  Constant: '<S431>/Constant1'
     *  Constant: '<S431>/Constant2'
     *  Constant: '<S432>/Constant1'
     *  Constant: '<S432>/Constant2'
     *  Constant: '<S433>/Constant1'
     *  Constant: '<S433>/Constant2'
     *  Constant: '<S438>/Calib'
     *  Constant: '<S439>/Calib'
     *  Constant: '<S440>/Calib'
     *  Constant: '<S441>/Calib'
     *  Constant: '<S442>/Calib'
     *  Constant: '<S443>/Calib'
     *  Constant: '<S444>/Calib'
     *  Constant: '<S445>/Calib'
     *  Constant: '<S446>/Calib'
     *  Constant: '<S447>/Constant1'
     *  Constant: '<S447>/Constant2'
     *  Constant: '<S448>/Constant1'
     *  Constant: '<S448>/Constant2'
     *  Constant: '<S449>/Constant1'
     *  Constant: '<S449>/Constant2'
     *  Constant: '<S450>/Constant1'
     *  Constant: '<S450>/Constant2'
     *  Constant: '<S451>/Constant1'
     *  Constant: '<S451>/Constant2'
     *  Constant: '<S452>/Constant1'
     *  Constant: '<S452>/Constant2'
     *  DataStoreRead: '<S432>/StatusByte_AC_RefrigTempSnsrCPerf'
     *  DataStoreRead: '<S433>/StatusByte_LostCommACRefrigExpVlvActC'
     *  DataStoreRead: '<S450>/StatusByte_LostCommACRefrigExpVlvActD'
     *  DataStoreRead: '<S451>/StatusByte_AC_RefrigTempSnsr4CktPerf'
     *  DataStoreRead: '<S452>/StatusByte_AC_RefrigTempSnsr5CktPerf'
     *  Logic: '<S340>/Logical Operator'
     *  Logic: '<S340>/Logical1'
     *  Logic: '<S340>/Logical3'
     *  Logic: '<S396>/Logical Operator'
     *  Logic: '<S396>/Logical Operator1'
     *  Logic: '<S396>/Logical Operator10'
     *  Logic: '<S396>/Logical Operator2'
     *  Logic: '<S396>/Logical Operator3'
     *  Logic: '<S396>/Logical Operator4'
     *  Logic: '<S396>/Logical Operator5'
     *  Logic: '<S396>/Logical Operator6'
     *  Logic: '<S396>/Logical Operator7'
     *  Logic: '<S396>/Logical Operator8'
     *  Logic: '<S396>/Logical Operator9'
     *  Logic: '<S400>/Logical Operator'
     *  Logic: '<S400>/Logical Operator1'
     *  Logic: '<S400>/Logical Operator10'
     *  Logic: '<S400>/Logical Operator2'
     *  Logic: '<S400>/Logical Operator3'
     *  Logic: '<S400>/Logical Operator4'
     *  Logic: '<S400>/Logical Operator5'
     *  Logic: '<S400>/Logical Operator6'
     *  Logic: '<S400>/Logical Operator7'
     *  Logic: '<S400>/Logical Operator8'
     *  Logic: '<S400>/Logical Operator9'
     *  Logic: '<S429>/Logical Operator'
     *  Logic: '<S430>/Logical Operator'
     *  Logic: '<S431>/Logical Operator'
     *  Logic: '<S432>/Logical Operator'
     *  Logic: '<S433>/Logical Operator'
     *  Logic: '<S447>/Logical Operator'
     *  Logic: '<S448>/Logical Operator'
     *  Logic: '<S449>/Logical Operator'
     *  Logic: '<S450>/Logical Operator'
     *  Logic: '<S451>/Logical Operator'
     *  Logic: '<S452>/Logical Operator'
     *  Logic: '<S8>/Logical1'
     *  RelationalOperator: '<S429>/Relational Operator1'
     *  RelationalOperator: '<S429>/Relational Operator2'
     *  RelationalOperator: '<S430>/Relational Operator1'
     *  RelationalOperator: '<S430>/Relational Operator2'
     *  RelationalOperator: '<S431>/Relational Operator1'
     *  RelationalOperator: '<S431>/Relational Operator2'
     *  RelationalOperator: '<S432>/Relational Operator1'
     *  RelationalOperator: '<S432>/Relational Operator2'
     *  RelationalOperator: '<S433>/Relational Operator1'
     *  RelationalOperator: '<S433>/Relational Operator2'
     *  RelationalOperator: '<S447>/Relational Operator1'
     *  RelationalOperator: '<S447>/Relational Operator2'
     *  RelationalOperator: '<S448>/Relational Operator1'
     *  RelationalOperator: '<S448>/Relational Operator2'
     *  RelationalOperator: '<S449>/Relational Operator1'
     *  RelationalOperator: '<S449>/Relational Operator2'
     *  RelationalOperator: '<S450>/Relational Operator1'
     *  RelationalOperator: '<S450>/Relational Operator2'
     *  RelationalOperator: '<S451>/Relational Operator1'
     *  RelationalOperator: '<S451>/Relational Operator2'
     *  RelationalOperator: '<S452>/Relational Operator1'
     *  RelationalOperator: '<S452>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S432>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S432>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S433>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S433>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S450>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S450>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S451>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S451>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S452>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S452>/Bitwise Operator2'
     */
    VeTPCC_b_EAC_OrPresFlt_Prst = (((rtb_LogicalOperator_h0 &&
        (TPCR_ac_B.TmpSignalConversionAtTmpVM__mj3)) || (VeTPCR_b_SC_WakeUpReq))
        && ((rtb_Switch_e || ((((((((((((uint32)
        TPCR_ac_DW.StatusByte_AC_RefrigTempSnsrCPe) & 1U) != 0U) && ((((uint32)
        TPCR_ac_DW.StatusByte_AC_RefrigTempSnsrCPe) & 64U) == 0U)) &&
        (KeTPCR_b_Enbl_EEXV_LOC_Ref_TmpSnrFlt)) || ((((((uint32)
        TPCR_ac_DW.StatusByte_LostCommACRefrigEx_m) & 1U) != 0U) && ((((uint32)
        TPCR_ac_DW.StatusByte_LostCommACRefrigEx_m) & 64U) == 0U)) &&
        (KeTPCR_b_Enbl_EEXV_LOC_ACRefVlvFlt))) ||
        ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ln) &&
         (KeTPCR_b_Enbl_EEXV_TempElctr_Flts))) ||
        ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_om) &&
         (KeTPCR_b_Enbl_EEXV_PressElctr_Flts))) ||
        ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pg) &&
         (KeTPCR_b_Enbl_EEXV_PressSens_Flts))) ||
        ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_hi) &&
         (KeTPCR_b_Enbl_EEXV_TempSens_Flts))) || (((((rtb_Switch_cw_tmp_0 != 0U)
        && (rtb_Switch_cw_tmp_1 == 0U)) && (KeTPCR_b_Enbl_EEXV_LIN1BusFlt)) ||
        (((rtb_Switch_cw_tmp_6 != 0U) && (rtb_Switch_cw_tmp == 0U)) &&
         (KeTPCR_b_Enbl_EEXV_LIN2BusFlt))) || (((rtb_Switch_cw_tmp_2 != 0U) &&
        (rtb_Switch_cw_tmp_3 == 0U)) && (KeTPCR_b_Enbl_EEXV_LIN3BusFlt))))) ||
            ((((((((((((uint32)TPCR_ac_DW.StatusByte_LostCommACRefrigEx_h) & 1U)
                     != 0U) && ((((uint32)
        TPCR_ac_DW.StatusByte_LostCommACRefrigEx_h) & 64U) == 0U)) &&
                   (KeTPCR_b_Enbl_OEXV_LOC_ACRefVlvFlt)) || ((((((uint32)
        TPCR_ac_DW.StatusByte_AC_RefrigTempSnsr4Ck) & 1U) != 0U) && ((((uint32)
        TPCR_ac_DW.StatusByte_AC_RefrigTempSnsr4Ck) & 64U) == 0U)) &&
        (KeTPCR_b_Enbl_OEXV_LOC_AC_TempSnr4Flt))) || ((((((uint32)
        TPCR_ac_DW.StatusByte_AC_RefrigTempSnsr5Ck) & 1U) != 0U) && ((((uint32)
        TPCR_ac_DW.StatusByte_AC_RefrigTempSnsr5Ck) & 64U) == 0U)) &&
        (KeTPCR_b_Enbl_OEXV_LOC_AC_TempSnr5Flt))) ||
                ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_mo) &&
                 (KeTPCR_b_Enbl_OEXV_PressElect_Flts))) ||
               ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_i3) &&
                (KeTPCR_b_Enbl_OEXV_PressSens_Flts))) ||
              ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_mr) &&
               (KeTPCR_b_Enbl_OEXV_PressDiag_Flts))) || (((((rtb_Switch_cw_tmp_0
        != 0U) && (rtb_Switch_cw_tmp_1 == 0U)) && (KeTPCR_b_Enbl_OEXV_LIN1BusFlt))
        || (((rtb_Switch_cw_tmp_6 != 0U) && (rtb_Switch_cw_tmp == 0U)) &&
            (KeTPCR_b_Enbl_OEXV_LIN2BusFlt))) || (((rtb_Switch_cw_tmp_2 != 0U) &&
        (rtb_Switch_cw_tmp_3 == 0U)) && (KeTPCR_b_Enbl_OEXV_LIN3BusFlt))))));

    /* Logic: '<S341>/Logical2' incorporates:
     *  SignalConversion generated from: '<S341>/VariantSource'
     */
#if Rte_SysCon_Variant_TPCR_27

    /* VariantMerge generated from: '<S341>/VariantSource' */
    rtb_VariantMerge_For_Variant_So = !VeTPCR_b_Rly_EnblCmnd_AD;

#else

    /* VariantMerge generated from: '<S341>/VariantSource' incorporates:
     *  Constant: '<S341>/Constant'
     *  SignalConversion generated from: '<S341>/VariantSource'
     */
    rtb_VariantMerge_For_Variant_So = false;

#endif

    /* End of Logic: '<S341>/Logical2' */

    /* S-Function (sfix_bitop): '<S456>/BitwiseOperator2' incorporates:
     *  Logic: '<S456>/LogicalOperator'
     *  RelationalOperator: '<S456>/RelationalOperator1'
     *  RelationalOperator: '<S456>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S456>/BitwiseOperator1'
     *  SignalConversion generated from: '<S341>/VariantSource1'
     */
#if Rte_SysCon_Variant_TPCR_28

    /* VariantMerge generated from: '<S341>/VariantSource1' incorporates:
     *  Constant: '<S456>/Constant1'
     *  Constant: '<S456>/Constant2'
     *  DataStoreRead: '<S456>/StatusByte_CommBusOff'
     */
    rtb_VariantMerge_For_Variant__i = (((((sint32)
        TPCR_ac_DW.StatusByte_CommBusOff) & 1) > 0) && ((((uint32)
        TPCR_ac_DW.StatusByte_CommBusOff) & 64U) == 0U));

#else

    /* VariantMerge generated from: '<S341>/VariantSource1' incorporates:
     *  Constant: '<S341>/Constant1'
     *  SignalConversion generated from: '<S341>/VariantSource1'
     */
    rtb_VariantMerge_For_Variant__i = false;

#endif

    /* End of S-Function (sfix_bitop): '<S456>/BitwiseOperator2' */

    /* Switch: '<S339>/Switch' incorporates:
     *  Constant: '<S393>/Calib'
     */
    if (KeTPCR_b_CabPrecondAny_Flt_SD)
    {
        /* Switch: '<S339>/Switch' incorporates:
         *  Constant: '<S392>/Calib'
         */
        VeTPCC_b_CabPrecondAny_Flt = KeTPCR_b_CabPrecondAny_Fault;
    }
    else
    {
        /* Switch: '<S339>/Switch' incorporates:
         *  Constant: '<S457>/Constant1'
         *  Constant: '<S457>/Constant2'
         *  Constant: '<S458>/Calib'
         *  DataStoreRead: '<S457>/StatusByte_CommBus_B_Off'
         *  Logic: '<S341>/Logical3'
         *  Logic: '<S341>/Logical5'
         *  Logic: '<S341>/Logical6'
         *  Logic: '<S457>/LogicalOperator'
         *  Logic: '<S68>/Logical3'
         *  RelationalOperator: '<S457>/RelationalOperator1'
         *  RelationalOperator: '<S457>/RelationalOperator2'
         *  S-Function (sfix_bitop): '<S457>/BitwiseOperator1'
         *  S-Function (sfix_bitop): '<S457>/BitwiseOperator2'
         */
        VeTPCC_b_CabPrecondAny_Flt = ((((VeTPCC_b_HtrStsFlty_Prst) ||
            (VeTPCC_b_EAC_OrPresFlt_Prst)) ||
            (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_hb)) ||
            (rtb_VariantMerge_For_Variant_So || (rtb_VariantMerge_For_Variant__i
            && ((((((sint32)TPCR_ac_DW.StatusByte_CommBus_B_Off) & 1) > 0) &&
                 ((((uint32)TPCR_ac_DW.StatusByte_CommBus_B_Off) & 64U) == 0U)) ||
                (KeTPCR_b_Dsbl_RdntePTBusOff_Flt)))));
    }

    /* End of Switch: '<S339>/Switch' */

    /* RelationalOperator: '<S8>/Comparison5' incorporates:
     *  Constant: '<S62>/Constant'
     *  UnitDelay: '<S4>/UnitDelay2'
     */
    rtb_Comparison5 = (((uint32)TPCR_ac_DW.UnitDelay2_DSTATE_n) ==
                       CeTPCR_e_SC_WakeUp);

    /* Outputs for Atomic SubSystem: '<S68>/EdgeRising2' */
    /* Logic: '<S333>/AND' incorporates:
     *  Logic: '<S333>/OR1'
     *  UnitDelay: '<S333>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant_So = ((VeTPCR_b_SC_WakeUpReq) &&
        (!TPCR_ac_DW.UnitDelay_DSTATE_ea3));

    /* Update for UnitDelay: '<S333>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ea3 = VeTPCR_b_SC_WakeUpReq;

    /* End of Outputs for SubSystem: '<S68>/EdgeRising2' */

    /* Outputs for Atomic SubSystem: '<S68>/EdgeRising1' */
    /* Logic: '<S332>/AND' incorporates:
     *  Logic: '<S332>/OR1'
     *  Logic: '<S8>/Logical1'
     *  UnitDelay: '<S332>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant__i = (rtb_LogicalOperator_h0 &&
        (!TPCR_ac_DW.UnitDelay_DSTATE_iz));

    /* Update for UnitDelay: '<S332>/UnitDelay' incorporates:
     *  Logic: '<S8>/Logical1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_iz = rtb_LogicalOperator_h0;

    /* End of Outputs for SubSystem: '<S68>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S68>/EdgeRising3' */
    /* Logic: '<S334>/AND' incorporates:
     *  Logic: '<S334>/OR1'
     *  UnitDelay: '<S334>/UnitDelay'
     */
    rtb_LogicalOperator_bpb = !TPCR_ac_DW.UnitDelay_DSTATE_gm;

    /* Update for UnitDelay: '<S334>/UnitDelay' incorporates:
     *  Constant: '<S68>/TRUEConstant'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_gm = true;

    /* End of Outputs for SubSystem: '<S68>/EdgeRising3' */

    /* Outputs for Atomic SubSystem: '<S68>/TimerRetriggerResetEnabled1' */
    /* Switch: '<S342>/Switch1' incorporates:
     *  Logic: '<S68>/Logical12'
     *  Logic: '<S68>/Logical17'
     *  Logic: '<S68>/Logical4'
     *  Logic: '<S8>/Logical1'
     *  Switch: '<S342>/Switch2'
     */
    if ((rtb_VariantMerge_For_Variant_So || rtb_VariantMerge_For_Variant__i) ||
            rtb_LogicalOperator_bpb)
    {
        /* Switch: '<S342>/Switch1' incorporates:
         *  Constant: '<S337>/Calib'
         */
        rtb_Switch1_l4 = KeTPCR_t_RS_NotEnbldDbnc;
    }
    else if ((!rtb_LogicalOperator_h0) && rtb_Comparison5)
    {
        /* Switch: '<S342>/Switch2' incorporates:
         *  Constant: '<S336>/Calib'
         *  Constant: '<S342>/ConstantValue4'
         *  MinMax: '<S342>/Maximum'
         *  Sum: '<S342>/Subtraction'
         *  Switch: '<S342>/Switch1'
         *  UnitDelay: '<S342>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_mn -
                               KeTPCR_t_RS_CabPrec_dT, 0.0F);
    }
    else
    {
        /* Switch: '<S342>/Switch1' incorporates:
         *  Switch: '<S342>/Switch2'
         *  UnitDelay: '<S342>/UnitDelay'
         */
        rtb_Switch1_l4 = TPCR_ac_DW.UnitDelay_DSTATE_mn;
    }

    /* End of Switch: '<S342>/Switch1' */

    /* Update for UnitDelay: '<S342>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_mn = rtb_Switch1_l4;

    /* Logic: '<S68>/Logical5' incorporates:
     *  Constant: '<S342>/ConstantValue2'
     *  RelationalOperator: '<S342>/GreaterThan1'
     */
    VeTPCR_b_SCWkUp_NoRSTm = (rtb_Switch1_l4 <= 0.0F);

    /* End of Outputs for SubSystem: '<S68>/TimerRetriggerResetEnabled1' */

    /* Logic: '<S68>/Logical8' incorporates:
     *  Constant: '<S335>/Calib'
     */
    VeTPCR_b_NoRS_SCWkUp = ((VeTPCR_b_SCWkUp_NoRSTm) &&
                            (KeTPCR_b_Enbl_SCWkUp_RSDsbld));

    /* Logic: '<S68>/Logical2' */
    VeTPCR_b_CabPrecFail = ((VeTPCC_b_CabPrecondAny_Flt) ||
                            (VeTPCR_b_NoRS_SCWkUp));

    /* UnitDelay: '<S612>/UnitDelay4' */
    VeTPCR_e_KHCStatus = TPCR_ac_DW.UnitDelay4_DSTATE_j;

    /* End of Outputs for S-Function (fcgen): '<S1>/FcnCallGen' */

    /* S-Function (fcgen): '<S1>/FcnCallGen' incorporates:
     *  SubSystem: '<S1>/TPCO_FUNC'
     */
    /* RelationalOperator: '<S607>/Comparison2' incorporates:
     *  RelationalOperator: '<S519>/Comparison15'
     *  RelationalOperator: '<S519>/Comparison30'
     *  RelationalOperator: '<S522>/Comparison34'
     *  RelationalOperator: '<S608>/Comparison1'
     *  RelationalOperator: '<S610>/Comparison1'
     *  RelationalOperator: '<S611>/Comparison1'
     *  RelationalOperator: '<S612>/Comparison15'
     *  RelationalOperator: '<S612>/Comparison30'
     *  RelationalOperator: '<S612>/Comparison34'
     *  RelationalOperator: '<S612>/Comparison35'
     *  RelationalOperator: '<S612>/Comparison36'
     *  RelationalOperator: '<S612>/Comparison6'
     *  RelationalOperator: '<S614>/Comparison33'
     *  Switch: '<S1877>/Switch'
     *  UnitDelay: '<S612>/UnitDelay4'
     */
    rtb_VariantMerge_For_Variant__1 = VeTPCR_e_KHCStatus;

    /* Logic: '<S607>/Logical5' incorporates:
     *  Constant: '<S623>/Constant'
     *  RelationalOperator: '<S607>/Comparison2'
     *  UnitDelay: '<S612>/UnitDelay4'
     */
    rtb_VariantMerge_For_Variant_So = ((((uint32)VeTPCR_e_KHCStatus) ==
        CeTPCR_e_Active) && (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_md));

    /* Outputs for Atomic SubSystem: '<S607>/EdgeRising11' */
    /* Logic: '<S621>/AND' incorporates:
     *  Logic: '<S621>/OR1'
     *  UnitDelay: '<S621>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant__i = (rtb_VariantMerge_For_Variant_So &&
        (!TPCR_ac_DW.UnitDelay_DSTATE_cw));

    /* Update for UnitDelay: '<S621>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_cw = rtb_VariantMerge_For_Variant_So;

    /* End of Outputs for SubSystem: '<S607>/EdgeRising11' */

    /* Outputs for Atomic SubSystem: '<S607>/TimerRetriggerResetEnabled6' */
    /* Switch: '<S627>/Switch1' incorporates:
     *  Logic: '<S607>/Logical41'
     *  Logic: '<S607>/Logical42'
     */
    if ((!rtb_VariantMerge_For_Variant_So) || rtb_VariantMerge_For_Variant__i)
    {
        /* Switch: '<S627>/Switch1' incorporates:
         *  Constant: '<S607>/ConstantValue'
         *  Constant: '<S625>/Calib'
         *  Sum: '<S607>/Add5'
         */
        rtb_Switch1_l4 = KeTPCR_t_DoorAjarTmr_KHC + 0.1F;
    }
    else
    {
        /* Switch: '<S627>/Switch1' incorporates:
         *  Constant: '<S607>/ConstantValue'
         *  Constant: '<S627>/ConstantValue4'
         *  MinMax: '<S627>/Maximum'
         *  Sum: '<S627>/Subtraction'
         *  Switch: '<S627>/Switch2'
         *  UnitDelay: '<S627>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_mw - 0.1F, 0.0F);
    }

    /* End of Switch: '<S627>/Switch1' */

    /* Update for UnitDelay: '<S627>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_mw = rtb_Switch1_l4;

    /* End of Outputs for SubSystem: '<S607>/TimerRetriggerResetEnabled6' */

    /* Outputs for Atomic SubSystem: '<S607>/EdgeRising1' */
    /* Logic: '<S620>/AND' incorporates:
     *  Logic: '<S620>/OR1'
     *  UnitDelay: '<S620>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant_So = !TPCR_ac_DW.UnitDelay_DSTATE_a1;

    /* Update for UnitDelay: '<S620>/UnitDelay' incorporates:
     *  Constant: '<S607>/TRUEConstant'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_a1 = true;

    /* End of Outputs for SubSystem: '<S607>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S607>/SignalLatchOnWithReset2' */
    /* Outputs for Atomic SubSystem: '<S607>/TimerRetriggerResetEnabled6' */
    /* Logic: '<S626>/OR1' incorporates:
     *  Constant: '<S622>/Constant'
     *  Constant: '<S627>/ConstantValue2'
     *  Logic: '<S607>/Logical4'
     *  Logic: '<S607>/Logical43'
     *  Logic: '<S626>/NOT'
     *  Logic: '<S626>/OR'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S627>/GreaterThan1'
     *  Switch: '<S1760>/Switch'
     *  UnitDelay: '<S626>/UnitDelay'
     */
    VeTPCR_b_DoorAjarEnblLtch_KHC = ((rtb_Switch1_l4 <= 0.0F) ||
        (((!rtb_VariantMerge_For_Variant_So) && (((uint32)
        VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff)) &&
         (TPCR_ac_DW.UnitDelay_DSTATE_ede)));

    /* End of Outputs for SubSystem: '<S607>/TimerRetriggerResetEnabled6' */

    /* Update for UnitDelay: '<S626>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ede = VeTPCR_b_DoorAjarEnblLtch_KHC;

    /* End of Outputs for SubSystem: '<S607>/SignalLatchOnWithReset2' */

    /* RelationalOperator: '<S519>/Comparison13' incorporates:
     *  Constant: '<S560>/Calib'
     */
    rtb_VariantMerge_For_Variant_So = (VeTPCR_P_ThrmlPwrBdgt <=
        KeTPCR_P_LowPwrBdgt_PCC_CabCond);

    /* Outputs for Atomic SubSystem: '<S519>/EdgeRising4' */
    /* Logic: '<S538>/AND' incorporates:
     *  Logic: '<S538>/OR1'
     *  UnitDelay: '<S538>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant__i = (rtb_VariantMerge_For_Variant_So &&
        (!TPCR_ac_DW.UnitDelay_DSTATE_gf));

    /* Update for UnitDelay: '<S538>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_gf = rtb_VariantMerge_For_Variant_So;

    /* End of Outputs for SubSystem: '<S519>/EdgeRising4' */

    /* Outputs for Atomic SubSystem: '<S519>/EdgeRising7' */
    /* Logic: '<S541>/AND' incorporates:
     *  Logic: '<S541>/OR1'
     *  UnitDelay: '<S541>/UnitDelay'
     */
    rtb_LogicalOperator_bpb = ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_en) &&
        (!TPCR_ac_DW.UnitDelay_DSTATE_mv));

    /* Update for UnitDelay: '<S541>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_mv = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_en;

    /* End of Outputs for SubSystem: '<S519>/EdgeRising7' */

    /* Switch: '<S1016>/Switch2' incorporates:
     *  Constant: '<S587>/Constant'
     *  Logic: '<S520>/Logical8'
     *  RelationalOperator: '<S520>/Comparison1'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     */
    rtb_Switch2_nq = ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nw) && (((uint32)
                        VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff));

    /* Switch: '<S593>/Switch1' incorporates:
     *  Constant: '<S596>/Calib'
     */
    if (KeTPCR_b_HotEnbl_KeyChk)
    {
        /* Switch: '<S593>/Switch1' */
        VeTPCR_b_HotEnbl_KeyChk = rtb_Switch2_nq;
    }
    else
    {
        /* Switch: '<S593>/Switch1' */
        VeTPCR_b_HotEnbl_KeyChk = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nw;
    }

    /* End of Switch: '<S593>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S519>/EdgeRising5' */
    /* Logic: '<S539>/AND' incorporates:
     *  Logic: '<S539>/OR1'
     *  UnitDelay: '<S539>/UnitDelay'
     */
    rtb_LogicalOperator1_c = ((VeTPCR_b_HotEnbl_KeyChk) &&
        (!TPCR_ac_DW.UnitDelay_DSTATE_ig));

    /* Update for UnitDelay: '<S539>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ig = VeTPCR_b_HotEnbl_KeyChk;

    /* End of Outputs for SubSystem: '<S519>/EdgeRising5' */

    /* Outputs for Atomic SubSystem: '<S518>/SignalLatchOnWithReset12' */
    /* Logic: '<S532>/OR1' incorporates:
     *  Constant: '<S524>/Constant'
     *  Constant: '<S525>/Constant'
     *  Logic: '<S518>/Logical22'
     *  Logic: '<S532>/NOT'
     *  Logic: '<S532>/OR'
     *  RelationalOperator: '<S518>/Comparison2'
     *  RelationalOperator: '<S518>/Comparison33'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     *  UnitDelay: '<S518>/UnitDelay2'
     *  UnitDelay: '<S532>/UnitDelay'
     */
    rtb_OR1_d5 = (((((uint32)VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff) &&
                   (TPCR_ac_DW.UnitDelay2_DSTATE)) || ((CeSSDR_e_KeyOff ==
                    ((uint32)VeTPCR_e_PMM_PowerMode_AD)) &&
                   (TPCR_ac_DW.UnitDelay_DSTATE_cra)));

    /* Update for UnitDelay: '<S532>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_cra = rtb_OR1_d5;

    /* End of Outputs for SubSystem: '<S518>/SignalLatchOnWithReset12' */

    /* Switch: '<S526>/Switch1' incorporates:
     *  Constant: '<S527>/Calib'
     */
    if (KeTPCR_b_ComfEnbl_KeyChk)
    {
        /* Switch: '<S526>/Switch1' incorporates:
         *  Logic: '<S518>/Logical5'
         */
        VeTPCR_b_ComfortEnable_KeyChk = (rtb_OR1_d5 &&
            (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_hl));
    }
    else
    {
        /* Switch: '<S526>/Switch1' */
        VeTPCR_b_ComfortEnable_KeyChk =
            TPCR_ac_B.TmpSignalConversionAtTmpVM_F_hl;
    }

    /* End of Switch: '<S526>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S519>/EdgeRising6' */
    /* Switch: '<S988>/Switch1' incorporates:
     *  UnitDelay: '<S540>/UnitDelay'
     */
    rtb_Switch1_cs = TPCR_ac_DW.UnitDelay_DSTATE_ju;

    /* Update for UnitDelay: '<S540>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ju = VeTPCR_b_ComfortEnable_KeyChk;

    /* Outputs for Atomic SubSystem: '<S519>/TimerRetriggerResetEnabled' */
    /* Switch: '<S577>/Switch1' incorporates:
     *  Logic: '<S519>/Logical20'
     *  Logic: '<S519>/Logical21'
     *  Logic: '<S540>/AND'
     *  Logic: '<S540>/OR1'
     */
    if (((((!rtb_VariantMerge_For_Variant_So) || rtb_VariantMerge_For_Variant__i)
          || rtb_LogicalOperator_bpb) || rtb_LogicalOperator1_c) ||
            ((VeTPCR_b_ComfortEnable_KeyChk) && (!rtb_Switch1_cs)))
    {
        /* Switch: '<S577>/Switch1' incorporates:
         *  Constant: '<S573>/Calib'
         *  Constant: '<S574>/Calib'
         *  Sum: '<S519>/Add2'
         */
        rtb_Switch1_l4 = KeTPCR_t_PCC_LoPwrBdgtDbnc + KeTPCR_t_PCC_CabPrec_dT;
    }
    else
    {
        /* Switch: '<S577>/Switch1' incorporates:
         *  Constant: '<S573>/Calib'
         *  Constant: '<S577>/ConstantValue4'
         *  MinMax: '<S577>/Maximum'
         *  Sum: '<S577>/Subtraction'
         *  Switch: '<S577>/Switch2'
         *  UnitDelay: '<S577>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_a5 -
                               KeTPCR_t_PCC_CabPrec_dT, 0.0F);
    }

    /* End of Switch: '<S577>/Switch1' */
    /* End of Outputs for SubSystem: '<S519>/EdgeRising6' */

    /* Update for UnitDelay: '<S577>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_a5 = rtb_Switch1_l4;

    /* Logic: '<S519>/Logical25' incorporates:
     *  Constant: '<S577>/ConstantValue2'
     *  RelationalOperator: '<S577>/GreaterThan1'
     */
    VeTPCR_b_PCC_PwrBdgtChk = (rtb_Switch1_l4 <= 0.0F);

    /* End of Outputs for SubSystem: '<S519>/TimerRetriggerResetEnabled' */

    /* Outputs for Atomic SubSystem: '<S519>/Hysteresis_1' */
    /* Switch: '<S556>/Switch1' incorporates:
     *  Constant: '<S565>/Calib'
     *  RelationalOperator: '<S556>/GreaterThan'
     */
    if (VeTPCR_Pct_HVBatSOC >= KeTPCR_Pct_KHC_SOCMax)
    {
        /* Switch: '<S556>/Switch1' incorporates:
         *  Constant: '<S556>/ConstantValue'
         */
        rtb_VariantMerge_For_Variant_So = true;
    }
    else
    {
        /* Switch: '<S556>/Switch1' incorporates:
         *  Constant: '<S566>/Calib'
         *  RelationalOperator: '<S556>/GreaterThan1'
         *  UnitDelay: '<S556>/UnitDelay'
         */
        rtb_VariantMerge_For_Variant_So = ((VeTPCR_Pct_HVBatSOC >
            KeTPCR_Pct_KHC_SOCMin) && (TPCR_ac_DW.UnitDelay_DSTATE_bai));
    }

    /* End of Switch: '<S556>/Switch1' */

    /* Update for UnitDelay: '<S556>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_bai = rtb_VariantMerge_For_Variant_So;

    /* End of Outputs for SubSystem: '<S519>/Hysteresis_1' */

    /* Logic: '<S519>/Logical13' */
    VeTPCR_b_KHC_SOCLimit = !rtb_VariantMerge_For_Variant_So;

    /* Logic: '<S519>/Logical14' incorporates:
     *  Constant: '<S549>/Constant'
     *  Constant: '<S553>/Constant'
     *  Logic: '<S519>/Logical24'
     *  RelationalOperator: '<S519>/Comparison15'
     *  RelationalOperator: '<S519>/Comparison30'
     *  RelationalOperator: '<S607>/Comparison2'
     *  Switch: '<S559>/Switch1'
     *  UnitDelay: '<S612>/UnitDelay4'
     */
    VeTPCR_b_KHC_PwrBdgt_SOC = ((((((uint32)VeTPCR_e_KHCStatus) ==
        CeTPCR_e_TemporaryNotAvailable) || (((uint32)VeTPCR_e_KHCStatus) ==
        CeTPCR_e_Active)) && (VeTPCR_b_PCC_PwrBdgtChk)) ||
        (VeTPCR_b_KHC_SOCLimit));

    /* Outputs for Atomic SubSystem: '<S519>/EdgeRising2' */
    /* Logic: '<S536>/AND' incorporates:
     *  Logic: '<S536>/OR1'
     *  UnitDelay: '<S536>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant_So = !TPCR_ac_DW.UnitDelay_DSTATE_af;

    /* Update for UnitDelay: '<S536>/UnitDelay' incorporates:
     *  Constant: '<S519>/TRUEConstant1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_af = true;

    /* End of Outputs for SubSystem: '<S519>/EdgeRising2' */

    /* Outputs for Atomic SubSystem: '<S519>/SignalLatchOnWithReset1' */
    /* Logic: '<S576>/OR1' incorporates:
     *  Constant: '<S542>/Constant'
     *  Logic: '<S519>/Logical9'
     *  Logic: '<S576>/NOT'
     *  Logic: '<S576>/OR'
     *  RelationalOperator: '<S519>/Comparison7'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     *  UnitDelay: '<S519>/UnitDelay2'
     *  UnitDelay: '<S576>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant_So = ((TPCR_ac_DW.UnitDelay2_DSTATE_l) ||
        (((!rtb_VariantMerge_For_Variant_So) && (((uint32)
        VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff)) &&
         (TPCR_ac_DW.UnitDelay_DSTATE_m2)));

    /* Update for UnitDelay: '<S576>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_m2 = rtb_VariantMerge_For_Variant_So;

    /* End of Outputs for SubSystem: '<S519>/SignalLatchOnWithReset1' */

    /* Logic: '<S519>/Logical40' incorporates:
     *  Constant: '<S550>/Constant'
     *  Constant: '<S568>/Calib'
     *  RelationalOperator: '<S519>/Comparison1'
     *  Switch: '<S1772>/Switch'
     */
    rtb_VariantMerge_For_Variant__i = (((KeTPCR_b_Enbl_CntctrOpen_KeyOffCabCond)
        && (((uint32)VeTPCR_e_BatCntctrStat) == CeHVTR_e_Open)) &&
        rtb_VariantMerge_For_Variant_So);

    /* Outputs for Atomic SubSystem: '<S519>/EdgeRising10' */
    /* Logic: '<S535>/AND' incorporates:
     *  Logic: '<S535>/OR1'
     *  UnitDelay: '<S535>/UnitDelay'
     */
    rtb_LogicalOperator_bpb = (rtb_VariantMerge_For_Variant__i &&
        (!TPCR_ac_DW.UnitDelay_DSTATE_jtj));

    /* Update for UnitDelay: '<S535>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_jtj = rtb_VariantMerge_For_Variant__i;

    /* End of Outputs for SubSystem: '<S519>/EdgeRising10' */

    /* Outputs for Atomic SubSystem: '<S519>/TimerRetriggerResetEnabled6' */
    /* Switch: '<S579>/Switch1' incorporates:
     *  Logic: '<S519>/Logical41'
     *  Logic: '<S519>/Logical42'
     */
    if ((!rtb_VariantMerge_For_Variant__i) || rtb_LogicalOperator_bpb)
    {
        /* Switch: '<S579>/Switch1' incorporates:
         *  Constant: '<S519>/ConstantValue'
         *  Constant: '<S571>/Calib'
         *  Sum: '<S519>/Add5'
         */
        rtb_Switch1_l4 = KeTPCR_t_CntctrOpen_KeyOffCabCond + 0.1F;
    }
    else
    {
        /* Switch: '<S579>/Switch1' incorporates:
         *  Constant: '<S519>/ConstantValue'
         *  Constant: '<S579>/ConstantValue4'
         *  MinMax: '<S579>/Maximum'
         *  Sum: '<S579>/Subtraction'
         *  Switch: '<S579>/Switch2'
         *  UnitDelay: '<S579>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_ij - 0.1F, 0.0F);
    }

    /* End of Switch: '<S579>/Switch1' */

    /* Update for UnitDelay: '<S579>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ij = rtb_Switch1_l4;

    /* End of Outputs for SubSystem: '<S519>/TimerRetriggerResetEnabled6' */

    /* Logic: '<S519>/Logical3' incorporates:
     *  Constant: '<S569>/Calib'
     */
    rtb_VariantMerge_For_Variant__i = (((KeTPCR_b_Enbl_LoadShed_KeyOffCabCond) &&
        (VeTPCR_b_ThrmLoad_Shed)) && rtb_VariantMerge_For_Variant_So);

    /* Outputs for Atomic SubSystem: '<S519>/EdgeRising1' */
    /* Logic: '<S534>/AND' incorporates:
     *  Logic: '<S534>/OR1'
     *  UnitDelay: '<S534>/UnitDelay'
     */
    rtb_LogicalOperator_bpb = (rtb_VariantMerge_For_Variant__i &&
        (!TPCR_ac_DW.UnitDelay_DSTATE_j0));

    /* Update for UnitDelay: '<S534>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_j0 = rtb_VariantMerge_For_Variant__i;

    /* End of Outputs for SubSystem: '<S519>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S519>/TimerRetriggerResetEnabled1' */
    /* Switch: '<S578>/Switch1' incorporates:
     *  Logic: '<S519>/Logical4'
     *  Logic: '<S519>/Logical5'
     */
    if ((!rtb_VariantMerge_For_Variant__i) || rtb_LogicalOperator_bpb)
    {
        /* Switch: '<S578>/Switch1' incorporates:
         *  Constant: '<S519>/ConstantValue1'
         *  Constant: '<S572>/Calib'
         *  Sum: '<S519>/Add1'
         */
        rtb_Switch1_ml1 = KeTPCR_t_LoadShed_KeyOffCabCond + 0.1F;
    }
    else
    {
        /* Switch: '<S578>/Switch1' incorporates:
         *  Constant: '<S519>/ConstantValue1'
         *  Constant: '<S578>/ConstantValue4'
         *  MinMax: '<S578>/Maximum'
         *  Sum: '<S578>/Subtraction'
         *  Switch: '<S578>/Switch2'
         *  UnitDelay: '<S578>/UnitDelay'
         */
        rtb_Switch1_ml1 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_iw - 0.1F, 0.0F);
    }

    /* End of Switch: '<S578>/Switch1' */

    /* Update for UnitDelay: '<S578>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_iw = rtb_Switch1_ml1;

    /* Outputs for Atomic SubSystem: '<S519>/TimerRetriggerResetEnabled6' */
    /* Logic: '<S519>/Logical1' incorporates:
     *  Constant: '<S551>/Constant'
     *  Constant: '<S552>/Constant'
     *  Constant: '<S554>/Constant'
     *  Constant: '<S555>/Constant'
     *  Constant: '<S570>/Calib'
     *  Constant: '<S578>/ConstantValue2'
     *  Constant: '<S579>/ConstantValue2'
     *  Logic: '<S519>/Logical12'
     *  Logic: '<S519>/Logical39'
     *  Logic: '<S519>/Logical6'
     *  Logic: '<S519>/Logical7'
     *  Logic: '<S519>/Logical8'
     *  RelationalOperator: '<S519>/Comparison11'
     *  RelationalOperator: '<S519>/Comparison12'
     *  RelationalOperator: '<S519>/Comparison2'
     *  RelationalOperator: '<S519>/Comparison5'
     *  RelationalOperator: '<S578>/GreaterThan1'
     *  RelationalOperator: '<S579>/GreaterThan1'
     *  Switch: '<S1763>/Switch1'
     *  Switch: '<S1774>/Switch'
     */
    VeTPCR_b_KeyOffCabCondThrmlFlts = (((((rtb_Switch_e || rtb_Switch_a5) ||
        (rtb_Switch1_l4 <= 0.0F)) || (rtb_Switch1_ml1 <= 0.0F)) ||
        ((rtb_VariantMerge_For_Variant_So && ((((uint32)VeTPCR_e_TurtleMd) ==
        CeDMDR_e_Turtle_Mode3) || (((uint32)VeTPCR_e_TurtleMd) ==
        CeDMDR_e_Turtle_Mode4))) && (KeTPCR_b_Enbl_TurtleMd_KeyOffCabCond))) ||
        ((((uint32)VeTPCR_e_FOTAInstallType) == CeCITR_e_FOTANow) || (((uint32)
        VeTPCR_e_FOTAInstallType) == CeCITR_e_FOTASchedule)));

    /* End of Outputs for SubSystem: '<S519>/TimerRetriggerResetEnabled6' */
    /* End of Outputs for SubSystem: '<S519>/TimerRetriggerResetEnabled1' */

    /* Switch: '<S519>/Switch1' incorporates:
     *  Constant: '<S567>/Calib'
     */
    if (KeTPCR_b_Enbl_BattTmpCrit_Chk)
    {
        /* RelationalOperator: '<S519>/Comparison4' incorporates:
         *  RelationalOperator: '<S519>/Comparison3'
         *  RelationalOperator: '<S519>/Comparison6'
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        rtb_Switch3_dh_tmp = TPCR_ac_B.TmpSignalConversionAtTmpVM__gr1;

        /* Switch: '<S1016>/Switch3' incorporates:
         *  Constant: '<S546>/Constant'
         *  Constant: '<S547>/Constant'
         *  Constant: '<S548>/Constant'
         *  Logic: '<S519>/Logical2'
         *  RelationalOperator: '<S519>/Comparison3'
         *  RelationalOperator: '<S519>/Comparison4'
         *  RelationalOperator: '<S519>/Comparison6'
         */
        rtb_Switch3_c2 = (((((uint32)rtb_Switch3_dh_tmp) != CeBTRR_e_BatOutOfRng)
                           && (((uint32)rtb_Switch3_dh_tmp) != CeBTRR_e_BatCrit))
                          && (((uint32)rtb_Switch3_dh_tmp) !=
                              CeBTRR_e_BatCritErrSt));
    }
    else
    {
        /* Switch: '<S1016>/Switch3' incorporates:
         *  Constant: '<S519>/TRUEConstant'
         */
        rtb_Switch3_c2 = true;
    }

    /* End of Switch: '<S519>/Switch1' */

    /* Logic: '<S607>/Logical1' incorporates:
     *  Logic: '<S608>/Logical4'
     *  Logic: '<S610>/Logical4'
     */
    rtb_VariantMerge_For_Variant__2 = !VeTPCR_b_KHC_PwrBdgt_SOC;

    /* Logic: '<S607>/Logical2' incorporates:
     *  Logic: '<S518>/Logical3'
     *  Logic: '<S520>/Logical3'
     *  Logic: '<S608>/Logical5'
     *  Logic: '<S610>/Logical5'
     */
    rtb_VariantMerge_For_Variant__3 = !VeTPCR_b_KeyOffCabCondThrmlFlts;

    /* Logic: '<S607>/Logical3' incorporates:
     *  DataStoreRead: '<S521>/DataStoreRead'
     *  Logic: '<S518>/LogicalOperator'
     *  Logic: '<S608>/Logical6'
     *  Logic: '<S610>/Logical6'
     */
    rtb_VariantMerge_For_Variant__4 = !TPCR_ac_DW.NeTPCR_b_12VloadShed;

    /* Logic: '<S607>/Logical39' incorporates:
     *  Constant: '<S624>/Calib'
     *  Logic: '<S607>/Logical1'
     *  Logic: '<S607>/Logical2'
     *  Logic: '<S607>/Logical3'
     *  Logic: '<S607>/Logical6'
     *  Logic: '<S607>/Logical7'
     *  UnitDelay: '<S607>/UnitDelay1'
     *  UnitDelay: '<S607>/UnitDelay3'
     */
    rtb_VariantMerge_For_Variant_So = ((((((((VeTPCR_b_DoorAjarEnblLtch_KHC) &&
        rtb_VariantMerge_For_Variant__2) && rtb_VariantMerge_For_Variant__3) &&
        rtb_Switch3_c2) && rtb_VariantMerge_For_Variant__4) &&
        (!TPCR_ac_DW.UnitDelay3_DSTATE)) && (!TPCR_ac_DW.UnitDelay1_DSTATE_p)) &&
        (KeTPCR_b_EnblDoorAjar_KHC));

    /* Logic: '<S608>/Logical8' incorporates:
     *  Constant: '<S631>/Constant'
     *  RelationalOperator: '<S607>/Comparison2'
     *  RelationalOperator: '<S608>/Comparison1'
     *  UnitDelay: '<S612>/UnitDelay4'
     */
    rtb_VariantMerge_For_Variant__i = ((((uint32)VeTPCR_e_KHCStatus) ==
        CeTPCR_e_Active) && (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gr));

    /* Outputs for Atomic SubSystem: '<S608>/EdgeRising3' */
    /* Logic: '<S629>/AND' incorporates:
     *  Logic: '<S629>/OR1'
     *  UnitDelay: '<S629>/UnitDelay'
     */
    rtb_LogicalOperator_bpb = (rtb_VariantMerge_For_Variant__i &&
        (!TPCR_ac_DW.UnitDelay_DSTATE_ft));

    /* Update for UnitDelay: '<S629>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ft = rtb_VariantMerge_For_Variant__i;

    /* End of Outputs for SubSystem: '<S608>/EdgeRising3' */

    /* Outputs for Atomic SubSystem: '<S608>/TimerRetriggerResetEnabled1' */
    /* Switch: '<S635>/Switch1' incorporates:
     *  Logic: '<S608>/Logical10'
     *  Logic: '<S608>/Logical9'
     */
    if ((!rtb_VariantMerge_For_Variant__i) || rtb_LogicalOperator_bpb)
    {
        /* Switch: '<S635>/Switch1' incorporates:
         *  Constant: '<S608>/ConstantValue1'
         *  Constant: '<S633>/Calib'
         *  Sum: '<S608>/Add1'
         */
        rtb_Switch1_l4 = KeTPCR_t_HoodAjarTmr_KHC + 0.1F;
    }
    else
    {
        /* Switch: '<S635>/Switch1' incorporates:
         *  Constant: '<S608>/ConstantValue1'
         *  Constant: '<S635>/ConstantValue4'
         *  MinMax: '<S635>/Maximum'
         *  Sum: '<S635>/Subtraction'
         *  Switch: '<S635>/Switch2'
         *  UnitDelay: '<S635>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_oz - 0.1F, 0.0F);
    }

    /* End of Switch: '<S635>/Switch1' */

    /* Update for UnitDelay: '<S635>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_oz = rtb_Switch1_l4;

    /* End of Outputs for SubSystem: '<S608>/TimerRetriggerResetEnabled1' */

    /* Outputs for Atomic SubSystem: '<S608>/EdgeRising2' */
    /* Logic: '<S628>/AND' incorporates:
     *  Logic: '<S628>/OR1'
     *  UnitDelay: '<S628>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant__i = !TPCR_ac_DW.UnitDelay_DSTATE_k2;

    /* Update for UnitDelay: '<S628>/UnitDelay' incorporates:
     *  Constant: '<S608>/TRUEConstant1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_k2 = true;

    /* End of Outputs for SubSystem: '<S608>/EdgeRising2' */

    /* Outputs for Atomic SubSystem: '<S608>/SignalLatchOnWithReset1' */
    /* Outputs for Atomic SubSystem: '<S608>/TimerRetriggerResetEnabled1' */
    /* Logic: '<S634>/OR1' incorporates:
     *  Constant: '<S630>/Constant'
     *  Constant: '<S635>/ConstantValue2'
     *  Logic: '<S608>/Logical1'
     *  Logic: '<S608>/Logical11'
     *  Logic: '<S634>/NOT'
     *  Logic: '<S634>/OR'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S608>/Comparison3'
     *  RelationalOperator: '<S635>/GreaterThan1'
     *  Switch: '<S1760>/Switch'
     *  UnitDelay: '<S634>/UnitDelay'
     */
    VeTPCR_b_HoodAjarEnblLtch_KHC = ((rtb_Switch1_l4 <= 0.0F) ||
        (((!rtb_VariantMerge_For_Variant__i) && (((uint32)
        VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff)) &&
         (TPCR_ac_DW.UnitDelay_DSTATE_gif)));

    /* End of Outputs for SubSystem: '<S608>/TimerRetriggerResetEnabled1' */

    /* Update for UnitDelay: '<S634>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_gif = VeTPCR_b_HoodAjarEnblLtch_KHC;

    /* End of Outputs for SubSystem: '<S608>/SignalLatchOnWithReset1' */

    /* Logic: '<S608>/Logical7' incorporates:
     *  Constant: '<S632>/Calib'
     *  Logic: '<S608>/Logical2'
     *  Logic: '<S608>/Logical3'
     *  UnitDelay: '<S608>/UnitDelay1'
     *  UnitDelay: '<S608>/UnitDelay2'
     */
    rtb_VariantMerge_For_Variant__i = ((((((((VeTPCR_b_HoodAjarEnblLtch_KHC) &&
        rtb_VariantMerge_For_Variant__2) && rtb_VariantMerge_For_Variant__3) &&
        rtb_Switch3_c2) && rtb_VariantMerge_For_Variant__4) &&
        (!TPCR_ac_DW.UnitDelay2_DSTATE_o)) && (!TPCR_ac_DW.UnitDelay1_DSTATE_c))
        && (KeTPCR_b_EnblHoodAjar_KHC));

    /* Logic: '<S610>/Logical8' incorporates:
     *  Constant: '<S640>/Constant'
     *  RelationalOperator: '<S607>/Comparison2'
     *  RelationalOperator: '<S610>/Comparison1'
     *  UnitDelay: '<S612>/UnitDelay4'
     */
    rtb_LogicalOperator_bpb = ((((uint32)VeTPCR_e_KHCStatus) == CeTPCR_e_Active)
        && (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_fa));

    /* Outputs for Atomic SubSystem: '<S610>/EdgeRising3' */
    /* Logic: '<S638>/AND' incorporates:
     *  Logic: '<S638>/OR1'
     *  UnitDelay: '<S638>/UnitDelay'
     */
    rtb_LogicalOperator1_c = (rtb_LogicalOperator_bpb &&
        (!TPCR_ac_DW.UnitDelay_DSTATE_aks));

    /* Update for UnitDelay: '<S638>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_aks = rtb_LogicalOperator_bpb;

    /* End of Outputs for SubSystem: '<S610>/EdgeRising3' */

    /* Outputs for Atomic SubSystem: '<S610>/TimerRetriggerResetEnabled1' */
    /* Switch: '<S644>/Switch1' incorporates:
     *  Logic: '<S610>/Logical10'
     *  Logic: '<S610>/Logical9'
     */
    if ((!rtb_LogicalOperator_bpb) || rtb_LogicalOperator1_c)
    {
        /* Switch: '<S644>/Switch1' incorporates:
         *  Constant: '<S610>/ConstantValue1'
         *  Constant: '<S642>/Calib'
         *  Sum: '<S610>/Add1'
         */
        rtb_Switch1_l4 = KeTPCR_t_TrunkAjarTmr_KHC + 0.1F;
    }
    else
    {
        /* Switch: '<S644>/Switch1' incorporates:
         *  Constant: '<S610>/ConstantValue1'
         *  Constant: '<S644>/ConstantValue4'
         *  MinMax: '<S644>/Maximum'
         *  Sum: '<S644>/Subtraction'
         *  Switch: '<S644>/Switch2'
         *  UnitDelay: '<S644>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_gp - 0.1F, 0.0F);
    }

    /* End of Switch: '<S644>/Switch1' */

    /* Update for UnitDelay: '<S644>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_gp = rtb_Switch1_l4;

    /* End of Outputs for SubSystem: '<S610>/TimerRetriggerResetEnabled1' */

    /* Outputs for Atomic SubSystem: '<S610>/EdgeRising2' */
    /* Logic: '<S637>/AND' incorporates:
     *  Logic: '<S637>/OR1'
     *  UnitDelay: '<S637>/UnitDelay'
     */
    rtb_LogicalOperator_bpb = !TPCR_ac_DW.UnitDelay_DSTATE_fc;

    /* Update for UnitDelay: '<S637>/UnitDelay' incorporates:
     *  Constant: '<S610>/TRUEConstant1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_fc = true;

    /* End of Outputs for SubSystem: '<S610>/EdgeRising2' */

    /* Outputs for Atomic SubSystem: '<S610>/SignalLatchOnWithReset1' */
    /* Outputs for Atomic SubSystem: '<S610>/TimerRetriggerResetEnabled1' */
    /* Logic: '<S643>/OR1' incorporates:
     *  Constant: '<S639>/Constant'
     *  Constant: '<S644>/ConstantValue2'
     *  Logic: '<S610>/Logical1'
     *  Logic: '<S610>/Logical11'
     *  Logic: '<S643>/NOT'
     *  Logic: '<S643>/OR'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S610>/Comparison3'
     *  RelationalOperator: '<S644>/GreaterThan1'
     *  Switch: '<S1760>/Switch'
     *  UnitDelay: '<S643>/UnitDelay'
     */
    VeTPCR_b_TrunkAjarEnblLtch_KHC = ((rtb_Switch1_l4 <= 0.0F) ||
        (((!rtb_LogicalOperator_bpb) && (((uint32)VeTPCR_e_PMM_PowerMode_AD) ==
        CeSSDR_e_KeyOff)) && (TPCR_ac_DW.UnitDelay_DSTATE_op0)));

    /* End of Outputs for SubSystem: '<S610>/TimerRetriggerResetEnabled1' */

    /* Update for UnitDelay: '<S643>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_op0 = VeTPCR_b_TrunkAjarEnblLtch_KHC;

    /* End of Outputs for SubSystem: '<S610>/SignalLatchOnWithReset1' */

    /* Logic: '<S610>/Logical7' incorporates:
     *  Constant: '<S641>/Calib'
     *  Logic: '<S610>/Logical2'
     *  Logic: '<S610>/Logical3'
     *  UnitDelay: '<S610>/UnitDelay1'
     *  UnitDelay: '<S610>/UnitDelay2'
     */
    rtb_LogicalOperator_bpb = ((((((((VeTPCR_b_TrunkAjarEnblLtch_KHC) &&
        rtb_VariantMerge_For_Variant__2) && rtb_VariantMerge_For_Variant__3) &&
        rtb_Switch3_c2) && rtb_VariantMerge_For_Variant__4) &&
        (!TPCR_ac_DW.UnitDelay2_DSTATE_g)) && (!TPCR_ac_DW.UnitDelay1_DSTATE_e))
        && (KeTPCR_b_EnblTrunkAjar_KHC));

    /* Switch: '<S1016>/Switch1' incorporates:
     *  Constant: '<S696>/Calib'
     *  DataStoreRead: '<S521>/DataStoreRead'
     *  Logic: '<S613>/Logical1'
     *  Logic: '<S613>/Logical2'
     */
    rtb_Switch1_eo = (((VeTPCR_b_KeyOffCabCondThrmlFlts) ||
                       (TPCR_ac_DW.NeTPCR_b_12VloadShed)) &&
                      (KeTPCR_b_EnblOnUnavailable_KHC));

    /* Gain: '<S1042>/Gain' incorporates:
     *  Constant: '<S636>/Calib'
     *  Logic: '<S609>/Logical3'
     */
    rtb_Gain_g = ((VeTPCR_b_KHC_PwrBdgt_SOC) && (KeTPCR_b_EnblLowBattery_KHC));

    /* Switch: '<S606>/Switch1' incorporates:
     *  Constant: '<S606>/TRUEConstant'
     *  Constant: '<S615>/Constant'
     *  Constant: '<S616>/Constant'
     *  Constant: '<S617>/Constant'
     *  Constant: '<S619>/Calib'
     *  Logic: '<S606>/Logical2'
     *  RelationalOperator: '<S606>/Comparison3'
     *  RelationalOperator: '<S606>/Comparison4'
     *  RelationalOperator: '<S606>/Comparison6'
     */
    if (KeTPCR_b_Enbl_BattTmpCrit_Chk)
    {
        /* RelationalOperator: '<S606>/Comparison4' incorporates:
         *  RelationalOperator: '<S606>/Comparison3'
         *  RelationalOperator: '<S606>/Comparison6'
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        rtb_Switch3_dh_tmp = TPCR_ac_B.TmpSignalConversionAtTmpVM__gr1;
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = (((((uint32)rtb_Switch3_dh_tmp) ==
            CeBTRR_e_BatOutOfRng) || (((uint32)rtb_Switch3_dh_tmp) ==
            CeBTRR_e_BatCrit)) || (((uint32)rtb_Switch3_dh_tmp) ==
            CeBTRR_e_BatCritErrSt));
    }
    else
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = true;
    }

    /* End of Switch: '<S606>/Switch1' */

    /* RelationalOperator: '<S1346>/Relational Operator1' incorporates:
     *  Constant: '<S618>/Calib'
     *  Logic: '<S606>/Logical3'
     */
    rtb_RelationalOperator1_dfl = (VeTPCR_b_DoorAjarEnblLtch_Rst_t &&
        (KeTPCR_b_EnblBattCrit_KHC));

    /* Outputs for Atomic SubSystem: '<S194>/EdgeFalling1' */
    /* Logic: '<S612>/Logical4' incorporates:
     *  Logic: '<S1114>/Logical8'
     *  Logic: '<S1115>/Logical8'
     *  Logic: '<S1116>/Logical8'
     *  Logic: '<S1117>/Logical8'
     *  Logic: '<S18>/Logical8'
     *  Logic: '<S194>/Logical7'
     *  Logic: '<S197>/OR1'
     *  Logic: '<S66>/Logical2'
     */
    rtb_VariantMerge_For_Variant__2 = !VeTPCR_b_SC_WakeUpReq;

    /* End of Outputs for SubSystem: '<S194>/EdgeFalling1' */

    /* Logic: '<S612>/Logical3' incorporates:
     *  Logic: '<S612>/Logical4'
     *  Logic: '<S9>/Logical21'
     */
    rtb_UnitDelay_gcx_tmp = ((VeTPCR_b_RmtVehStartReq) &&
        rtb_VariantMerge_For_Variant__2);

    /* UnitDelay: '<S26>/UnitDelay' incorporates:
     *  Constant: '<S678>/Constant'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S612>/Comparison4'
     *  Switch: '<S1760>/Switch'
     */
    rtb_UnitDelay_l3 = (((uint32)VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff);

    /* Outputs for Atomic SubSystem: '<S612>/EdgeRising12' */
    /* Logic: '<S672>/AND' incorporates:
     *  Logic: '<S672>/OR1'
     *  UnitDelay: '<S672>/UnitDelay'
     */
    rtb_AND_gq3 = !TPCR_ac_DW.UnitDelay_DSTATE_muw;

    /* Update for UnitDelay: '<S672>/UnitDelay' incorporates:
     *  Constant: '<S612>/TRUEConstant17'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_muw = true;

    /* End of Outputs for SubSystem: '<S612>/EdgeRising12' */

    /* RelationalOperator: '<S612>/Comparison1' incorporates:
     *  Constant: '<S676>/Constant'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     */
    rtb_Comparison1_pa = (((uint32)VeTPCR_e_PMM_PowerMode_AD) != CeSSDR_e_KeyOff);

    /* Outputs for Atomic SubSystem: '<S612>/EdgeBi' */
    /* RelationalOperator: '<S670>/NotEqual' incorporates:
     *  UnitDelay: '<S670>/UnitDelay'
     */
    rtb_NotEqual_p = (rtb_Comparison1_pa != TPCR_ac_DW.UnitDelay_DSTATE_l5j);

    /* Update for UnitDelay: '<S670>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_l5j = rtb_Comparison1_pa;

    /* End of Outputs for SubSystem: '<S612>/EdgeBi' */

    /* Outputs for Atomic SubSystem: '<S612>/SignalLatchOnWithReset12' */
    /* Logic: '<S693>/OR1' incorporates:
     *  Constant: '<S679>/Constant'
     *  Constant: '<S685>/Constant'
     *  Constant: '<S687>/Constant'
     *  Logic: '<S612>/Logical2'
     *  Logic: '<S612>/Logical22'
     *  Logic: '<S612>/Logical23'
     *  Logic: '<S612>/Logical24'
     *  Logic: '<S612>/Logical25'
     *  Logic: '<S612>/Logical26'
     *  Logic: '<S612>/Logical3'
     *  Logic: '<S693>/NOT'
     *  Logic: '<S693>/OR'
     *  RelationalOperator: '<S607>/Comparison2'
     *  RelationalOperator: '<S612>/Comparison34'
     *  RelationalOperator: '<S612>/Comparison35'
     *  RelationalOperator: '<S612>/Comparison5'
     *  Switch: '<S1775>/Switch'
     *  UnitDelay: '<S612>/UnitDelay4'
     *  UnitDelay: '<S693>/UnitDelay'
     */
    rtb_LogicalOperator1_c = (((((((((rtb_VariantMerge_For_Variant_So ||
        rtb_VariantMerge_For_Variant__i) || rtb_LogicalOperator_bpb) ||
        rtb_Switch1_eo) || rtb_Gain_g) || rtb_RelationalOperator1_dfl) ||
        rtb_UnitDelay_gcx_tmp) && (((uint32)VeTPCR_e_KHCStatus) ==
        CeTPCR_e_Active)) || ((((((rtb_Switch1_eo || rtb_Gain_g) ||
        rtb_RelationalOperator1_dfl) || rtb_UnitDelay_gcx_tmp) ||
        (CePLTR_e_ShipingMode_SHIP_MD == ((uint32)VeTPCR_e_ShippingMode_AD))) &&
        (((uint32)VeTPCR_e_KHCStatus) == CeTPCR_e_NotActive)) &&
        rtb_UnitDelay_l3)) || (((!rtb_AND_gq3) && (!rtb_NotEqual_p)) &&
        (TPCR_ac_DW.UnitDelay_DSTATE_ccs)));

    /* Update for UnitDelay: '<S693>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ccs = rtb_LogicalOperator1_c;

    /* End of Outputs for SubSystem: '<S612>/SignalLatchOnWithReset12' */

    /* Outputs for Atomic SubSystem: '<S612>/EdgeRising13' */
    /* Logic: '<S673>/AND' incorporates:
     *  Logic: '<S673>/OR1'
     *  UnitDelay: '<S673>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant__n =
        ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_en) &&
         (!TPCR_ac_DW.UnitDelay_DSTATE_nj));

    /* Update for UnitDelay: '<S673>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_nj = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_en;

    /* End of Outputs for SubSystem: '<S612>/EdgeRising13' */

    /* Logic: '<S612>/Logical27' incorporates:
     *  Constant: '<S689>/Constant'
     *  RelationalOperator: '<S607>/Comparison2'
     *  RelationalOperator: '<S612>/Comparison36'
     *  UnitDelay: '<S612>/UnitDelay4'
     */
    rtb_AND_gq3 = ((rtb_VariantMerge_For_Variant__n && (((uint32)
                      VeTPCR_e_KHCStatus) == CeTPCR_e_NotActive)) &&
                   rtb_UnitDelay_l3);

    /* RelationalOperator: '<S614>/Comparison33' incorporates:
     *  Constant: '<S698>/Constant'
     *  RelationalOperator: '<S607>/Comparison2'
     *  UnitDelay: '<S612>/UnitDelay4'
     */
    rtb_Comparison1_pa = (((uint32)VeTPCR_e_KHCStatus) == CeTPCR_e_Active);

    /* Outputs for Atomic SubSystem: '<S614>/EdgeRising12' */
    /* Logic: '<S697>/AND' incorporates:
     *  Logic: '<S697>/OR1'
     *  UnitDelay: '<S697>/UnitDelay'
     */
    rtb_NotEqual_p = (rtb_Comparison1_pa && (!TPCR_ac_DW.UnitDelay_DSTATE_l5));

    /* Update for UnitDelay: '<S697>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_l5 = rtb_Comparison1_pa;

    /* End of Outputs for SubSystem: '<S614>/EdgeRising12' */

    /* Outputs for Atomic SubSystem: '<S614>/TimerRetriggerResetEnabled1' */
    /* Switch: '<S700>/Switch1' incorporates:
     *  Logic: '<S614>/Logical23'
     *  Logic: '<S614>/Logical24'
     */
    if ((!rtb_Comparison1_pa) || rtb_NotEqual_p)
    {
        /* Switch: '<S700>/Switch1' incorporates:
         *  Constant: '<S614>/ConstantValue3'
         *  Constant: '<S699>/Calib'
         *  Sum: '<S614>/Add2'
         */
        rtb_Switch1_l4 = KeTPCR_t_KHCActiveTmr + 0.1F;
    }
    else
    {
        /* Switch: '<S700>/Switch1' incorporates:
         *  Constant: '<S614>/ConstantValue3'
         *  Constant: '<S700>/ConstantValue4'
         *  MinMax: '<S700>/Maximum'
         *  Sum: '<S700>/Subtraction'
         *  Switch: '<S700>/Switch2'
         *  UnitDelay: '<S700>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_mh - 0.1F, 0.0F);
    }

    /* End of Switch: '<S700>/Switch1' */

    /* Update for UnitDelay: '<S700>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_mh = rtb_Switch1_l4;

    /* UnitDelay: '<S26>/UnitDelay' incorporates:
     *  Constant: '<S700>/ConstantValue2'
     *  Logic: '<S614>/Logical22'
     *  RelationalOperator: '<S700>/GreaterThan1'
     */
    rtb_UnitDelay_l3 = (rtb_Switch1_l4 <= 0.0F);

    /* End of Outputs for SubSystem: '<S614>/TimerRetriggerResetEnabled1' */

    /* RelationalOperator: '<S612>/Comparison2' incorporates:
     *  Constant: '<S677>/Constant'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     */
    rtb_Comparison1_pa = (((uint32)VeTPCR_e_PMM_PowerMode_AD) != CeSSDR_e_KeyOff);

    /* Outputs for Atomic SubSystem: '<S612>/EdgeRising2' */
    /* Logic: '<S674>/AND' incorporates:
     *  Logic: '<S674>/OR1'
     *  UnitDelay: '<S674>/UnitDelay'
     */
    rtb_NotEqual_p = (rtb_Comparison1_pa && (!TPCR_ac_DW.UnitDelay_DSTATE_jt2));

    /* Update for UnitDelay: '<S674>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_jt2 = rtb_Comparison1_pa;

    /* End of Outputs for SubSystem: '<S612>/EdgeRising2' */

    /* Outputs for Atomic SubSystem: '<S612>/SignalLatchOnWithReset13' */
    /* Logic: '<S694>/OR1' incorporates:
     *  Constant: '<S680>/Constant'
     *  Logic: '<S612>/Logical28'
     *  Logic: '<S612>/Logical5'
     *  Logic: '<S694>/NOT'
     *  Logic: '<S694>/OR'
     *  RelationalOperator: '<S607>/Comparison2'
     *  RelationalOperator: '<S612>/Comparison6'
     *  UnitDelay: '<S612>/UnitDelay4'
     *  UnitDelay: '<S694>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant__n = (rtb_AND_gq3 ||
        (((((!rtb_LogicalOperator1_c) && (!rtb_UnitDelay_l3)) &&
           ((!rtb_VariantMerge_For_Variant__n) || (((uint32)VeTPCR_e_KHCStatus)
        != CeTPCR_e_Active))) && (!rtb_NotEqual_p)) &&
         (TPCR_ac_DW.UnitDelay_DSTATE_c3)));

    /* Update for UnitDelay: '<S694>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_c3 = rtb_VariantMerge_For_Variant__n;

    /* End of Outputs for SubSystem: '<S612>/SignalLatchOnWithReset13' */

    /* Switch: '<S692>/Switch1' incorporates:
     *  Switch: '<S691>/Switch1'
     */
    if (rtb_LogicalOperator1_c)
    {
        /* Switch: '<S692>/Switch1' incorporates:
         *  Constant: '<S686>/Constant'
         */
        rtb_Switch1_dk = CeTPCR_e_TemporaryNotAvailable;
    }
    else if (rtb_VariantMerge_For_Variant__n)
    {
        /* Switch: '<S691>/Switch1' incorporates:
         *  Constant: '<S688>/Constant'
         *  Switch: '<S692>/Switch1'
         */
        rtb_Switch1_dk = CeTPCR_e_Active;
    }
    else
    {
        /* Switch: '<S692>/Switch1' incorporates:
         *  Constant: '<S684>/Constant'
         *  Switch: '<S691>/Switch1'
         */
        rtb_Switch1_dk = CeTPCR_e_NotActive;
    }

    /* End of Switch: '<S692>/Switch1' */

    /* Logic: '<S1349>/Logical Operator' incorporates:
     *  Constant: '<S109>/Constant'
     *  Logic: '<S94>/Logical1'
     *  RelationalOperator: '<S94>/Comparison1'
     */
    rtb_LogicalOperator_gy = ((VeTPCR_b_CabPrecFail) || (((uint32)rtb_Switch1_dk)
        == CeTPCR_e_Active));

    /* RelationalOperator: '<S60>/Comparison1' incorporates:
     *  RelationalOperator: '<S60>/Comparison2'
     *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
     */
    VeTPCR_b_BattThrmlSt_Cond_tmp = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ih;

    /* Logic: '<S60>/Logical6' incorporates:
     *  Constant: '<S74>/Constant'
     *  Constant: '<S75>/Constant'
     *  RelationalOperator: '<S60>/Comparison1'
     *  RelationalOperator: '<S60>/Comparison2'
     */
    VeTPCR_b_BattThrmlSt_Cond = ((((uint32)VeTPCR_b_BattThrmlSt_Cond_tmp) ==
        CeTHMR_e_ActiveCooling) || (((uint32)VeTPCR_b_BattThrmlSt_Cond_tmp) ==
        CeTHMR_e_Heating));

    /* Switch: '<S60>/Switch' incorporates:
     *  Constant: '<S77>/Calib'
     */
    if (KeTPCR_b_BEV_BattCondCheck)
    {
        /* Switch: '<S60>/Switch' incorporates:
         *  Constant: '<S73>/Constant'
         *  RelationalOperator: '<S60>/Comparison3'
         *  Switch: '<S1764>/Switch'
         */
        VeTPCR_b_RSReq_BattCond = (((uint32)VeTPCR_e_BCMPreCondCabinReq) ==
            CePLTR_e_CabinPreCondStrt);
    }
    else
    {
        /* Switch: '<S60>/Switch' incorporates:
         *  Constant: '<S60>/TRUEConstant'
         */
        VeTPCR_b_RSReq_BattCond = true;
    }

    /* End of Switch: '<S60>/Switch' */

    /* Logic: '<S60>/Logical1' */
    rtb_LogicalOperator1_c = ((VeTPCR_b_BattThrmlSt_Cond) &&
        (VeTPCR_b_RSReq_BattCond));

    /* Outputs for Atomic SubSystem: '<S60>/TurnOnDelayTime1' */
    /* Outputs for Atomic SubSystem: '<S88>/EdgeRising' */
    /* Logic: '<S91>/AND' incorporates:
     *  Logic: '<S91>/OR1'
     *  UnitDelay: '<S91>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant__n = (rtb_LogicalOperator1_c &&
        (!TPCR_ac_DW.UnitDelay_DSTATE_hl));

    /* Update for UnitDelay: '<S91>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_hl = rtb_LogicalOperator1_c;

    /* End of Outputs for SubSystem: '<S88>/EdgeRising' */

    /* Switch: '<S88>/Switch1' incorporates:
     *  Logic: '<S88>/OR'
     *  Logic: '<S88>/OR1'
     */
    if ((!rtb_LogicalOperator1_c) || rtb_VariantMerge_For_Variant__n)
    {
        /* Switch: '<S88>/Switch1' incorporates:
         *  Constant: '<S88>/ConstantValue1'
         */
        rtb_Switch1_l4 = 0.0F;
    }
    else
    {
        /* Switch: '<S88>/Switch1' incorporates:
         *  Constant: '<S84>/Calib'
         *  Constant: '<S86>/Calib'
         *  MinMax: '<S88>/Minimum'
         *  Sum: '<S88>/Summation'
         *  UnitDelay: '<S88>/UnitDelay'
         */
        rtb_Switch1_l4 = fminf(KeTPCR_t_DebounceBattCondOn,
                               KeTPCR_t_RS_CabPrec_dT +
                               TPCR_ac_DW.UnitDelay_DSTATE_oh);
    }

    /* End of Switch: '<S88>/Switch1' */

    /* Logic: '<S88>/AND' incorporates:
     *  Constant: '<S84>/Calib'
     *  RelationalOperator: '<S88>/GreaterThan'
     */
    VeTPCR_b_BattCondOn = (rtb_LogicalOperator1_c && (rtb_Switch1_l4 >=
                            KeTPCR_t_DebounceBattCondOn));

    /* Update for UnitDelay: '<S88>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_oh = rtb_Switch1_l4;

    /* End of Outputs for SubSystem: '<S60>/TurnOnDelayTime1' */

    /* Outputs for Atomic SubSystem: '<S60>/EdgeFalling2' */
    /* Logic: '<S70>/OR1' incorporates:
     *  Logic: '<S102>/Logical6'
     *  Logic: '<S103>/Logical6'
     *  Logic: '<S104>/Logical6'
     *  Logic: '<S897>/Logical4'
     *  Logic: '<S95>/Logical6'
     *  Logic: '<S96>/Logical6'
     */
    rtb_LogicalOperator1_kl_tmp = !VeTPCR_b_BattCondOn;

    /* Logic: '<S70>/AND' incorporates:
     *  Logic: '<S70>/OR1'
     *  UnitDelay: '<S70>/UnitDelay'
     */
    rtb_LogicalOperator1_c = (rtb_LogicalOperator1_kl_tmp &&
        (TPCR_ac_DW.UnitDelay_DSTATE_gm4));

    /* Update for UnitDelay: '<S70>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_gm4 = VeTPCR_b_BattCondOn;

    /* End of Outputs for SubSystem: '<S60>/EdgeFalling2' */

    /* Outputs for Atomic SubSystem: '<S60>/EdgeFalling3' */
    /* Switch: '<S988>/Switch1' incorporates:
     *  UnitDelay: '<S71>/UnitDelay'
     */
    rtb_Switch1_cs = TPCR_ac_DW.UnitDelay_DSTATE_lx;

    /* Update for UnitDelay: '<S71>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_lx = VeTPCR_b_HCPShutDwnCmd;

    /* Outputs for Atomic SubSystem: '<S60>/SignalLatchOnWithReset1' */
    /* Logic: '<S87>/OR1' incorporates:
     *  Logic: '<S71>/AND'
     *  Logic: '<S71>/OR1'
     *  Logic: '<S87>/NOT'
     *  Logic: '<S87>/OR'
     *  UnitDelay: '<S87>/UnitDelay'
     */
    VeTPCR_b_BattCondStopLtch = (rtb_LogicalOperator1_c ||
        (((VeTPCR_b_HCPShutDwnCmd) || (!rtb_Switch1_cs)) &&
         (TPCR_ac_DW.UnitDelay_DSTATE_fdj)));

    /* End of Outputs for SubSystem: '<S60>/EdgeFalling3' */

    /* Update for UnitDelay: '<S87>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fdj = VeTPCR_b_BattCondStopLtch;

    /* End of Outputs for SubSystem: '<S60>/SignalLatchOnWithReset1' */

    /* Outputs for Atomic SubSystem: '<S60>/EdgeRising1' */
    /* Logic: '<S72>/AND' incorporates:
     *  Logic: '<S72>/OR1'
     *  UnitDelay: '<S72>/UnitDelay'
     */
    rtb_LogicalOperator1_c = !TPCR_ac_DW.UnitDelay_DSTATE_mo;

    /* Update for UnitDelay: '<S72>/UnitDelay' incorporates:
     *  Constant: '<S60>/TRUEConstant1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_mo = true;

    /* End of Outputs for SubSystem: '<S60>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S60>/CountDownResetTriggerEnabled1' */
    /* Outputs for Atomic SubSystem: '<S69>/EdgeRising' */
    /* Logic: '<S90>/OR1' incorporates:
     *  UnitDelay: '<S90>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant__n = !TPCR_ac_DW.UnitDelay_DSTATE_fg;

    /* Update for UnitDelay: '<S90>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fg = rtb_LogicalOperator1_c;

    /* Switch: '<S69>/Switch1' incorporates:
     *  Constant: '<S69>/ConstantValue'
     *  Logic: '<S90>/AND'
     *  RelationalOperator: '<S69>/GreaterThan'
     *  Switch: '<S69>/Switch2'
     *  UnitDelay: '<S69>/UnitDelay'
     */
    if (rtb_LogicalOperator1_c && rtb_VariantMerge_For_Variant__n)
    {
        /* Switch: '<S69>/Switch1' incorporates:
         *  Constant: '<S85>/Calib'
         */
        rtb_Switch1_g1 = KeTPCR_t_RS_BCCTim_Expired;
    }
    else if (((sint32)TPCR_ac_DW.UnitDelay_DSTATE_bs) > 0)
    {
        /* Switch: '<S69>/Switch2' incorporates:
         *  Constant: '<S69>/ConstantValue1'
         *  Sum: '<S69>/Subtraction'
         *  Switch: '<S69>/Switch1'
         *  UnitDelay: '<S69>/UnitDelay'
         */
        rtb_Switch1_g1 = (uint16)((sint32)(((sint32)
            TPCR_ac_DW.UnitDelay_DSTATE_bs) - 1));
    }
    else
    {
        /* Switch: '<S69>/Switch1' incorporates:
         *  Switch: '<S69>/Switch2'
         *  UnitDelay: '<S69>/UnitDelay'
         */
        rtb_Switch1_g1 = TPCR_ac_DW.UnitDelay_DSTATE_bs;
    }

    /* End of Switch: '<S69>/Switch1' */
    /* End of Outputs for SubSystem: '<S69>/EdgeRising' */

    /* Update for UnitDelay: '<S69>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_bs = rtb_Switch1_g1;

    /* Logic: '<S60>/Logical4' incorporates:
     *  Constant: '<S69>/ConstantValue2'
     *  Constant: '<S80>/Calib'
     *  Logic: '<S60>/Logical3'
     *  RelationalOperator: '<S69>/GreaterThan1'
     */
    VeTPCR_b_BCC_TmrExpired = ((((sint32)rtb_Switch1_g1) <= 0) &&
        (KeTPCR_b_RS_EnblBCCTmrChk));

    /* End of Outputs for SubSystem: '<S60>/CountDownResetTriggerEnabled1' */

    /* Switch: '<S60>/Switch1' incorporates:
     *  Constant: '<S76>/Calib'
     *  Constant: '<S79>/Calib'
     *  Constant: '<S82>/Calib'
     *  RelationalOperator: '<S60>/Comparison4'
     *  RelationalOperator: '<S60>/Comparison5'
     */
    if (KeTPCR_b_RS_BCC_EnblCellTmpMin)
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t =
            (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lp >=
             KeTPCR_T_RS_BCC_CellTemp_Min);
    }
    else
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t =
            (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn <=
             KeTPCR_dT_RS_BCC_CellUnderTemp_Min);
    }

    /* End of Switch: '<S60>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S1117>/EdgeFalling' */
    /* Outputs for Atomic SubSystem: '<S1115>/EdgeFalling' */
    /* Logic: '<S60>/Logical2' incorporates:
     *  Logic: '<S1026>/Logical4'
     *  Logic: '<S1139>/OR1'
     *  Logic: '<S1176>/OR1'
     *  Logic: '<S894>/Logical16'
     */
    VeTPCR_b_BCC_CellUnderTmpChk_tm = !VeTPCR_b_HCPShutDwnCmd;

    /* End of Outputs for SubSystem: '<S1115>/EdgeFalling' */
    /* End of Outputs for SubSystem: '<S1117>/EdgeFalling' */

    /* Logic: '<S60>/Logical' incorporates:
     *  Constant: '<S78>/Calib'
     *  Logic: '<S60>/Logical2'
     */
    VeTPCR_b_BCC_CellUnderTmpChk = ((VeTPCR_b_DoorAjarEnblLtch_Rst_t &&
        (KeTPCR_b_RS_BCC_CellUnderTmpChk)) && VeTPCR_b_BCC_CellUnderTmpChk_tm);

    /* Outputs for Atomic SubSystem: '<S60>/TurnOnDelayTime2' */
    /* Outputs for Atomic SubSystem: '<S89>/EdgeRising' */
    /* Switch: '<S988>/Switch1' incorporates:
     *  UnitDelay: '<S92>/UnitDelay'
     */
    rtb_Switch1_cs = TPCR_ac_DW.UnitDelay_DSTATE_bi;

    /* Update for UnitDelay: '<S92>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_bi = VeTPCR_b_BCC_CellUnderTmpChk;

    /* Switch: '<S89>/Switch1' incorporates:
     *  Logic: '<S89>/OR'
     *  Logic: '<S89>/OR1'
     *  Logic: '<S92>/AND'
     *  Logic: '<S92>/OR1'
     */
    if ((!VeTPCR_b_BCC_CellUnderTmpChk) || ((VeTPCR_b_BCC_CellUnderTmpChk) &&
            (!rtb_Switch1_cs)))
    {
        /* Switch: '<S89>/Switch1' incorporates:
         *  Constant: '<S89>/ConstantValue1'
         */
        rtb_Switch1_l4 = 0.0F;
    }
    else
    {
        /* Switch: '<S89>/Switch1' incorporates:
         *  Constant: '<S83>/Calib'
         *  Constant: '<S86>/Calib'
         *  MinMax: '<S89>/Minimum'
         *  Sum: '<S89>/Summation'
         *  UnitDelay: '<S89>/UnitDelay'
         */
        rtb_Switch1_l4 = fminf(KeTPCR_t_DebounceBattCondCmplt,
                               KeTPCR_t_RS_CabPrec_dT +
                               TPCR_ac_DW.UnitDelay_DSTATE_cr);
    }

    /* End of Switch: '<S89>/Switch1' */
    /* End of Outputs for SubSystem: '<S89>/EdgeRising' */

    /* Logic: '<S89>/AND' incorporates:
     *  Constant: '<S83>/Calib'
     *  RelationalOperator: '<S89>/GreaterThan'
     */
    VeTPCR_b_BCC_CellUnderTmpChkDbnc = ((VeTPCR_b_BCC_CellUnderTmpChk) &&
        (rtb_Switch1_l4 >= KeTPCR_t_DebounceBattCondCmplt));

    /* Update for UnitDelay: '<S89>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_cr = rtb_Switch1_l4;

    /* End of Outputs for SubSystem: '<S60>/TurnOnDelayTime2' */

    /* Logic: '<S60>/Logical7' */
    VeTPCR_b_BattCondCmplt = ((VeTPCR_b_BCC_TmrExpired) ||
        (VeTPCR_b_BCC_CellUnderTmpChkDbnc));

    /* Logic: '<S60>/Logical5' incorporates:
     *  Constant: '<S81>/Calib'
     *  Logic: '<S60>/Logical8'
     */
    VeTPCR_b_BattCondStop = (((VeTPCR_b_BattCondStopLtch) &&
        (!VeTPCR_b_BattCondCmplt)) && (KeTPCR_b_RS_EnblBCS));

    /* RelationalOperator: '<S17>/Comparison1' incorporates:
     *  RelationalOperator: '<S17>/Comparison2'
     *  RelationalOperator: '<S17>/Comparison3'
     *  RelationalOperator: '<S17>/Comparison4'
     *  RelationalOperator: '<S17>/Comparison5'
     *  RelationalOperator: '<S887>/Comparison12'
     *  RelationalOperator: '<S888>/Comparison8'
     *  RelationalOperator: '<S889>/Comparison15'
     *  RelationalOperator: '<S890>/Comparison19'
     *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
     */
    VeTPCC_b_VhclPlgdIn_tmp = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lm;

    /* Logic: '<S17>/Logical3' incorporates:
     *  Constant: '<S981>/Constant'
     *  Constant: '<S982>/Constant'
     *  Constant: '<S983>/Constant'
     *  Constant: '<S984>/Constant'
     *  Constant: '<S985>/Constant'
     *  RelationalOperator: '<S17>/Comparison1'
     *  RelationalOperator: '<S17>/Comparison2'
     *  RelationalOperator: '<S17>/Comparison3'
     *  RelationalOperator: '<S17>/Comparison4'
     *  RelationalOperator: '<S17>/Comparison5'
     */
    VeTPCC_b_VhclPlgdIn = (((((((uint32)VeTPCC_b_VhclPlgdIn_tmp) ==
        CeOBCR_e_ChargingLvlAC1) || (((uint32)VeTPCC_b_VhclPlgdIn_tmp) ==
        CeOBCR_e_ChargingLvlAC2)) || (((uint32)VeTPCC_b_VhclPlgdIn_tmp) ==
        CeOBCR_e_ChargingLvlAC3)) || (((uint32)VeTPCC_b_VhclPlgdIn_tmp) ==
        CeOBCR_e_ChargingLvlDC1)) || (((uint32)VeTPCC_b_VhclPlgdIn_tmp) ==
                            CeOBCR_e_ChargingLvlDC2));

    /* Outputs for Atomic SubSystem: '<S897>/Hysteresis' */
    /* Switch: '<S977>/Switch1' incorporates:
     *  Constant: '<S978>/Calib'
     *  Constant: '<S979>/Calib'
     *  RelationalOperator: '<S977>/GreaterThan'
     *  Sum: '<S897>/Sum'
     */
    if (VeTPCR_Pct_HVBatSOC > (KeTPCR_Pct_UnplugSOCTh +
                               KeTPCR_Pct_UnplugSOCTh_Hys))
    {
        /* Switch: '<S977>/Switch1' incorporates:
         *  Constant: '<S977>/ConstantValue'
         */
        rtb_LogicalOperator1_c = true;
    }
    else
    {
        /* Switch: '<S977>/Switch1' incorporates:
         *  RelationalOperator: '<S977>/GreaterThan1'
         *  UnitDelay: '<S977>/UnitDelay'
         */
        rtb_LogicalOperator1_c = ((VeTPCR_Pct_HVBatSOC >= KeTPCR_Pct_UnplugSOCTh)
            && (TPCR_ac_DW.UnitDelay_DSTATE_nr));
    }

    /* End of Switch: '<S977>/Switch1' */

    /* Update for UnitDelay: '<S977>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_nr = rtb_LogicalOperator1_c;

    /* End of Outputs for SubSystem: '<S897>/Hysteresis' */

    /* Outputs for Atomic SubSystem: '<S1117>/EdgeRising1' */
    /* Logic: '<S897>/Logical6' incorporates:
     *  Logic: '<S101>/Logical9'
     *  Logic: '<S1117>/Logical18'
     *  Logic: '<S1177>/AND'
     *  Logic: '<S756>/Logical4'
     *  Logic: '<S7>/Logical1'
     *  Logic: '<S881>/Logical9'
     *  Logic: '<S891>/Logical19'
     *  Logic: '<S896>/Logical11'
     */
    VeTPCR_b_UnplugNoBattCond_SOC_t = !VeTPCC_b_VhclPlgdIn;

    /* End of Outputs for SubSystem: '<S1117>/EdgeRising1' */

    /* Logic: '<S897>/Logical7' incorporates:
     *  Constant: '<S980>/Calib'
     *  Logic: '<S888>/Logical7'
     *  Logic: '<S890>/Logical7'
     */
    rtb_VariantMerge_For_Variant__n = (rtb_LogicalOperator1_kl_tmp ||
        (KeTPCR_b_DsblBattCondChk));

    /* Logic: '<S897>/Logical2' incorporates:
     *  Constant: '<S975>/Constant'
     *  Constant: '<S976>/Constant'
     *  Logic: '<S897>/Logical1'
     *  Logic: '<S897>/Logical3'
     *  Logic: '<S897>/Logical5'
     *  Logic: '<S897>/Logical6'
     *  Logic: '<S897>/Logical7'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S897>/Comparison1'
     *  RelationalOperator: '<S897>/Comparison3'
     *  Switch: '<S1760>/Switch'
     */
    VeTPCR_b_UnplugNoBattCond_SOC = (((VeTPCR_b_UnplugNoBattCond_SOC_t ||
        ((((uint32)VeTPCR_e_PMM_PowerMode_AD) != CeSSDR_e_KeyOff) && (((uint32)
        VeTPCR_e_PMM_PowerMode_AD) != CeSSDR_e_KeyAccy))) &&
        rtb_VariantMerge_For_Variant__n) && (!rtb_LogicalOperator1_c));

    /* Outputs for Atomic SubSystem: '<S896>/Hysteresis1' */
    /* Switch: '<S971>/Switch1' incorporates:
     *  Constant: '<S972>/Calib'
     *  Constant: '<S973>/Calib'
     *  RelationalOperator: '<S971>/GreaterThan'
     *  Sum: '<S896>/Sum1'
     */
    if (VeTPCR_Pct_HVBatSOC > (KeTPCR_Pct_UnplugBattCondSOCThrshd +
                               KeTPCR_Pct_UnplugBattCondSOCHys))
    {
        /* Switch: '<S971>/Switch1' incorporates:
         *  Constant: '<S971>/ConstantValue'
         */
        rtb_LogicalOperator1_c = true;
    }
    else
    {
        /* Switch: '<S971>/Switch1' incorporates:
         *  RelationalOperator: '<S971>/GreaterThan1'
         *  UnitDelay: '<S971>/UnitDelay'
         */
        rtb_LogicalOperator1_c = ((VeTPCR_Pct_HVBatSOC >=
            KeTPCR_Pct_UnplugBattCondSOCThrshd) &&
            (TPCR_ac_DW.UnitDelay_DSTATE_ab));
    }

    /* End of Switch: '<S971>/Switch1' */

    /* Update for UnitDelay: '<S971>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ab = rtb_LogicalOperator1_c;

    /* End of Outputs for SubSystem: '<S896>/Hysteresis1' */

    /* Logic: '<S896>/Logical1' incorporates:
     *  Constant: '<S974>/Calib'
     *  Logic: '<S887>/Logical7'
     *  Logic: '<S889>/Logical7'
     */
    rtb_AND_gq3 = ((VeTPCR_b_BattCondOn) || (KeTPCR_b_DsblBattCondChk));

    /* Logic: '<S896>/Logical9' incorporates:
     *  Constant: '<S969>/Constant'
     *  Constant: '<S970>/Constant'
     *  Logic: '<S896>/Logical1'
     *  Logic: '<S896>/Logical10'
     *  Logic: '<S896>/Logical11'
     *  Logic: '<S896>/Logical7'
     *  Logic: '<S896>/Logical8'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S896>/Comparison2'
     *  RelationalOperator: '<S896>/Comparison4'
     *  Switch: '<S1760>/Switch'
     */
    VeTPCR_b_UnplugBattCond_SOC = (((VeTPCR_b_UnplugNoBattCond_SOC_t ||
        ((((uint32)VeTPCR_e_PMM_PowerMode_AD) != CeSSDR_e_KeyOff) && (((uint32)
        VeTPCR_e_PMM_PowerMode_AD) != CeSSDR_e_KeyAccy))) && rtb_AND_gq3) &&
        (!rtb_LogicalOperator1_c));

    /* Outputs for Atomic SubSystem: '<S888>/Hysteresis1' */
    /* Switch: '<S918>/Switch1' incorporates:
     *  Constant: '<S919>/Calib'
     *  Constant: '<S920>/Calib'
     *  RelationalOperator: '<S918>/GreaterThan'
     *  Sum: '<S888>/Sum2'
     */
    if (VeTPCR_Pct_HVBatSOC > (KeTPCR_Pct_PlugLvl1SOCThrshd +
                               KeTPCR_Pct_PlugLvl1SOCHys))
    {
        /* Switch: '<S918>/Switch1' incorporates:
         *  Constant: '<S918>/ConstantValue'
         */
        rtb_LogicalOperator1_c = true;
    }
    else
    {
        /* Switch: '<S918>/Switch1' incorporates:
         *  RelationalOperator: '<S918>/GreaterThan1'
         *  UnitDelay: '<S918>/UnitDelay'
         */
        rtb_LogicalOperator1_c = ((VeTPCR_Pct_HVBatSOC >=
            KeTPCR_Pct_PlugLvl1SOCThrshd) && (TPCR_ac_DW.UnitDelay_DSTATE_ado));
    }

    /* End of Switch: '<S918>/Switch1' */

    /* Update for UnitDelay: '<S918>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ado = rtb_LogicalOperator1_c;

    /* End of Outputs for SubSystem: '<S888>/Hysteresis1' */

    /* Logic: '<S888>/Logical16' incorporates:
     *  Constant: '<S914>/Constant'
     *  Constant: '<S915>/Constant'
     *  Constant: '<S916>/Constant'
     *  Constant: '<S917>/Constant'
     *  Logic: '<S888>/Logical12'
     *  Logic: '<S888>/Logical13'
     *  Logic: '<S888>/Logical14'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S888>/Comparison5'
     *  RelationalOperator: '<S888>/Comparison6'
     *  RelationalOperator: '<S888>/Comparison7'
     *  RelationalOperator: '<S888>/Comparison8'
     *  Switch: '<S1760>/Switch'
     *  Switch: '<S1766>/Switch'
     */
    VeTPCR_b_PlugLv1_NoBattCond_SOC = (((((((uint32)VeTPCC_b_VhclPlgdIn_tmp) ==
        CeOBCR_e_ChargingLvlAC1) && ((((uint32)VeTPCR_e_PMM_PowerMode_AD) ==
        CeSSDR_e_KeyOff) || (((uint32)VeTPCR_e_PMM_PowerMode_AD) ==
        CeSSDR_e_KeyAccy))) && (((uint32)VeTPCR_e_ChargingSystemSts) ==
        CeOBCR_e_ChargingSts_Charging)) && rtb_VariantMerge_For_Variant__n) && (
        !rtb_LogicalOperator1_c));

    /* Outputs for Atomic SubSystem: '<S887>/Hysteresis1' */
    /* Switch: '<S910>/Switch1' incorporates:
     *  Constant: '<S911>/Calib'
     *  Constant: '<S912>/Calib'
     *  RelationalOperator: '<S910>/GreaterThan'
     *  Sum: '<S887>/Sum3'
     */
    if (VeTPCR_Pct_HVBatSOC > (KeTPCR_Pct_PlugLvl1BattCondSOCThrshd +
                               KeTPCR_Pct_PlugLvl1BattCondSOCHys))
    {
        /* Switch: '<S910>/Switch1' incorporates:
         *  Constant: '<S910>/ConstantValue'
         */
        rtb_LogicalOperator1_c = true;
    }
    else
    {
        /* Switch: '<S910>/Switch1' incorporates:
         *  RelationalOperator: '<S910>/GreaterThan1'
         *  UnitDelay: '<S910>/UnitDelay'
         */
        rtb_LogicalOperator1_c = ((VeTPCR_Pct_HVBatSOC >=
            KeTPCR_Pct_PlugLvl1BattCondSOCThrshd) &&
            (TPCR_ac_DW.UnitDelay_DSTATE_m5));
    }

    /* End of Switch: '<S910>/Switch1' */

    /* Update for UnitDelay: '<S910>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_m5 = rtb_LogicalOperator1_c;

    /* End of Outputs for SubSystem: '<S887>/Hysteresis1' */

    /* Logic: '<S887>/Logical21' incorporates:
     *  Constant: '<S906>/Constant'
     *  Constant: '<S907>/Constant'
     *  Constant: '<S908>/Constant'
     *  Constant: '<S909>/Constant'
     *  Logic: '<S887>/Logical17'
     *  Logic: '<S887>/Logical18'
     *  Logic: '<S887>/Logical19'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S887>/Comparison10'
     *  RelationalOperator: '<S887>/Comparison11'
     *  RelationalOperator: '<S887>/Comparison12'
     *  RelationalOperator: '<S887>/Comparison9'
     *  RelationalOperator: '<S888>/Comparison7'
     *  Switch: '<S1760>/Switch'
     *  Switch: '<S1766>/Switch'
     */
    VeTPCR_b_PlugLv1_BattCond_SOC = (((((((uint32)VeTPCC_b_VhclPlgdIn_tmp) ==
        CeOBCR_e_ChargingLvlAC1) && ((((uint32)VeTPCR_e_PMM_PowerMode_AD) ==
        CeSSDR_e_KeyOff) || (((uint32)VeTPCR_e_PMM_PowerMode_AD) ==
        CeSSDR_e_KeyAccy))) && (((uint32)VeTPCR_e_ChargingSystemSts) ==
        CeOBCR_e_ChargingSts_Charging)) && rtb_AND_gq3) &&
        (!rtb_LogicalOperator1_c));

    /* Outputs for Atomic SubSystem: '<S890>/Hysteresis1' */
    /* Switch: '<S934>/Switch1' incorporates:
     *  Constant: '<S935>/Calib'
     *  Constant: '<S936>/Calib'
     *  RelationalOperator: '<S934>/GreaterThan'
     *  Sum: '<S890>/Sum4'
     */
    if (VeTPCR_Pct_HVBatSOC > (KeTPCR_Pct_PlugLvl2SOCThrshd +
                               KeTPCR_Pct_PlugLvl2SOCHys))
    {
        /* Switch: '<S934>/Switch1' incorporates:
         *  Constant: '<S934>/ConstantValue'
         */
        rtb_LogicalOperator1_c = true;
    }
    else
    {
        /* Switch: '<S934>/Switch1' incorporates:
         *  RelationalOperator: '<S934>/GreaterThan1'
         *  UnitDelay: '<S934>/UnitDelay'
         */
        rtb_LogicalOperator1_c = ((VeTPCR_Pct_HVBatSOC >=
            KeTPCR_Pct_PlugLvl2SOCThrshd) && (TPCR_ac_DW.UnitDelay_DSTATE_msz));
    }

    /* End of Switch: '<S934>/Switch1' */

    /* Update for UnitDelay: '<S934>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_msz = rtb_LogicalOperator1_c;

    /* End of Outputs for SubSystem: '<S890>/Hysteresis1' */

    /* Logic: '<S890>/Logical25' incorporates:
     *  Constant: '<S930>/Constant'
     *  Constant: '<S931>/Constant'
     *  Constant: '<S932>/Constant'
     *  Constant: '<S933>/Constant'
     *  Logic: '<S890>/Logical20'
     *  Logic: '<S890>/Logical22'
     *  Logic: '<S890>/Logical23'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S888>/Comparison7'
     *  RelationalOperator: '<S890>/Comparison16'
     *  RelationalOperator: '<S890>/Comparison17'
     *  RelationalOperator: '<S890>/Comparison18'
     *  RelationalOperator: '<S890>/Comparison19'
     *  Switch: '<S1760>/Switch'
     *  Switch: '<S1766>/Switch'
     */
    VeTPCR_b_PlugLv2_NoBattCond_SOC = (((((((uint32)VeTPCC_b_VhclPlgdIn_tmp) ==
        CeOBCR_e_ChargingLvlAC2) && ((((uint32)VeTPCR_e_PMM_PowerMode_AD) ==
        CeSSDR_e_KeyOff) || (((uint32)VeTPCR_e_PMM_PowerMode_AD) ==
        CeSSDR_e_KeyAccy))) && (((uint32)VeTPCR_e_ChargingSystemSts) ==
        CeOBCR_e_ChargingSts_Charging)) && rtb_VariantMerge_For_Variant__n) && (
        !rtb_LogicalOperator1_c));

    /* Outputs for Atomic SubSystem: '<S889>/Hysteresis1' */
    /* Switch: '<S926>/Switch1' incorporates:
     *  Constant: '<S927>/Calib'
     *  Constant: '<S928>/Calib'
     *  RelationalOperator: '<S926>/GreaterThan'
     *  Sum: '<S889>/Sum5'
     */
    if (VeTPCR_Pct_HVBatSOC > (KeTPCR_Pct_PlugLvl2BattCondSOCThrshd +
                               KeTPCR_Pct_PlugLvl2BattCondSOCHys))
    {
        /* Switch: '<S926>/Switch1' incorporates:
         *  Constant: '<S926>/ConstantValue'
         */
        rtb_LogicalOperator1_c = true;
    }
    else
    {
        /* Switch: '<S926>/Switch1' incorporates:
         *  RelationalOperator: '<S926>/GreaterThan1'
         *  UnitDelay: '<S926>/UnitDelay'
         */
        rtb_LogicalOperator1_c = ((VeTPCR_Pct_HVBatSOC >=
            KeTPCR_Pct_PlugLvl2BattCondSOCThrshd) &&
            (TPCR_ac_DW.UnitDelay_DSTATE_g5));
    }

    /* End of Switch: '<S926>/Switch1' */

    /* Update for UnitDelay: '<S926>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_g5 = rtb_LogicalOperator1_c;

    /* End of Outputs for SubSystem: '<S889>/Hysteresis1' */

    /* Logic: '<S889>/Logical29' incorporates:
     *  Constant: '<S922>/Constant'
     *  Constant: '<S923>/Constant'
     *  Constant: '<S924>/Constant'
     *  Constant: '<S925>/Constant'
     *  Logic: '<S889>/Logical26'
     *  Logic: '<S889>/Logical27'
     *  Logic: '<S889>/Logical28'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S888>/Comparison7'
     *  RelationalOperator: '<S889>/Comparison13'
     *  RelationalOperator: '<S889>/Comparison14'
     *  RelationalOperator: '<S889>/Comparison15'
     *  RelationalOperator: '<S889>/Comparison20'
     *  Switch: '<S1760>/Switch'
     *  Switch: '<S1766>/Switch'
     */
    VeTPCR_b_PlugLv2_BattCond_SOC = (((((((uint32)VeTPCC_b_VhclPlgdIn_tmp) ==
        CeOBCR_e_ChargingLvlAC2) && ((((uint32)VeTPCR_e_PMM_PowerMode_AD) ==
        CeSSDR_e_KeyOff) || (((uint32)VeTPCR_e_PMM_PowerMode_AD) ==
        CeSSDR_e_KeyAccy))) && (((uint32)VeTPCR_e_ChargingSystemSts) ==
        CeOBCR_e_ChargingSts_Charging)) && rtb_AND_gq3) &&
        (!rtb_LogicalOperator1_c));

    /* Logic: '<S16>/Logical2' */
    VeTPCR_b_SOCChk_InhibitRS = ((((((VeTPCR_b_UnplugNoBattCond_SOC) &&
        (VeTPCR_b_UnplugBattCond_SOC)) && (VeTPCR_b_PlugLv1_NoBattCond_SOC)) &&
        (VeTPCR_b_PlugLv1_BattCond_SOC)) && (VeTPCR_b_PlugLv2_NoBattCond_SOC)) &&
        (VeTPCR_b_PlugLv2_BattCond_SOC));

    /* Logic: '<S16>/Logical' incorporates:
     *  Constant: '<S884>/Calib'
     */
    VeTPCR_b_SOCFlt_BEVRS = ((VeTPCR_b_SOCChk_InhibitRS) &&
        (KeTPCR_b_EnblBEV_SOCCond));

    /* Outputs for Atomic SubSystem: '<S881>/Hysteresis1' */
    /* Switch: '<S898>/Switch1' incorporates:
     *  Constant: '<S899>/Calib'
     *  RelationalOperator: '<S898>/GreaterThan'
     */
    if (VeTPCR_Pct_HVBatSOC > KeTPCR_Pct_PreCond_CabNoPlugInSOC_Max)
    {
        /* Switch: '<S898>/Switch1' incorporates:
         *  Constant: '<S898>/ConstantValue'
         */
        VeTPCR_b_SOCNoRejection = true;
    }
    else
    {
        /* Switch: '<S898>/Switch1' incorporates:
         *  Constant: '<S900>/Calib'
         *  RelationalOperator: '<S898>/GreaterThan1'
         *  UnitDelay: '<S898>/UnitDelay'
         */
        VeTPCR_b_SOCNoRejection = ((VeTPCR_Pct_HVBatSOC >=
            KeTPCR_Pct_PreCond_CabNoPlugInSOC_Min) &&
            (TPCR_ac_DW.UnitDelay_DSTATE_fux));
    }

    /* End of Switch: '<S898>/Switch1' */

    /* Update for UnitDelay: '<S898>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fux = VeTPCR_b_SOCNoRejection;

    /* End of Outputs for SubSystem: '<S881>/Hysteresis1' */

    /* Logic: '<S881>/Logical1' */
    VeTPCR_b_SOCRejection = !VeTPCR_b_SOCNoRejection;

    /* Logic: '<S881>/Logical8' incorporates:
     *  Constant: '<S901>/Calib'
     */
    VeTPCR_b_SOCRejection_SOC_NoPlugIn = ((VeTPCR_b_UnplugNoBattCond_SOC_t &&
        (VeTPCR_b_SOCRejection)) && (KeTPCR_b_EnblNoPlugIn_SOCChk));

    /* Outputs for Atomic SubSystem: '<S882>/Hysteresis' */
    /* Switch: '<S902>/Switch1' incorporates:
     *  Constant: '<S903>/Calib'
     *  RelationalOperator: '<S902>/GreaterThan'
     */
    if (VeTPCR_Pct_HVBatSOC > KeTPCR_Pct_PreCond_CabPlugInSOC_Max)
    {
        /* Switch: '<S902>/Switch1' incorporates:
         *  Constant: '<S902>/ConstantValue'
         */
        VeTPCR_b_SOCInLimit_PlugIn = true;
    }
    else
    {
        /* Switch: '<S902>/Switch1' incorporates:
         *  Constant: '<S904>/Calib'
         *  RelationalOperator: '<S902>/GreaterThan1'
         *  UnitDelay: '<S902>/UnitDelay'
         */
        VeTPCR_b_SOCInLimit_PlugIn = ((VeTPCR_Pct_HVBatSOC >=
            KeTPCR_Pct_PreCond_CabPlugInSOC_Min) &&
            (TPCR_ac_DW.UnitDelay_DSTATE_bbd));
    }

    /* End of Switch: '<S902>/Switch1' */

    /* Update for UnitDelay: '<S902>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_bbd = VeTPCR_b_SOCInLimit_PlugIn;

    /* End of Outputs for SubSystem: '<S882>/Hysteresis' */

    /* Logic: '<S882>/Logical4' */
    VeTPCR_b_SOCRejectionLimit_PlugIn = !VeTPCR_b_SOCInLimit_PlugIn;

    /* Logic: '<S882>/Logical11' incorporates:
     *  Constant: '<S905>/Calib'
     *  Logic: '<S882>/Logical19'
     */
    VeTPCR_b_SOCRejection_SOC_PlugIn = (((VeTPCC_b_VhclPlgdIn) ||
        (KeTPCR_b_DsblPlugIn_SOCChk)) && (VeTPCR_b_SOCRejectionLimit_PlugIn));

    /* Outputs for Atomic SubSystem: '<S891>/Hysteresis' */
    /* Switch: '<S938>/Switch1' incorporates:
     *  Constant: '<S939>/Calib'
     *  RelationalOperator: '<S938>/GreaterThan'
     */
    if (VeTPCR_P_PwrBdgtAvail > KeTPCR_P_NoPlugIn_PwrBdgtAllowCabCond_Max)
    {
        /* Switch: '<S938>/Switch1' incorporates:
         *  Constant: '<S938>/ConstantValue'
         */
        rtb_LogicalOperator1_c = true;
    }
    else
    {
        /* Switch: '<S938>/Switch1' incorporates:
         *  Constant: '<S940>/Calib'
         *  RelationalOperator: '<S938>/GreaterThan1'
         *  UnitDelay: '<S938>/UnitDelay'
         */
        rtb_LogicalOperator1_c = ((VeTPCR_P_PwrBdgtAvail >=
            KeTPCR_P_NoPlugIn_PwrBdgtAllowCabCond_Min) &&
            (TPCR_ac_DW.UnitDelay_DSTATE_my));
    }

    /* End of Switch: '<S938>/Switch1' */

    /* Update for UnitDelay: '<S938>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_my = rtb_LogicalOperator1_c;

    /* End of Outputs for SubSystem: '<S891>/Hysteresis' */

    /* Logic: '<S891>/Logical5' */
    VeTPCR_b_PwrBdgtRejectionLimit_NoPlugIn = !rtb_LogicalOperator1_c;

    /* Logic: '<S891>/Logical11' */
    VeTPCR_b_SOCRejection_SOC_PwrBdgt_NoPlugIn =
        (VeTPCR_b_UnplugNoBattCond_SOC_t &&
         (VeTPCR_b_PwrBdgtRejectionLimit_NoPlugIn));

    /* Outputs for Atomic SubSystem: '<S892>/Hysteresis' */
    /* Switch: '<S941>/Switch1' incorporates:
     *  Constant: '<S942>/Calib'
     *  RelationalOperator: '<S941>/GreaterThan'
     */
    if (VeTPCR_P_PwrBdgtAvail > KeTPCR_P_PlugIn_PwrBdgtAllowCabCond_Max)
    {
        /* Switch: '<S941>/Switch1' incorporates:
         *  Constant: '<S941>/ConstantValue'
         */
        rtb_LogicalOperator1_c = true;
    }
    else
    {
        /* Switch: '<S941>/Switch1' incorporates:
         *  Constant: '<S943>/Calib'
         *  RelationalOperator: '<S941>/GreaterThan1'
         *  UnitDelay: '<S941>/UnitDelay'
         */
        rtb_LogicalOperator1_c = ((VeTPCR_P_PwrBdgtAvail >=
            KeTPCR_P_PlugIn_PwrBdgtAllowCabCond_Min) &&
            (TPCR_ac_DW.UnitDelay_DSTATE_n1));
    }

    /* End of Switch: '<S941>/Switch1' */

    /* Update for UnitDelay: '<S941>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_n1 = rtb_LogicalOperator1_c;

    /* End of Outputs for SubSystem: '<S892>/Hysteresis' */

    /* Logic: '<S892>/Logical5' */
    VeTPCR_b_PwrBdgtRejectionLimit_PlugIn = !rtb_LogicalOperator1_c;

    /* Logic: '<S892>/Logical11' incorporates:
     *  Constant: '<S944>/Calib'
     *  Logic: '<S892>/Logical19'
     */
    VeTPCR_b_SOCRejection_SOC_PwrBdgt_PlugIn = (((VeTPCC_b_VhclPlgdIn) ||
        (KeTPCR_b_DsblPlugIn_PwrBdgtChk)) &&
        (VeTPCR_b_PwrBdgtRejectionLimit_PlugIn));

    /* Outputs for Atomic SubSystem: '<S894>/Hysteresis3' */
    /* Switch: '<S947>/Switch1' incorporates:
     *  Constant: '<S948>/Calib'
     *  RelationalOperator: '<S947>/GreaterThan'
     */
    if (VeTPCR_Pct_HVBatSOC > KeTPCR_Pct_BattPriority_SOCMax)
    {
        /* Switch: '<S947>/Switch1' incorporates:
         *  Constant: '<S947>/ConstantValue'
         */
        VeTPCR_b_SOCLimit_BattPrio = true;
    }
    else
    {
        /* Switch: '<S947>/Switch1' incorporates:
         *  Constant: '<S949>/Calib'
         *  RelationalOperator: '<S947>/GreaterThan1'
         *  UnitDelay: '<S947>/UnitDelay'
         */
        VeTPCR_b_SOCLimit_BattPrio = ((VeTPCR_Pct_HVBatSOC >=
            KeTPCR_Pct_BattPriority_SOCMin) && (TPCR_ac_DW.UnitDelay_DSTATE_f4p));
    }

    /* End of Switch: '<S947>/Switch1' */

    /* Update for UnitDelay: '<S947>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_f4p = VeTPCR_b_SOCLimit_BattPrio;

    /* End of Outputs for SubSystem: '<S894>/Hysteresis3' */

    /* Logic: '<S894>/Logical13' */
    VeTPCR_b_SOCRejection_BattPrio = !VeTPCR_b_SOCLimit_BattPrio;

    /* Logic: '<S894>/Logical10' incorporates:
     *  Constant: '<S950>/Calib'
     *  Constant: '<S951>/Calib'
     *  Constant: '<S952>/Calib'
     *  Constant: '<S953>/Calib'
     *  Logic: '<S894>/Logical14'
     *  Logic: '<S894>/Logical15'
     *  Logic: '<S894>/Logical17'
     *  Logic: '<S894>/Logical7'
     */
    VeTPCR_b_SOCReject_BattPrio =
        ((((((!TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gt) &&
             (VeTPCR_b_SOCRejection_BattPrio)) && ((VeTPCC_b_VhclPlgdIn) ||
             (KeTPCR_b_Enbl_PlugInChkPrec_BattPrio))) &&
           (VeTPCR_b_BCC_CellUnderTmpChk_tm || (KeTPCR_b_Enbl_ShtDwnCmd_BattPrio)))
          && ((VeTPCR_b_SC_WakeUpReq) || (KeTPCR_b_DsblScWkUp_BattPrio))) &&
         (KeTPCR_b_EnblBattPriority));

    /* Outputs for Atomic SubSystem: '<S895>/Hysteresis' */
    /* Switch: '<S960>/Switch1' incorporates:
     *  Constant: '<S963>/Calib'
     *  RelationalOperator: '<S960>/GreaterThan'
     */
    if (VeTPCR_P_PwrBdgtAvail > KeTPCR_P_PwrBdgtMax)
    {
        /* Switch: '<S960>/Switch1' incorporates:
         *  Constant: '<S960>/ConstantValue'
         */
        VeTPCR_b_PwrBdgtLimit = true;
    }
    else
    {
        /* Switch: '<S960>/Switch1' incorporates:
         *  Constant: '<S964>/Calib'
         *  RelationalOperator: '<S960>/GreaterThan1'
         *  UnitDelay: '<S960>/UnitDelay'
         */
        VeTPCR_b_PwrBdgtLimit = ((VeTPCR_P_PwrBdgtAvail >= KeTPCR_P_PwrBdgtMin) &&
            (TPCR_ac_DW.UnitDelay_DSTATE_oc));
    }

    /* End of Switch: '<S960>/Switch1' */

    /* Update for UnitDelay: '<S960>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_oc = VeTPCR_b_PwrBdgtLimit;

    /* End of Outputs for SubSystem: '<S895>/Hysteresis' */

    /* Logic: '<S194>/Logical12' incorporates:
     *  Constant: '<S959>/Constant'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S895>/Comparison3'
     *  Switch: '<S1760>/Switch'
     */
    rtb_NotEqual_p = (((uint32)VeTPCR_e_PMM_PowerMode_AD) ==
                      CeSSDR_e_KeyPostCrnk);

    /* Outputs for Atomic SubSystem: '<S895>/EdgeRising2' */
    /* Logic: '<S955>/OR1' incorporates:
     *  UnitDelay: '<S955>/UnitDelay'
     */
    rtb_VariantMerge_For_Variant__n = !TPCR_ac_DW.UnitDelay_DSTATE_gvw;

    /* Update for UnitDelay: '<S955>/UnitDelay' incorporates:
     *  Constant: '<S895>/TRUEConstant'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_gvw = true;

    /* End of Outputs for SubSystem: '<S895>/EdgeRising2' */

    /* Outputs for Atomic SubSystem: '<S895>/EdgeRising1' */
    /* Logic: '<S954>/OR1' incorporates:
     *  UnitDelay: '<S954>/UnitDelay'
     */
    rtb_AND_gq3 = !TPCR_ac_DW.UnitDelay_DSTATE_l2;

    /* Update for UnitDelay: '<S954>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_l2 = VeTPCR_b_SC_WakeUpReq;

    /* End of Outputs for SubSystem: '<S895>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S895>/EdgeRising3' */
    /* Logic: '<S956>/OR1' incorporates:
     *  UnitDelay: '<S956>/UnitDelay'
     */
    rtb_Comparison1_pa = !TPCR_ac_DW.UnitDelay_DSTATE_jo;

    /* Update for UnitDelay: '<S956>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_jo = VeTPCR_b_HCPShutDwnCmd;

    /* End of Outputs for SubSystem: '<S895>/EdgeRising3' */

    /* Outputs for Atomic SubSystem: '<S895>/EdgeRising4' */
    /* Logic: '<S957>/OR1' incorporates:
     *  UnitDelay: '<S957>/UnitDelay'
     */
    rtb_OR1_ksz = !TPCR_ac_DW.UnitDelay_DSTATE_fy;

    /* Update for UnitDelay: '<S957>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fy = rtb_LogicalOperator_h0;

    /* Outputs for Atomic SubSystem: '<S895>/EdgeRising2' */
    /* Outputs for Atomic SubSystem: '<S895>/EdgeRising1' */
    /* Outputs for Atomic SubSystem: '<S895>/EdgeRising3' */
    /* Logic: '<S895>/Logical3' incorporates:
     *  Logic: '<S954>/AND'
     *  Logic: '<S955>/AND'
     *  Logic: '<S956>/AND'
     *  Logic: '<S957>/AND'
     */
    rtb_VariantMerge_For_Variant__n = ((((rtb_VariantMerge_For_Variant__n ||
        ((VeTPCR_b_SC_WakeUpReq) && rtb_AND_gq3)) || ((VeTPCR_b_HCPShutDwnCmd) &&
        rtb_Comparison1_pa)) || (rtb_LogicalOperator_h0 && rtb_OR1_ksz)) ||
        rtb_NotEqual_p);

    /* End of Outputs for SubSystem: '<S895>/EdgeRising3' */
    /* End of Outputs for SubSystem: '<S895>/EdgeRising1' */
    /* End of Outputs for SubSystem: '<S895>/EdgeRising2' */
    /* End of Outputs for SubSystem: '<S895>/EdgeRising4' */

    /* Switch: '<S962>/Switch1' incorporates:
     *  Constant: '<S967>/Calib'
     *  UnitDelay: '<S895>/UnitDelay1'
     */
    if (KeTPCR_b_EnblRstDly)
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = TPCR_ac_DW.UnitDelay1_DSTATE_d;
    }
    else
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = rtb_VariantMerge_For_Variant__n;
    }

    /* Outputs for Atomic SubSystem: '<S895>/SignalLatchOnWithReset' */
    /* Logic: '<S968>/OR1' incorporates:
     *  Constant: '<S966>/Calib'
     *  DataStoreRead: '<S895>/DataStoreRead1'
     *  Logic: '<S895>/Logical6'
     *  Logic: '<S895>/Logical7'
     *  Logic: '<S895>/Logical8'
     *  Logic: '<S968>/NOT'
     *  Logic: '<S968>/OR'
     *  RelationalOperator: '<S895>/Comparison2'
     *  Switch: '<S962>/Switch1'
     *  UnitDelay: '<S895>/UnitDelay'
     *  UnitDelay: '<S968>/UnitDelay'
     */
    rtb_AND_gq3 = (((TPCR_ac_DW.NeTPCR_Pct_WupSOC <= KeTPCR_Pct_SOCMin) &&
                    (!rtb_NotEqual_p)) || (((!VeTPCR_b_DoorAjarEnblLtch_Rst_t) &&
                     (!TPCR_ac_DW.UnitDelay_DSTATE_di)) &&
                    (TPCR_ac_DW.UnitDelay_DSTATE_fr)));

    /* Update for UnitDelay: '<S968>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fr = rtb_AND_gq3;

    /* End of Outputs for SubSystem: '<S895>/SignalLatchOnWithReset' */

    /* Outputs for Atomic SubSystem: '<S895>/Hysteresis3' */
    /* Switch: '<S961>/Switch1' incorporates:
     *  Constant: '<S965>/Calib'
     *  RelationalOperator: '<S961>/GreaterThan'
     */
    if (VeTPCR_Pct_HVBatSOC > KeTPCR_Pct_SOCMax)
    {
        /* Switch: '<S961>/Switch1' incorporates:
         *  Constant: '<S961>/ConstantValue'
         */
        VeTPCR_b_SOCLimit = true;
    }
    else
    {
        /* Switch: '<S961>/Switch1' incorporates:
         *  Constant: '<S966>/Calib'
         *  RelationalOperator: '<S961>/GreaterThan1'
         *  UnitDelay: '<S961>/UnitDelay'
         */
        VeTPCR_b_SOCLimit = ((VeTPCR_Pct_HVBatSOC >= KeTPCR_Pct_SOCMin) &&
                             (TPCR_ac_DW.UnitDelay_DSTATE_nbi));
    }

    /* End of Switch: '<S961>/Switch1' */

    /* Update for UnitDelay: '<S961>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_nbi = VeTPCR_b_SOCLimit;

    /* End of Outputs for SubSystem: '<S895>/Hysteresis3' */

    /* Switch: '<S895>/Switch1' incorporates:
     *  Logic: '<S895>/Logical1'
     *  Logic: '<S895>/Logical2'
     */
    if ((!VeTPCR_b_PwrBdgtLimit) || rtb_AND_gq3)
    {
        /* Switch: '<S895>/Switch2' */
        if (VeTPCR_b_PwrBdgtLimit)
        {
            /* Logic: '<S895>/Logical13' incorporates:
             *  Constant: '<S895>/ConstantValue'
             *  DataStoreRead: '<S895>/DataStoreRead2'
             *  RelationalOperator: '<S895>/Comparison1'
             *  Sum: '<S895>/Sum1'
             */
            rtb_AND_gq3 = ((TPCR_ac_DW.NeTPCR_Pct_WupSOC - VeTPCR_Pct_HVBatSOC) >=
                           1.0F);
        }
        else
        {
            /* Logic: '<S895>/Logical13' */
            rtb_AND_gq3 = true;
        }

        /* End of Switch: '<S895>/Switch2' */
    }
    else
    {
        /* Logic: '<S895>/Logical13' */
        rtb_AND_gq3 = !VeTPCR_b_SOCLimit;
    }

    /* End of Switch: '<S895>/Switch1' */

    /* Logic: '<S16>/Logical3' incorporates:
     *  Constant: '<S883>/Calib'
     *  Constant: '<S885>/Calib'
     *  Constant: '<S886>/Calib'
     *  Logic: '<S16>/Logical1'
     *  Logic: '<S16>/Logical12'
     *  Logic: '<S16>/Logical6'
     *  Logic: '<S16>/Logical7'
     *  Logic: '<S16>/Logical8'
     *  Logic: '<S895>/Logical4'
     *  Logic: '<S895>/Logical5'
     */
    VeTPCR_b_SOCRejected = (((VeTPCR_b_SOCFlt_BEVRS) || ((KeTPCR_b_Enbl_SOCCond)
        && (((((VeTPCR_b_SOCRejection_SOC_NoPlugIn) ||
               (VeTPCR_b_SOCRejection_SOC_PlugIn)) ||
              (VeTPCR_b_SOCRejection_SOC_PwrBdgt_NoPlugIn)) ||
             (VeTPCR_b_SOCRejection_SOC_PwrBdgt_PlugIn)) ||
            (VeTPCR_b_SOCReject_BattPrio)))) || ((KeTPCR_b_Enbl_SOCCond_New) &&
        (((((VeTPCR_b_SC_WakeUpReq) || (VeTPCR_b_HCPShutDwnCmd)) ||
           rtb_LogicalOperator_h0) && rtb_AND_gq3) ||
         ((KeTPCR_b_BattPrioritySOCRejct) && (VeTPCR_b_SOCReject_BattPrio)))));

    /* Switch: '<S16>/Switch' incorporates:
     *  Constant: '<S945>/Calib'
     *  Constant: '<S946>/Calib'
     *  Logic: '<S893>/Logical10'
     *  Logic: '<S893>/Logical4'
     *  Logic: '<S893>/Logical5'
     *  Logic: '<S893>/Logical9'
     */
    VeTPCR_b_SOCRejected_AS = (((((!VeTPCR_b_RmtVehStartReq) ||
        (VeTPCR_b_SC_WakeUpReq)) || ((KeTPCR_b_EngOutOfFuelChk) &&
        (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_hq))) ||
        (!KeTPCR_b_NARmtStart_DsblSocChk)) && (VeTPCR_b_SOCRejected));

    /* Logic: '<S99>/Logical3' incorporates:
     *  Constant: '<S146>/Constant'
     *  Constant: '<S149>/Constant1'
     *  Constant: '<S149>/Constant2'
     *  Constant: '<S152>/Calib'
     *  DataStoreRead: '<S149>/StatusByte_HiSpdCANCommBus'
     *  Logic: '<S149>/LogicalOperator'
     *  RelationalOperator: '<S149>/RelationalOperator1'
     *  RelationalOperator: '<S149>/RelationalOperator2'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S99>/Comparison1'
     *  S-Function (sfix_bitop): '<S149>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S149>/BitwiseOperator2'
     *  Switch: '<S1760>/Switch'
     */
    VeTPCR_b_CANCOff_SNA = (((((((sint32)TPCR_ac_DW.StatusByte_HiSpdCANCommBus)
        & 1) > 0) && ((((uint32)TPCR_ac_DW.StatusByte_HiSpdCANCommBus) & 64U) ==
                      0U)) && (((uint32)VeTPCR_e_PMM_PowerMode_AD) ==
        CeSSDR_e_KeyOff)) && (KeTPCR_b_Enbl_CANCOff_SNA));

    /* Logic: '<S99>/Logical5' incorporates:
     *  Constant: '<S147>/Constant'
     *  Constant: '<S150>/Constant1'
     *  Constant: '<S150>/Constant2'
     *  Constant: '<S154>/Calib'
     *  DataStoreRead: '<S150>/StatusByte_LostCommBCM'
     *  Logic: '<S150>/LogicalOperator'
     *  RelationalOperator: '<S150>/RelationalOperator1'
     *  RelationalOperator: '<S150>/RelationalOperator2'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S99>/Comparison4'
     *  S-Function (sfix_bitop): '<S150>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S150>/BitwiseOperator2'
     *  Switch: '<S1760>/Switch'
     */
    VeTPCR_b_LOCBCM_SNA = (((((((sint32)TPCR_ac_DW.StatusByte_LostCommBCM) & 1) >
        0) && ((((uint32)TPCR_ac_DW.StatusByte_LostCommBCM) & 64U) == 0U)) &&
                            (((uint32)VeTPCR_e_PMM_PowerMode_AD) ==
        CeSSDR_e_KeyOff)) && (KeTPCR_b_Enbl_LOCBCM_SNA));

    /* Logic: '<S99>/Logical1' incorporates:
     *  Constant: '<S145>/Constant'
     *  Constant: '<S153>/Calib'
     *  Logic: '<S8>/Logical1'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S99>/Comparison2'
     *  Switch: '<S1760>/Switch'
     */
    VeTPCR_b_KeySts_SNA = ((rtb_LogicalOperator_h0 && (((uint32)
        VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff)) &&
                           (KeTPCR_b_Enbl_KeySt_SNA));

    /* Logic: '<S99>/Logical2' incorporates:
     *  Constant: '<S148>/Constant'
     *  Constant: '<S151>/Calib'
     *  RelationalOperator: '<S99>/Comparison3'
     *  Switch: '<S1764>/Switch'
     */
    VeTPCR_b_BCMPrecReq_SNA = ((((uint32)VeTPCR_e_BCMPreCondCabinReq) ==
        CePLTR_e_CPCSNA) && (KeTPCR_b_Enbl_BCMPrecSNA));

    /* Logic: '<S99>/Logical4' */
    VeTPCC_b_RS_NoCabPrecond_SNA = ((((VeTPCR_b_CANCOff_SNA) ||
        (VeTPCR_b_LOCBCM_SNA)) || (VeTPCR_b_KeySts_SNA)) ||
        (VeTPCR_b_BCMPrecReq_SNA));

    /* Logic: '<S194>/Logical12' incorporates:
     *  Constant: '<S1118>/Calib'
     *  Logic: '<S1023>/Logical1'
     *  Logic: '<S1023>/Logical3'
     */
    rtb_NotEqual_p = (((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_a0) ||
                       (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_m3)) &&
                      (KeTPCR_b_EnblAmbFA_SC));

    /* Outputs for Atomic SubSystem: '<S1117>/EdgeRising1' */
    /* Logic: '<S1177>/OR1' incorporates:
     *  UnitDelay: '<S1177>/UnitDelay'
     */
    rtb_Comparison1_pa = !TPCR_ac_DW.UnitDelay_DSTATE_dn;

    /* Update for UnitDelay: '<S1177>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_dn = VeTPCC_b_VhclPlgdIn;

    /* End of Outputs for SubSystem: '<S1117>/EdgeRising1' */

    /* RelationalOperator: '<S1117>/RelationalOperator' incorporates:
     *  Constant: '<S1174>/Constant'
     *  Switch: '<S1778>/Switch1'
     */
    rtb_RelationalOperator_k = (((uint32)VeTPCR_e_ClimateScheduleOption) ==
        CeCITR_e_AnyTime);

    /* Outputs for Atomic SubSystem: '<S1117>/TurnOnDelayTime' */
    /* Outputs for Atomic SubSystem: '<S1208>/EdgeRising' */
    /* Logic: '<S1211>/AND' incorporates:
     *  Logic: '<S1211>/OR1'
     *  UnitDelay: '<S1211>/Unit Delay'
     */
    rtb_Switch1_cs = (rtb_RelationalOperator_k &&
                      (!TPCR_ac_DW.UnitDelay_DSTATE_bb));

    /* Update for UnitDelay: '<S1211>/Unit Delay' */
    TPCR_ac_DW.UnitDelay_DSTATE_bb = rtb_RelationalOperator_k;

    /* End of Outputs for SubSystem: '<S1208>/EdgeRising' */

    /* Logic: '<S1208>/OR1' incorporates:
     *  Logic: '<S1208>/AND'
     */
    VeTPCR_b_DoorAjarEnblLtch_Rst_t = !rtb_RelationalOperator_k;

    /* Switch: '<S1208>/Switch1' incorporates:
     *  Logic: '<S1208>/OR'
     *  Logic: '<S1208>/OR1'
     */
    if (VeTPCR_b_DoorAjarEnblLtch_Rst_t || rtb_Switch1_cs)
    {
        /* Switch: '<S1208>/Switch1' incorporates:
         *  Constant: '<S1208>/Constant Value1'
         */
        rtb_Switch1_l4 = 0.0F;
    }
    else
    {
        /* Switch: '<S1208>/Switch1' incorporates:
         *  Constant: '<S1198>/Calib'
         *  Constant: '<S1199>/Calib'
         *  MinMax: '<S1208>/Minimum'
         *  Sum: '<S1208>/Summation'
         *  UnitDelay: '<S1208>/Unit Delay'
         */
        rtb_Switch1_l4 = fminf(KeTPCR_t_ClmSchOpt_Dbnc, KeTPCR_t_ClmSchOpt_dT +
                               TPCR_ac_DW.UnitDelay_DSTATE_e);
    }

    /* End of Switch: '<S1208>/Switch1' */

    /* Update for UnitDelay: '<S1208>/Unit Delay' */
    TPCR_ac_DW.UnitDelay_DSTATE_e = rtb_Switch1_l4;

    /* Outputs for Atomic SubSystem: '<S1117>/SignalLatchOnWithReset1' */
    /* Outputs for Atomic SubSystem: '<S1117>/EdgeRising1' */
    /* Logic: '<S1204>/OR1' incorporates:
     *  Constant: '<S1172>/Constant'
     *  Constant: '<S1173>/Constant'
     *  Constant: '<S1187>/Calib'
     *  Constant: '<S1189>/Calib'
     *  Constant: '<S1192>/Calib'
     *  Constant: '<S1198>/Calib'
     *  Constant: '<S1200>/Calib'
     *  Logic: '<S1117>/Logical17'
     *  Logic: '<S1117>/Logical19'
     *  Logic: '<S1117>/LogicalOperator'
     *  Logic: '<S1117>/LogicalOperator1'
     *  Logic: '<S1177>/AND'
     *  Logic: '<S1204>/NOT'
     *  Logic: '<S1204>/OR'
     *  Logic: '<S1208>/AND'
     *  RelationalOperator: '<S1117>/Comparison11'
     *  RelationalOperator: '<S1117>/Comparison12'
     *  RelationalOperator: '<S1117>/Comparison2'
     *  RelationalOperator: '<S1117>/RelationalOperator'
     *  RelationalOperator: '<S1208>/Greater  Than'
     *  Switch: '<S1778>/Switch1'
     *  UnitDelay: '<S1204>/UnitDelay'
     */
    rtb_Comparison1_pa = ((((((uint32)VeTPCR_e_ClimateScheduleOption) ==
        CeCITR_e_PluggedInOnly) && VeTPCR_b_UnplugNoBattCond_SOC_t) &&
                           (KeTPCR_b_Enbl_ClmSchOptn_PrecNotSup)) ||
                          ((((((((uint32)VeTPCR_e_ClimateScheduleOption) !=
        CeCITR_e_PluggedInOnly) || (VeTPCR_b_UnplugNoBattCond_SOC_t ||
        (!rtb_Comparison1_pa))) || (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx <
        KeTPCR_t_PlugInDepTmChk)) || (!KeTPCR_b_EnblPlugIn_RstPrecNotSup)) &&
                            ((VeTPCR_b_DoorAjarEnblLtch_Rst_t || (rtb_Switch1_l4
        < KeTPCR_t_ClmSchOpt_Dbnc)) || (!KeTPCR_b_EnblClmSchOptn_RstPrecNotSup)))
                           && (TPCR_ac_DW.UnitDelay_DSTATE_hy)));

    /* End of Outputs for SubSystem: '<S1117>/EdgeRising1' */
    /* End of Outputs for SubSystem: '<S1117>/TurnOnDelayTime' */

    /* Update for UnitDelay: '<S1204>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_hy = rtb_Comparison1_pa;

    /* End of Outputs for SubSystem: '<S1117>/SignalLatchOnWithReset1' */

    /* Switch: '<S1114>/Switch' incorporates:
     *  Constant: '<S1114>/TRUEConstant'
     *  Constant: '<S1136>/Calib'
     *  RelationalOperator: '<S1114>/Comparison2'
     */
    if (rtb_NotEqual_p)
    {
        rtb_OR1_ksz = true;
    }
    else
    {
        rtb_OR1_ksz = (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx >=
                       KeTPCR_t_ShortPreCondTmr);
    }

    /* End of Switch: '<S1114>/Switch' */

    /* Logic: '<S1114>/Logical6' incorporates:
     *  Logic: '<S102>/Logical9'
     *  Logic: '<S104>/Logical9'
     *  Logic: '<S1115>/Logical6'
     *  Logic: '<S1116>/Logical6'
     *  Logic: '<S95>/Logical9'
     *  Logic: '<S96>/Logical9'
     *  Logic: '<S97>/Logical10'
     *  Switch: '<S1116>/Switch'
     */
    rtb_UnitDelay4_k = !VeTPCR_b_SOCRejected_AS;

    /* Logic: '<S1114>/Logical4' incorporates:
     *  Logic: '<S1016>/Logical1'
     *  Logic: '<S1016>/Logical7'
     *  Logic: '<S1018>/Logical2'
     *  Logic: '<S1018>/Logical7'
     *  Logic: '<S1115>/Logical4'
     *  Logic: '<S1116>/Logical4'
     *  Logic: '<S1117>/Logical3'
     *  Switch: '<S1016>/Switch1'
     *  Switch: '<S1018>/Switch2'
     */
    rtb_LogicalOperator1_c = !rtb_LogicalOperator_h0;

    /* Logic: '<S1114>/Logical19' incorporates:
     *  Logic: '<S1115>/Logical21'
     *  Logic: '<S1116>/Logical19'
     */
    VeTPCR_b_SetLongTimerCond_tmp = !rtb_Comparison1_pa;

    /* Logic: '<S1114>/Logical5' incorporates:
     *  Constant: '<S1125>/Constant'
     *  Constant: '<S1126>/Constant'
     *  Constant: '<S1127>/Calib'
     *  Constant: '<S1128>/Calib'
     *  Constant: '<S1129>/Calib'
     *  Constant: '<S1130>/Calib'
     *  Constant: '<S1131>/Calib'
     *  Constant: '<S1132>/Calib'
     *  Constant: '<S1133>/Calib'
     *  Constant: '<S1134>/Calib'
     *  Constant: '<S1135>/Calib'
     *  Logic: '<S1114>/Logical1'
     *  Logic: '<S1114>/Logical10'
     *  Logic: '<S1114>/Logical11'
     *  Logic: '<S1114>/Logical13'
     *  Logic: '<S1114>/Logical14'
     *  Logic: '<S1114>/Logical19'
     *  Logic: '<S1114>/Logical2'
     *  Logic: '<S1114>/Logical20'
     *  Logic: '<S1114>/Logical3'
     *  Logic: '<S1114>/Logical4'
     *  Logic: '<S1114>/Logical6'
     *  Logic: '<S1114>/Logical7'
     *  Logic: '<S1114>/Logical9'
     *  RelationalOperator: '<S1114>/Comparison1'
     *  RelationalOperator: '<S1114>/Comparison4'
     *  RelationalOperator: '<S1114>/Comparison6'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S612>/Comparison5'
     *  Switch: '<S1760>/Switch'
     *  Switch: '<S1775>/Switch'
     */
    VeTPCR_b_SetLongTimerCond = ((((((((((((VeTPCC_b_VhclPlgdIn) &&
        (KeTPCR_b_Enbl_PlugInChkPrec_LngTmr)) || ((VeTPCR_b_HCPShutDwnCmd) &&
        (KeTPCR_b_Dsbl_ShtDwnCmdChkPrec_LngTmr))) || ((VeTPCR_b_12VPwup) &&
        (KeTPCR_b_Enbl_12VPWup_LngTmr))) && ((((uint32)VeTPCR_e_PMM_PowerMode_AD)
        == CeSSDR_e_KeyOff) || (KeTPCR_b_Dsbl_KeyStsChkPrec_LngTmr))) &&
        (rtb_UnitDelay4_k || (KeTPCR_b_Dsbl_SCChk_LongTmr))) && (rtb_OR1_ksz &&
        (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx != -1))) && (((uint32)
        VeTPCR_e_ShippingMode_AD) != CePLTR_e_ShipingMode_SHIP_MD)) &&
        (KeTPCR_b_EnblPreCond_LongTmr)) && (rtb_LogicalOperator1_c ||
        (KeTPCR_b_Dsbl_RSReq_LngTmr))) && (rtb_VariantMerge_For_Variant__2 ||
        (KeTPCR_b_Dsbl_SCWkUp_LngTmr))) && (VeTPCR_b_SetLongTimerCond_tmp ||
        (KeTPCR_b_Dsbl_ClmSchOptn_LngTmr)));

    /* Logic: '<S1115>/Logical11' incorporates:
     *  Logic: '<S1116>/Logical12'
     */
    rtb_NotEqual_p = !rtb_NotEqual_p;

    /* Logic: '<S1115>/Logical5' incorporates:
     *  Constant: '<S1115>/ConstantValue'
     *  Constant: '<S1138>/Constant'
     *  Constant: '<S1140>/Constant'
     *  Constant: '<S1141>/Calib'
     *  Constant: '<S1142>/Calib'
     *  Constant: '<S1143>/Calib'
     *  Constant: '<S1144>/Calib'
     *  Constant: '<S1145>/Calib'
     *  Constant: '<S1146>/Calib'
     *  Constant: '<S1147>/Calib'
     *  Constant: '<S1148>/Calib'
     *  Constant: '<S1150>/Calib'
     *  Constant: '<S1153>/Calib'
     *  Constant: '<S1154>/Calib'
     *  Logic: '<S1115>/Logical1'
     *  Logic: '<S1115>/Logical11'
     *  Logic: '<S1115>/Logical15'
     *  Logic: '<S1115>/Logical16'
     *  Logic: '<S1115>/Logical17'
     *  Logic: '<S1115>/Logical18'
     *  Logic: '<S1115>/Logical19'
     *  Logic: '<S1115>/Logical2'
     *  Logic: '<S1115>/Logical22'
     *  Logic: '<S1115>/Logical3'
     *  Logic: '<S1115>/Logical7'
     *  Logic: '<S1115>/Logical9'
     *  RelationalOperator: '<S1115>/Comparison1'
     *  RelationalOperator: '<S1115>/Comparison2'
     *  RelationalOperator: '<S1115>/Comparison4'
     *  RelationalOperator: '<S1115>/Comparison6'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S612>/Comparison5'
     *  Switch: '<S1760>/Switch'
     *  Switch: '<S1775>/Switch'
     */
    VeTPCR_b_SetShortTmrCond = (((((((((((((VeTPCR_b_12VPwup) ||
        (KeTPCR_b_Enbl_12VPWup_ShrtTmr)) || ((VeTPCR_b_HCPShutDwnCmd) ||
        (KeTPCR_b_Dsbl_ShtDwnCmdChkPrec_ShrtTmr))) && ((((uint32)
        VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff) ||
        (KeTPCR_b_Dsbl_KeyStsChkPrec_ShrtTmr))) && (rtb_UnitDelay4_k ||
        (KeTPCR_b_Dsbl_SOCChk_ShortTmr))) &&
        (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx < KeTPCR_t_ShortPreCondTmr)) &&
        ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx > 0) ||
         (KeTPCR_b_Dsbl_DepTmNoZero_ShrtTmr))) && (((uint32)
        VeTPCR_e_ShippingMode_AD) != CePLTR_e_ShipingMode_SHIP_MD)) &&
        (KeTPCR_b_EnblPreCond_ShortTmr)) && (rtb_LogicalOperator1_c ||
        (KeTPCR_b_Dsbl_RSReq_ShortTmr))) && (rtb_VariantMerge_For_Variant__2 ||
        (KeTPCR_b_Dsbl_SCWkUp_ShortTmr))) && (rtb_NotEqual_p ||
        (KeTPCR_b_Dsbl_AmbFA_ShortTmr))) && (VeTPCR_b_SetLongTimerCond_tmp ||
        (KeTPCR_b_Dsbl_ClmSchOptn_ShtTmr)));

    /* Outputs for Atomic SubSystem: '<S1115>/EdgeFalling' */
    /* Logic: '<S1139>/AND' incorporates:
     *  UnitDelay: '<S1139>/UnitDelay'
     */
    rtb_OR1_ksz = (VeTPCR_b_BCC_CellUnderTmpChk_tm &&
                   (TPCR_ac_DW.UnitDelay_DSTATE_lt));

    /* Update for UnitDelay: '<S1139>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_lt = VeTPCR_b_HCPShutDwnCmd;

    /* End of Outputs for SubSystem: '<S1115>/EdgeFalling' */

    /* Logic: '<S1115>/Logical12' incorporates:
     *  Constant: '<S1137>/Constant'
     *  Constant: '<S1149>/Calib'
     *  Constant: '<S1151>/Calib'
     *  Constant: '<S1152>/Calib'
     *  Logic: '<S1115>/Logical10'
     *  Logic: '<S1115>/Logical13'
     *  Logic: '<S1115>/Logical14'
     *  RelationalOperator: '<S1115>/Comparison3'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     */
    VeTPCR_b_SetShortTmrCond_Rst = (((rtb_LogicalOperator_h0 &&
        (KeTPCR_b_EnblRSCheck_ShortTmr)) || ((((uint32)VeTPCR_e_PMM_PowerMode_AD)
        != CeSSDR_e_KeyOff) && (KeTPCR_b_EnblKeyOnChk_ShortTmr))) ||
        (rtb_OR1_ksz && (KeTPCR_b_EnblShtDwnCheck_ShortTmr)));

    /* Outputs for Atomic SubSystem: '<S1115>/SignalLatchOnWithReset2' */
    /* Logic: '<S1155>/OR1' incorporates:
     *  Logic: '<S1155>/NOT'
     *  Logic: '<S1155>/OR'
     *  UnitDelay: '<S1155>/UnitDelay'
     */
    VeTPCR_b_SetShortTmrCond_Ltch = ((VeTPCR_b_SetShortTmrCond) ||
        ((!VeTPCR_b_SetShortTmrCond_Rst) && (TPCR_ac_DW.UnitDelay_DSTATE_kk)));

    /* Update for UnitDelay: '<S1155>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_kk = VeTPCR_b_SetShortTmrCond_Ltch;

    /* End of Outputs for SubSystem: '<S1115>/SignalLatchOnWithReset2' */

    /* Switch: '<S1116>/Switch' incorporates:
     *  Constant: '<S1166>/Calib'
     *  Constant: '<S1169>/Calib'
     *  Logic: '<S1116>/Logical11'
     *  Logic: '<S1116>/Logical14'
     *  RelationalOperator: '<S1116>/Comparison3'
     */
    if (((VeTPCR_b_HCPShutDwnCmd) && (KeTPCR_b_EnblShtDwnChk_PlugInSOC)) ||
            (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx < KeTPCR_t_SOCRej_DepTmTh))
    {
        /* Switch: '<S1116>/Switch' incorporates:
         *  Constant: '<S1164>/Calib'
         *  Logic: '<S1116>/Logical3'
         */
        VeTPCR_b_SOCReject_PrecTmr_PlugIn = (rtb_UnitDelay4_k ||
            (KeTPCR_b_Dsbl_SOCChk_PlugIn));
    }
    else
    {
        /* Switch: '<S1116>/Switch' incorporates:
         *  Constant: '<S1116>/TRUEConstant'
         */
        VeTPCR_b_SOCReject_PrecTmr_PlugIn = true;
    }

    /* Logic: '<S1116>/Logical5' incorporates:
     *  Constant: '<S1156>/Constant'
     *  Constant: '<S1157>/Constant'
     *  Constant: '<S1158>/Calib'
     *  Constant: '<S1159>/Calib'
     *  Constant: '<S1160>/Calib'
     *  Constant: '<S1161>/Calib'
     *  Constant: '<S1162>/Calib'
     *  Constant: '<S1163>/Calib'
     *  Constant: '<S1165>/Calib'
     *  Constant: '<S1167>/Calib'
     *  Constant: '<S1168>/Calib'
     *  Constant: '<S1170>/Calib'
     *  Logic: '<S1116>/Logical1'
     *  Logic: '<S1116>/Logical10'
     *  Logic: '<S1116>/Logical13'
     *  Logic: '<S1116>/Logical15'
     *  Logic: '<S1116>/Logical16'
     *  Logic: '<S1116>/Logical17'
     *  Logic: '<S1116>/Logical2'
     *  Logic: '<S1116>/Logical20'
     *  Logic: '<S1116>/Logical7'
     *  Logic: '<S1116>/Logical9'
     *  RelationalOperator: '<S1116>/Comparison1'
     *  RelationalOperator: '<S1116>/Comparison2'
     *  RelationalOperator: '<S1116>/Comparison4'
     *  RelationalOperator: '<S1116>/Comparison6'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S612>/Comparison5'
     *  Switch: '<S1760>/Switch'
     *  Switch: '<S1775>/Switch'
     */
    VeTPCR_b_SetShortTmrCond_PlugIn = ((((((((((((((VeTPCR_b_HCPShutDwnCmd) &&
        (KeTPCR_b_Enbl_ShtDwnCmdChk_PlugIn)) || (VeTPCC_b_VhclPlgdIn)) ||
        ((VeTPCR_b_12VPwup) && (KeTPCR_b_Enbl_12VPWup_PlugIn))) && ((((uint32)
        VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff) ||
        (KeTPCR_b_Dsbl_KeyStsChkPrec_PlugIn))) &&
        (VeTPCR_b_SOCReject_PrecTmr_PlugIn)) &&
        (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx < KeTPCR_t_ShortPreCondTmr)) &&
        ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx > 0) ||
         (KeTPCR_b_Dsbl_DepTmNoZero_PlugIn))) && (((uint32)
        VeTPCR_e_ShippingMode_AD) != CePLTR_e_ShipingMode_SHIP_MD)) &&
        (KeTPCR_b_EnblPreCond_ShortTmrPlugIn)) && (rtb_LogicalOperator1_c ||
        (KeTPCR_b_Dsbl_RSReq_PlugIn))) && (rtb_VariantMerge_For_Variant__2 ||
        (KeTPCR_b_Dsbl_SCWkUp_PlugIn))) && (rtb_NotEqual_p ||
        (KeTPCR_b_Dsbl_AmbFA_PlugIn))) && (VeTPCR_b_SetLongTimerCond_tmp ||
        (KeTPCR_b_Dsbl_ClmSchOptn_ShtTmrPlugIn)));

    /* Outputs for Atomic SubSystem: '<S1117>/TurnOnDelaySample1' */
    /* Outputs for Atomic SubSystem: '<S1207>/EdgeRising' */
    /* Logic: '<S1210>/AND' incorporates:
     *  Logic: '<S1210>/OR1'
     *  UnitDelay: '<S1210>/UnitDelay'
     */
    rtb_NotEqual_p = !TPCR_ac_DW.UnitDelay_DSTATE_kx;

    /* Update for UnitDelay: '<S1210>/UnitDelay' incorporates:
     *  Constant: '<S1117>/TRUEConstant1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_kx = true;

    /* End of Outputs for SubSystem: '<S1207>/EdgeRising' */

    /* Switch: '<S1207>/Switch1' incorporates:
     *  Constant: '<S1181>/Calib'
     *  Constant: '<S1207>/ConstantValue'
     *  Logic: '<S1207>/OR'
     *  MinMax: '<S1207>/Minimum'
     *  Sum: '<S1207>/Summation'
     *  UnitDelay: '<S1207>/UnitDelay'
     */
    if (rtb_NotEqual_p)
    {
        /* Switch: '<S1207>/Switch1' incorporates:
         *  Constant: '<S1207>/ConstantValue1'
         */
        rtb_Switch1_g1 = 0U;
    }
    else if (KeTPCR_Cnt_WakeUpChk_Dly < ((uint16)(((uint32)
                TPCR_ac_DW.UnitDelay_DSTATE_nu) + 1U)))
    {
        /* MinMax: '<S1207>/Minimum' incorporates:
         *  Constant: '<S1181>/Calib'
         *  Switch: '<S1207>/Switch1'
         */
        rtb_Switch1_g1 = KeTPCR_Cnt_WakeUpChk_Dly;
    }
    else
    {
        /* Switch: '<S1207>/Switch1' incorporates:
         *  Constant: '<S1207>/ConstantValue'
         *  MinMax: '<S1207>/Minimum'
         *  Sum: '<S1207>/Summation'
         *  UnitDelay: '<S1207>/UnitDelay'
         */
        rtb_Switch1_g1 = (uint16)(((uint32)TPCR_ac_DW.UnitDelay_DSTATE_nu) + 1U);
    }

    /* End of Switch: '<S1207>/Switch1' */

    /* Logic: '<S1207>/AND' incorporates:
     *  Constant: '<S1181>/Calib'
     *  RelationalOperator: '<S1207>/GreaterThan'
     */
    rtb_NotEqual_p = (rtb_Switch1_g1 >= KeTPCR_Cnt_WakeUpChk_Dly);

    /* Update for UnitDelay: '<S1207>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_nu = rtb_Switch1_g1;

    /* End of Outputs for SubSystem: '<S1117>/TurnOnDelaySample1' */

    /* Outputs for Atomic SubSystem: '<S1117>/EdgeRising2' */
    /* Logic: '<S1178>/OR1' incorporates:
     *  UnitDelay: '<S1178>/UnitDelay'
     */
    rtb_OR1_ksz = !TPCR_ac_DW.UnitDelay_DSTATE_go;

    /* Update for UnitDelay: '<S1178>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_go = rtb_NotEqual_p;

    /* End of Outputs for SubSystem: '<S1117>/EdgeRising2' */

    /* Outputs for Atomic SubSystem: '<S1117>/TurnOnDelaySample' */
    /* Outputs for Atomic SubSystem: '<S1206>/EdgeRising' */
    /* Logic: '<S1209>/AND' incorporates:
     *  Logic: '<S1209>/OR1'
     *  UnitDelay: '<S1209>/UnitDelay'
     */
    rtb_RelationalOperator_k = !TPCR_ac_DW.UnitDelay_DSTATE_jb;

    /* Update for UnitDelay: '<S1209>/UnitDelay' incorporates:
     *  Constant: '<S1117>/TRUEConstant'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_jb = true;

    /* End of Outputs for SubSystem: '<S1206>/EdgeRising' */

    /* Switch: '<S1206>/Switch1' incorporates:
     *  Constant: '<S1180>/Calib'
     *  Constant: '<S1206>/ConstantValue'
     *  Logic: '<S1206>/OR'
     *  MinMax: '<S1206>/Minimum'
     *  Sum: '<S1206>/Summation'
     *  UnitDelay: '<S1206>/UnitDelay'
     */
    if (rtb_RelationalOperator_k)
    {
        /* Switch: '<S1206>/Switch1' incorporates:
         *  Constant: '<S1206>/ConstantValue1'
         */
        rtb_Switch1_g1 = 0U;
    }
    else if (KeTPCR_Cnt_SOCRej_DlyVal < ((uint16)(((uint32)
                TPCR_ac_DW.UnitDelay_DSTATE_lg) + 1U)))
    {
        /* MinMax: '<S1206>/Minimum' incorporates:
         *  Constant: '<S1180>/Calib'
         *  Switch: '<S1206>/Switch1'
         */
        rtb_Switch1_g1 = KeTPCR_Cnt_SOCRej_DlyVal;
    }
    else
    {
        /* Switch: '<S1206>/Switch1' incorporates:
         *  Constant: '<S1206>/ConstantValue'
         *  MinMax: '<S1206>/Minimum'
         *  Sum: '<S1206>/Summation'
         *  UnitDelay: '<S1206>/UnitDelay'
         */
        rtb_Switch1_g1 = (uint16)(((uint32)TPCR_ac_DW.UnitDelay_DSTATE_lg) + 1U);
    }

    /* End of Switch: '<S1206>/Switch1' */

    /* Update for UnitDelay: '<S1206>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_lg = rtb_Switch1_g1;

    /* Outputs for Atomic SubSystem: '<S1117>/EdgeRising2' */
    /* Logic: '<S1117>/Logical5' incorporates:
     *  Constant: '<S1175>/Constant'
     *  Constant: '<S1179>/Constant'
     *  Constant: '<S1180>/Calib'
     *  Constant: '<S1182>/Calib'
     *  Constant: '<S1183>/Calib'
     *  Constant: '<S1184>/Calib'
     *  Constant: '<S1185>/Calib'
     *  Constant: '<S1193>/Calib'
     *  Constant: '<S1194>/Calib'
     *  Constant: '<S1195>/Calib'
     *  Constant: '<S1196>/Calib'
     *  Constant: '<S1201>/Calib'
     *  Constant: '<S1202>/Calib'
     *  Constant: '<S1203>/Calib'
     *  Logic: '<S1117>/Logical1'
     *  Logic: '<S1117>/Logical10'
     *  Logic: '<S1117>/Logical11'
     *  Logic: '<S1117>/Logical2'
     *  Logic: '<S1117>/Logical21'
     *  Logic: '<S1117>/Logical4'
     *  Logic: '<S1117>/Logical6'
     *  Logic: '<S1117>/Logical7'
     *  Logic: '<S1117>/Logical9'
     *  Logic: '<S1117>/LogicalOperator2'
     *  Logic: '<S1117>/LogicalOperator3'
     *  Logic: '<S1117>/LogicalOperator4'
     *  Logic: '<S1178>/AND'
     *  RelationalOperator: '<S1117>/Comparison4'
     *  RelationalOperator: '<S1117>/Comparison6'
     *  RelationalOperator: '<S1117>/RelationalOperator1'
     *  RelationalOperator: '<S1117>/RelationalOperator2'
     *  RelationalOperator: '<S1206>/GreaterThan'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S612>/Comparison5'
     *  Switch: '<S1117>/Switch1'
     *  Switch: '<S1760>/Switch'
     *  Switch: '<S1775>/Switch'
     */
    VeTPCR_b_SCNotSupp_SOCReject = (((((((((((VeTPCC_b_VhclPlgdIn) &&
        (KeTPCR_b_Enbl_PlugInChkPrec_NotSupp)) || ((VeTPCR_b_HCPShutDwnCmd) &&
        (KeTPCR_b_Enbl_ShtDwnCmdChkPrec_NotSupp))) || ((rtb_NotEqual_p &&
        rtb_OR1_ksz) && (KeTPCR_b_Enbl_PrecMsg_WakeUpChk))) && ((((uint32)
        VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff) ||
        (KeTPCR_b_Dsbl_KeyStsChkPrec_PrecNotSup))) && (((rtb_Switch1_g1 >=
        KeTPCR_Cnt_SOCRej_DlyVal) && (VeTPCR_b_SOCRejected_AS)) ||
        rtb_Comparison1_pa)) && ((((((float32)
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx) <= KeTPCR_t_PrecMsgDepTmChk) ||
        (KeTPCR_b_Dsbl_PrecMsg_DepTmChk)) && (((float32)
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx) >=
        KeTPCR_t_PluginDepTm_ZeroChk)) || (KeTPCR_b_Enbl_DepTmSetChk_PrecDsbld)))
        && (((uint32)VeTPCR_e_ShippingMode_AD) != CePLTR_e_ShipingMode_SHIP_MD))
        && (KeTPCR_b_Enbl_PrecDsbld)) && (rtb_LogicalOperator1_c ||
        (KeTPCR_b_Dsbl_RSReq_SOCNotOK))) && (rtb_VariantMerge_For_Variant__2 ||
        (KeTPCR_b_Dsbl_SCWkUp_SOCNotOK)));

    /* End of Outputs for SubSystem: '<S1117>/EdgeRising2' */
    /* End of Outputs for SubSystem: '<S1117>/TurnOnDelaySample' */

    /* Outputs for Atomic SubSystem: '<S1117>/EdgeFalling' */
    /* Logic: '<S1176>/AND' incorporates:
     *  UnitDelay: '<S1176>/UnitDelay'
     */
    rtb_Comparison1_pa = (VeTPCR_b_BCC_CellUnderTmpChk_tm &&
                          (TPCR_ac_DW.UnitDelay_DSTATE_pr));

    /* Update for UnitDelay: '<S1176>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_pr = VeTPCR_b_HCPShutDwnCmd;

    /* End of Outputs for SubSystem: '<S1117>/EdgeFalling' */

    /* Abs: '<S1124>/Abs' incorporates:
     *  Sum: '<S1117>/Sum1'
     *  UnitDelay: '<S1117>/UnitDelay4'
     */
    rtb_Abs_o = (sint16)(TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx -
                         TPCR_ac_DW.UnitDelay4_DSTATE);

    /* Abs: '<S1117>/Abs' */
    if (rtb_Abs_o < 0)
    {
        tmp = -((sint32)rtb_Abs_o);
        if ((-rtb_Abs_o) > 32767)
        {
            tmp = 32767;
        }

        /* Abs: '<S1124>/Abs' */
        rtb_Abs_o = (sint16)tmp;
    }

    /* End of Abs: '<S1117>/Abs' */

    /* Logic: '<S1117>/Logical12' incorporates:
     *  Constant: '<S1171>/Constant'
     *  Constant: '<S1186>/Calib'
     *  Constant: '<S1188>/Calib'
     *  Constant: '<S1190>/Calib'
     *  Constant: '<S1191>/Calib'
     *  Constant: '<S1197>/Calib'
     *  Logic: '<S1117>/Logical13'
     *  Logic: '<S1117>/Logical14'
     *  Logic: '<S1117>/Logical15'
     *  Logic: '<S1117>/Logical16'
     *  RelationalOperator: '<S1117>/Comparison1'
     *  RelationalOperator: '<S1117>/Comparison7'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     */
    VeTPCR_b_SCNotSupp_SOCReject_Rst = ((((rtb_LogicalOperator_h0 &&
        (KeTPCR_b_EnblRSCheck_PlugIn)) || ((((uint32)VeTPCR_e_PMM_PowerMode_AD)
        != CeSSDR_e_KeyOff) && (KeTPCR_b_EnblKeyOnChk_PlugIn))) ||
        (rtb_Comparison1_pa && (KeTPCR_b_EnblShtDwnCheck_PlugIn))) ||
        ((rtb_Abs_o >= KeTPCR_t_ChngInDepTmTh) &&
         (KeTPCR_b_EnblChngInDepTm_PlugIn)));

    /* Outputs for Atomic SubSystem: '<S1117>/SignalLatchOnWithReset2' */
    /* Logic: '<S1205>/OR1' incorporates:
     *  Logic: '<S1205>/NOT'
     *  Logic: '<S1205>/OR'
     *  UnitDelay: '<S1205>/UnitDelay'
     */
    VeTPCR_b_SCNotSupp_SOCReject_Ltch = ((VeTPCR_b_SCNotSupp_SOCReject) ||
        ((!VeTPCR_b_SCNotSupp_SOCReject_Rst) && (TPCR_ac_DW.UnitDelay_DSTATE_mk)));

    /* Update for UnitDelay: '<S1205>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_mk = VeTPCR_b_SCNotSupp_SOCReject_Ltch;

    /* End of Outputs for SubSystem: '<S1117>/SignalLatchOnWithReset2' */

    /* If: '<S1023>/If1' */
    if (VeTPCR_b_SetLongTimerCond)
    {
        /* Outputs for IfAction SubSystem: '<S1023>/PreCond_LongTmr_HCPWup' incorporates:
         *  ActionPort: '<S1119>/ActionPort'
         */
        /* Switch: '<S1119>/Switch' incorporates:
         *  Constant: '<S1214>/Calib'
         *  Sum: '<S1119>/Sum2'
         */
        rtb_Abs_o = (sint16)(TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx -
                             KeTPCR_t_PrecTmr_LongDT);

        /* Sum: '<S1119>/Sum1' */
        VeTPCR_t_Long_PrecWkUpTmr_B4Sw = (sint16)
            (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx - rtb_Abs_o);

        /* Switch: '<S1119>/Switch' incorporates:
         *  Constant: '<S1215>/Calib'
         *  RelationalOperator: '<S1119>/Comparison2'
         */
        if (rtb_Abs_o <= KeTPCR_t_PrecTmr_MinTh)
        {
            /* Merge: '<S1023>/Merge' incorporates:
             *  Constant: '<S1216>/Calib'
             *  Gain: '<S1219>/Gain'
             */
            VeTPCR_t_PrecTmr_AftrMrg = KeTPCR_t_PrecTmr_MinWkUpTmr;
        }
        else
        {
            /* Merge: '<S1023>/Merge' incorporates:
             *  Gain: '<S1219>/Gain'
             */
            VeTPCR_t_PrecTmr_AftrMrg = VeTPCR_t_Long_PrecWkUpTmr_B4Sw;
        }

        /* End of Switch: '<S1119>/Switch' */

        /* Merge: '<S1023>/Merge2' incorporates:
         *  Constant: '<S1119>/ConstantValue1'
         *  SignalConversion generated from: '<S1119>/NoPreCond_Msg'
         */
        VeTPCR_b_PrecWarningMsg_AftrMrg = false;

        /* Outputs for Atomic SubSystem: '<S1119>/TurnOnDelayTime' */
        /* Outputs for Atomic SubSystem: '<S1220>/EdgeRising' */
        /* Logic: '<S1221>/AND' incorporates:
         *  Constant: '<S1213>/Calib'
         *  Logic: '<S1221>/OR1'
         *  UnitDelay: '<S1221>/UnitDelay'
         */
        rtb_Comparison1_pa = ((KeTPCR_b_RdyForShtDwn_PrecLongTmr) &&
                              (!TPCR_ac_DW.UnitDelay_DSTATE_n5));

        /* Update for UnitDelay: '<S1221>/UnitDelay' incorporates:
         *  Constant: '<S1213>/Calib'
         */
        TPCR_ac_DW.UnitDelay_DSTATE_n5 = KeTPCR_b_RdyForShtDwn_PrecLongTmr;

        /* End of Outputs for SubSystem: '<S1220>/EdgeRising' */

        /* Switch: '<S1220>/Switch1' incorporates:
         *  Constant: '<S1213>/Calib'
         *  Logic: '<S1220>/OR'
         *  Logic: '<S1220>/OR1'
         */
        if ((!KeTPCR_b_RdyForShtDwn_PrecLongTmr) || rtb_Comparison1_pa)
        {
            /* Switch: '<S1220>/Switch1' incorporates:
             *  Constant: '<S1220>/ConstantValue1'
             */
            rtb_Switch1_l4 = 0.0F;
        }
        else
        {
            /* Switch: '<S1220>/Switch1' incorporates:
             *  Constant: '<S1217>/Calib'
             *  Constant: '<S1218>/Calib'
             *  MinMax: '<S1220>/Minimum'
             *  Sum: '<S1220>/Summation'
             *  UnitDelay: '<S1220>/UnitDelay'
             */
            rtb_Switch1_l4 = fminf(KeTPCR_t_RdyForShtDwn_PreCondDly,
                                   KeTPCR_t_RS_CabPrec_dT +
                                   TPCR_ac_DW.UnitDelay_DSTATE_i);
        }

        /* End of Switch: '<S1220>/Switch1' */

        /* Logic: '<S1220>/AND' incorporates:
         *  Constant: '<S1213>/Calib'
         *  Constant: '<S1218>/Calib'
         *  RelationalOperator: '<S1220>/GreaterThan'
         */
        VeTPCR_b_RdyForShtDwn_LongWkUp = ((KeTPCR_b_RdyForShtDwn_PrecLongTmr) &&
            (rtb_Switch1_l4 >= KeTPCR_t_RdyForShtDwn_PreCondDly));

        /* Update for UnitDelay: '<S1220>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_i = rtb_Switch1_l4;

        /* End of Outputs for SubSystem: '<S1119>/TurnOnDelayTime' */

        /* Merge: '<S1023>/Merge3' incorporates:
         *  Logic: '<S1212>/AND'
         */
        VeTPCR_b_PrecRdyForShtDwn_AftrMrg = VeTPCR_b_RdyForShtDwn_LongWkUp;

        /* Merge: '<S1023>/Merge1' incorporates:
         *  Constant: '<S1119>/ConstantValue2'
         *  SignalConversion generated from: '<S1119>/FOTAReject'
         */
        VeTPCR_b_FOTAReject_AftrMrg = false;

        /* End of Outputs for SubSystem: '<S1023>/PreCond_LongTmr_HCPWup' */
    }
    else if (VeTPCR_b_SetShortTmrCond_Ltch)
    {
        /* Outputs for IfAction SubSystem: '<S1023>/PreCond_ShortTmr_NMWup' incorporates:
         *  ActionPort: '<S1120>/ActionPort'
         */
        /* Outputs for Atomic SubSystem: '<S1223>/ProtectedDivision' */
        /* Switch: '<S1245>/Switch1' incorporates:
         *  Constant: '<S1232>/Calib'
         *  Constant: '<S1245>/ConstantValue'
         *  Constant: '<S1245>/ConstantValue2'
         *  Constant: '<S1245>/ConstantValue3'
         *  RelationalOperator: '<S1245>/GreaterThanorEqual'
         *  RelationalOperator: '<S1245>/GreaterThanorEqual1'
         *  RelationalOperator: '<S1245>/NotEqual'
         *  Switch: '<S1245>/Switch2'
         *  Switch: '<S1245>/Switch3'
         */
        if (KeTPCR_cmp_VehSoakRate != 0.0F)
        {
            /* Switch: '<S1245>/Switch1' incorporates:
             *  Constant: '<S1223>/ConstantValue'
             *  Product: '<S1245>/Division'
             */
            rtb_Switch1_l4 = KeTPCR_cmp_VehSoakRate / 60.0F;
        }
        else if (KeTPCR_cmp_VehSoakRate > 0.0F)
        {
            /* Switch: '<S1245>/Switch2' incorporates:
             *  Constant: '<S1245>/MAXFLOAT'
             *  Switch: '<S1245>/Switch1'
             */
            rtb_Switch1_l4 = 3.402823466E+38F;
        }
        else if (KeTPCR_cmp_VehSoakRate < 0.0F)
        {
            /* Switch: '<S1245>/Switch3' incorporates:
             *  Constant: '<S1245>/MINFLOAT'
             *  Switch: '<S1245>/Switch1'
             *  Switch: '<S1245>/Switch2'
             */
            rtb_Switch1_l4 = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1245>/Switch1' incorporates:
             *  Constant: '<S1245>/ConstantValue4'
             *  Switch: '<S1245>/Switch2'
             *  Switch: '<S1245>/Switch3'
             */
            rtb_Switch1_l4 = 0.0F;
        }

        /* End of Switch: '<S1245>/Switch1' */
        /* End of Outputs for SubSystem: '<S1223>/ProtectedDivision' */

        /* Lookup_n-D: '<S1242>/Vector' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         *  Switch: '<S1770>/Switch'
         */
        rtb_Switch1_ml1 = look2_iflf_binlcapw
            (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d, VeTPCR_P_PwrBdgtAvail,
             ((const float32 *)&(KxTPCR_cmp_CabCond_SPRt[0])), ((const float32 *)
              &(KyTPCR_cmp_CabCond_SPRt[0])), ((const float32 *)
              &(KtTPCR_cmp_CabCond_SPRt[0])), TPCR_ac_ConstP.pooled10, 7U);

        /* Outputs for Atomic SubSystem: '<S1223>/ProtectedDivision1' */
        /* Switch: '<S1246>/Switch1' incorporates:
         *  Constant: '<S1246>/ConstantValue'
         *  RelationalOperator: '<S1246>/NotEqual'
         */
        if (rtb_Switch1_ml1 != 0.0F)
        {
            /* Switch: '<S1246>/Switch1' incorporates:
             *  Constant: '<S1223>/ConstantValue1'
             *  Product: '<S1246>/Division'
             */
            rtb_Switch1_ml1 /= 60.0F;
        }
        else
        {
            /* Switch: '<S1246>/Switch1' incorporates:
             *  Constant: '<S1246>/ConstantValue4'
             *  Switch: '<S1246>/Switch2'
             *  Switch: '<S1246>/Switch3'
             */
            rtb_Switch1_ml1 = 0.0F;
        }

        /* End of Switch: '<S1246>/Switch1' */
        /* End of Outputs for SubSystem: '<S1223>/ProtectedDivision1' */

        /* MATLAB Function: '<S1223>/MATLABFunction' incorporates:
         *  Constant: '<S1223>/ConstantValue2'
         *  Constant: '<S1233>/Calib'
         *  Constant: '<S1234>/Calib'
         *  Constant: '<S1241>/Calib'
         *  Product: '<S1223>/Product3'
         */
        TPCR_ac_MATLABFunction(TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx,
                               TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d,
                               TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_b,
                               VeTPCR_T_CabSP, rtb_Switch1_l4, rtb_Switch1_ml1,
                               (sint16)(KeTPCR_t_SCDfltTime * 60),
                               KeTPCR_k_SCCTimerCalcErr,
                               KeTPCR_k_SCCTimerCalcIter,
                               &TPCR_ac_B.sf_MATLABFunction);

        /* Gain: '<S1248>/Gain' */
        VeTPCR_t_CondTime_ShortDepTm_SF = TPCR_ac_B.sf_MATLABFunction.Cond_Time;

        /* MinMax: '<S1223>/MinMax1' incorporates:
         *  Constant: '<S1236>/Calib'
         */
        if (KeTPCR_t_MinSchPrecTime > VeTPCR_t_CondTime_ShortDepTm_SF)
        {
            /* MinMax: '<S1223>/MinMax1' */
            rtb_Abs_o = KeTPCR_t_MinSchPrecTime;
        }
        else
        {
            /* MinMax: '<S1223>/MinMax1' */
            rtb_Abs_o = VeTPCR_t_CondTime_ShortDepTm_SF;
        }

        /* End of MinMax: '<S1223>/MinMax1' */

        /* Outputs for Atomic SubSystem: '<S1223>/LeftOpenInterval' */
        /* Switch: '<S1230>/Switch1' incorporates:
         *  Constant: '<S1239>/Calib'
         *  Constant: '<S1240>/Calib'
         *  Logic: '<S1243>/LogicalOperator'
         *  RelationalOperator: '<S1243>/RelatonalOperator'
         *  RelationalOperator: '<S1243>/RelatonalOperator1'
         */
        if ((rtb_Abs_o > KeTPCR_t_SCCTmrMinInterval) && (rtb_Abs_o <=
                KeTPCR_t_SCCTmrMaxInterval))
        {
            /* Switch: '<S1230>/Switch1' */
            VeTPCR_t_CondTime_AtShortDepTm = rtb_Abs_o;
        }
        else
        {
            /* Switch: '<S1230>/Switch1' incorporates:
             *  Constant: '<S1238>/Calib'
             */
            VeTPCR_t_CondTime_AtShortDepTm = KeTPCR_t_SCCRejectionDfltTmr;
        }

        /* End of Switch: '<S1230>/Switch1' */
        /* End of Outputs for SubSystem: '<S1223>/LeftOpenInterval' */

        /* UnitDelay: '<S1252>/UnitDelay' incorporates:
         *  Constant: '<S1228>/Constant'
         *  Constant: '<S1229>/Constant'
         *  Constant: '<S1235>/Calib'
         *  Logic: '<S1223>/LogicalOperator'
         *  Logic: '<S1223>/LogicalOperator1'
         *  Logic: '<S1223>/LogicalOperator2'
         *  RelationalOperator: '<S1223>/Comparison'
         *  RelationalOperator: '<S1223>/Comparison1'
         *  RelationalOperator: '<S1223>/Comparison4'
         *  RelationalOperator: '<S519>/Comparison12'
         *  Sum: '<S1223>/Sum'
         *  Switch: '<S1763>/Switch1'
         */
        rtb_Comparison1_pa = ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx <=
                               ((sint16)(VeTPCR_t_CondTime_AtShortDepTm +
            KeTPCR_t_FOTARunTm))) && ((((uint32)VeTPCR_e_FOTAInstallType) ==
                                CeCITR_e_FOTANow) || (((uint32)
            VeTPCR_e_FOTAInstallType) == CeCITR_e_FOTASchedule)));

        /* Switch: '<S1231>/Switch1' */
        if (rtb_Comparison1_pa)
        {
            /* Merge: '<S1023>/Merge' incorporates:
             *  Constant: '<S1237>/Calib'
             */
            VeTPCR_t_PrecTmr_AftrMrg = KeTPCR_t_SCCFOTARejectTmr;
        }
        else
        {
            /* Merge: '<S1023>/Merge' */
            VeTPCR_t_PrecTmr_AftrMrg = VeTPCR_t_CondTime_AtShortDepTm;
        }

        /* End of Switch: '<S1231>/Switch1' */

        /* Gain: '<S1247>/Gain' */
        VeTPCR_t_WupTimer_Short = TPCR_ac_B.sf_MATLABFunction.Wup_Timer;

        /* Merge: '<S1023>/Merge1' incorporates:
         *  Gain: '<S1249>/Gain'
         */
        VeTPCR_b_FOTAReject_AftrMrg = rtb_Comparison1_pa;

        /* Gain: '<S1250>/Gain' */
        VeTPCR_Cnt_WupTimer_Dbg =
            TPCR_ac_B.sf_MATLABFunction.LeTPCR_e_Debug_TmrSrc;

        /* Gain: '<S1251>/Gain' */
        VeTPCR_Cnt_SCTimer_Iteration = TPCR_ac_B.sf_MATLABFunction.Iteration;

        /* Merge: '<S1023>/Merge2' incorporates:
         *  Constant: '<S1120>/ConstantValue1'
         *  SignalConversion generated from: '<S1120>/NoPreCond_Msg'
         */
        VeTPCR_b_PrecWarningMsg_AftrMrg = false;

        /* Outputs for Atomic SubSystem: '<S1120>/TurnOnDelayTime' */
        /* Outputs for Atomic SubSystem: '<S1227>/EdgeRising' */
        /* Logic: '<S1252>/AND' incorporates:
         *  Constant: '<S1224>/Calib'
         *  Logic: '<S1252>/OR1'
         *  UnitDelay: '<S1252>/UnitDelay'
         */
        rtb_Comparison1_pa = ((KeTPCR_b_RdyForShtDwn_PrecShortTmr) &&
                              (!TPCR_ac_DW.UnitDelay_DSTATE_e4p));

        /* Update for UnitDelay: '<S1252>/UnitDelay' incorporates:
         *  Constant: '<S1224>/Calib'
         */
        TPCR_ac_DW.UnitDelay_DSTATE_e4p = KeTPCR_b_RdyForShtDwn_PrecShortTmr;

        /* End of Outputs for SubSystem: '<S1227>/EdgeRising' */

        /* Switch: '<S1227>/Switch1' incorporates:
         *  Constant: '<S1224>/Calib'
         *  Logic: '<S1227>/OR'
         *  Logic: '<S1227>/OR1'
         */
        if ((!KeTPCR_b_RdyForShtDwn_PrecShortTmr) || rtb_Comparison1_pa)
        {
            /* Switch: '<S1227>/Switch1' incorporates:
             *  Constant: '<S1227>/ConstantValue1'
             */
            rtb_Switch1_l4 = 0.0F;
        }
        else
        {
            /* Switch: '<S1227>/Switch1' incorporates:
             *  Constant: '<S1225>/Calib'
             *  Constant: '<S1226>/Calib'
             *  MinMax: '<S1227>/Minimum'
             *  Sum: '<S1227>/Summation'
             *  UnitDelay: '<S1227>/UnitDelay'
             */
            rtb_Switch1_l4 = fminf(KeTPCR_t_RdyForShtDwn_PrecShrtTmrDly,
                                   KeTPCR_t_RS_CabPrec_dT +
                                   TPCR_ac_DW.UnitDelay_DSTATE_n);
        }

        /* End of Switch: '<S1227>/Switch1' */

        /* Logic: '<S1227>/AND' incorporates:
         *  Constant: '<S1224>/Calib'
         *  Constant: '<S1226>/Calib'
         *  RelationalOperator: '<S1227>/GreaterThan'
         */
        VeTPCR_b_RdyForShtDwn_AtShortDepTm =
            ((KeTPCR_b_RdyForShtDwn_PrecShortTmr) && (rtb_Switch1_l4 >=
              KeTPCR_t_RdyForShtDwn_PrecShrtTmrDly));

        /* Update for UnitDelay: '<S1227>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_n = rtb_Switch1_l4;

        /* End of Outputs for SubSystem: '<S1120>/TurnOnDelayTime' */

        /* Merge: '<S1023>/Merge3' incorporates:
         *  Logic: '<S1222>/AND'
         */
        VeTPCR_b_PrecRdyForShtDwn_AftrMrg = VeTPCR_b_RdyForShtDwn_AtShortDepTm;

        /* End of Outputs for SubSystem: '<S1023>/PreCond_ShortTmr_NMWup' */
    }
    else if (VeTPCR_b_SetShortTmrCond_PlugIn)
    {
        /* Outputs for IfAction SubSystem: '<S1023>/PreCond_ShortTmr_PlugIn' incorporates:
         *  ActionPort: '<S1121>/ActionPort'
         */
        /* RelationalOperator: '<S1258>/Comparison1' incorporates:
         *  Constant: '<S1258>/ConstantValue'
         */
        VeTPCR_b_NonZeroDepTm = (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx != 0);

        /* Outputs for Atomic SubSystem: '<S1258>/EdgeRising5' */
        /* Logic: '<S1267>/AND' incorporates:
         *  Logic: '<S1267>/OR1'
         *  UnitDelay: '<S1267>/UnitDelay'
         */
        VeTPCR_b_NonZeroDepTm_Trig = ((VeTPCR_b_NonZeroDepTm) &&
            (!TPCR_ac_DW.UnitDelay_DSTATE_o2));

        /* Update for UnitDelay: '<S1267>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_o2 = VeTPCR_b_NonZeroDepTm;

        /* End of Outputs for SubSystem: '<S1258>/EdgeRising5' */

        /* Abs: '<S1258>/Abs' incorporates:
         *  Sum: '<S1258>/Sum1'
         *  UnitDelay: '<S1258>/UnitDelay4'
         */
        rtb_Abs_o = (sint16)(TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx -
                             TPCR_ac_DW.UnitDelay4_DSTATE_f);

        /* Abs: '<S1258>/Abs' */
        if (rtb_Abs_o < 0)
        {
            tmp = -((sint32)rtb_Abs_o);
            if ((-rtb_Abs_o) > 32767)
            {
                tmp = 32767;
            }

            /* Abs: '<S1258>/Abs' */
            rtb_Abs_o = (sint16)tmp;
        }

        /* End of Abs: '<S1258>/Abs' */

        /* RelationalOperator: '<S1258>/Comparison3' incorporates:
         *  Constant: '<S1268>/Calib'
         */
        VeTPCR_b_ChngInDepTm = (rtb_Abs_o >= KeTPCR_t_ChngInDepTmTh);

        /* Outputs for Atomic SubSystem: '<S1258>/EdgeRising1' */
        /* Logic: '<S1266>/AND' incorporates:
         *  Logic: '<S1266>/OR1'
         *  UnitDelay: '<S1266>/UnitDelay'
         */
        VeTPCR_b_TrigTm_PlugIn = !TPCR_ac_DW.UnitDelay_DSTATE_e4;

        /* Update for UnitDelay: '<S1266>/UnitDelay' incorporates:
         *  Constant: '<S1258>/TRUEConstant'
         */
        TPCR_ac_DW.UnitDelay_DSTATE_e4 = true;

        /* End of Outputs for SubSystem: '<S1258>/EdgeRising1' */

        /* Logic: '<S1258>/Logical3' incorporates:
         *  Constant: '<S1258>/ConstantValue1'
         *  RelationalOperator: '<S1258>/Comparison2'
         */
        VeTPCR_b_DepTmTrig = ((((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx == 0)
                                || (VeTPCR_b_NonZeroDepTm_Trig)) ||
                               (VeTPCR_b_ChngInDepTm)) ||
                              (VeTPCR_b_TrigTm_PlugIn));

        /* Outputs for Enabled SubSystem: '<S1121>/Subsystem' incorporates:
         *  EnablePort: '<S1257>/Enable'
         */
        if (VeTPCR_b_DepTmTrig)
        {
            /* Gain: '<S1261>/Gain' */
            TPCR_ac_B.Gain_d = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx;

            /* Gain: '<S1262>/Gain' */
            TPCR_ac_B.Gain = TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d;

            /* Gain: '<S1263>/Gain' */
            TPCR_ac_B.Gain_o = TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_b;

            /* Gain: '<S1264>/Gain' */
            VeTPCR_T_CabSPLtch = VeTPCR_T_CabSP;

            /* Gain: '<S1265>/Gain' */
            VeTPCR_P_PwrBdgtAvailLtch = VeTPCR_P_PwrBdgtAvail;
        }

        /* End of Outputs for SubSystem: '<S1121>/Subsystem' */

        /* Outputs for Atomic SubSystem: '<S1259>/ProtectedDivision' */
        /* Switch: '<S1286>/Switch1' incorporates:
         *  Constant: '<S1273>/Calib'
         *  Constant: '<S1286>/ConstantValue'
         *  Constant: '<S1286>/ConstantValue2'
         *  Constant: '<S1286>/ConstantValue3'
         *  RelationalOperator: '<S1286>/GreaterThanorEqual'
         *  RelationalOperator: '<S1286>/GreaterThanorEqual1'
         *  RelationalOperator: '<S1286>/NotEqual'
         *  Switch: '<S1286>/Switch2'
         *  Switch: '<S1286>/Switch3'
         */
        if (KeTPCR_cmp_VehSoakRate != 0.0F)
        {
            /* Switch: '<S1286>/Switch1' incorporates:
             *  Constant: '<S1259>/ConstantValue'
             *  Product: '<S1286>/Division'
             */
            rtb_Switch1_l4 = KeTPCR_cmp_VehSoakRate / 60.0F;
        }
        else if (KeTPCR_cmp_VehSoakRate > 0.0F)
        {
            /* Switch: '<S1286>/Switch2' incorporates:
             *  Constant: '<S1286>/MAXFLOAT'
             *  Switch: '<S1286>/Switch1'
             */
            rtb_Switch1_l4 = 3.402823466E+38F;
        }
        else if (KeTPCR_cmp_VehSoakRate < 0.0F)
        {
            /* Switch: '<S1286>/Switch3' incorporates:
             *  Constant: '<S1286>/MINFLOAT'
             *  Switch: '<S1286>/Switch1'
             *  Switch: '<S1286>/Switch2'
             */
            rtb_Switch1_l4 = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1286>/Switch1' incorporates:
             *  Constant: '<S1286>/ConstantValue4'
             *  Switch: '<S1286>/Switch2'
             *  Switch: '<S1286>/Switch3'
             */
            rtb_Switch1_l4 = 0.0F;
        }

        /* End of Switch: '<S1286>/Switch1' */
        /* End of Outputs for SubSystem: '<S1259>/ProtectedDivision' */

        /* Lookup_n-D: '<S1283>/Vector' incorporates:
         *  Gain: '<S1262>/Gain'
         *  Gain: '<S1265>/Gain'
         */
        rtb_Switch1_ml1 = look2_iflf_binlcapw(TPCR_ac_B.Gain,
            VeTPCR_P_PwrBdgtAvailLtch, ((const float32 *)
            &(KxTPCR_cmp_CabCond_SPRt[0])), ((const float32 *)
            &(KyTPCR_cmp_CabCond_SPRt[0])), ((const float32 *)
            &(KtTPCR_cmp_CabCond_SPRt[0])), TPCR_ac_ConstP.pooled10, 7U);

        /* Outputs for Atomic SubSystem: '<S1259>/ProtectedDivision1' */
        /* Switch: '<S1287>/Switch1' incorporates:
         *  Constant: '<S1287>/ConstantValue'
         *  RelationalOperator: '<S1287>/NotEqual'
         */
        if (rtb_Switch1_ml1 != 0.0F)
        {
            /* Switch: '<S1287>/Switch1' incorporates:
             *  Constant: '<S1259>/ConstantValue1'
             *  Product: '<S1287>/Division'
             */
            rtb_Switch1_ml1 /= 60.0F;
        }
        else
        {
            /* Switch: '<S1287>/Switch1' incorporates:
             *  Constant: '<S1287>/ConstantValue4'
             *  Switch: '<S1287>/Switch2'
             *  Switch: '<S1287>/Switch3'
             */
            rtb_Switch1_ml1 = 0.0F;
        }

        /* End of Switch: '<S1287>/Switch1' */
        /* End of Outputs for SubSystem: '<S1259>/ProtectedDivision1' */

        /* MATLAB Function: '<S1259>/MATLABFunction' incorporates:
         *  Constant: '<S1259>/ConstantValue2'
         *  Constant: '<S1274>/Calib'
         *  Constant: '<S1275>/Calib'
         *  Constant: '<S1282>/Calib'
         *  Product: '<S1259>/Product3'
         */
        TPCR_ac_MATLABFunction(TPCR_ac_B.Gain_d, TPCR_ac_B.Gain,
                               TPCR_ac_B.Gain_o, VeTPCR_T_CabSPLtch,
                               rtb_Switch1_l4, rtb_Switch1_ml1, (sint16)
                               (KeTPCR_t_SCDfltTime * 60),
                               KeTPCR_k_SCCTimerCalcErr,
                               KeTPCR_k_SCCTimerCalcIter,
                               &TPCR_ac_B.sf_MATLABFunction_o);

        /* Gain: '<S1289>/Gain' */
        VeTPCR_t_CondTime_ShortDepTm_SF_PlugIn =
            TPCR_ac_B.sf_MATLABFunction_o.Cond_Time;

        /* MinMax: '<S1259>/MinMax1' incorporates:
         *  Constant: '<S1277>/Calib'
         */
        if (KeTPCR_t_MinSchPrecTime > VeTPCR_t_CondTime_ShortDepTm_SF_PlugIn)
        {
            /* MinMax: '<S1259>/MinMax1' */
            rtb_Abs_o = KeTPCR_t_MinSchPrecTime;
        }
        else
        {
            /* MinMax: '<S1259>/MinMax1' */
            rtb_Abs_o = VeTPCR_t_CondTime_ShortDepTm_SF_PlugIn;
        }

        /* End of MinMax: '<S1259>/MinMax1' */

        /* Outputs for Atomic SubSystem: '<S1259>/LeftOpenInterval' */
        /* Switch: '<S1271>/Switch1' incorporates:
         *  Constant: '<S1280>/Calib'
         *  Constant: '<S1281>/Calib'
         *  Logic: '<S1284>/LogicalOperator'
         *  RelationalOperator: '<S1284>/RelatonalOperator'
         *  RelationalOperator: '<S1284>/RelatonalOperator1'
         */
        if ((rtb_Abs_o > KeTPCR_t_SCCTmrMinInterval) && (rtb_Abs_o <=
                KeTPCR_t_SCCTmrMaxInterval))
        {
            /* Switch: '<S1271>/Switch1' */
            VeTPCR_t_CondTime_AtShortDepTm_PlugIn = rtb_Abs_o;
        }
        else
        {
            /* Switch: '<S1271>/Switch1' incorporates:
             *  Constant: '<S1279>/Calib'
             */
            VeTPCR_t_CondTime_AtShortDepTm_PlugIn = KeTPCR_t_SCCRejectionDfltTmr;
        }

        /* End of Switch: '<S1271>/Switch1' */
        /* End of Outputs for SubSystem: '<S1259>/LeftOpenInterval' */

        /* UnitDelay: '<S1293>/UnitDelay' incorporates:
         *  Constant: '<S1269>/Constant'
         *  Constant: '<S1270>/Constant'
         *  Constant: '<S1276>/Calib'
         *  Logic: '<S1259>/LogicalOperator3'
         *  Logic: '<S1259>/LogicalOperator4'
         *  Logic: '<S1259>/LogicalOperator5'
         *  RelationalOperator: '<S1259>/Comparison2'
         *  RelationalOperator: '<S1259>/Comparison3'
         *  RelationalOperator: '<S1259>/Comparison5'
         *  RelationalOperator: '<S519>/Comparison12'
         *  Sum: '<S1259>/Sum1'
         *  Switch: '<S1763>/Switch1'
         */
        rtb_Comparison1_pa = ((TPCR_ac_B.Gain_d <= ((sint16)
                                (VeTPCR_t_CondTime_AtShortDepTm_PlugIn +
            KeTPCR_t_FOTARunTm))) && ((((uint32)VeTPCR_e_FOTAInstallType) ==
                                CeCITR_e_FOTANow) || (((uint32)
            VeTPCR_e_FOTAInstallType) == CeCITR_e_FOTASchedule)));

        /* Switch: '<S1272>/Switch1' */
        if (rtb_Comparison1_pa)
        {
            /* Merge: '<S1023>/Merge' incorporates:
             *  Constant: '<S1278>/Calib'
             */
            VeTPCR_t_PrecTmr_AftrMrg = KeTPCR_t_SCCFOTARejectTmr;
        }
        else
        {
            /* Merge: '<S1023>/Merge' */
            VeTPCR_t_PrecTmr_AftrMrg = VeTPCR_t_CondTime_AtShortDepTm_PlugIn;
        }

        /* End of Switch: '<S1272>/Switch1' */

        /* Gain: '<S1288>/Gain' */
        VeTPCR_t_WupTimer_PlugIn = TPCR_ac_B.sf_MATLABFunction_o.Wup_Timer;

        /* Merge: '<S1023>/Merge1' incorporates:
         *  Gain: '<S1290>/Gain'
         */
        VeTPCR_b_FOTAReject_AftrMrg = rtb_Comparison1_pa;

        /* Gain: '<S1291>/Gain' */
        VeTPCR_Cnt_WupTimerDbg_PlugIn =
            TPCR_ac_B.sf_MATLABFunction_o.LeTPCR_e_Debug_TmrSrc;

        /* Gain: '<S1292>/Gain' */
        VeTPCR_Cnt_SCTimer_Iteration_PlugIn =
            TPCR_ac_B.sf_MATLABFunction_o.Iteration;

        /* Merge: '<S1023>/Merge2' incorporates:
         *  Constant: '<S1121>/ConstantValue1'
         *  SignalConversion generated from: '<S1121>/NoPreCond_Msg'
         */
        VeTPCR_b_PrecWarningMsg_AftrMrg = false;

        /* Outputs for Atomic SubSystem: '<S1121>/TurnOnDelayTime' */
        /* Outputs for Atomic SubSystem: '<S1260>/EdgeRising' */
        /* Logic: '<S1293>/AND' incorporates:
         *  Constant: '<S1254>/Calib'
         *  Logic: '<S1293>/OR1'
         *  UnitDelay: '<S1293>/UnitDelay'
         */
        rtb_Comparison1_pa = ((KeTPCR_b_RdyForShtDwn_PrecShortTmr_PlugIn) &&
                              (!TPCR_ac_DW.UnitDelay_DSTATE_e5));

        /* Update for UnitDelay: '<S1293>/UnitDelay' incorporates:
         *  Constant: '<S1254>/Calib'
         */
        TPCR_ac_DW.UnitDelay_DSTATE_e5 =
            KeTPCR_b_RdyForShtDwn_PrecShortTmr_PlugIn;

        /* End of Outputs for SubSystem: '<S1260>/EdgeRising' */

        /* Switch: '<S1260>/Switch1' incorporates:
         *  Constant: '<S1254>/Calib'
         *  Logic: '<S1260>/OR'
         *  Logic: '<S1260>/OR1'
         */
        if ((!KeTPCR_b_RdyForShtDwn_PrecShortTmr_PlugIn) || rtb_Comparison1_pa)
        {
            /* Switch: '<S1260>/Switch1' incorporates:
             *  Constant: '<S1260>/ConstantValue1'
             */
            rtb_Switch1_l4 = 0.0F;
        }
        else
        {
            /* Switch: '<S1260>/Switch1' incorporates:
             *  Constant: '<S1255>/Calib'
             *  Constant: '<S1256>/Calib'
             *  MinMax: '<S1260>/Minimum'
             *  Sum: '<S1260>/Summation'
             *  UnitDelay: '<S1260>/UnitDelay'
             */
            rtb_Switch1_l4 = fminf(KeTPCR_t_RdyForShtDwn_PrecShrtTmrDly_PlugIn,
                                   KeTPCR_t_RS_CabPrec_dT +
                                   TPCR_ac_DW.UnitDelay_DSTATE_d);
        }

        /* End of Switch: '<S1260>/Switch1' */

        /* Logic: '<S1260>/AND' incorporates:
         *  Constant: '<S1254>/Calib'
         *  Constant: '<S1256>/Calib'
         *  RelationalOperator: '<S1260>/GreaterThan'
         */
        VeTPCR_b_RdyForShtDwn_PlugIn =
            ((KeTPCR_b_RdyForShtDwn_PrecShortTmr_PlugIn) && (rtb_Switch1_l4 >=
              KeTPCR_t_RdyForShtDwn_PrecShrtTmrDly_PlugIn));

        /* Update for UnitDelay: '<S1260>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_d = rtb_Switch1_l4;

        /* End of Outputs for SubSystem: '<S1121>/TurnOnDelayTime' */

        /* Merge: '<S1023>/Merge3' incorporates:
         *  Logic: '<S1253>/AND'
         */
        VeTPCR_b_PrecRdyForShtDwn_AftrMrg = VeTPCR_b_RdyForShtDwn_PlugIn;

        /* Update for UnitDelay: '<S1258>/UnitDelay4' */
        TPCR_ac_DW.UnitDelay4_DSTATE_f =
            TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx;

        /* End of Outputs for SubSystem: '<S1023>/PreCond_ShortTmr_PlugIn' */
    }
    else if (VeTPCR_b_SCNotSupp_SOCReject_Ltch)
    {
        /* Outputs for IfAction SubSystem: '<S1023>/Prec_NotSupported' incorporates:
         *  ActionPort: '<S1123>/ActionPort'
         */
        /* Merge: '<S1023>/Merge' incorporates:
         *  Constant: '<S1306>/Calib'
         *  SignalConversion generated from: '<S1123>/Prec_Timer'
         */
        VeTPCR_t_PrecTmr_AftrMrg = KeTPCR_t_SOCNotOK_SCTimer;

        /* Merge: '<S1023>/Merge2' incorporates:
         *  Constant: '<S1302>/Calib'
         *  SignalConversion generated from: '<S1123>/NoPreCond_Msg'
         */
        VeTPCR_b_PrecWarningMsg_AftrMrg = KeTPCR_b_NoPrecMsg;

        /* Outputs for Atomic SubSystem: '<S1123>/TurnOnDelayTime' */
        /* Outputs for Atomic SubSystem: '<S1307>/EdgeRising' */
        /* Logic: '<S1308>/AND' incorporates:
         *  Constant: '<S1303>/Calib'
         *  Logic: '<S1308>/OR1'
         *  UnitDelay: '<S1308>/UnitDelay'
         */
        rtb_Comparison1_pa = ((KeTPCR_b_RdyForShtDwn_NoPrec) &&
                              (!TPCR_ac_DW.UnitDelay_DSTATE_mx));

        /* Update for UnitDelay: '<S1308>/UnitDelay' incorporates:
         *  Constant: '<S1303>/Calib'
         */
        TPCR_ac_DW.UnitDelay_DSTATE_mx = KeTPCR_b_RdyForShtDwn_NoPrec;

        /* End of Outputs for SubSystem: '<S1307>/EdgeRising' */

        /* Switch: '<S1307>/Switch1' incorporates:
         *  Constant: '<S1303>/Calib'
         *  Logic: '<S1307>/OR'
         *  Logic: '<S1307>/OR1'
         */
        if ((!KeTPCR_b_RdyForShtDwn_NoPrec) || rtb_Comparison1_pa)
        {
            /* Switch: '<S1307>/Switch1' incorporates:
             *  Constant: '<S1307>/ConstantValue1'
             */
            rtb_Switch1_l4 = 0.0F;
        }
        else
        {
            /* Switch: '<S1307>/Switch1' incorporates:
             *  Constant: '<S1304>/Calib'
             *  Constant: '<S1305>/Calib'
             *  MinMax: '<S1307>/Minimum'
             *  Sum: '<S1307>/Summation'
             *  UnitDelay: '<S1307>/UnitDelay'
             */
            rtb_Switch1_l4 = fminf(KeTPCR_t_RdyForShtDwn_PreCondDly,
                                   KeTPCR_t_RS_CabPrec_dT +
                                   TPCR_ac_DW.UnitDelay_DSTATE_h);
        }

        /* End of Switch: '<S1307>/Switch1' */

        /* Logic: '<S1307>/AND' incorporates:
         *  Constant: '<S1303>/Calib'
         *  Constant: '<S1305>/Calib'
         *  RelationalOperator: '<S1307>/GreaterThan'
         */
        VeTPCR_b_RdyForShtDwn_SOCReject = ((KeTPCR_b_RdyForShtDwn_NoPrec) &&
            (rtb_Switch1_l4 >= KeTPCR_t_RdyForShtDwn_PreCondDly));

        /* Update for UnitDelay: '<S1307>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_h = rtb_Switch1_l4;

        /* End of Outputs for SubSystem: '<S1123>/TurnOnDelayTime' */

        /* Merge: '<S1023>/Merge3' incorporates:
         *  Logic: '<S1301>/AND'
         */
        VeTPCR_b_PrecRdyForShtDwn_AftrMrg = VeTPCR_b_RdyForShtDwn_SOCReject;

        /* Merge: '<S1023>/Merge1' incorporates:
         *  Constant: '<S1123>/ConstantValue3'
         *  SignalConversion generated from: '<S1123>/FOTAReject'
         */
        VeTPCR_b_FOTAReject_AftrMrg = false;

        /* End of Outputs for SubSystem: '<S1023>/Prec_NotSupported' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1023>/Prec_Dflt' incorporates:
         *  ActionPort: '<S1122>/ActionPort'
         */
        /* Merge: '<S1023>/Merge' incorporates:
         *  Constant: '<S1296>/Calib'
         *  SignalConversion generated from: '<S1122>/Prec_Timer'
         */
        VeTPCR_t_PrecTmr_AftrMrg = KeTPCR_t_Dflt_SCTimer;

        /* Merge: '<S1023>/Merge2' incorporates:
         *  Constant: '<S1122>/ConstantValue1'
         *  SignalConversion generated from: '<S1122>/Dflt_Msg'
         */
        VeTPCR_b_PrecWarningMsg_AftrMrg = false;

        /* Outputs for Atomic SubSystem: '<S1122>/TurnOnDelayTime' */
        /* Outputs for Atomic SubSystem: '<S1299>/EdgeRising' */
        /* Logic: '<S1300>/AND' incorporates:
         *  Constant: '<S1295>/Calib'
         *  Logic: '<S1300>/OR1'
         *  UnitDelay: '<S1300>/UnitDelay'
         */
        rtb_Comparison1_pa = ((KeTPCR_b_RdyForShtDwn_PrecDflt) &&
                              (!TPCR_ac_DW.UnitDelay_DSTATE_j4));

        /* Update for UnitDelay: '<S1300>/UnitDelay' incorporates:
         *  Constant: '<S1295>/Calib'
         */
        TPCR_ac_DW.UnitDelay_DSTATE_j4 = KeTPCR_b_RdyForShtDwn_PrecDflt;

        /* End of Outputs for SubSystem: '<S1299>/EdgeRising' */

        /* Switch: '<S1299>/Switch1' incorporates:
         *  Constant: '<S1295>/Calib'
         *  Logic: '<S1299>/OR'
         *  Logic: '<S1299>/OR1'
         */
        if ((!KeTPCR_b_RdyForShtDwn_PrecDflt) || rtb_Comparison1_pa)
        {
            /* Switch: '<S1299>/Switch1' incorporates:
             *  Constant: '<S1299>/ConstantValue1'
             */
            rtb_Switch1_l4 = 0.0F;
        }
        else
        {
            /* Switch: '<S1299>/Switch1' incorporates:
             *  Constant: '<S1297>/Calib'
             *  Constant: '<S1298>/Calib'
             *  MinMax: '<S1299>/Minimum'
             *  Sum: '<S1299>/Summation'
             *  UnitDelay: '<S1299>/UnitDelay'
             */
            rtb_Switch1_l4 = fminf(KeTPCR_t_RdyForShtDwn_PreCondDly,
                                   KeTPCR_t_RS_CabPrec_dT +
                                   TPCR_ac_DW.UnitDelay_DSTATE_l);
        }

        /* End of Switch: '<S1299>/Switch1' */

        /* Logic: '<S1299>/AND' incorporates:
         *  Constant: '<S1295>/Calib'
         *  Constant: '<S1298>/Calib'
         *  RelationalOperator: '<S1299>/GreaterThan'
         */
        VeTPCR_b_RdyForShtDwn_Dflt = ((KeTPCR_b_RdyForShtDwn_PrecDflt) &&
            (rtb_Switch1_l4 >= KeTPCR_t_RdyForShtDwn_PreCondDly));

        /* Update for UnitDelay: '<S1299>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_l = rtb_Switch1_l4;

        /* End of Outputs for SubSystem: '<S1122>/TurnOnDelayTime' */

        /* Merge: '<S1023>/Merge3' incorporates:
         *  Logic: '<S1294>/AND'
         */
        VeTPCR_b_PrecRdyForShtDwn_AftrMrg = VeTPCR_b_RdyForShtDwn_Dflt;

        /* Merge: '<S1023>/Merge1' incorporates:
         *  Constant: '<S1122>/ConstantValue3'
         *  SignalConversion generated from: '<S1122>/FOTAReject'
         */
        VeTPCR_b_FOTAReject_AftrMrg = false;

        /* End of Outputs for SubSystem: '<S1023>/Prec_Dflt' */
    }

    /* End of If: '<S1023>/If1' */

    /* Outputs for Atomic SubSystem: '<S194>/TimerRetriggerResetEnabled3' */
    /* Outputs for Atomic SubSystem: '<S194>/EdgeFalling' */
    /* Logic: '<S101>/Logical11' incorporates:
     *  Logic: '<S194>/Logical22'
     *  Logic: '<S194>/Logical6'
     *  Logic: '<S196>/OR1'
     *  Logic: '<S241>/Logical15'
     *  Logic: '<S241>/Logical27'
     *  Logic: '<S241>/Logical3'
     *  Logic: '<S8>/Logical1'
     *  Switch: '<S241>/Switch1'
     *  Switch: '<S241>/Switch3'
     *  Switch: '<S244>/Switch1'
     */
    rtb_RelationalOperator_k = !rtb_LogicalOperator_h0;

    /* End of Outputs for SubSystem: '<S194>/EdgeFalling' */
    /* End of Outputs for SubSystem: '<S194>/TimerRetriggerResetEnabled3' */

    /* Logic: '<S101>/Logical1' incorporates:
     *  Logic: '<S100>/Logical1'
     *  Logic: '<S102>/Logical3'
     *  Logic: '<S103>/Logical3'
     *  Logic: '<S104>/Logical3'
     *  Logic: '<S95>/Logical3'
     *  Logic: '<S96>/Logical3'
     *  Logic: '<S98>/Logical3'
     */
    VeTPCC_b_RS_NoCabPrecond_NoPl_0 = !rtb_LogicalOperator_gy;

    /* Logic: '<S101>/Logical2' incorporates:
     *  Logic: '<S100>/Logical2'
     *  Logic: '<S102>/Logical7'
     *  Logic: '<S103>/Logical4'
     *  Logic: '<S104>/Logical8'
     *  Logic: '<S95>/Logical10'
     *  Logic: '<S96>/Logical10'
     *  Logic: '<S97>/Logical11'
     *  Logic: '<S98>/Logical5'
     */
    VeTPCC_b_RS_NoCabPrecond_NoPl_1 = !VeTPCC_b_RS_NoCabPrecond_SNA;

    /* Logic: '<S101>/Logical3' incorporates:
     *  Constant: '<S167>/Constant'
     *  Constant: '<S168>/Calib'
     *  Constant: '<S169>/Calib'
     *  Constant: '<S170>/Calib'
     *  Logic: '<S101>/Logical1'
     *  Logic: '<S101>/Logical10'
     *  Logic: '<S101>/Logical11'
     *  Logic: '<S101>/Logical2'
     *  Logic: '<S101>/Logical4'
     *  Logic: '<S101>/Logical5'
     *  Logic: '<S101>/Logical6'
     *  Logic: '<S101>/Logical7'
     *  Logic: '<S101>/Logical8'
     *  Logic: '<S8>/Logical1'
     *  RelationalOperator: '<S101>/Comparison4'
     *  RelationalOperator: '<S1117>/RelationalOperator'
     *  Switch: '<S1778>/Switch1'
     */
    VeTPCC_b_RS_NoCabPrecond_NoPlug = ((((((((VeTPCR_b_PrecWarningMsg_AftrMrg) &&
        (KeTPCR_b_Enbl_PrecMsg_RSPlugInChk)) || (VeTPCR_b_SC_WakeUpReq)) ||
        rtb_LogicalOperator_h0) && (VeTPCC_b_RS_NoCabPrecond_NoPl_0 ||
        (KeTPCR_b_DsblFltsChk_CabPrecNoPlug))) && (((VeTPCR_b_SOCRejected_AS) &&
        VeTPCR_b_UnplugNoBattCond_SOC_t) || (((((uint32)
        VeTPCR_e_ClimateScheduleOption) == CeCITR_e_PluggedInOnly) &&
        VeTPCR_b_UnplugNoBattCond_SOC_t) && rtb_RelationalOperator_k))) &&
        VeTPCC_b_RS_NoCabPrecond_NoPl_1) && (KeTPCR_b_Enbl_NoCabPrec_NoPlugIn));

    /* Outputs for Atomic SubSystem: '<S101>/SignalLatchOnWithReset' */
    /* Logic: '<S173>/OR1' incorporates:
     *  Logic: '<S173>/NOT'
     *  Logic: '<S173>/OR'
     *  UnitDelay: '<S101>/UnitDelay'
     *  UnitDelay: '<S173>/UnitDelay'
     */
    VeTPCC_b_RS_NoCabPrecond_NoPlugLtch = ((VeTPCC_b_RS_NoCabPrecond_NoPlug) ||
        ((!TPCR_ac_DW.UnitDelay_DSTATE_bso) && (TPCR_ac_DW.UnitDelay_DSTATE_by)));

    /* Update for UnitDelay: '<S173>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_by = VeTPCC_b_RS_NoCabPrecond_NoPlugLtch;

    /* End of Outputs for SubSystem: '<S101>/SignalLatchOnWithReset' */

    /* Outputs for Atomic SubSystem: '<S194>/EdgeFalling1' */
    /* Logic: '<S197>/AND' incorporates:
     *  UnitDelay: '<S197>/UnitDelay'
     */
    rtb_Comparison1_pa = (rtb_VariantMerge_For_Variant__2 &&
                          (TPCR_ac_DW.UnitDelay_DSTATE_at3));

    /* Update for UnitDelay: '<S197>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_at3 = VeTPCR_b_SC_WakeUpReq;

    /* End of Outputs for SubSystem: '<S194>/EdgeFalling1' */

    /* Outputs for Atomic SubSystem: '<S194>/EdgeFalling' */
    /* Logic: '<S196>/AND' incorporates:
     *  UnitDelay: '<S196>/UnitDelay'
     */
    rtb_NotEqual_p = (rtb_RelationalOperator_k &&
                      (TPCR_ac_DW.UnitDelay_DSTATE_o2w));

    /* Update for UnitDelay: '<S196>/UnitDelay' incorporates:
     *  Logic: '<S8>/Logical1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_o2w = rtb_LogicalOperator_h0;

    /* End of Outputs for SubSystem: '<S194>/EdgeFalling' */

    /* Outputs for Atomic SubSystem: '<S194>/SignalLatchOnWithReset' */
    /* Logic: '<S236>/OR1' incorporates:
     *  Constant: '<S222>/Calib'
     *  Constant: '<S223>/Calib'
     *  Logic: '<S194>/Logical29'
     *  Logic: '<S194>/Logical30'
     *  Logic: '<S194>/Logical6'
     *  Logic: '<S194>/Logical7'
     *  Logic: '<S236>/NOT'
     *  Logic: '<S236>/OR'
     *  UnitDelay: '<S236>/UnitDelay'
     */
    VeTPCR_b_RSOffLtch = (((rtb_Comparison1_pa && (KeTPCR_b_EnblSCWkUp_PrecOff))
                           || rtb_NotEqual_p) || ((rtb_RelationalOperator_k &&
                            (rtb_VariantMerge_For_Variant__2 ||
        (!KeTPCR_b_EnblSCWkUp_PrecOffRst))) && (TPCR_ac_DW.UnitDelay_DSTATE_ji5)));

    /* Update for UnitDelay: '<S236>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ji5 = VeTPCR_b_RSOffLtch;

    /* End of Outputs for SubSystem: '<S194>/SignalLatchOnWithReset' */

    /* Switch: '<S1018>/Switch2' incorporates:
     *  Constant: '<S210>/Constant'
     *  Constant: '<S211>/Constant'
     *  Constant: '<S218>/Calib'
     *  Logic: '<S194>/Logical10'
     *  Logic: '<S194>/Logical16'
     *  Logic: '<S194>/Logical4'
     *  RelationalOperator: '<S194>/Comparison1'
     *  RelationalOperator: '<S194>/Comparison2'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S99>/Comparison3'
     *  Switch: '<S1760>/Switch'
     *  Switch: '<S1764>/Switch'
     */
    rtb_Switch2_du = (((VeTPCR_b_RSOffLtch) || (((uint32)
                         VeTPCR_e_BCMPreCondCabinReq) ==
                        CePLTR_e_CabinPreCondStop)) && ((((uint32)
                         VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff) ||
                       (KeTPCR_b_DsblKeyChk_CabOff)));

    /* Outputs for Atomic SubSystem: '<S194>/EdgeFalling2' */
    /* Logic: '<S241>/Logical34' incorporates:
     *  Logic: '<S198>/OR1'
     */
    rtb_OR1_lo = !rtb_Comparison5;

    /* End of Outputs for SubSystem: '<S194>/EdgeFalling2' */

    /* Logic: '<S241>/Logical4' incorporates:
     *  Logic: '<S241>/Logical34'
     */
    VeTPCR_b_CabPrecOff_CBC = (rtb_OR1_lo && rtb_RelationalOperator_k);

    /* Outputs for Atomic SubSystem: '<S241>/EdgeRising1' */
    /* Switch: '<S988>/Switch1' incorporates:
     *  UnitDelay: '<S253>/UnitDelay'
     */
    rtb_Switch1_cs = TPCR_ac_DW.UnitDelay_DSTATE_myh;

    /* Update for UnitDelay: '<S253>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_myh = VeTPCR_b_CabPrecOff_CBC;

    /* Outputs for Atomic SubSystem: '<S241>/TimerRetriggerResetEnabled1' */
    /* Switch: '<S267>/Switch1' incorporates:
     *  Logic: '<S241>/Logical20'
     *  Logic: '<S241>/Logical28'
     *  Logic: '<S253>/AND'
     *  Logic: '<S253>/OR1'
     *  Switch: '<S267>/Switch2'
     */
    if ((!VeTPCR_b_CabPrecOff_CBC) || ((VeTPCR_b_CabPrecOff_CBC) &&
            (!rtb_Switch1_cs)))
    {
        /* Switch: '<S267>/Switch1' incorporates:
         *  Constant: '<S263>/Calib'
         *  Constant: '<S264>/Calib'
         *  Sum: '<S241>/Add2'
         */
        rtb_Switch1_l4 = KeTPCR_t_RSOn_AftrTmrExprDbnc + KeTPCR_t_RS_CabPrec_dT;
    }
    else if (VeTPCR_b_CabPrecOff_CBC)
    {
        /* Switch: '<S267>/Switch2' incorporates:
         *  Constant: '<S264>/Calib'
         *  Constant: '<S267>/ConstantValue4'
         *  MinMax: '<S267>/Maximum'
         *  Sum: '<S267>/Subtraction'
         *  Switch: '<S267>/Switch1'
         *  UnitDelay: '<S267>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_do -
                               KeTPCR_t_RS_CabPrec_dT, 0.0F);
    }
    else
    {
        /* Switch: '<S267>/Switch1' incorporates:
         *  Switch: '<S267>/Switch2'
         *  UnitDelay: '<S267>/UnitDelay'
         */
        rtb_Switch1_l4 = TPCR_ac_DW.UnitDelay_DSTATE_do;
    }

    /* End of Switch: '<S267>/Switch1' */
    /* End of Outputs for SubSystem: '<S241>/EdgeRising1' */

    /* Update for UnitDelay: '<S267>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_do = rtb_Switch1_l4;

    /* Logic: '<S241>/Logical10' incorporates:
     *  Constant: '<S267>/ConstantValue2'
     *  RelationalOperator: '<S267>/GreaterThan1'
     */
    VeTPCR_b_CabPrecOff_CBCDbnc = (rtb_Switch1_l4 <= 0.0F);

    /* End of Outputs for SubSystem: '<S241>/TimerRetriggerResetEnabled1' */

    /* Switch: '<S241>/Switch' incorporates:
     *  Constant: '<S259>/Calib'
     *  Gain: '<S1792>/Gain'
     *  Logic: '<S8>/Logical1'
     */
    if (KeTPCR_b_Use_RSActv)
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = rtb_LogicalOperator_h0;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S1>/TPCI_ProcessInternalInputs' */
        VeTPCR_b_DoorAjarEnblLtch_Rst_t =
            TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_f;

        /* End of Outputs for SubSystem: '<S1>/TPCI_ProcessInternalInputs' */
    }

    /* End of Switch: '<S241>/Switch' */

    /* Logic: '<S241>/Logical11' incorporates:
     *  Constant: '<S258>/Calib'
     *  RelationalOperator: '<S241>/Comparison3'
     */
    VeTPCR_b_DepTimeZero = (((VeTPCR_b_DoorAjarEnblLtch_Rst_t &&
        (VeTPCR_b_SC_WakeUpReq)) && (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx ==
        0)) && (KeTPCR_b_EnblTmrChk_CabPrecOff));

    /* Outputs for Atomic SubSystem: '<S241>/EdgeRising' */
    /* Logic: '<S252>/AND' incorporates:
     *  Logic: '<S252>/OR1'
     *  UnitDelay: '<S252>/UnitDelay'
     */
    rtb_NotEqual_p = ((VeTPCR_b_DepTimeZero) &&
                      (!TPCR_ac_DW.UnitDelay_DSTATE_eik));

    /* Update for UnitDelay: '<S252>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_eik = VeTPCR_b_DepTimeZero;

    /* End of Outputs for SubSystem: '<S241>/EdgeRising' */

    /* Switch: '<S241>/Switch1' incorporates:
     *  Constant: '<S259>/Calib'
     *  Gain: '<S1792>/Gain'
     *  Logic: '<S241>/Logical33'
     */
    if (KeTPCR_b_Use_RSActv)
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = rtb_RelationalOperator_k;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S1>/TPCI_ProcessInternalInputs' */
        VeTPCR_b_DoorAjarEnblLtch_Rst_t =
            !TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_f;

        /* End of Outputs for SubSystem: '<S1>/TPCI_ProcessInternalInputs' */
    }

    /* Outputs for Atomic SubSystem: '<S241>/SignalLatchOnWithReset1' */
    /* Logic: '<S265>/OR1' incorporates:
     *  Logic: '<S241>/Logical8'
     *  Logic: '<S265>/NOT'
     *  Logic: '<S265>/OR'
     *  UnitDelay: '<S241>/UnitDelay1'
     *  UnitDelay: '<S265>/UnitDelay'
     */
    VeTPCR_b_DepTimeZeroLtch = (rtb_NotEqual_p ||
        (((!VeTPCR_b_DoorAjarEnblLtch_Rst_t) && (!TPCR_ac_DW.UnitDelay1_DSTATE_o))
         && (TPCR_ac_DW.UnitDelay_DSTATE_mkb)));

    /* Update for UnitDelay: '<S265>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_mkb = VeTPCR_b_DepTimeZeroLtch;

    /* End of Outputs for SubSystem: '<S241>/SignalLatchOnWithReset1' */

    /* Abs: '<S1124>/Abs' incorporates:
     *  Sum: '<S241>/Sum1'
     *  UnitDelay: '<S241>/UnitDelay4'
     */
    rtb_Abs_o = (sint16)(TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx -
                         TPCR_ac_DW.UnitDelay4_DSTATE_b);

    /* Abs: '<S241>/Abs' */
    if (rtb_Abs_o < 0)
    {
        tmp = -((sint32)rtb_Abs_o);
        if ((-rtb_Abs_o) > 32767)
        {
            tmp = 32767;
        }

        /* Abs: '<S1124>/Abs' */
        rtb_Abs_o = (sint16)tmp;
    }

    /* End of Abs: '<S241>/Abs' */

    /* RelationalOperator: '<S241>/Comparison6' incorporates:
     *  Constant: '<S260>/Calib'
     */
    VeTPCR_b_BigDepTmChng = (rtb_Abs_o >= KeTPCR_t_CabPrecOff_DepTmTh);

    /* Switch: '<S241>/Switch2' incorporates:
     *  Constant: '<S259>/Calib'
     *  Gain: '<S1792>/Gain'
     *  Logic: '<S8>/Logical1'
     */
    if (KeTPCR_b_Use_RSActv)
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = rtb_LogicalOperator_h0;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S1>/TPCI_ProcessInternalInputs' */
        VeTPCR_b_DoorAjarEnblLtch_Rst_t =
            TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_f;

        /* End of Outputs for SubSystem: '<S1>/TPCI_ProcessInternalInputs' */
    }

    /* End of Switch: '<S241>/Switch2' */

    /* Logic: '<S241>/Logical14' incorporates:
     *  Logic: '<S241>/Logical12'
     *  Logic: '<S241>/Logical7'
     */
    VeTPCR_b_SetLongTimerCond_tmp = !VeTPCR_b_DepTimeZeroLtch;

    /* Logic: '<S241>/Logical13' incorporates:
     *  Logic: '<S241>/Logical14'
     */
    VeTPCR_b_DepTimeBigChng = (((VeTPCR_b_DoorAjarEnblLtch_Rst_t &&
        (VeTPCR_b_SC_WakeUpReq)) && VeTPCR_b_SetLongTimerCond_tmp) &&
        (VeTPCR_b_BigDepTmChng));

    /* Switch: '<S241>/Switch3' incorporates:
     *  Constant: '<S259>/Calib'
     *  Gain: '<S1792>/Gain'
     *  Logic: '<S241>/Logical16'
     */
    if (KeTPCR_b_Use_RSActv)
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = rtb_RelationalOperator_k;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S1>/TPCI_ProcessInternalInputs' */
        VeTPCR_b_DoorAjarEnblLtch_Rst_t =
            !TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_f;

        /* End of Outputs for SubSystem: '<S1>/TPCI_ProcessInternalInputs' */
    }

    /* Outputs for Atomic SubSystem: '<S241>/SignalLatchOnWithReset2' */
    /* Logic: '<S266>/OR1' incorporates:
     *  Logic: '<S266>/NOT'
     *  Logic: '<S266>/OR'
     *  UnitDelay: '<S266>/UnitDelay'
     */
    VeTPCR_b_DepTimeBigChngLtch = ((VeTPCR_b_DepTimeBigChng) ||
        ((!VeTPCR_b_DoorAjarEnblLtch_Rst_t) && (TPCR_ac_DW.UnitDelay_DSTATE_fra)));

    /* Update for UnitDelay: '<S266>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fra = VeTPCR_b_DepTimeBigChngLtch;

    /* End of Outputs for SubSystem: '<S241>/SignalLatchOnWithReset2' */

    /* Outputs for Atomic SubSystem: '<S241>/EdgeRising3' */
    /* Switch: '<S988>/Switch1' incorporates:
     *  UnitDelay: '<S255>/UnitDelay'
     */
    rtb_Switch1_cs = TPCR_ac_DW.UnitDelay_DSTATE_h5;

    /* Update for UnitDelay: '<S255>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_h5 = VeTPCR_b_DepTimeZeroLtch;

    /* End of Outputs for SubSystem: '<S241>/EdgeRising3' */

    /* Logic: '<S241>/Logical21' incorporates:
     *  Constant: '<S257>/Calib'
     */
    rtb_Comparison1_pa = (rtb_NotEqual_p && (KeTPCR_b_EnblSCCOvrlap));

    /* Outputs for Atomic SubSystem: '<S241>/TimerRetriggerResetEnabled2' */
    /* Outputs for Atomic SubSystem: '<S241>/EdgeRising3' */
    /* Switch: '<S268>/Switch1' incorporates:
     *  Logic: '<S241>/Logical19'
     *  Logic: '<S255>/AND'
     *  Logic: '<S255>/OR1'
     *  Switch: '<S268>/Switch2'
     */
    if ((VeTPCR_b_SetLongTimerCond_tmp || ((VeTPCR_b_DepTimeZeroLtch) &&
            (!rtb_Switch1_cs))) || rtb_Comparison1_pa)
    {
        /* Switch: '<S268>/Switch1' incorporates:
         *  Constant: '<S261>/Calib'
         *  Constant: '<S264>/Calib'
         *  Sum: '<S241>/Add3'
         */
        rtb_Switch1_l4 = KeTPCR_t_PrecOffTm_AfterSC + KeTPCR_t_RS_CabPrec_dT;
    }
    else if (VeTPCR_b_DepTimeZeroLtch)
    {
        /* Switch: '<S268>/Switch2' incorporates:
         *  Constant: '<S264>/Calib'
         *  Constant: '<S268>/ConstantValue4'
         *  MinMax: '<S268>/Maximum'
         *  Sum: '<S268>/Subtraction'
         *  Switch: '<S268>/Switch1'
         *  UnitDelay: '<S268>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_f3 -
                               KeTPCR_t_RS_CabPrec_dT, 0.0F);
    }
    else
    {
        /* Switch: '<S268>/Switch1' incorporates:
         *  Switch: '<S268>/Switch2'
         *  UnitDelay: '<S268>/UnitDelay'
         */
        rtb_Switch1_l4 = TPCR_ac_DW.UnitDelay_DSTATE_f3;
    }

    /* End of Switch: '<S268>/Switch1' */
    /* End of Outputs for SubSystem: '<S241>/EdgeRising3' */

    /* Update for UnitDelay: '<S268>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_f3 = rtb_Switch1_l4;

    /* Logic: '<S241>/Logical6' incorporates:
     *  Constant: '<S268>/ConstantValue2'
     *  RelationalOperator: '<S268>/GreaterThan1'
     */
    VeTPCR_b_TmrExpiredAfterDepTim = (rtb_Switch1_l4 <= 0.0F);

    /* End of Outputs for SubSystem: '<S241>/TimerRetriggerResetEnabled2' */

    /* Outputs for Atomic SubSystem: '<S240>/Hysteresis1' */
    /* Switch: '<S247>/Switch1' incorporates:
     *  Constant: '<S248>/Calib'
     *  RelationalOperator: '<S247>/GreaterThan'
     */
    if (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn >
            KeTPCR_T_BattCritThMax_CabPrecOff)
    {
        /* Switch: '<S247>/Switch1' incorporates:
         *  Constant: '<S247>/ConstantValue'
         */
        rtb_Switch1_im = true;
    }
    else
    {
        /* Switch: '<S247>/Switch1' incorporates:
         *  Constant: '<S249>/Calib'
         *  RelationalOperator: '<S247>/GreaterThan1'
         *  UnitDelay: '<S247>/UnitDelay'
         */
        rtb_Switch1_im = ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn >=
                           KeTPCR_T_BattCritThMin_CabPrecOff) &&
                          (TPCR_ac_DW.UnitDelay_DSTATE_fnw));
    }

    /* End of Switch: '<S247>/Switch1' */

    /* Update for UnitDelay: '<S247>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fnw = rtb_Switch1_im;

    /* End of Outputs for SubSystem: '<S240>/Hysteresis1' */

    /* Logic: '<S194>/Logical18' incorporates:
     *  Logic: '<S8>/Logical1'
     */
    VeTPCR_b_DoorAjarEnbl = (rtb_LogicalOperator_h0 &&
        (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_md));

    /* Outputs for Atomic SubSystem: '<S194>/EdgeRising6' */
    /* Switch: '<S988>/Switch1' incorporates:
     *  UnitDelay: '<S206>/UnitDelay'
     */
    rtb_Switch1_cs = TPCR_ac_DW.UnitDelay_DSTATE_aw;

    /* Update for UnitDelay: '<S206>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_aw = VeTPCR_b_DoorAjarEnbl;

    /* Outputs for Atomic SubSystem: '<S194>/TimerRetriggerResetEnabled2' */
    /* Switch: '<S243>/Switch1' incorporates:
     *  Logic: '<S194>/Logical19'
     *  Logic: '<S194>/Logical37'
     *  Logic: '<S206>/AND'
     *  Logic: '<S206>/OR1'
     *  Switch: '<S243>/Switch2'
     */
    if ((!VeTPCR_b_DoorAjarEnbl) || ((VeTPCR_b_DoorAjarEnbl) && (!rtb_Switch1_cs)))
    {
        /* Switch: '<S243>/Switch1' incorporates:
         *  Constant: '<S231>/Calib'
         *  Constant: '<S234>/Calib'
         *  Sum: '<S194>/Add2'
         */
        rtb_Switch1_l4 = KeTPCR_t_DoorAjarTmr_CabPrecOff +
            KeTPCR_t_RS_CabPrec_dT;
    }
    else if (VeTPCR_b_DoorAjarEnbl)
    {
        /* Switch: '<S243>/Switch2' incorporates:
         *  Constant: '<S234>/Calib'
         *  Constant: '<S243>/ConstantValue4'
         *  MinMax: '<S243>/Maximum'
         *  Sum: '<S243>/Subtraction'
         *  Switch: '<S243>/Switch1'
         *  UnitDelay: '<S243>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_ps -
                               KeTPCR_t_RS_CabPrec_dT, 0.0F);
    }
    else
    {
        /* Switch: '<S243>/Switch1' incorporates:
         *  Switch: '<S243>/Switch2'
         *  UnitDelay: '<S243>/UnitDelay'
         */
        rtb_Switch1_l4 = TPCR_ac_DW.UnitDelay_DSTATE_ps;
    }

    /* End of Switch: '<S243>/Switch1' */
    /* End of Outputs for SubSystem: '<S194>/EdgeRising6' */

    /* Update for UnitDelay: '<S243>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ps = rtb_Switch1_l4;

    /* Logic: '<S194>/Logical8' incorporates:
     *  Constant: '<S243>/ConstantValue2'
     *  RelationalOperator: '<S243>/GreaterThan1'
     */
    VeTPCR_b_DoorAjarTime_CabPrec = (rtb_Switch1_l4 <= 0.0F);

    /* End of Outputs for SubSystem: '<S194>/TimerRetriggerResetEnabled2' */

    /* Logic: '<S194>/Logical9' incorporates:
     *  Logic: '<S194>/Logical21'
     *  Logic: '<S194>/Logical33'
     *  Logic: '<S194>/Logical42'
     *  Logic: '<S240>/Logical28'
     *  Logic: '<S240>/Logical5'
     *  Logic: '<S8>/Logical1'
     */
    VeTPCR_b_DoorAjarEnblLtch_Rst_t = (rtb_LogicalOperator_h0 ||
        (VeTPCR_b_SC_WakeUpReq));

    /* Logic: '<S194>/Logical9' */
    VeTPCR_b_DoorAjarEnblLtch_Rst = VeTPCR_b_DoorAjarEnblLtch_Rst_t;

    /* Outputs for Atomic SubSystem: '<S194>/EdgeRising' */
    /* Logic: '<S200>/OR1' incorporates:
     *  UnitDelay: '<S200>/UnitDelay'
     */
    rtb_NotEqual_p = !TPCR_ac_DW.UnitDelay_DSTATE_cd;

    /* Update for UnitDelay: '<S200>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_cd = VeTPCR_b_DoorAjarEnblLtch_Rst;

    /* Outputs for Atomic SubSystem: '<S194>/SignalLatchOnWithReset4' */
    /* Logic: '<S238>/OR1' incorporates:
     *  Logic: '<S200>/AND'
     *  Logic: '<S238>/NOT'
     *  Logic: '<S238>/OR'
     *  UnitDelay: '<S238>/UnitDelay'
     */
    VeTPCR_b_DoorAjarEnblLtch = ((VeTPCR_b_DoorAjarTime_CabPrec) ||
        (((!VeTPCR_b_DoorAjarEnblLtch_Rst) || (!rtb_NotEqual_p)) &&
         (TPCR_ac_DW.UnitDelay_DSTATE_lv)));

    /* End of Outputs for SubSystem: '<S194>/EdgeRising' */

    /* Update for UnitDelay: '<S238>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_lv = VeTPCR_b_DoorAjarEnblLtch;

    /* End of Outputs for SubSystem: '<S194>/SignalLatchOnWithReset4' */

    /* Logic: '<S194>/Logical17' incorporates:
     *  Constant: '<S220>/Calib'
     */
    VeTPCR_b_DoorOpen_CabPrecOffSt = ((VeTPCR_b_DoorAjarEnblLtch) &&
        (KeTPCR_b_EnblDoorAjar_CabPrecOffChk));

    /* Logic: '<S194>/Logical15' incorporates:
     *  Logic: '<S8>/Logical1'
     */
    VeTPCR_b_HoodAjarEnbl = (rtb_LogicalOperator_h0 &&
        (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gr));

    /* Outputs for Atomic SubSystem: '<S194>/EdgeRising7' */
    /* Switch: '<S988>/Switch1' incorporates:
     *  UnitDelay: '<S207>/UnitDelay'
     */
    rtb_Switch1_cs = TPCR_ac_DW.UnitDelay_DSTATE_mvwt;

    /* Update for UnitDelay: '<S207>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_mvwt = VeTPCR_b_HoodAjarEnbl;

    /* Outputs for Atomic SubSystem: '<S194>/TimerRetriggerResetEnabled1' */
    /* Switch: '<S242>/Switch1' incorporates:
     *  Logic: '<S194>/Logical20'
     *  Logic: '<S194>/Logical38'
     *  Logic: '<S207>/AND'
     *  Logic: '<S207>/OR1'
     *  Switch: '<S242>/Switch2'
     */
    if ((!VeTPCR_b_HoodAjarEnbl) || ((VeTPCR_b_HoodAjarEnbl) && (!rtb_Switch1_cs)))
    {
        /* Switch: '<S242>/Switch1' incorporates:
         *  Constant: '<S232>/Calib'
         *  Constant: '<S234>/Calib'
         *  Sum: '<S194>/Add1'
         */
        rtb_Switch1_l4 = KeTPCR_t_HoodAjarTmr_CabPrecOff +
            KeTPCR_t_RS_CabPrec_dT;
    }
    else if (VeTPCR_b_HoodAjarEnbl)
    {
        /* Switch: '<S242>/Switch2' incorporates:
         *  Constant: '<S234>/Calib'
         *  Constant: '<S242>/ConstantValue4'
         *  MinMax: '<S242>/Maximum'
         *  Sum: '<S242>/Subtraction'
         *  Switch: '<S242>/Switch1'
         *  UnitDelay: '<S242>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_lk -
                               KeTPCR_t_RS_CabPrec_dT, 0.0F);
    }
    else
    {
        /* Switch: '<S242>/Switch1' incorporates:
         *  Switch: '<S242>/Switch2'
         *  UnitDelay: '<S242>/UnitDelay'
         */
        rtb_Switch1_l4 = TPCR_ac_DW.UnitDelay_DSTATE_lk;
    }

    /* End of Switch: '<S242>/Switch1' */
    /* End of Outputs for SubSystem: '<S194>/EdgeRising7' */

    /* Update for UnitDelay: '<S242>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_lk = rtb_Switch1_l4;

    /* Logic: '<S194>/Logical1' incorporates:
     *  Constant: '<S242>/ConstantValue2'
     *  RelationalOperator: '<S242>/GreaterThan1'
     */
    VeTPCR_b_HoodAjarTime_CabPrec = (rtb_Switch1_l4 <= 0.0F);

    /* End of Outputs for SubSystem: '<S194>/TimerRetriggerResetEnabled1' */

    /* Logic: '<S194>/Logical21' */
    VeTPCR_b_HoodAjarEnblLtch_Rst = VeTPCR_b_DoorAjarEnblLtch_Rst_t;

    /* Outputs for Atomic SubSystem: '<S194>/EdgeRising1' */
    /* Logic: '<S201>/OR1' incorporates:
     *  UnitDelay: '<S201>/UnitDelay'
     */
    rtb_NotEqual_p = !TPCR_ac_DW.UnitDelay_DSTATE_i2e;

    /* Update for UnitDelay: '<S201>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_i2e = VeTPCR_b_HoodAjarEnblLtch_Rst;

    /* Outputs for Atomic SubSystem: '<S194>/SignalLatchOnWithReset5' */
    /* Logic: '<S239>/OR1' incorporates:
     *  Logic: '<S201>/AND'
     *  Logic: '<S239>/NOT'
     *  Logic: '<S239>/OR'
     *  UnitDelay: '<S239>/UnitDelay'
     */
    VeTPCR_b_HoodAjarEnblLtch = ((VeTPCR_b_HoodAjarTime_CabPrec) ||
        (((!VeTPCR_b_HoodAjarEnblLtch_Rst) || (!rtb_NotEqual_p)) &&
         (TPCR_ac_DW.UnitDelay_DSTATE_fta)));

    /* End of Outputs for SubSystem: '<S194>/EdgeRising1' */

    /* Update for UnitDelay: '<S239>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fta = VeTPCR_b_HoodAjarEnblLtch;

    /* End of Outputs for SubSystem: '<S194>/SignalLatchOnWithReset5' */

    /* Logic: '<S194>/Logical14' incorporates:
     *  Constant: '<S221>/Calib'
     */
    VeTPCR_b_HoodOpen_CabPrecOffSt = ((VeTPCR_b_HoodAjarEnblLtch) &&
        (KeTPCR_b_EnblHoodAjar_CabPrecOffChk));

    /* Outputs for Atomic SubSystem: '<S194>/EdgeRising2' */
    /* Logic: '<S202>/AND' incorporates:
     *  Logic: '<S202>/OR1'
     *  UnitDelay: '<S202>/UnitDelay'
     */
    rtb_NotEqual_p = ((VeTPCR_b_SC_WakeUpReq) &&
                      (!TPCR_ac_DW.UnitDelay_DSTATE_er));

    /* Update for UnitDelay: '<S202>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_er = VeTPCR_b_SC_WakeUpReq;

    /* End of Outputs for SubSystem: '<S194>/EdgeRising2' */

    /* Outputs for Atomic SubSystem: '<S194>/EdgeRising3' */
    /* Logic: '<S203>/AND' incorporates:
     *  Logic: '<S203>/OR1'
     *  Logic: '<S8>/Logical1'
     *  UnitDelay: '<S203>/UnitDelay'
     */
    rtb_OR1_ksz = (rtb_LogicalOperator_h0 && (!TPCR_ac_DW.UnitDelay_DSTATE_isk));

    /* Update for UnitDelay: '<S203>/UnitDelay' incorporates:
     *  Logic: '<S8>/Logical1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_isk = rtb_LogicalOperator_h0;

    /* End of Outputs for SubSystem: '<S194>/EdgeRising3' */

    /* Outputs for Atomic SubSystem: '<S194>/EdgeRising9' */
    /* Logic: '<S209>/AND' incorporates:
     *  Logic: '<S209>/OR1'
     *  UnitDelay: '<S209>/UnitDelay'
     */
    Gain_fm = !TPCR_ac_DW.UnitDelay_DSTATE_cm;

    /* Update for UnitDelay: '<S209>/UnitDelay' incorporates:
     *  Constant: '<S194>/TRUEConstant'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_cm = true;

    /* End of Outputs for SubSystem: '<S194>/EdgeRising9' */

    /* Outputs for Atomic SubSystem: '<S194>/TimerRetriggerResetEnabled3' */
    /* Switch: '<S244>/Switch1' incorporates:
     *  Logic: '<S194>/Logical23'
     *  Logic: '<S194>/Logical24'
     *  Switch: '<S244>/Switch2'
     */
    if ((rtb_NotEqual_p || rtb_OR1_ksz) || Gain_fm)
    {
        /* Switch: '<S244>/Switch1' incorporates:
         *  Constant: '<S235>/Calib'
         */
        rtb_Switch1_l4 = KeTPCR_t_RS_NotEnbldDbnc;
    }
    else if (rtb_RelationalOperator_k && rtb_Comparison5)
    {
        /* Switch: '<S244>/Switch2' incorporates:
         *  Constant: '<S234>/Calib'
         *  Constant: '<S244>/ConstantValue4'
         *  MinMax: '<S244>/Maximum'
         *  Sum: '<S244>/Subtraction'
         *  Switch: '<S244>/Switch1'
         *  UnitDelay: '<S244>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_jk -
                               KeTPCR_t_RS_CabPrec_dT, 0.0F);
    }
    else
    {
        /* Switch: '<S244>/Switch1' incorporates:
         *  Switch: '<S244>/Switch2'
         *  UnitDelay: '<S244>/UnitDelay'
         */
        rtb_Switch1_l4 = TPCR_ac_DW.UnitDelay_DSTATE_jk;
    }

    /* Update for UnitDelay: '<S244>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_jk = rtb_Switch1_l4;

    /* Logic: '<S194>/Logical3' incorporates:
     *  Constant: '<S244>/ConstantValue2'
     *  RelationalOperator: '<S244>/GreaterThan1'
     */
    VeTPCR_b_SCWkUp_NoRSTmCabPrecOff = (rtb_Switch1_l4 <= 0.0F);

    /* End of Outputs for SubSystem: '<S194>/TimerRetriggerResetEnabled3' */

    /* Logic: '<S194>/Logical25' incorporates:
     *  Constant: '<S228>/Calib'
     */
    VeTPCR_b_NoRS_SCWkUp_CabPrecOff = ((VeTPCR_b_SCWkUp_NoRSTmCabPrecOff) &&
        (KeTPCR_b_Enbl_SCWkUp_RSDsbld_CabPrecOff));

    /* Logic: '<S194>/Logical2' incorporates:
     *  Constant: '<S212>/Constant'
     *  Constant: '<S225>/Calib'
     *  Logic: '<S8>/Logical1'
     *  RelationalOperator: '<S194>/Comparison10'
     *  RelationalOperator: '<S519>/Comparison1'
     *  Switch: '<S1772>/Switch'
     */
    rtb_NotEqual_p = (((KeTPCR_b_Enbl_CntctrOpen_CabPrecOff) &&
                       rtb_LogicalOperator_h0) && (((uint32)
                        VeTPCR_e_BatCntctrStat) == CeHVTR_e_Open));

    /* Outputs for Atomic SubSystem: '<S194>/EdgeRising5' */
    /* Logic: '<S205>/AND' incorporates:
     *  Logic: '<S205>/OR1'
     *  UnitDelay: '<S205>/UnitDelay'
     */
    rtb_OR1_ksz = (rtb_NotEqual_p && (!TPCR_ac_DW.UnitDelay_DSTATE_el));

    /* Update for UnitDelay: '<S205>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_el = rtb_NotEqual_p;

    /* End of Outputs for SubSystem: '<S194>/EdgeRising5' */

    /* Outputs for Atomic SubSystem: '<S194>/TimerRetriggerResetEnabled4' */
    /* Switch: '<S245>/Switch1' incorporates:
     *  Logic: '<S194>/Logical35'
     *  Logic: '<S194>/Logical5'
     */
    if ((!rtb_NotEqual_p) || rtb_OR1_ksz)
    {
        /* Switch: '<S245>/Switch1' incorporates:
         *  Constant: '<S230>/Calib'
         *  Constant: '<S234>/Calib'
         *  Sum: '<S194>/Add3'
         */
        rtb_Switch1_l4 = KeTPCR_t_CntctrOpen_CabPrecOffDbnc +
            KeTPCR_t_RS_CabPrec_dT;
    }
    else
    {
        /* Switch: '<S245>/Switch1' incorporates:
         *  Constant: '<S234>/Calib'
         *  Constant: '<S245>/ConstantValue4'
         *  MinMax: '<S245>/Maximum'
         *  Sum: '<S245>/Subtraction'
         *  Switch: '<S245>/Switch2'
         *  UnitDelay: '<S245>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_nb -
                               KeTPCR_t_RS_CabPrec_dT, 0.0F);
    }

    /* End of Switch: '<S245>/Switch1' */

    /* Update for UnitDelay: '<S245>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_nb = rtb_Switch1_l4;

    /* Logic: '<S194>/Logical11' incorporates:
     *  Constant: '<S245>/ConstantValue2'
     *  RelationalOperator: '<S245>/GreaterThan1'
     */
    rtb_OR1_ksz = (rtb_Switch1_l4 <= 0.0F);

    /* End of Outputs for SubSystem: '<S194>/TimerRetriggerResetEnabled4' */

    /* Logic: '<S194>/Logical27' incorporates:
     *  Constant: '<S227>/Calib'
     *  Logic: '<S8>/Logical1'
     */
    rtb_NotEqual_p = (((KeTPCR_b_Enbl_LoadShed_CabPrecOff) &&
                       rtb_LogicalOperator_h0) && (VeTPCR_b_ThrmLoad_Shed));

    /* Outputs for Atomic SubSystem: '<S194>/EdgeRising8' */
    /* Logic: '<S208>/AND' incorporates:
     *  Logic: '<S208>/OR1'
     *  UnitDelay: '<S208>/UnitDelay'
     */
    Gain_fm = (rtb_NotEqual_p && (!TPCR_ac_DW.UnitDelay_DSTATE_edi));

    /* Update for UnitDelay: '<S208>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_edi = rtb_NotEqual_p;

    /* End of Outputs for SubSystem: '<S194>/EdgeRising8' */

    /* Outputs for Atomic SubSystem: '<S194>/TimerRetriggerResetEnabled5' */
    /* Switch: '<S246>/Switch1' incorporates:
     *  Logic: '<S194>/Logical28'
     *  Logic: '<S194>/Logical36'
     */
    if ((!rtb_NotEqual_p) || Gain_fm)
    {
        /* Switch: '<S246>/Switch1' incorporates:
         *  Constant: '<S233>/Calib'
         *  Constant: '<S234>/Calib'
         *  Sum: '<S194>/Add4'
         */
        rtb_Switch1_l4 = KeTPCR_t_LoadShed_CabPrecOffDbnc +
            KeTPCR_t_RS_CabPrec_dT;
    }
    else
    {
        /* Switch: '<S246>/Switch1' incorporates:
         *  Constant: '<S234>/Calib'
         *  Constant: '<S246>/ConstantValue4'
         *  MinMax: '<S246>/Maximum'
         *  Sum: '<S246>/Subtraction'
         *  Switch: '<S246>/Switch2'
         *  UnitDelay: '<S246>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_bg -
                               KeTPCR_t_RS_CabPrec_dT, 0.0F);
    }

    /* End of Switch: '<S246>/Switch1' */

    /* Update for UnitDelay: '<S246>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_bg = rtb_Switch1_l4;

    /* Logic: '<S194>/Logical12' incorporates:
     *  Constant: '<S246>/ConstantValue2'
     *  RelationalOperator: '<S246>/GreaterThan1'
     */
    rtb_NotEqual_p = (rtb_Switch1_l4 <= 0.0F);

    /* End of Outputs for SubSystem: '<S194>/TimerRetriggerResetEnabled5' */

    /* Logic: '<S194>/Logical32' incorporates:
     *  Constant: '<S213>/Constant'
     *  Constant: '<S214>/Constant'
     *  Constant: '<S229>/Calib'
     *  Logic: '<S194>/Logical31'
     *  Logic: '<S8>/Logical1'
     *  RelationalOperator: '<S194>/Comparison12'
     *  RelationalOperator: '<S194>/Comparison14'
     *  RelationalOperator: '<S519>/Comparison5'
     *  Switch: '<S1774>/Switch'
     */
    Gain_fm = (((KeTPCR_b_Enbl_TurTlMd_CabPrecOff) && rtb_LogicalOperator_h0) &&
               ((((uint32)VeTPCR_e_TurtleMd) == CeDMDR_e_Turtle_Mode3) ||
                (((uint32)VeTPCR_e_TurtleMd) == CeDMDR_e_Turtle_Mode4)));

    /* Outputs for Atomic SubSystem: '<S194>/EdgeFalling2' */
    /* Logic: '<S198>/AND' incorporates:
     *  UnitDelay: '<S198>/UnitDelay'
     */
    rtb_RelationalOperator_k = (rtb_OR1_lo && (TPCR_ac_DW.UnitDelay_DSTATE_d3));

    /* Update for UnitDelay: '<S198>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_d3 = rtb_Comparison5;

    /* End of Outputs for SubSystem: '<S194>/EdgeFalling2' */

    /* Outputs for Atomic SubSystem: '<S194>/EdgeFalling3' */
    /* Logic: '<S199>/AND' incorporates:
     *  Logic: '<S199>/OR1'
     *  UnitDelay: '<S194>/UnitDelay2'
     *  UnitDelay: '<S199>/UnitDelay'
     */
    rtb_Comparison5 = ((!TPCR_ac_DW.UnitDelay2_DSTATE_i) &&
                       (TPCR_ac_DW.UnitDelay_DSTATE_mb));

    /* Update for UnitDelay: '<S199>/UnitDelay' incorporates:
     *  UnitDelay: '<S194>/UnitDelay2'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_mb = TPCR_ac_DW.UnitDelay2_DSTATE_i;

    /* End of Outputs for SubSystem: '<S194>/EdgeFalling3' */

    /* Outputs for Atomic SubSystem: '<S194>/EdgeRising4' */
    /* Logic: '<S204>/OR1' incorporates:
     *  UnitDelay: '<S204>/UnitDelay'
     */
    rtb_OR1_lo = !TPCR_ac_DW.UnitDelay_DSTATE_nkn;

    /* Update for UnitDelay: '<S204>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_nkn = VeTPCR_b_DoorAjarEnblLtch_Rst_t;

    /* Outputs for Atomic SubSystem: '<S194>/SignalLatchOnWithReset1' */
    /* Logic: '<S237>/OR1' incorporates:
     *  Constant: '<S219>/Calib'
     *  Logic: '<S194>/Logical34'
     *  Logic: '<S204>/AND'
     *  Logic: '<S237>/NOT'
     *  Logic: '<S237>/OR'
     *  UnitDelay: '<S237>/UnitDelay'
     */
    VeTPCR_b_RmtStartReqDrop = (((rtb_RelationalOperator_k && rtb_Comparison5) &&
        (KeTPCR_b_EnblCBCDropAbort)) || (((!VeTPCR_b_DoorAjarEnblLtch_Rst_t) ||
        (!rtb_OR1_lo)) && (TPCR_ac_DW.UnitDelay_DSTATE_hi)));

    /* End of Outputs for SubSystem: '<S194>/EdgeRising4' */

    /* Update for UnitDelay: '<S237>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_hi = VeTPCR_b_RmtStartReqDrop;

    /* End of Outputs for SubSystem: '<S194>/SignalLatchOnWithReset1' */

    /* Logic: '<S194>/Logical39' incorporates:
     *  Constant: '<S215>/Constant'
     *  Constant: '<S216>/Constant'
     *  Constant: '<S226>/Calib'
     *  Logic: '<S194>/Logical40'
     *  Logic: '<S194>/Logical41'
     *  RelationalOperator: '<S194>/Comparison3'
     *  RelationalOperator: '<S194>/Comparison4'
     *  RelationalOperator: '<S519>/Comparison12'
     *  Switch: '<S1763>/Switch1'
     */
    rtb_RelationalOperator_k = (((KeTPCR_b_Enbl_FOTA_CabPrecOff) &&
        ((VeTPCR_b_SC_WakeUpReq) || (VeTPCR_b_FOTAReject_AftrMrg))) &&
        ((((uint32)VeTPCR_e_FOTAInstallType) == CeCITR_e_FOTANow) || (((uint32)
        VeTPCR_e_FOTAInstallType) == CeCITR_e_FOTASchedule)));

    /* Logic: '<S194>/Logical43' incorporates:
     *  Constant: '<S217>/Constant'
     *  Constant: '<S224>/Calib'
     *  RelationalOperator: '<S194>/Comparison5'
     *  Switch: '<S1780>/Switch'
     */
    VeTPCR_b_V2LActv_SCCRSDsbl = ((VeTPCR_b_DoorAjarEnblLtch_Rst_t && (((uint32)
        VeTPCR_e_DschrgSysSts_AD) == CeVTLR_e_DschrgActv)) &&
        (KeTPCR_b_EnblV2L_SCCRS_CabPrecOff));

    /* Logic: '<S194>/Logical13' incorporates:
     *  Constant: '<S250>/Calib'
     *  Constant: '<S251>/Calib'
     *  Constant: '<S256>/Calib'
     *  Logic: '<S240>/Logical1'
     *  Logic: '<S240>/Logical2'
     *  Logic: '<S240>/Logical27'
     *  Logic: '<S241>/Logical1'
     *  Logic: '<S241>/Logical2'
     *  Logic: '<S241>/Logical5'
     *  UnitDelay: '<S4>/UnitDelay'
     */
    VeTPCR_b_CabPrecOffCond = (((((((((((rtb_Switch2_du ||
        (((VeTPCR_b_CabPrecOff_CBCDbnc) || (KeTPCR_b_EnblRSTmr_AftrSC)) &&
         ((VeTPCR_b_DepTimeBigChngLtch) || (VeTPCR_b_TmrExpiredAfterDepTim)))) ||
        (((((VeTPCR_b_HVBatPerWkUp) && VeTPCR_b_DoorAjarEnblLtch_Rst_t) &&
           (KeTPCR_b_Enbl_PerWupThrml_RSOff)) && rtb_Switch1_im) ||
         (((TPCR_ac_DW.UnitDelay_DSTATE_kj) && VeTPCR_b_DoorAjarEnblLtch_Rst_t) &&
          (KeTPCR_b_Enbl_BattCond_RSOff)))) || (VeTPCR_b_DoorOpen_CabPrecOffSt))
        || (VeTPCR_b_HoodOpen_CabPrecOffSt)) || (VeTPCR_b_NoRS_SCWkUp_CabPrecOff))
        || rtb_OR1_ksz) || rtb_NotEqual_p) || Gain_fm) ||
        (VeTPCR_b_RmtStartReqDrop)) || rtb_RelationalOperator_k) ||
        (VeTPCR_b_V2LActv_SCCRSDsbl));

    /* Logic: '<S104>/Logical2' incorporates:
     *  Logic: '<S103>/Logical2'
     *  Logic: '<S95>/Logical7'
     *  Logic: '<S96>/Logical7'
     *  Logic: '<S98>/Logical7'
     *  UnitDelay: '<S64>/UnitDelay4'
     */
    rtb_Switch1_im = !TPCR_ac_DW.UnitDelay4_DSTATE_lj;

    /* Logic: '<S104>/Logical7' incorporates:
     *  Logic: '<S102>/Logical8'
     *  Logic: '<S95>/Logical8'
     *  Logic: '<S96>/Logical8'
     *  Logic: '<S98>/Logical8'
     */
    rtb_OR1_lo = !VeTPCR_b_BattCondStop;

    /* Logic: '<S104>/Logical15' incorporates:
     *  Logic: '<S95>/Logical11'
     *  Logic: '<S96>/Logical11'
     *  Logic: '<S97>/Logical5'
     */
    rtb_Switch1_cs = !VeTPCC_b_RS_NoCabPrecond_NoPlugLtch;

    /* Logic: '<S104>/Logical1' incorporates:
     *  Constant: '<S188>/Calib'
     *  Constant: '<S190>/Calib'
     *  Logic: '<S104>/Logical14'
     *  Logic: '<S104>/Logical15'
     *  Logic: '<S104>/Logical2'
     *  Logic: '<S104>/Logical7'
     */
    VeTPCR_b_RS_NoCabPrecond_CabPrecOff = (((((((((VeTPCR_b_CabPrecOffCond) &&
        rtb_Switch1_cs) && VeTPCC_b_RS_NoCabPrecond_NoPl_0) &&
        (rtb_LogicalOperator1_kl_tmp || (KeTPCR_b_Dsbl_BattCondChk_RSOff))) &&
        rtb_Switch1_im) && rtb_OR1_lo) && rtb_UnitDelay4_k) &&
        VeTPCC_b_RS_NoCabPrecond_NoPl_1) && (KeTPCR_b_Enbl_CabPrec_Off));

    /* Outputs for Atomic SubSystem: '<S104>/EdgeRising' */
    /* Logic: '<S187>/AND' incorporates:
     *  Logic: '<S187>/OR1'
     *  UnitDelay: '<S187>/UnitDelay'
     */
    rtb_Comparison5 = ((VeTPCR_b_RS_NoCabPrecond_CabPrecOff) &&
                       (!TPCR_ac_DW.UnitDelay_DSTATE_awo));

    /* Update for UnitDelay: '<S187>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_awo = VeTPCR_b_RS_NoCabPrecond_CabPrecOff;

    /* End of Outputs for SubSystem: '<S104>/EdgeRising' */

    /* Switch: '<S104>/Switch' incorporates:
     *  Constant: '<S189>/Calib'
     */
    if (!KeTPCR_b_EnblEdge_CabPrecOff)
    {
        rtb_Comparison5 = VeTPCR_b_RS_NoCabPrecond_CabPrecOff;
    }

    /* End of Switch: '<S104>/Switch' */

    /* Outputs for Atomic SubSystem: '<S104>/SignalLatchOnWithReset' */
    /* Logic: '<S193>/OR1' incorporates:
     *  Logic: '<S193>/NOT'
     *  Logic: '<S193>/OR'
     *  UnitDelay: '<S104>/UnitDelay'
     *  UnitDelay: '<S193>/UnitDelay'
     */
    VeTPCR_b_RS_NoCabPrecond_CabPrecOffLtch = (rtb_Comparison5 ||
        ((!TPCR_ac_DW.UnitDelay_DSTATE_k0) && (TPCR_ac_DW.UnitDelay_DSTATE_bpm)));

    /* Update for UnitDelay: '<S193>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_bpm = VeTPCR_b_RS_NoCabPrecond_CabPrecOffLtch;

    /* End of Outputs for SubSystem: '<S104>/SignalLatchOnWithReset' */

    /* Logic: '<S96>/Logical5' incorporates:
     *  Logic: '<S95>/Logical14'
     */
    rtb_Comparison5 = !VeTPCR_b_RS_NoCabPrecond_CabPrecOffLtch;

    /* Logic: '<S96>/Logical1' incorporates:
     *  Constant: '<S115>/Constant'
     *  Constant: '<S116>/Constant'
     *  Constant: '<S117>/Calib'
     *  Constant: '<S118>/Calib'
     *  Logic: '<S8>/Logical1'
     *  Logic: '<S96>/Logical2'
     *  Logic: '<S96>/Logical4'
     *  Logic: '<S96>/Logical5'
     *  RelationalOperator: '<S96>/Comparison1'
     *  RelationalOperator: '<S96>/Comparison2'
     *  RelationalOperator: '<S99>/Comparison3'
     *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
     *  Switch: '<S1764>/Switch'
     */
    VeTPCR_b_RS_CabPrecondSPR = ((((((((((((rtb_LogicalOperator_h0 || (((uint32)
        VeTPCR_e_BCMPreCondCabinReq) == CePLTR_e_CabinPreCondStrt)) &&
        rtb_Switch3_o) && (((uint32)TPCR_ac_B.TmpSignalConversionAtTmpVM__ate) ==
                           CeTRIR_e_HVAC_SPR)) &&
        VeTPCC_b_RS_NoCabPrecond_NoPl_0) && ((KeTPCR_b_Dsbl_BattCondChk_RSSPR) ||
        rtb_LogicalOperator1_kl_tmp)) && rtb_Switch1_im) && rtb_OR1_lo) &&
        rtb_UnitDelay4_k) && VeTPCC_b_RS_NoCabPrecond_NoPl_1) && rtb_Switch1_cs)
        && rtb_Comparison5) && (KeTPCR_b_Enbl_OkToPreCond_RS));

    /* Logic: '<S95>/Logical1' incorporates:
     *  Constant: '<S111>/Constant'
     *  Constant: '<S112>/Calib'
     *  Constant: '<S113>/Calib'
     *  Logic: '<S8>/Logical1'
     *  Logic: '<S95>/Logical2'
     *  Logic: '<S95>/Logical4'
     *  Logic: '<S95>/Logical5'
     *  RelationalOperator: '<S95>/Comparison1'
     *  RelationalOperator: '<S99>/Comparison3'
     *  Switch: '<S1764>/Switch'
     */
    VeTPCR_b_RS_CabPrecondOk = ((((((((((((rtb_LogicalOperator_h0 || (((uint32)
        VeTPCR_e_BCMPreCondCabinReq) == CePLTR_e_CabinPreCondStrt)) &&
        rtb_Switch3_o) && VeTPCC_b_RS_NoCabPrecond_NoPl_0) &&
        ((KeTPCR_b_Dsbl_BattCondChk_RSOK) || rtb_LogicalOperator1_kl_tmp)) &&
        rtb_Switch1_im) && rtb_OR1_lo) && rtb_UnitDelay4_k) &&
        VeTPCC_b_RS_NoCabPrecond_NoPl_1) && rtb_Switch1_cs) &&
        (!VeTPCR_b_RS_CabPrecondSPR)) && rtb_Comparison5) &&
        (KeTPCR_b_Enbl_OkToPreCond_RS));

    /* Logic: '<S98>/Logical4' incorporates:
     *  Logic: '<S8>/Logical1'
     *  Logic: '<S97>/Logical1'
     */
    rtb_Comparison5 = ((VeTPCR_b_SC_WakeUpReq) || rtb_LogicalOperator_h0);

    /* Logic: '<S98>/Logical4' incorporates:
     *  Constant: '<S132>/Constant'
     *  RelationalOperator: '<S98>/Comparison1'
     *  RelationalOperator: '<S99>/Comparison3'
     *  Switch: '<S1764>/Switch'
     */
    VeTPCR_b_LtchRS_BattCrit = (rtb_Comparison5 || (((uint32)
        VeTPCR_e_BCMPreCondCabinReq) == CePLTR_e_CabinPreCondStrt));

    /* Switch: '<S130>/Switch1' incorporates:
     *  Constant: '<S130>/TRUEConstant'
     *  Constant: '<S139>/Constant'
     *  Constant: '<S140>/Constant'
     *  Constant: '<S141>/Constant'
     *  Constant: '<S142>/Calib'
     *  Logic: '<S130>/Logical2'
     *  RelationalOperator: '<S130>/Comparison3'
     *  RelationalOperator: '<S130>/Comparison4'
     *  RelationalOperator: '<S130>/Comparison6'
     */
    if (KeTPCR_b_Enbl_BattTmpCrit_Chk)
    {
        /* RelationalOperator: '<S130>/Comparison4' incorporates:
         *  RelationalOperator: '<S130>/Comparison3'
         *  RelationalOperator: '<S130>/Comparison6'
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        rtb_Switch3_dh_tmp = TPCR_ac_B.TmpSignalConversionAtTmpVM__gr1;
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = (((((uint32)rtb_Switch3_dh_tmp) ==
            CeBTRR_e_BatOutOfRng) || (((uint32)rtb_Switch3_dh_tmp) ==
            CeBTRR_e_BatCrit)) || (((uint32)rtb_Switch3_dh_tmp) ==
            CeBTRR_e_BatCritErrSt));
    }
    else
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = true;
    }

    /* End of Switch: '<S130>/Switch1' */

    /* Logic: '<S98>/Logical1' incorporates:
     *  Constant: '<S133>/Calib'
     *  Constant: '<S134>/Calib'
     *  Logic: '<S98>/Logical2'
     */
    VeTPCR_b_RS_NoCabPrecond_BattCrit = ((((((((VeTPCR_b_LtchRS_BattCrit) &&
        VeTPCR_b_DoorAjarEnblLtch_Rst_t) && VeTPCC_b_RS_NoCabPrecond_NoPl_0) &&
        ((VeTPCR_b_BattCondOn) || (KeTPCR_b_Dsbl_BattCondChk_RSBattCrit))) &&
        rtb_Switch1_im) && rtb_OR1_lo) && VeTPCC_b_RS_NoCabPrecond_NoPl_1) &&
        (KeTPCR_b_Enbl_NoCabPrec_BattCrit));

    /* Outputs for Atomic SubSystem: '<S98>/SignalLatchOnWithReset' */
    /* Logic: '<S137>/OR1' incorporates:
     *  Logic: '<S137>/NOT'
     *  Logic: '<S137>/OR'
     *  UnitDelay: '<S137>/UnitDelay'
     *  UnitDelay: '<S98>/UnitDelay'
     */
    VeTPCR_b_RS_NoCabPrecond_BattCritLtch = ((VeTPCR_b_RS_NoCabPrecond_BattCrit)
        || ((!TPCR_ac_DW.UnitDelay_DSTATE_bx) && (TPCR_ac_DW.UnitDelay_DSTATE_pj)));

    /* Update for UnitDelay: '<S137>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_pj = VeTPCR_b_RS_NoCabPrecond_BattCritLtch;

    /* End of Outputs for SubSystem: '<S98>/SignalLatchOnWithReset' */

    /* Logic: '<S97>/Logical3' incorporates:
     *  Constant: '<S120>/Constant'
     *  Constant: '<S121>/Calib'
     *  Constant: '<S122>/Calib'
     *  Constant: '<S123>/Calib'
     *  Constant: '<S124>/Calib'
     *  Logic: '<S97>/Logical1'
     *  Logic: '<S97>/Logical2'
     *  Logic: '<S97>/Logical4'
     *  Logic: '<S97>/Logical6'
     *  Logic: '<S97>/Logical7'
     *  RelationalOperator: '<S97>/Comparison1'
     *  RelationalOperator: '<S99>/Comparison3'
     *  Switch: '<S1764>/Switch'
     */
    VeTPCC_b_RS_NoCabPrecond_Flt = ((((((rtb_Comparison5 || (((uint32)
        VeTPCR_e_BCMPreCondCabinReq) == CePLTR_e_CabinPreCondStrt)) &&
        rtb_LogicalOperator_gy) && (rtb_UnitDelay4_k ||
        (KeTPCR_b_Dsbl_SOCChk_RSThrmlFlts))) && (VeTPCC_b_RS_NoCabPrecond_NoPl_1
        || (KeTPCR_b_Dsbl_RSSNA_RSThrmlFlts))) && (rtb_Switch1_cs ||
        (KeTPCR_b_Dsbl_NotPlug_RSThrmlFlts))) && (KeTPCR_b_Enbl_NoCabPrec_Flt));

    /* Outputs for Atomic SubSystem: '<S97>/SignalLatchOnWithReset' */
    /* Logic: '<S127>/OR1' incorporates:
     *  Logic: '<S127>/NOT'
     *  Logic: '<S127>/OR'
     *  UnitDelay: '<S127>/UnitDelay'
     *  UnitDelay: '<S97>/UnitDelay'
     */
    VeTPCC_b_RS_NoCabPrecond_FltLtch = ((VeTPCC_b_RS_NoCabPrecond_Flt) ||
        ((!TPCR_ac_DW.UnitDelay_DSTATE_br) && (TPCR_ac_DW.UnitDelay_DSTATE_hg)));

    /* Update for UnitDelay: '<S127>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_hg = VeTPCC_b_RS_NoCabPrecond_FltLtch;

    /* End of Outputs for SubSystem: '<S97>/SignalLatchOnWithReset' */

    /* Outputs for Atomic SubSystem: '<S102>/EdgeFalling2' */
    /* Logic: '<S177>/AND' incorporates:
     *  Logic: '<S177>/OR1'
     *  UnitDelay: '<S177>/UnitDelay'
     */
    rtb_Comparison5 = ((!VeTPCR_b_RS_NoCabPrecond_BattCritLtch) &&
                       (TPCR_ac_DW.UnitDelay_DSTATE_doq));

    /* Update for UnitDelay: '<S177>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_doq = VeTPCR_b_RS_NoCabPrecond_BattCritLtch;

    /* End of Outputs for SubSystem: '<S102>/EdgeFalling2' */

    /* Outputs for Atomic SubSystem: '<S102>/EdgeFalling3' */
    /* Switch: '<S988>/Switch1' incorporates:
     *  UnitDelay: '<S178>/UnitDelay'
     */
    rtb_Switch1_cs = TPCR_ac_DW.UnitDelay_DSTATE_d3c;

    /* Update for UnitDelay: '<S178>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_d3c = VeTPCR_b_HCPShutDwnCmd;

    /* Outputs for Atomic SubSystem: '<S102>/SignalLatchOnWithReset1' */
    /* Logic: '<S182>/OR1' incorporates:
     *  Logic: '<S178>/AND'
     *  Logic: '<S178>/OR1'
     *  Logic: '<S182>/NOT'
     *  Logic: '<S182>/OR'
     *  UnitDelay: '<S182>/UnitDelay'
     */
    VeTPCR_b_OutOfBattCrit = (rtb_Comparison5 || (((VeTPCR_b_HCPShutDwnCmd) || (
        !rtb_Switch1_cs)) && (TPCR_ac_DW.UnitDelay_DSTATE_o0)));

    /* End of Outputs for SubSystem: '<S102>/EdgeFalling3' */

    /* Update for UnitDelay: '<S182>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_o0 = VeTPCR_b_OutOfBattCrit;

    /* End of Outputs for SubSystem: '<S102>/SignalLatchOnWithReset1' */

    /* Logic: '<S102>/Logical1' incorporates:
     *  Constant: '<S179>/Constant'
     *  Constant: '<S180>/Calib'
     *  Constant: '<S181>/Calib'
     *  Logic: '<S102>/Logical2'
     *  Logic: '<S102>/Logical4'
     *  RelationalOperator: '<S102>/Comparison1'
     *  RelationalOperator: '<S99>/Comparison3'
     *  Switch: '<S1764>/Switch'
     */
    VeTPCR_b_RS_BattCondCmplt = ((((((((((VeTPCR_b_OutOfBattCrit) || (((uint32)
        VeTPCR_e_BCMPreCondCabinReq) == CePLTR_e_CabinPreCondStrt)) &&
        rtb_Switch3_o) && VeTPCC_b_RS_NoCabPrecond_NoPl_0) &&
        ((KeTPCR_b_Dsbl_BattCondChk_RSBattCmplt) || rtb_LogicalOperator1_kl_tmp))
        && (VeTPCR_b_BattCondCmplt)) && rtb_OR1_lo) && rtb_UnitDelay4_k) &&
        VeTPCC_b_RS_NoCabPrecond_NoPl_1) && (KeTPCR_b_Enbl_CabPrec_BattCondCmplt));

    /* Logic: '<S103>/Logical1' incorporates:
     *  Constant: '<S184>/Constant'
     *  Constant: '<S185>/Calib'
     *  RelationalOperator: '<S103>/Comparison1'
     *  RelationalOperator: '<S99>/Comparison3'
     *  Switch: '<S1764>/Switch'
     */
    VeTPCR_b_RS_BattCondStop = (((((((((uint32)VeTPCR_e_BCMPreCondCabinReq) ==
        CePLTR_e_CabinPreCondStop) && VeTPCC_b_RS_NoCabPrecond_NoPl_0) &&
        rtb_LogicalOperator1_kl_tmp) && rtb_Switch1_im) &&
        (VeTPCR_b_BattCondStop)) && VeTPCC_b_RS_NoCabPrecond_NoPl_1) &&
        (KeTPCR_b_Enbl_CabPrec_BattCondStop));

    /* Logic: '<S100>/Logical3' incorporates:
     *  Constant: '<S156>/Constant'
     *  Constant: '<S157>/Calib'
     *  Constant: '<S158>/Calib'
     *  Constant: '<S159>/Calib'
     *  Constant: '<S160>/Calib'
     *  Logic: '<S100>/Logical10'
     *  Logic: '<S100>/Logical4'
     *  Logic: '<S100>/Logical5'
     *  Logic: '<S100>/Logical8'
     *  Logic: '<S100>/Logical9'
     *  Logic: '<S8>/Logical1'
     *  RelationalOperator: '<S100>/Comparison1'
     *  RelationalOperator: '<S99>/Comparison3'
     *  Switch: '<S1764>/Switch'
     */
    VeTPCC_b_RS_NoCabPrecond_SOC = ((((((((((uint32)VeTPCR_e_BCMPreCondCabinReq)
        == CePLTR_e_CabinPreCondStrt) || ((VeTPCR_b_PrecWarningMsg_AftrMrg) &&
        (KeTPCR_b_Enbl_PrecMsg_RSSOCChk))) || (VeTPCR_b_SC_WakeUpReq)) ||
        rtb_LogicalOperator_h0) && (VeTPCC_b_RS_NoCabPrecond_NoPl_0 ||
        (KeTPCR_b_DsblFltsChk_CabPrecSOC))) && ((VeTPCR_b_SOCRejected_AS) &&
        ((VeTPCC_b_VhclPlgdIn) || (KeTPCR_b_DsblPlugInChk_CabPrecSOC)))) &&
        VeTPCC_b_RS_NoCabPrecond_NoPl_1) && (KeTPCR_b_Enbl_NoCabPrec_SOC));

    /* Outputs for Atomic SubSystem: '<S100>/SignalLatchOnWithReset' */
    /* Logic: '<S163>/OR1' incorporates:
     *  Logic: '<S163>/NOT'
     *  Logic: '<S163>/OR'
     *  UnitDelay: '<S100>/UnitDelay'
     *  UnitDelay: '<S163>/UnitDelay'
     */
    VeTPCC_b_RS_NoCabPrecond_SOCLtch = ((VeTPCC_b_RS_NoCabPrecond_SOC) ||
        ((!TPCR_ac_DW.UnitDelay_DSTATE_jgq) && (TPCR_ac_DW.UnitDelay_DSTATE_c4)));

    /* Update for UnitDelay: '<S163>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_c4 = VeTPCC_b_RS_NoCabPrecond_SOCLtch;

    /* End of Outputs for SubSystem: '<S100>/SignalLatchOnWithReset' */

    /* Outputs for Atomic SubSystem: '<S65>/CountDownResetTriggerEnabled' */
    /* Outputs for Atomic SubSystem: '<S271>/EdgeRising' */
    /* Logic: '<S273>/OR1' incorporates:
     *  UnitDelay: '<S273>/UnitDelay'
     */
    rtb_Comparison5 = !TPCR_ac_DW.UnitDelay_DSTATE_be;

    /* Update for UnitDelay: '<S273>/UnitDelay' incorporates:
     *  Constant: '<S65>/TRUEConstant1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_be = true;

    /* Switch: '<S271>/Switch1' incorporates:
     *  Constant: '<S271>/ConstantValue'
     *  Logic: '<S273>/AND'
     *  RelationalOperator: '<S271>/GreaterThan'
     *  Switch: '<S271>/Switch2'
     *  UnitDelay: '<S271>/UnitDelay'
     */
    if (rtb_Comparison5)
    {
        /* Switch: '<S271>/Switch1' incorporates:
         *  Constant: '<S272>/Calib'
         */
        rtb_Switch1_g1 = KeTPCR_t_RS_LogicWaitTim;
    }
    else if (((sint32)TPCR_ac_DW.UnitDelay_DSTATE_gr) > 0)
    {
        /* Switch: '<S271>/Switch2' incorporates:
         *  Constant: '<S271>/ConstantValue1'
         *  Sum: '<S271>/Subtraction'
         *  Switch: '<S271>/Switch1'
         *  UnitDelay: '<S271>/UnitDelay'
         */
        rtb_Switch1_g1 = (uint16)((sint32)(((sint32)
            TPCR_ac_DW.UnitDelay_DSTATE_gr) - 1));
    }
    else
    {
        /* Switch: '<S271>/Switch1' incorporates:
         *  Switch: '<S271>/Switch2'
         *  UnitDelay: '<S271>/UnitDelay'
         */
        rtb_Switch1_g1 = TPCR_ac_DW.UnitDelay_DSTATE_gr;
    }

    /* End of Switch: '<S271>/Switch1' */
    /* End of Outputs for SubSystem: '<S271>/EdgeRising' */

    /* RelationalOperator: '<S271>/GreaterThan1' incorporates:
     *  Constant: '<S271>/ConstantValue2'
     */
    VeTPCR_b_RSStDsbl_App1 = (((sint32)rtb_Switch1_g1) > 0);

    /* Update for UnitDelay: '<S271>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_gr = rtb_Switch1_g1;

    /* End of Outputs for SubSystem: '<S65>/CountDownResetTriggerEnabled' */

    /* Logic: '<S65>/Logical2' */
    VeTPCR_b_RSStEnbl_App1 = !VeTPCR_b_RSStDsbl_App1;

    /* Outputs for Enabled SubSystem: '<S8>/RemoteStart_States' incorporates:
     *  EnablePort: '<S67>/Enable'
     */
    if (VeTPCR_b_RSStEnbl_App1)
    {
        TPCR_ac_DW.RemoteStart_States_MODE = true;

        /* If: '<S67>/If' */
        rtPrevAction = TPCR_ac_DW.If_ActiveSubsystem_j;
        if (VeTPCR_b_RS_CabPrecondOk)
        {
            rtAction = 0;
        }
        else if (VeTPCR_b_RS_NoCabPrecond_BattCritLtch)
        {
            rtAction = 1;
        }
        else if (VeTPCC_b_RS_NoCabPrecond_FltLtch)
        {
            rtAction = 2;
        }
        else if (VeTPCC_b_RS_NoCabPrecond_SOCLtch)
        {
            rtAction = 3;
        }
        else if (VeTPCC_b_RS_NoCabPrecond_NoPlugLtch)
        {
            rtAction = 4;
        }
        else if (VeTPCR_b_RS_CabPrecondSPR)
        {
            rtAction = 5;
        }
        else if (VeTPCR_b_RS_BattCondCmplt)
        {
            rtAction = 6;
        }
        else if (VeTPCR_b_RS_BattCondStop)
        {
            rtAction = 7;
        }
        else if (VeTPCR_b_RS_NoCabPrecond_CabPrecOffLtch)
        {
            rtAction = 8;
        }
        else if (VeTPCC_b_RS_NoCabPrecond_SNA)
        {
            rtAction = 9;
        }
        else
        {
            rtAction = 10;
        }

        TPCR_ac_DW.If_ActiveSubsystem_j = rtAction;
        switch (rtAction)
        {
          case 0:
            /* Outputs for IfAction SubSystem: '<S67>/CabPrec_State' incorporates:
             *  ActionPort: '<S277>/ActionPort'
             */
            /* Merge: '<S67>/Merge' incorporates:
             *  Constant: '<S291>/Constant'
             *  SignalConversion generated from: '<S277>/OkCabPrec'
             */
            TPCR_ac_B.VeTPCC_e_CabinPreCondReqStat_Ap = CeTPCR_e_OkCabinPrec;

            /* Merge: '<S67>/Merge1' incorporates:
             *  Constant: '<S292>/Calib'
             *  SignalConversion generated from: '<S277>/ThrmlRdy_SDwn_CabPrecOk'
             */
            VeTPCC_b_RS_ThrmlRdyShtDwn_AftMrg = KeTPCR_b_ThrRdyShtdwn_CabPrecOk;

            /* End of Outputs for SubSystem: '<S67>/CabPrec_State' */
            break;

          case 1:
            if (rtAction != rtPrevAction)
            {
                /* SystemReset for IfAction SubSystem: '<S67>/CabPrec_State1' incorporates:
                 *  ActionPort: '<S278>/ActionPort'
                 */
                /* SystemReset for Atomic SubSystem: '<S278>/TurnOnDelayTime' */
                /* SystemReset for If: '<S67>/If' incorporates:
                 *  UnitDelay: '<S295>/UnitDelay'
                 *  UnitDelay: '<S296>/UnitDelay'
                 */
                TPCR_ac_DW.UnitDelay_DSTATE_bp = 0.0F;

                /* SystemReset for Atomic SubSystem: '<S295>/EdgeRising' */
                TPCR_ac_DW.UnitDelay_DSTATE_jd = false;

                /* End of SystemReset for SubSystem: '<S295>/EdgeRising' */
                /* End of SystemReset for SubSystem: '<S278>/TurnOnDelayTime' */
                /* End of SystemReset for SubSystem: '<S67>/CabPrec_State1' */
            }

            /* Outputs for IfAction SubSystem: '<S67>/CabPrec_State1' incorporates:
             *  ActionPort: '<S278>/ActionPort'
             */
            /* Merge: '<S67>/Merge' incorporates:
             *  Constant: '<S293>/Constant'
             *  SignalConversion generated from: '<S278>/NoCabPrec_BatCrit'
             */
            TPCR_ac_B.VeTPCC_e_CabinPreCondReqStat_Ap =
                CeTPCR_e_NoCabPrec_HV_BatCrit;

            /* Outputs for Atomic SubSystem: '<S278>/TurnOnDelayTime' */
            /* Outputs for Atomic SubSystem: '<S295>/EdgeRising' */
            /* Logic: '<S296>/AND' incorporates:
             *  Constant: '<S294>/Calib'
             *  Logic: '<S296>/OR1'
             *  UnitDelay: '<S296>/UnitDelay'
             */
            rtb_Comparison5 = ((KeTPCR_b_ThrRdyShtdwn_CabPrecBatCrit) &&
                               (!TPCR_ac_DW.UnitDelay_DSTATE_jd));

            /* Update for UnitDelay: '<S296>/UnitDelay' incorporates:
             *  Constant: '<S294>/Calib'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_jd =
                KeTPCR_b_ThrRdyShtdwn_CabPrecBatCrit;

            /* End of Outputs for SubSystem: '<S295>/EdgeRising' */

            /* Switch: '<S295>/Switch1' incorporates:
             *  Constant: '<S294>/Calib'
             *  Logic: '<S295>/OR'
             *  Logic: '<S295>/OR1'
             */
            if ((!KeTPCR_b_ThrRdyShtdwn_CabPrecBatCrit) || rtb_Comparison5)
            {
                /* Switch: '<S295>/Switch1' incorporates:
                 *  Constant: '<S295>/ConstantValue1'
                 */
                rtb_Switch1_l4 = 0.0F;
            }
            else
            {
                /* Switch: '<S295>/Switch1' incorporates:
                 *  Constant: '<S289>/Calib'
                 *  Constant: '<S290>/Calib'
                 *  MinMax: '<S295>/Minimum'
                 *  Sum: '<S295>/Summation'
                 *  UnitDelay: '<S295>/UnitDelay'
                 */
                rtb_Switch1_l4 = fminf(KeTPCR_t_RS_CabPrec_delayTime,
                                       KeTPCR_t_RS_CabPrec_dT +
                                       TPCR_ac_DW.UnitDelay_DSTATE_bp);
            }

            /* End of Switch: '<S295>/Switch1' */

            /* Merge: '<S67>/Merge1' incorporates:
             *  Constant: '<S290>/Calib'
             *  Constant: '<S294>/Calib'
             *  Logic: '<S295>/AND'
             *  RelationalOperator: '<S295>/GreaterThan'
             */
            VeTPCC_b_RS_ThrmlRdyShtDwn_AftMrg =
                ((KeTPCR_b_ThrRdyShtdwn_CabPrecBatCrit) && (rtb_Switch1_l4 >=
                  KeTPCR_t_RS_CabPrec_delayTime));

            /* Update for UnitDelay: '<S295>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_bp = rtb_Switch1_l4;

            /* End of Outputs for SubSystem: '<S278>/TurnOnDelayTime' */
            /* End of Outputs for SubSystem: '<S67>/CabPrec_State1' */
            break;

          case 2:
            if (rtAction != rtPrevAction)
            {
                /* SystemReset for IfAction SubSystem: '<S67>/CabPrec_State2' incorporates:
                 *  ActionPort: '<S280>/ActionPort'
                 */
                /* SystemReset for Atomic SubSystem: '<S280>/TurnOnDelayTime' */
                /* SystemReset for If: '<S67>/If' incorporates:
                 *  UnitDelay: '<S303>/UnitDelay'
                 *  UnitDelay: '<S304>/UnitDelay'
                 */
                TPCR_ac_DW.UnitDelay_DSTATE_b3 = 0.0F;

                /* SystemReset for Atomic SubSystem: '<S303>/EdgeRising' */
                TPCR_ac_DW.UnitDelay_DSTATE_oi = false;

                /* End of SystemReset for SubSystem: '<S303>/EdgeRising' */
                /* End of SystemReset for SubSystem: '<S280>/TurnOnDelayTime' */
                /* End of SystemReset for SubSystem: '<S67>/CabPrec_State2' */
            }

            /* Outputs for IfAction SubSystem: '<S67>/CabPrec_State2' incorporates:
             *  ActionPort: '<S280>/ActionPort'
             */
            /* Merge: '<S67>/Merge' incorporates:
             *  Constant: '<S301>/Constant'
             *  SignalConversion generated from: '<S280>/NoCabPrec_Failed'
             */
            TPCR_ac_B.VeTPCC_e_CabinPreCondReqStat_Ap = CeTPCR_e_NoCabPrec_Flts;

            /* Outputs for Atomic SubSystem: '<S280>/TurnOnDelayTime' */
            /* Outputs for Atomic SubSystem: '<S303>/EdgeRising' */
            /* Logic: '<S304>/AND' incorporates:
             *  Constant: '<S302>/Calib'
             *  Logic: '<S304>/OR1'
             *  UnitDelay: '<S304>/UnitDelay'
             */
            rtb_Comparison5 = ((KeTPCR_b_ThrRdyShtdwn_CabPrecFail) &&
                               (!TPCR_ac_DW.UnitDelay_DSTATE_oi));

            /* Update for UnitDelay: '<S304>/UnitDelay' incorporates:
             *  Constant: '<S302>/Calib'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_oi = KeTPCR_b_ThrRdyShtdwn_CabPrecFail;

            /* End of Outputs for SubSystem: '<S303>/EdgeRising' */

            /* Switch: '<S303>/Switch1' incorporates:
             *  Constant: '<S302>/Calib'
             *  Logic: '<S303>/OR'
             *  Logic: '<S303>/OR1'
             */
            if ((!KeTPCR_b_ThrRdyShtdwn_CabPrecFail) || rtb_Comparison5)
            {
                /* Switch: '<S303>/Switch1' incorporates:
                 *  Constant: '<S303>/ConstantValue1'
                 */
                rtb_Switch1_l4 = 0.0F;
            }
            else
            {
                /* Switch: '<S303>/Switch1' incorporates:
                 *  Constant: '<S289>/Calib'
                 *  Constant: '<S290>/Calib'
                 *  MinMax: '<S303>/Minimum'
                 *  Sum: '<S303>/Summation'
                 *  UnitDelay: '<S303>/UnitDelay'
                 */
                rtb_Switch1_l4 = fminf(KeTPCR_t_RS_CabPrec_delayTime,
                                       KeTPCR_t_RS_CabPrec_dT +
                                       TPCR_ac_DW.UnitDelay_DSTATE_b3);
            }

            /* End of Switch: '<S303>/Switch1' */

            /* Merge: '<S67>/Merge1' incorporates:
             *  Constant: '<S290>/Calib'
             *  Constant: '<S302>/Calib'
             *  Logic: '<S303>/AND'
             *  RelationalOperator: '<S303>/GreaterThan'
             */
            VeTPCC_b_RS_ThrmlRdyShtDwn_AftMrg =
                ((KeTPCR_b_ThrRdyShtdwn_CabPrecFail) && (rtb_Switch1_l4 >=
                  KeTPCR_t_RS_CabPrec_delayTime));

            /* Update for UnitDelay: '<S303>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_b3 = rtb_Switch1_l4;

            /* End of Outputs for SubSystem: '<S280>/TurnOnDelayTime' */
            /* End of Outputs for SubSystem: '<S67>/CabPrec_State2' */
            break;

          case 3:
            if (rtAction != rtPrevAction)
            {
                /* SystemReset for IfAction SubSystem: '<S67>/CabPrec_State8' incorporates:
                 *  ActionPort: '<S286>/ActionPort'
                 */
                /* SystemReset for Atomic SubSystem: '<S286>/TurnOnDelayTime' */
                /* SystemReset for If: '<S67>/If' incorporates:
                 *  UnitDelay: '<S326>/UnitDelay'
                 *  UnitDelay: '<S327>/UnitDelay'
                 */
                TPCR_ac_DW.UnitDelay_DSTATE_ly = 0.0F;

                /* SystemReset for Atomic SubSystem: '<S326>/EdgeRising' */
                TPCR_ac_DW.UnitDelay_DSTATE_fe = false;

                /* End of SystemReset for SubSystem: '<S326>/EdgeRising' */
                /* End of SystemReset for SubSystem: '<S286>/TurnOnDelayTime' */
                /* End of SystemReset for SubSystem: '<S67>/CabPrec_State8' */
            }

            /* Outputs for IfAction SubSystem: '<S67>/CabPrec_State8' incorporates:
             *  ActionPort: '<S286>/ActionPort'
             */
            /* Merge: '<S67>/Merge' incorporates:
             *  Constant: '<S324>/Constant'
             *  SignalConversion generated from: '<S286>/NoCabPrec_Failed_SOC'
             */
            TPCR_ac_B.VeTPCC_e_CabinPreCondReqStat_Ap = CeTPCR_e_NoCabPrec_SOC;

            /* Outputs for Atomic SubSystem: '<S286>/TurnOnDelayTime' */
            /* Outputs for Atomic SubSystem: '<S326>/EdgeRising' */
            /* Logic: '<S327>/AND' incorporates:
             *  Constant: '<S325>/Calib'
             *  Logic: '<S327>/OR1'
             *  UnitDelay: '<S327>/UnitDelay'
             */
            rtb_Comparison5 = ((KeTPCR_b_ThrRdyShtdwn_CabPrecSOC) &&
                               (!TPCR_ac_DW.UnitDelay_DSTATE_fe));

            /* Update for UnitDelay: '<S327>/UnitDelay' incorporates:
             *  Constant: '<S325>/Calib'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_fe = KeTPCR_b_ThrRdyShtdwn_CabPrecSOC;

            /* End of Outputs for SubSystem: '<S326>/EdgeRising' */

            /* Switch: '<S326>/Switch1' incorporates:
             *  Constant: '<S325>/Calib'
             *  Logic: '<S326>/OR'
             *  Logic: '<S326>/OR1'
             */
            if ((!KeTPCR_b_ThrRdyShtdwn_CabPrecSOC) || rtb_Comparison5)
            {
                /* Switch: '<S326>/Switch1' incorporates:
                 *  Constant: '<S326>/ConstantValue1'
                 */
                rtb_Switch1_l4 = 0.0F;
            }
            else
            {
                /* Switch: '<S326>/Switch1' incorporates:
                 *  Constant: '<S289>/Calib'
                 *  Constant: '<S290>/Calib'
                 *  MinMax: '<S326>/Minimum'
                 *  Sum: '<S326>/Summation'
                 *  UnitDelay: '<S326>/UnitDelay'
                 */
                rtb_Switch1_l4 = fminf(KeTPCR_t_RS_CabPrec_delayTime,
                                       KeTPCR_t_RS_CabPrec_dT +
                                       TPCR_ac_DW.UnitDelay_DSTATE_ly);
            }

            /* End of Switch: '<S326>/Switch1' */

            /* Merge: '<S67>/Merge1' incorporates:
             *  Constant: '<S290>/Calib'
             *  Constant: '<S325>/Calib'
             *  Logic: '<S326>/AND'
             *  RelationalOperator: '<S326>/GreaterThan'
             */
            VeTPCC_b_RS_ThrmlRdyShtDwn_AftMrg =
                ((KeTPCR_b_ThrRdyShtdwn_CabPrecSOC) && (rtb_Switch1_l4 >=
                  KeTPCR_t_RS_CabPrec_delayTime));

            /* Update for UnitDelay: '<S326>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_ly = rtb_Switch1_l4;

            /* End of Outputs for SubSystem: '<S286>/TurnOnDelayTime' */
            /* End of Outputs for SubSystem: '<S67>/CabPrec_State8' */
            break;

          case 4:
            /* Outputs for IfAction SubSystem: '<S67>/CabPrec_State9' incorporates:
             *  ActionPort: '<S287>/ActionPort'
             */
            /* Merge: '<S67>/Merge' incorporates:
             *  Constant: '<S328>/Constant'
             *  SignalConversion generated from: '<S287>/NoCabPrec_Failed_NoPlug'
             */
            TPCR_ac_B.VeTPCC_e_CabinPreCondReqStat_Ap =
                CeTPCR_e_NoCabPrec_NotPlugged;

            /* Outputs for Atomic SubSystem: '<S287>/TurnOnDelayTime' */
            /* Outputs for Atomic SubSystem: '<S330>/EdgeRising' */
            /* Logic: '<S331>/AND' incorporates:
             *  Constant: '<S329>/Calib'
             *  Logic: '<S331>/OR1'
             *  UnitDelay: '<S331>/UnitDelay'
             */
            rtb_Comparison5 = ((KeTPCR_b_ThrRdyShtdwn_CabPrecNoPlug) &&
                               (!TPCR_ac_DW.UnitDelay_DSTATE_gie));

            /* Update for UnitDelay: '<S331>/UnitDelay' incorporates:
             *  Constant: '<S329>/Calib'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_gie =
                KeTPCR_b_ThrRdyShtdwn_CabPrecNoPlug;

            /* End of Outputs for SubSystem: '<S330>/EdgeRising' */

            /* Switch: '<S330>/Switch1' incorporates:
             *  Constant: '<S329>/Calib'
             *  Logic: '<S330>/OR'
             *  Logic: '<S330>/OR1'
             */
            if ((!KeTPCR_b_ThrRdyShtdwn_CabPrecNoPlug) || rtb_Comparison5)
            {
                /* Switch: '<S330>/Switch1' incorporates:
                 *  Constant: '<S330>/ConstantValue1'
                 */
                rtb_Switch1_l4 = 0.0F;
            }
            else
            {
                /* Switch: '<S330>/Switch1' incorporates:
                 *  Constant: '<S289>/Calib'
                 *  Constant: '<S290>/Calib'
                 *  MinMax: '<S330>/Minimum'
                 *  Sum: '<S330>/Summation'
                 *  UnitDelay: '<S330>/UnitDelay'
                 */
                rtb_Switch1_l4 = fminf(KeTPCR_t_RS_CabPrec_delayTime,
                                       KeTPCR_t_RS_CabPrec_dT +
                                       TPCR_ac_DW.UnitDelay_DSTATE_akc);
            }

            /* End of Switch: '<S330>/Switch1' */

            /* Merge: '<S67>/Merge1' incorporates:
             *  Constant: '<S290>/Calib'
             *  Constant: '<S329>/Calib'
             *  Logic: '<S330>/AND'
             *  RelationalOperator: '<S330>/GreaterThan'
             */
            VeTPCC_b_RS_ThrmlRdyShtDwn_AftMrg =
                ((KeTPCR_b_ThrRdyShtdwn_CabPrecNoPlug) && (rtb_Switch1_l4 >=
                  KeTPCR_t_RS_CabPrec_delayTime));

            /* Update for UnitDelay: '<S330>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_akc = rtb_Switch1_l4;

            /* End of Outputs for SubSystem: '<S287>/TurnOnDelayTime' */
            /* End of Outputs for SubSystem: '<S67>/CabPrec_State9' */
            break;

          case 5:
            /* Outputs for IfAction SubSystem: '<S67>/CabPrec_State10' incorporates:
             *  ActionPort: '<S279>/ActionPort'
             */
            /* Merge: '<S67>/Merge' incorporates:
             *  Constant: '<S297>/Constant'
             *  SignalConversion generated from: '<S279>/CabPrec_SPR'
             */
            TPCR_ac_B.VeTPCC_e_CabinPreCondReqStat_Ap =
                CeTPCR_e_CabinPrec_SP_Reached;

            /* Outputs for Atomic SubSystem: '<S279>/TurnOnDelayTime' */
            /* Outputs for Atomic SubSystem: '<S299>/EdgeRising' */
            /* Logic: '<S300>/AND' incorporates:
             *  Constant: '<S298>/Calib'
             *  Logic: '<S300>/OR1'
             *  UnitDelay: '<S300>/UnitDelay'
             */
            rtb_Comparison5 = ((KeTPCR_b_ThrRdyShtdwn_CabPrecSPR) &&
                               (!TPCR_ac_DW.UnitDelay_DSTATE_dr));

            /* Update for UnitDelay: '<S300>/UnitDelay' incorporates:
             *  Constant: '<S298>/Calib'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_dr = KeTPCR_b_ThrRdyShtdwn_CabPrecSPR;

            /* End of Outputs for SubSystem: '<S299>/EdgeRising' */

            /* Switch: '<S299>/Switch1' incorporates:
             *  Constant: '<S298>/Calib'
             *  Logic: '<S299>/OR'
             *  Logic: '<S299>/OR1'
             */
            if ((!KeTPCR_b_ThrRdyShtdwn_CabPrecSPR) || rtb_Comparison5)
            {
                /* Switch: '<S299>/Switch1' incorporates:
                 *  Constant: '<S299>/ConstantValue1'
                 */
                rtb_Switch1_l4 = 0.0F;
            }
            else
            {
                /* Switch: '<S299>/Switch1' incorporates:
                 *  Constant: '<S289>/Calib'
                 *  Constant: '<S290>/Calib'
                 *  MinMax: '<S299>/Minimum'
                 *  Sum: '<S299>/Summation'
                 *  UnitDelay: '<S299>/UnitDelay'
                 */
                rtb_Switch1_l4 = fminf(KeTPCR_t_RS_CabPrec_delayTime,
                                       KeTPCR_t_RS_CabPrec_dT +
                                       TPCR_ac_DW.UnitDelay_DSTATE_co);
            }

            /* End of Switch: '<S299>/Switch1' */

            /* Merge: '<S67>/Merge1' incorporates:
             *  Constant: '<S290>/Calib'
             *  Constant: '<S298>/Calib'
             *  Logic: '<S299>/AND'
             *  RelationalOperator: '<S299>/GreaterThan'
             */
            VeTPCC_b_RS_ThrmlRdyShtDwn_AftMrg =
                ((KeTPCR_b_ThrRdyShtdwn_CabPrecSPR) && (rtb_Switch1_l4 >=
                  KeTPCR_t_RS_CabPrec_delayTime));

            /* Update for UnitDelay: '<S299>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_co = rtb_Switch1_l4;

            /* End of Outputs for SubSystem: '<S279>/TurnOnDelayTime' */
            /* End of Outputs for SubSystem: '<S67>/CabPrec_State10' */
            break;

          case 6:
            /* Outputs for IfAction SubSystem: '<S67>/CabPrec_State3' incorporates:
             *  ActionPort: '<S281>/ActionPort'
             */
            /* Merge: '<S67>/Merge' incorporates:
             *  Constant: '<S305>/Constant'
             *  SignalConversion generated from: '<S281>/CabPrec_Cmplt'
             */
            TPCR_ac_B.VeTPCC_e_CabinPreCondReqStat_Ap =
                CeTPCR_e_NoCabPrec_HV_BatCondCmplt;

            /* Outputs for Atomic SubSystem: '<S281>/TurnOnDelayTime' */
            /* Outputs for Atomic SubSystem: '<S307>/EdgeRising' */
            /* Logic: '<S308>/AND' incorporates:
             *  Constant: '<S306>/Calib'
             *  Logic: '<S308>/OR1'
             *  UnitDelay: '<S308>/UnitDelay'
             */
            rtb_Comparison5 = ((KeTPCR_b_ThrRdyShtdwn_CabPrecBatCmplt) &&
                               (!TPCR_ac_DW.UnitDelay_DSTATE_d45));

            /* Update for UnitDelay: '<S308>/UnitDelay' incorporates:
             *  Constant: '<S306>/Calib'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_d45 =
                KeTPCR_b_ThrRdyShtdwn_CabPrecBatCmplt;

            /* End of Outputs for SubSystem: '<S307>/EdgeRising' */

            /* Switch: '<S307>/Switch1' incorporates:
             *  Constant: '<S306>/Calib'
             *  Logic: '<S307>/OR'
             *  Logic: '<S307>/OR1'
             */
            if ((!KeTPCR_b_ThrRdyShtdwn_CabPrecBatCmplt) || rtb_Comparison5)
            {
                /* Switch: '<S307>/Switch1' incorporates:
                 *  Constant: '<S307>/ConstantValue1'
                 */
                rtb_Switch1_l4 = 0.0F;
            }
            else
            {
                /* Switch: '<S307>/Switch1' incorporates:
                 *  Constant: '<S289>/Calib'
                 *  Constant: '<S290>/Calib'
                 *  MinMax: '<S307>/Minimum'
                 *  Sum: '<S307>/Summation'
                 *  UnitDelay: '<S307>/UnitDelay'
                 */
                rtb_Switch1_l4 = fminf(KeTPCR_t_RS_CabPrec_delayTime,
                                       KeTPCR_t_RS_CabPrec_dT +
                                       TPCR_ac_DW.UnitDelay_DSTATE_jn);
            }

            /* End of Switch: '<S307>/Switch1' */

            /* Merge: '<S67>/Merge1' incorporates:
             *  Constant: '<S290>/Calib'
             *  Constant: '<S306>/Calib'
             *  Logic: '<S307>/AND'
             *  RelationalOperator: '<S307>/GreaterThan'
             */
            VeTPCC_b_RS_ThrmlRdyShtDwn_AftMrg =
                ((KeTPCR_b_ThrRdyShtdwn_CabPrecBatCmplt) && (rtb_Switch1_l4 >=
                  KeTPCR_t_RS_CabPrec_delayTime));

            /* Update for UnitDelay: '<S307>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_jn = rtb_Switch1_l4;

            /* End of Outputs for SubSystem: '<S281>/TurnOnDelayTime' */
            /* End of Outputs for SubSystem: '<S67>/CabPrec_State3' */
            break;

          case 7:
            /* Outputs for IfAction SubSystem: '<S67>/CabPrec_State4' incorporates:
             *  ActionPort: '<S282>/ActionPort'
             */
            /* Merge: '<S67>/Merge' incorporates:
             *  Constant: '<S309>/Constant'
             *  SignalConversion generated from: '<S282>/CabPrec_Stopped'
             */
            TPCR_ac_B.VeTPCC_e_CabinPreCondReqStat_Ap =
                CeTPCR_e_NoCabPrec_HV_BatCondStop;

            /* Outputs for Atomic SubSystem: '<S282>/TurnOnDelayTime' */
            /* Outputs for Atomic SubSystem: '<S311>/EdgeRising' */
            /* Logic: '<S312>/AND' incorporates:
             *  Constant: '<S310>/Calib'
             *  Logic: '<S312>/OR1'
             *  UnitDelay: '<S312>/UnitDelay'
             */
            rtb_Comparison5 = ((KeTPCR_b_ThrRdyShtdwn_CabPrecStp) &&
                               (!TPCR_ac_DW.UnitDelay_DSTATE_ah));

            /* Update for UnitDelay: '<S312>/UnitDelay' incorporates:
             *  Constant: '<S310>/Calib'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_ah = KeTPCR_b_ThrRdyShtdwn_CabPrecStp;

            /* End of Outputs for SubSystem: '<S311>/EdgeRising' */

            /* Switch: '<S311>/Switch1' incorporates:
             *  Constant: '<S310>/Calib'
             *  Logic: '<S311>/OR'
             *  Logic: '<S311>/OR1'
             */
            if ((!KeTPCR_b_ThrRdyShtdwn_CabPrecStp) || rtb_Comparison5)
            {
                /* Switch: '<S311>/Switch1' incorporates:
                 *  Constant: '<S311>/ConstantValue1'
                 */
                rtb_Switch1_l4 = 0.0F;
            }
            else
            {
                /* Switch: '<S311>/Switch1' incorporates:
                 *  Constant: '<S289>/Calib'
                 *  Constant: '<S290>/Calib'
                 *  MinMax: '<S311>/Minimum'
                 *  Sum: '<S311>/Summation'
                 *  UnitDelay: '<S311>/UnitDelay'
                 */
                rtb_Switch1_l4 = fminf(KeTPCR_t_RS_CabPrec_delayTime,
                                       KeTPCR_t_RS_CabPrec_dT +
                                       TPCR_ac_DW.UnitDelay_DSTATE_mg);
            }

            /* End of Switch: '<S311>/Switch1' */

            /* Merge: '<S67>/Merge1' incorporates:
             *  Constant: '<S290>/Calib'
             *  Constant: '<S310>/Calib'
             *  Logic: '<S311>/AND'
             *  RelationalOperator: '<S311>/GreaterThan'
             */
            VeTPCC_b_RS_ThrmlRdyShtDwn_AftMrg =
                ((KeTPCR_b_ThrRdyShtdwn_CabPrecStp) && (rtb_Switch1_l4 >=
                  KeTPCR_t_RS_CabPrec_delayTime));

            /* Update for UnitDelay: '<S311>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_mg = rtb_Switch1_l4;

            /* End of Outputs for SubSystem: '<S282>/TurnOnDelayTime' */
            /* End of Outputs for SubSystem: '<S67>/CabPrec_State4' */
            break;

          case 8:
            if (rtAction != rtPrevAction)
            {
                /* SystemReset for IfAction SubSystem: '<S67>/CabPrec_State5' incorporates:
                 *  ActionPort: '<S283>/ActionPort'
                 */
                /* SystemReset for Atomic SubSystem: '<S283>/TurnOnDelayTime' */
                /* SystemReset for If: '<S67>/If' incorporates:
                 *  UnitDelay: '<S316>/UnitDelay'
                 *  UnitDelay: '<S317>/UnitDelay'
                 */
                TPCR_ac_DW.UnitDelay_DSTATE_ozh = 0.0F;

                /* SystemReset for Atomic SubSystem: '<S316>/EdgeRising' */
                TPCR_ac_DW.UnitDelay_DSTATE_ecj = false;

                /* End of SystemReset for SubSystem: '<S316>/EdgeRising' */
                /* End of SystemReset for SubSystem: '<S283>/TurnOnDelayTime' */
                /* End of SystemReset for SubSystem: '<S67>/CabPrec_State5' */
            }

            /* Outputs for IfAction SubSystem: '<S67>/CabPrec_State5' incorporates:
             *  ActionPort: '<S283>/ActionPort'
             */
            /* Merge: '<S67>/Merge' incorporates:
             *  Constant: '<S313>/Constant'
             *  SignalConversion generated from: '<S283>/CabPrec_Off'
             */
            TPCR_ac_B.VeTPCC_e_CabinPreCondReqStat_Ap = CeTPCR_e_CabinPrec_Off;

            /* Outputs for Atomic SubSystem: '<S283>/TurnOnDelayTime' */
            /* Outputs for Atomic SubSystem: '<S316>/EdgeRising' */
            /* Logic: '<S317>/AND' incorporates:
             *  Constant: '<S314>/Calib'
             *  Logic: '<S317>/OR1'
             *  UnitDelay: '<S317>/UnitDelay'
             */
            rtb_Comparison5 = ((KeTPCR_b_ThrRdyShtdwn_CabPrecOff) &&
                               (!TPCR_ac_DW.UnitDelay_DSTATE_ecj));

            /* Update for UnitDelay: '<S317>/UnitDelay' incorporates:
             *  Constant: '<S314>/Calib'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_ecj = KeTPCR_b_ThrRdyShtdwn_CabPrecOff;

            /* End of Outputs for SubSystem: '<S316>/EdgeRising' */

            /* Switch: '<S316>/Switch1' incorporates:
             *  Constant: '<S314>/Calib'
             *  Logic: '<S316>/OR'
             *  Logic: '<S316>/OR1'
             */
            if ((!KeTPCR_b_ThrRdyShtdwn_CabPrecOff) || rtb_Comparison5)
            {
                /* Switch: '<S316>/Switch1' incorporates:
                 *  Constant: '<S316>/ConstantValue1'
                 */
                rtb_Switch1_l4 = 0.0F;
            }
            else
            {
                /* Switch: '<S316>/Switch1' incorporates:
                 *  Constant: '<S289>/Calib'
                 *  Constant: '<S315>/Calib'
                 *  MinMax: '<S316>/Minimum'
                 *  Sum: '<S316>/Summation'
                 *  UnitDelay: '<S316>/UnitDelay'
                 */
                rtb_Switch1_l4 = fminf(KeTPCR_t_RS_CabPrecOff_DlyTm,
                                       KeTPCR_t_RS_CabPrec_dT +
                                       TPCR_ac_DW.UnitDelay_DSTATE_ozh);
            }

            /* End of Switch: '<S316>/Switch1' */

            /* Merge: '<S67>/Merge1' incorporates:
             *  Constant: '<S314>/Calib'
             *  Constant: '<S315>/Calib'
             *  Logic: '<S316>/AND'
             *  RelationalOperator: '<S316>/GreaterThan'
             */
            VeTPCC_b_RS_ThrmlRdyShtDwn_AftMrg =
                ((KeTPCR_b_ThrRdyShtdwn_CabPrecOff) && (rtb_Switch1_l4 >=
                  KeTPCR_t_RS_CabPrecOff_DlyTm));

            /* Update for UnitDelay: '<S316>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_ozh = rtb_Switch1_l4;

            /* End of Outputs for SubSystem: '<S283>/TurnOnDelayTime' */
            /* End of Outputs for SubSystem: '<S67>/CabPrec_State5' */
            break;

          case 9:
            if (rtAction != rtPrevAction)
            {
                /* SystemReset for IfAction SubSystem: '<S67>/CabPrec_State6' incorporates:
                 *  ActionPort: '<S284>/ActionPort'
                 */
                /* SystemReset for Atomic SubSystem: '<S284>/TurnOnDelayTime' */
                /* SystemReset for If: '<S67>/If' incorporates:
                 *  UnitDelay: '<S320>/UnitDelay'
                 *  UnitDelay: '<S321>/UnitDelay'
                 */
                TPCR_ac_DW.UnitDelay_DSTATE_hpx = 0.0F;

                /* SystemReset for Atomic SubSystem: '<S320>/EdgeRising' */
                TPCR_ac_DW.UnitDelay_DSTATE_n1v = false;

                /* End of SystemReset for SubSystem: '<S320>/EdgeRising' */
                /* End of SystemReset for SubSystem: '<S284>/TurnOnDelayTime' */
                /* End of SystemReset for SubSystem: '<S67>/CabPrec_State6' */
            }

            /* Outputs for IfAction SubSystem: '<S67>/CabPrec_State6' incorporates:
             *  ActionPort: '<S284>/ActionPort'
             */
            /* Merge: '<S67>/Merge' incorporates:
             *  Constant: '<S318>/Constant'
             *  SignalConversion generated from: '<S284>/CabPrec_SNA'
             */
            TPCR_ac_B.VeTPCC_e_CabinPreCondReqStat_Ap = CeTPCR_e_NoCabPrec_SNA;

            /* Outputs for Atomic SubSystem: '<S284>/TurnOnDelayTime' */
            /* Outputs for Atomic SubSystem: '<S320>/EdgeRising' */
            /* Logic: '<S321>/AND' incorporates:
             *  Constant: '<S319>/Calib'
             *  Logic: '<S321>/OR1'
             *  UnitDelay: '<S321>/UnitDelay'
             */
            rtb_Comparison5 = ((KeTPCR_b_ThrRdyShtdwn_CabPrecSNA) &&
                               (!TPCR_ac_DW.UnitDelay_DSTATE_n1v));

            /* Update for UnitDelay: '<S321>/UnitDelay' incorporates:
             *  Constant: '<S319>/Calib'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_n1v = KeTPCR_b_ThrRdyShtdwn_CabPrecSNA;

            /* End of Outputs for SubSystem: '<S320>/EdgeRising' */

            /* Switch: '<S320>/Switch1' incorporates:
             *  Constant: '<S319>/Calib'
             *  Logic: '<S320>/OR'
             *  Logic: '<S320>/OR1'
             */
            if ((!KeTPCR_b_ThrRdyShtdwn_CabPrecSNA) || rtb_Comparison5)
            {
                /* Switch: '<S320>/Switch1' incorporates:
                 *  Constant: '<S320>/ConstantValue1'
                 */
                rtb_Switch1_l4 = 0.0F;
            }
            else
            {
                /* Switch: '<S320>/Switch1' incorporates:
                 *  Constant: '<S289>/Calib'
                 *  Constant: '<S290>/Calib'
                 *  MinMax: '<S320>/Minimum'
                 *  Sum: '<S320>/Summation'
                 *  UnitDelay: '<S320>/UnitDelay'
                 */
                rtb_Switch1_l4 = fminf(KeTPCR_t_RS_CabPrec_delayTime,
                                       KeTPCR_t_RS_CabPrec_dT +
                                       TPCR_ac_DW.UnitDelay_DSTATE_hpx);
            }

            /* End of Switch: '<S320>/Switch1' */

            /* Merge: '<S67>/Merge1' incorporates:
             *  Constant: '<S290>/Calib'
             *  Constant: '<S319>/Calib'
             *  Logic: '<S320>/AND'
             *  RelationalOperator: '<S320>/GreaterThan'
             */
            VeTPCC_b_RS_ThrmlRdyShtDwn_AftMrg =
                ((KeTPCR_b_ThrRdyShtdwn_CabPrecSNA) && (rtb_Switch1_l4 >=
                  KeTPCR_t_RS_CabPrec_delayTime));

            /* Update for UnitDelay: '<S320>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_hpx = rtb_Switch1_l4;

            /* End of Outputs for SubSystem: '<S284>/TurnOnDelayTime' */
            /* End of Outputs for SubSystem: '<S67>/CabPrec_State6' */
            break;

          default:
            /* Outputs for IfAction SubSystem: '<S67>/CabPrec_State7' incorporates:
             *  ActionPort: '<S285>/ActionPort'
             */
            /* Merge: '<S67>/Merge' incorporates:
             *  Constant: '<S322>/Constant'
             *  SignalConversion generated from: '<S285>/CabPrec_Dflt'
             */
            TPCR_ac_B.VeTPCC_e_CabinPreCondReqStat_Ap = CeTPCR_e_CabinPrec_Dflt;

            /* Merge: '<S67>/Merge1' incorporates:
             *  Constant: '<S323>/Calib'
             *  SignalConversion generated from: '<S285>/ThrmlRdy_SDwn_Dflt'
             */
            VeTPCC_b_RS_ThrmlRdyShtDwn_AftMrg =
                KeTPCR_b_ThrRdyShtdwn_CabPrecDflt;

            /* End of Outputs for SubSystem: '<S67>/CabPrec_State7' */
            break;
        }

        /* End of If: '<S67>/If' */

        /* Logic: '<S67>/Logical1' */
        TPCR_ac_B.VeTPCC_b_RS_ThrmlRdyShtDwn_App1 =
            ((VeTPCR_b_PrecRdyForShtDwn_AftrMrg) ||
             (VeTPCC_b_RS_ThrmlRdyShtDwn_AftMrg));
    }
    else
    {
        if (TPCR_ac_DW.RemoteStart_States_MODE)
        {
            /* Disable for If: '<S67>/If' */
            TPCR_ac_DW.If_ActiveSubsystem_j = -1;
            TPCR_ac_DW.RemoteStart_States_MODE = false;
        }
    }

    /* End of Outputs for SubSystem: '<S8>/RemoteStart_States' */

    /* Outputs for Atomic SubSystem: '<S9>/EdgeRising10' */
    /* Logic: '<S461>/OR1' incorporates:
     *  UnitDelay: '<S461>/UnitDelay'
     */
    rtb_Comparison5 = !TPCR_ac_DW.UnitDelay_DSTATE_kz;

    /* Update for UnitDelay: '<S461>/UnitDelay' incorporates:
     *  Constant: '<S9>/TRUEConstant1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_kz = true;

    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset10' */
    /* Logic: '<S507>/OR1' incorporates:
     *  Logic: '<S461>/AND'
     *  Logic: '<S507>/OR'
     *  UnitDelay: '<S507>/UnitDelay'
     */
    VeTPCR_b_RmtStartDsbleSCCMsg = (rtb_UnitDelay_gcx_tmp || ((!rtb_Comparison5)
        && (TPCR_ac_DW.UnitDelay_DSTATE_ap)));

    /* End of Outputs for SubSystem: '<S9>/EdgeRising10' */

    /* Update for UnitDelay: '<S507>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ap = VeTPCR_b_RmtStartDsbleSCCMsg;

    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset10' */

    /* Logic: '<S9>/Logical10' incorporates:
     *  Logic: '<S9>/Logical11'
     *  Logic: '<S9>/Logical13'
     *  Logic: '<S9>/Logical15'
     *  Logic: '<S9>/Logical17'
     *  Logic: '<S9>/Logical18'
     *  Logic: '<S9>/Logical19'
     *  Logic: '<S9>/Logical20'
     *  Logic: '<S9>/Logical24'
     *  Logic: '<S9>/Logical25'
     */
    rtb_LogicalOperator_gy = !VeTPCR_b_RmtStartDsbleSCCMsg;

    /* Logic: '<S9>/Logical7' incorporates:
     *  Constant: '<S494>/Constant'
     *  Logic: '<S9>/Logical10'
     *  Merge: '<S67>/Merge'
     *  RelationalOperator: '<S9>/Comparison2'
     */
    rtb_Comparison5 = ((((uint32)TPCR_ac_B.VeTPCC_e_CabinPreCondReqStat_Ap) ==
                        CeTPCR_e_NoCabPrec_Flts) && rtb_LogicalOperator_gy);

    /* Outputs for Atomic SubSystem: '<S9>/EdgeRising' */
    /* Logic: '<S459>/OR1' incorporates:
     *  UnitDelay: '<S459>/UnitDelay'
     */
    rtb_Switch1_cs = !TPCR_ac_DW.UnitDelay_DSTATE_pb0;

    /* Update for UnitDelay: '<S459>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_pb0 = rtb_Comparison5;

    /* End of Outputs for SubSystem: '<S9>/EdgeRising' */

    /* Logic: '<S9>/Logical9' incorporates:
     *  Logic: '<S18>/Logical5'
     */
    rtb_LogicalOperator1_kl_tmp = (rtb_LogicalOperator_h0 ||
        (VeTPCR_b_SC_WakeUpReq));

    /* Logic: '<S9>/Logical9' incorporates:
     *  Constant: '<S477>/Constant'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S9>/Comparison8'
     *  Switch: '<S1760>/Switch'
     */
    rtb_Switch3_o = (rtb_LogicalOperator1_kl_tmp || (((uint32)
                       VeTPCR_e_PMM_PowerMode_AD) != CeSSDR_e_KeyOff));

    /* Outputs for Atomic SubSystem: '<S9>/EdgeRising7' */
    /* Logic: '<S469>/AND' incorporates:
     *  Logic: '<S469>/OR1'
     *  UnitDelay: '<S469>/UnitDelay'
     */
    VeTPCR_b_RstMsg = (rtb_Switch3_o && (!TPCR_ac_DW.UnitDelay_DSTATE_lr));

    /* Update for UnitDelay: '<S469>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_lr = rtb_Switch3_o;

    /* End of Outputs for SubSystem: '<S9>/EdgeRising7' */

    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset7' */
    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset11' */
    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset6' */
    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset5' */
    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset9' */
    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset12' */
    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset3' */
    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset2' */
    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset1' */
    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset4' */
    /* Logic: '<S512>/NOT' incorporates:
     *  Logic: '<S506>/NOT'
     *  Logic: '<S508>/NOT'
     *  Logic: '<S509>/NOT'
     *  Logic: '<S510>/NOT'
     *  Logic: '<S511>/NOT'
     *  Logic: '<S513>/NOT'
     *  Logic: '<S514>/NOT'
     *  Logic: '<S515>/NOT'
     *  Logic: '<S517>/NOT'
     */
    rtb_UnitDelay_gcx_tmp = !VeTPCR_b_RstMsg;

    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset1' */
    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset2' */
    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset3' */
    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset12' */
    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset9' */
    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset5' */
    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset6' */
    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset11' */
    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset7' */

    /* Outputs for Atomic SubSystem: '<S9>/EdgeRising' */
    /* Logic: '<S512>/OR1' incorporates:
     *  Logic: '<S459>/AND'
     *  Logic: '<S512>/NOT'
     *  Logic: '<S512>/OR'
     *  UnitDelay: '<S512>/UnitDelay'
     */
    VeTPCR_b_CabReqStFail_Msg = ((rtb_Comparison5 && rtb_Switch1_cs) ||
        (rtb_UnitDelay_gcx_tmp && (TPCR_ac_DW.UnitDelay_DSTATE_mi)));

    /* End of Outputs for SubSystem: '<S9>/EdgeRising' */

    /* Update for UnitDelay: '<S512>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_mi = VeTPCR_b_CabReqStFail_Msg;

    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset4' */

    /* S-Function (fcgen): '<S1>/FcnCallGen' incorporates:
     *  SubSystem: '<S1>/TPCO_FUNC'
     */
    /* Outputs for IfAction SubSystem: '<S19>/Wup_WaitBatCond_RS' incorporates:
     *  ActionPort: '<S1029>/ActionPort'
     */
    /* If: '<S19>/If' incorporates:
     *  Merge: '<S67>/Merge'
     *  RelationalOperator: '<S1016>/Comparison1'
     *  RelationalOperator: '<S1019>/Comparison2'
     *  RelationalOperator: '<S1019>/Comparison3'
     *  RelationalOperator: '<S1029>/Comparison2'
     *  RelationalOperator: '<S1029>/Comparison3'
     *  RelationalOperator: '<S1029>/Comparison4'
     *  RelationalOperator: '<S1124>/Comparison1'
     *  RelationalOperator: '<S1124>/Comparison10'
     *  RelationalOperator: '<S1124>/Comparison2'
     *  RelationalOperator: '<S1124>/Comparison3'
     *  RelationalOperator: '<S1124>/Comparison4'
     *  RelationalOperator: '<S1124>/Comparison5'
     *  RelationalOperator: '<S1124>/Comparison6'
     *  RelationalOperator: '<S1124>/Comparison9'
     *  RelationalOperator: '<S15>/Comparison2'
     *  RelationalOperator: '<S15>/Comparison3'
     *  RelationalOperator: '<S15>/Comparison4'
     *  RelationalOperator: '<S66>/Comparison5'
     *  RelationalOperator: '<S7>/Comparison1'
     *  RelationalOperator: '<S7>/Comparison11'
     *  RelationalOperator: '<S7>/Comparison5'
     *  RelationalOperator: '<S9>/Comparison1'
     *  RelationalOperator: '<S9>/Comparison10'
     *  RelationalOperator: '<S9>/Comparison11'
     *  RelationalOperator: '<S9>/Comparison12'
     *  RelationalOperator: '<S9>/Comparison13'
     *  RelationalOperator: '<S9>/Comparison16'
     *  RelationalOperator: '<S9>/Comparison17'
     *  RelationalOperator: '<S9>/Comparison3'
     *  RelationalOperator: '<S9>/Comparison4'
     *  RelationalOperator: '<S9>/Comparison5'
     *  RelationalOperator: '<S9>/Comparison6'
     *  RelationalOperator: '<S9>/Comparison7'
     *  Switch: '<S1016>/Switch'
     *  Switch: '<S1019>/Switch'
     *  Switch: '<S1328>/Switch1'
     *  Switch: '<S1880>/Switch'
     *  Switch: '<S1880>/Switch1'
     */
    Switch_cl = TPCR_ac_B.VeTPCC_e_CabinPreCondReqStat_Ap;

    /* End of Outputs for SubSystem: '<S19>/Wup_WaitBatCond_RS' */

    /* Logic: '<S9>/Logical12' incorporates:
     *  Constant: '<S483>/Constant'
     *  RelationalOperator: '<S9>/Comparison1'
     */
    rtb_Comparison5 = ((((uint32)Switch_cl) == CeTPCR_e_NoCabPrec_HV_BatCrit) &&
                       rtb_LogicalOperator_gy);

    /* Outputs for Atomic SubSystem: '<S9>/EdgeRising1' */
    /* Logic: '<S460>/OR1' incorporates:
     *  UnitDelay: '<S460>/UnitDelay'
     */
    rtb_Switch1_cs = !TPCR_ac_DW.UnitDelay_DSTATE_m22;

    /* Update for UnitDelay: '<S460>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_m22 = rtb_Comparison5;

    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset1' */
    /* Logic: '<S506>/OR1' incorporates:
     *  Logic: '<S460>/AND'
     *  Logic: '<S506>/OR'
     *  UnitDelay: '<S506>/UnitDelay'
     */
    VeTPCR_b_CabReqStBattCrit_Msg = ((rtb_Comparison5 && rtb_Switch1_cs) ||
        (rtb_UnitDelay_gcx_tmp && (TPCR_ac_DW.UnitDelay_DSTATE_ov)));

    /* End of Outputs for SubSystem: '<S9>/EdgeRising1' */

    /* Update for UnitDelay: '<S506>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ov = VeTPCR_b_CabReqStBattCrit_Msg;

    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset1' */

    /* Logic: '<S9>/Logical14' incorporates:
     *  Constant: '<S496>/Constant'
     *  RelationalOperator: '<S9>/Comparison3'
     */
    rtb_Comparison5 = ((((uint32)Switch_cl) == CeTPCR_e_NoCabPrec_NotPlugged) &&
                       rtb_LogicalOperator_gy);

    /* Outputs for Atomic SubSystem: '<S9>/EdgeRising2' */
    /* Logic: '<S464>/OR1' incorporates:
     *  UnitDelay: '<S464>/UnitDelay'
     */
    rtb_Switch1_cs = !TPCR_ac_DW.UnitDelay_DSTATE_co2;

    /* Update for UnitDelay: '<S464>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_co2 = rtb_Comparison5;

    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset2' */
    /* Logic: '<S510>/OR1' incorporates:
     *  Logic: '<S464>/AND'
     *  Logic: '<S510>/OR'
     *  UnitDelay: '<S510>/UnitDelay'
     */
    VeTPCR_b_CabReqStNoPlugIn_Msg = ((rtb_Comparison5 && rtb_Switch1_cs) ||
        (rtb_UnitDelay_gcx_tmp && (TPCR_ac_DW.UnitDelay_DSTATE_mq)));

    /* End of Outputs for SubSystem: '<S9>/EdgeRising2' */

    /* Update for UnitDelay: '<S510>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_mq = VeTPCR_b_CabReqStNoPlugIn_Msg;

    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset2' */

    /* Logic: '<S9>/Logical16' incorporates:
     *  Constant: '<S498>/Constant'
     *  RelationalOperator: '<S9>/Comparison4'
     */
    rtb_Comparison5 = ((((uint32)Switch_cl) == CeTPCR_e_NoCabPrec_SOC) &&
                       rtb_LogicalOperator_gy);

    /* Outputs for Atomic SubSystem: '<S9>/EdgeRising3' */
    /* Logic: '<S465>/OR1' incorporates:
     *  UnitDelay: '<S465>/UnitDelay'
     */
    rtb_Switch1_cs = !TPCR_ac_DW.UnitDelay_DSTATE_lkx;

    /* Update for UnitDelay: '<S465>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_lkx = rtb_Comparison5;

    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset3' */
    /* Logic: '<S511>/OR1' incorporates:
     *  Logic: '<S465>/AND'
     *  Logic: '<S511>/OR'
     *  UnitDelay: '<S511>/UnitDelay'
     */
    VeTPCR_b_CabReqStLoSOC_Msg = ((rtb_Comparison5 && rtb_Switch1_cs) ||
        (rtb_UnitDelay_gcx_tmp && (TPCR_ac_DW.UnitDelay_DSTATE_bp3)));

    /* End of Outputs for SubSystem: '<S9>/EdgeRising3' */

    /* Update for UnitDelay: '<S511>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_bp3 = VeTPCR_b_CabReqStLoSOC_Msg;

    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset3' */

    /* Logic: '<S9>/Logical26' incorporates:
     *  Constant: '<S493>/Constant'
     *  Constant: '<S503>/Calib'
     *  Logic: '<S9>/Logical27'
     *  RelationalOperator: '<S9>/Comparison17'
     */
    rtb_Comparison5 = (((((uint32)Switch_cl) == CeTPCR_e_CabinPrec_Off) &&
                        (VeTPCR_b_V2LActv_SCCRSDsbl)) &&
                       ((KeTPCR_b_DsblRmtStrt_V2L) || rtb_LogicalOperator_gy));

    /* Outputs for Atomic SubSystem: '<S9>/EdgeRising12' */
    /* Logic: '<S463>/OR1' incorporates:
     *  UnitDelay: '<S463>/UnitDelay'
     */
    rtb_Switch1_cs = !TPCR_ac_DW.UnitDelay_DSTATE_a0r;

    /* Update for UnitDelay: '<S463>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_a0r = rtb_Comparison5;

    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset12' */
    /* Logic: '<S509>/OR1' incorporates:
     *  Logic: '<S463>/AND'
     *  Logic: '<S509>/OR'
     *  UnitDelay: '<S509>/UnitDelay'
     */
    VeTPCR_b_V2L_SCCRSDsbl_Msg = ((rtb_Comparison5 && rtb_Switch1_cs) ||
        (rtb_UnitDelay_gcx_tmp && (TPCR_ac_DW.UnitDelay_DSTATE_mvw)));

    /* End of Outputs for SubSystem: '<S9>/EdgeRising12' */

    /* Update for UnitDelay: '<S509>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_mvw = VeTPCR_b_V2L_SCCRSDsbl_Msg;

    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset12' */

    /* RelationalOperator: '<S9>/Comparison15' incorporates:
     *  Constant: '<S479>/Constant'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     */
    VeTPCR_b_KeyoffCheck = (((uint32)VeTPCR_e_PMM_PowerMode_AD) !=
                            CeSSDR_e_KeyOff);

    /* RelationalOperator: '<S9>/Comparison9' incorporates:
     *  Constant: '<S486>/Constant'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     */
    VeTPCR_b_KeyRunoffCheck = (((uint32)VeTPCR_e_PMM_PowerMode_AD) !=
        CeSSDR_e_KeyRun);

    /* Outputs for Atomic SubSystem: '<S9>/EdgeRising9' */
    /* Logic: '<S471>/OR1' incorporates:
     *  UnitDelay: '<S471>/UnitDelay'
     */
    rtb_Comparison5 = !TPCR_ac_DW.UnitDelay_DSTATE_iwt;

    /* Update for UnitDelay: '<S471>/UnitDelay' incorporates:
     *  Constant: '<S9>/TRUEConstant'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_iwt = true;

    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset8' */
    /* Logic: '<S516>/OR1' incorporates:
     *  Logic: '<S471>/AND'
     *  Logic: '<S516>/OR'
     *  Logic: '<S9>/Logical4'
     *  Logic: '<S9>/Logical8'
     *  UnitDelay: '<S516>/UnitDelay'
     *  UnitDelay: '<S9>/UnitDelay1'
     */
    VeTPCR_b_KeyCheck = (((TPCR_ac_DW.UnitDelay1_DSTATE_pp) &&
                          ((VeTPCR_b_KeyoffCheck) && (VeTPCR_b_KeyRunoffCheck)))
                         || ((!rtb_Comparison5) &&
                          (TPCR_ac_DW.UnitDelay_DSTATE_pt)));

    /* End of Outputs for SubSystem: '<S9>/EdgeRising9' */

    /* Update for UnitDelay: '<S516>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_pt = VeTPCR_b_KeyCheck;

    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset8' */

    /* Logic: '<S9>/Logical6' incorporates:
     *  Constant: '<S488>/Constant'
     *  RelationalOperator: '<S9>/Comparison13'
     */
    rtb_Comparison5 = ((((((uint32)Switch_cl) == CeTPCR_e_CabinPrec_Off) &&
                         (VeTPCR_b_NoRS_SCWkUp_CabPrecOff)) &&
                        (VeTPCR_b_KeyCheck)) && rtb_LogicalOperator_gy);

    /* Outputs for Atomic SubSystem: '<S9>/EdgeRising8' */
    /* Logic: '<S470>/OR1' incorporates:
     *  UnitDelay: '<S470>/UnitDelay'
     */
    rtb_Switch1_cs = !TPCR_ac_DW.UnitDelay_DSTATE_fd;

    /* Update for UnitDelay: '<S470>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fd = rtb_Comparison5;

    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset9' */
    /* Logic: '<S517>/OR1' incorporates:
     *  Logic: '<S470>/AND'
     *  Logic: '<S517>/OR'
     *  UnitDelay: '<S517>/UnitDelay'
     */
    VeTPCR_b_CabReq_Default = ((rtb_Comparison5 && rtb_Switch1_cs) ||
        (rtb_UnitDelay_gcx_tmp && (TPCR_ac_DW.UnitDelay_DSTATE_gg)));

    /* End of Outputs for SubSystem: '<S9>/EdgeRising8' */

    /* Update for UnitDelay: '<S517>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_gg = VeTPCR_b_CabReq_Default;

    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset9' */

    /* Logic: '<S9>/Logical5' incorporates:
     *  Constant: '<S500>/Constant'
     *  RelationalOperator: '<S9>/Comparison5'
     */
    rtb_Comparison5 = (((((uint32)Switch_cl) == CeTPCR_e_CabinPrec_Off) &&
                        (VeTPCR_b_NoRS_SCWkUp_CabPrecOff)) &&
                       rtb_LogicalOperator_gy);

    /* Outputs for Atomic SubSystem: '<S9>/EdgeRising4' */
    /* Logic: '<S466>/OR1' incorporates:
     *  UnitDelay: '<S466>/UnitDelay'
     */
    rtb_Switch1_cs = !TPCR_ac_DW.UnitDelay_DSTATE_e2;

    /* Update for UnitDelay: '<S466>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_e2 = rtb_Comparison5;

    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset5' */
    /* Logic: '<S513>/OR1' incorporates:
     *  Logic: '<S466>/AND'
     *  Logic: '<S513>/OR'
     *  UnitDelay: '<S513>/UnitDelay'
     */
    VeTPCR_b_NoRS_SCWkUp_CabPrecOff_Msg = ((rtb_Comparison5 && rtb_Switch1_cs) ||
        (rtb_UnitDelay_gcx_tmp && (TPCR_ac_DW.UnitDelay_DSTATE_kd3)));

    /* End of Outputs for SubSystem: '<S9>/EdgeRising4' */

    /* Update for UnitDelay: '<S513>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_kd3 = VeTPCR_b_NoRS_SCWkUp_CabPrecOff_Msg;

    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset5' */

    /* Logic: '<S241>/Logical17' */
    rtb_Comparison5 = ((VeTPCR_b_TmrExpiredAfterDepTim) ||
                       (VeTPCR_b_DepTimeBigChngLtch));

    /* Logic: '<S9>/Logical1' incorporates:
     *  Constant: '<S474>/Constant'
     *  RelationalOperator: '<S9>/Comparison6'
     */
    rtb_Switch1_cs = (((((uint32)Switch_cl) == CeTPCR_e_CabinPrec_Off) &&
                       rtb_Comparison5) && rtb_LogicalOperator_gy);

    /* Outputs for Atomic SubSystem: '<S9>/EdgeRising5' */
    /* Logic: '<S467>/OR1' incorporates:
     *  UnitDelay: '<S467>/UnitDelay'
     */
    rtb_UnitDelay4_k = !TPCR_ac_DW.UnitDelay_DSTATE_jq;

    /* Update for UnitDelay: '<S467>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_jq = rtb_Switch1_cs;

    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset6' */
    /* Logic: '<S514>/OR1' incorporates:
     *  Logic: '<S467>/AND'
     *  Logic: '<S514>/OR'
     *  UnitDelay: '<S514>/UnitDelay'
     */
    VeTPCR_b_TmrExpiredAfterDepTim_Msg = ((rtb_Switch1_cs && rtb_UnitDelay4_k) ||
        (rtb_UnitDelay_gcx_tmp && (TPCR_ac_DW.UnitDelay_DSTATE_enf)));

    /* End of Outputs for SubSystem: '<S9>/EdgeRising5' */

    /* Update for UnitDelay: '<S514>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_enf = VeTPCR_b_TmrExpiredAfterDepTim_Msg;

    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset6' */

    /* Logic: '<S9>/Logical23' incorporates:
     *  Constant: '<S491>/Constant'
     *  RelationalOperator: '<S9>/Comparison16'
     */
    rtb_Switch1_cs = (((((uint32)Switch_cl) == CeTPCR_e_CabinPrec_Off) &&
                       rtb_RelationalOperator_k) && rtb_LogicalOperator_gy);

    /* Outputs for Atomic SubSystem: '<S9>/EdgeRising11' */
    /* Logic: '<S462>/OR1' incorporates:
     *  UnitDelay: '<S462>/UnitDelay'
     */
    rtb_UnitDelay4_k = !TPCR_ac_DW.UnitDelay_DSTATE_ib;

    /* Update for UnitDelay: '<S462>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ib = rtb_Switch1_cs;

    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset11' */
    /* Logic: '<S508>/OR1' incorporates:
     *  Logic: '<S462>/AND'
     *  Logic: '<S508>/OR'
     *  UnitDelay: '<S508>/UnitDelay'
     */
    VeTPCR_b_SCCCancelledFOTA_Msg = ((rtb_Switch1_cs && rtb_UnitDelay4_k) ||
        (rtb_UnitDelay_gcx_tmp && (TPCR_ac_DW.UnitDelay_DSTATE_pi)));

    /* End of Outputs for SubSystem: '<S9>/EdgeRising11' */

    /* Update for UnitDelay: '<S508>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_pi = VeTPCR_b_SCCCancelledFOTA_Msg;

    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset11' */

    /* Logic: '<S9>/Logical2' incorporates:
     *  Constant: '<S476>/Constant'
     *  RelationalOperator: '<S9>/Comparison7'
     */
    rtb_Switch1_cs = ((((((uint32)Switch_cl) == CeTPCR_e_CabinPrec_Off) &&
                        rtb_Switch2_du) && (VeTPCR_b_SC_WakeUpReq)) &&
                      rtb_LogicalOperator_gy);

    /* Outputs for Atomic SubSystem: '<S9>/EdgeRising6' */
    /* Logic: '<S468>/OR1' incorporates:
     *  UnitDelay: '<S468>/UnitDelay'
     */
    rtb_UnitDelay4_k = !TPCR_ac_DW.UnitDelay_DSTATE_oy;

    /* Update for UnitDelay: '<S468>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_oy = rtb_Switch1_cs;

    /* Outputs for Atomic SubSystem: '<S9>/SignalLatchOnWithReset7' */
    /* Logic: '<S515>/OR1' incorporates:
     *  Logic: '<S468>/AND'
     *  Logic: '<S515>/OR'
     *  UnitDelay: '<S515>/UnitDelay'
     */
    VeTPCR_b_SCC_Off_WhileCond_Msg = ((rtb_Switch1_cs && rtb_UnitDelay4_k) ||
        (rtb_UnitDelay_gcx_tmp && (TPCR_ac_DW.UnitDelay_DSTATE_hyc)));

    /* End of Outputs for SubSystem: '<S9>/EdgeRising6' */

    /* Update for UnitDelay: '<S515>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_hyc = VeTPCR_b_SCC_Off_WhileCond_Msg;

    /* End of Outputs for SubSystem: '<S9>/SignalLatchOnWithReset7' */

    /* Switch: '<S9>/Switch1' incorporates:
     *  Constant: '<S504>/Calib'
     */
    if (KeTPCR_b_EnblRstTrigMsg)
    {
        rtb_Switch3_o = VeTPCR_b_RstMsg;
    }

    /* End of Switch: '<S9>/Switch1' */

    /* Logic: '<S9>/Logical3' incorporates:
     *  Constant: '<S480>/Constant'
     *  Constant: '<S481>/Constant'
     *  Constant: '<S482>/Constant'
     *  RelationalOperator: '<S9>/Comparison10'
     *  RelationalOperator: '<S9>/Comparison11'
     *  RelationalOperator: '<S9>/Comparison12'
     */
    VeTPCR_b_ResetClusterMsg = ((((((uint32)Switch_cl) == CeTPCR_e_OkCabinPrec) ||
        (((uint32)Switch_cl) == CeTPCR_e_CabinPrec_SP_Reached)) || (((uint32)
        Switch_cl) == CeTPCR_e_CabinPrec_Off)) || rtb_Switch3_o);

    /* Switch: '<S9>/Switch' */
    if (VeTPCR_b_ResetClusterMsg)
    {
        /* Switch: '<S9>/Switch' incorporates:
         *  Constant: '<S484>/Constant'
         */
        VeTPCR_e_ClusterMsgFrmMemory = CeTPCR_e_CabinPrec_Dflt;
    }
    else
    {
        /* Switch: '<S9>/Switch' incorporates:
         *  DataStoreRead: '<S9>/DataStoreRead1'
         *  DataTypeConversion: '<S9>/DataTypeConversion3'
         */
        VeTPCR_e_ClusterMsgFrmMemory = (TeTPCR_e_CabinPreCondReqStat)
            EeTPCR_e_HoldClusterMsg;
    }

    /* End of Switch: '<S9>/Switch' */

    /* Switch: '<S501>/Switch1' incorporates:
     *  Switch: '<S501>/Switch10'
     *  Switch: '<S501>/Switch2'
     *  Switch: '<S501>/Switch3'
     *  Switch: '<S501>/Switch4'
     *  Switch: '<S501>/Switch5'
     *  Switch: '<S501>/Switch6'
     *  Switch: '<S501>/Switch7'
     *  Switch: '<S501>/Switch8'
     *  Switch: '<S501>/Switch9'
     */
    if (VeTPCR_b_CabReqStFail_Msg)
    {
        /* Switch: '<S501>/Switch1' incorporates:
         *  Constant: '<S472>/Constant'
         */
        VeTPCR_e_CabReqSt_MsgBfrMap = CeTPCR_e_NoCabPrec_Flts;
    }
    else if (VeTPCR_b_CabReqStBattCrit_Msg)
    {
        /* Switch: '<S501>/Switch2' incorporates:
         *  Constant: '<S495>/Constant'
         *  Switch: '<S501>/Switch1'
         */
        VeTPCR_e_CabReqSt_MsgBfrMap = CeTPCR_e_NoCabPrec_HV_BatCrit;
    }
    else if (VeTPCR_b_CabReqStNoPlugIn_Msg)
    {
        /* Switch: '<S501>/Switch3' incorporates:
         *  Constant: '<S497>/Constant'
         *  Switch: '<S501>/Switch1'
         *  Switch: '<S501>/Switch2'
         */
        VeTPCR_e_CabReqSt_MsgBfrMap = CeTPCR_e_NoCabPrec_NotPlugged;
    }
    else if (VeTPCR_b_CabReqStLoSOC_Msg)
    {
        /* Switch: '<S501>/Switch4' incorporates:
         *  Constant: '<S499>/Constant'
         *  Switch: '<S501>/Switch1'
         *  Switch: '<S501>/Switch2'
         *  Switch: '<S501>/Switch3'
         */
        VeTPCR_e_CabReqSt_MsgBfrMap = CeTPCR_e_NoCabPrec_SOC;
    }
    else if (VeTPCR_b_V2L_SCCRSDsbl_Msg)
    {
        /* Switch: '<S501>/Switch10' incorporates:
         *  Constant: '<S492>/Constant'
         *  Switch: '<S501>/Switch1'
         *  Switch: '<S501>/Switch2'
         *  Switch: '<S501>/Switch3'
         *  Switch: '<S501>/Switch4'
         */
        VeTPCR_e_CabReqSt_MsgBfrMap = CeTPCR_e_NoCabPrec_Flts;
    }
    else if (VeTPCR_b_CabReq_Default)
    {
        /* Switch: '<S501>/Switch5' incorporates:
         *  Constant: '<S487>/Constant'
         *  Switch: '<S501>/Switch1'
         *  Switch: '<S501>/Switch10'
         *  Switch: '<S501>/Switch2'
         *  Switch: '<S501>/Switch3'
         *  Switch: '<S501>/Switch4'
         */
        VeTPCR_e_CabReqSt_MsgBfrMap = CeTPCR_e_CabinPrec_Dflt;
    }
    else if (VeTPCR_b_NoRS_SCWkUp_CabPrecOff_Msg)
    {
        /* Switch: '<S501>/Switch6' incorporates:
         *  Constant: '<S473>/Constant'
         *  Switch: '<S501>/Switch1'
         *  Switch: '<S501>/Switch10'
         *  Switch: '<S501>/Switch2'
         *  Switch: '<S501>/Switch3'
         *  Switch: '<S501>/Switch4'
         *  Switch: '<S501>/Switch5'
         */
        VeTPCR_e_CabReqSt_MsgBfrMap = CeTPCR_e_NoCabPrec_Flts;
    }
    else if (VeTPCR_b_TmrExpiredAfterDepTim_Msg)
    {
        /* Switch: '<S501>/Switch7' incorporates:
         *  Constant: '<S475>/Constant'
         *  Switch: '<S501>/Switch1'
         *  Switch: '<S501>/Switch10'
         *  Switch: '<S501>/Switch2'
         *  Switch: '<S501>/Switch3'
         *  Switch: '<S501>/Switch4'
         *  Switch: '<S501>/Switch5'
         *  Switch: '<S501>/Switch6'
         */
        VeTPCR_e_CabReqSt_MsgBfrMap = CeTPCR_e_CabinPrec_Off;
    }
    else if (VeTPCR_b_SCCCancelledFOTA_Msg)
    {
        /* Switch: '<S9>/Switch2' incorporates:
         *  Constant: '<S505>/Calib'
         *  Switch: '<S501>/Switch10'
         *  Switch: '<S501>/Switch2'
         *  Switch: '<S501>/Switch3'
         *  Switch: '<S501>/Switch4'
         *  Switch: '<S501>/Switch5'
         *  Switch: '<S501>/Switch6'
         *  Switch: '<S501>/Switch7'
         *  Switch: '<S501>/Switch8'
         */
        if (KeTPCR_b_FOTAMsgSlct)
        {
            /* Switch: '<S501>/Switch1' incorporates:
             *  Constant: '<S490>/Constant'
             *  Switch: '<S501>/Switch8'
             */
            VeTPCR_e_CabReqSt_MsgBfrMap = CeTPCR_e_CabinPrec_Off;
        }
        else
        {
            /* Switch: '<S501>/Switch1' incorporates:
             *  Constant: '<S489>/Constant'
             *  Switch: '<S501>/Switch8'
             */
            VeTPCR_e_CabReqSt_MsgBfrMap = CeTPCR_e_NoCabPrec_Flts;
        }

        /* End of Switch: '<S9>/Switch2' */
    }
    else if (VeTPCR_b_SCC_Off_WhileCond_Msg)
    {
        /* Switch: '<S501>/Switch9' incorporates:
         *  Constant: '<S478>/Constant'
         *  Switch: '<S501>/Switch1'
         *  Switch: '<S501>/Switch10'
         *  Switch: '<S501>/Switch2'
         *  Switch: '<S501>/Switch3'
         *  Switch: '<S501>/Switch4'
         *  Switch: '<S501>/Switch5'
         *  Switch: '<S501>/Switch6'
         *  Switch: '<S501>/Switch7'
         *  Switch: '<S501>/Switch8'
         */
        VeTPCR_e_CabReqSt_MsgBfrMap = CeTPCR_e_NoCabPrec_Flts;
    }
    else
    {
        /* Switch: '<S501>/Switch1' incorporates:
         *  Switch: '<S501>/Switch10'
         *  Switch: '<S501>/Switch2'
         *  Switch: '<S501>/Switch3'
         *  Switch: '<S501>/Switch4'
         *  Switch: '<S501>/Switch5'
         *  Switch: '<S501>/Switch6'
         *  Switch: '<S501>/Switch7'
         *  Switch: '<S501>/Switch8'
         *  Switch: '<S501>/Switch9'
         *  Switch: '<S9>/Switch'
         */
        VeTPCR_e_CabReqSt_MsgBfrMap = VeTPCR_e_ClusterMsgFrmMemory;
    }

    /* End of Switch: '<S501>/Switch1' */

    /* DataTypeConversion: '<S9>/DataTypeConversion2' incorporates:
     *  DataStoreWrite: '<S9>/DataStoreWrite'
     *  Switch: '<S501>/Switch1'
     */
    EeTPCR_e_HoldClusterMsg = VeTPCR_e_CabReqSt_MsgBfrMap;

    /* RelationalOperator: '<S9>/Comparison14' incorporates:
     *  Constant: '<S485>/Constant'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     */
    VeTPCR_b_KeyRunCheck = (((uint32)VeTPCR_e_PMM_PowerMode_AD) ==
                            CeSSDR_e_KeyRun);

    /* Selector: '<S9>/Selector' incorporates:
     *  Constant: '<S502>/Calib'
     *  DataTypeConversion: '<S9>/DataTypeConversion1'
     *  Switch: '<S501>/Switch1'
     */
    VeTPCR_e_CabReqSt_MsgAftrMap = KaTPCR_e_CabPrecReqStMap
        [(VeTPCR_e_CabReqSt_MsgBfrMap)];

    /* RelationalOperator: '<S611>/Comparison1' incorporates:
     *  Constant: '<S653>/Constant'
     *  RelationalOperator: '<S607>/Comparison2'
     *  UnitDelay: '<S612>/UnitDelay4'
     */
    rtb_Switch3_o = (((uint32)VeTPCR_e_KHCStatus) == CeTPCR_e_Active);

    /* RelationalOperator: '<S611>/Comparison2' incorporates:
     *  Constant: '<S652>/Constant'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     */
    rtb_Switch1_cs = (((uint32)VeTPCR_e_PMM_PowerMode_AD) != CeSSDR_e_KeyOff);

    /* Outputs for Atomic SubSystem: '<S611>/EdgeRising2' */
    /* Logic: '<S646>/AND' incorporates:
     *  Logic: '<S646>/OR1'
     *  UnitDelay: '<S646>/UnitDelay'
     */
    rtb_UnitDelay4_k = !TPCR_ac_DW.UnitDelay_DSTATE_p0;

    /* Update for UnitDelay: '<S646>/UnitDelay' incorporates:
     *  Constant: '<S611>/TRUEConstant2'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_p0 = true;

    /* End of Outputs for SubSystem: '<S611>/EdgeRising2' */

    /* Logic: '<S611>/Logical2' incorporates:
     *  Logic: '<S611>/Logical1'
     *  Logic: '<S611>/Logical3'
     *  Logic: '<S611>/Logical4'
     *  Logic: '<S611>/Logical5'
     *  Logic: '<S611>/Logical6'
     *  Logic: '<S611>/Logical7'
     */
    rtb_UnitDelay_gcx_tmp = !rtb_Switch1_cs;

    /* Outputs for Atomic SubSystem: '<S611>/SignalLatchOnWithReset12' */
    /* Logic: '<S663>/OR1' incorporates:
     *  Logic: '<S611>/Logical2'
     *  Logic: '<S611>/Logical22'
     *  Logic: '<S663>/NOT'
     *  Logic: '<S663>/OR'
     *  UnitDelay: '<S663>/UnitDelay'
     */
    rtb_UnitDelay4_k = ((rtb_Switch3_o && rtb_VariantMerge_For_Variant_So) ||
                        ((rtb_UnitDelay_gcx_tmp && (!rtb_UnitDelay4_k)) &&
                         (TPCR_ac_DW.UnitDelay_DSTATE_ie)));

    /* Update for UnitDelay: '<S663>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ie = rtb_UnitDelay4_k;

    /* End of Outputs for SubSystem: '<S611>/SignalLatchOnWithReset12' */

    /* Outputs for Atomic SubSystem: '<S611>/EdgeRising1' */
    /* Logic: '<S645>/AND' incorporates:
     *  Logic: '<S645>/OR1'
     *  UnitDelay: '<S645>/UnitDelay'
     */
    rtb_LogicalOperator_gy = !TPCR_ac_DW.UnitDelay_DSTATE_dhe;

    /* Update for UnitDelay: '<S645>/UnitDelay' incorporates:
     *  Constant: '<S611>/TRUEConstant1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_dhe = true;

    /* End of Outputs for SubSystem: '<S611>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S611>/SignalLatchOnWithReset13' */
    /* Logic: '<S664>/OR1' incorporates:
     *  Logic: '<S611>/Logical1'
     *  Logic: '<S611>/Logical23'
     *  Logic: '<S664>/NOT'
     *  Logic: '<S664>/OR'
     *  UnitDelay: '<S664>/UnitDelay'
     */
    rtb_LogicalOperator_gy = ((rtb_Switch3_o && rtb_VariantMerge_For_Variant__i)
        || ((rtb_UnitDelay_gcx_tmp && (!rtb_LogicalOperator_gy)) &&
            (TPCR_ac_DW.UnitDelay_DSTATE_k3)));

    /* Update for UnitDelay: '<S664>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_k3 = rtb_LogicalOperator_gy;

    /* End of Outputs for SubSystem: '<S611>/SignalLatchOnWithReset13' */

    /* Outputs for Atomic SubSystem: '<S611>/EdgeRising3' */
    /* Logic: '<S647>/AND' incorporates:
     *  Logic: '<S647>/OR1'
     *  UnitDelay: '<S647>/UnitDelay'
     */
    rtb_Switch2_du = !TPCR_ac_DW.UnitDelay_DSTATE_ej;

    /* Update for UnitDelay: '<S647>/UnitDelay' incorporates:
     *  Constant: '<S611>/TRUEConstant3'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_ej = true;

    /* End of Outputs for SubSystem: '<S611>/EdgeRising3' */

    /* Outputs for Atomic SubSystem: '<S611>/SignalLatchOnWithReset14' */
    /* Logic: '<S665>/OR1' incorporates:
     *  Logic: '<S611>/Logical24'
     *  Logic: '<S611>/Logical3'
     *  Logic: '<S665>/NOT'
     *  Logic: '<S665>/OR'
     *  UnitDelay: '<S665>/UnitDelay'
     */
    rtb_Switch2_du = ((rtb_Switch3_o && rtb_LogicalOperator_bpb) ||
                      ((rtb_UnitDelay_gcx_tmp && (!rtb_Switch2_du)) &&
                       (TPCR_ac_DW.UnitDelay_DSTATE_am)));

    /* Update for UnitDelay: '<S665>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_am = rtb_Switch2_du;

    /* End of Outputs for SubSystem: '<S611>/SignalLatchOnWithReset14' */

    /* Outputs for Atomic SubSystem: '<S611>/EdgeRising4' */
    /* Logic: '<S648>/AND' incorporates:
     *  Logic: '<S648>/OR1'
     *  UnitDelay: '<S648>/UnitDelay'
     */
    rtb_Switch1_im = !TPCR_ac_DW.UnitDelay_DSTATE_l5c;

    /* Update for UnitDelay: '<S648>/UnitDelay' incorporates:
     *  Constant: '<S611>/TRUEConstant4'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_l5c = true;

    /* End of Outputs for SubSystem: '<S611>/EdgeRising4' */

    /* Outputs for Atomic SubSystem: '<S611>/SignalLatchOnWithReset15' */
    /* Logic: '<S666>/OR1' incorporates:
     *  Logic: '<S611>/Logical25'
     *  Logic: '<S611>/Logical4'
     *  Logic: '<S666>/NOT'
     *  Logic: '<S666>/OR'
     *  UnitDelay: '<S666>/UnitDelay'
     */
    rtb_Switch1_eo = ((rtb_Switch3_o && rtb_Switch1_eo) ||
                      ((rtb_UnitDelay_gcx_tmp && (!rtb_Switch1_im)) &&
                       (TPCR_ac_DW.UnitDelay_DSTATE_ph)));

    /* Update for UnitDelay: '<S666>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ph = rtb_Switch1_eo;

    /* End of Outputs for SubSystem: '<S611>/SignalLatchOnWithReset15' */

    /* Outputs for Atomic SubSystem: '<S611>/EdgeRising5' */
    /* Logic: '<S649>/AND' incorporates:
     *  Logic: '<S649>/OR1'
     *  UnitDelay: '<S649>/UnitDelay'
     */
    rtb_Switch1_im = !TPCR_ac_DW.UnitDelay_DSTATE_ip;

    /* Update for UnitDelay: '<S649>/UnitDelay' incorporates:
     *  Constant: '<S611>/TRUEConstant5'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_ip = true;

    /* End of Outputs for SubSystem: '<S611>/EdgeRising5' */

    /* Outputs for Atomic SubSystem: '<S611>/SignalLatchOnWithReset16' */
    /* Logic: '<S667>/OR1' incorporates:
     *  Logic: '<S611>/Logical26'
     *  Logic: '<S611>/Logical5'
     *  Logic: '<S667>/NOT'
     *  Logic: '<S667>/OR'
     *  UnitDelay: '<S667>/UnitDelay'
     */
    rtb_UnitDelay_l3 = ((rtb_Switch3_o && rtb_UnitDelay_l3) ||
                        ((rtb_UnitDelay_gcx_tmp && (!rtb_Switch1_im)) &&
                         (TPCR_ac_DW.UnitDelay_DSTATE_ho)));

    /* Update for UnitDelay: '<S667>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ho = rtb_UnitDelay_l3;

    /* End of Outputs for SubSystem: '<S611>/SignalLatchOnWithReset16' */

    /* Outputs for Atomic SubSystem: '<S611>/EdgeRising6' */
    /* Logic: '<S650>/AND' incorporates:
     *  Logic: '<S650>/OR1'
     *  UnitDelay: '<S650>/UnitDelay'
     */
    rtb_Switch1_im = !TPCR_ac_DW.UnitDelay_DSTATE_b2;

    /* Update for UnitDelay: '<S650>/UnitDelay' incorporates:
     *  Constant: '<S611>/TRUEConstant6'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_b2 = true;

    /* End of Outputs for SubSystem: '<S611>/EdgeRising6' */

    /* Outputs for Atomic SubSystem: '<S611>/SignalLatchOnWithReset17' */
    /* Logic: '<S668>/OR1' incorporates:
     *  Logic: '<S611>/Logical27'
     *  Logic: '<S611>/Logical6'
     *  Logic: '<S668>/NOT'
     *  Logic: '<S668>/OR'
     *  UnitDelay: '<S668>/UnitDelay'
     */
    rtb_Gain_g = ((rtb_Switch3_o && rtb_Gain_g) || ((rtb_UnitDelay_gcx_tmp &&
                    (!rtb_Switch1_im)) && (TPCR_ac_DW.UnitDelay_DSTATE_bq)));

    /* Update for UnitDelay: '<S668>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_bq = rtb_Gain_g;

    /* End of Outputs for SubSystem: '<S611>/SignalLatchOnWithReset17' */

    /* Outputs for Atomic SubSystem: '<S611>/EdgeRising7' */
    /* Logic: '<S651>/AND' incorporates:
     *  Logic: '<S651>/OR1'
     *  UnitDelay: '<S651>/UnitDelay'
     */
    rtb_Switch1_im = !TPCR_ac_DW.UnitDelay_DSTATE_pd;

    /* Update for UnitDelay: '<S651>/UnitDelay' incorporates:
     *  Constant: '<S611>/TRUEConstant7'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_pd = true;

    /* End of Outputs for SubSystem: '<S611>/EdgeRising7' */

    /* Outputs for Atomic SubSystem: '<S611>/SignalLatchOnWithReset18' */
    /* Logic: '<S669>/OR1' incorporates:
     *  Logic: '<S611>/Logical28'
     *  Logic: '<S611>/Logical7'
     *  Logic: '<S669>/NOT'
     *  Logic: '<S669>/OR'
     *  UnitDelay: '<S669>/UnitDelay'
     */
    rtb_RelationalOperator1_dfl = ((rtb_Switch3_o && rtb_RelationalOperator1_dfl)
        || ((rtb_UnitDelay_gcx_tmp && (!rtb_Switch1_im)) &&
            (TPCR_ac_DW.UnitDelay_DSTATE_nt)));

    /* Update for UnitDelay: '<S669>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_nt = rtb_RelationalOperator1_dfl;

    /* End of Outputs for SubSystem: '<S611>/SignalLatchOnWithReset18' */

    /* Switch: '<S662>/Switch1' incorporates:
     *  Logic: '<S611>/Logical8'
     *  Switch: '<S662>/Switch2'
     *  Switch: '<S662>/Switch3'
     *  Switch: '<S662>/Switch4'
     *  Switch: '<S662>/Switch5'
     *  Switch: '<S662>/Switch6'
     *  Switch: '<S662>/Switch7'
     *  Switch: '<S662>/Switch8'
     */
    if (rtb_UnitDelay4_k)
    {
        /* Switch: '<S662>/Switch1' incorporates:
         *  Constant: '<S654>/Constant'
         */
        VeTPCR_e_KHCClusterMsg = CeTPCR_e_AbortedDoorOpen;
    }
    else if (rtb_LogicalOperator_gy)
    {
        /* Switch: '<S662>/Switch2' incorporates:
         *  Constant: '<S655>/Constant'
         *  Switch: '<S662>/Switch1'
         */
        VeTPCR_e_KHCClusterMsg = CeTPCR_e_AbortedHoodOpen;
    }
    else if (rtb_Switch2_du)
    {
        /* Switch: '<S662>/Switch3' incorporates:
         *  Constant: '<S656>/Constant'
         *  Switch: '<S662>/Switch1'
         *  Switch: '<S662>/Switch2'
         */
        VeTPCR_e_KHCClusterMsg = CeTPCR_e_AbortedTrunkOpen;
    }
    else if (rtb_Switch1_eo)
    {
        /* Switch: '<S662>/Switch4' incorporates:
         *  Constant: '<S657>/Constant'
         *  Switch: '<S662>/Switch1'
         *  Switch: '<S662>/Switch2'
         *  Switch: '<S662>/Switch3'
         */
        VeTPCR_e_KHCClusterMsg = CeTPCR_e_OnUnavailable;
    }
    else if (rtb_UnitDelay_l3)
    {
        /* Switch: '<S662>/Switch5' incorporates:
         *  Constant: '<S658>/Constant'
         *  Switch: '<S662>/Switch1'
         *  Switch: '<S662>/Switch2'
         *  Switch: '<S662>/Switch3'
         *  Switch: '<S662>/Switch4'
         */
        VeTPCR_e_KHCClusterMsg = CeTPCR_e_OnTimeExpired;
    }
    else if (rtb_Gain_g)
    {
        /* Switch: '<S662>/Switch6' incorporates:
         *  Constant: '<S659>/Constant'
         *  Switch: '<S662>/Switch1'
         *  Switch: '<S662>/Switch2'
         *  Switch: '<S662>/Switch3'
         *  Switch: '<S662>/Switch4'
         *  Switch: '<S662>/Switch5'
         */
        VeTPCR_e_KHCClusterMsg = CeTPCR_e_AbortedLowBattery;
    }
    else if (rtb_RelationalOperator1_dfl)
    {
        /* Switch: '<S662>/Switch7' incorporates:
         *  Constant: '<S660>/Constant'
         *  Switch: '<S662>/Switch1'
         *  Switch: '<S662>/Switch2'
         *  Switch: '<S662>/Switch3'
         *  Switch: '<S662>/Switch4'
         *  Switch: '<S662>/Switch5'
         *  Switch: '<S662>/Switch6'
         */
        VeTPCR_e_KHCClusterMsg = CeTPCR_e_AbortedBattTempNotOk;
    }
    else if (rtb_Switch3_o || rtb_Switch1_cs)
    {
        /* Switch: '<S662>/Switch8' incorporates:
         *  Constant: '<S661>/Constant'
         *  Switch: '<S662>/Switch1'
         *  Switch: '<S662>/Switch2'
         *  Switch: '<S662>/Switch3'
         *  Switch: '<S662>/Switch4'
         *  Switch: '<S662>/Switch5'
         *  Switch: '<S662>/Switch6'
         *  Switch: '<S662>/Switch7'
         */
        VeTPCR_e_KHCClusterMsg = CeTPCR_e_NoRequest;
    }
    else
    {
        /* Switch: '<S662>/Switch1' incorporates:
         *  DataStoreRead: '<S611>/DataStoreRead1'
         *  DataTypeConversion: '<S611>/DataTypeConversion1'
         *  Switch: '<S662>/Switch2'
         *  Switch: '<S662>/Switch3'
         *  Switch: '<S662>/Switch4'
         *  Switch: '<S662>/Switch5'
         *  Switch: '<S662>/Switch6'
         *  Switch: '<S662>/Switch7'
         *  Switch: '<S662>/Switch8'
         */
        VeTPCR_e_KHCClusterMsg = (TeTPCR_e_KeepHotCold)
            EeTPCR_e_HoldClusterMsg_KHC;
    }

    /* End of Switch: '<S662>/Switch1' */

    /* DataTypeConversion: '<S611>/DataTypeConversion' incorporates:
     *  DataStoreWrite: '<S611>/DataStoreWrite1'
     *  Switch: '<S662>/Switch1'
     */
    EeTPCR_e_HoldClusterMsg_KHC = VeTPCR_e_KHCClusterMsg;

    /* Outputs for Atomic SubSystem: '<S612>/EdgeRising10' */
    /* Logic: '<S671>/AND' incorporates:
     *  Logic: '<S671>/OR1'
     *  UnitDelay: '<S671>/UnitDelay'
     */
    rtb_Gain_g = ((VeTPCR_b_HCPShutDwnCmd) && (!TPCR_ac_DW.UnitDelay_DSTATE_i1));

    /* Update for UnitDelay: '<S671>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_i1 = VeTPCR_b_HCPShutDwnCmd;

    /* End of Outputs for SubSystem: '<S612>/EdgeRising10' */

    /* Outputs for Atomic SubSystem: '<S519>/Hysteresis_3' */
    /* Switch: '<S558>/Switch1' incorporates:
     *  Constant: '<S561>/Calib'
     *  RelationalOperator: '<S558>/GreaterThan'
     */
    if (VeTPCR_Pct_HVBatSOC >= KeTPCR_Pct_CmftEnbl_SOCMax)
    {
        /* Switch: '<S558>/Switch1' incorporates:
         *  Constant: '<S558>/ConstantValue'
         */
        rtb_Switch1_eo = true;
    }
    else
    {
        /* Switch: '<S558>/Switch1' incorporates:
         *  Constant: '<S562>/Calib'
         *  RelationalOperator: '<S558>/GreaterThan1'
         *  UnitDelay: '<S558>/UnitDelay'
         */
        rtb_Switch1_eo = ((VeTPCR_Pct_HVBatSOC > KeTPCR_Pct_CmftEnbl_SOCMin) &&
                          (TPCR_ac_DW.UnitDelay_DSTATE_cj));
    }

    /* End of Switch: '<S558>/Switch1' */

    /* Update for UnitDelay: '<S558>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_cj = rtb_Switch1_eo;

    /* End of Outputs for SubSystem: '<S519>/Hysteresis_3' */

    /* Logic: '<S519>/Logical18' */
    VeTPCR_b_CmftEnbl_SOCLimit = !rtb_Switch1_eo;

    /* Logic: '<S519>/Logical19' */
    VeTPCR_b_CmftEnbl_PwrBdgt_SOC = ((VeTPCR_b_PCC_PwrBdgtChk) ||
        (VeTPCR_b_CmftEnbl_SOCLimit));

    /* Logic: '<S518>/Logical1' incorporates:
     *  Constant: '<S528>/Calib'
     *  Constant: '<S529>/Calib'
     *  Constant: '<S530>/Calib'
     *  Constant: '<S531>/Calib'
     *  Logic: '<S518>/Logical2'
     *  Logic: '<S518>/Logical4'
     *  Logic: '<S518>/Logical6'
     *  Logic: '<S518>/Logical7'
     */
    VeTPCR_b_ComfortEnable = ((((((rtb_OR1_d5 &&
        (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_hl)) &&
        ((!VeTPCR_b_CmftEnbl_PwrBdgt_SOC) || (KeTPCR_b_DsblSOCChk_ComfEnb))) &&
        (rtb_VariantMerge_For_Variant__3 || (KeTPCR_b_DsblFltChk_ComfEnb))) &&
        (rtb_Switch3_c2 || (KeTPCR_b_DsblBattCritChk_ComfEnb))) &&
        (KeTPCR_b_Enbl_ComfEnbl)) && rtb_VariantMerge_For_Variant__4);

    /* Outputs for Atomic SubSystem: '<S612>/SignalLatchOnWithReset9' */
    /* Logic: '<S695>/OR1' incorporates:
     *  Constant: '<S675>/Constant'
     *  Constant: '<S681>/Constant'
     *  Constant: '<S682>/Constant'
     *  Constant: '<S683>/Constant'
     *  Logic: '<S612>/Logical1'
     *  Logic: '<S612>/Logical10'
     *  Logic: '<S612>/Logical21'
     *  Logic: '<S695>/NOT'
     *  Logic: '<S695>/OR'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S607>/Comparison2'
     *  RelationalOperator: '<S612>/Comparison14'
     *  RelationalOperator: '<S612>/Comparison15'
     *  RelationalOperator: '<S612>/Comparison3'
     *  RelationalOperator: '<S612>/Comparison30'
     *  Switch: '<S1760>/Switch'
     *  UnitDelay: '<S612>/UnitDelay1'
     *  UnitDelay: '<S612>/UnitDelay4'
     *  UnitDelay: '<S695>/UnitDelay'
     */
    VeTPCR_b_KHCRdyForShtDwn = (((((uint32)TPCR_ac_DW.UnitDelay1_DSTATE_k) ==
        CeTPCR_e_Active) && ((((uint32)VeTPCR_e_KHCStatus) ==
        CeTPCR_e_TemporaryNotAvailable) || (((uint32)VeTPCR_e_KHCStatus) ==
        CeTPCR_e_NotActive))) || (((!rtb_Gain_g) && (((uint32)
        VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff)) &&
        (TPCR_ac_DW.UnitDelay_DSTATE_o3)));

    /* Update for UnitDelay: '<S695>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_o3 = VeTPCR_b_KHCRdyForShtDwn;

    /* End of Outputs for SubSystem: '<S612>/SignalLatchOnWithReset9' */

    /* Logic: '<S519>/Logical11' incorporates:
     *  Constant: '<S545>/Constant'
     *  RelationalOperator: '<S519>/Comparison10'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     *  UnitDelay: '<S519>/UnitDelay1'
     */
    rtb_Switch1_eo = ((((uint32)VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff) &&
                      (TPCR_ac_DW.UnitDelay1_DSTATE_n));

    /* Outputs for Atomic SubSystem: '<S519>/EdgeRising' */
    /* Logic: '<S533>/AND' incorporates:
     *  Logic: '<S533>/OR1'
     *  UnitDelay: '<S533>/UnitDelay'
     */
    rtb_Gain_g = (rtb_Switch1_eo && (!TPCR_ac_DW.UnitDelay_DSTATE_iu));

    /* Update for UnitDelay: '<S533>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_iu = rtb_Switch1_eo;

    /* End of Outputs for SubSystem: '<S519>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S519>/EdgeRising3' */
    /* Logic: '<S537>/AND' incorporates:
     *  Logic: '<S537>/OR1'
     *  UnitDelay: '<S519>/UnitDelay3'
     *  UnitDelay: '<S537>/UnitDelay'
     */
    rtb_Switch1_eo = ((TPCR_ac_DW.UnitDelay3_DSTATE_i) &&
                      (!TPCR_ac_DW.UnitDelay_DSTATE_gn));

    /* Update for UnitDelay: '<S537>/UnitDelay' incorporates:
     *  UnitDelay: '<S519>/UnitDelay3'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_gn = TPCR_ac_DW.UnitDelay3_DSTATE_i;

    /* End of Outputs for SubSystem: '<S519>/EdgeRising3' */

    /* Outputs for Enabled SubSystem: '<S519>/LoadShed_Save' incorporates:
     *  EnablePort: '<S575>/Enable'
     */
    /* Logic: '<S519>/Logical10' incorporates:
     *  Constant: '<S544>/Constant'
     *  RelationalOperator: '<S519>/Comparison9'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     */
    if ((rtb_Gain_g || (((uint32)VeTPCR_e_PMM_PowerMode_AD) != CeSSDR_e_KeyOff))
        || rtb_Switch1_eo)
    {
        /* DataStoreWrite: '<S575>/DataStoreWrite' incorporates:
         *  UnitDelay: '<S519>/UnitDelay3'
         */
        TPCR_ac_DW.NeTPCR_b_12VloadShed = TPCR_ac_DW.UnitDelay3_DSTATE_i;
    }

    /* End of Logic: '<S519>/Logical10' */
    /* End of Outputs for SubSystem: '<S519>/LoadShed_Save' */

    /* Outputs for Atomic SubSystem: '<S519>/Hysteresis_2' */
    /* Switch: '<S557>/Switch1' incorporates:
     *  Constant: '<S563>/Calib'
     *  RelationalOperator: '<S557>/GreaterThan'
     */
    if (VeTPCR_Pct_HVBatSOC >= KeTPCR_Pct_HotEnbl_SOCMax)
    {
        /* Switch: '<S557>/Switch1' incorporates:
         *  Constant: '<S557>/ConstantValue'
         */
        rtb_Gain_g = true;
    }
    else
    {
        /* Switch: '<S557>/Switch1' incorporates:
         *  Constant: '<S564>/Calib'
         *  RelationalOperator: '<S557>/GreaterThan1'
         *  UnitDelay: '<S557>/UnitDelay'
         */
        rtb_Gain_g = ((VeTPCR_Pct_HVBatSOC > KeTPCR_Pct_HotEnbl_SOCMin) &&
                      (TPCR_ac_DW.UnitDelay_DSTATE_em));
    }

    /* End of Switch: '<S557>/Switch1' */

    /* Update for UnitDelay: '<S557>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_em = rtb_Gain_g;

    /* End of Outputs for SubSystem: '<S519>/Hysteresis_2' */

    /* Logic: '<S519>/Logical15' */
    VeTPCR_b_HotEnbl_SOCLimit = !rtb_Gain_g;

    /* Logic: '<S519>/Logical17' */
    VeTPCR_b_HotEnbl_PwrBdgt_SOC = ((VeTPCR_b_PCC_PwrBdgtChk) ||
        (VeTPCR_b_HotEnbl_SOCLimit));

    /* Outputs for Atomic SubSystem: '<S520>/EdgeRising1' */
    /* Logic: '<S580>/AND' incorporates:
     *  Logic: '<S580>/OR1'
     *  UnitDelay: '<S580>/UnitDelay'
     */
    rtb_RelationalOperator1_dfl = !TPCR_ac_DW.UnitDelay_DSTATE_agr;

    /* Update for UnitDelay: '<S580>/UnitDelay' incorporates:
     *  Constant: '<S520>/TRUEConstant2'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_agr = true;

    /* End of Outputs for SubSystem: '<S520>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S520>/EdgeRising2' */
    /* Logic: '<S581>/AND' incorporates:
     *  Logic: '<S581>/OR1'
     *  UnitDelay: '<S581>/UnitDelay'
     */
    rtb_Gain_g = !TPCR_ac_DW.UnitDelay_DSTATE_ba;

    /* Update for UnitDelay: '<S581>/UnitDelay' incorporates:
     *  Constant: '<S520>/TRUEConstant1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_ba = true;

    /* End of Outputs for SubSystem: '<S520>/EdgeRising2' */

    /* UnitDelay: '<S520>/UnitDelay' */
    rtb_UnitDelay4_k = TPCR_ac_DW.UnitDelay_DSTATE_iy;

    /* Logic: '<S520>/Logical13' */
    rtb_Switch1_eo = (rtb_UnitDelay4_k &&
                      (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_fa));

    /* Outputs for Atomic SubSystem: '<S520>/EdgeRising3' */
    /* Logic: '<S582>/AND' incorporates:
     *  Logic: '<S582>/OR1'
     *  UnitDelay: '<S582>/UnitDelay'
     */
    rtb_OR1_d5 = (rtb_Switch1_eo && (!TPCR_ac_DW.UnitDelay_DSTATE_jp));

    /* Update for UnitDelay: '<S582>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_jp = rtb_Switch1_eo;

    /* End of Outputs for SubSystem: '<S520>/EdgeRising3' */

    /* Logic: '<S520>/Logical18' */
    rtb_UnitDelay_l3 = (rtb_UnitDelay4_k &&
                        (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gr));

    /* Outputs for Atomic SubSystem: '<S520>/EdgeRising4' */
    /* Logic: '<S583>/AND' incorporates:
     *  Logic: '<S583>/OR1'
     *  UnitDelay: '<S583>/UnitDelay'
     */
    rtb_Switch3_o = (rtb_UnitDelay_l3 && (!TPCR_ac_DW.UnitDelay_DSTATE_c3d));

    /* Update for UnitDelay: '<S583>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_c3d = rtb_UnitDelay_l3;

    /* End of Outputs for SubSystem: '<S520>/EdgeRising4' */

    /* Outputs for Atomic SubSystem: '<S520>/EdgeRising5' */
    /* Logic: '<S584>/AND' incorporates:
     *  Logic: '<S584>/OR1'
     *  UnitDelay: '<S584>/UnitDelay'
     */
    rtb_Switch1_cs = !TPCR_ac_DW.UnitDelay_DSTATE_m1w;

    /* Update for UnitDelay: '<S584>/UnitDelay' incorporates:
     *  Constant: '<S520>/TRUEConstant3'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_m1w = true;

    /* End of Outputs for SubSystem: '<S520>/EdgeRising5' */

    /* Logic: '<S520>/Logical23' */
    rtb_UnitDelay4_k = (rtb_UnitDelay4_k &&
                        (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_md));

    /* Outputs for Atomic SubSystem: '<S520>/EdgeRising6' */
    /* Logic: '<S585>/AND' incorporates:
     *  Logic: '<S585>/OR1'
     *  UnitDelay: '<S585>/UnitDelay'
     */
    rtb_LogicalOperator_gy = (rtb_UnitDelay4_k &&
        (!TPCR_ac_DW.UnitDelay_DSTATE_as));

    /* Update for UnitDelay: '<S585>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_as = rtb_UnitDelay4_k;

    /* End of Outputs for SubSystem: '<S520>/EdgeRising6' */

    /* Outputs for Atomic SubSystem: '<S520>/TimerRetriggerResetEnabled3' */
    /* Switch: '<S605>/Switch1' incorporates:
     *  Logic: '<S520>/Logical21'
     *  Logic: '<S520>/Logical25'
     */
    if ((!rtb_UnitDelay4_k) || rtb_LogicalOperator_gy)
    {
        /* Switch: '<S605>/Switch1' incorporates:
         *  Constant: '<S520>/ConstantValue3'
         *  Constant: '<S597>/Calib'
         *  Sum: '<S520>/Add3'
         */
        rtb_Switch1_l4 = KeTPCR_t_DoorAjarTmr_HotEnblReq + 0.1F;
    }
    else
    {
        /* Switch: '<S605>/Switch1' incorporates:
         *  Constant: '<S520>/ConstantValue3'
         *  Constant: '<S605>/ConstantValue4'
         *  MinMax: '<S605>/Maximum'
         *  Sum: '<S605>/Subtraction'
         *  Switch: '<S605>/Switch2'
         *  UnitDelay: '<S605>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_or - 0.1F, 0.0F);
    }

    /* End of Switch: '<S605>/Switch1' */

    /* Update for UnitDelay: '<S605>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_or = rtb_Switch1_l4;

    /* Outputs for Atomic SubSystem: '<S520>/SignalLatchOnWithReset3' */
    /* Logic: '<S602>/OR1' incorporates:
     *  Constant: '<S589>/Constant'
     *  Constant: '<S605>/ConstantValue2'
     *  Logic: '<S520>/Logical22'
     *  Logic: '<S520>/Logical24'
     *  Logic: '<S602>/NOT'
     *  Logic: '<S602>/OR'
     *  RelationalOperator: '<S520>/Comparison4'
     *  RelationalOperator: '<S605>/GreaterThan1'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     *  UnitDelay: '<S602>/UnitDelay'
     */
    rtb_Switch1_cs = ((rtb_Switch1_l4 <= 0.0F) || (((!rtb_Switch1_cs) &&
                        (((uint32)VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff))
                       && (TPCR_ac_DW.UnitDelay_DSTATE_m0)));

    /* End of Outputs for SubSystem: '<S520>/TimerRetriggerResetEnabled3' */

    /* Update for UnitDelay: '<S602>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_m0 = rtb_Switch1_cs;

    /* End of Outputs for SubSystem: '<S520>/SignalLatchOnWithReset3' */

    /* Outputs for Atomic SubSystem: '<S520>/TimerRetriggerResetEnabled2' */
    /* Switch: '<S604>/Switch1' incorporates:
     *  Logic: '<S520>/Logical16'
     *  Logic: '<S520>/Logical20'
     */
    if ((!rtb_UnitDelay_l3) || rtb_Switch3_o)
    {
        /* Switch: '<S604>/Switch1' incorporates:
         *  Constant: '<S520>/ConstantValue2'
         *  Constant: '<S598>/Calib'
         *  Sum: '<S520>/Add2'
         */
        rtb_Switch1_l4 = KeTPCR_t_HoodAjarTmr_HotEnblReq + 0.1F;
    }
    else
    {
        /* Switch: '<S604>/Switch1' incorporates:
         *  Constant: '<S520>/ConstantValue2'
         *  Constant: '<S604>/ConstantValue4'
         *  MinMax: '<S604>/Maximum'
         *  Sum: '<S604>/Subtraction'
         *  Switch: '<S604>/Switch2'
         *  UnitDelay: '<S604>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_dj - 0.1F, 0.0F);
    }

    /* End of Switch: '<S604>/Switch1' */

    /* Update for UnitDelay: '<S604>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_dj = rtb_Switch1_l4;

    /* Outputs for Atomic SubSystem: '<S520>/SignalLatchOnWithReset2' */
    /* Logic: '<S601>/OR1' incorporates:
     *  Constant: '<S588>/Constant'
     *  Constant: '<S604>/ConstantValue2'
     *  Logic: '<S520>/Logical17'
     *  Logic: '<S520>/Logical19'
     *  Logic: '<S601>/NOT'
     *  Logic: '<S601>/OR'
     *  RelationalOperator: '<S520>/Comparison2'
     *  RelationalOperator: '<S604>/GreaterThan1'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     *  UnitDelay: '<S601>/UnitDelay'
     */
    rtb_RelationalOperator1_dfl = ((rtb_Switch1_l4 <= 0.0F) ||
        (((!rtb_RelationalOperator1_dfl) && (((uint32)VeTPCR_e_PMM_PowerMode_AD)
        == CeSSDR_e_KeyOff)) && (TPCR_ac_DW.UnitDelay_DSTATE_dv)));

    /* End of Outputs for SubSystem: '<S520>/TimerRetriggerResetEnabled2' */

    /* Update for UnitDelay: '<S601>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_dv = rtb_RelationalOperator1_dfl;

    /* End of Outputs for SubSystem: '<S520>/SignalLatchOnWithReset2' */

    /* Outputs for Atomic SubSystem: '<S520>/TimerRetriggerResetEnabled1' */
    /* Switch: '<S603>/Switch1' incorporates:
     *  Logic: '<S520>/Logical11'
     *  Logic: '<S520>/Logical15'
     */
    if ((!rtb_Switch1_eo) || rtb_OR1_d5)
    {
        /* Switch: '<S603>/Switch1' incorporates:
         *  Constant: '<S520>/ConstantValue1'
         *  Constant: '<S599>/Calib'
         *  Sum: '<S520>/Add1'
         */
        rtb_Switch1_l4 = KeTPCR_t_TrunkAjarTmr_HotEnblReq + 0.1F;
    }
    else
    {
        /* Switch: '<S603>/Switch1' incorporates:
         *  Constant: '<S520>/ConstantValue1'
         *  Constant: '<S603>/ConstantValue4'
         *  MinMax: '<S603>/Maximum'
         *  Sum: '<S603>/Subtraction'
         *  Switch: '<S603>/Switch2'
         *  UnitDelay: '<S603>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_pn - 0.1F, 0.0F);
    }

    /* End of Switch: '<S603>/Switch1' */

    /* Update for UnitDelay: '<S603>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_pn = rtb_Switch1_l4;

    /* Outputs for Atomic SubSystem: '<S520>/SignalLatchOnWithReset1' */
    /* Logic: '<S600>/OR1' incorporates:
     *  Constant: '<S586>/Constant'
     *  Constant: '<S603>/ConstantValue2'
     *  Logic: '<S520>/Logical12'
     *  Logic: '<S520>/Logical14'
     *  Logic: '<S600>/NOT'
     *  Logic: '<S600>/OR'
     *  RelationalOperator: '<S520>/Comparison3'
     *  RelationalOperator: '<S603>/GreaterThan1'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     *  UnitDelay: '<S600>/UnitDelay'
     */
    rtb_Gain_g = ((rtb_Switch1_l4 <= 0.0F) || (((!rtb_Gain_g) && (((uint32)
                      VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff)) &&
                   (TPCR_ac_DW.UnitDelay_DSTATE_ca)));

    /* End of Outputs for SubSystem: '<S520>/TimerRetriggerResetEnabled1' */

    /* Update for UnitDelay: '<S600>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ca = rtb_Gain_g;

    /* End of Outputs for SubSystem: '<S520>/SignalLatchOnWithReset1' */

    /* Logic: '<S520>/Logical1' incorporates:
     *  Constant: '<S595>/Calib'
     *  DataStoreRead: '<S520>/DataStoreRead'
     *  Logic: '<S520>/Logical2'
     *  Logic: '<S520>/Logical4'
     *  Logic: '<S520>/Logical5'
     *  Logic: '<S520>/Logical6'
     *  Logic: '<S520>/Logical7'
     */
    VeTPCR_b_HotEnableRequest = ((((((((rtb_Switch2_nq &&
        (!VeTPCR_b_HotEnbl_PwrBdgt_SOC)) && rtb_VariantMerge_For_Variant__3) &&
        rtb_Switch3_c2) && (!TPCR_ac_DW.NeTPCR_b_12VloadShed)) &&
        (!rtb_Switch1_cs)) && (!rtb_RelationalOperator1_dfl)) && (!rtb_Gain_g)) &&
        (KeTPCR_b_Enbl_HotEnblReq));

    /* Switch: '<S520>/Switch2' incorporates:
     *  Constant: '<S594>/Calib'
     */
    if (KeTPCR_b_Enbl_BattTmpCrit_Chk)
    {
        /* RelationalOperator: '<S520>/Comparison6' incorporates:
         *  RelationalOperator: '<S520>/Comparison5'
         *  RelationalOperator: '<S520>/Comparison7'
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        rtb_Switch3_dh_tmp = TPCR_ac_B.TmpSignalConversionAtTmpVM__gr1;

        /* Switch: '<S1018>/Switch2' incorporates:
         *  Constant: '<S590>/Constant'
         *  Constant: '<S591>/Constant'
         *  Constant: '<S592>/Constant'
         *  Logic: '<S520>/Logical26'
         *  RelationalOperator: '<S520>/Comparison5'
         *  RelationalOperator: '<S520>/Comparison6'
         *  RelationalOperator: '<S520>/Comparison7'
         */
        rtb_Switch2_du = (((((uint32)rtb_Switch3_dh_tmp) == CeBTRR_e_BatOutOfRng)
                           || (((uint32)rtb_Switch3_dh_tmp) == CeBTRR_e_BatCrit))
                          || (((uint32)rtb_Switch3_dh_tmp) ==
                              CeBTRR_e_BatCritErrSt));
    }
    else
    {
        /* Switch: '<S1018>/Switch2' incorporates:
         *  Constant: '<S520>/TRUEConstant4'
         */
        rtb_Switch2_du = true;
    }

    /* End of Switch: '<S520>/Switch2' */

    /* Logic: '<S520>/Logical27' incorporates:
     *  DataStoreRead: '<S520>/DataStoreRead'
     *  Logic: '<S520>/Logical9'
     */
    VeTPCR_b_HotEnblReq_ClimateFail = ((((((((VeTPCR_b_HotEnbl_PwrBdgt_SOC) ||
        (VeTPCR_b_KeyOffCabCondThrmlFlts)) || rtb_Switch2_du) ||
        (TPCR_ac_DW.NeTPCR_b_12VloadShed)) || rtb_Switch1_cs) ||
        rtb_RelationalOperator1_dfl) || rtb_Gain_g) && (VeTPCR_b_HotEnbl_KeyChk));

    /* Logic: '<S520>/Logical28' incorporates:
     *  DataStoreRead: '<S520>/DataStoreRead'
     *  Logic: '<S520>/Logical29'
     */
    VeTPCR_b_CmftEnblReq_ClimateFail = ((VeTPCR_b_ComfortEnable_KeyChk) &&
        ((((VeTPCR_b_CmftEnbl_PwrBdgt_SOC) || (VeTPCR_b_KeyOffCabCondThrmlFlts))
          || rtb_Switch2_du) || (TPCR_ac_DW.NeTPCR_b_12VloadShed)));

    /* Logic: '<S522>/Logical1' incorporates:
     *  Constant: '<S701>/Constant'
     *  RelationalOperator: '<S522>/Comparison34'
     *  RelationalOperator: '<S607>/Comparison2'
     *  UnitDelay: '<S612>/UnitDelay4'
     */
    VeTPCR_b_PostCabinCond = (((VeTPCR_b_ComfortEnable) ||
        (VeTPCR_b_HotEnableRequest)) || (((uint32)VeTPCR_e_KHCStatus) ==
        CeTPCR_e_Active));

    /* Outputs for Atomic SubSystem: '<S19>/Hysteresis' */
    /* Switch: '<S995>/Switch1' incorporates:
     *  Constant: '<S997>/Calib'
     *  RelationalOperator: '<S995>/Greater  Than'
     */
    if (VeTPCR_Pct_HVBatSOC > KeTPCR_Pct_PerWup_SOCMax)
    {
        /* Switch: '<S995>/Switch1' incorporates:
         *  Constant: '<S995>/Constant Value'
         */
        rtb_Switch2_nq = true;
    }
    else
    {
        /* Switch: '<S995>/Switch1' incorporates:
         *  Constant: '<S998>/Calib'
         *  RelationalOperator: '<S995>/Greater  Than1'
         *  UnitDelay: '<S995>/Unit Delay'
         */
        rtb_Switch2_nq = ((VeTPCR_Pct_HVBatSOC >= KeTPCR_Pct_PerWup_SOCMin) &&
                          (TPCR_ac_DW.UnitDelay_DSTATE_ln));
    }

    /* End of Switch: '<S995>/Switch1' */

    /* Update for UnitDelay: '<S995>/Unit Delay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ln = rtb_Switch2_nq;

    /* End of Outputs for SubSystem: '<S19>/Hysteresis' */

    /* Outputs for Atomic SubSystem: '<S7>/TurnOnDelayTime1' */
    /* Logic: '<S19>/Logical3' incorporates:
     *  Logic: '<S57>/OR1'
     */
    rtb_Switch3_o = !TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gr;

    /* End of Outputs for SubSystem: '<S7>/TurnOnDelayTime1' */

    /* Outputs for Enabled SubSystem: '<S14>/PreconditionChecks' incorporates:
     *  EnablePort: '<S770>/Enable'
     */
    /* Logic: '<S19>/Logical5' incorporates:
     *  Logic: '<S770>/NOT5'
     */
    rtb_VariantMerge_For_Variant__3 = !VeTPCR_b_ChrgSysFlt;

    /* End of Outputs for SubSystem: '<S14>/PreconditionChecks' */

    /* Logic: '<S19>/Logical1' incorporates:
     *  Constant: '<S1003>/Calib'
     *  Constant: '<S1004>/Calib'
     *  Constant: '<S1006>/Calib'
     *  Constant: '<S1007>/Calib'
     *  Constant: '<S993>/Constant'
     *  Constant: '<S994>/Constant'
     *  Logic: '<S19>/Logical Operator'
     *  Logic: '<S19>/Logical2'
     *  Logic: '<S19>/Logical3'
     *  Logic: '<S19>/Logical4'
     *  Logic: '<S19>/Logical5'
     *  Logic: '<S19>/Logical6'
     *  Logic: '<S19>/Logical7'
     *  RelationalOperator: '<S19>/Comparison1'
     *  RelationalOperator: '<S19>/Comparison5'
     *  RelationalOperator: '<S519>/Comparison12'
     *  Switch: '<S1763>/Switch1'
     *  Switch: '<S996>/Switch1'
     */
    VeTPCR_b_PerWup_Enbl = (((((rtb_Switch2_nq && (KeTPCR_b_EnblBatSOC_PerWkUp))
        || (VeTPCC_b_VhclPlgdIn)) && (rtb_Switch3_o ||
        (KeTPCR_b_HoodAjarDisPerWup_Enbl))) && (rtb_VariantMerge_For_Variant__3 ||
        (KeTPCR_b_ChrgFltDisPerWup_Dsbl))) && (((((uint32)
        VeTPCR_e_FOTAInstallType) != CeCITR_e_FOTANow) && (((uint32)
        VeTPCR_e_FOTAInstallType) != CeCITR_e_FOTASchedule)) ||
        (KeTPCR_b_FOTAPerWup_Dsbl)));

    /* Logic: '<S1348>/Logical20' incorporates:
     *  Constant: '<S1433>/Constant1'
     *  Constant: '<S1433>/Constant2'
     *  Constant: '<S1439>/Calib'
     *  DataStoreRead: '<S1433>/StatusByte_BattCoolPmpPerf'
     *  Logic: '<S1433>/LogicalOperator'
     *  RelationalOperator: '<S1433>/RelationalOperator1'
     *  RelationalOperator: '<S1433>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1433>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1433>/BitwiseOperator2'
     */
    VeTPCR_b_LTAP_PerfFlt = ((((((sint32)TPCR_ac_DW.StatusByte_BattCoolPmpPerf)
        & 1) > 0) && ((((uint32)TPCR_ac_DW.StatusByte_BattCoolPmpPerf) & 64U) ==
                      0U)) && (KeTPCR_b_Enbl_LTAP_PerfFlt));

    /* Logic: '<S1348>/Logical5' incorporates:
     *  Constant: '<S1432>/Constant1'
     *  Constant: '<S1432>/Constant2'
     *  Constant: '<S1440>/Calib'
     *  DataStoreRead: '<S1432>/StatusByte_BattCoolPmpATempSnsrPerf'
     *  Logic: '<S1432>/LogicalOperator'
     *  RelationalOperator: '<S1432>/RelationalOperator1'
     *  RelationalOperator: '<S1432>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1432>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1432>/BitwiseOperator2'
     */
    VeTPCR_b_LTAP_TmpSnsrFlt = ((((((sint32)
        TPCR_ac_DW.StatusByte_BattCoolPmpATempSnsr) & 1) > 0) && ((((uint32)
        TPCR_ac_DW.StatusByte_BattCoolPmpATempSnsr) & 64U) == 0U)) &&
        (KeTPCR_b_Enbl_LTAP_TmpFlt));

    /* Logic: '<S1348>/Logical3' incorporates:
     *  Constant: '<S1429>/Constant1'
     *  Constant: '<S1429>/Constant2'
     *  Constant: '<S1430>/Constant'
     *  Constant: '<S1431>/Constant'
     *  Constant: '<S1434>/Calib'
     *  Constant: '<S1435>/Calib'
     *  Constant: '<S1436>/Calib'
     *  Constant: '<S1437>/Calib'
     *  Constant: '<S1438>/Calib'
     *  Constant: '<S1441>/Constant1'
     *  Constant: '<S1441>/Constant2'
     *  Constant: '<S1442>/Constant1'
     *  Constant: '<S1442>/Constant2'
     *  Constant: '<S1443>/Constant1'
     *  Constant: '<S1443>/Constant2'
     *  Constant: '<S1444>/Constant1'
     *  Constant: '<S1444>/Constant2'
     *  DataStoreRead: '<S1429>/StatusByte_BattCoolPmpOveSpd'
     *  DataStoreRead: '<S1444>/StatusByte_LostCommHB_CoolPmp'
     *  Logic: '<S1348>/Logical Operator'
     *  Logic: '<S1348>/Logical Operator1'
     *  Logic: '<S1348>/Logical Operator2'
     *  Logic: '<S1348>/Logical Operator3'
     *  Logic: '<S1348>/Logical Operator4'
     *  Logic: '<S1348>/Logical Operator5'
     *  Logic: '<S1429>/Logical Operator'
     *  Logic: '<S1441>/Logical Operator'
     *  Logic: '<S1442>/Logical Operator'
     *  Logic: '<S1443>/Logical Operator'
     *  Logic: '<S1444>/Logical Operator'
     *  RelationalOperator: '<S1348>/Comparison1'
     *  RelationalOperator: '<S1348>/Comparison4'
     *  RelationalOperator: '<S1429>/Relational Operator1'
     *  RelationalOperator: '<S1429>/Relational Operator2'
     *  RelationalOperator: '<S1441>/Relational Operator1'
     *  RelationalOperator: '<S1441>/Relational Operator2'
     *  RelationalOperator: '<S1442>/Relational Operator1'
     *  RelationalOperator: '<S1442>/Relational Operator2'
     *  RelationalOperator: '<S1443>/Relational Operator1'
     *  RelationalOperator: '<S1443>/Relational Operator2'
     *  RelationalOperator: '<S1444>/Relational Operator1'
     *  RelationalOperator: '<S1444>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S1429>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1429>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1444>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1444>/Bitwise Operator2'
     *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
     *  Switch: '<S1777>/Switch'
     */
    VeTPCR_b_LTAP_Flts = (((((((((VeTPCR_b_LTAP_PerfFlt) ||
        (CePMPR_e_FTSNA_False != ((uint32)
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ag))) ||
        (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ci)) || (((uint32)
        VeTPCR_e_LTAP_LOC) != CeBPCR_e_LOC_BCP_False)) || (VeTPCR_b_LTAP_LOC_FA))
        || (VeTPCR_b_LTAP_TmpSnsrFlt)) || ((((((uint32)
        TPCR_ac_DW.StatusByte_BattCoolPmpOveSpd) & 1U) != 0U) && ((((uint32)
        TPCR_ac_DW.StatusByte_BattCoolPmpOveSpd) & 64U) == 0U)) &&
        (KeTPCR_b_Enbl_LTAP_OvSpFlt))) || ((((((uint32)
        TPCR_ac_DW.StatusByte_LostCommHB_CoolPmp) & 1U) != 0U) && ((((uint32)
        TPCR_ac_DW.StatusByte_LostCommHB_CoolPmp) & 64U) == 0U)) &&
                            (KeTPCR_b_Enbl_LTAP_ClPmpFlt))) ||
                          (((((rtb_Switch_cw_tmp_0 != 0U) &&
        (rtb_Switch_cw_tmp_1 == 0U)) && (KeTPCR_b_Enbl_LTAP_LIN1BusFlt)) ||
                            (((rtb_Switch_cw_tmp_6 != 0U) && (rtb_Switch_cw_tmp ==
        0U)) && (KeTPCR_b_Enbl_LTAP_LIN2BusFlt))) || (((rtb_Switch_cw_tmp_2 !=
        0U) && (rtb_Switch_cw_tmp_3 == 0U)) && (KeTPCR_b_Enbl_LTAP_LIN3BusFlt))));

    /* Logic: '<S1350>/Logical7' incorporates:
     *  Constant: '<S1457>/Constant1'
     *  Constant: '<S1457>/Constant2'
     *  Constant: '<S1458>/Calib'
     *  DataStoreRead: '<S1457>/StatusByte_HB_CT_SnsrPerf'
     *  Logic: '<S1457>/LogicalOperator'
     *  RelationalOperator: '<S1457>/RelationalOperator1'
     *  RelationalOperator: '<S1457>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1457>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1457>/BitwiseOperator2'
     */
    VeTPCR_b_BTISFlt = ((((((sint32)TPCR_ac_DW.StatusByte_HB_CT_SnsrPerf) & 1) >
                          0) && ((((uint32)TPCR_ac_DW.StatusByte_HB_CT_SnsrPerf)
                           & 64U) == 0U)) && (KeTPCR_b_Enbl_BTIS_Flt));

    /* Logic: '<S1350>/Logical8' incorporates:
     *  Constant: '<S1456>/Constant1'
     *  Constant: '<S1456>/Constant2'
     *  Constant: '<S1459>/Calib'
     *  DataStoreRead: '<S1456>/StatusByte_CoolOutTempSnsCkt'
     *  Logic: '<S1456>/LogicalOperator'
     *  RelationalOperator: '<S1456>/RelationalOperator1'
     *  RelationalOperator: '<S1456>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1456>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1456>/BitwiseOperator2'
     */
    VeTPCR_b_BTOSFlt = ((((((sint32)TPCR_ac_DW.StatusByte_CoolOutTempSnsCkt) & 1)
                          > 0) && ((((uint32)
                            TPCR_ac_DW.StatusByte_CoolOutTempSnsCkt) & 64U) ==
                          0U)) && (KeTPCR_b_Enbl_BTOS_Flt));

    /* Logic: '<S1350>/Logical2' incorporates:
     *  SignalConversion generated from: '<S1350>/VariantSource'
     */
#if Rte_SysCon_Variant_TPCR_27

    /* UnitDelay: '<S749>/UnitDelay' */
    rtb_UnitDelay_jk = !VeTPCR_b_Rly_EnblCmnd_AD;

#else

    /* UnitDelay: '<S749>/UnitDelay' incorporates:
     *  Constant: '<S1350>/Constant'
     *  SignalConversion generated from: '<S1350>/VariantSource'
     */
    rtb_UnitDelay_jk = false;

#endif

    /* End of Logic: '<S1350>/Logical2' */

    /* Logic: '<S1350>/Logical20' incorporates:
     *  Constant: '<S1454>/Constant1'
     *  Constant: '<S1454>/Constant2'
     *  Constant: '<S1460>/Calib'
     *  DataStoreRead: '<S1454>/StatusByte_BattCoolLvlLow'
     *  Logic: '<S1454>/LogicalOperator'
     *  RelationalOperator: '<S1454>/RelationalOperator1'
     *  RelationalOperator: '<S1454>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1454>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1454>/BitwiseOperator2'
     */
    VeTPCR_b_BtlClntLvlLo_Flt = ((((((sint32)
        TPCR_ac_DW.StatusByte_BattCoolLvlLow) & 1) > 0) && ((((uint32)
        TPCR_ac_DW.StatusByte_BattCoolLvlLow) & 64U) == 0U)) &&
        (KeTPCR_b_Enbl_BtlClntLvlLo_Flt));

    /* Logic: '<S1350>/Logical21' incorporates:
     *  Constant: '<S1455>/Constant1'
     *  Constant: '<S1455>/Constant2'
     *  Constant: '<S1461>/Calib'
     *  DataStoreRead: '<S1455>/StatusByte_BattCoolLvlSnsCkt'
     *  Logic: '<S1455>/LogicalOperator'
     *  RelationalOperator: '<S1455>/RelationalOperator1'
     *  RelationalOperator: '<S1455>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1455>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1455>/BitwiseOperator2'
     */
    VeTPCR_b_BtlSnsr_SG_Flt = ((((((sint32)
        TPCR_ac_DW.StatusByte_BattCoolLvlSnsCkt) & 1) > 0) && ((((uint32)
        TPCR_ac_DW.StatusByte_BattCoolLvlSnsCkt) & 64U) == 0U)) &&
        (KeTPCR_b_Enbl_BtlSnsr_SG));

    /* UnitDelay: '<S749>/UnitDelay' incorporates:
     *  Logic: '<S1350>/Logical1'
     */
    rtb_UnitDelay_jk = (((((VeTPCR_b_BTISFlt) || (VeTPCR_b_BTOSFlt)) ||
                          rtb_UnitDelay_jk) || (VeTPCR_b_BtlClntLvlLo_Flt)) ||
                        (VeTPCR_b_BtlSnsr_SG_Flt));

    /* SignalConversion generated from: '<S1340>/VariantSource2' incorporates:
     *  Logic: '<S1356>/LogicalOperator'
     *  RelationalOperator: '<S1356>/RelationalOperator1'
     *  RelationalOperator: '<S1356>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1356>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1356>/BitwiseOperator2'
     */
#if Rte_SysCon_Variant_TPCR_7

    /* Switch: '<S989>/Switch1' incorporates:
     *  Constant: '<S1340>/Constant2'
     */
    rtb_Switch1_mw = false;

#else

    /* Switch: '<S989>/Switch1' incorporates:
     *  Constant: '<S1356>/Constant1'
     *  Constant: '<S1356>/Constant2'
     *  DataStoreRead: '<S1356>/StatusByte_BattHeat'
     *  Logic: '<S1356>/LogicalOperator'
     *  RelationalOperator: '<S1356>/RelationalOperator1'
     *  RelationalOperator: '<S1356>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1356>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1356>/BitwiseOperator2'
     */
    rtb_Switch1_mw = (((((sint32)TPCR_ac_DW.StatusByte_BattHeat) & 1) > 0) &&
                      ((((uint32)TPCR_ac_DW.StatusByte_BattHeat) & 64U) == 0U));

#endif

    /* End of SignalConversion generated from: '<S1340>/VariantSource2' */

    /* SignalConversion generated from: '<S1340>/VariantSource2' */
    VeTPCR_b_BattHeatFlt = rtb_Switch1_mw;

    /* SignalConversion generated from: '<S1340>/VariantSource' incorporates:
     *  Logic: '<S1359>/LogicalOperator'
     *  RelationalOperator: '<S1359>/RelationalOperator1'
     *  RelationalOperator: '<S1359>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1359>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1359>/BitwiseOperator2'
     */
#if Rte_SysCon_Variant_TPCR_5

    /* Switch: '<S989>/Switch1' incorporates:
     *  Constant: '<S1340>/Constant'
     */
    rtb_Switch1_mw = false;

#else

    /* Switch: '<S989>/Switch1' incorporates:
     *  Constant: '<S1359>/Constant1'
     *  Constant: '<S1359>/Constant2'
     *  DataStoreRead: '<S1359>/StatusByte_CoolantHeaterBPerf'
     *  Logic: '<S1359>/LogicalOperator'
     *  RelationalOperator: '<S1359>/RelationalOperator1'
     *  RelationalOperator: '<S1359>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1359>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1359>/BitwiseOperator2'
     */
    rtb_Switch1_mw = (((((sint32)TPCR_ac_DW.StatusByte_CoolantHeaterBPerf) & 1) >
                       0) && ((((uint32)TPCR_ac_DW.StatusByte_CoolantHeaterBPerf)
                        & 64U) == 0U));

#endif

    /* End of SignalConversion generated from: '<S1340>/VariantSource' */

    /* SignalConversion generated from: '<S1340>/VariantSource' */
    VeTPCR_b_BattHtrPerf_Flt = rtb_Switch1_mw;

    /* Logic: '<S1340>/Logical8' incorporates:
     *  Constant: '<S1355>/Constant1'
     *  Constant: '<S1355>/Constant2'
     *  Constant: '<S1365>/Calib'
     *  DataStoreRead: '<S1355>/StatusByte_BattCoolPmpHtrBTempSnsrPerf'
     *  Logic: '<S1355>/LogicalOperator'
     *  RelationalOperator: '<S1355>/RelationalOperator1'
     *  RelationalOperator: '<S1355>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1355>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1355>/BitwiseOperator2'
     */
    VeTPCR_b_BHOSFlt = ((((((sint32)TPCR_ac_DW.StatusByte_BattCoolPmpHtrBTempS)
                           & 1) > 0) && ((((uint32)
                            TPCR_ac_DW.StatusByte_BattCoolPmpHtrBTempS) & 64U) ==
                          0U)) && (KeTPCR_b_Enbl_BHOS_Flt));

    /* S-Function (sfix_bitop): '<S1362>/BitwiseOperator2' incorporates:
     *  Logic: '<S1362>/LogicalOperator'
     *  RelationalOperator: '<S1362>/RelationalOperator1'
     *  RelationalOperator: '<S1362>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1362>/BitwiseOperator1'
     *  SignalConversion generated from: '<S1340>/VariantSource1'
     */
#if Rte_SysCon_Variant_TPCR_6

    /* Switch: '<S989>/Switch1' incorporates:
     *  Constant: '<S1362>/Constant1'
     *  Constant: '<S1362>/Constant2'
     *  DataStoreRead: '<S1362>/StatusByte_LosCommBECM_A'
     */
    rtb_Switch1_mw = (((((sint32)TPCR_ac_DW.StatusByte_LosCommBECM_A) & 1) > 0) &&
                      ((((uint32)TPCR_ac_DW.StatusByte_LosCommBECM_A) & 64U) ==
                       0U));

#else

    /* Switch: '<S989>/Switch1' incorporates:
     *  Constant: '<S1340>/Constant1'
     *  SignalConversion generated from: '<S1340>/VariantSource1'
     */
    rtb_Switch1_mw = false;

#endif

    /* End of S-Function (sfix_bitop): '<S1362>/BitwiseOperator2' */

    /* Logic: '<S1340>/Logical21' incorporates:
     *  Constant: '<S1361>/Constant1'
     *  Constant: '<S1361>/Constant2'
     *  Constant: '<S1363>/Calib'
     *  DataStoreRead: '<S1361>/StatusByte_LosCommBECM_A_CANC11'
     *  Logic: '<S1340>/Logical12'
     *  Logic: '<S1361>/LogicalOperator'
     *  RelationalOperator: '<S1361>/RelationalOperator1'
     *  RelationalOperator: '<S1361>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1361>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1361>/BitwiseOperator2'
     */
    VeTPCR_b_BPCMLOC = (rtb_Switch1_mw && ((((((sint32)
        TPCR_ac_DW.StatusByte_LosCommBECM_A_CANC11) & 1) > 0) && ((((uint32)
        TPCR_ac_DW.StatusByte_LosCommBECM_A_CANC11) & 64U) == 0U)) ||
                         (KeTPCR_b_Dsbl_RdntBPCM_LOC)));

    /* S-Function (sfix_bitop): '<S1357>/BitwiseOperator2' incorporates:
     *  Logic: '<S1357>/LogicalOperator'
     *  RelationalOperator: '<S1357>/RelationalOperator1'
     *  RelationalOperator: '<S1357>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1357>/BitwiseOperator1'
     *  SignalConversion generated from: '<S1340>/VariantSource5'
     */
#if Rte_SysCon_Variant_TPCR_28

    /* Switch: '<S989>/Switch1' incorporates:
     *  Constant: '<S1357>/Constant1'
     *  Constant: '<S1357>/Constant2'
     *  DataStoreRead: '<S1357>/StatusByte_CommBusOff'
     */
    rtb_Switch1_mw = (((((sint32)TPCR_ac_DW.StatusByte_CommBusOff) & 1) > 0) &&
                      ((((uint32)TPCR_ac_DW.StatusByte_CommBusOff) & 64U) == 0U));

#else

    /* Switch: '<S989>/Switch1' incorporates:
     *  Constant: '<S1340>/Constant5'
     *  SignalConversion generated from: '<S1340>/VariantSource5'
     */
    rtb_Switch1_mw = false;

#endif

    /* End of S-Function (sfix_bitop): '<S1357>/BitwiseOperator2' */

    /* Logic: '<S1340>/Logical1' incorporates:
     *  Constant: '<S1358>/Constant1'
     *  Constant: '<S1358>/Constant2'
     *  Constant: '<S1364>/Calib'
     *  DataStoreRead: '<S1358>/StatusByte_CommBus_B_Off'
     *  Logic: '<S1340>/Logical10'
     *  Logic: '<S1358>/LogicalOperator'
     *  RelationalOperator: '<S1358>/RelationalOperator1'
     *  RelationalOperator: '<S1358>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1358>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1358>/BitwiseOperator2'
     */
    VeTPCR_b_ePTBUSOff = (rtb_Switch1_mw && ((((((sint32)
        TPCR_ac_DW.StatusByte_CommBus_B_Off) & 1) > 0) && ((((uint32)
        TPCR_ac_DW.StatusByte_CommBus_B_Off) & 64U) == 0U)) ||
                           (KeTPCR_b_Dsbl_RdntePTBusOff_Flt)));

    /* SignalConversion generated from: '<S1340>/VariantSource3' incorporates:
     *  Logic: '<S1360>/LogicalOperator'
     *  RelationalOperator: '<S1360>/RelationalOperator1'
     *  RelationalOperator: '<S1360>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1360>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1360>/BitwiseOperator2'
     */
#if Rte_SysCon_Variant_TPCR_17

    /* Switch: '<S989>/Switch1' incorporates:
     *  Constant: '<S1340>/Constant3'
     */
    rtb_Switch1_mw = false;

#else

    /* Switch: '<S989>/Switch1' incorporates:
     *  Constant: '<S1360>/Constant1'
     *  Constant: '<S1360>/Constant2'
     *  DataStoreRead: '<S1360>/StatusByte_HeatingElmntPerf'
     *  Logic: '<S1360>/LogicalOperator'
     *  RelationalOperator: '<S1360>/RelationalOperator1'
     *  RelationalOperator: '<S1360>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1360>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1360>/BitwiseOperator2'
     */
    rtb_Switch1_mw = (((((sint32)TPCR_ac_DW.StatusByte_HeatingElmntPerf) & 1) >
                       0) && ((((uint32)TPCR_ac_DW.StatusByte_HeatingElmntPerf)
                        & 64U) == 0U));

#endif

    /* End of SignalConversion generated from: '<S1340>/VariantSource3' */

    /* SignalConversion generated from: '<S1340>/VariantSource3' */
    VeTPCR_b_HeatingElmntFlt = rtb_Switch1_mw;

    /* SignalConversion generated from: '<S1340>/VariantSource4' incorporates:
     *  Logic: '<S1340>/Logical2'
     *  RelationalOperator: '<S1340>/Comparison11'
     *  RelationalOperator: '<S1340>/Comparison2'
     *  RelationalOperator: '<S1340>/Comparison3'
     */
#if Rte_SysCon_Variant_TPCR_20

    /* Switch: '<S989>/Switch1' incorporates:
     *  Constant: '<S1340>/Constant4'
     */
    rtb_Switch1_mw = false;

#else

    /* Switch: '<S989>/Switch1' incorporates:
     *  Constant: '<S1351>/Constant'
     *  Constant: '<S1352>/Constant'
     *  Constant: '<S1353>/Constant'
     *  Logic: '<S1340>/Logical2'
     *  RelationalOperator: '<S1340>/Comparison11'
     *  RelationalOperator: '<S1340>/Comparison2'
     *  RelationalOperator: '<S1340>/Comparison3'
     *  Switch: '<S1761>/Switch1'
     */
    rtb_Switch1_mw = (((((uint32)Switch1_e) ==
                        CeHTIR_e_HtrSts_LockedUntilNextStart) || (((uint32)
                         Switch1_e) == CeHTIR_e_HtrSts_LockedUntilService)) ||
                      (((uint32)Switch1_e) == CeHTIR_e_HtrSts_LockedPermanent));

#endif

    /* End of SignalConversion generated from: '<S1340>/VariantSource4' */

    /* Logic: '<S1340>/Logical3' incorporates:
     *  Constant: '<S1354>/Constant'
     *  RelationalOperator: '<S1340>/Comparison1'
     *  Switch: '<S1776>/Switch'
     */
    VeTPCR_b_BattHeaterFlts = (((((((((VeTPCR_b_BattHeatFlt) || (((uint32)
        VeTPCR_e_BattHtr_LOC) != CeBPCR_e_LOC_BatClntHtr_False)) ||
        (VeTPCR_b_BattHtr_LOC_FA)) || (VeTPCR_b_BattHtrPerf_Flt)) ||
        (VeTPCR_b_BHOSFlt)) || (VeTPCR_b_BPCMLOC)) || (VeTPCR_b_ePTBUSOff)) ||
        (VeTPCR_b_HeatingElmntFlt)) || rtb_Switch1_mw);

    /* Logic: '<S1345>/Logical20' incorporates:
     *  Constant: '<S1412>/Constant1'
     *  Constant: '<S1412>/Constant2'
     *  Constant: '<S1413>/Constant1'
     *  Constant: '<S1413>/Constant2'
     *  Constant: '<S1414>/Constant1'
     *  Constant: '<S1414>/Constant2'
     *  Constant: '<S1416>/Calib'
     *  DataStoreRead: '<S1412>/StatusByte_CoolantVlvA_CktHi'
     *  DataStoreRead: '<S1413>/StatusByte_CoolantVlvA_CktLo'
     *  DataStoreRead: '<S1414>/StatusByte_CoolantVlvA_Ckt'
     *  Logic: '<S1345>/Logical8'
     *  Logic: '<S1412>/LogicalOperator'
     *  Logic: '<S1413>/LogicalOperator'
     *  Logic: '<S1414>/LogicalOperator'
     *  RelationalOperator: '<S1412>/RelationalOperator1'
     *  RelationalOperator: '<S1412>/RelationalOperator2'
     *  RelationalOperator: '<S1413>/RelationalOperator1'
     *  RelationalOperator: '<S1413>/RelationalOperator2'
     *  RelationalOperator: '<S1414>/RelationalOperator1'
     *  RelationalOperator: '<S1414>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1412>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1412>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S1413>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1413>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S1414>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1414>/BitwiseOperator2'
     */
    VeTPCR_b_HTCV_PinFlts = ((((((((sint32)TPCR_ac_DW.StatusByte_CoolantVlvA_Ckt)
        & 1) > 0) && ((((uint32)TPCR_ac_DW.StatusByte_CoolantVlvA_Ckt) & 64U) ==
                      0U)) || (((((sint32)
        TPCR_ac_DW.StatusByte_CoolantVlvA_CktLo) & 1) > 0) && ((((uint32)
        TPCR_ac_DW.StatusByte_CoolantVlvA_CktLo) & 64U) == 0U))) || (((((sint32)
        TPCR_ac_DW.StatusByte_CoolantVlvA_CktHi) & 1) > 0) && ((((uint32)
        TPCR_ac_DW.StatusByte_CoolantVlvA_CktHi) & 64U) == 0U))) &&
        (KeTPCR_b_Enbl_HTCV_PinFlts));

    /* Logic: '<S1345>/Logical5' incorporates:
     *  Constant: '<S1415>/Constant1'
     *  Constant: '<S1415>/Constant2'
     *  Constant: '<S1417>/Calib'
     *  DataStoreRead: '<S1415>/StatusByte_CoolantVlvA_Perf'
     *  Logic: '<S1415>/LogicalOperator'
     *  RelationalOperator: '<S1415>/RelationalOperator1'
     *  RelationalOperator: '<S1415>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1415>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1415>/BitwiseOperator2'
     */
    VeTPCR_b_HTCV_StckFlt = ((((((sint32)TPCR_ac_DW.StatusByte_CoolantVlvA_Perf)
        & 1) > 0) && ((((uint32)TPCR_ac_DW.StatusByte_CoolantVlvA_Perf) & 64U) ==
                      0U)) && (KeTPCR_b_Enbl_HTCV_StckFlt));

    /* Switch: '<S989>/Switch1' incorporates:
     *  Logic: '<S1345>/Logical3'
     */
    rtb_Switch1_mw = ((VeTPCR_b_HTCV_PinFlts) || (VeTPCR_b_HTCV_StckFlt));

    /* Logic: '<S1024>/Logical1' incorporates:
     *  Logic: '<S1024>/Logical3'
     */
    rtb_UnitDelay_gcx_tmp = (((VeTPCR_b_LTAP_Flts) || rtb_UnitDelay_jk) ||
        (VeTPCR_b_BattHeaterFlts));

    /* UnitDelay: '<S26>/UnitDelay' incorporates:
     *  Logic: '<S1024>/Logical1'
     */
    rtb_UnitDelay_l3 = (rtb_UnitDelay_gcx_tmp || rtb_Switch1_mw);

    /* Outputs for Atomic SubSystem: '<S1019>/EdgeRising2' */
    /* Logic: '<S1079>/OR1' incorporates:
     *  UnitDelay: '<S1079>/UnitDelay'
     */
    rtb_Switch2_nq = !TPCR_ac_DW.UnitDelay_DSTATE_ou;

    /* Update for UnitDelay: '<S1079>/UnitDelay' incorporates:
     *  Constant: '<S1019>/TRUEConstant3'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_ou = true;

    /* End of Outputs for SubSystem: '<S1019>/EdgeRising2' */

    /* Switch: '<S1019>/Switch' incorporates:
     *  Constant: '<S1080>/Constant'
     *  Constant: '<S1082>/Constant'
     *  Constant: '<S1086>/Calib'
     *  Logic: '<S1019>/Logical2'
     *  RelationalOperator: '<S1019>/Comparison2'
     *  RelationalOperator: '<S1019>/Comparison3'
     */
    if (KeTPCR_b_Wp_CabPrecBatCrit_S)
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = (((uint32)Switch_cl) ==
            CeTPCR_e_NoCabPrec_HV_BatCrit);
    }
    else
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = (((uint32)Switch_cl) !=
            CeTPCR_e_OkCabinPrec);
    }

    /* Switch: '<S1019>/Switch1' incorporates:
     *  Constant: '<S1019>/TRUEConstant'
     *  Constant: '<S1083>/Calib'
     *  Logic: '<S1019>/Logical3'
     */
    if (KeTPCR_b_EnblHVBatPWup_RSDnd)
    {
        rtb_Gain_g = !VeTPCR_b_HVBatPerWkUp;
    }
    else
    {
        rtb_Gain_g = true;
    }

    /* End of Switch: '<S1019>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S1019>/SignalLatchOnWithReset1' */
    /* Outputs for Atomic SubSystem: '<S1019>/EdgeRising2' */
    /* Logic: '<S1087>/OR1' incorporates:
     *  Constant: '<S1009>/Calib'
     *  Constant: '<S1010>/Calib'
     *  Constant: '<S1081>/Constant'
     *  Constant: '<S1084>/Calib'
     *  Constant: '<S1085>/Calib'
     *  Logic: '<S1019>/Logical1'
     *  Logic: '<S1019>/Logical15'
     *  Logic: '<S1019>/Logical4'
     *  Logic: '<S1019>/Logical6'
     *  Logic: '<S1079>/AND'
     *  Logic: '<S1087>/OR'
     *  RelationalOperator: '<S1019>/Comparison1'
     *  RelationalOperator: '<S1019>/Comparison4'
     *  RelationalOperator: '<S1019>/Comparison6'
     *  RelationalOperator: '<S612>/Comparison5'
     *  Switch: '<S1775>/Switch'
     *  UnitDelay: '<S1087>/UnitDelay'
     */
    VeTPCC_b_NoWup_RS_DendShrtTimr = (((((((VeTPCR_b_DoorAjarEnblLtch_Rst_t &&
        ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn >
          KeTPCR_dT_PerWup_CellUnderTemp_Min) ||
         (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_g >
          KeTPCR_dT_PerWup_CellOverTemp_Min))) && (VeTPCR_b_PerWup_Enbl)) &&
        (((uint32)VeTPCR_e_ShippingMode_AD) != CePLTR_e_ShipingMode_SHIP_MD)) &&
        rtb_Gain_g) && (KeTPCR_b_EnblRSDnd_PerWUp)) && ((!rtb_UnitDelay_l3) ||
        (KeTPCR_b_NoWpBattCrit_ThrmlFltsChk))) || ((!rtb_Switch2_nq) &&
        (TPCR_ac_DW.UnitDelay_DSTATE_mh2)));

    /* End of Outputs for SubSystem: '<S1019>/EdgeRising2' */

    /* Update for UnitDelay: '<S1087>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_mh2 = VeTPCC_b_NoWup_RS_DendShrtTimr;

    /* End of Outputs for SubSystem: '<S1019>/SignalLatchOnWithReset1' */

    /* Logic: '<S1015>/Logical' */
    VeTPCC_b_RS_WUpNVRAM = ((VeTPCC_b_NoWup_RS_DendShrtTimr) &&
                            (VeTPCR_b_HCPShutDwnCmd));

    /* UnitDelay: '<S19>/UnitDelay2' */
    rtb_UnitDelay4_k = TPCR_ac_DW.UnitDelay2_DSTATE_d;

    /* Logic: '<S1344>/Logical20' incorporates:
     *  Constant: '<S1400>/Constant1'
     *  Constant: '<S1400>/Constant2'
     *  Constant: '<S1405>/Calib'
     *  Logic: '<S1400>/LogicalOperator'
     *  RelationalOperator: '<S1400>/RelationalOperator1'
     *  RelationalOperator: '<S1400>/RelationalOperator2'
     */
    VeTPCR_b_HTAP_PerfFlt = (((rtb_Switch_cw_tmp_7 > 0) && (rtb_Switch_cw_tmp_8 ==
        0U)) && (KeTPCR_b_Enbl_HTAP_PerfFlt));

    /* Logic: '<S1344>/Logical5' incorporates:
     *  Constant: '<S1402>/Constant1'
     *  Constant: '<S1402>/Constant2'
     *  Constant: '<S1409>/Calib'
     *  Logic: '<S1402>/LogicalOperator'
     *  RelationalOperator: '<S1402>/RelationalOperator1'
     *  RelationalOperator: '<S1402>/RelationalOperator2'
     */
    VeTPCR_b_LOC_HTAP = (((rtb_Switch_cw_tmp_9 > 0) && (rtb_Switch_cw_tmp_a ==
                           0U)) && (KeTPCR_b_Enbl_LOC_HTAP));

    /* Logic: '<S1344>/Logical1' incorporates:
     *  Constant: '<S1401>/Constant1'
     *  Constant: '<S1401>/Constant2'
     *  Constant: '<S1407>/Calib'
     *  Logic: '<S1401>/LogicalOperator'
     *  RelationalOperator: '<S1401>/RelationalOperator1'
     *  RelationalOperator: '<S1401>/RelationalOperator2'
     */
    VeTPCR_b_LIN2_BusOff = (((rtb_Switch_cw_tmp_5 > 0) && (rtb_Switch_cw_tmp ==
        0U)) && (KeTPCR_b_Enbl_LIN2BusOff_Flt));

    /* Logic: '<S1342>/Logical20' incorporates:
     *  Constant: '<S1379>/Constant1'
     *  Constant: '<S1379>/Constant2'
     *  Constant: '<S1380>/Constant1'
     *  Constant: '<S1380>/Constant2'
     *  Constant: '<S1391>/Calib'
     *  DataStoreRead: '<S1379>/StatusByte_LostCommCoolHtrA'
     *  DataStoreRead: '<S1380>/StatusByte_LostCommHighVolCabinAirHtr'
     *  Logic: '<S1342>/Logical11'
     *  Logic: '<S1379>/LogicalOperator'
     *  Logic: '<S1380>/LogicalOperator'
     *  RelationalOperator: '<S1379>/RelationalOperator1'
     *  RelationalOperator: '<S1379>/RelationalOperator2'
     *  RelationalOperator: '<S1380>/RelationalOperator1'
     *  RelationalOperator: '<S1380>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1379>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1379>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S1380>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1380>/BitwiseOperator2'
     */
    VeTPCR_b_LOC_ECH = (((((((sint32)TPCR_ac_DW.StatusByte_LostCommCoolHtrA) & 1)
                           > 0) && ((((uint32)
        TPCR_ac_DW.StatusByte_LostCommCoolHtrA) & 64U) == 0U)) || (((((sint32)
        TPCR_ac_DW.StatusByte_LostCommHighVolCabin) & 1) > 0) && ((((uint32)
        TPCR_ac_DW.StatusByte_LostCommHighVolCabin) & 64U) == 0U))) &&
                        (KeTPCR_b_Enbl_LOC_ECH));

    /* Logic: '<S1342>/Logical5' incorporates:
     *  Constant: '<S1371>/Constant1'
     *  Constant: '<S1371>/Constant2'
     *  Constant: '<S1387>/Calib'
     *  DataStoreRead: '<S1371>/StatusByte_CoolHeaterAPerf'
     *  Logic: '<S1371>/LogicalOperator'
     *  RelationalOperator: '<S1371>/RelationalOperator1'
     *  RelationalOperator: '<S1371>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1371>/BitwiseOperator2'
     */
    VeTPCR_b_ECH_PerfFlt = ((((((sint32)TPCR_ac_DW.StatusByte_CoolHeaterAPerf) &
        1) > 0) && (rtb_Switch_cw_tmp_b == 0U)) && (KeTPCR_b_Enbl_ECH_PerfFlt));

    /* Logic: '<S1342>/Logical1' incorporates:
     *  Constant: '<S1368>/Constant1'
     *  Constant: '<S1368>/Constant2'
     *  Constant: '<S1369>/Constant1'
     *  Constant: '<S1369>/Constant2'
     *  Constant: '<S1370>/Constant1'
     *  Constant: '<S1370>/Constant2'
     *  Constant: '<S1383>/Calib'
     *  DataStoreRead: '<S1368>/StatusByte_CT2_SnsrCktHi'
     *  DataStoreRead: '<S1369>/StatusByte_CT2_SnsrCktLo'
     *  DataStoreRead: '<S1370>/StatusByte_CT2_SnsrPerf'
     *  Logic: '<S1342>/Logical2'
     *  Logic: '<S1368>/LogicalOperator'
     *  Logic: '<S1369>/LogicalOperator'
     *  Logic: '<S1370>/LogicalOperator'
     *  RelationalOperator: '<S1368>/RelationalOperator1'
     *  RelationalOperator: '<S1368>/RelationalOperator2'
     *  RelationalOperator: '<S1369>/RelationalOperator1'
     *  RelationalOperator: '<S1369>/RelationalOperator2'
     *  RelationalOperator: '<S1370>/RelationalOperator1'
     *  RelationalOperator: '<S1370>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1368>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1368>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S1369>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1369>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S1370>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1370>/BitwiseOperator2'
     */
    VeTPCR_b_ECHTIS_PinDiag = ((((((((sint32)TPCR_ac_DW.StatusByte_CT2_SnsrCktLo)
        & 1) > 0) && ((((uint32)TPCR_ac_DW.StatusByte_CT2_SnsrCktLo) & 64U) ==
                      0U)) || (((((sint32)TPCR_ac_DW.StatusByte_CT2_SnsrCktHi) &
        1) > 0) && ((((uint32)TPCR_ac_DW.StatusByte_CT2_SnsrCktHi) & 64U) == 0U)))
        || (((((sint32)TPCR_ac_DW.StatusByte_CT2_SnsrPerf) & 1) > 0) &&
            ((((uint32)TPCR_ac_DW.StatusByte_CT2_SnsrPerf) & 64U) == 0U))) &&
        (KeTPCR_b_Enbl_ECHTIS_Flt));

    /* Logic: '<S1342>/Logical4' incorporates:
     *  Constant: '<S1377>/Constant1'
     *  Constant: '<S1377>/Constant2'
     *  Constant: '<S1381>/Calib'
     *  DataStoreRead: '<S1377>/StatusByte_ECH_TempIn'
     *  Logic: '<S1377>/LogicalOperator'
     *  RelationalOperator: '<S1377>/RelationalOperator1'
     *  RelationalOperator: '<S1377>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1377>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1377>/BitwiseOperator2'
     */
    VeTPCR_b_ECH_InFlt = ((((((sint32)TPCR_ac_DW.StatusByte_ECH_TempIn) & 1) > 0)
                           && ((((uint32)TPCR_ac_DW.StatusByte_ECH_TempIn) & 64U)
                            == 0U)) && (KeTPCR_b_Enbl_ECHIn_Flt));

    /* Logic: '<S1342>/Logical6' incorporates:
     *  Constant: '<S1378>/Constant1'
     *  Constant: '<S1378>/Constant2'
     *  Constant: '<S1382>/Calib'
     *  DataStoreRead: '<S1378>/StatusByte_ECH_TempOut'
     *  Logic: '<S1378>/LogicalOperator'
     *  RelationalOperator: '<S1378>/RelationalOperator1'
     *  RelationalOperator: '<S1378>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1378>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1378>/BitwiseOperator2'
     */
    VeTPCR_b_ECH_OutFlt = ((((((sint32)TPCR_ac_DW.StatusByte_ECH_TempOut) & 1) >
        0) && ((((uint32)TPCR_ac_DW.StatusByte_ECH_TempOut) & 64U) == 0U)) &&
                           (KeTPCR_b_Enbl_ECHOut_Flt));

    /* Logic: '<S1342>/Logical7' incorporates:
     *  Constant: '<S1372>/Constant1'
     *  Constant: '<S1372>/Constant2'
     *  Constant: '<S1388>/Calib'
     *  Logic: '<S1372>/LogicalOperator'
     *  RelationalOperator: '<S1372>/RelationalOperator1'
     *  RelationalOperator: '<S1372>/RelationalOperator2'
     */
    VeTPCR_b_HTAP_TmpFlt = (((rtb_Switch_cw_tmp_c > 0) && (rtb_Switch_cw_tmp_d ==
        0U)) && (KeTPCR_b_Enbl_HTAP_TmpFlt));

    /* Logic: '<S1342>/Logical8' incorporates:
     *  Constant: '<S1376>/Constant1'
     *  Constant: '<S1376>/Constant2'
     *  Constant: '<S1390>/Calib'
     *  DataStoreRead: '<S1376>/StatusByte_CoolantVlvB_StkClsd'
     *  Logic: '<S1376>/LogicalOperator'
     *  RelationalOperator: '<S1376>/RelationalOperator1'
     *  RelationalOperator: '<S1376>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1376>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1376>/BitwiseOperator2'
     */
    VeTPCR_b_HTSOV_StckFlt = ((((((sint32)
        TPCR_ac_DW.StatusByte_CoolantVlvB_StkClsd) & 1) > 0) && ((((uint32)
        TPCR_ac_DW.StatusByte_CoolantVlvB_StkClsd) & 64U) == 0U)) &&
        (KeTPCR_b_Enbl_HTSOV_StkClose));

    /* S-Function (sfix_bitop): '<S1375>/BitwiseOperator1' incorporates:
     *  DataStoreRead: '<S1375>/StatusByte_CoolantVlvB_Ckt'
     *  S-Function (sfix_bitop): '<S1425>/Bitwise Operator1'
     */
    rtb_Switch_cw_tmp_8 = ((uint32)TPCR_ac_DW.StatusByte_CoolantVlvB_Ckt) & 64U;

    /* S-Function (sfix_bitop): '<S1374>/BitwiseOperator1' incorporates:
     *  DataStoreRead: '<S1374>/StatusByte_CoolantVlvB_CktLo'
     *  S-Function (sfix_bitop): '<S1426>/Bitwise Operator1'
     */
    rtb_Switch_cw_tmp_a = ((uint32)TPCR_ac_DW.StatusByte_CoolantVlvB_CktLo) &
        64U;

    /* S-Function (sfix_bitop): '<S1373>/BitwiseOperator1' incorporates:
     *  DataStoreRead: '<S1373>/StatusByte_CoolantVlvB_CktHi'
     *  S-Function (sfix_bitop): '<S1427>/Bitwise Operator1'
     */
    rtb_Switch_cw_tmp_b = ((uint32)TPCR_ac_DW.StatusByte_CoolantVlvB_CktHi) &
        64U;

    /* Logic: '<S1342>/Logical9' incorporates:
     *  Constant: '<S1373>/Constant1'
     *  Constant: '<S1373>/Constant2'
     *  Constant: '<S1374>/Constant1'
     *  Constant: '<S1374>/Constant2'
     *  Constant: '<S1375>/Constant1'
     *  Constant: '<S1375>/Constant2'
     *  Constant: '<S1389>/Calib'
     *  DataStoreRead: '<S1373>/StatusByte_CoolantVlvB_CktHi'
     *  DataStoreRead: '<S1374>/StatusByte_CoolantVlvB_CktLo'
     *  DataStoreRead: '<S1375>/StatusByte_CoolantVlvB_Ckt'
     *  Logic: '<S1342>/Logical10'
     *  Logic: '<S1373>/LogicalOperator'
     *  Logic: '<S1374>/LogicalOperator'
     *  Logic: '<S1375>/LogicalOperator'
     *  RelationalOperator: '<S1373>/RelationalOperator1'
     *  RelationalOperator: '<S1373>/RelationalOperator2'
     *  RelationalOperator: '<S1374>/RelationalOperator1'
     *  RelationalOperator: '<S1374>/RelationalOperator2'
     *  RelationalOperator: '<S1375>/RelationalOperator1'
     *  RelationalOperator: '<S1375>/RelationalOperator2'
     *  S-Function (sfix_bitop): '<S1373>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1373>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S1374>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1374>/BitwiseOperator2'
     *  S-Function (sfix_bitop): '<S1375>/BitwiseOperator1'
     *  S-Function (sfix_bitop): '<S1375>/BitwiseOperator2'
     */
    VeTPCR_b_HTSOV_PinFlts = ((((((((sint32)
        TPCR_ac_DW.StatusByte_CoolantVlvB_Ckt) & 1) > 0) && (rtb_Switch_cw_tmp_8
        == 0U)) || (((((sint32)TPCR_ac_DW.StatusByte_CoolantVlvB_CktLo) & 1) > 0)
                    && (rtb_Switch_cw_tmp_a == 0U))) || (((((sint32)
        TPCR_ac_DW.StatusByte_CoolantVlvB_CktHi) & 1) > 0) &&
        (rtb_Switch_cw_tmp_b == 0U))) && (KeTPCR_b_Enbl_HTSOV_PinFlts));

    /* RelationalOperator: '<S1349>/Relational Operator' incorporates:
     *  RelationalOperator: '<S1349>/Relational Operator1'
     *  RelationalOperator: '<S1349>/Relational Operator2'
     *  RelationalOperator: '<S1349>/Relational Operator3'
     *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
     */
    rtb_Switch_cw_tmp_4 = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lq;

    /* Switch: '<S1018>/Switch2' incorporates:
     *  Constant: '<S1445>/Constant'
     *  RelationalOperator: '<S1349>/Relational Operator'
     */
    rtb_Switch2_du = (((uint32)rtb_Switch_cw_tmp_4) == CeRCVR_e_Faulty_Open);

    /* Logic: '<S1349>/Logical Operator' incorporates:
     *  Constant: '<S1446>/Constant'
     *  Constant: '<S1447>/Constant'
     *  Constant: '<S1450>/Calib'
     *  Constant: '<S1451>/Calib'
     *  Constant: '<S1453>/Calib'
     *  Logic: '<S1349>/Logical Operator1'
     *  Logic: '<S1349>/Logical Operator2'
     *  Logic: '<S1349>/Logical Operator3'
     *  RelationalOperator: '<S1349>/Relational Operator1'
     *  RelationalOperator: '<S1349>/Relational Operator2'
     */
    rtb_LogicalOperator_gy = (((rtb_Switch2_du &&
        (KeTPCR_b_Enbl_CPV_ValveStuckOpen)) || ((((uint32)rtb_Switch_cw_tmp_4) ==
        CeRCVR_e_Faulty_Open_Bypass) && (KeTPCR_b_Enbl_CPV_ValveStuckOpenBypass)))
        || ((((uint32)rtb_Switch_cw_tmp_4) == CeRCVR_e_SNA) &&
            (KeTPCR_b_Enbl_CPV_ValveStuckSNA)));

    /* RelationalOperator: '<S1346>/Relational Operator1' incorporates:
     *  RelationalOperator: '<S1346>/Relational Operator'
     *  RelationalOperator: '<S1346>/Relational Operator2'
     *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
     */
    rtb_RelationalOperator1_ol_tmp = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_px;

    /* RelationalOperator: '<S1346>/Relational Operator1' incorporates:
     *  Constant: '<S1419>/Constant'
     */
    rtb_RelationalOperator1_dfl = (((uint32)rtb_RelationalOperator1_ol_tmp) ==
        CeRCVR_e_SNA);

    /* Logic: '<S1024>/Logical3' incorporates:
     *  Constant: '<S1384>/Calib'
     *  Constant: '<S1385>/Calib'
     *  Constant: '<S1386>/Calib'
     *  Constant: '<S1392>/Constant1'
     *  Constant: '<S1392>/Constant2'
     *  Constant: '<S1393>/Constant1'
     *  Constant: '<S1393>/Constant2'
     *  Constant: '<S1394>/Constant1'
     *  Constant: '<S1394>/Constant2'
     *  Constant: '<S1399>/Constant'
     *  Constant: '<S1403>/Calib'
     *  Constant: '<S1404>/Calib'
     *  Constant: '<S1406>/Calib'
     *  Constant: '<S1408>/Calib'
     *  Constant: '<S1410>/Constant1'
     *  Constant: '<S1410>/Constant2'
     *  Constant: '<S1411>/Constant1'
     *  Constant: '<S1411>/Constant2'
     *  Constant: '<S1418>/Constant'
     *  Constant: '<S1422>/Calib'
     *  Constant: '<S1423>/Calib'
     *  Constant: '<S1424>/Calib'
     *  Constant: '<S1425>/Constant1'
     *  Constant: '<S1425>/Constant2'
     *  Constant: '<S1426>/Constant1'
     *  Constant: '<S1426>/Constant2'
     *  Constant: '<S1427>/Constant1'
     *  Constant: '<S1427>/Constant2'
     *  Constant: '<S1428>/Constant1'
     *  Constant: '<S1428>/Constant2'
     *  Constant: '<S1448>/Constant'
     *  Constant: '<S1449>/Calib'
     *  DataStoreRead: '<S1425>/StatusByte_CoolantVlvB_Ckt'
     *  DataStoreRead: '<S1426>/StatusByte_CoolantVlvB_CktLo'
     *  DataStoreRead: '<S1427>/StatusByte_CoolantVlvB_CktHi'
     *  Logic: '<S1024>/Logical Operator'
     *  Logic: '<S1342>/Logical Operator'
     *  Logic: '<S1342>/Logical Operator1'
     *  Logic: '<S1342>/Logical Operator2'
     *  Logic: '<S1342>/Logical3'
     *  Logic: '<S1344>/Logical2'
     *  Logic: '<S1344>/Logical3'
     *  Logic: '<S1344>/Logical4'
     *  Logic: '<S1344>/Logical6'
     *  Logic: '<S1344>/Logical7'
     *  Logic: '<S1346>/Logical1'
     *  Logic: '<S1346>/Logical4'
     *  Logic: '<S1347>/Logical1'
     *  Logic: '<S1347>/Logical3'
     *  Logic: '<S1347>/Logical4'
     *  Logic: '<S1347>/Logical8'
     *  Logic: '<S1349>/Logical Operator4'
     *  Logic: '<S1392>/Logical Operator'
     *  Logic: '<S1393>/Logical Operator'
     *  Logic: '<S1394>/Logical Operator'
     *  Logic: '<S1410>/Logical Operator'
     *  Logic: '<S1411>/Logical Operator'
     *  Logic: '<S1425>/Logical Operator'
     *  Logic: '<S1426>/Logical Operator'
     *  Logic: '<S1427>/Logical Operator'
     *  Logic: '<S1428>/Logical Operator'
     *  RelationalOperator: '<S1344>/Comparison4'
     *  RelationalOperator: '<S1346>/Relational Operator'
     *  RelationalOperator: '<S1349>/Relational Operator3'
     *  RelationalOperator: '<S1392>/Relational Operator1'
     *  RelationalOperator: '<S1392>/Relational Operator2'
     *  RelationalOperator: '<S1393>/Relational Operator1'
     *  RelationalOperator: '<S1393>/Relational Operator2'
     *  RelationalOperator: '<S1394>/Relational Operator1'
     *  RelationalOperator: '<S1394>/Relational Operator2'
     *  RelationalOperator: '<S1410>/Relational Operator1'
     *  RelationalOperator: '<S1410>/Relational Operator2'
     *  RelationalOperator: '<S1411>/Relational Operator1'
     *  RelationalOperator: '<S1411>/Relational Operator2'
     *  RelationalOperator: '<S1425>/Relational Operator1'
     *  RelationalOperator: '<S1425>/Relational Operator2'
     *  RelationalOperator: '<S1426>/Relational Operator1'
     *  RelationalOperator: '<S1426>/Relational Operator2'
     *  RelationalOperator: '<S1427>/Relational Operator1'
     *  RelationalOperator: '<S1427>/Relational Operator2'
     *  RelationalOperator: '<S1428>/Relational Operator1'
     *  RelationalOperator: '<S1428>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S1425>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1426>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S1427>/Bitwise Operator2'
     */
    VeTPCR_b_ThermalFltsPerWkUp = ((((((rtb_UnitDelay_gcx_tmp ||
        (((((((VeTPCR_b_HTAP_PerfFlt) || (VeTPCR_b_LOC_HTAP)) ||
             (VeTPCR_b_LIN2_BusOff)) || ((CePMPR_e_FTSNA_False != ((uint32)
        rtb_Switch_cw_tmp_e)) && (KeTPCR_b_Enbl_HTAPDryRun_Flt))) ||
           ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_fi) &&
            (KeTPCR_b_Enbl_HTAPDryRunFA_Flt))) || (((rtb_Switch_cw_tmp_0 != 0U) &&
        (rtb_Switch_cw_tmp_1 == 0U)) && (KeTPCR_b_Enbl_LIN1BusOff_Flt_PerWup))) ||
         (((rtb_Switch_cw_tmp_2 != 0U) && (rtb_Switch_cw_tmp_3 == 0U)) &&
          (KeTPCR_b_Enbl_LIN3BusOff_Flt_PerWup)))) ||
        (((((((((((VeTPCR_b_LOC_ECH) || (VeTPCR_b_ECH_PerfFlt)) ||
                 (VeTPCR_b_ECHTIS_PinDiag)) || (VeTPCR_b_ECH_InFlt)) ||
               (VeTPCR_b_ECH_OutFlt)) || (VeTPCR_b_HTAP_TmpFlt)) ||
             (VeTPCR_b_HTSOV_StckFlt)) || (VeTPCR_b_HTSOV_PinFlts)) ||
           (((rtb_Switch_cw_tmp_0 != 0U) && (rtb_Switch_cw_tmp_1 == 0U)) &&
            (KeTPCR_b_Enbl_ECH_LIN1BusFlt_PerWup))) || (((rtb_Switch_cw_tmp_6 !=
        0U) && (rtb_Switch_cw_tmp == 0U)) &&
        (KeTPCR_b_Enbl_ECH_LIN2BusFlt_PerWup))) || (((rtb_Switch_cw_tmp_2 != 0U)
        && (rtb_Switch_cw_tmp_3 == 0U)) && (KeTPCR_b_Enbl_ECH_LIN3BusFlt_PerWup))))
        || rtb_Switch1_mw) || (((((((((uint32)
        TPCR_ac_DW.StatusByte_CoolantVlvB_Ckt) & 1U) != 0U) &&
        (rtb_Switch_cw_tmp_8 == 0U)) || (((((uint32)
        TPCR_ac_DW.StatusByte_CoolantVlvB_CktLo) & 1U) != 0U) &&
        (rtb_Switch_cw_tmp_a == 0U))) || (((((uint32)
        TPCR_ac_DW.StatusByte_CoolantVlvB_CktHi) & 1U) != 0U) &&
        (rtb_Switch_cw_tmp_b == 0U))) && (KeTPCR_b_Enbl_HTSOV_PerWup_PinFlts)) ||
        (((rtb_Switch_cw_tmp_f != 0U) && (rtb_Switch_cw_tmp_g == 0U)) &&
         (KeTPCR_b_Enbl_HTSOV_PerWup_StckFlts)))) || (rtb_LogicalOperator_gy ||
        ((((uint32)rtb_Switch_cw_tmp_4) == CeRCVR_e_Faulty_Closed) &&
         (KeTPCR_b_Enbl_CPV_ValveStuckClosed)))) || (((((uint32)
        rtb_RelationalOperator1_ol_tmp) == CeRCVR_e_Faulty_Closed) ||
        rtb_RelationalOperator1_dfl) && (KeTPCR_b_Enbl_HTLBV_Stuck_PerWup)));

    /* Outputs for Atomic SubSystem: '<S1026>/Hysteresis' */
    /* Switch: '<S1482>/Switch1' incorporates:
     *  Constant: '<S1483>/Calib'
     *  RelationalOperator: '<S1482>/GreaterThan'
     */
    if (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn > KeTPCR_T_BattCritThMax)
    {
        /* Switch: '<S1482>/Switch1' incorporates:
         *  Constant: '<S1482>/ConstantValue'
         */
        rtb_OR1_d5 = true;
    }
    else
    {
        /* Switch: '<S1482>/Switch1' incorporates:
         *  Constant: '<S1484>/Calib'
         *  RelationalOperator: '<S1482>/GreaterThan1'
         *  UnitDelay: '<S1482>/UnitDelay'
         */
        rtb_OR1_d5 = ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn >=
                       KeTPCR_T_BattCritThMin) &&
                      (TPCR_ac_DW.UnitDelay_DSTATE_ms));
    }

    /* End of Switch: '<S1482>/Switch1' */

    /* Update for UnitDelay: '<S1482>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ms = rtb_OR1_d5;

    /* End of Outputs for SubSystem: '<S1026>/Hysteresis' */

    /* Logic: '<S1026>/Logical10' incorporates:
     *  Constant: '<S1487>/Calib'
     *  Logic: '<S1026>/Logical11'
     *  Logic: '<S1027>/Logical10'
     *  Logic: '<S1030>/Logical10'
     */
    rtb_Switch3_c2 = ((rtb_LogicalOperator_h0 && (KeTPCR_b_EnblRSReq_PerWkup)) ||
                      (VeTPCR_b_SC_WakeUpReq));

    /* Logic: '<S1026>/Logical9' incorporates:
     *  Logic: '<S1026>/Logical10'
     *  Logic: '<S1026>/Logical12'
     */
    VeTPCR_b_CabWkUp_LowTemps = (rtb_Switch3_c2 && (!rtb_OR1_d5));

    /* RelationalOperator: '<S7>/Comparison5' incorporates:
     *  Constant: '<S27>/Constant'
     */
    rtb_OR1_d5 = (((uint32)Switch_cl) == CeTPCR_e_NoCabPrec_HV_BatCrit);

    /* Logic: '<S7>/Logical8' incorporates:
     *  Constant: '<S39>/Calib'
     */
    VeTPCR_b_SchCabPrecDnyRaw_BattCond = (((VeTPCR_b_SC_WakeUpReq) &&
        (KeTPCR_b_Enbl_VehOnBattCond_SC)) && rtb_OR1_d5);

    /* Outputs for Atomic SubSystem: '<S7>/EdgeRising1' */
    /* Logic: '<S24>/AND' incorporates:
     *  Logic: '<S24>/OR1'
     *  UnitDelay: '<S24>/UnitDelay'
     */
    rtb_Switch1_im = ((VeTPCR_b_SchCabPrecDnyRaw_BattCond) &&
                      (!TPCR_ac_DW.UnitDelay_DSTATE_hm));

    /* Update for UnitDelay: '<S24>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_hm = VeTPCR_b_SchCabPrecDnyRaw_BattCond;

    /* End of Outputs for SubSystem: '<S7>/EdgeRising1' */

    /* Logic: '<S7>/Logical3' incorporates:
     *  Constant: '<S28>/Constant'
     *  Constant: '<S29>/Constant'
     *  Constant: '<S38>/Calib'
     *  Logic: '<S7>/Logical5'
     *  RelationalOperator: '<S7>/Comparison1'
     *  RelationalOperator: '<S7>/Comparison11'
     *  UnitDelay: '<S7>/UnitDelay'
     */
    VeTPCR_b_CabPrecDnyRaw_BattCond = (((TPCR_ac_DW.UnitDelay_DSTATE_i3) &&
        ((((uint32)Switch_cl) == CeTPCR_e_CabinPrec_Off) || (((uint32)Switch_cl)
        == CeTPCR_e_CabinPrec_Dflt))) && (KeTPCR_b_Enbl_VehOnBattCond));

    /* Outputs for Atomic SubSystem: '<S7>/EdgeRising' */
    /* Logic: '<S23>/OR1' incorporates:
     *  UnitDelay: '<S23>/UnitDelay'
     */
    rtb_Switch1_cs = !TPCR_ac_DW.UnitDelay_DSTATE_ntj;

    /* Update for UnitDelay: '<S23>/UnitDelay' incorporates:
     *  Constant: '<S7>/TRUEConstant1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_ntj = true;

    /* Outputs for Atomic SubSystem: '<S7>/TimerRetriggerResetEnabled4' */
    /* Switch: '<S55>/Switch1' incorporates:
     *  Logic: '<S23>/AND'
     */
    if (rtb_Switch1_cs)
    {
        /* Switch: '<S55>/Switch1' incorporates:
         *  Constant: '<S46>/Calib'
         */
        rtb_Switch1_l4 = KeTPCR_t_BattCond_MaxTm;
    }
    else
    {
        /* Switch: '<S55>/Switch1' incorporates:
         *  Constant: '<S49>/Calib'
         *  Constant: '<S55>/ConstantValue4'
         *  MinMax: '<S55>/Maximum'
         *  Sum: '<S55>/Subtraction'
         *  UnitDelay: '<S55>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_na -
                               KeTPCR_t_PerWupCond_dT, 0.0F);
    }

    /* End of Switch: '<S55>/Switch1' */
    /* End of Outputs for SubSystem: '<S7>/EdgeRising' */

    /* Update for UnitDelay: '<S55>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_na = rtb_Switch1_l4;

    /* Logic: '<S7>/Logical2' incorporates:
     *  Constant: '<S44>/Calib'
     *  Constant: '<S45>/Calib'
     *  Constant: '<S55>/ConstantValue2'
     *  Logic: '<S7>/Logical18'
     *  RelationalOperator: '<S55>/GreaterThan1'
     *  RelationalOperator: '<S7>/Comparison4'
     *  RelationalOperator: '<S7>/Comparison8'
     */
    VeTPCR_b_MaxTime_BattCond = (((rtb_Switch1_l4 <= 0.0F) &&
        (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_g <=
         KeTPCR_dT_TimeOutCellOT_BattCond)) &&
        (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn <=
         KeTPCR_dT_TimeOutCellTmp_BattCond));

    /* End of Outputs for SubSystem: '<S7>/TimerRetriggerResetEnabled4' */

    /* Logic: '<S7>/Logical' incorporates:
     *  Constant: '<S40>/Calib'
     *  Constant: '<S41>/Calib'
     *  RelationalOperator: '<S7>/Comparison2'
     *  RelationalOperator: '<S7>/Comparison6'
     */
    VeTPCR_b_CellUTMet_BattCond = ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn <=
        KeTPCR_dT_BattCond_CellUnderTemp_Min) &&
        (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_g <=
         KeTPCR_dT_BattCond_CellOT_Min));

    /* Outputs for Atomic SubSystem: '<S7>/TurnOnDelayTime1' */
    /* Outputs for Atomic SubSystem: '<S57>/EdgeRising' */
    /* Logic: '<S59>/AND' incorporates:
     *  Logic: '<S59>/OR1'
     *  UnitDelay: '<S59>/UnitDelay'
     */
    rtb_Switch1_cs = ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gr) &&
                      (!TPCR_ac_DW.UnitDelay_DSTATE_c5));

    /* Update for UnitDelay: '<S59>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_c5 = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gr;

    /* End of Outputs for SubSystem: '<S57>/EdgeRising' */

    /* Switch: '<S57>/Switch1' incorporates:
     *  Logic: '<S57>/OR'
     */
    if (rtb_Switch3_o || rtb_Switch1_cs)
    {
        /* Switch: '<S57>/Switch1' incorporates:
         *  Constant: '<S57>/ConstantValue1'
         */
        rtb_Switch1_l4 = 0.0F;
    }
    else
    {
        /* Switch: '<S57>/Switch1' incorporates:
         *  Constant: '<S47>/Calib'
         *  Constant: '<S50>/Calib'
         *  MinMax: '<S57>/Minimum'
         *  Sum: '<S57>/Summation'
         *  UnitDelay: '<S57>/UnitDelay'
         */
        rtb_Switch1_l4 = fminf(KeTPCR_t_HdAjarDbnc_BattCond, KeTPCR_t_PerWup_dT
                               + TPCR_ac_DW.UnitDelay_DSTATE_av);
    }

    /* End of Switch: '<S57>/Switch1' */

    /* Update for UnitDelay: '<S57>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_av = rtb_Switch1_l4;

    /* Logic: '<S7>/Logical9' incorporates:
     *  Constant: '<S35>/Calib'
     *  Constant: '<S47>/Calib'
     *  Logic: '<S57>/AND'
     *  RelationalOperator: '<S57>/GreaterThan'
     */
    VeTPCR_b_HoodAjar_BattCond = (((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gr) &&
        (rtb_Switch1_l4 >= KeTPCR_t_HdAjarDbnc_BattCond)) &&
        (KeTPCR_b_EnblHdAjar_BattCond));

    /* End of Outputs for SubSystem: '<S7>/TurnOnDelayTime1' */

    /* Outputs for Atomic SubSystem: '<S7>/EdgeRising2' */
    /* Logic: '<S25>/OR1' incorporates:
     *  UnitDelay: '<S25>/UnitDelay'
     */
    rtb_Switch1_cs = !TPCR_ac_DW.UnitDelay_DSTATE_gim;

    /* Update for UnitDelay: '<S25>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_gim = VeTPCR_b_SC_WakeUpReq;

    /* End of Outputs for SubSystem: '<S7>/EdgeRising2' */

    /* Switch: '<S7>/Switch' incorporates:
     *  Constant: '<S32>/Calib'
     *  Logic: '<S25>/AND'
     */
    if (KeTPCR_b_EnblContSCWkUp_BattCond)
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = VeTPCR_b_SC_WakeUpReq;
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S7>/EdgeRising2' */
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = ((VeTPCR_b_SC_WakeUpReq) &&
            rtb_Switch1_cs);

        /* End of Outputs for SubSystem: '<S7>/EdgeRising2' */
    }

    /* End of Switch: '<S7>/Switch' */

    /* Logic: '<S7>/Logical14' incorporates:
     *  Constant: '<S37>/Calib'
     *  Constant: '<S42>/Calib'
     *  Constant: '<S43>/Calib'
     *  Logic: '<S7>/Logical10'
     *  Logic: '<S7>/Logical11'
     *  Logic: '<S7>/Logical12'
     *  RelationalOperator: '<S7>/Comparison3'
     *  RelationalOperator: '<S7>/Comparison9'
     */
    VeTPCR_b_CabWkUp_LowTemp = (((rtb_LogicalOperator_h0 &&
        (KeTPCR_b_EnblRSReq_BattCond)) || VeTPCR_b_DoorAjarEnblLtch_Rst_t) &&
        ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn <=
          KeTPCR_dT_CabCondCellTmp_BattCond) &&
         (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_g <=
          KeTPCR_dT_CabCondCellOT_BattCond)));

    /* Logic: '<S7>/Logical7' incorporates:
     *  Constant: '<S31>/Calib'
     */
    VeTPCR_b_ChrgSysFlt_BattCond = ((VeTPCR_b_ChrgSysFlt) &&
        (KeTPCR_b_DsblChrgSysFlt_BattCond));

    /* Switch: '<S988>/Switch1' incorporates:
     *  Constant: '<S21>/Constant'
     *  Constant: '<S36>/Calib'
     *  Logic: '<S7>/Logical13'
     *  RelationalOperator: '<S607>/Comparison1'
     *  RelationalOperator: '<S7>/Comparison10'
     *  Switch: '<S1760>/Switch'
     */
    rtb_Switch1_cs = ((((uint32)VeTPCR_e_PMM_PowerMode_AD) != CeSSDR_e_KeyOff) &&
                      (KeTPCR_b_EnblKeyChk_BattCond));

    /* RelationalOperator: '<S7>/Comparison13' incorporates:
     *  Constant: '<S30>/Calib'
     */
    rtb_OR1_lo = (VeTPCR_P_ThrmlPwrBdgt <= KeTPCR_P_LowPwrBdgt_BattCond);

    /* Outputs for Atomic SubSystem: '<S7>/EdgeRising3' */
    /* Logic: '<S26>/AND' incorporates:
     *  Logic: '<S26>/OR1'
     *  UnitDelay: '<S26>/UnitDelay'
     */
    rtb_Switch2_nq = (rtb_OR1_lo && (!TPCR_ac_DW.UnitDelay_DSTATE_fom));

    /* Update for UnitDelay: '<S26>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fom = rtb_OR1_lo;

    /* End of Outputs for SubSystem: '<S7>/EdgeRising3' */

    /* Outputs for Atomic SubSystem: '<S7>/TimerRetriggerResetEnabled1' */
    /* Switch: '<S54>/Switch1' incorporates:
     *  Logic: '<S7>/Logical20'
     *  Logic: '<S7>/Logical23'
     */
    if ((!rtb_OR1_lo) || rtb_Switch2_nq)
    {
        /* Switch: '<S54>/Switch1' incorporates:
         *  Constant: '<S48>/Calib'
         *  Constant: '<S49>/Calib'
         *  Sum: '<S7>/Add2'
         */
        rtb_Switch1_l4 = KeTPCR_t_LoPwrBdgtDbnc + KeTPCR_t_PerWupCond_dT;
    }
    else
    {
        /* Switch: '<S54>/Switch1' incorporates:
         *  Constant: '<S49>/Calib'
         *  Constant: '<S54>/ConstantValue4'
         *  MinMax: '<S54>/Maximum'
         *  Sum: '<S54>/Subtraction'
         *  Switch: '<S54>/Switch2'
         *  UnitDelay: '<S54>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_fu -
                               KeTPCR_t_PerWupCond_dT, 0.0F);
    }

    /* End of Switch: '<S54>/Switch1' */

    /* Update for UnitDelay: '<S54>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fu = rtb_Switch1_l4;

    /* End of Outputs for SubSystem: '<S7>/TimerRetriggerResetEnabled1' */

    /* Logic: '<S1024>/Logical2' incorporates:
     *  Constant: '<S1366>/Calib'
     *  Constant: '<S1367>/Constant1'
     *  Constant: '<S1367>/Constant2'
     *  Constant: '<S1395>/Calib'
     *  Constant: '<S1396>/Calib'
     *  Constant: '<S1397>/Calib'
     *  Constant: '<S1398>/Calib'
     *  Constant: '<S1420>/Constant'
     *  Constant: '<S1421>/Calib'
     *  Constant: '<S1452>/Calib'
     *  DataStoreRead: '<S1367>/StatusByte_BattCool'
     *  Logic: '<S1340>/Logical7'
     *  Logic: '<S1341>/Logical Operator'
     *  Logic: '<S1343>/Logical Operator'
     *  Logic: '<S1343>/Logical Operator1'
     *  Logic: '<S1343>/Logical Operator2'
     *  Logic: '<S1343>/Logical Operator3'
     *  Logic: '<S1343>/Logical Operator4'
     *  Logic: '<S1346>/Logical2'
     *  Logic: '<S1346>/Logical3'
     *  Logic: '<S1349>/Logical Operator5'
     *  Logic: '<S1367>/Logical Operator'
     *  RelationalOperator: '<S1346>/Relational Operator2'
     *  RelationalOperator: '<S1367>/Relational Operator1'
     *  RelationalOperator: '<S1367>/Relational Operator2'
     *  S-Function (sfix_bitop): '<S1367>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S1367>/Bitwise Operator2'
     */
    rtb_RelationalOperator1_dfl = ((((((((rtb_Switch_e || (VeTPCR_b_LTAP_Flts)) ||
        rtb_UnitDelay_jk) || ((VeTPCR_b_BPCMLOC) || (VeTPCR_b_ePTBUSOff))) ||
        ((((((uint32)TPCR_ac_DW.StatusByte_BattCool) & 1U) != 0U) && ((((uint32)
        TPCR_ac_DW.StatusByte_BattCool) & 64U) == 0U)) &&
         (KeTPCR_b_Enbl_BattCool_Flt))) ||
        (((((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_hw) &&
            (KeTPCR_b_Enbl_EXV_TempElctrFlt)) ||
           ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_mc) &&
            (KeTPCR_b_Enbl_EXV_PressElctrFlt))) ||
          ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_dd) &&
           (KeTPCR_b_Enbl_EXV_PressSensFlt))) ||
         ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gf) &&
          (KeTPCR_b_Enbl_EXV_TempSensFlt)))) || rtb_LogicalOperator_gy) ||
        (rtb_Switch2_du && (KeTPCR_b_Enbl_CPV_ValveStuckOpen_HotSide))) ||
        ((rtb_RelationalOperator1_dfl || (((uint32)
        rtb_RelationalOperator1_ol_tmp) == CeRCVR_e_Faulty_Open)) &&
         (KeTPCR_b_Enbl_HTLBV_Stuck_Open_PerWup)));

    /* Outputs for Atomic SubSystem: '<S7>/TimerRetriggerResetEnabled1' */
    /* Logic: '<S7>/Logical6' incorporates:
     *  Constant: '<S33>/Calib'
     *  Constant: '<S34>/Calib'
     *  Constant: '<S54>/ConstantValue2'
     *  Constant: '<S7>/ConstantValue1'
     *  Constant: '<S7>/ConstantValue3'
     *  Logic: '<S7>/Logical17'
     *  Logic: '<S7>/Logical19'
     *  Logic: '<S7>/Logical4'
     *  RelationalOperator: '<S54>/GreaterThan1'
     *  RelationalOperator: '<S7>/Comparison'
     *  RelationalOperator: '<S7>/Comparison14'
     */
    VeTPCR_b_ResetBattCond = ((((((((((VeTPCR_b_MaxTime_BattCond) ||
        (VeTPCR_b_CellUTMet_BattCond)) || (VeTPCR_b_HoodAjar_BattCond)) ||
        (VeTPCR_b_CabWkUp_LowTemp)) || (VeTPCR_b_ChrgSysFlt_BattCond)) ||
        VeTPCR_b_UnplugNoBattCond_SOC_t) || rtb_Switch1_cs) ||
        (((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn > 0.0F) && rtb_UnitDelay_l3)
         && (KeTPCR_b_EnblFlts_BattCond))) || (rtb_Switch1_l4 <= 0.0F)) ||
        (((TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_g > 0.0F) &&
          rtb_RelationalOperator1_dfl) && (KeTPCR_b_EnblCoolFlts_BattCond)));

    /* End of Outputs for SubSystem: '<S7>/TimerRetriggerResetEnabled1' */

    /* Outputs for Atomic SubSystem: '<S7>/SignalLatchOnWithReset2' */
    /* Logic: '<S53>/OR1' incorporates:
     *  Logic: '<S53>/NOT'
     *  Logic: '<S53>/OR'
     *  Logic: '<S7>/Logical16'
     *  UnitDelay: '<S53>/UnitDelay'
     */
    VeTPCR_b_CabPrecDny_BattCondLtch = ((rtb_Switch1_im ||
        (VeTPCR_b_CabPrecDnyRaw_BattCond)) || ((!VeTPCR_b_ResetBattCond) &&
        (TPCR_ac_DW.UnitDelay_DSTATE_bb3)));

    /* Update for UnitDelay: '<S53>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_bb3 = VeTPCR_b_CabPrecDny_BattCondLtch;

    /* End of Outputs for SubSystem: '<S7>/SignalLatchOnWithReset2' */

    /* Logic: '<S1026>/Logical14' incorporates:
     *  Constant: '<S1005>/Calib'
     *  Logic: '<S1030>/Logical14'
     *  Logic: '<S19>/Logical9'
     */
    rtb_UnitDelay_jk = ((!VeTPCR_b_CabPrecDny_BattCondLtch) ||
                        (!KeTPCR_b_Enbl_CabPrecDny_BattCond));

    /* Switch: '<S1026>/Switch1' incorporates:
     *  Logic: '<S1026>/Logical14'
     */
    VeTPCR_b_CabCond_DsblBattCond_NormPerWkUp = ((!VeTPCR_b_CabWkUp_LowTemps) &&
        rtb_UnitDelay_jk);

    /* Logic: '<S1026>/Logical13' incorporates:
     *  Constant: '<S1474>/Constant'
     *  Constant: '<S1486>/Calib'
     *  RelationalOperator: '<S1026>/Comparison1'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     */
    rtb_UnitDelay_l3 = ((((uint32)VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff)
                        || (KeTPCR_b_DsblKeyChk_PerWkUp));

    /* Outputs for Atomic SubSystem: '<S1026>/EdgeFalling1' */
    /* Logic: '<S1477>/AND' incorporates:
     *  Logic: '<S1477>/OR1'
     *  UnitDelay: '<S1477>/UnitDelay'
     */
    rtb_LogicalOperator_gy = ((!rtb_UnitDelay_l3) &&
        (TPCR_ac_DW.UnitDelay_DSTATE_lu));

    /* Update for UnitDelay: '<S1477>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_lu = rtb_UnitDelay_l3;

    /* End of Outputs for SubSystem: '<S1026>/EdgeFalling1' */

    /* Outputs for Atomic SubSystem: '<S1026>/EdgeRising' */
    /* Logic: '<S1478>/AND' incorporates:
     *  Logic: '<S1478>/OR1'
     *  UnitDelay: '<S1478>/UnitDelay'
     */
    rtb_Switch2_du = !TPCR_ac_DW.UnitDelay_DSTATE_cl;

    /* Update for UnitDelay: '<S1478>/UnitDelay' incorporates:
     *  Constant: '<S1026>/TRUEConstant'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_cl = true;

    /* End of Outputs for SubSystem: '<S1026>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S1026>/EdgeRising3' */
    /* Logic: '<S1480>/AND' incorporates:
     *  Logic: '<S1480>/OR1'
     *  UnitDelay: '<S1480>/UnitDelay'
     *  UnitDelay: '<S19>/UnitDelay1'
     */
    rtb_Switch1_im = ((TPCR_ac_DW.UnitDelay1_DSTATE_f) &&
                      (!TPCR_ac_DW.UnitDelay_DSTATE_p4));

    /* Update for UnitDelay: '<S1480>/UnitDelay' incorporates:
     *  UnitDelay: '<S19>/UnitDelay1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_p4 = TPCR_ac_DW.UnitDelay1_DSTATE_f;

    /* End of Outputs for SubSystem: '<S1026>/EdgeRising3' */

    /* Outputs for Atomic SubSystem: '<S1026>/CountDownResetTriggerEnabled1' */
    /* Outputs for Atomic SubSystem: '<S1475>/EdgeRising' */
    /* Logic: '<S1491>/OR1' incorporates:
     *  UnitDelay: '<S1491>/UnitDelay'
     */
    rtb_OR1_lo = !TPCR_ac_DW.UnitDelay_DSTATE_fo;

    /* Update for UnitDelay: '<S1491>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fo = rtb_Switch1_im;

    /* Switch: '<S1475>/Switch1' incorporates:
     *  Constant: '<S1475>/ConstantValue'
     *  Logic: '<S1475>/AND'
     *  Logic: '<S1491>/AND'
     *  RelationalOperator: '<S1475>/GreaterThan'
     *  Switch: '<S1475>/Switch2'
     *  UnitDelay: '<S1475>/UnitDelay'
     *  UnitDelay: '<S19>/UnitDelay1'
     */
    if (rtb_Switch1_im && rtb_OR1_lo)
    {
        /* Switch: '<S1475>/Switch1' incorporates:
         *  Constant: '<S1489>/Calib'
         */
        rtb_Switch1_g1 = KeTPCR_t_Wp_Norml_Abrtd_Tim;
    }
    else if ((TPCR_ac_DW.UnitDelay1_DSTATE_f) && (((sint32)
               TPCR_ac_DW.UnitDelay_DSTATE_ok) > 0))
    {
        /* Switch: '<S1475>/Switch2' incorporates:
         *  Constant: '<S1475>/ConstantValue1'
         *  Sum: '<S1475>/Subtraction'
         *  Switch: '<S1475>/Switch1'
         *  UnitDelay: '<S1475>/UnitDelay'
         */
        rtb_Switch1_g1 = (uint16)((sint32)(((sint32)
            TPCR_ac_DW.UnitDelay_DSTATE_ok) - 1));
    }
    else
    {
        /* Switch: '<S1475>/Switch1' incorporates:
         *  Switch: '<S1475>/Switch2'
         *  UnitDelay: '<S1475>/UnitDelay'
         */
        rtb_Switch1_g1 = TPCR_ac_DW.UnitDelay_DSTATE_ok;
    }

    /* End of Switch: '<S1475>/Switch1' */
    /* End of Outputs for SubSystem: '<S1475>/EdgeRising' */

    /* Update for UnitDelay: '<S1475>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ok = rtb_Switch1_g1;

    /* Logic: '<S1026>/Logical6' incorporates:
     *  Constant: '<S1475>/ConstantValue2'
     *  RelationalOperator: '<S1475>/GreaterThan1'
     */
    rtb_Switch1_im = (((sint32)rtb_Switch1_g1) <= 0);

    /* End of Outputs for SubSystem: '<S1026>/CountDownResetTriggerEnabled1' */

    /* Outputs for Atomic SubSystem: '<S1026>/EdgeRising1' */
    /* Logic: '<S1479>/AND' incorporates:
     *  Logic: '<S1479>/OR1'
     *  UnitDelay: '<S1479>/UnitDelay'
     */
    rtb_OR1_lo = (rtb_Switch1_im && (!TPCR_ac_DW.UnitDelay_DSTATE_djk));

    /* Update for UnitDelay: '<S1479>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_djk = rtb_Switch1_im;

    /* End of Outputs for SubSystem: '<S1026>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S1026>/EdgeFalling' */
    /* Logic: '<S1476>/AND' incorporates:
     *  Logic: '<S1476>/OR1'
     *  UnitDelay: '<S1476>/UnitDelay'
     */
    VeTPCR_b_CabCond_DsblBattCond_NormPerWkUpTrig =
        ((!VeTPCR_b_CabCond_DsblBattCond_NormPerWkUp) &&
         (TPCR_ac_DW.UnitDelay_DSTATE_eo));

    /* Update for UnitDelay: '<S1476>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_eo = VeTPCR_b_CabCond_DsblBattCond_NormPerWkUp;

    /* End of Outputs for SubSystem: '<S1026>/EdgeFalling' */

    /* Switch: '<S1026>/Switch3' incorporates:
     *  Constant: '<S1026>/TRUEConstant3'
     *  Constant: '<S1485>/Calib'
     *  Logic: '<S1026>/Logical7'
     */
    if (KeTPCR_b_AmbTmpFAChk_WUpWaitBatCond)
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t =
            !TPCR_ac_B.TmpSignalConversionAtTmpVM_F_a0;
    }
    else
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = true;
    }

    /* End of Switch: '<S1026>/Switch3' */

    /* Logic: '<S1026>/Logical3' incorporates:
     *  Logic: '<S1030>/Logical3'
     */
    rtb_Switch2_nq = ((VeTPCR_b_PerWup_Enbl) && (VeTPCR_b_HVBatPerWkUp));

    /* Outputs for Atomic SubSystem: '<S1026>/SignalLatchOnWithReset3' */
    /* Logic: '<S1490>/OR1' incorporates:
     *  Constant: '<S1009>/Calib'
     *  Constant: '<S1010>/Calib'
     *  Constant: '<S1481>/Constant'
     *  Constant: '<S1488>/Calib'
     *  DataStoreRead: '<S1015>/DataStoreRead'
     *  Gain: '<S1042>/Gain'
     *  Logic: '<S1026>/Logical1'
     *  Logic: '<S1026>/Logical2'
     *  Logic: '<S1026>/Logical3'
     *  Logic: '<S1026>/Logical5'
     *  Logic: '<S1026>/Logical8'
     *  Logic: '<S1490>/NOT'
     *  Logic: '<S1490>/OR'
     *  RelationalOperator: '<S1026>/Comparison10'
     *  RelationalOperator: '<S1026>/Comparison2'
     *  RelationalOperator: '<S1026>/Comparison3'
     *  RelationalOperator: '<S612>/Comparison5'
     *  Switch: '<S1775>/Switch'
     *  UnitDelay: '<S1490>/UnitDelay'
     *  UnitDelay: '<S19>/UnitDelay'
     */
    VeTPCC_b_WpWaitBatCond_PerWpTimr = ((((((((rtb_Switch2_nq &&
        (!TPCR_ac_DW.NeTPCR_b_RS_CabPrecDeny_Prev)) && (((uint32)
        VeTPCR_e_ShippingMode_AD) != CePLTR_e_ShipingMode_SHIP_MD)) &&
        (((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn >
           KeTPCR_dT_PerWup_CellUnderTemp_Min) ||
          (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_g >
           KeTPCR_dT_PerWup_CellOverTemp_Min)) ||
         (TPCR_ac_DW.UnitDelay_DSTATE_cu))) && (VeTPCR_b_BCC_CellUnderTmpChk_tm ||
        (KeTPCR_b_HCPShtDwnChk_WUpWaitBatCond))) &&
        VeTPCR_b_DoorAjarEnblLtch_Rst_t) &&
        (VeTPCR_b_CabCond_DsblBattCond_NormPerWkUp)) && rtb_UnitDelay_l3) ||
        (((((!rtb_LogicalOperator_gy) && (!rtb_Switch2_du)) && (!rtb_OR1_lo)) &&
          (!VeTPCR_b_CabCond_DsblBattCond_NormPerWkUpTrig)) &&
         (TPCR_ac_DW.UnitDelay_DSTATE_g3)));

    /* Update for UnitDelay: '<S1490>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_g3 = VeTPCC_b_WpWaitBatCond_PerWpTimr;

    /* End of Outputs for SubSystem: '<S1026>/SignalLatchOnWithReset3' */

    /* Outputs for Atomic SubSystem: '<S1030>/Hysteresis' */
    /* Switch: '<S1741>/Switch1' incorporates:
     *  Constant: '<S1742>/Calib'
     *  RelationalOperator: '<S1741>/GreaterThan'
     */
    if (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn > KeTPCR_T_BattCritThMax)
    {
        /* Switch: '<S1741>/Switch1' incorporates:
         *  Constant: '<S1741>/ConstantValue'
         */
        rtb_UnitDelay_l3 = true;
    }
    else
    {
        /* Switch: '<S1741>/Switch1' incorporates:
         *  Constant: '<S1743>/Calib'
         *  RelationalOperator: '<S1741>/GreaterThan1'
         *  UnitDelay: '<S1741>/UnitDelay'
         */
        rtb_UnitDelay_l3 = ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn >=
                             KeTPCR_T_BattCritThMin) &&
                            (TPCR_ac_DW.UnitDelay_DSTATE_jh));
    }

    /* End of Switch: '<S1741>/Switch1' */

    /* Update for UnitDelay: '<S1741>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_jh = rtb_UnitDelay_l3;

    /* End of Outputs for SubSystem: '<S1030>/Hysteresis' */

    /* Logic: '<S1030>/Logical9' incorporates:
     *  Logic: '<S1030>/Logical12'
     */
    VeTPCR_b_CabWkUp_LowTemps_RSDnyPerWkUp = (rtb_Switch3_c2 &&
        (!rtb_UnitDelay_l3));

    /* Switch: '<S1030>/Switch1' incorporates:
     *  Logic: '<S1030>/Logical14'
     */
    VeTPCR_b_CabCond_DsblBattCond_RSDnyPerWkUp =
        ((!VeTPCR_b_CabWkUp_LowTemps_RSDnyPerWkUp) && rtb_UnitDelay_jk);

    /* Logic: '<S1030>/Logical4' incorporates:
     *  Constant: '<S1733>/Constant'
     *  Constant: '<S1744>/Calib'
     *  RelationalOperator: '<S1030>/Comparison1'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     */
    rtb_UnitDelay_jk = ((((uint32)VeTPCR_e_PMM_PowerMode_AD) == CeSSDR_e_KeyOff)
                        || (KeTPCR_b_DsblKeyChk_RSDnyPerWkUp));

    /* Outputs for Atomic SubSystem: '<S1030>/EdgeFalling1' */
    /* Logic: '<S1736>/AND' incorporates:
     *  Logic: '<S1736>/OR1'
     *  UnitDelay: '<S1736>/UnitDelay'
     */
    rtb_UnitDelay_l3 = ((!rtb_UnitDelay_jk) && (TPCR_ac_DW.UnitDelay_DSTATE_ds));

    /* Update for UnitDelay: '<S1736>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ds = rtb_UnitDelay_jk;

    /* End of Outputs for SubSystem: '<S1030>/EdgeFalling1' */

    /* Outputs for Atomic SubSystem: '<S1030>/EdgeRising' */
    /* Logic: '<S1737>/AND' incorporates:
     *  Logic: '<S1737>/OR1'
     *  UnitDelay: '<S1737>/UnitDelay'
     */
    rtb_Switch3_o = !TPCR_ac_DW.UnitDelay_DSTATE_lp;

    /* Update for UnitDelay: '<S1737>/UnitDelay' incorporates:
     *  Constant: '<S1030>/TRUEConstant'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_lp = true;

    /* End of Outputs for SubSystem: '<S1030>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S1030>/EdgeRising2' */
    /* Logic: '<S1739>/AND' incorporates:
     *  Logic: '<S1739>/OR1'
     *  UnitDelay: '<S1739>/UnitDelay'
     */
    rtb_LogicalOperator_gy = (rtb_UnitDelay4_k &&
        (!TPCR_ac_DW.UnitDelay_DSTATE_gry));

    /* Update for UnitDelay: '<S1739>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_gry = rtb_UnitDelay4_k;

    /* End of Outputs for SubSystem: '<S1030>/EdgeRising2' */

    /* Outputs for Atomic SubSystem: '<S1030>/CountDownResetTriggerEnabled1' */
    /* Outputs for Atomic SubSystem: '<S1734>/EdgeRising' */
    /* Logic: '<S1748>/OR1' incorporates:
     *  UnitDelay: '<S1748>/UnitDelay'
     */
    rtb_Switch2_du = !TPCR_ac_DW.UnitDelay_DSTATE_mu;

    /* Update for UnitDelay: '<S1748>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_mu = rtb_LogicalOperator_gy;

    /* Switch: '<S1734>/Switch1' incorporates:
     *  Constant: '<S1734>/ConstantValue'
     *  Logic: '<S1734>/AND'
     *  Logic: '<S1748>/AND'
     *  RelationalOperator: '<S1734>/GreaterThan'
     *  Switch: '<S1734>/Switch2'
     *  UnitDelay: '<S1734>/UnitDelay'
     */
    if (rtb_LogicalOperator_gy && rtb_Switch2_du)
    {
        /* Switch: '<S1734>/Switch1' incorporates:
         *  Constant: '<S1746>/Calib'
         */
        rtb_Switch1_g1 = KeTPCR_t_Wp_RS_Abrtd_Tim;
    }
    else if (rtb_UnitDelay4_k && (((sint32)TPCR_ac_DW.UnitDelay_DSTATE_op) > 0))
    {
        /* Switch: '<S1734>/Switch2' incorporates:
         *  Constant: '<S1734>/ConstantValue1'
         *  Sum: '<S1734>/Subtraction'
         *  Switch: '<S1734>/Switch1'
         *  UnitDelay: '<S1734>/UnitDelay'
         */
        rtb_Switch1_g1 = (uint16)((sint32)(((sint32)
            TPCR_ac_DW.UnitDelay_DSTATE_op) - 1));
    }
    else
    {
        /* Switch: '<S1734>/Switch1' incorporates:
         *  Switch: '<S1734>/Switch2'
         *  UnitDelay: '<S1734>/UnitDelay'
         */
        rtb_Switch1_g1 = TPCR_ac_DW.UnitDelay_DSTATE_op;
    }

    /* End of Switch: '<S1734>/Switch1' */
    /* End of Outputs for SubSystem: '<S1734>/EdgeRising' */

    /* Update for UnitDelay: '<S1734>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_op = rtb_Switch1_g1;

    /* Logic: '<S1030>/Logical2' incorporates:
     *  Constant: '<S1734>/ConstantValue2'
     *  RelationalOperator: '<S1734>/GreaterThan1'
     */
    rtb_LogicalOperator_gy = (((sint32)rtb_Switch1_g1) <= 0);

    /* End of Outputs for SubSystem: '<S1030>/CountDownResetTriggerEnabled1' */

    /* Outputs for Atomic SubSystem: '<S1030>/EdgeRising1' */
    /* Logic: '<S1738>/AND' incorporates:
     *  Logic: '<S1738>/OR1'
     *  UnitDelay: '<S1738>/UnitDelay'
     */
    rtb_Switch2_du = (rtb_LogicalOperator_gy && (!TPCR_ac_DW.UnitDelay_DSTATE_en));

    /* Update for UnitDelay: '<S1738>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_en = rtb_LogicalOperator_gy;

    /* End of Outputs for SubSystem: '<S1030>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S1030>/EdgeFalling' */
    /* Logic: '<S1735>/AND' incorporates:
     *  Logic: '<S1735>/OR1'
     *  UnitDelay: '<S1735>/UnitDelay'
     */
    VeTPCR_b_CabCond_DsblBattCond_RSDnyPerWkUpTrig =
        ((!VeTPCR_b_CabCond_DsblBattCond_RSDnyPerWkUp) &&
         (TPCR_ac_DW.UnitDelay_DSTATE_oo5));

    /* Update for UnitDelay: '<S1735>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_oo5 = VeTPCR_b_CabCond_DsblBattCond_RSDnyPerWkUp;

    /* End of Outputs for SubSystem: '<S1030>/EdgeFalling' */

    /* Outputs for Atomic SubSystem: '<S1030>/SignalLatchOnWithReset3' */
    /* Logic: '<S1747>/OR1' incorporates:
     *  Constant: '<S1009>/Calib'
     *  Constant: '<S1010>/Calib'
     *  Constant: '<S1740>/Constant'
     *  DataStoreRead: '<S1015>/DataStoreRead'
     *  Gain: '<S1042>/Gain'
     *  Logic: '<S1030>/Logical1'
     *  Logic: '<S1030>/Logical3'
     *  Logic: '<S1030>/Logical5'
     *  Logic: '<S1747>/NOT'
     *  Logic: '<S1747>/OR'
     *  RelationalOperator: '<S1030>/Comparison10'
     *  RelationalOperator: '<S1030>/Comparison2'
     *  RelationalOperator: '<S1030>/Comparison3'
     *  RelationalOperator: '<S612>/Comparison5'
     *  Switch: '<S1775>/Switch'
     *  UnitDelay: '<S1747>/UnitDelay'
     */
    VeTPCC_b_WpWaitBatCond_RS_DndDftTimr = ((((((rtb_Switch2_nq &&
        ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn >
          KeTPCR_dT_PerWup_CellUnderTemp_Min) ||
         (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_g >
          KeTPCR_dT_PerWup_CellOverTemp_Min))) &&
        (TPCR_ac_DW.NeTPCR_b_RS_CabPrecDeny_Prev)) && (((uint32)
        VeTPCR_e_ShippingMode_AD) != CePLTR_e_ShipingMode_SHIP_MD)) &&
        (VeTPCR_b_CabCond_DsblBattCond_RSDnyPerWkUp)) && rtb_UnitDelay_jk) ||
        (((((!rtb_UnitDelay_l3) && (!rtb_Switch3_o)) && (!rtb_Switch2_du)) &&
          (!VeTPCR_b_CabCond_DsblBattCond_RSDnyPerWkUpTrig)) &&
         (TPCR_ac_DW.UnitDelay_DSTATE_f3i)));

    /* Update for UnitDelay: '<S1747>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_f3i = VeTPCC_b_WpWaitBatCond_RS_DndDftTimr;

    /* End of Outputs for SubSystem: '<S1030>/SignalLatchOnWithReset3' */

    /* Outputs for Atomic SubSystem: '<S1016>/EdgeRising1' */
    /* Logic: '<S1044>/AND' incorporates:
     *  Logic: '<S1044>/OR1'
     *  UnitDelay: '<S1044>/UnitDelay'
     */
    rtb_Switch2_nq = !TPCR_ac_DW.UnitDelay_DSTATE_ci;

    /* Update for UnitDelay: '<S1044>/UnitDelay' incorporates:
     *  Constant: '<S1016>/TRUEConstant4'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_ci = true;

    /* End of Outputs for SubSystem: '<S1016>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S1016>/EdgeFalling' */
    /* Switch: '<S989>/Switch1' incorporates:
     *  UnitDelay: '<S1043>/UnitDelay'
     */
    rtb_Switch1_mw = TPCR_ac_DW.UnitDelay_DSTATE_i2;

    /* Update for UnitDelay: '<S1043>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_i2 = VeTPCR_b_HCPShutDwnCmd;

    /* End of Outputs for SubSystem: '<S1016>/EdgeFalling' */

    /* Switch: '<S1016>/Switch' incorporates:
     *  Constant: '<S1016>/TRUEConstant'
     *  Constant: '<S1046>/Constant'
     *  Constant: '<S1054>/Calib'
     *  RelationalOperator: '<S1016>/Comparison1'
     */
    if (KeTPCR_b_NoWp_CabPrecBatCrit_S)
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = (((uint32)Switch_cl) !=
            CeTPCR_e_NoCabPrec_HV_BatCrit);
    }
    else
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = true;
    }

    /* Switch: '<S1016>/Switch2' incorporates:
     *  Constant: '<S1016>/TRUEConstant2'
     *  Constant: '<S1053>/Calib'
     *  Logic: '<S1016>/Logical4'
     */
    if (KeTPCR_b_NoWUpHVBatPWup_FrstTmrSet)
    {
        rtb_Gain_g = !VeTPCR_b_HVBatPerWkUp;
    }
    else
    {
        rtb_Gain_g = true;
    }

    /* End of Switch: '<S1016>/Switch2' */

    /* Switch: '<S1016>/Switch3' incorporates:
     *  Constant: '<S1016>/TRUEConstant3'
     *  Constant: '<S1047>/Calib'
     *  Logic: '<S1016>/Logical3'
     */
    if (KeTPCR_b_AmbTmpFAChk_NoWUpFrstTmrSet)
    {
        rtb_UnitDelay_jk = !TPCR_ac_B.TmpSignalConversionAtTmpVM_F_a0;
    }
    else
    {
        rtb_UnitDelay_jk = true;
    }

    /* End of Switch: '<S1016>/Switch3' */

    /* Switch: '<S1016>/Switch1' incorporates:
     *  Constant: '<S1016>/TRUEConstant1'
     *  Constant: '<S1051>/Calib'
     */
    if (KeTPCR_b_EnblRSCheck_FrstTmrSet)
    {
        rtb_UnitDelay_l3 = rtb_LogicalOperator1_c;
    }
    else
    {
        rtb_UnitDelay_l3 = true;
    }

    /* Outputs for Atomic SubSystem: '<S1016>/SignalLatchOnWithReset2' */
    /* Outputs for Atomic SubSystem: '<S1016>/EdgeFalling' */
    /* Logic: '<S1056>/OR1' incorporates:
     *  Constant: '<S1000>/Calib'
     *  Constant: '<S1045>/Constant'
     *  Constant: '<S1048>/Calib'
     *  Constant: '<S1049>/Calib'
     *  Constant: '<S1050>/Calib'
     *  Constant: '<S1052>/Calib'
     *  Constant: '<S1055>/Calib'
     *  Constant: '<S999>/Calib'
     *  Logic: '<S1016>/Logical10'
     *  Logic: '<S1016>/Logical11'
     *  Logic: '<S1016>/Logical12'
     *  Logic: '<S1016>/Logical13'
     *  Logic: '<S1016>/Logical15'
     *  Logic: '<S1016>/Logical2'
     *  Logic: '<S1016>/Logical5'
     *  Logic: '<S1016>/Logical6'
     *  Logic: '<S1016>/Logical7'
     *  Logic: '<S1016>/Logical8'
     *  Logic: '<S1016>/Logical9'
     *  Logic: '<S1043>/AND'
     *  Logic: '<S1043>/OR1'
     *  Logic: '<S1056>/NOT'
     *  Logic: '<S1056>/OR'
     *  RelationalOperator: '<S1016>/Comparison2'
     *  RelationalOperator: '<S1016>/Comparison3'
     *  RelationalOperator: '<S1016>/Comparison6'
     *  RelationalOperator: '<S612>/Comparison5'
     *  Switch: '<S1775>/Switch'
     *  UnitDelay: '<S1056>/UnitDelay'
     */
    VeTPCR_b_NoWup_FrstPerTimrSet = (((((((((((((!VeTPCR_b_ThermalFltsPerWkUp) ||
        (KeTPCR_b_NoWp_ThrmlFltsChk)) && (VeTPCR_b_PerWup_Enbl)) &&
        ((TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d <=
          KeTPCR_T_BatThrmlCond_LowAmbTemp) ||
         (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d >=
          KeTPCR_T_BatThrmlCond_HighAmbTemp))) && (VeTPCR_b_HCPShutDwnCmd)) &&
        (((uint32)VeTPCR_e_ShippingMode_AD) != CePLTR_e_ShipingMode_SHIP_MD)) &&
        VeTPCR_b_DoorAjarEnblLtch_Rst_t) && rtb_Gain_g) && rtb_UnitDelay_jk) &&
        rtb_UnitDelay_l3) && ((!VeTPCC_b_WpWaitBatCond_PerWpTimr) ||
        (KeTPCR_b_DsblPerWkUpChk_FirstTmr))) &&
        ((!VeTPCC_b_WpWaitBatCond_RS_DndDftTimr) ||
         (KeTPCR_b_DsblPerWkUpChkRSDny_FirstTmr))) || ((((!rtb_Switch2_nq) &&
        (rtb_LogicalOperator1_c || (!KeTPCR_b_EnblRSCheck_FrstTmrRst))) &&
        (((VeTPCR_b_HCPShutDwnCmd) || (!rtb_Switch1_mw)) ||
         (!KeTPCR_b_EnblShtDwnCheck_FrstTmrRst))) &&
        (TPCR_ac_DW.UnitDelay_DSTATE_orn)));

    /* End of Outputs for SubSystem: '<S1016>/EdgeFalling' */

    /* Update for UnitDelay: '<S1056>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_orn = VeTPCR_b_NoWup_FrstPerTimrSet;

    /* End of Outputs for SubSystem: '<S1016>/SignalLatchOnWithReset2' */

    /* Outputs for Atomic SubSystem: '<S1018>/EdgeRising' */
    /* Logic: '<S1071>/AND' incorporates:
     *  Logic: '<S1071>/OR1'
     *  UnitDelay: '<S1071>/UnitDelay'
     */
    rtb_Switch2_nq = !TPCR_ac_DW.UnitDelay_DSTATE_gh;

    /* Update for UnitDelay: '<S1071>/UnitDelay' incorporates:
     *  Constant: '<S1018>/TRUEConstant3'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_gh = true;

    /* End of Outputs for SubSystem: '<S1018>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S1018>/EdgeFalling' */
    /* Switch: '<S989>/Switch1' incorporates:
     *  UnitDelay: '<S1070>/UnitDelay'
     */
    rtb_Switch1_mw = TPCR_ac_DW.UnitDelay_DSTATE_jw;

    /* Update for UnitDelay: '<S1070>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_jw = VeTPCR_b_HCPShutDwnCmd;

    /* End of Outputs for SubSystem: '<S1018>/EdgeFalling' */

    /* Switch: '<S1018>/Switch1' incorporates:
     *  Constant: '<S1000>/Calib'
     *  Constant: '<S1018>/TRUEConstant'
     *  Constant: '<S1077>/Calib'
     *  Constant: '<S999>/Calib'
     *  Logic: '<S1018>/Logical1'
     *  Logic: '<S1018>/Logical6'
     *  RelationalOperator: '<S1018>/Comparison2'
     *  RelationalOperator: '<S1018>/Comparison8'
     */
    if (KeTPCR_b_PerWup_BatPlugShip)
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = ((VeTPCR_b_PerWup_Enbl) &&
            ((TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d <=
              KeTPCR_T_BatThrmlCond_LowAmbTemp) ||
             (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d >=
              KeTPCR_T_BatThrmlCond_HighAmbTemp)));
    }
    else
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = true;
    }

    /* End of Switch: '<S1018>/Switch1' */

    /* Switch: '<S1018>/Switch3' incorporates:
     *  Constant: '<S1018>/TRUEConstant2'
     *  Constant: '<S1073>/Calib'
     *  Logic: '<S1018>/Logical4'
     */
    if (KeTPCR_b_AmbTmpFAChk_ShipDfltTimr)
    {
        rtb_Gain_g = !TPCR_ac_B.TmpSignalConversionAtTmpVM_F_a0;
    }
    else
    {
        rtb_Gain_g = true;
    }

    /* End of Switch: '<S1018>/Switch3' */

    /* Switch: '<S1018>/Switch2' incorporates:
     *  Constant: '<S1018>/TRUEConstant1'
     *  Constant: '<S1074>/Calib'
     */
    if (KeTPCR_b_EnblRSCheck_ShipDfltTimr)
    {
        rtb_UnitDelay_jk = rtb_LogicalOperator1_c;
    }
    else
    {
        rtb_UnitDelay_jk = true;
    }

    /* Outputs for Atomic SubSystem: '<S1018>/SignalLatchOnWithReset3' */
    /* Outputs for Atomic SubSystem: '<S1018>/EdgeFalling' */
    /* Logic: '<S1078>/OR1' incorporates:
     *  Constant: '<S1072>/Constant'
     *  Constant: '<S1075>/Calib'
     *  Constant: '<S1076>/Calib'
     *  Logic: '<S1018>/Logical3'
     *  Logic: '<S1018>/Logical5'
     *  Logic: '<S1018>/Logical7'
     *  Logic: '<S1018>/Logical8'
     *  Logic: '<S1070>/AND'
     *  Logic: '<S1070>/OR1'
     *  Logic: '<S1078>/NOT'
     *  Logic: '<S1078>/OR'
     *  RelationalOperator: '<S1018>/Comparison10'
     *  RelationalOperator: '<S612>/Comparison5'
     *  Switch: '<S1775>/Switch'
     *  UnitDelay: '<S1078>/UnitDelay'
     */
    VeTPCR_b_NoWup_ShipDfltTimr = (((((VeTPCR_b_DoorAjarEnblLtch_Rst_t &&
        rtb_Gain_g) && (((uint32)VeTPCR_e_ShippingMode_AD) ==
                        CePLTR_e_ShipingMode_SHIP_MD)) &&
        (VeTPCR_b_HCPShutDwnCmd)) && rtb_UnitDelay_jk) || ((((!rtb_Switch2_nq) &&
        (rtb_LogicalOperator1_c || (!KeTPCR_b_EnblRSCheck_ShipDfltTimrRst))) &&
        (((VeTPCR_b_HCPShutDwnCmd) || (!rtb_Switch1_mw)) ||
         (!KeTPCR_b_EnblShtDwnCheck_ShipDfltTimrRst))) &&
        (TPCR_ac_DW.UnitDelay_DSTATE_md)));

    /* End of Outputs for SubSystem: '<S1018>/EdgeFalling' */

    /* Update for UnitDelay: '<S1078>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_md = VeTPCR_b_NoWup_ShipDfltTimr;

    /* End of Outputs for SubSystem: '<S1018>/SignalLatchOnWithReset3' */

    /* Outputs for IfAction SubSystem: '<S19>/Wup_WaitBatCond' incorporates:
     *  ActionPort: '<S1028>/ActionPort'
     */
    /* Outputs for IfAction SubSystem: '<S1028>/Subsystem6' incorporates:
     *  ActionPort: '<S1517>/ActionPort'
     */
    /* Outputs for IfAction SubSystem: '<S1028>/Subsystem1' incorporates:
     *  ActionPort: '<S1516>/ActionPort'
     */
    /* Outputs for IfAction SubSystem: '<S19>/Wup_WaitBatCond_RS' incorporates:
     *  ActionPort: '<S1029>/ActionPort'
     */
    /* If: '<S19>/If' incorporates:
     *  If: '<S1028>/If'
     *  Logic: '<S1027>/Logical1'
     *  Logic: '<S1027>/Logical4'
     *  Logic: '<S1029>/Logical7'
     *  Logic: '<S1542>/Logical6'
     *  Logic: '<S1610>/Logical6'
     */
    rtb_UnitDelay_l3 = !VeTPCR_b_PerWup_Enbl;

    /* End of Outputs for SubSystem: '<S19>/Wup_WaitBatCond_RS' */
    /* End of Outputs for SubSystem: '<S1028>/Subsystem1' */
    /* End of Outputs for SubSystem: '<S1028>/Subsystem6' */
    /* End of Outputs for SubSystem: '<S19>/Wup_WaitBatCond' */

    /* Outputs for Atomic SubSystem: '<S1027>/TurnOnDelayTime' */
    /* Outputs for Atomic SubSystem: '<S1506>/EdgeRising' */
    /* Logic: '<S1508>/AND' incorporates:
     *  Logic: '<S1027>/Logical4'
     *  Logic: '<S1508>/OR1'
     *  UnitDelay: '<S1508>/UnitDelay'
     */
    rtb_Switch1_mw = (rtb_UnitDelay_l3 && (!TPCR_ac_DW.UnitDelay_DSTATE_m1));

    /* Update for UnitDelay: '<S1508>/UnitDelay' incorporates:
     *  Logic: '<S1027>/Logical4'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_m1 = rtb_UnitDelay_l3;

    /* End of Outputs for SubSystem: '<S1506>/EdgeRising' */

    /* Switch: '<S1506>/Switch1' incorporates:
     *  Logic: '<S1027>/Logical4'
     *  Logic: '<S1506>/OR'
     *  Logic: '<S1506>/OR1'
     */
    if ((!rtb_UnitDelay_l3) || rtb_Switch1_mw)
    {
        /* Switch: '<S1506>/Switch1' incorporates:
         *  Constant: '<S1506>/ConstantValue1'
         */
        rtb_Switch1_l4 = 0.0F;
    }
    else
    {
        /* Switch: '<S1506>/Switch1' incorporates:
         *  Constant: '<S1502>/Calib'
         *  Constant: '<S1503>/Calib'
         *  MinMax: '<S1506>/Minimum'
         *  Sum: '<S1506>/Summation'
         *  UnitDelay: '<S1506>/UnitDelay'
         */
        rtb_Switch1_l4 = fminf(KeTPCR_t_PerWup_delayTime_PerWkupDsbl,
                               KeTPCR_t_PerWup_dT + TPCR_ac_DW.UnitDelay_DSTATE);
    }

    /* End of Switch: '<S1506>/Switch1' */

    /* Update for UnitDelay: '<S1506>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE = rtb_Switch1_l4;

    /* End of Outputs for SubSystem: '<S1027>/TurnOnDelayTime' */

    /* Logic: '<S1027>/Logical10' */
    VeTPCR_b_CabCond_DsblBattCond_PerWkUpDsbl = rtb_Switch3_c2;

    /* Switch: '<S989>/Switch1' incorporates:
     *  Logic: '<S1027>/Logical2'
     */
    rtb_Switch1_mw = !VeTPCR_b_CabCond_DsblBattCond_PerWkUpDsbl;

    /* Outputs for Atomic SubSystem: '<S1027>/TurnOnDelayTime' */
    /* Logic: '<S1027>/Logical3' incorporates:
     *  Constant: '<S1503>/Calib'
     *  Logic: '<S1027>/Logical4'
     *  Logic: '<S1506>/AND'
     *  RelationalOperator: '<S1506>/GreaterThan'
     */
    rtb_UnitDelay_jk = (((rtb_UnitDelay_l3 && (rtb_Switch1_l4 >=
                           KeTPCR_t_PerWup_delayTime_PerWkupDsbl)) &&
                         (VeTPCR_b_HVBatPerWkUp)) && rtb_Switch1_mw);

    /* End of Outputs for SubSystem: '<S1027>/TurnOnDelayTime' */

    /* Outputs for Atomic SubSystem: '<S1027>/EdgeFalling1' */
    /* Logic: '<S1493>/AND' incorporates:
     *  Logic: '<S1493>/OR1'
     *  UnitDelay: '<S1493>/UnitDelay'
     */
    rtb_Switch3_c2 = ((!VeTPCR_b_HVBatPerWkUp) &&
                      (TPCR_ac_DW.UnitDelay_DSTATE_gv));

    /* Update for UnitDelay: '<S1493>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_gv = VeTPCR_b_HVBatPerWkUp;

    /* End of Outputs for SubSystem: '<S1027>/EdgeFalling1' */

    /* Outputs for Atomic SubSystem: '<S1027>/EdgeRising2' */
    /* Logic: '<S1496>/AND' incorporates:
     *  Logic: '<S1027>/Logical4'
     *  Logic: '<S1496>/OR1'
     *  UnitDelay: '<S1496>/UnitDelay'
     */
    rtb_Gain_g = (rtb_UnitDelay_l3 && (!TPCR_ac_DW.UnitDelay_DSTATE_bk));

    /* Update for UnitDelay: '<S1496>/UnitDelay' incorporates:
     *  Logic: '<S1027>/Logical4'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_bk = rtb_UnitDelay_l3;

    /* End of Outputs for SubSystem: '<S1027>/EdgeRising2' */

    /* Outputs for Atomic SubSystem: '<S1027>/TurnOnDelaySample' */
    /* Outputs for Atomic SubSystem: '<S1505>/EdgeRising' */
    /* Logic: '<S1507>/AND' incorporates:
     *  Logic: '<S1507>/OR1'
     *  UnitDelay: '<S1507>/UnitDelay'
     */
    rtb_Switch2_nq = !TPCR_ac_DW.UnitDelay_DSTATE_od;

    /* Update for UnitDelay: '<S1507>/UnitDelay' incorporates:
     *  Constant: '<S1027>/TRUEConstant1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_od = true;

    /* End of Outputs for SubSystem: '<S1505>/EdgeRising' */

    /* Switch: '<S1505>/Switch1' incorporates:
     *  Constant: '<S1497>/Calib'
     *  Constant: '<S1505>/ConstantValue'
     *  Logic: '<S1505>/OR'
     *  MinMax: '<S1505>/Minimum'
     *  Sum: '<S1505>/Summation'
     *  UnitDelay: '<S1505>/UnitDelay'
     */
    if (rtb_Switch2_nq)
    {
        /* Switch: '<S1505>/Switch1' incorporates:
         *  Constant: '<S1505>/ConstantValue1'
         */
        rtb_Switch1_g1 = 0U;
    }
    else if (KeTPCR_Cnt_PerWupDsblDly < ((uint16)(((uint32)
                TPCR_ac_DW.UnitDelay_DSTATE_om) + 1U)))
    {
        /* MinMax: '<S1505>/Minimum' incorporates:
         *  Constant: '<S1497>/Calib'
         *  Switch: '<S1505>/Switch1'
         */
        rtb_Switch1_g1 = KeTPCR_Cnt_PerWupDsblDly;
    }
    else
    {
        /* Switch: '<S1505>/Switch1' incorporates:
         *  Constant: '<S1505>/ConstantValue'
         *  MinMax: '<S1505>/Minimum'
         *  Sum: '<S1505>/Summation'
         *  UnitDelay: '<S1505>/UnitDelay'
         */
        rtb_Switch1_g1 = (uint16)(((uint32)TPCR_ac_DW.UnitDelay_DSTATE_om) + 1U);
    }

    /* End of Switch: '<S1505>/Switch1' */

    /* Update for UnitDelay: '<S1505>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_om = rtb_Switch1_g1;

    /* Logic: '<S1027>/Logical7' incorporates:
     *  Constant: '<S1497>/Calib'
     *  Constant: '<S1500>/Calib'
     *  RelationalOperator: '<S1505>/GreaterThan'
     *  Switch: '<S1027>/Switch1'
     */
    rtb_Switch2_nq = (((rtb_Switch1_mw && rtb_Switch3_c2) && ((rtb_Switch1_g1 >=
                         KeTPCR_Cnt_PerWupDsblDly) && rtb_Gain_g)) &&
                      (KeTPCR_b_PerWupDsbl));

    /* End of Outputs for SubSystem: '<S1027>/TurnOnDelaySample' */

    /* Outputs for Atomic SubSystem: '<S1027>/EdgeRising1' */
    /* Logic: '<S1495>/AND' incorporates:
     *  Logic: '<S1495>/OR1'
     *  UnitDelay: '<S1495>/UnitDelay'
     */
    VeTPCR_b_CabCond_DsblBattCond_PerWkUpDsblTrig =
        ((VeTPCR_b_CabCond_DsblBattCond_PerWkUpDsbl) &&
         (!TPCR_ac_DW.UnitDelay_DSTATE_fb));

    /* Update for UnitDelay: '<S1495>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fb = VeTPCR_b_CabCond_DsblBattCond_PerWkUpDsbl;

    /* End of Outputs for SubSystem: '<S1027>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S1027>/EdgeRising' */
    /* Logic: '<S1494>/AND' incorporates:
     *  Logic: '<S1494>/OR1'
     *  UnitDelay: '<S1494>/UnitDelay'
     */
    rtb_Switch3_c2 = !TPCR_ac_DW.UnitDelay_DSTATE_il;

    /* Update for UnitDelay: '<S1494>/UnitDelay' incorporates:
     *  Constant: '<S1027>/TRUEConstant'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_il = true;

    /* End of Outputs for SubSystem: '<S1027>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S1027>/EdgeFalling' */
    /* Switch: '<S989>/Switch1' incorporates:
     *  UnitDelay: '<S1492>/UnitDelay'
     */
    rtb_Switch1_mw = TPCR_ac_DW.UnitDelay_DSTATE_fbp;

    /* Update for UnitDelay: '<S1492>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fbp = VeTPCR_b_HCPShutDwnCmd;

    /* Outputs for Atomic SubSystem: '<S1027>/SignalLatchOnWithReset3' */
    /* Logic: '<S1504>/OR1' incorporates:
     *  Constant: '<S1499>/Calib'
     *  Constant: '<S1501>/Calib'
     *  Logic: '<S1027>/Logical1'
     *  Logic: '<S1027>/Logical5'
     *  Logic: '<S1027>/Logical6'
     *  Logic: '<S1027>/Logical8'
     *  Logic: '<S1492>/AND'
     *  Logic: '<S1492>/OR1'
     *  Logic: '<S1504>/NOT'
     *  Logic: '<S1504>/OR'
     *  UnitDelay: '<S1504>/UnitDelay'
     */
    VeTPCC_b_Wp_PerWupDsbld = ((rtb_UnitDelay_jk || rtb_Switch2_nq) ||
        (((((!VeTPCR_b_CabCond_DsblBattCond_PerWkUpDsblTrig) && (!rtb_Switch3_c2))
           && (rtb_UnitDelay_l3 || (!KeTPCR_b_PerWupEnblChk_InPerWupDsbl))) &&
          (((VeTPCR_b_HCPShutDwnCmd) || (!rtb_Switch1_mw)) ||
           (!KeTPCR_b_EnblShtDwnChk_PerWupDsbl))) &&
         (TPCR_ac_DW.UnitDelay_DSTATE_omf)));

    /* End of Outputs for SubSystem: '<S1027>/EdgeFalling' */

    /* Update for UnitDelay: '<S1504>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_omf = VeTPCC_b_Wp_PerWupDsbld;

    /* End of Outputs for SubSystem: '<S1027>/SignalLatchOnWithReset3' */

    /* If: '<S19>/If' */
    rtPrevAction = TPCR_ac_DW.If_ActiveSubsystem;
    if (VeTPCC_b_NoWup_RS_DendShrtTimr)
    {
        rtAction = 0;
    }
    else if (VeTPCR_b_NoWup_FrstPerTimrSet)
    {
        rtAction = 1;
    }
    else if (VeTPCR_b_NoWup_ShipDfltTimr)
    {
        rtAction = 2;
    }
    else if (VeTPCC_b_WpWaitBatCond_RS_DndDftTimr)
    {
        rtAction = 3;
    }
    else if (VeTPCC_b_WpWaitBatCond_PerWpTimr)
    {
        rtAction = 4;
    }
    else if (VeTPCC_b_Wp_PerWupDsbld)
    {
        rtAction = 5;
    }
    else
    {
        rtAction = 6;
    }

    TPCR_ac_DW.If_ActiveSubsystem = rtAction;
    if (rtPrevAction != rtAction)
    {
        switch (rtPrevAction)
        {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
            break;

          case 5:
            /* Disable for Gain: '<S1472>/Gain' incorporates:
             *  Outport: '<S1025>/PerWupDsbl_ThrmlCond_Dflt'
             */
            VeTPCC_b_PerWupDsbl_ThrmlCond_Dflt = false;
            break;

          case 6:
            /* Disable for Gain: '<S1040>/Gain' incorporates:
             *  Outport: '<S992>/BatPerWU_ThrmlCond_Dflt'
             */
            VeTPCC_b_BatPerWU_ThrmlCond_Dflt = false;
            break;

          default:
            /* no actions */
            break;
        }
    }

    switch (rtAction)
    {
      case 0:
        /* Outputs for IfAction SubSystem: '<S19>/No_Wup_RS_Denied' incorporates:
         *  ActionPort: '<S1021>/ActionPort'
         */
        /* Merge: '<S19>/Merge' incorporates:
         *  Constant: '<S1096>/Calib'
         *  Gain: '<S1097>/Gain'
         */
        VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD =
            KeTPCR_t_BatThrmlCond_HCP_TimerShort;

        /* Outputs for Atomic SubSystem: '<S1021>/TurnOnDelayTime' */
        /* Outputs for Atomic SubSystem: '<S1099>/EdgeRising' */
        /* Logic: '<S1100>/AND' incorporates:
         *  Constant: '<S1008>/Calib'
         *  Logic: '<S1100>/OR1'
         *  UnitDelay: '<S1100>/UnitDelay'
         */
        rtb_Switch1_mw = ((KeTPCR_b_PerWup_RdyForShtDwn) &&
                          (!TPCR_ac_DW.UnitDelay_DSTATE_ii));

        /* Update for UnitDelay: '<S1100>/UnitDelay' incorporates:
         *  Constant: '<S1008>/Calib'
         */
        TPCR_ac_DW.UnitDelay_DSTATE_ii = KeTPCR_b_PerWup_RdyForShtDwn;

        /* End of Outputs for SubSystem: '<S1099>/EdgeRising' */

        /* Switch: '<S1099>/Switch1' incorporates:
         *  Constant: '<S1008>/Calib'
         *  Logic: '<S1099>/OR'
         *  Logic: '<S1099>/OR1'
         */
        if ((!KeTPCR_b_PerWup_RdyForShtDwn) || rtb_Switch1_mw)
        {
            /* Switch: '<S1099>/Switch1' incorporates:
             *  Constant: '<S1099>/ConstantValue1'
             */
            rtb_Switch1_l4 = 0.0F;
        }
        else
        {
            /* Switch: '<S1099>/Switch1' incorporates:
             *  Constant: '<S1013>/Calib'
             *  Constant: '<S1014>/Calib'
             *  MinMax: '<S1099>/Minimum'
             *  Sum: '<S1099>/Summation'
             *  UnitDelay: '<S1099>/UnitDelay'
             */
            rtb_Switch1_l4 = fminf(KeTPCR_t_PerWup_delayTime, KeTPCR_t_PerWup_dT
                                   + TPCR_ac_DW.UnitDelay_DSTATE_lw);
        }

        /* End of Switch: '<S1099>/Switch1' */

        /* Merge: '<S19>/Merge1' incorporates:
         *  Constant: '<S1008>/Calib'
         *  Constant: '<S1014>/Calib'
         *  Logic: '<S1099>/AND'
         *  RelationalOperator: '<S1099>/GreaterThan'
         */
        VeTPCC_b_PerWup_RdyShtDwn_BD = ((KeTPCR_b_PerWup_RdyForShtDwn) &&
            (rtb_Switch1_l4 >= KeTPCR_t_PerWup_delayTime));

        /* Update for UnitDelay: '<S1099>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_lw = rtb_Switch1_l4;

        /* End of Outputs for SubSystem: '<S1021>/TurnOnDelayTime' */

        /* Merge: '<S19>/Merge2' incorporates:
         *  Constant: '<S1094>/Calib'
         *  Gain: '<S1098>/Gain'
         */
        VeTPCC_b_PeriodWup_Msg2 = KeTPCR_b_NoWp_ShrtTim_Msg2;

        /* Merge: '<S19>/Merge3' incorporates:
         *  Constant: '<S1093>/Constant'
         *  SignalConversion generated from: '<S1021>/PerWup_BattEngCond_State'
         */
        TPCR_ac_B.Merge3_f = CeTPCR_e_NoneOfEngBatt_Cond;

        /* Merge: '<S19>/Merge4' incorporates:
         *  Constant: '<S1095>/Calib'
         *  SignalConversion generated from: '<S1021>/PerWpCond_BatTmpErr'
         */
        TPCR_ac_B.Merge4 = KeTPCR_dT_PerWkUpBattErr;

        /* End of Outputs for SubSystem: '<S19>/No_Wup_RS_Denied' */
        break;

      case 1:
        /* Outputs for IfAction SubSystem: '<S19>/NoWup_FirstTimerSet' incorporates:
         *  ActionPort: '<S1017>/ActionPort'
         */
        /* RelationalOperator: '<S1017>/Comparison' incorporates:
         *  Constant: '<S1001>/Calib'
         */
        VeTPCR_b_AmbLowTimer = (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d <=
                                KeTPCR_T_PerWup_AmbTempThrsld);

        /* RelationalOperator: '<S1017>/Comparison1' incorporates:
         *  Constant: '<S1002>/Calib'
         */
        VeTPCR_b_AmbHiTimer = (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d >=
                               KeTPCR_T_PerWup_AmbTempThrsldHot);

        /* Outputs for Atomic SubSystem: '<S1017>/OpenInterval' */
        /* Logic: '<S1066>/LogicalOperator' incorporates:
         *  Constant: '<S1001>/Calib'
         *  Constant: '<S1002>/Calib'
         *  RelationalOperator: '<S1066>/RelatonalOperator'
         *  RelationalOperator: '<S1066>/RelatonalOperator1'
         */
        VeTPCR_b_AmbOptimalNoTmr = ((TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d >
            KeTPCR_T_PerWup_AmbTempThrsld) &&
            (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d <
             KeTPCR_T_PerWup_AmbTempThrsldHot));

        /* End of Outputs for SubSystem: '<S1017>/OpenInterval' */

        /* Switch: '<S1017>/Switch' incorporates:
         *  Switch: '<S1017>/Switch2'
         *  Switch: '<S1017>/Switch3'
         */
        if (VeTPCR_b_AmbOptimalNoTmr)
        {
            /* Merge: '<S19>/Merge' incorporates:
             *  Constant: '<S1012>/Calib'
             */
            VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD =
                KeTPCR_t_BatThrmlCond_HCP_TimerDflt;
        }
        else if (VeTPCR_b_AmbLowTimer)
        {
            /* Switch: '<S1017>/Switch1' incorporates:
             *  Constant: '<S1059>/Calib'
             *  Switch: '<S1017>/Switch2'
             */
            if (KeTPCR_b_Sel_AmbTmpFirstTmr)
            {
                /* Merge: '<S19>/Merge' incorporates:
                 *  Lookup_n-D: '<S1064>/Vector'
                 *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
                 *  Switch: '<S1017>/Switch1'
                 *  Switch: '<S1017>/Switch2'
                 */
                VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD = look1_iflf_binlcapw
                    (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d, ((const float32 *)
                      &(KxTPCR_t_ThrmPerWp_FirstTmr[0])), ((const float32 *)
                      &(KtTPCR_t_ThrmPerWp_FirstTmr[0])), 7U);
            }
            else
            {
                /* Merge: '<S19>/Merge' incorporates:
                 *  Lookup_n-D: '<S1062>/Vector'
                 *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
                 *  Switch: '<S1017>/Switch1'
                 *  Switch: '<S1017>/Switch2'
                 */
                VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD = look2_iflf_binlcapw
                    (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d,
                     TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lp, ((const float32 *)
                      &(KxTPCR_t_PerWkup_AmbCellMinTmr[0])), ((const float32 *)
                      &(KyTPCR_t_PerWkup_AmbCellMinTmr[0])), ((const float32 *)
                      &(KtTPCR_t_PerWkup_AmbCellMinTmr[0])),
                     TPCR_ac_ConstP.pooled10, 7U);
            }

            /* End of Switch: '<S1017>/Switch1' */
        }
        else if (VeTPCR_b_AmbHiTimer)
        {
            /* Switch: '<S1017>/Switch4' incorporates:
             *  Constant: '<S1060>/Calib'
             *  Switch: '<S1017>/Switch2'
             *  Switch: '<S1017>/Switch3'
             */
            if (KeTPCR_b_Sel_AmbTmpFirstTmr_Hot)
            {
                /* Merge: '<S19>/Merge' incorporates:
                 *  Lookup_n-D: '<S1065>/Vector'
                 *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
                 *  Switch: '<S1017>/Switch4'
                 */
                VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD = look1_iflf_binlcapw
                    (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d, ((const float32 *)
                      &(KxTPCR_t_ThrmPerWp_FirstTmrHot[0])), ((const float32 *)
                      &(KtTPCR_t_ThrmPerWp_FirstTmrHot[0])), 7U);
            }
            else
            {
                /* Merge: '<S19>/Merge' incorporates:
                 *  Lookup_n-D: '<S1063>/Vector'
                 *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
                 *  Switch: '<S1017>/Switch4'
                 */
                VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD = look2_iflf_binlcapw
                    (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d,
                     TPCR_ac_B.TmpSignalConversionAtTmpVM_F_du, ((const float32 *)
                      &(KxTPCR_t_PerWkup_AmbCellMinTmrHot[0])), ((const float32 *)
                      &(KyTPCR_t_PerWkup_AmbCellMinTmrHot[0])), ((const float32 *)
                      &(KtTPCR_t_PerWkup_AmbCellMinTmrHot[0])),
                     TPCR_ac_ConstP.pooled10, 7U);
            }

            /* End of Switch: '<S1017>/Switch4' */
        }
        else
        {
            /* Merge: '<S19>/Merge' incorporates:
             *  Constant: '<S1012>/Calib'
             *  Switch: '<S1017>/Switch2'
             *  Switch: '<S1017>/Switch3'
             */
            VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD =
                KeTPCR_t_BatThrmlCond_HCP_TimerDflt;
        }

        /* End of Switch: '<S1017>/Switch' */

        /* Outputs for Atomic SubSystem: '<S1017>/TurnOnDelayTime' */
        /* Outputs for Atomic SubSystem: '<S1068>/EdgeRising' */
        /* Logic: '<S1069>/AND' incorporates:
         *  Constant: '<S1008>/Calib'
         *  Logic: '<S1069>/OR1'
         *  UnitDelay: '<S1069>/UnitDelay'
         */
        rtb_Switch1_mw = ((KeTPCR_b_PerWup_RdyForShtDwn) &&
                          (!TPCR_ac_DW.UnitDelay_DSTATE_bz5));

        /* Update for UnitDelay: '<S1069>/UnitDelay' incorporates:
         *  Constant: '<S1008>/Calib'
         */
        TPCR_ac_DW.UnitDelay_DSTATE_bz5 = KeTPCR_b_PerWup_RdyForShtDwn;

        /* End of Outputs for SubSystem: '<S1068>/EdgeRising' */

        /* Switch: '<S1068>/Switch1' incorporates:
         *  Constant: '<S1008>/Calib'
         *  Logic: '<S1068>/OR'
         *  Logic: '<S1068>/OR1'
         */
        if ((!KeTPCR_b_PerWup_RdyForShtDwn) || rtb_Switch1_mw)
        {
            /* Switch: '<S1068>/Switch1' incorporates:
             *  Constant: '<S1068>/ConstantValue1'
             */
            rtb_Switch1_l4 = 0.0F;
        }
        else
        {
            /* Switch: '<S1068>/Switch1' incorporates:
             *  Constant: '<S1013>/Calib'
             *  Constant: '<S1014>/Calib'
             *  MinMax: '<S1068>/Minimum'
             *  Sum: '<S1068>/Summation'
             *  UnitDelay: '<S1068>/UnitDelay'
             */
            rtb_Switch1_l4 = fminf(KeTPCR_t_PerWup_delayTime, KeTPCR_t_PerWup_dT
                                   + TPCR_ac_DW.UnitDelay_DSTATE_f);
        }

        /* End of Switch: '<S1068>/Switch1' */

        /* Merge: '<S19>/Merge1' incorporates:
         *  Constant: '<S1008>/Calib'
         *  Constant: '<S1014>/Calib'
         *  Logic: '<S1068>/AND'
         *  RelationalOperator: '<S1068>/GreaterThan'
         */
        VeTPCC_b_PerWup_RdyShtDwn_BD = ((KeTPCR_b_PerWup_RdyForShtDwn) &&
            (rtb_Switch1_l4 >= KeTPCR_t_PerWup_delayTime));

        /* Update for UnitDelay: '<S1068>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_f = rtb_Switch1_l4;

        /* End of Outputs for SubSystem: '<S1017>/TurnOnDelayTime' */

        /* Merge: '<S19>/Merge2' incorporates:
         *  Constant: '<S1058>/Calib'
         *  Gain: '<S1067>/Gain'
         */
        VeTPCC_b_PeriodWup_Msg2 = KeTPCR_b_NoWp_FirstTimSet_Msg2;

        /* Merge: '<S19>/Merge3' incorporates:
         *  Constant: '<S1057>/Constant'
         *  SignalConversion generated from: '<S1017>/PerWup_BattEngCond_State'
         */
        TPCR_ac_B.Merge3_f = CeTPCR_e_NoneOfEngBatt_Cond;

        /* Merge: '<S19>/Merge4' incorporates:
         *  Constant: '<S1061>/Calib'
         *  SignalConversion generated from: '<S1017>/PerWpCond_BatTmpErr'
         */
        TPCR_ac_B.Merge4 = KeTPCR_dT_PerWkUpBattErr;

        /* End of Outputs for SubSystem: '<S19>/NoWup_FirstTimerSet' */
        break;

      case 2:
        /* Outputs for IfAction SubSystem: '<S19>/NoWup_Ship_DftTim' incorporates:
         *  ActionPort: '<S1020>/ActionPort'
         */
        /* Merge: '<S19>/Merge' incorporates:
         *  Constant: '<S1012>/Calib'
         *  Gain: '<S1089>/Gain'
         */
        VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD =
            KeTPCR_t_BatThrmlCond_HCP_TimerDflt;

        /* Outputs for Atomic SubSystem: '<S1020>/TurnOnDelayTime' */
        /* Outputs for Atomic SubSystem: '<S1091>/EdgeRising' */
        /* Logic: '<S1092>/AND' incorporates:
         *  Constant: '<S1008>/Calib'
         *  Logic: '<S1092>/OR1'
         *  UnitDelay: '<S1092>/UnitDelay'
         */
        rtb_Switch1_mw = ((KeTPCR_b_PerWup_RdyForShtDwn) &&
                          (!TPCR_ac_DW.UnitDelay_DSTATE_nh));

        /* Update for UnitDelay: '<S1092>/UnitDelay' incorporates:
         *  Constant: '<S1008>/Calib'
         */
        TPCR_ac_DW.UnitDelay_DSTATE_nh = KeTPCR_b_PerWup_RdyForShtDwn;

        /* End of Outputs for SubSystem: '<S1091>/EdgeRising' */

        /* Switch: '<S1091>/Switch1' incorporates:
         *  Constant: '<S1008>/Calib'
         *  Logic: '<S1091>/OR'
         *  Logic: '<S1091>/OR1'
         */
        if ((!KeTPCR_b_PerWup_RdyForShtDwn) || rtb_Switch1_mw)
        {
            /* Switch: '<S1091>/Switch1' incorporates:
             *  Constant: '<S1091>/ConstantValue1'
             */
            rtb_Switch1_l4 = 0.0F;
        }
        else
        {
            /* Switch: '<S1091>/Switch1' incorporates:
             *  Constant: '<S1013>/Calib'
             *  Constant: '<S1014>/Calib'
             *  MinMax: '<S1091>/Minimum'
             *  Sum: '<S1091>/Summation'
             *  UnitDelay: '<S1091>/UnitDelay'
             */
            rtb_Switch1_l4 = fminf(KeTPCR_t_PerWup_delayTime, KeTPCR_t_PerWup_dT
                                   + TPCR_ac_DW.UnitDelay_DSTATE_oo);
        }

        /* End of Switch: '<S1091>/Switch1' */

        /* Merge: '<S19>/Merge1' incorporates:
         *  Constant: '<S1008>/Calib'
         *  Constant: '<S1014>/Calib'
         *  Logic: '<S1091>/AND'
         *  RelationalOperator: '<S1091>/GreaterThan'
         */
        VeTPCC_b_PerWup_RdyShtDwn_BD = ((KeTPCR_b_PerWup_RdyForShtDwn) &&
            (rtb_Switch1_l4 >= KeTPCR_t_PerWup_delayTime));

        /* Update for UnitDelay: '<S1091>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_oo = rtb_Switch1_l4;

        /* End of Outputs for SubSystem: '<S1020>/TurnOnDelayTime' */

        /* Merge: '<S19>/Merge2' incorporates:
         *  Constant: '<S1088>/Calib'
         *  Gain: '<S1090>/Gain'
         */
        VeTPCC_b_PeriodWup_Msg2 = KeTPCR_b_NoWp_Ship_Msg2;

        /* End of Outputs for SubSystem: '<S19>/NoWup_Ship_DftTim' */
        break;

      case 3:
        /* Outputs for IfAction SubSystem: '<S19>/Wup_WaitBatCond_RS' incorporates:
         *  ActionPort: '<S1029>/ActionPort'
         */
        /* RelationalOperator: '<S1029>/Comparison13' incorporates:
         *  Constant: '<S1703>/Calib'
         */
        rtb_UnitDelay_jk = (VeTPCR_P_ThrmlPwrBdgt <=
                            KeTPCR_P_LowPwrBdgt_BattCond);

        /* Outputs for Atomic SubSystem: '<S1029>/EdgeRising1' */
        /* Logic: '<S1696>/OR1' incorporates:
         *  UnitDelay: '<S1696>/UnitDelay'
         */
        rtb_Switch1_mw = !TPCR_ac_DW.UnitDelay_DSTATE_avz3;

        /* Update for UnitDelay: '<S1696>/UnitDelay' incorporates:
         *  Constant: '<S1029>/TRUEConstant4'
         */
        TPCR_ac_DW.UnitDelay_DSTATE_avz3 = true;

        /* End of Outputs for SubSystem: '<S1029>/EdgeRising1' */

        /* Outputs for Atomic SubSystem: '<S1029>/EdgeRising2' */
        /* Logic: '<S1697>/OR1' incorporates:
         *  UnitDelay: '<S1697>/UnitDelay'
         */
        rtb_Switch2_nq = !TPCR_ac_DW.UnitDelay_DSTATE_gj;

        /* Update for UnitDelay: '<S1697>/UnitDelay' incorporates:
         *  Constant: '<S1029>/TRUEConstant1'
         */
        TPCR_ac_DW.UnitDelay_DSTATE_gj = true;

        /* End of Outputs for SubSystem: '<S1029>/EdgeRising2' */

        /* Outputs for Atomic SubSystem: '<S1029>/EdgeRising3' */
        /* Logic: '<S1698>/AND' incorporates:
         *  Logic: '<S1698>/OR1'
         *  UnitDelay: '<S1698>/UnitDelay'
         */
        rtb_Switch3_c2 = (rtb_UnitDelay_jk && (!TPCR_ac_DW.UnitDelay_DSTATE_ed));

        /* Update for UnitDelay: '<S1698>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_ed = rtb_UnitDelay_jk;

        /* End of Outputs for SubSystem: '<S1029>/EdgeRising3' */

        /* Outputs for Atomic SubSystem: '<S1029>/TimerRetriggerResetEnabled' */
        /* Outputs for Atomic SubSystem: '<S1029>/EdgeRising2' */
        /* Switch: '<S1724>/Switch1' incorporates:
         *  Logic: '<S1697>/AND'
         */
        if (rtb_Switch2_nq)
        {
            /* Switch: '<S1724>/Switch1' incorporates:
             *  Constant: '<S1719>/Calib'
             */
            rtb_Switch1_l4 = KeTPCR_t_Wp_WaitBatCond_Tim;
        }
        else
        {
            /* Switch: '<S1724>/Switch1' incorporates:
             *  Constant: '<S1716>/Calib'
             *  Constant: '<S1724>/ConstantValue4'
             *  MinMax: '<S1724>/Maximum'
             *  Sum: '<S1724>/Subtraction'
             *  UnitDelay: '<S1724>/UnitDelay'
             */
            rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_ec -
                                   KeTPCR_t_PerWupCond_dT, 0.0F);
        }

        /* End of Switch: '<S1724>/Switch1' */
        /* End of Outputs for SubSystem: '<S1029>/EdgeRising2' */

        /* Update for UnitDelay: '<S1724>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_ec = rtb_Switch1_l4;

        /* Logic: '<S1029>/Logical13' incorporates:
         *  Constant: '<S1724>/ConstantValue2'
         *  RelationalOperator: '<S1724>/GreaterThan1'
         */
        VeTPCR_b_RSDsbld_PerWupTmOut = (rtb_Switch1_l4 <= 0.0F);

        /* End of Outputs for SubSystem: '<S1029>/TimerRetriggerResetEnabled' */

        /* Outputs for Atomic SubSystem: '<S1029>/TimerRetriggerResetEnabled1' */
        /* Switch: '<S1725>/Switch1' incorporates:
         *  Logic: '<S1029>/Logical15'
         *  Logic: '<S1029>/Logical20'
         */
        if ((!rtb_UnitDelay_jk) || rtb_Switch3_c2)
        {
            /* Switch: '<S1725>/Switch1' incorporates:
             *  Constant: '<S1715>/Calib'
             *  Constant: '<S1716>/Calib'
             *  Sum: '<S1029>/Add'
             */
            rtb_Switch1_l4 = KeTPCR_t_LoPwrBdgtDbnc + KeTPCR_t_PerWupCond_dT;
        }
        else
        {
            /* Switch: '<S1725>/Switch1' incorporates:
             *  Constant: '<S1716>/Calib'
             *  Constant: '<S1725>/ConstantValue4'
             *  MinMax: '<S1725>/Maximum'
             *  Sum: '<S1725>/Subtraction'
             *  Switch: '<S1725>/Switch2'
             *  UnitDelay: '<S1725>/UnitDelay'
             */
            rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_hp -
                                   KeTPCR_t_PerWupCond_dT, 0.0F);
        }

        /* End of Switch: '<S1725>/Switch1' */

        /* Update for UnitDelay: '<S1725>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_hp = rtb_Switch1_l4;

        /* End of Outputs for SubSystem: '<S1029>/TimerRetriggerResetEnabled1' */

        /* Outputs for Atomic SubSystem: '<S1029>/TurnOnDelayTime' */
        /* Outputs for Atomic SubSystem: '<S1726>/EdgeRising' */
        /* Logic: '<S1732>/AND' incorporates:
         *  Logic: '<S1732>/OR1'
         *  UnitDelay: '<S1732>/UnitDelay'
         */
        rtb_Switch2_nq = (rtb_UnitDelay_l3 && (!TPCR_ac_DW.UnitDelay_DSTATE_ad));

        /* Update for UnitDelay: '<S1732>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_ad = rtb_UnitDelay_l3;

        /* End of Outputs for SubSystem: '<S1726>/EdgeRising' */

        /* Switch: '<S1726>/Switch1' incorporates:
         *  Logic: '<S1726>/OR'
         *  Logic: '<S1726>/OR1'
         */
        if ((!rtb_UnitDelay_l3) || rtb_Switch2_nq)
        {
            /* Switch: '<S1726>/Switch1' incorporates:
             *  Constant: '<S1726>/ConstantValue1'
             */
            rtb_Switch1_ml1 = 0.0F;
        }
        else
        {
            /* Switch: '<S1726>/Switch1' incorporates:
             *  Constant: '<S1717>/Calib'
             *  Constant: '<S1718>/Calib'
             *  MinMax: '<S1726>/Minimum'
             *  Sum: '<S1726>/Summation'
             *  UnitDelay: '<S1726>/UnitDelay'
             */
            rtb_Switch1_ml1 = fminf(KeTPCR_t_PerWupEnblDbnc, KeTPCR_t_PerWup_dT
                                    + TPCR_ac_DW.UnitDelay_DSTATE_kp);
        }

        /* End of Switch: '<S1726>/Switch1' */

        /* Update for UnitDelay: '<S1726>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_kp = rtb_Switch1_ml1;

        /* Outputs for Atomic SubSystem: '<S1029>/TimerRetriggerResetEnabled1' */
        /* Logic: '<S1029>/Logical5' incorporates:
         *  Constant: '<S1029>/ConstantValue1'
         *  Constant: '<S1029>/ConstantValue3'
         *  Constant: '<S1699>/Constant'
         *  Constant: '<S1700>/Constant'
         *  Constant: '<S1702>/Constant'
         *  Constant: '<S1704>/Calib'
         *  Constant: '<S1705>/Calib'
         *  Constant: '<S1706>/Calib'
         *  Constant: '<S1707>/Calib'
         *  Constant: '<S1708>/Calib'
         *  Constant: '<S1709>/Calib'
         *  Constant: '<S1710>/Calib'
         *  Constant: '<S1711>/Calib'
         *  Constant: '<S1713>/Calib'
         *  Constant: '<S1714>/Calib'
         *  Constant: '<S1717>/Calib'
         *  Constant: '<S1725>/ConstantValue2'
         *  Logic: '<S1029>/Logical'
         *  Logic: '<S1029>/Logical1'
         *  Logic: '<S1029>/Logical10'
         *  Logic: '<S1029>/Logical11'
         *  Logic: '<S1029>/Logical12'
         *  Logic: '<S1029>/Logical14'
         *  Logic: '<S1029>/Logical2'
         *  Logic: '<S1029>/Logical3'
         *  Logic: '<S1029>/Logical4'
         *  Logic: '<S1029>/Logical6'
         *  Logic: '<S1029>/Logical8'
         *  Logic: '<S1029>/Logical9'
         *  Logic: '<S1726>/AND'
         *  RelationalOperator: '<S1029>/Comparison'
         *  RelationalOperator: '<S1029>/Comparison1'
         *  RelationalOperator: '<S1029>/Comparison2'
         *  RelationalOperator: '<S1029>/Comparison3'
         *  RelationalOperator: '<S1029>/Comparison4'
         *  RelationalOperator: '<S1029>/Comparison6'
         *  RelationalOperator: '<S1029>/Comparison7'
         *  RelationalOperator: '<S1029>/Comparison8'
         *  RelationalOperator: '<S1029>/Comparison9'
         *  RelationalOperator: '<S1725>/GreaterThan1'
         *  RelationalOperator: '<S1726>/GreaterThan'
         */
        VeTPCR_b_WUpWaitBatCond_RSDndPrev =
            (((((((((VeTPCR_b_RSDsbld_PerWupTmOut) &&
                    ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lp >=
                      KeTPCR_T_RSDniedWkUp_TimeOutCellTmp) ||
                     (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_du <=
                      KeTPCR_T_RSDniedWkUp_TimeOutCellTmpHot))) &&
                   (KeTPCR_b_EnblTmOut_RSDniedWkUp)) ||
                  (((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn <=
                     KeTPCR_dT_WupWaitBatCond_CellUnderTemp_Min) ||
                    (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_g <=
                     KeTPCR_dT_WupWaitBatCond_CellOvrTemp_Min)) &&
                   (KeTPCR_b_WpWaitBatCond_CellUnderTmpLess))) || ((((((uint32)
                      Switch_cl) != CeTPCR_e_NoCabPrec_HV_BatCrit) &&
                    (KeTPCR_b_WpWaitBatCond_CabPrecBatCrit)) || ((((uint32)
                      Switch_cl) != CeTPCR_e_CabinPrec_Off) &&
                    (KeTPCR_b_WpWaitBatCond_CabPrec_Off))) || ((((uint32)
                     Switch_cl) != CeTPCR_e_CabinPrec_Dflt) &&
                   (KeTPCR_b_WpWaitBatCond_CabPrec_Dflt)))) ||
                ((rtb_UnitDelay_l3 && (rtb_Switch1_ml1 >=
                   KeTPCR_t_PerWupEnblDbnc)) &&
                 (KeTPCR_b_EnblShtDwnPerWupEnblBit))) ||
               ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn > 0.0F) &&
                (VeTPCR_b_ThermalFltsPerWkUp))) ||
              ((TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_g > 0.0F) &&
               rtb_RelationalOperator1_dfl)) || (rtb_Switch1_l4 <= 0.0F));

        /* End of Outputs for SubSystem: '<S1029>/TimerRetriggerResetEnabled1' */
        /* End of Outputs for SubSystem: '<S1029>/TurnOnDelayTime' */

        /* Outputs for Atomic SubSystem: '<S1029>/SignalLatchOnWithReset2' */
        /* Outputs for Atomic SubSystem: '<S1029>/EdgeRising1' */
        /* Logic: '<S1722>/OR1' incorporates:
         *  Logic: '<S1696>/AND'
         *  Logic: '<S1722>/OR'
         *  UnitDelay: '<S1722>/UnitDelay'
         */
        rtb_Switch1_mw = ((VeTPCR_b_WUpWaitBatCond_RSDndPrev) ||
                          ((!rtb_Switch1_mw) && (TPCR_ac_DW.UnitDelay_DSTATE_jt)));

        /* End of Outputs for SubSystem: '<S1029>/EdgeRising1' */

        /* Update for UnitDelay: '<S1722>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_jt = rtb_Switch1_mw;

        /* End of Outputs for SubSystem: '<S1029>/SignalLatchOnWithReset2' */

        /* Outputs for Enabled SubSystem: '<S1029>/Subsystem2' incorporates:
         *  EnablePort: '<S1723>/Enable'
         */
        if (rtb_Switch1_mw)
        {
            /* Gain: '<S1728>/Gain' incorporates:
             *  Constant: '<S1012>/Calib'
             */
            TPCR_ac_B.Gain_m = KeTPCR_t_BatThrmlCond_HCP_TimerDflt;

            /* Outputs for Atomic SubSystem: '<S1723>/TurnOnDelayTime' */
            /* Outputs for Atomic SubSystem: '<S1730>/EdgeRising' */
            /* Logic: '<S1731>/AND' incorporates:
             *  Constant: '<S1008>/Calib'
             *  Logic: '<S1731>/OR1'
             *  UnitDelay: '<S1731>/UnitDelay'
             */
            rtb_Switch1_mw = ((KeTPCR_b_PerWup_RdyForShtDwn) &&
                              (!TPCR_ac_DW.UnitDelay_DSTATE_fq));

            /* Update for UnitDelay: '<S1731>/UnitDelay' incorporates:
             *  Constant: '<S1008>/Calib'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_fq = KeTPCR_b_PerWup_RdyForShtDwn;

            /* End of Outputs for SubSystem: '<S1730>/EdgeRising' */

            /* Switch: '<S1730>/Switch1' incorporates:
             *  Constant: '<S1008>/Calib'
             *  Logic: '<S1730>/OR'
             *  Logic: '<S1730>/OR1'
             */
            if ((!KeTPCR_b_PerWup_RdyForShtDwn) || rtb_Switch1_mw)
            {
                /* Switch: '<S1730>/Switch1' incorporates:
                 *  Constant: '<S1730>/ConstantValue1'
                 */
                rtb_Switch1_l4 = 0.0F;
            }
            else
            {
                /* Switch: '<S1730>/Switch1' incorporates:
                 *  Constant: '<S1013>/Calib'
                 *  Constant: '<S1014>/Calib'
                 *  MinMax: '<S1730>/Minimum'
                 *  Sum: '<S1730>/Summation'
                 *  UnitDelay: '<S1730>/UnitDelay'
                 */
                rtb_Switch1_l4 = fminf(KeTPCR_t_PerWup_delayTime,
                                       KeTPCR_t_PerWup_dT +
                                       TPCR_ac_DW.UnitDelay_DSTATE_g);
            }

            /* End of Switch: '<S1730>/Switch1' */

            /* Logic: '<S1730>/AND' incorporates:
             *  Constant: '<S1008>/Calib'
             *  Constant: '<S1014>/Calib'
             *  RelationalOperator: '<S1730>/GreaterThan'
             */
            TPCR_ac_B.AND_m = ((KeTPCR_b_PerWup_RdyForShtDwn) && (rtb_Switch1_l4
                                >= KeTPCR_t_PerWup_delayTime));

            /* Update for UnitDelay: '<S1730>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_g = rtb_Switch1_l4;

            /* End of Outputs for SubSystem: '<S1723>/TurnOnDelayTime' */

            /* Gain: '<S1729>/Gain' incorporates:
             *  Constant: '<S1727>/Calib'
             */
            TPCR_ac_B.Gain_gc = KeTPCR_b_Wp_RS_Msg2;
        }

        /* End of Outputs for SubSystem: '<S1029>/Subsystem2' */

        /* Merge: '<S19>/Merge2' incorporates:
         *  SignalConversion generated from: '<S1029>/Wp_RS_Msg2'
         */
        VeTPCC_b_PeriodWup_Msg2 = TPCR_ac_B.Gain_gc;

        /* Merge: '<S19>/Merge' incorporates:
         *  Gain: '<S1720>/Gain'
         */
        VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD = TPCR_ac_B.Gain_m;

        /* Merge: '<S19>/Merge1' incorporates:
         *  Gain: '<S1721>/Gain'
         */
        VeTPCC_b_PerWup_RdyShtDwn_BD = TPCR_ac_B.AND_m;

        /* Merge: '<S19>/Merge3' incorporates:
         *  Constant: '<S1701>/Constant'
         *  SignalConversion generated from: '<S1029>/PerWup_BattEngCond_State'
         */
        TPCR_ac_B.Merge3_f = CeTPCR_e_NoneOfEngBatt_Cond;

        /* Merge: '<S19>/Merge4' incorporates:
         *  Constant: '<S1712>/Calib'
         *  SignalConversion generated from: '<S1029>/PerWpCond_BatTmpErr'
         */
        TPCR_ac_B.Merge4 = KeTPCR_dT_PerWkUpBattErr;

        /* End of Outputs for SubSystem: '<S19>/Wup_WaitBatCond_RS' */
        break;

      case 4:
        /* Outputs for IfAction SubSystem: '<S19>/Wup_WaitBatCond' incorporates:
         *  ActionPort: '<S1028>/ActionPort'
         */
        /* If: '<S1028>/If' incorporates:
         *  Constant: '<S1512>/Calib'
         *  Constant: '<S1513>/Calib'
         *  Constant: '<S1562>/Calib'
         *  Constant: '<S1659>/Calib'
         *  Logic: '<S1561>/Logical1'
         *  Logic: '<S1657>/Logical1'
         *  RelationalOperator: '<S1028>/Comparison'
         *  RelationalOperator: '<S1028>/Comparison1'
         *  Switch: '<S1567>/Switch1'
         *  Switch: '<S1666>/Switch1'
         *  UnitDelay: '<S1561>/UnitDelay2'
         *  UnitDelay: '<S1657>/UnitDelay2'
         */
        if (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d <=
                KeTPCR_T_ColdAmbTh_PerWkup)
        {
            /* Outputs for IfAction SubSystem: '<S1028>/Subsystem6' incorporates:
             *  ActionPort: '<S1517>/ActionPort'
             */
            /* Lookup_n-D: '<S1646>/Vector' incorporates:
             *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
             */
            rtb_Switch1_l4 = look1_iflf_binlcapw
                (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d, ((const float32 *)
                  &(KxTPCR_t_ThrmPerWp_BattEngCond_Tim[0])), ((const float32 *)
                  &(KtTPCR_t_ThrmPerWp_BattEngCond_Tim[0])), 7U);

            /* Sum: '<S1648>/Subtraction1' incorporates:
             *  Constant: '<S1598>/Calib'
             *  Constant: '<S1656>/Calib'
             *  Math: '<S1654>/MathFunction'
             *  Product: '<S1648>/Product'
             *  Product: '<S1648>/Product1'
             *  Sum: '<S1648>/Subtraction'
             *
             * About '<S1654>/MathFunction':
             *  Operator: exp
             */
            VeTPCR_T_BatTmpTgt_Tob = ((KeTPCR_T_PerWpCond_BatTempFin -
                TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d) * expf(rtb_Switch1_l4
                * KeTPCR_cmp_BatTmpDecad_rate)) +
                TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d;

            /* Switch: '<S1648>/Switch' incorporates:
             *  Constant: '<S1598>/Calib'
             *  Constant: '<S1655>/Calib'
             *  Logic: '<S1648>/Logical7'
             *  RelationalOperator: '<S1648>/Comparison'
             */
            if ((TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d >=
                    KeTPCR_T_PerWpCond_BatTempFin) &&
                    (KeTPCR_b_EnblAmbChk_ForBattTgt))
            {
                /* Switch: '<S1648>/Switch' */
                rtb_Switch1_ml1 = KeTPCR_T_PerWpCond_BatTempFin;
            }
            else
            {
                /* Switch: '<S1648>/Switch' */
                rtb_Switch1_ml1 = VeTPCR_T_BatTmpTgt_Tob;
            }

            /* End of Switch: '<S1648>/Switch' */

            /* Sum: '<S1647>/Subtraction1' incorporates:
             *  Constant: '<S1599>/Calib'
             *  Constant: '<S1653>/Calib'
             *  Math: '<S1649>/MathFunction'
             *  Product: '<S1647>/Product'
             *  Product: '<S1647>/Product1'
             *  Sum: '<S1647>/Subtraction'
             *
             * About '<S1649>/MathFunction':
             *  Operator: exp
             */
            VeTPCR_T_EngTmpTgt_Toe = ((KeTPCR_T_PerWpCond_EngTempFin -
                TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d) * expf(rtb_Switch1_l4
                * KeTPCR_cmp_EngTmpDecad_rate)) +
                TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d;

            /* Switch: '<S1647>/Switch' incorporates:
             *  Constant: '<S1599>/Calib'
             *  Constant: '<S1652>/Calib'
             *  Logic: '<S1647>/Logical7'
             *  RelationalOperator: '<S1647>/Comparison'
             */
            if ((TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d >=
                    KeTPCR_T_PerWpCond_EngTempFin) &&
                    (KeTPCR_b_EnblAmbChk_ForEngTgt))
            {
                /* Switch: '<S1647>/Switch' */
                VeTPCR_T_EngTmpTgt_ToeAftrAmbChk = KeTPCR_T_PerWpCond_EngTempFin;
            }
            else
            {
                /* Switch: '<S1647>/Switch' */
                VeTPCR_T_EngTmpTgt_ToeAftrAmbChk = VeTPCR_T_EngTmpTgt_Toe;
            }

            /* End of Switch: '<S1647>/Switch' */

            /* Switch: '<S1647>/Switch1' incorporates:
             *  Constant: '<S1651>/Calib'
             */
            if (KeTPCR_b_DsblEngCond_PerWup)
            {
                /* Switch: '<S1647>/Switch1' incorporates:
                 *  Constant: '<S1650>/Calib'
                 */
                rtb_Switch1_ko = KeTPCR_T_DsblEngCond_EngTmpTgt;
            }
            else
            {
                /* Switch: '<S1647>/Switch1' */
                rtb_Switch1_ko = VeTPCR_T_EngTmpTgt_ToeAftrAmbChk;
            }

            /* End of Switch: '<S1647>/Switch1' */

            /* RelationalOperator: '<S1607>/Comparison7' incorporates:
             *  Constant: '<S1599>/Calib'
             */
            rtb_UnitDelay_jk = (rtb_Switch1_ko < KeTPCR_T_PerWpCond_EngTempFin);

            /* RelationalOperator: '<S1607>/Comparison1' incorporates:
             *  Constant: '<S1598>/Calib'
             */
            rtb_Switch2_nq = (rtb_Switch1_ml1 < KeTPCR_T_PerWpCond_BatTempFin);

            /* Logic: '<S1611>/Logical1' incorporates:
             *  Logic: '<S1610>/Logical3'
             *  Logic: '<S1611>/Logical2'
             *  Switch: '<S1610>/Switch'
             */
            rtb_RelationalOperator1_dfl = ((VeTPCR_b_EngCoolantTemp_FA) ||
                (!VeTPCR_b_ECT_Sgnl_Rcvd));

            /* Switch: '<S1610>/Switch' incorporates:
             *  Constant: '<S1694>/Calib'
             *  Logic: '<S1611>/Logical1'
             *  Logic: '<S1611>/Logical3'
             */
            rtb_Switch1_mw = (rtb_RelationalOperator1_dfl &&
                              (KeTPCR_b_EnblECHTIS_AtPerWup));

            /* Switch: '<S1611>/Switch2' */
            if (rtb_Switch1_mw)
            {
                /* Switch: '<S1611>/Switch2' */
                VeTPCC_T_ECT_ECHTIS_Tmp =
                    TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_h;
            }
            else
            {
                /* Switch: '<S1611>/Switch2' */
                VeTPCC_T_ECT_ECHTIS_Tmp = VeTPCR_T_EngCoolantTemp;
            }

            /* End of Switch: '<S1611>/Switch2' */

            /* RelationalOperator: '<S1607>/Comparison4' */
            rtb_Switch3_c2 = (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lp >
                              rtb_Switch1_ml1);

            /* RelationalOperator: '<S1607>/Comparison5' */
            rtb_Gain_g = (VeTPCC_T_ECT_ECHTIS_Tmp > rtb_Switch1_ko);

            /* Switch: '<S1607>/Switch' incorporates:
             *  Constant: '<S1598>/Calib'
             *  Constant: '<S1599>/Calib'
             *  Constant: '<S1601>/Calib'
             *  Constant: '<S1603>/Calib'
             *  Constant: '<S1645>/Calib'
             *  Logic: '<S1607>/Logical1'
             *  Logic: '<S1607>/Logical2'
             *  Logic: '<S1607>/Logical3'
             *  Logic: '<S1607>/Logical6'
             *  Logic: '<S1607>/Logical7'
             *  RelationalOperator: '<S1607>/Comparison2'
             *  RelationalOperator: '<S1607>/Comparison3'
             *  RelationalOperator: '<S1607>/Comparison6'
             *  RelationalOperator: '<S1607>/Comparison8'
             */
            if (KeTPCR_b_EnblAmbChk_ForBattEngCondSt)
            {
                VeTPCR_b_DoorAjarEnblLtch_Rst_t =
                    (((TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d <
                       KeTPCR_T_PerWpCond_EngTempFin) ||
                      (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d <
                       KeTPCR_T_PerWpCond_BatTempFin)) && ((((rtb_UnitDelay_jk &&
                         rtb_Switch2_nq) ||
                        (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lp <
                         KeTPCR_T_PerWp_Bat_OOO_TmpMin)) ||
                       (VeTPCC_T_ECT_ECHTIS_Tmp < KeTPCR_T_PerWp_Eng_OOO_TmpMin))
                      || (rtb_Switch3_c2 && rtb_Gain_g)));
            }
            else
            {
                VeTPCR_b_DoorAjarEnblLtch_Rst_t = ((((rtb_UnitDelay_jk &&
                    rtb_Switch2_nq) ||
                    (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lp <
                     KeTPCR_T_PerWp_Bat_OOO_TmpMin)) || (VeTPCC_T_ECT_ECHTIS_Tmp
                    < KeTPCR_T_PerWp_Eng_OOO_TmpMin)) || (rtb_Switch3_c2 &&
                    rtb_Gain_g));
            }

            /* End of Switch: '<S1607>/Switch' */

            /* Switch: '<S1644>/Switch1' */
            if (VeTPCR_b_DoorAjarEnblLtch_Rst_t)
            {
                /* Switch: '<S1644>/Switch1' incorporates:
                 *  Constant: '<S1638>/Constant'
                 */
                rtb_Switch1_io = CeTPCR_e_NoneOfEngBatt_Cond;

                /* Outputs for IfAction SubSystem: '<S1606>/None' incorporates:
                 *  ActionPort: '<S1628>/ActionPort'
                 */
                /* If: '<S1606>/If' incorporates:
                 *  Constant: '<S1600>/Calib'
                 *  Constant: '<S1602>/Calib'
                 *  Gain: '<S1635>/Gain'
                 *  Gain: '<S1636>/Gain'
                 *  Merge: '<S1606>/Merge'
                 *  Merge: '<S1606>/Merge1'
                 */
                VeTPCC_T_EngTmpTgt_Toe_0 = KeTPCR_T_PerWp_EngTmpTgt_Dflt;
                VeTPCC_T_BatTmpTgt_Tob_0 = KeTPCR_T_PerWp_BatTmpTgt_Dflt;

                /* End of Outputs for SubSystem: '<S1606>/None' */
            }
            else
            {
                /* Switch: '<S1642>/Switch1' incorporates:
                 *  Logic: '<S1607>/Logical4'
                 */
                if (rtb_UnitDelay_jk || rtb_Gain_g)
                {
                    /* Switch: '<S1644>/Switch1' incorporates:
                     *  Constant: '<S1639>/Constant'
                     *  Switch: '<S1642>/Switch1'
                     */
                    rtb_Switch1_io = CeTPCR_e_BattOnly_Cond;
                }
                else if (rtb_Switch2_nq || rtb_Switch3_c2)
                {
                    /* Switch: '<S1643>/Switch1' incorporates:
                     *  Constant: '<S1640>/Constant'
                     *  Switch: '<S1642>/Switch1'
                     *  Switch: '<S1644>/Switch1'
                     */
                    rtb_Switch1_io = CeTPCR_e_EngOnly_Cond;
                }
                else
                {
                    /* Switch: '<S1644>/Switch1' incorporates:
                     *  Constant: '<S1641>/Constant'
                     *  Switch: '<S1642>/Switch1'
                     *  Switch: '<S1643>/Switch1'
                     */
                    rtb_Switch1_io = CeTPCR_e_Both_Eng_N_Bat_Cond;
                }

                /* End of Switch: '<S1642>/Switch1' */

                /* If: '<S1606>/If' incorporates:
                 *  Constant: '<S1624>/Constant'
                 *  Constant: '<S1625>/Constant'
                 *  Constant: '<S1626>/Constant'
                 *  RelationalOperator: '<S1606>/Comparison2'
                 *  RelationalOperator: '<S1606>/Comparison3'
                 *  RelationalOperator: '<S1606>/Comparison5'
                 */
                if (((uint32)rtb_Switch1_io) == CeTPCR_e_BattOnly_Cond)
                {
                    /* Outputs for IfAction SubSystem: '<S1606>/Bat_Only' incorporates:
                     *  ActionPort: '<S1620>/ActionPort'
                     */
                    /* Merge: '<S1606>/Merge' incorporates:
                     *  Constant: '<S1602>/Calib'
                     *  Gain: '<S1629>/Gain'
                     */
                    VeTPCC_T_EngTmpTgt_Toe_0 = KeTPCR_T_PerWp_EngTmpTgt_Dflt;

                    /* Merge: '<S1606>/Merge1' incorporates:
                     *  Gain: '<S1630>/Gain'
                     */
                    VeTPCC_T_BatTmpTgt_Tob_0 = rtb_Switch1_ml1;

                    /* End of Outputs for SubSystem: '<S1606>/Bat_Only' */
                }
                else if (((uint32)rtb_Switch1_io) == CeTPCR_e_EngOnly_Cond)
                {
                    /* Outputs for IfAction SubSystem: '<S1606>/Eng_Only' incorporates:
                     *  ActionPort: '<S1622>/ActionPort'
                     */
                    /* Merge: '<S1606>/Merge' incorporates:
                     *  Gain: '<S1633>/Gain'
                     */
                    VeTPCC_T_EngTmpTgt_Toe_0 = rtb_Switch1_ko;

                    /* Merge: '<S1606>/Merge1' incorporates:
                     *  Constant: '<S1600>/Calib'
                     *  Gain: '<S1634>/Gain'
                     */
                    VeTPCC_T_BatTmpTgt_Tob_0 = KeTPCR_T_PerWp_BatTmpTgt_Dflt;

                    /* End of Outputs for SubSystem: '<S1606>/Eng_Only' */
                }
                else
                {
                    if (((uint32)rtb_Switch1_io) == CeTPCR_e_Both_Eng_N_Bat_Cond)
                    {
                        /* Outputs for IfAction SubSystem: '<S1606>/Both' incorporates:
                         *  ActionPort: '<S1621>/ActionPort'
                         */
                        /* Merge: '<S1606>/Merge' incorporates:
                         *  Gain: '<S1631>/Gain'
                         */
                        VeTPCC_T_EngTmpTgt_Toe_0 = rtb_Switch1_ko;

                        /* Merge: '<S1606>/Merge1' incorporates:
                         *  Gain: '<S1632>/Gain'
                         */
                        VeTPCC_T_BatTmpTgt_Tob_0 = rtb_Switch1_ml1;

                        /* End of Outputs for SubSystem: '<S1606>/Both' */
                    }
                }
            }

            /* End of Switch: '<S1644>/Switch1' */

            /* Switch: '<S1606>/Switch1' incorporates:
             *  Constant: '<S1627>/Calib'
             *  Switch: '<S1606>/Switch'
             */
            if (KeTPCR_b_TmpTgt_SelRaw)
            {
                /* Switch: '<S1606>/Switch1' */
                VeTPCC_T_BatTmpTgt_Tob = rtb_Switch1_ml1;

                /* Switch: '<S1606>/Switch' */
                VeTPCC_T_EngTmpTgt_Toe = rtb_Switch1_ko;
            }
            else
            {
                /* Switch: '<S1606>/Switch1' */
                VeTPCC_T_BatTmpTgt_Tob = VeTPCC_T_BatTmpTgt_Tob_0;

                /* Switch: '<S1606>/Switch' */
                VeTPCC_T_EngTmpTgt_Toe = VeTPCC_T_EngTmpTgt_Toe_0;
            }

            /* End of Switch: '<S1606>/Switch1' */

            /* Sum: '<S1609>/Subtraction' */
            rtb_Switch1_ml1 = VeTPCC_T_BatTmpTgt_Tob -
                TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lp;

            /* Switch: '<S1609>/Switch1' incorporates:
             *  Constant: '<S1658>/Calib'
             */
            if (KeTPCR_b_DsblEngCond_PerWup)
            {
                /* Switch: '<S1609>/Switch1' incorporates:
                 *  Constant: '<S1660>/Calib'
                 */
                TPCR_ac_B.Switch1_o = KeTPCR_dT_DsblEngCond_EngTmpErr;
            }
            else
            {
                /* Switch: '<S1609>/Switch1' incorporates:
                 *  Sum: '<S1609>/Subtraction1'
                 */
                TPCR_ac_B.Switch1_o = VeTPCC_T_EngTmpTgt_Toe -
                    VeTPCC_T_ECT_ECHTIS_Tmp;
            }

            /* End of Switch: '<S1609>/Switch1' */

            /* Logic: '<S1609>/Logical' incorporates:
             *  Constant: '<S1661>/Calib'
             *  Constant: '<S1662>/Calib'
             *  RelationalOperator: '<S1609>/Comparison1'
             *  RelationalOperator: '<S1609>/Comparison4'
             */
            VeTPCC_b_isStillCondEng_Bat_B4Deb = ((rtb_Switch1_ml1 >
                KeTPCR_dT_PerWpCond_BatTmpErr) || (TPCR_ac_B.Switch1_o >
                KeTPCR_dT_PerWpCond_EngTmpErr));

            /* Outputs for Atomic SubSystem: '<S1657>/CountDownResetEnabled' */
            /* Switch: '<S1664>/Switch1' incorporates:
             *  Constant: '<S1664>/ConstantValue'
             *  Logic: '<S1657>/Logical2'
             *  RelationalOperator: '<S1657>/Comparison4'
             *  RelationalOperator: '<S1664>/GreaterThan'
             *  Switch: '<S1664>/Switch2'
             *  UnitDelay: '<S1657>/UnitDelay'
             *  UnitDelay: '<S1664>/UnitDelay'
             */
            if (VeTPCC_b_isStillCondEng_Bat_B4Deb !=
                    TPCR_ac_DW.UnitDelay_DSTATE_iv)
            {
                /* Switch: '<S1664>/Switch1' incorporates:
                 *  Constant: '<S1657>/ConstantValue'
                 *  Constant: '<S1663>/Calib'
                 *  Product: '<S1657>/Product'
                 */
                rtb_Switch1_ko = KeTPCR_t_isStillCondEngBat_DebTim * 10.0F;
            }
            else if (TPCR_ac_DW.UnitDelay_DSTATE_bz > 0.0F)
            {
                /* Switch: '<S1664>/Switch2' incorporates:
                 *  Constant: '<S1664>/ConstantValue1'
                 *  Sum: '<S1664>/Subtraction'
                 *  Switch: '<S1664>/Switch1'
                 *  UnitDelay: '<S1664>/UnitDelay'
                 */
                rtb_Switch1_ko = TPCR_ac_DW.UnitDelay_DSTATE_bz - 1.0F;
            }
            else
            {
                /* Switch: '<S1664>/Switch1' incorporates:
                 *  Switch: '<S1664>/Switch2'
                 *  UnitDelay: '<S1664>/UnitDelay'
                 */
                rtb_Switch1_ko = TPCR_ac_DW.UnitDelay_DSTATE_bz;
            }

            /* End of Switch: '<S1664>/Switch1' */

            /* RelationalOperator: '<S1664>/GreaterThan1' incorporates:
             *  Constant: '<S1664>/ConstantValue2'
             */
            rtb_UnitDelay_jk = (rtb_Switch1_ko > 0.0F);

            /* Update for UnitDelay: '<S1664>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_bz = rtb_Switch1_ko;

            /* End of Outputs for SubSystem: '<S1657>/CountDownResetEnabled' */

            /* Outputs for Atomic SubSystem: '<S1657>/EdgeFalling' */
            /* Logic: '<S1665>/AND' incorporates:
             *  Logic: '<S1665>/OR1'
             *  UnitDelay: '<S1665>/UnitDelay'
             */
            rtb_Switch2_nq = ((!rtb_UnitDelay_jk) &&
                              (TPCR_ac_DW.UnitDelay_DSTATE_eqn));

            /* Update for UnitDelay: '<S1665>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_eqn = rtb_UnitDelay_jk;

            /* End of Outputs for SubSystem: '<S1657>/EdgeFalling' */

            /* Outputs for Enabled SubSystem: '<S1657>/Subsystem2' incorporates:
             *  EnablePort: '<S1667>/Enable'
             */
            if (rtb_Switch2_nq || ((!KeTPCR_b_Engcnd_DisDebnc_RST) &&
                                   (TPCR_ac_DW.UnitDelay2_DSTATE_a)))
            {
                /* SignalConversion generated from: '<S1667>/Out1' incorporates:
                 *  Constant: '<S1667>/ConstantValue1'
                 */
                TPCR_ac_B.OutportBufferForOut1_b = false;

                /* Gain: '<S1668>/Gain' */
                TPCR_ac_B.Gain_h = VeTPCC_b_isStillCondEng_Bat_B4Deb;
            }

            /* End of Outputs for SubSystem: '<S1657>/Subsystem2' */

            /* Logic: '<S1509>/AND' incorporates:
             *  Constant: '<S1659>/Calib'
             *  Logic: '<S1596>/AND'
             *  Logic: '<S1657>/Logical1'
             *  Switch: '<S1666>/Switch1'
             *  UnitDelay: '<S1529>/UnitDelay'
             *  UnitDelay: '<S1657>/UnitDelay2'
             */
            TPCR_ac_B.AND_b = TPCR_ac_B.Gain_h;

            /* Merge: '<S19>/Merge3' incorporates:
             *  DataTypeConversion: '<S1597>/DataTypeConversion'
             *  Merge: '<S1028>/Merge'
             *  Switch: '<S1644>/Switch1'
             */
            TPCR_ac_B.Merge3_f = rtb_Switch1_io;

            /* Outputs for Atomic SubSystem: '<S1610>/EdgeFalling' */
            /* Logic: '<S1670>/AND' incorporates:
             *  Logic: '<S1670>/OR1'
             *  UnitDelay: '<S1670>/UnitDelay'
             */
            rtb_UnitDelay_jk = ((!TPCR_ac_B.Gain_h) &&
                                (TPCR_ac_DW.UnitDelay_DSTATE_a0));

            /* Update for UnitDelay: '<S1670>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_a0 = TPCR_ac_B.Gain_h;

            /* End of Outputs for SubSystem: '<S1610>/EdgeFalling' */

            /* Outputs for Atomic SubSystem: '<S1610>/EdgeRising2' */
            /* Logic: '<S1672>/AND' incorporates:
             *  Logic: '<S1672>/OR1'
             *  UnitDelay: '<S1672>/UnitDelay'
             */
            rtb_Switch2_nq = !TPCR_ac_DW.UnitDelay_DSTATE_gq;

            /* Update for UnitDelay: '<S1672>/UnitDelay' incorporates:
             *  Constant: '<S1610>/TRUEConstant3'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_gq = true;

            /* End of Outputs for SubSystem: '<S1610>/EdgeRising2' */

            /* Outputs for Atomic SubSystem: '<S1610>/CountDownResetTriggerEnabled' */
            /* Outputs for Atomic SubSystem: '<S1669>/EdgeRising' */
            /* Logic: '<S1692>/OR1' incorporates:
             *  UnitDelay: '<S1692>/UnitDelay'
             */
            rtb_Switch3_c2 = !TPCR_ac_DW.UnitDelay_DSTATE_dt;

            /* Update for UnitDelay: '<S1692>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_dt = rtb_Switch2_nq;

            /* Switch: '<S1669>/Switch1' incorporates:
             *  Constant: '<S1669>/ConstantValue'
             *  Logic: '<S1692>/AND'
             *  RelationalOperator: '<S1669>/GreaterThan'
             *  Switch: '<S1669>/Switch2'
             *  UnitDelay: '<S1669>/UnitDelay'
             */
            if (rtb_Switch2_nq && rtb_Switch3_c2)
            {
                /* Switch: '<S1669>/Switch1' incorporates:
                 *  Constant: '<S1686>/Calib'
                 */
                rtb_Switch1_g1 = KeTPCR_t_WpThrml_BatEngCond_TimOut;
            }
            else if (((sint32)TPCR_ac_DW.UnitDelay_DSTATE_aq) > 0)
            {
                /* Switch: '<S1669>/Switch2' incorporates:
                 *  Constant: '<S1669>/ConstantValue1'
                 *  Sum: '<S1669>/Subtraction'
                 *  Switch: '<S1669>/Switch1'
                 *  UnitDelay: '<S1669>/UnitDelay'
                 */
                rtb_Switch1_g1 = (uint16)((sint32)(((sint32)
                    TPCR_ac_DW.UnitDelay_DSTATE_aq) - 1));
            }
            else
            {
                /* Switch: '<S1669>/Switch1' incorporates:
                 *  Switch: '<S1669>/Switch2'
                 *  UnitDelay: '<S1669>/UnitDelay'
                 */
                rtb_Switch1_g1 = TPCR_ac_DW.UnitDelay_DSTATE_aq;
            }

            /* End of Switch: '<S1669>/Switch1' */
            /* End of Outputs for SubSystem: '<S1669>/EdgeRising' */

            /* Update for UnitDelay: '<S1669>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_aq = rtb_Switch1_g1;

            /* End of Outputs for SubSystem: '<S1610>/CountDownResetTriggerEnabled' */

            /* Switch: '<S1610>/Switch' */
            if (rtb_Switch1_mw)
            {
                /* Switch: '<S1610>/Switch' */
                rtb_Switch1_mw = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_l0;
            }
            else
            {
                /* Switch: '<S1610>/Switch' */
                rtb_Switch1_mw = rtb_RelationalOperator1_dfl;
            }

            /* Outputs for Atomic SubSystem: '<S1610>/TurnOnDelayTime' */
            /* Outputs for Atomic SubSystem: '<S1691>/EdgeRising' */
            /* Logic: '<S1693>/AND' incorporates:
             *  Logic: '<S1693>/OR1'
             *  UnitDelay: '<S1693>/UnitDelay'
             */
            rtb_Switch3_c2 = (rtb_UnitDelay_l3 &&
                              (!TPCR_ac_DW.UnitDelay_DSTATE_fs));

            /* Update for UnitDelay: '<S1693>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_fs = rtb_UnitDelay_l3;

            /* End of Outputs for SubSystem: '<S1691>/EdgeRising' */

            /* Switch: '<S1691>/Switch1' incorporates:
             *  Logic: '<S1691>/OR'
             *  Logic: '<S1691>/OR1'
             */
            if ((!rtb_UnitDelay_l3) || rtb_Switch3_c2)
            {
                /* Switch: '<S1691>/Switch1' incorporates:
                 *  Constant: '<S1691>/ConstantValue1'
                 */
                rtb_Switch1_ko = 0.0F;
            }
            else
            {
                /* Switch: '<S1691>/Switch1' incorporates:
                 *  Constant: '<S1683>/Calib'
                 *  Constant: '<S1684>/Calib'
                 *  MinMax: '<S1691>/Minimum'
                 *  Sum: '<S1691>/Summation'
                 *  UnitDelay: '<S1691>/UnitDelay'
                 */
                rtb_Switch1_ko = fminf(KeTPCR_t_PerWupEnblDbnc,
                                       KeTPCR_t_PerWupCond_dT +
                                       TPCR_ac_DW.UnitDelay_DSTATE_p);
            }

            /* End of Switch: '<S1691>/Switch1' */

            /* Update for UnitDelay: '<S1691>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_p = rtb_Switch1_ko;

            /* End of Outputs for SubSystem: '<S1610>/TurnOnDelayTime' */

            /* Outputs for Atomic SubSystem: '<S1610>/EdgeRising1' */
            /* Logic: '<S1671>/OR1' incorporates:
             *  UnitDelay: '<S1671>/UnitDelay'
             */
            rtb_Switch3_c2 = !TPCR_ac_DW.UnitDelay_DSTATE_gi;

            /* Update for UnitDelay: '<S1671>/UnitDelay' incorporates:
             *  Constant: '<S1610>/TRUEConstant2'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_gi = true;

            /* Outputs for Atomic SubSystem: '<S1610>/TimerRetriggerResetEnabled1' */
            /* Switch: '<S1689>/Switch1' incorporates:
             *  Logic: '<S1671>/AND'
             */
            if (rtb_Switch3_c2)
            {
                /* Switch: '<S1689>/Switch1' incorporates:
                 *  Constant: '<S1685>/Calib'
                 */
                rtb_Switch1_e4x = KeTPCR_t_ThrmlWUp_CondTimeOut;
            }
            else
            {
                /* Switch: '<S1689>/Switch1' incorporates:
                 *  Constant: '<S1683>/Calib'
                 *  Constant: '<S1689>/ConstantValue4'
                 *  MinMax: '<S1689>/Maximum'
                 *  Sum: '<S1689>/Subtraction'
                 *  UnitDelay: '<S1689>/UnitDelay'
                 */
                rtb_Switch1_e4x = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_is -
                                        KeTPCR_t_PerWupCond_dT, 0.0F);
            }

            /* End of Switch: '<S1689>/Switch1' */
            /* End of Outputs for SubSystem: '<S1610>/EdgeRising1' */

            /* Update for UnitDelay: '<S1689>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_is = rtb_Switch1_e4x;

            /* Logic: '<S1610>/Logical11' incorporates:
             *  Constant: '<S1689>/ConstantValue2'
             *  RelationalOperator: '<S1689>/GreaterThan1'
             */
            VeTPCR_b_PerWupCond_TmOut = (rtb_Switch1_e4x <= 0.0F);

            /* End of Outputs for SubSystem: '<S1610>/TimerRetriggerResetEnabled1' */

            /* RelationalOperator: '<S1610>/Comparison13' incorporates:
             *  Constant: '<S1675>/Calib'
             */
            rtb_Switch3_c2 = (VeTPCR_P_ThrmlPwrBdgt <=
                              KeTPCR_P_LowPwrBdgt_BattCond);

            /* Outputs for Atomic SubSystem: '<S1610>/EdgeRising4' */
            /* Logic: '<S1673>/AND' incorporates:
             *  Logic: '<S1673>/OR1'
             *  UnitDelay: '<S1673>/UnitDelay'
             */
            rtb_Gain_g = (rtb_Switch3_c2 && (!TPCR_ac_DW.UnitDelay_DSTATE_mht));

            /* Update for UnitDelay: '<S1673>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_mht = rtb_Switch3_c2;

            /* End of Outputs for SubSystem: '<S1610>/EdgeRising4' */

            /* Outputs for Atomic SubSystem: '<S1610>/TimerRetriggerResetEnabled2' */
            /* Switch: '<S1690>/Switch1' incorporates:
             *  Logic: '<S1610>/Logical16'
             *  Logic: '<S1610>/Logical17'
             */
            if ((!rtb_Switch3_c2) || rtb_Gain_g)
            {
                /* Switch: '<S1690>/Switch1' incorporates:
                 *  Constant: '<S1682>/Calib'
                 *  Constant: '<S1683>/Calib'
                 *  Sum: '<S1610>/Add1'
                 */
                rtb_Switch1_e4x = KeTPCR_t_LoPwrBdgtDbnc +
                    KeTPCR_t_PerWupCond_dT;
            }
            else
            {
                /* Switch: '<S1690>/Switch1' incorporates:
                 *  Constant: '<S1683>/Calib'
                 *  Constant: '<S1690>/ConstantValue4'
                 *  MinMax: '<S1690>/Maximum'
                 *  Sum: '<S1690>/Subtraction'
                 *  Switch: '<S1690>/Switch2'
                 *  UnitDelay: '<S1690>/UnitDelay'
                 */
                rtb_Switch1_e4x = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_ak -
                                        KeTPCR_t_PerWupCond_dT, 0.0F);
            }

            /* End of Switch: '<S1690>/Switch1' */

            /* Update for UnitDelay: '<S1690>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_ak = rtb_Switch1_e4x;

            /* Outputs for Atomic SubSystem: '<S1610>/SignalLatchOn' */
            /* Outputs for Atomic SubSystem: '<S1610>/CountDownResetTriggerEnabled' */
            /* Outputs for Atomic SubSystem: '<S1610>/TurnOnDelayTime' */
            /* Logic: '<S1688>/OR2' incorporates:
             *  Constant: '<S1669>/ConstantValue2'
             *  Constant: '<S1674>/Constant'
             *  Constant: '<S1676>/Calib'
             *  Constant: '<S1677>/Calib'
             *  Constant: '<S1678>/Calib'
             *  Constant: '<S1679>/Calib'
             *  Constant: '<S1680>/Calib'
             *  Constant: '<S1681>/Calib'
             *  Constant: '<S1684>/Calib'
             *  Constant: '<S1690>/ConstantValue2'
             *  Logic: '<S1610>/Logical1'
             *  Logic: '<S1610>/Logical10'
             *  Logic: '<S1610>/Logical12'
             *  Logic: '<S1610>/Logical2'
             *  Logic: '<S1610>/Logical5'
             *  Logic: '<S1610>/Logical7'
             *  Logic: '<S1610>/Logical8'
             *  Logic: '<S1610>/Logical9'
             *  Logic: '<S1691>/AND'
             *  RelationalOperator: '<S1610>/Comparison2'
             *  RelationalOperator: '<S1610>/Comparison3'
             *  RelationalOperator: '<S1610>/Comparison6'
             *  RelationalOperator: '<S1669>/GreaterThan1'
             *  RelationalOperator: '<S1690>/GreaterThan1'
             *  RelationalOperator: '<S1691>/GreaterThan'
             *  Switch: '<S1644>/Switch1'
             *  UnitDelay: '<S1688>/UnitDelay'
             */
            VeTPCC_b_OutTimer_N_ShutDwn_Enb = (((((((rtb_UnitDelay_jk ||
                ((((uint32)rtb_Switch1_io) == CeTPCR_e_NoneOfEngBatt_Cond) &&
                 (((sint32)rtb_Switch1_g1) <= 0))) || (rtb_Switch1_mw &&
                (KeTPCR_b_Enbl_ECTChk_PerWkUpCondShtDwn))) || ((rtb_UnitDelay_l3
                && (rtb_Switch1_ko >= KeTPCR_t_PerWupEnblDbnc)) &&
                (KeTPCR_b_EnblShtDwnPerWupEnblBit))) ||
                ((((VeTPCR_b_PerWupCond_TmOut) && (VeTPCC_T_ECT_ECHTIS_Tmp >=
                KeTPCR_T_ThrmlWkUp_TimeOutECTTmp)) &&
                  (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lp >=
                   KeTPCR_T_ThrmlWkUp_TimeOutCellTmp)) &&
                 (KeTPCR_b_EnblTmOut_ThrmlWkUp))) ||
                ((VeTPCR_b_ThermalFltsPerWkUp) &&
                 (KeTPCR_b_Enbl_Flts_PerWkUpCondShtDwn))) || (rtb_Switch1_e4x <=
                0.0F)) || (TPCR_ac_DW.UnitDelay_DSTATE_nk0));

            /* End of Outputs for SubSystem: '<S1610>/TurnOnDelayTime' */
            /* End of Outputs for SubSystem: '<S1610>/CountDownResetTriggerEnabled' */
            /* End of Outputs for SubSystem: '<S1610>/TimerRetriggerResetEnabled2' */

            /* Update for UnitDelay: '<S1688>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_nk0 = VeTPCC_b_OutTimer_N_ShutDwn_Enb;

            /* End of Outputs for SubSystem: '<S1610>/SignalLatchOn' */

            /* Outputs for Enabled SubSystem: '<S1517>/Subsystem' incorporates:
             *  EnablePort: '<S1605>/Enable'
             */
            if (VeTPCC_b_OutTimer_N_ShutDwn_Enb)
            {
                /* Outputs for Atomic SubSystem: '<S1605>/TurnOnDelayTime' */
                /* Outputs for Atomic SubSystem: '<S1618>/EdgeRising' */
                /* Logic: '<S1619>/AND' incorporates:
                 *  Constant: '<S1008>/Calib'
                 *  Logic: '<S1619>/OR1'
                 *  UnitDelay: '<S1619>/UnitDelay'
                 */
                rtb_Switch1_mw = ((KeTPCR_b_PerWup_RdyForShtDwn) &&
                                  (!TPCR_ac_DW.UnitDelay_DSTATE_hj));

                /* Update for UnitDelay: '<S1619>/UnitDelay' incorporates:
                 *  Constant: '<S1008>/Calib'
                 */
                TPCR_ac_DW.UnitDelay_DSTATE_hj = KeTPCR_b_PerWup_RdyForShtDwn;

                /* End of Outputs for SubSystem: '<S1618>/EdgeRising' */

                /* Switch: '<S1618>/Switch1' incorporates:
                 *  Constant: '<S1008>/Calib'
                 *  Logic: '<S1618>/OR'
                 *  Logic: '<S1618>/OR1'
                 */
                if ((!KeTPCR_b_PerWup_RdyForShtDwn) || rtb_Switch1_mw)
                {
                    /* Switch: '<S1618>/Switch1' incorporates:
                     *  Constant: '<S1618>/ConstantValue1'
                     */
                    rtb_Switch1_ko = 0.0F;
                }
                else
                {
                    /* Switch: '<S1618>/Switch1' incorporates:
                     *  Constant: '<S1013>/Calib'
                     *  Constant: '<S1014>/Calib'
                     *  MinMax: '<S1618>/Minimum'
                     *  Sum: '<S1618>/Summation'
                     *  UnitDelay: '<S1618>/UnitDelay'
                     */
                    rtb_Switch1_ko = fminf(KeTPCR_t_PerWup_delayTime,
                                           KeTPCR_t_PerWup_dT +
                                           TPCR_ac_DW.UnitDelay_DSTATE_nw);
                }

                /* End of Switch: '<S1618>/Switch1' */

                /* Logic: '<S1618>/AND' incorporates:
                 *  Constant: '<S1008>/Calib'
                 *  Constant: '<S1014>/Calib'
                 *  RelationalOperator: '<S1618>/GreaterThan'
                 */
                VeTPCC_b_NrmlPerWup_ShutDwnReq_New =
                    ((KeTPCR_b_PerWup_RdyForShtDwn) && (rtb_Switch1_ko >=
                      KeTPCR_t_PerWup_delayTime));

                /* Update for UnitDelay: '<S1618>/UnitDelay' */
                TPCR_ac_DW.UnitDelay_DSTATE_nw = rtb_Switch1_ko;

                /* End of Outputs for SubSystem: '<S1605>/TurnOnDelayTime' */

                /* Gain: '<S1617>/Gain' */
                TPCR_ac_B.Gain_op = VeTPCC_b_NrmlPerWup_ShutDwnReq_New;

                /* Gain: '<S1614>/Gain' */
                TPCR_ac_B.Gain_g = rtb_Switch1_l4;

                /* Gain: '<S1616>/Gain' incorporates:
                 *  Constant: '<S1612>/Calib'
                 */
                VeTPCC_b_NormalWp_Msg2 = KeTPCR_b_NormalWp_Msg2;

                /* Gain: '<S1615>/Gain' */
                TPCR_ac_B.Gain_nv = VeTPCC_b_NormalWp_Msg2;
            }

            /* End of Outputs for SubSystem: '<S1517>/Subsystem' */

            /* Merge: '<S19>/Merge2' incorporates:
             *  SignalConversion generated from: '<S1517>/NormalWp_Msg2'
             */
            VeTPCC_b_PeriodWup_Msg2 = TPCR_ac_B.Gain_nv;

            /* Merge: '<S19>/Merge' incorporates:
             *  SignalConversion generated from: '<S1517>/ThrmPerWp_BatEngCond_Tmr_New'
             */
            VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD = TPCR_ac_B.Gain_g;

            /* Merge: '<S19>/Merge1' incorporates:
             *  SignalConversion generated from: '<S1517>/Wp_HCP_Timer_RdyForShtDwn'
             */
            VeTPCC_b_PerWup_RdyShtDwn_BD = TPCR_ac_B.Gain_op;

            /* Merge: '<S19>/Merge4' incorporates:
             *  Gain: '<S1604>/Gain'
             *  Merge: '<S1028>/Merge6'
             */
            TPCR_ac_B.Merge4 = rtb_Switch1_ml1;

            /* Merge: '<S1028>/Merge5' incorporates:
             *  Gain: '<S1687>/Gain'
             */
            TPCR_ac_B.Merge5_b = VeTPCC_b_OutTimer_N_ShutDwn_Enb;

            /* Update for UnitDelay: '<S1657>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_iv = VeTPCC_b_isStillCondEng_Bat_B4Deb;

            /* Update for UnitDelay: '<S1657>/UnitDelay2' */
            TPCR_ac_DW.UnitDelay2_DSTATE_a = TPCR_ac_B.OutportBufferForOut1_b;

            /* End of Outputs for SubSystem: '<S1028>/Subsystem6' */
        }
        else if (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d >=
                 KeTPCR_T_HotAmbTh_PerWkup)
        {
            /* Outputs for IfAction SubSystem: '<S1028>/Subsystem1' incorporates:
             *  ActionPort: '<S1516>/ActionPort'
             */
            /* Lookup_n-D: '<S1556>/Vector' incorporates:
             *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
             */
            rtb_Switch1_l4 = look1_iflf_binlcapw
                (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d, ((const float32 *)
                  &(KxTPCR_t_ThrmPerWp_BattEngCond_TimHot[0])), ((const float32 *)
                  &(KtTPCR_t_ThrmPerWp_BattEngCond_TimHot[0])), 7U);

            /* Sum: '<S1557>/Subtraction2' incorporates:
             *  Constant: '<S1535>/Calib'
             *  Constant: '<S1560>/Calib'
             *  Math: '<S1558>/MathFunction'
             *  Product: '<S1557>/Product'
             *  Product: '<S1557>/Product1'
             *  Sum: '<S1557>/Subtraction'
             *
             * About '<S1558>/MathFunction':
             *  Operator: exp
             */
            VeTPCR_T_BatTmpTgt_TobHot =
                TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d -
                ((TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d -
                  KeTPCR_T_PerWpCond_BatTempFinHot) * expf(rtb_Switch1_l4 *
                  KeTPCR_cmp_BatTmpDecad_rateHot));

            /* Switch: '<S1557>/Switch' incorporates:
             *  Constant: '<S1535>/Calib'
             *  Constant: '<S1559>/Calib'
             *  Logic: '<S1557>/Logical7'
             *  RelationalOperator: '<S1557>/Comparison'
             */
            if ((TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d <=
                    KeTPCR_T_PerWpCond_BatTempFinHot) &&
                    (KeTPCR_b_EnblAmbChk_ForBatTgtHot))
            {
                /* Switch: '<S1557>/Switch' */
                VeTPCR_T_BatTmpTgt_AftrAmbChkHotRaw =
                    KeTPCR_T_PerWpCond_BatTempFinHot;
            }
            else
            {
                /* Switch: '<S1557>/Switch' */
                VeTPCR_T_BatTmpTgt_AftrAmbChkHotRaw = VeTPCR_T_BatTmpTgt_TobHot;
            }

            /* End of Switch: '<S1557>/Switch' */

            /* Switch: '<S1557>/Switch1' incorporates:
             *  RelationalOperator: '<S1557>/Comparison1'
             */
            if (VeTPCR_T_BatTmpTgt_AftrAmbChkHotRaw <= VeTPCR_T_CellTmpMaxAllwd)
            {
                /* Switch: '<S1557>/Switch1' */
                VeTPCR_T_BatTmpTgt_AftrAmbChkHot = VeTPCR_T_CellTmpMaxAllwd;
            }
            else
            {
                /* Switch: '<S1557>/Switch1' */
                VeTPCR_T_BatTmpTgt_AftrAmbChkHot =
                    VeTPCR_T_BatTmpTgt_AftrAmbChkHotRaw;
            }

            /* End of Switch: '<S1557>/Switch1' */

            /* Sum: '<S1541>/Subtraction' */
            rtb_Switch1_ml1 = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_du -
                VeTPCR_T_BatTmpTgt_AftrAmbChkHot;

            /* RelationalOperator: '<S1541>/Comparison4' incorporates:
             *  Constant: '<S1563>/Calib'
             */
            VeTPCC_b_isStillCondEng_Bat_B4DebHot = (rtb_Switch1_ml1 >
                KeTPCR_dT_PerWpCond_BatTmpErrHot);

            /* Outputs for Atomic SubSystem: '<S1561>/CountDownResetEnabled' */
            /* Switch: '<S1565>/Switch1' incorporates:
             *  Constant: '<S1565>/ConstantValue'
             *  Logic: '<S1561>/Logical2'
             *  RelationalOperator: '<S1561>/Comparison4'
             *  RelationalOperator: '<S1565>/GreaterThan'
             *  Switch: '<S1565>/Switch2'
             *  UnitDelay: '<S1561>/UnitDelay'
             *  UnitDelay: '<S1565>/UnitDelay'
             */
            if (VeTPCC_b_isStillCondEng_Bat_B4DebHot !=
                    TPCR_ac_DW.UnitDelay_DSTATE_fi)
            {
                /* Switch: '<S1565>/Switch1' incorporates:
                 *  Constant: '<S1561>/ConstantValue'
                 *  Constant: '<S1564>/Calib'
                 *  Product: '<S1561>/Product'
                 */
                rtb_Switch1_ko = KeTPCR_t_isStillCondEngBat_DebTimHot * 10.0F;
            }
            else if (TPCR_ac_DW.UnitDelay_DSTATE_kd > 0.0F)
            {
                /* Switch: '<S1565>/Switch2' incorporates:
                 *  Constant: '<S1565>/ConstantValue1'
                 *  Sum: '<S1565>/Subtraction'
                 *  Switch: '<S1565>/Switch1'
                 *  UnitDelay: '<S1565>/UnitDelay'
                 */
                rtb_Switch1_ko = TPCR_ac_DW.UnitDelay_DSTATE_kd - 1.0F;
            }
            else
            {
                /* Switch: '<S1565>/Switch1' incorporates:
                 *  Switch: '<S1565>/Switch2'
                 *  UnitDelay: '<S1565>/UnitDelay'
                 */
                rtb_Switch1_ko = TPCR_ac_DW.UnitDelay_DSTATE_kd;
            }

            /* End of Switch: '<S1565>/Switch1' */

            /* RelationalOperator: '<S1565>/GreaterThan1' incorporates:
             *  Constant: '<S1565>/ConstantValue2'
             */
            rtb_Switch1_mw = (rtb_Switch1_ko > 0.0F);

            /* Update for UnitDelay: '<S1565>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_kd = rtb_Switch1_ko;

            /* End of Outputs for SubSystem: '<S1561>/CountDownResetEnabled' */

            /* Outputs for Atomic SubSystem: '<S1561>/EdgeFalling' */
            /* Logic: '<S1566>/AND' incorporates:
             *  Logic: '<S1566>/OR1'
             *  UnitDelay: '<S1566>/UnitDelay'
             */
            rtb_UnitDelay_jk = ((!rtb_Switch1_mw) &&
                                (TPCR_ac_DW.UnitDelay_DSTATE_h0));

            /* Update for UnitDelay: '<S1566>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_h0 = rtb_Switch1_mw;

            /* End of Outputs for SubSystem: '<S1561>/EdgeFalling' */

            /* Outputs for Enabled SubSystem: '<S1561>/Subsystem2' incorporates:
             *  EnablePort: '<S1568>/Enable'
             */
            if (rtb_UnitDelay_jk || ((!KeTPCR_b_Engcnd_DisDebnc_RSTHot) &&
                                     (TPCR_ac_DW.UnitDelay2_DSTATE_iu)))
            {
                /* SignalConversion generated from: '<S1568>/Out1' incorporates:
                 *  Constant: '<S1568>/ConstantValue1'
                 */
                TPCR_ac_B.OutportBufferForOut1 = false;

                /* Gain: '<S1569>/Gain' */
                VeTPCR_b_isStillCondEng_BatHot =
                    VeTPCC_b_isStillCondEng_Bat_B4DebHot;
            }

            /* End of Outputs for SubSystem: '<S1561>/Subsystem2' */

            /* Logic: '<S1509>/AND' incorporates:
             *  Constant: '<S1562>/Calib'
             *  Logic: '<S1533>/AND'
             *  Logic: '<S1561>/Logical1'
             *  Switch: '<S1567>/Switch1'
             *  UnitDelay: '<S1529>/UnitDelay'
             *  UnitDelay: '<S1561>/UnitDelay2'
             */
            TPCR_ac_B.AND_b = VeTPCR_b_isStillCondEng_BatHot;

            /* Switch: '<S1554>/Switch1' incorporates:
             *  Constant: '<S1535>/Calib'
             *  Constant: '<S1536>/Calib'
             *  Constant: '<S1555>/Calib'
             *  Logic: '<S1539>/Logical1'
             *  Logic: '<S1539>/Logical2'
             *  RelationalOperator: '<S1539>/Comparison1'
             *  RelationalOperator: '<S1539>/Comparison2'
             *  RelationalOperator: '<S1539>/Comparison4'
             */
            if ((((VeTPCR_T_BatTmpTgt_AftrAmbChkHot >
                    KeTPCR_T_PerWpCond_BatTempFinHot) &&
                    (KeTPCR_b_Enbl_Tgt_TfbChkPerWkupHot)) ||
                    (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_du >
                     KeTPCR_T_PerWp_Bat_OOO_TmpMax)) ||
                    (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_du <
                     VeTPCR_T_BatTmpTgt_AftrAmbChkHot))
            {
                /* Switch: '<S1554>/Switch1' incorporates:
                 *  Constant: '<S1552>/Constant'
                 */
                rtb_Switch1_io = CeTPCR_e_NoneOfEngBatt_Cond;
            }
            else
            {
                /* Switch: '<S1554>/Switch1' incorporates:
                 *  Constant: '<S1553>/Constant'
                 */
                rtb_Switch1_io = CeTPCR_e_BattOnly_Cond;
            }

            /* End of Switch: '<S1554>/Switch1' */

            /* Merge: '<S19>/Merge3' incorporates:
             *  DataTypeConversion: '<S1534>/DataTypeConversion'
             *  Merge: '<S1028>/Merge'
             *  Switch: '<S1554>/Switch1'
             */
            TPCR_ac_B.Merge3_f = rtb_Switch1_io;

            /* Outputs for Atomic SubSystem: '<S1542>/EdgeFalling' */
            /* Logic: '<S1572>/AND' incorporates:
             *  Logic: '<S1572>/OR1'
             *  UnitDelay: '<S1572>/UnitDelay'
             */
            rtb_Switch1_mw = ((!VeTPCR_b_isStillCondEng_BatHot) &&
                              (TPCR_ac_DW.UnitDelay_DSTATE_ld));

            /* Update for UnitDelay: '<S1572>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_ld = VeTPCR_b_isStillCondEng_BatHot;

            /* End of Outputs for SubSystem: '<S1542>/EdgeFalling' */

            /* Outputs for Atomic SubSystem: '<S1542>/EdgeRising2' */
            /* Logic: '<S1574>/AND' incorporates:
             *  Logic: '<S1574>/OR1'
             *  UnitDelay: '<S1574>/UnitDelay'
             */
            rtb_UnitDelay_jk = !TPCR_ac_DW.UnitDelay_DSTATE_kh;

            /* Update for UnitDelay: '<S1574>/UnitDelay' incorporates:
             *  Constant: '<S1542>/TRUEConstant3'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_kh = true;

            /* End of Outputs for SubSystem: '<S1542>/EdgeRising2' */

            /* Outputs for Atomic SubSystem: '<S1542>/CountDownResetTriggerEnabled' */
            /* Outputs for Atomic SubSystem: '<S1570>/EdgeRising' */
            /* Logic: '<S1593>/OR1' incorporates:
             *  UnitDelay: '<S1593>/UnitDelay'
             */
            rtb_Switch2_nq = !TPCR_ac_DW.UnitDelay_DSTATE_ir;

            /* Update for UnitDelay: '<S1593>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_ir = rtb_UnitDelay_jk;

            /* Switch: '<S1570>/Switch1' incorporates:
             *  Constant: '<S1570>/ConstantValue'
             *  Logic: '<S1593>/AND'
             *  RelationalOperator: '<S1570>/GreaterThan'
             *  Switch: '<S1570>/Switch2'
             *  UnitDelay: '<S1570>/UnitDelay'
             */
            if (rtb_UnitDelay_jk && rtb_Switch2_nq)
            {
                /* Switch: '<S1570>/Switch1' incorporates:
                 *  Constant: '<S1587>/Calib'
                 */
                rtb_Switch1_g1 = KeTPCR_t_WpThrml_BatEngCond_TimOutHot;
            }
            else if (((sint32)TPCR_ac_DW.UnitDelay_DSTATE_nk) > 0)
            {
                /* Switch: '<S1570>/Switch2' incorporates:
                 *  Constant: '<S1570>/ConstantValue1'
                 *  Sum: '<S1570>/Subtraction'
                 *  Switch: '<S1570>/Switch1'
                 *  UnitDelay: '<S1570>/UnitDelay'
                 */
                rtb_Switch1_g1 = (uint16)((sint32)(((sint32)
                    TPCR_ac_DW.UnitDelay_DSTATE_nk) - 1));
            }
            else
            {
                /* Switch: '<S1570>/Switch1' incorporates:
                 *  Switch: '<S1570>/Switch2'
                 *  UnitDelay: '<S1570>/UnitDelay'
                 */
                rtb_Switch1_g1 = TPCR_ac_DW.UnitDelay_DSTATE_nk;
            }

            /* End of Switch: '<S1570>/Switch1' */
            /* End of Outputs for SubSystem: '<S1570>/EdgeRising' */

            /* Update for UnitDelay: '<S1570>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_nk = rtb_Switch1_g1;

            /* End of Outputs for SubSystem: '<S1542>/CountDownResetTriggerEnabled' */

            /* Outputs for Atomic SubSystem: '<S1542>/TurnOnDelayTime' */
            /* Outputs for Atomic SubSystem: '<S1592>/EdgeRising' */
            /* Logic: '<S1595>/AND' incorporates:
             *  Logic: '<S1595>/OR1'
             *  UnitDelay: '<S1595>/UnitDelay'
             */
            rtb_Switch2_nq = (rtb_UnitDelay_l3 &&
                              (!TPCR_ac_DW.UnitDelay_DSTATE_cqv));

            /* Update for UnitDelay: '<S1595>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_cqv = rtb_UnitDelay_l3;

            /* End of Outputs for SubSystem: '<S1592>/EdgeRising' */

            /* Switch: '<S1592>/Switch1' incorporates:
             *  Logic: '<S1592>/OR'
             *  Logic: '<S1592>/OR1'
             */
            if ((!rtb_UnitDelay_l3) || rtb_Switch2_nq)
            {
                /* Switch: '<S1592>/Switch1' incorporates:
                 *  Constant: '<S1592>/ConstantValue1'
                 */
                rtb_Switch1_ko = 0.0F;
            }
            else
            {
                /* Switch: '<S1592>/Switch1' incorporates:
                 *  Constant: '<S1584>/Calib'
                 *  Constant: '<S1585>/Calib'
                 *  MinMax: '<S1592>/Minimum'
                 *  Sum: '<S1592>/Summation'
                 *  UnitDelay: '<S1592>/UnitDelay'
                 */
                rtb_Switch1_ko = fminf(KeTPCR_t_PerWupEnblDbnc,
                                       KeTPCR_t_PerWupCond_dT +
                                       TPCR_ac_DW.UnitDelay_DSTATE_a);
            }

            /* End of Switch: '<S1592>/Switch1' */

            /* Update for UnitDelay: '<S1592>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_a = rtb_Switch1_ko;

            /* End of Outputs for SubSystem: '<S1542>/TurnOnDelayTime' */

            /* Outputs for Atomic SubSystem: '<S1542>/EdgeRising1' */
            /* Logic: '<S1573>/OR1' incorporates:
             *  UnitDelay: '<S1573>/UnitDelay'
             */
            rtb_Switch2_nq = !TPCR_ac_DW.UnitDelay_DSTATE_je;

            /* Update for UnitDelay: '<S1573>/UnitDelay' incorporates:
             *  Constant: '<S1542>/TRUEConstant2'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_je = true;

            /* Outputs for Atomic SubSystem: '<S1542>/TimerRetriggerResetEnabled1' */
            /* Switch: '<S1590>/Switch1' incorporates:
             *  Logic: '<S1573>/AND'
             */
            if (rtb_Switch2_nq)
            {
                /* Switch: '<S1590>/Switch1' incorporates:
                 *  Constant: '<S1586>/Calib'
                 */
                rtb_Switch1_e4x = KeTPCR_t_ThrmlWUp_CondTimeOutHot;
            }
            else
            {
                /* Switch: '<S1590>/Switch1' incorporates:
                 *  Constant: '<S1584>/Calib'
                 *  Constant: '<S1590>/ConstantValue4'
                 *  MinMax: '<S1590>/Maximum'
                 *  Sum: '<S1590>/Subtraction'
                 *  UnitDelay: '<S1590>/UnitDelay'
                 */
                rtb_Switch1_e4x = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_b -
                                        KeTPCR_t_PerWupCond_dT, 0.0F);
            }

            /* End of Switch: '<S1590>/Switch1' */
            /* End of Outputs for SubSystem: '<S1542>/EdgeRising1' */

            /* Update for UnitDelay: '<S1590>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_b = rtb_Switch1_e4x;

            /* Logic: '<S1542>/Logical11' incorporates:
             *  Constant: '<S1590>/ConstantValue2'
             *  RelationalOperator: '<S1590>/GreaterThan1'
             */
            VeTPCR_b_PerWupCond_TmOutHot = (rtb_Switch1_e4x <= 0.0F);

            /* End of Outputs for SubSystem: '<S1542>/TimerRetriggerResetEnabled1' */

            /* RelationalOperator: '<S1542>/Comparison3' incorporates:
             *  Constant: '<S1542>/ConstantValue'
             */
            rtb_Switch2_nq = (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_g == 0.0F);

            /* Logic: '<S1542>/Logical9' */
            rtb_Switch3_c2 = !rtb_Switch2_nq;

            /* Outputs for Atomic SubSystem: '<S1542>/CountDownResetTriggerEnabled1' */
            /* Outputs for Atomic SubSystem: '<S1571>/EdgeRising' */
            /* Logic: '<S1594>/OR1' incorporates:
             *  UnitDelay: '<S1594>/UnitDelay'
             */
            rtb_Gain_g = !TPCR_ac_DW.UnitDelay_DSTATE_j3;

            /* Update for UnitDelay: '<S1594>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_j3 = rtb_Switch3_c2;

            /* Switch: '<S1571>/Switch1' incorporates:
             *  Constant: '<S1571>/ConstantValue'
             *  Logic: '<S1571>/AND'
             *  Logic: '<S1594>/AND'
             *  RelationalOperator: '<S1571>/GreaterThan'
             *  Switch: '<S1571>/Switch2'
             *  UnitDelay: '<S1571>/UnitDelay'
             */
            if (rtb_Switch3_c2 && rtb_Gain_g)
            {
                /* Switch: '<S1571>/Switch1' incorporates:
                 *  Constant: '<S1582>/Calib'
                 */
                rtb_Switch1_a = KeTPCR_t_CellOTTmOut_PerWkupHot;
            }
            else if (rtb_Switch2_nq && (((sint32)TPCR_ac_DW.UnitDelay_DSTATE_ea)
                      > 0))
            {
                /* Switch: '<S1571>/Switch2' incorporates:
                 *  Constant: '<S1571>/ConstantValue1'
                 *  Sum: '<S1571>/Subtraction'
                 *  Switch: '<S1571>/Switch1'
                 *  UnitDelay: '<S1571>/UnitDelay'
                 */
                rtb_Switch1_a = (uint16)((sint32)(((sint32)
                    TPCR_ac_DW.UnitDelay_DSTATE_ea) - 1));
            }
            else
            {
                /* Switch: '<S1571>/Switch1' incorporates:
                 *  Switch: '<S1571>/Switch2'
                 *  UnitDelay: '<S1571>/UnitDelay'
                 */
                rtb_Switch1_a = TPCR_ac_DW.UnitDelay_DSTATE_ea;
            }

            /* End of Switch: '<S1571>/Switch1' */
            /* End of Outputs for SubSystem: '<S1571>/EdgeRising' */

            /* Update for UnitDelay: '<S1571>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_ea = rtb_Switch1_a;

            /* End of Outputs for SubSystem: '<S1542>/CountDownResetTriggerEnabled1' */

            /* RelationalOperator: '<S1542>/Comparison13' incorporates:
             *  Constant: '<S1577>/Calib'
             */
            rtb_Switch2_nq = (VeTPCR_P_ThrmlPwrBdgt <=
                              KeTPCR_P_LowPwrBdgt_BattCond);

            /* Outputs for Atomic SubSystem: '<S1542>/EdgeRising4' */
            /* Logic: '<S1575>/AND' incorporates:
             *  Logic: '<S1575>/OR1'
             *  UnitDelay: '<S1575>/UnitDelay'
             */
            rtb_Switch3_c2 = (rtb_Switch2_nq && (!TPCR_ac_DW.UnitDelay_DSTATE_kv));

            /* Update for UnitDelay: '<S1575>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_kv = rtb_Switch2_nq;

            /* End of Outputs for SubSystem: '<S1542>/EdgeRising4' */

            /* Outputs for Atomic SubSystem: '<S1542>/TimerRetriggerResetEnabled2' */
            /* Switch: '<S1591>/Switch1' incorporates:
             *  Logic: '<S1542>/Logical16'
             *  Logic: '<S1542>/Logical17'
             */
            if ((!rtb_Switch2_nq) || rtb_Switch3_c2)
            {
                /* Switch: '<S1591>/Switch1' incorporates:
                 *  Constant: '<S1583>/Calib'
                 *  Constant: '<S1584>/Calib'
                 *  Sum: '<S1542>/Add1'
                 */
                rtb_Switch1_e4x = KeTPCR_t_LoPwrBdgtDbnc +
                    KeTPCR_t_PerWupCond_dT;
            }
            else
            {
                /* Switch: '<S1591>/Switch1' incorporates:
                 *  Constant: '<S1584>/Calib'
                 *  Constant: '<S1591>/ConstantValue4'
                 *  MinMax: '<S1591>/Maximum'
                 *  Sum: '<S1591>/Subtraction'
                 *  Switch: '<S1591>/Switch2'
                 *  UnitDelay: '<S1591>/UnitDelay'
                 */
                rtb_Switch1_e4x = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_l4 -
                                        KeTPCR_t_PerWupCond_dT, 0.0F);
            }

            /* End of Switch: '<S1591>/Switch1' */

            /* Update for UnitDelay: '<S1591>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_l4 = rtb_Switch1_e4x;

            /* Outputs for Atomic SubSystem: '<S1542>/SignalLatchOn' */
            /* Outputs for Atomic SubSystem: '<S1542>/CountDownResetTriggerEnabled' */
            /* Outputs for Atomic SubSystem: '<S1542>/TurnOnDelayTime' */
            /* Outputs for Atomic SubSystem: '<S1542>/CountDownResetTriggerEnabled1' */
            /* Logic: '<S1589>/OR2' incorporates:
             *  Constant: '<S1570>/ConstantValue2'
             *  Constant: '<S1571>/ConstantValue2'
             *  Constant: '<S1576>/Constant'
             *  Constant: '<S1578>/Calib'
             *  Constant: '<S1579>/Calib'
             *  Constant: '<S1580>/Calib'
             *  Constant: '<S1581>/Calib'
             *  Constant: '<S1585>/Calib'
             *  Constant: '<S1591>/ConstantValue2'
             *  Logic: '<S1542>/Logical1'
             *  Logic: '<S1542>/Logical10'
             *  Logic: '<S1542>/Logical12'
             *  Logic: '<S1542>/Logical2'
             *  Logic: '<S1542>/Logical3'
             *  Logic: '<S1542>/Logical4'
             *  Logic: '<S1542>/Logical5'
             *  Logic: '<S1542>/Logical7'
             *  Logic: '<S1542>/Logical8'
             *  Logic: '<S1592>/AND'
             *  RelationalOperator: '<S1542>/Comparison2'
             *  RelationalOperator: '<S1542>/Comparison6'
             *  RelationalOperator: '<S1570>/GreaterThan1'
             *  RelationalOperator: '<S1571>/GreaterThan1'
             *  RelationalOperator: '<S1591>/GreaterThan1'
             *  RelationalOperator: '<S1592>/GreaterThan'
             *  Switch: '<S1554>/Switch1'
             *  UnitDelay: '<S1589>/UnitDelay'
             */
            VeTPCC_b_OutTimer_N_ShutDwn_EnbHot = (((((((rtb_Switch1_mw ||
                ((((uint32)rtb_Switch1_io) == CeTPCR_e_NoneOfEngBatt_Cond) &&
                 (((sint32)rtb_Switch1_g1) <= 0))) || ((rtb_UnitDelay_l3 &&
                (rtb_Switch1_ko >= KeTPCR_t_PerWupEnblDbnc)) &&
                (KeTPCR_b_EnblShtDwnPerWupEnblBitHot))) ||
                ((VeTPCR_b_PerWupCond_TmOutHot) &&
                 (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_du <=
                  KeTPCR_T_ThrmlWkUp_TimeOutCellTmpHot))) || ((((sint32)
                rtb_Switch1_a) <= 0) && (KeTPCR_b_EnblCellOTChk_ShtDwnHot))) ||
                (rtb_RelationalOperator1_dfl &&
                 (KeTPCR_b_Enbl_CoolFlts_PerWkUpCondShtDwn))) ||
                (rtb_Switch1_e4x <= 0.0F)) || (TPCR_ac_DW.UnitDelay_DSTATE_mf));

            /* End of Outputs for SubSystem: '<S1542>/CountDownResetTriggerEnabled1' */
            /* End of Outputs for SubSystem: '<S1542>/TurnOnDelayTime' */
            /* End of Outputs for SubSystem: '<S1542>/CountDownResetTriggerEnabled' */
            /* End of Outputs for SubSystem: '<S1542>/TimerRetriggerResetEnabled2' */

            /* Update for UnitDelay: '<S1589>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_mf = VeTPCC_b_OutTimer_N_ShutDwn_EnbHot;

            /* End of Outputs for SubSystem: '<S1542>/SignalLatchOn' */

            /* Outputs for Enabled SubSystem: '<S1516>/Subsystem' incorporates:
             *  EnablePort: '<S1538>/Enable'
             */
            if (VeTPCC_b_OutTimer_N_ShutDwn_EnbHot)
            {
                /* Outputs for Atomic SubSystem: '<S1538>/TurnOnDelayTime' */
                /* Outputs for Atomic SubSystem: '<S1549>/EdgeRising' */
                /* Logic: '<S1550>/AND' incorporates:
                 *  Constant: '<S1008>/Calib'
                 *  Logic: '<S1550>/OR1'
                 *  UnitDelay: '<S1550>/UnitDelay'
                 */
                rtb_Switch1_mw = ((KeTPCR_b_PerWup_RdyForShtDwn) &&
                                  (!TPCR_ac_DW.UnitDelay_DSTATE_mp));

                /* Update for UnitDelay: '<S1550>/UnitDelay' incorporates:
                 *  Constant: '<S1008>/Calib'
                 */
                TPCR_ac_DW.UnitDelay_DSTATE_mp = KeTPCR_b_PerWup_RdyForShtDwn;

                /* End of Outputs for SubSystem: '<S1549>/EdgeRising' */

                /* Switch: '<S1549>/Switch1' incorporates:
                 *  Constant: '<S1008>/Calib'
                 *  Logic: '<S1549>/OR'
                 *  Logic: '<S1549>/OR1'
                 */
                if ((!KeTPCR_b_PerWup_RdyForShtDwn) || rtb_Switch1_mw)
                {
                    /* Switch: '<S1549>/Switch1' incorporates:
                     *  Constant: '<S1549>/ConstantValue1'
                     */
                    rtb_Switch1_ko = 0.0F;
                }
                else
                {
                    /* Switch: '<S1549>/Switch1' incorporates:
                     *  Constant: '<S1013>/Calib'
                     *  Constant: '<S1014>/Calib'
                     *  MinMax: '<S1549>/Minimum'
                     *  Sum: '<S1549>/Summation'
                     *  UnitDelay: '<S1549>/UnitDelay'
                     */
                    rtb_Switch1_ko = fminf(KeTPCR_t_PerWup_delayTime,
                                           KeTPCR_t_PerWup_dT +
                                           TPCR_ac_DW.UnitDelay_DSTATE_j);
                }

                /* End of Switch: '<S1549>/Switch1' */

                /* Logic: '<S1549>/AND' incorporates:
                 *  Constant: '<S1008>/Calib'
                 *  Constant: '<S1014>/Calib'
                 *  RelationalOperator: '<S1549>/GreaterThan'
                 */
                VeTPCC_b_NrmlPerWup_ShutDwnReq_NewHot =
                    ((KeTPCR_b_PerWup_RdyForShtDwn) && (rtb_Switch1_ko >=
                      KeTPCR_t_PerWup_delayTime));

                /* Update for UnitDelay: '<S1549>/UnitDelay' */
                TPCR_ac_DW.UnitDelay_DSTATE_j = rtb_Switch1_ko;

                /* End of Outputs for SubSystem: '<S1538>/TurnOnDelayTime' */

                /* Gain: '<S1548>/Gain' */
                TPCR_ac_B.Gain_gg = VeTPCC_b_NrmlPerWup_ShutDwnReq_NewHot;

                /* Gain: '<S1545>/Gain' */
                TPCR_ac_B.Gain_n = rtb_Switch1_l4;

                /* Gain: '<S1547>/Gain' incorporates:
                 *  Constant: '<S1543>/Calib'
                 */
                VeTPCC_b_NormalWp_Msg2Hot = KeTPCR_b_NormalWp_Msg2;

                /* Gain: '<S1546>/Gain' */
                TPCR_ac_B.Gain_f = VeTPCC_b_NormalWp_Msg2Hot;
            }

            /* End of Outputs for SubSystem: '<S1516>/Subsystem' */

            /* Merge: '<S19>/Merge2' incorporates:
             *  SignalConversion generated from: '<S1516>/NormalWp_Msg2'
             */
            VeTPCC_b_PeriodWup_Msg2 = TPCR_ac_B.Gain_f;

            /* Merge: '<S19>/Merge' incorporates:
             *  SignalConversion generated from: '<S1516>/ThrmPerWp_BatEngCond_Tmr_New'
             */
            VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD = TPCR_ac_B.Gain_n;

            /* Merge: '<S19>/Merge1' incorporates:
             *  SignalConversion generated from: '<S1516>/Wp_HCP_Timer_RdyForShtDwn'
             */
            VeTPCC_b_PerWup_RdyShtDwn_BD = TPCR_ac_B.Gain_gg;

            /* Merge: '<S19>/Merge4' incorporates:
             *  Gain: '<S1537>/Gain'
             *  Merge: '<S1028>/Merge6'
             */
            TPCR_ac_B.Merge4 = rtb_Switch1_ml1;

            /* Merge: '<S1028>/Merge5' incorporates:
             *  Gain: '<S1588>/Gain'
             */
            TPCR_ac_B.Merge5_b = VeTPCC_b_OutTimer_N_ShutDwn_EnbHot;

            /* Update for UnitDelay: '<S1561>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_fi =
                VeTPCC_b_isStillCondEng_Bat_B4DebHot;

            /* Update for UnitDelay: '<S1561>/UnitDelay2' */
            TPCR_ac_DW.UnitDelay2_DSTATE_iu = TPCR_ac_B.OutportBufferForOut1;

            /* End of Outputs for SubSystem: '<S1028>/Subsystem1' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S1028>/IfActionSubsystem' incorporates:
             *  ActionPort: '<S1511>/ActionPort'
             */
            /* Merge: '<S19>/Merge' incorporates:
             *  Constant: '<S1522>/Calib'
             *  SignalConversion generated from: '<S1511>/Bat_ThrmlCond_HCP_Timer'
             */
            VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD =
                KeTPCR_t_BatThrmlCond_HCP_TimerDflt;

            /* Outputs for Atomic SubSystem: '<S1511>/TurnOnDelayTime' */
            /* Outputs for Atomic SubSystem: '<S1524>/EdgeRising' */
            /* Logic: '<S1525>/AND' incorporates:
             *  Constant: '<S1008>/Calib'
             *  Logic: '<S1525>/OR1'
             *  UnitDelay: '<S1525>/UnitDelay'
             */
            rtb_Switch1_mw = ((KeTPCR_b_PerWup_RdyForShtDwn) &&
                              (!TPCR_ac_DW.UnitDelay_DSTATE_dg));

            /* Update for UnitDelay: '<S1525>/UnitDelay' incorporates:
             *  Constant: '<S1008>/Calib'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_dg = KeTPCR_b_PerWup_RdyForShtDwn;

            /* End of Outputs for SubSystem: '<S1524>/EdgeRising' */

            /* Switch: '<S1524>/Switch1' incorporates:
             *  Constant: '<S1008>/Calib'
             *  Logic: '<S1524>/OR'
             *  Logic: '<S1524>/OR1'
             */
            if ((!KeTPCR_b_PerWup_RdyForShtDwn) || rtb_Switch1_mw)
            {
                /* Switch: '<S1524>/Switch1' incorporates:
                 *  Constant: '<S1524>/ConstantValue1'
                 */
                rtb_Switch1_l4 = 0.0F;
            }
            else
            {
                /* Switch: '<S1524>/Switch1' incorporates:
                 *  Constant: '<S1013>/Calib'
                 *  Constant: '<S1014>/Calib'
                 *  MinMax: '<S1524>/Minimum'
                 *  Sum: '<S1524>/Summation'
                 *  UnitDelay: '<S1524>/UnitDelay'
                 */
                rtb_Switch1_l4 = fminf(KeTPCR_t_PerWup_delayTime,
                                       KeTPCR_t_PerWup_dT +
                                       TPCR_ac_DW.UnitDelay_DSTATE_k);
            }

            /* End of Switch: '<S1524>/Switch1' */

            /* Merge: '<S19>/Merge1' incorporates:
             *  Constant: '<S1008>/Calib'
             *  Constant: '<S1014>/Calib'
             *  Logic: '<S1524>/AND'
             *  RelationalOperator: '<S1524>/GreaterThan'
             */
            VeTPCC_b_PerWup_RdyShtDwn_BD = ((KeTPCR_b_PerWup_RdyForShtDwn) &&
                (rtb_Switch1_l4 >= KeTPCR_t_PerWup_delayTime));

            /* Update for UnitDelay: '<S1524>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_k = rtb_Switch1_l4;

            /* End of Outputs for SubSystem: '<S1511>/TurnOnDelayTime' */

            /* Merge: '<S19>/Merge3' incorporates:
             *  Constant: '<S1520>/Constant'
             *  DataTypeConversion: '<S1519>/DataTypeConversion'
             *  Merge: '<S1028>/Merge'
             */
            TPCR_ac_B.Merge3_f = CeTPCR_e_NoneOfEngBatt_Cond;

            /* Logic: '<S1509>/AND' incorporates:
             *  Constant: '<S1511>/FALSEConstant'
             *  Logic: '<S1518>/AND'
             *  UnitDelay: '<S1529>/UnitDelay'
             */
            TPCR_ac_B.AND_b = false;

            /* Merge: '<S19>/Merge4' incorporates:
             *  Constant: '<S1511>/ConstantValue3'
             *  Gain: '<S1523>/Gain'
             *  Merge: '<S1028>/Merge6'
             */
            TPCR_ac_B.Merge4 = 0.0F;

            /* Merge: '<S19>/Merge2' incorporates:
             *  Constant: '<S1521>/Calib'
             *  SignalConversion generated from: '<S1511>/NormalWp_Msg2'
             */
            VeTPCC_b_PeriodWup_Msg2 = KeTPCR_b_NormalWp_Msg2;

            /* Merge: '<S1028>/Merge5' incorporates:
             *  Constant: '<S1511>/ConstantValue2'
             *  SignalConversion generated from: '<S1511>/OT_N_SD_Enb_Bis'
             */
            TPCR_ac_B.Merge5_b = true;

            /* End of Outputs for SubSystem: '<S1028>/IfActionSubsystem' */
        }

        /* SignalConversion generated from: '<S1028>/PerWpCond_EngTmpErr' */
        TPCR_ac_B.OutportBufferForPerWpCond_Eng_i = TPCR_ac_B.Switch1_o;

        /* Outputs for Atomic SubSystem: '<S1515>/EdgeRising1' */
        /* Logic: '<S1526>/OR1' incorporates:
         *  UnitDelay: '<S1526>/UnitDelay'
         */
        rtb_Switch1_mw = !TPCR_ac_DW.UnitDelay_DSTATE_pa;

        /* Update for UnitDelay: '<S1526>/UnitDelay' incorporates:
         *  Constant: '<S1515>/TRUEConstant4'
         */
        TPCR_ac_DW.UnitDelay_DSTATE_pa = true;

        /* Outputs for Atomic SubSystem: '<S1515>/SignalLatchOnWithReset2' */
        /* Logic: '<S1529>/OR1' incorporates:
         *  Constant: '<S1010>/Calib'
         *  Logic: '<S1526>/AND'
         *  Logic: '<S1529>/OR'
         *  RelationalOperator: '<S1515>/Comparison1'
         *  UnitDelay: '<S1529>/UnitDelay'
         */
        rtb_Switch1_mw = ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_kn ==
                           KeTPCR_dT_PerWup_CellUnderTemp_Min) ||
                          ((!rtb_Switch1_mw) && (TPCR_ac_DW.UnitDelay_DSTATE_k4)));

        /* End of Outputs for SubSystem: '<S1515>/EdgeRising1' */

        /* Update for UnitDelay: '<S1529>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_k4 = rtb_Switch1_mw;

        /* End of Outputs for SubSystem: '<S1515>/SignalLatchOnWithReset2' */

        /* Outputs for Enabled SubSystem: '<S1515>/Subsystem2' incorporates:
         *  EnablePort: '<S1530>/Enable'
         */
        if (rtb_Switch1_mw)
        {
            /* Switch: '<S1530>/Switch' incorporates:
             *  Constant: '<S1001>/Calib'
             *  RelationalOperator: '<S1530>/Comparison3'
             */
            if (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d >
                    KeTPCR_T_PerWup_AmbTempThrsld)
            {
                /* Switch: '<S1530>/Switch' incorporates:
                 *  Constant: '<S1012>/Calib'
                 */
                TPCR_ac_B.Switch_l = KeTPCR_t_BatThrmlCond_HCP_TimerDflt;
            }
            else
            {
                /* Switch: '<S1530>/Switch' incorporates:
                 *  Constant: '<S1011>/Calib'
                 */
                TPCR_ac_B.Switch_l = KeTPCR_t_BatThrmlCond_HCP_Timer;
            }

            /* End of Switch: '<S1530>/Switch' */

            /* Outputs for Atomic SubSystem: '<S1530>/TurnOnDelayTime' */
            /* Outputs for Atomic SubSystem: '<S1531>/EdgeRising' */
            /* Logic: '<S1532>/AND' incorporates:
             *  Constant: '<S1008>/Calib'
             *  Logic: '<S1532>/OR1'
             *  UnitDelay: '<S1532>/UnitDelay'
             */
            rtb_Switch1_mw = ((KeTPCR_b_PerWup_RdyForShtDwn) &&
                              (!TPCR_ac_DW.UnitDelay_DSTATE_b3j));

            /* Update for UnitDelay: '<S1532>/UnitDelay' incorporates:
             *  Constant: '<S1008>/Calib'
             */
            TPCR_ac_DW.UnitDelay_DSTATE_b3j = KeTPCR_b_PerWup_RdyForShtDwn;

            /* End of Outputs for SubSystem: '<S1531>/EdgeRising' */

            /* Switch: '<S1531>/Switch1' incorporates:
             *  Constant: '<S1008>/Calib'
             *  Logic: '<S1531>/OR'
             *  Logic: '<S1531>/OR1'
             */
            if ((!KeTPCR_b_PerWup_RdyForShtDwn) || rtb_Switch1_mw)
            {
                /* Switch: '<S1531>/Switch1' incorporates:
                 *  Constant: '<S1531>/ConstantValue1'
                 */
                rtb_Switch1_l4 = 0.0F;
            }
            else
            {
                /* Switch: '<S1531>/Switch1' incorporates:
                 *  Constant: '<S1013>/Calib'
                 *  Constant: '<S1014>/Calib'
                 *  MinMax: '<S1531>/Minimum'
                 *  Sum: '<S1531>/Summation'
                 *  UnitDelay: '<S1531>/UnitDelay'
                 */
                rtb_Switch1_l4 = fminf(KeTPCR_t_PerWup_delayTime,
                                       KeTPCR_t_PerWup_dT +
                                       TPCR_ac_DW.UnitDelay_DSTATE_c);
            }

            /* End of Switch: '<S1531>/Switch1' */

            /* Logic: '<S1531>/AND' incorporates:
             *  Constant: '<S1008>/Calib'
             *  Constant: '<S1014>/Calib'
             *  RelationalOperator: '<S1531>/GreaterThan'
             */
            TPCR_ac_B.AND_o = ((KeTPCR_b_PerWup_RdyForShtDwn) && (rtb_Switch1_l4
                                >= KeTPCR_t_PerWup_delayTime));

            /* Update for UnitDelay: '<S1531>/UnitDelay' */
            TPCR_ac_DW.UnitDelay_DSTATE_c = rtb_Switch1_l4;

            /* End of Outputs for SubSystem: '<S1530>/TurnOnDelayTime' */
        }

        /* End of Outputs for SubSystem: '<S1515>/Subsystem2' */

        /* Gain: '<S1527>/Gain' */
        VeTPCC_t_NormlPerWup_TimrOld = TPCR_ac_B.Switch_l;

        /* Gain: '<S1528>/Gain' */
        VeTPCC_b_NrmlPerWup_ShutDwnReq_Old = TPCR_ac_B.AND_o;

        /* End of Outputs for SubSystem: '<S19>/Wup_WaitBatCond' */
        break;

      case 5:
        /* Outputs for IfAction SubSystem: '<S19>/WakeUp_PerWupDsbl' incorporates:
         *  ActionPort: '<S1025>/ActionPort'
         */
        /* Merge: '<S19>/Merge' incorporates:
         *  Constant: '<S1012>/Calib'
         *  Gain: '<S1469>/Gain'
         */
        VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD =
            KeTPCR_t_BatThrmlCond_HCP_TimerDflt;

        /* Merge: '<S19>/Merge1' incorporates:
         *  Constant: '<S1467>/Calib'
         *  Gain: '<S1470>/Gain'
         */
        VeTPCC_b_PerWup_RdyShtDwn_BD = KeTPCR_b_RdyForShtDwn_PerWUpDsbl;

        /* Merge: '<S19>/Merge2' incorporates:
         *  Constant: '<S1466>/Calib'
         *  Gain: '<S1471>/Gain'
         */
        VeTPCC_b_PeriodWup_Msg2 = KeTPCR_b_PerWupDsbl_Msg2;

        /* Outputs for Atomic SubSystem: '<S1025>/EdgeRising' */
        /* Logic: '<S1463>/AND' incorporates:
         *  Logic: '<S1463>/OR1'
         *  UnitDelay: '<S1463>/UnitDelay'
         */
        rtb_Switch1_mw = !TPCR_ac_DW.UnitDelay_DSTATE_jhq;

        /* Update for UnitDelay: '<S1463>/UnitDelay' incorporates:
         *  Constant: '<S1025>/TRUEConstant'
         */
        TPCR_ac_DW.UnitDelay_DSTATE_jhq = true;

        /* End of Outputs for SubSystem: '<S1025>/EdgeRising' */

        /* Outputs for Atomic SubSystem: '<S1025>/CountDownResetTriggerEnabled1' */
        /* Outputs for Atomic SubSystem: '<S1462>/EdgeRising' */
        /* Logic: '<S1473>/OR1' incorporates:
         *  UnitDelay: '<S1473>/UnitDelay'
         */
        rtb_UnitDelay_jk = !TPCR_ac_DW.UnitDelay_DSTATE_bxu;

        /* Update for UnitDelay: '<S1473>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_bxu = rtb_Switch1_mw;

        /* Switch: '<S1462>/Switch1' incorporates:
         *  Constant: '<S1462>/ConstantValue'
         *  Logic: '<S1473>/AND'
         *  RelationalOperator: '<S1462>/GreaterThan'
         *  Switch: '<S1462>/Switch2'
         *  UnitDelay: '<S1462>/UnitDelay'
         */
        if (rtb_Switch1_mw && rtb_UnitDelay_jk)
        {
            /* Switch: '<S1462>/Switch1' incorporates:
             *  Constant: '<S1465>/Calib'
             */
            rtb_Switch1_g1 = KeTPCR_Cnt_Wp_ThrmlCond_Dflt;
        }
        else if (((sint32)TPCR_ac_DW.UnitDelay_DSTATE_gc) > 0)
        {
            /* Switch: '<S1462>/Switch2' incorporates:
             *  Constant: '<S1462>/ConstantValue1'
             *  Sum: '<S1462>/Subtraction'
             *  Switch: '<S1462>/Switch1'
             *  UnitDelay: '<S1462>/UnitDelay'
             */
            rtb_Switch1_g1 = (uint16)((sint32)(((sint32)
                TPCR_ac_DW.UnitDelay_DSTATE_gc) - 1));
        }
        else
        {
            /* Switch: '<S1462>/Switch1' incorporates:
             *  Switch: '<S1462>/Switch2'
             *  UnitDelay: '<S1462>/UnitDelay'
             */
            rtb_Switch1_g1 = TPCR_ac_DW.UnitDelay_DSTATE_gc;
        }

        /* End of Switch: '<S1462>/Switch1' */
        /* End of Outputs for SubSystem: '<S1462>/EdgeRising' */

        /* Update for UnitDelay: '<S1462>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_gc = rtb_Switch1_g1;

        /* Gain: '<S1472>/Gain' incorporates:
         *  Constant: '<S1462>/ConstantValue2'
         *  Logic: '<S1025>/Logical2'
         *  RelationalOperator: '<S1462>/GreaterThan1'
         */
        VeTPCC_b_PerWupDsbl_ThrmlCond_Dflt = (((sint32)rtb_Switch1_g1) <= 0);

        /* End of Outputs for SubSystem: '<S1025>/CountDownResetTriggerEnabled1' */

        /* Merge: '<S19>/Merge3' incorporates:
         *  Constant: '<S1464>/Constant'
         *  SignalConversion generated from: '<S1025>/PerWup_BattEngCond_State'
         */
        TPCR_ac_B.Merge3_f = CeTPCR_e_NoneOfEngBatt_Cond;

        /* Merge: '<S19>/Merge4' incorporates:
         *  Constant: '<S1468>/Calib'
         *  SignalConversion generated from: '<S1025>/PerWpCond_BatTmpErr'
         */
        TPCR_ac_B.Merge4 = KeTPCR_dT_PerWkUpBattErr;

        /* End of Outputs for SubSystem: '<S19>/WakeUp_PerWupDsbl' */
        break;

      default:
        /* Outputs for IfAction SubSystem: '<S19>/Else_PerWup' incorporates:
         *  ActionPort: '<S992>/ActionPort'
         */
        /* Merge: '<S19>/Merge' incorporates:
         *  Constant: '<S1012>/Calib'
         *  Gain: '<S1037>/Gain'
         */
        VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD =
            KeTPCR_t_BatThrmlCond_HCP_TimerDflt;

        /* Merge: '<S19>/Merge1' incorporates:
         *  Constant: '<S992>/FALSEConstant1'
         *  Gain: '<S1038>/Gain'
         */
        VeTPCC_b_PerWup_RdyShtDwn_BD = false;

        /* Merge: '<S19>/Merge2' incorporates:
         *  Constant: '<S1035>/Calib'
         *  Gain: '<S1039>/Gain'
         */
        VeTPCC_b_PeriodWup_Msg2 = KeTPCR_b_NoWp_Dflt_Msg2;

        /* Outputs for Atomic SubSystem: '<S992>/EdgeRising' */
        /* Logic: '<S1032>/AND' incorporates:
         *  Logic: '<S1032>/OR1'
         *  UnitDelay: '<S1032>/UnitDelay'
         */
        rtb_Switch1_mw = !TPCR_ac_DW.UnitDelay_DSTATE_cq;

        /* Update for UnitDelay: '<S1032>/UnitDelay' incorporates:
         *  Constant: '<S992>/TRUEConstant'
         */
        TPCR_ac_DW.UnitDelay_DSTATE_cq = true;

        /* End of Outputs for SubSystem: '<S992>/EdgeRising' */

        /* Outputs for Atomic SubSystem: '<S992>/CountDownResetTriggerEnabled1' */
        /* Outputs for Atomic SubSystem: '<S1031>/EdgeRising' */
        /* Logic: '<S1041>/OR1' incorporates:
         *  UnitDelay: '<S1041>/UnitDelay'
         */
        rtb_UnitDelay_jk = !TPCR_ac_DW.UnitDelay_DSTATE_dq;

        /* Update for UnitDelay: '<S1041>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_dq = rtb_Switch1_mw;

        /* Switch: '<S1031>/Switch1' incorporates:
         *  Constant: '<S1031>/ConstantValue'
         *  Logic: '<S1041>/AND'
         *  RelationalOperator: '<S1031>/GreaterThan'
         *  Switch: '<S1031>/Switch2'
         *  UnitDelay: '<S1031>/UnitDelay'
         */
        if (rtb_Switch1_mw && rtb_UnitDelay_jk)
        {
            /* Switch: '<S1031>/Switch1' incorporates:
             *  Constant: '<S1034>/Calib'
             */
            rtb_Switch1_g1 = KeTPCR_Cnt_Wp_ThrmlCond_Dflt;
        }
        else if (((sint32)TPCR_ac_DW.UnitDelay_DSTATE_at) > 0)
        {
            /* Switch: '<S1031>/Switch2' incorporates:
             *  Constant: '<S1031>/ConstantValue1'
             *  Sum: '<S1031>/Subtraction'
             *  Switch: '<S1031>/Switch1'
             *  UnitDelay: '<S1031>/UnitDelay'
             */
            rtb_Switch1_g1 = (uint16)((sint32)(((sint32)
                TPCR_ac_DW.UnitDelay_DSTATE_at) - 1));
        }
        else
        {
            /* Switch: '<S1031>/Switch1' incorporates:
             *  Switch: '<S1031>/Switch2'
             *  UnitDelay: '<S1031>/UnitDelay'
             */
            rtb_Switch1_g1 = TPCR_ac_DW.UnitDelay_DSTATE_at;
        }

        /* End of Switch: '<S1031>/Switch1' */
        /* End of Outputs for SubSystem: '<S1031>/EdgeRising' */

        /* Update for UnitDelay: '<S1031>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_at = rtb_Switch1_g1;

        /* Gain: '<S1040>/Gain' incorporates:
         *  Constant: '<S1031>/ConstantValue2'
         *  Logic: '<S992>/Logical2'
         *  RelationalOperator: '<S1031>/GreaterThan1'
         */
        VeTPCC_b_BatPerWU_ThrmlCond_Dflt = (((sint32)rtb_Switch1_g1) <= 0);

        /* End of Outputs for SubSystem: '<S992>/CountDownResetTriggerEnabled1' */

        /* Merge: '<S19>/Merge3' incorporates:
         *  Constant: '<S1033>/Constant'
         *  SignalConversion generated from: '<S992>/PerWup_BattEngCond_State'
         */
        TPCR_ac_B.Merge3_f = CeTPCR_e_NoneOfEngBatt_Cond;

        /* Merge: '<S19>/Merge4' incorporates:
         *  Constant: '<S1036>/Calib'
         *  SignalConversion generated from: '<S992>/PerWpCond_BatTmpErr'
         */
        TPCR_ac_B.Merge4 = KeTPCR_dT_PerWkUpBattErr;

        /* End of Outputs for SubSystem: '<S19>/Else_PerWup' */
        break;
    }

    /* Logic: '<S1015>/Logical1' */
    VeTPCC_b_RS_WUpNVRAM_Rst = ((((rtb_UnitDelay4_k ||
        (VeTPCR_b_NoWup_FrstPerTimrSet)) || (VeTPCR_b_NoWup_ShipDfltTimr)) ||
        (VeTPCC_b_BatPerWU_ThrmlCond_Dflt)) ||
        (VeTPCC_b_PerWupDsbl_ThrmlCond_Dflt));

    /* Switch: '<S1015>/Switch' incorporates:
     *  DataStoreWrite: '<S1015>/DataStoreWrite'
     */
    if (VeTPCC_b_RS_WUpNVRAM)
    {
        TPCR_ac_DW.NeTPCR_b_RS_CabPrecDeny_Prev = VeTPCC_b_NoWup_RS_DendShrtTimr;
    }
    else
    {
        /* DataStoreWrite: '<S1015>/DataStoreWrite' incorporates:
         *  Switch: '<S1015>/Switch1'
         */
        TPCR_ac_DW.NeTPCR_b_RS_CabPrecDeny_Prev = ((!VeTPCC_b_RS_WUpNVRAM_Rst) &&
            (TPCR_ac_DW.NeTPCR_b_RS_CabPrecDeny_Prev));
    }

    /* End of Switch: '<S1015>/Switch' */

    /* RelationalOperator: '<S1124>/Comparison3' incorporates:
     *  Constant: '<S1310>/Constant'
     */
    rtb_Switch1_mw = (((uint32)Switch_cl) == CeTPCR_e_NoCabPrec_Flts);

    /* Outputs for Atomic SubSystem: '<S1124>/EdgeRising2' */
    /* Logic: '<S1320>/OR1' incorporates:
     *  UnitDelay: '<S1320>/UnitDelay'
     */
    rtb_UnitDelay_jk = !TPCR_ac_DW.UnitDelay_DSTATE_avz;

    /* Update for UnitDelay: '<S1320>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_avz = rtb_Switch1_mw;

    /* End of Outputs for SubSystem: '<S1124>/EdgeRising2' */

    /* RelationalOperator: '<S1124>/Comparison1' incorporates:
     *  Constant: '<S1309>/Constant'
     */
    rtb_Switch2_nq = (((uint32)Switch_cl) == CeTPCR_e_NoCabPrec_HV_BatCrit);

    /* Outputs for Atomic SubSystem: '<S1124>/EdgeRising3' */
    /* Logic: '<S1321>/OR1' incorporates:
     *  UnitDelay: '<S1321>/UnitDelay'
     */
    rtb_Switch3_c2 = !TPCR_ac_DW.UnitDelay_DSTATE_eq;

    /* Update for UnitDelay: '<S1321>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_eq = rtb_Switch2_nq;

    /* End of Outputs for SubSystem: '<S1124>/EdgeRising3' */

    /* RelationalOperator: '<S1124>/Comparison2' incorporates:
     *  Constant: '<S1311>/Constant'
     */
    rtb_Gain_g = (((uint32)Switch_cl) == CeTPCR_e_NoCabPrec_SOC);

    /* Outputs for Atomic SubSystem: '<S1124>/EdgeRising4' */
    /* Logic: '<S1322>/OR1' incorporates:
     *  UnitDelay: '<S1322>/UnitDelay'
     */
    rtb_Switch1_eo = !TPCR_ac_DW.UnitDelay_DSTATE_bw;

    /* Update for UnitDelay: '<S1322>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_bw = rtb_Gain_g;

    /* End of Outputs for SubSystem: '<S1124>/EdgeRising4' */

    /* RelationalOperator: '<S1124>/Comparison9' incorporates:
     *  Constant: '<S1315>/Constant'
     */
    rtb_RelationalOperator1_dfl = (((uint32)Switch_cl) ==
        CeTPCR_e_NoCabPrec_NotPlugged);

    /* Outputs for Atomic SubSystem: '<S1124>/EdgeRising8' */
    /* Logic: '<S1326>/OR1' incorporates:
     *  UnitDelay: '<S1326>/UnitDelay'
     */
    rtb_UnitDelay_l3 = !TPCR_ac_DW.UnitDelay_DSTATE_da;

    /* Update for UnitDelay: '<S1326>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_da = rtb_RelationalOperator1_dfl;

    /* End of Outputs for SubSystem: '<S1124>/EdgeRising8' */

    /* RelationalOperator: '<S1124>/Comparison10' incorporates:
     *  Constant: '<S1316>/Constant'
     */
    rtb_Switch3_o = (((uint32)Switch_cl) == CeTPCR_e_NoCabPrec_SNA);

    /* Outputs for Atomic SubSystem: '<S1124>/EdgeRising9' */
    /* Logic: '<S1327>/OR1' incorporates:
     *  UnitDelay: '<S1327>/UnitDelay'
     */
    rtb_UnitDelay4_k = !TPCR_ac_DW.UnitDelay_DSTATE_kq;

    /* Update for UnitDelay: '<S1327>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_kq = rtb_Switch3_o;

    /* Outputs for Atomic SubSystem: '<S1124>/EdgeRising2' */
    /* Outputs for Atomic SubSystem: '<S1124>/EdgeRising3' */
    /* Outputs for Atomic SubSystem: '<S1124>/EdgeRising4' */
    /* Outputs for Atomic SubSystem: '<S1124>/EdgeRising8' */
    /* Logic: '<S1124>/Logical9' incorporates:
     *  Logic: '<S1320>/AND'
     *  Logic: '<S1321>/AND'
     *  Logic: '<S1322>/AND'
     *  Logic: '<S1326>/AND'
     *  Logic: '<S1327>/AND'
     */
    VeTPCR_b_PrecSt_FailTrig = (((((rtb_Switch1_mw && rtb_UnitDelay_jk) ||
        (rtb_Switch2_nq && rtb_Switch3_c2)) || (rtb_Gain_g && rtb_Switch1_eo)) ||
        (rtb_RelationalOperator1_dfl && rtb_UnitDelay_l3)) || (rtb_Switch3_o &&
        rtb_UnitDelay4_k));

    /* End of Outputs for SubSystem: '<S1124>/EdgeRising8' */
    /* End of Outputs for SubSystem: '<S1124>/EdgeRising4' */
    /* End of Outputs for SubSystem: '<S1124>/EdgeRising3' */
    /* End of Outputs for SubSystem: '<S1124>/EdgeRising2' */
    /* End of Outputs for SubSystem: '<S1124>/EdgeRising9' */

    /* Logic: '<S1124>/Logical5' incorporates:
     *  Constant: '<S1312>/Constant'
     *  Logic: '<S194>/Logical26'
     *  RelationalOperator: '<S1124>/Comparison4'
     */
    rtb_Switch1_mw = ((((uint32)Switch_cl) == CeTPCR_e_CabinPrec_Off) &&
                      (((((((((VeTPCR_b_DoorOpen_CabPrecOffSt) ||
        (VeTPCR_b_HoodOpen_CabPrecOffSt)) || (VeTPCR_b_NoRS_SCWkUp_CabPrecOff)) ||
                            rtb_OR1_ksz) || rtb_NotEqual_p) || Gain_fm) ||
                         (VeTPCR_b_RmtStartReqDrop)) || rtb_RelationalOperator_k)
                       || (VeTPCR_b_V2LActv_SCCRSDsbl)));

    /* Outputs for Atomic SubSystem: '<S1124>/EdgeRising' */
    /* Logic: '<S1318>/AND' incorporates:
     *  Logic: '<S1318>/OR1'
     *  UnitDelay: '<S1318>/UnitDelay'
     */
    VeTPCR_b_DoorOpenTrig = (rtb_Switch1_mw && (!TPCR_ac_DW.UnitDelay_DSTATE_eh));

    /* Update for UnitDelay: '<S1318>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_eh = rtb_Switch1_mw;

    /* End of Outputs for SubSystem: '<S1124>/EdgeRising' */

    /* Outputs for Atomic SubSystem: '<S1124>/EdgeRising7' */
    /* Logic: '<S1325>/AND' incorporates:
     *  Logic: '<S1325>/OR1'
     *  UnitDelay: '<S1325>/UnitDelay'
     */
    rtb_UnitDelay_jk = !TPCR_ac_DW.UnitDelay_DSTATE_dh;

    /* Update for UnitDelay: '<S1325>/UnitDelay' incorporates:
     *  Constant: '<S1124>/TRUEConstant2'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_dh = true;

    /* End of Outputs for SubSystem: '<S1124>/EdgeRising7' */

    /* Outputs for Atomic SubSystem: '<S1124>/EdgeRising1' */
    /* Logic: '<S1319>/AND' incorporates:
     *  Logic: '<S1319>/OR1'
     *  UnitDelay: '<S1319>/UnitDelay'
     */
    rtb_Switch2_nq = ((VeTPCC_b_VhclPlgdIn) && (!TPCR_ac_DW.UnitDelay_DSTATE_j1));

    /* Update for UnitDelay: '<S1319>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_j1 = VeTPCC_b_VhclPlgdIn;

    /* End of Outputs for SubSystem: '<S1124>/EdgeRising1' */

    /* Abs: '<S1124>/Abs' incorporates:
     *  Sum: '<S1124>/Sum1'
     *  UnitDelay: '<S1124>/UnitDelay4'
     */
    rtb_Abs_o = (sint16)(TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx -
                         TPCR_ac_DW.UnitDelay4_DSTATE_l);

    /* Abs: '<S1124>/Abs' */
    if (rtb_Abs_o < 0)
    {
        tmp = -((sint32)rtb_Abs_o);
        if ((-rtb_Abs_o) > 32767)
        {
            tmp = 32767;
        }

        /* Abs: '<S1124>/Abs' */
        rtb_Abs_o = (sint16)tmp;
    }

    /* End of Abs: '<S1124>/Abs' */

    /* RelationalOperator: '<S1124>/Comparison7' incorporates:
     *  Constant: '<S1333>/Calib'
     */
    VeTPCR_b_ChngInDepTm_RstLtch = (rtb_Abs_o >= KeTPCR_t_ChngInDepTmTh);

    /* Outputs for Atomic SubSystem: '<S1124>/EdgeRising6' */
    /* Logic: '<S1324>/OR1' incorporates:
     *  UnitDelay: '<S1324>/UnitDelay'
     */
    rtb_Switch1_mw = !TPCR_ac_DW.UnitDelay_DSTATE_dal;

    /* Update for UnitDelay: '<S1324>/UnitDelay' incorporates:
     *  Constant: '<S1124>/TRUEConstant1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_dal = true;

    /* Outputs for Atomic SubSystem: '<S1124>/TimerRetriggerResetEnabled1' */
    /* Switch: '<S1339>/Switch1' incorporates:
     *  Logic: '<S1324>/AND'
     */
    if (rtb_Switch1_mw)
    {
        /* Switch: '<S1339>/Switch1' incorporates:
         *  Constant: '<S1334>/Calib'
         */
        rtb_Switch1_l4 = KeTPCR_t_DebInit_DepTm;
    }
    else
    {
        /* Switch: '<S1339>/Switch1' incorporates:
         *  Constant: '<S1337>/Calib'
         *  Constant: '<S1339>/ConstantValue4'
         *  MinMax: '<S1339>/Maximum'
         *  Sum: '<S1339>/Subtraction'
         *  UnitDelay: '<S1339>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_o -
                               KeTPCR_t_RS_CabPrec_dT, 0.0F);
    }

    /* End of Switch: '<S1339>/Switch1' */
    /* End of Outputs for SubSystem: '<S1124>/EdgeRising6' */

    /* Update for UnitDelay: '<S1339>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_o = rtb_Switch1_l4;

    /* Logic: '<S1124>/Logical10' incorporates:
     *  Constant: '<S1339>/ConstantValue2'
     *  RelationalOperator: '<S1339>/GreaterThan1'
     */
    VeTPCR_b_DebDepTm_RstLtchCabFail = (rtb_Switch1_l4 <= 0.0F);

    /* End of Outputs for SubSystem: '<S1124>/TimerRetriggerResetEnabled1' */

    /* Outputs for Atomic SubSystem: '<S1124>/EdgeRising5' */
    /* Switch: '<S989>/Switch1' incorporates:
     *  UnitDelay: '<S1323>/UnitDelay'
     */
    rtb_Switch1_mw = TPCR_ac_DW.UnitDelay_DSTATE_k5m;

    /* Update for UnitDelay: '<S1323>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_k5m = VeTPCR_b_SetLongTimerCond;

    /* Logic: '<S1124>/Logical3' incorporates:
     *  Constant: '<S1317>/Constant'
     *  Constant: '<S1329>/Calib'
     *  Constant: '<S1330>/Calib'
     *  Constant: '<S1331>/Calib'
     *  Constant: '<S1336>/Calib'
     *  Logic: '<S1124>/Logical1'
     *  Logic: '<S1124>/Logical6'
     *  Logic: '<S1124>/Logical7'
     *  Logic: '<S1124>/Logical8'
     *  Logic: '<S1323>/AND'
     *  Logic: '<S1323>/OR1'
     *  RelationalOperator: '<S1117>/RelationalOperator'
     *  RelationalOperator: '<S1124>/Comparison11'
     *  RelationalOperator: '<S1124>/Comparison12'
     *  Switch: '<S1778>/Switch1'
     */
    VeTPCR_b_RstLtch_CabPrecFail = ((((rtb_UnitDelay_jk &&
        (KeTPCR_b_EnblWkUpTrig_RstPrecFailLtch)) || ((((((uint32)
        VeTPCR_e_ClimateScheduleOption) == CeCITR_e_PluggedInOnly) &&
        rtb_Switch2_nq) && (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx >=
                            KeTPCR_t_PlugInDepTmChk)) &&
        (KeTPCR_b_EnblPlugIn_RstPrecFailLtch))) ||
        ((VeTPCR_b_ChngInDepTm_RstLtch) && (VeTPCR_b_DebDepTm_RstLtchCabFail))) ||
        (((VeTPCR_b_SetLongTimerCond) && (!rtb_Switch1_mw)) &&
         (KeTPCR_b_EnblLongTmr_RstPrecFailLtch)));

    /* End of Outputs for SubSystem: '<S1124>/EdgeRising5' */

    /* Outputs for Atomic SubSystem: '<S1124>/SignalLatchOnWithReset' */
    /* Logic: '<S1338>/NOT' incorporates:
     *  Switch: '<S1124>/Switch'
     *  Switch: '<S1124>/Switch1'
     */
    rtb_Switch2_nq = !VeTPCR_b_RstLtch_CabPrecFail;

    /* Logic: '<S1338>/OR1' incorporates:
     *  Logic: '<S1124>/Logical2'
     *  Logic: '<S1338>/NOT'
     *  Logic: '<S1338>/OR'
     *  UnitDelay: '<S1338>/UnitDelay'
     */
    VeTPCR_b_CabPrecFailLtch_CondTmr = (((VeTPCR_b_PrecSt_FailTrig) ||
        (VeTPCR_b_DoorOpenTrig)) || (rtb_Switch2_nq &&
        (TPCR_ac_DW.UnitDelay_DSTATE_p3)));

    /* Update for UnitDelay: '<S1338>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_p3 = VeTPCR_b_CabPrecFailLtch_CondTmr;

    /* End of Outputs for SubSystem: '<S1124>/SignalLatchOnWithReset' */

    /* Switch: '<S1124>/Switch' incorporates:
     *  DataStoreWrite: '<S1124>/DataStoreWrite'
     */
    if (VeTPCR_b_CabPrecFailLtch_CondTmr)
    {
        TPCR_ac_DW.NeTPCR_b_HoldCabPrecFailLtch =
            VeTPCR_b_CabPrecFailLtch_CondTmr;
    }
    else
    {
        /* DataStoreWrite: '<S1124>/DataStoreWrite' incorporates:
         *  Switch: '<S1124>/Switch1'
         */
        TPCR_ac_DW.NeTPCR_b_HoldCabPrecFailLtch = (rtb_Switch2_nq &&
            (TPCR_ac_DW.NeTPCR_b_HoldCabPrecFailLtch));
    }

    /* Switch: '<S1124>/Switch2' incorporates:
     *  Constant: '<S1332>/Calib'
     */
    if (KeTPCR_b_Enbl_CabPrecAbortStore)
    {
        /* Switch: '<S1124>/Switch2' incorporates:
         *  DataStoreWrite: '<S1124>/DataStoreWrite'
         */
        VeTPCR_b_CabPrecFailLtch_DfltTmr =
            TPCR_ac_DW.NeTPCR_b_HoldCabPrecFailLtch;
    }
    else
    {
        /* Switch: '<S1124>/Switch2' */
        VeTPCR_b_CabPrecFailLtch_DfltTmr = VeTPCR_b_CabPrecFailLtch_CondTmr;
    }

    /* End of Switch: '<S1124>/Switch2' */

    /* Switch: '<S1328>/Switch1' incorporates:
     *  Constant: '<S1313>/Constant'
     *  Constant: '<S1314>/Constant'
     *  Logic: '<S1124>/Logical4'
     *  RelationalOperator: '<S1124>/Comparison5'
     *  RelationalOperator: '<S1124>/Comparison6'
     *  Switch: '<S1328>/Switch2'
     */
    if (VeTPCR_b_CabPrecFailLtch_DfltTmr)
    {
        /* Switch: '<S1328>/Switch1' incorporates:
         *  Constant: '<S1335>/Calib'
         */
        VeTPCR_t_SchPrecTimer = KeTPCR_t_Dflt_SCTimer;
    }
    else if ((((uint32)Switch_cl) == CeTPCR_e_CabinPrec_Off) || (((uint32)
               Switch_cl) == CeTPCR_e_CabinPrec_Dflt))
    {
        /* Switch: '<S1328>/Switch2' incorporates:
         *  Switch: '<S1328>/Switch1'
         */
        VeTPCR_t_SchPrecTimer = VeTPCR_t_PrecTmr_AftrMrg;
    }
    else
    {
        /* Switch: '<S1328>/Switch1' incorporates:
         *  UnitDelay: '<S1124>/UnitDelay1'
         */
        VeTPCR_t_SchPrecTimer = TPCR_ac_DW.UnitDelay1_DSTATE;
    }

    /* Switch: '<S1109>/Switch1' incorporates:
     *  Switch: '<S1108>/Switch1'
     *  Switch: '<S1110>/Switch1'
     *  Switch: '<S1111>/Switch1'
     *  Switch: '<S1112>/Switch1'
     *  Switch: '<S1113>/Switch1'
     */
    if (VeTPCC_b_NoWup_RS_DendShrtTimr)
    {
        /* Switch: '<S1109>/Switch1' incorporates:
         *  Constant: '<S1101>/Constant'
         */
        VeTPCC_e_ThrmPerWup_State = CeTPCR_e_NoWup_Set_ShortTim_RS_Denied;
    }
    else if (VeTPCR_b_NoWup_FrstPerTimrSet)
    {
        /* Switch: '<S1108>/Switch1' incorporates:
         *  Constant: '<S1102>/Constant'
         *  Switch: '<S1109>/Switch1'
         */
        VeTPCC_e_ThrmPerWup_State = CeTPCR_e_NoWup_FirstSet_ThrmlPerWup_Timer;
    }
    else if (VeTPCR_b_NoWup_ShipDfltTimr)
    {
        /* Switch: '<S1110>/Switch1' incorporates:
         *  Constant: '<S1103>/Constant'
         *  Switch: '<S1108>/Switch1'
         *  Switch: '<S1109>/Switch1'
         */
        VeTPCC_e_ThrmPerWup_State = CeTPCR_e_NoWup_SHIPSet_ThrmlPerWup_DfltTimer;
    }
    else if (VeTPCC_b_WpWaitBatCond_RS_DndDftTimr)
    {
        /* Switch: '<S1111>/Switch1' incorporates:
         *  Constant: '<S1104>/Constant'
         *  Switch: '<S1108>/Switch1'
         *  Switch: '<S1109>/Switch1'
         *  Switch: '<S1110>/Switch1'
         */
        VeTPCC_e_ThrmPerWup_State = CeTPCR_e_Wup_WaitBatCond_ThrmlPerWup_Timer;
    }
    else if (VeTPCC_b_WpWaitBatCond_PerWpTimr)
    {
        /* Switch: '<S1112>/Switch1' incorporates:
         *  Constant: '<S1105>/Constant'
         *  Switch: '<S1108>/Switch1'
         *  Switch: '<S1109>/Switch1'
         *  Switch: '<S1110>/Switch1'
         *  Switch: '<S1111>/Switch1'
         */
        VeTPCC_e_ThrmPerWup_State = CeTPCR_e_WpWaitBatCond_PerWpTimr;
    }
    else if (VeTPCC_b_Wp_PerWupDsbld)
    {
        /* Switch: '<S1113>/Switch1' incorporates:
         *  Constant: '<S1107>/Constant'
         *  Switch: '<S1108>/Switch1'
         *  Switch: '<S1109>/Switch1'
         *  Switch: '<S1110>/Switch1'
         *  Switch: '<S1111>/Switch1'
         *  Switch: '<S1112>/Switch1'
         */
        VeTPCC_e_ThrmPerWup_State = CeTPCR_e_Default_PerWupDsbld;
    }
    else
    {
        /* Switch: '<S1109>/Switch1' incorporates:
         *  Constant: '<S1106>/Constant'
         *  Switch: '<S1108>/Switch1'
         *  Switch: '<S1110>/Switch1'
         *  Switch: '<S1111>/Switch1'
         *  Switch: '<S1112>/Switch1'
         *  Switch: '<S1113>/Switch1'
         */
        VeTPCC_e_ThrmPerWup_State = CeTPCR_e_Default_PerWup;
    }

    /* End of Switch: '<S1109>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S7>/EdgeFalling' */
    /* Switch: '<S989>/Switch1' incorporates:
     *  UnitDelay: '<S22>/UnitDelay'
     */
    rtb_Switch1_mw = TPCR_ac_DW.UnitDelay_DSTATE_fw;

    /* Update for UnitDelay: '<S22>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fw = VeTPCR_b_CabPrecDny_BattCondLtch;

    /* End of Outputs for SubSystem: '<S7>/EdgeFalling' */

    /* Logic: '<S7>/Logical15' */
    VeTPCR_b_RdyForShtDwnRaw_BattCond = ((VeTPCR_b_CabWkUp_LowTemp) ||
        rtb_Switch1_cs);

    /* Outputs for Atomic SubSystem: '<S7>/SignalLatchOnWithReset' */
    /* Outputs for Atomic SubSystem: '<S7>/EdgeFalling' */
    /* Logic: '<S52>/OR1' incorporates:
     *  Logic: '<S22>/AND'
     *  Logic: '<S22>/OR1'
     *  Logic: '<S52>/NOT'
     *  Logic: '<S52>/OR'
     *  UnitDelay: '<S52>/UnitDelay'
     */
    rtb_Switch1_mw = (((!VeTPCR_b_CabPrecDny_BattCondLtch) && rtb_Switch1_mw) ||
                      ((!VeTPCR_b_RdyForShtDwnRaw_BattCond) &&
                       (TPCR_ac_DW.UnitDelay_DSTATE_hlq)));

    /* End of Outputs for SubSystem: '<S7>/EdgeFalling' */

    /* Update for UnitDelay: '<S52>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_hlq = rtb_Switch1_mw;

    /* End of Outputs for SubSystem: '<S7>/SignalLatchOnWithReset' */

    /* Outputs for Atomic SubSystem: '<S7>/TurnOnDelayTime' */
    /* Outputs for Atomic SubSystem: '<S56>/EdgeRising' */
    /* Logic: '<S58>/AND' incorporates:
     *  Logic: '<S58>/OR1'
     *  UnitDelay: '<S58>/UnitDelay'
     */
    rtb_UnitDelay_jk = (rtb_Switch1_mw && (!TPCR_ac_DW.UnitDelay_DSTATE_igy));

    /* Update for UnitDelay: '<S58>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_igy = rtb_Switch1_mw;

    /* End of Outputs for SubSystem: '<S56>/EdgeRising' */

    /* Switch: '<S56>/Switch1' incorporates:
     *  Logic: '<S56>/OR'
     *  Logic: '<S56>/OR1'
     */
    if ((!rtb_Switch1_mw) || rtb_UnitDelay_jk)
    {
        /* Switch: '<S56>/Switch1' incorporates:
         *  Constant: '<S56>/ConstantValue1'
         */
        rtb_Switch1_l4 = 0.0F;
    }
    else
    {
        /* Switch: '<S56>/Switch1' incorporates:
         *  Constant: '<S50>/Calib'
         *  Constant: '<S51>/Calib'
         *  MinMax: '<S56>/Minimum'
         *  Sum: '<S56>/Summation'
         *  UnitDelay: '<S56>/UnitDelay'
         */
        rtb_Switch1_l4 = fminf(KeTPCR_t_ShtDwnDbnc_BattCond, KeTPCR_t_PerWup_dT
                               + TPCR_ac_DW.UnitDelay_DSTATE_k5);
    }

    /* End of Switch: '<S56>/Switch1' */

    /* Logic: '<S56>/AND' incorporates:
     *  Constant: '<S51>/Calib'
     *  RelationalOperator: '<S56>/GreaterThan'
     */
    VeTPCR_b_RdyForShtDwnDbnc_BattCond = (rtb_Switch1_mw && (rtb_Switch1_l4 >=
        KeTPCR_t_ShtDwnDbnc_BattCond));

    /* Update for UnitDelay: '<S56>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_k5 = rtb_Switch1_l4;

    /* End of Outputs for SubSystem: '<S7>/TurnOnDelayTime' */

    /* Outputs for Atomic SubSystem: '<S97>/TimerRetriggerResetTriggerEnabled' */
    /* Outputs for Atomic SubSystem: '<S128>/EdgeRising' */
    /* Logic: '<S129>/OR1' incorporates:
     *  UnitDelay: '<S129>/UnitDelay'
     */
    rtb_Switch1_mw = !TPCR_ac_DW.UnitDelay_DSTATE_b2v;

    /* Update for UnitDelay: '<S129>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_b2v = VeTPCC_b_RS_NoCabPrecond_FltLtch;

    /* Switch: '<S128>/Switch1' incorporates:
     *  Logic: '<S129>/AND'
     *  Switch: '<S128>/Switch2'
     */
    if ((VeTPCC_b_RS_NoCabPrecond_FltLtch) && rtb_Switch1_mw)
    {
        /* Switch: '<S128>/Switch1' incorporates:
         *  Constant: '<S125>/Calib'
         */
        rtb_Switch1_l4 = KeTPCR_t_LtchRSSt_ForETM;
    }
    else if (VeTPCC_b_RS_NoCabPrecond_FltLtch)
    {
        /* Switch: '<S128>/Switch2' incorporates:
         *  Constant: '<S126>/Calib'
         *  Constant: '<S128>/ConstantValue4'
         *  MinMax: '<S128>/Maximum'
         *  Sum: '<S128>/Subtraction'
         *  Switch: '<S128>/Switch1'
         *  UnitDelay: '<S128>/UnitDelay'
         */
        rtb_Switch1_l4 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_po -
                               KeTPCR_t_RS_CabPrec_dT, 0.0F);
    }
    else
    {
        /* Switch: '<S128>/Switch1' incorporates:
         *  Switch: '<S128>/Switch2'
         *  UnitDelay: '<S128>/UnitDelay'
         */
        rtb_Switch1_l4 = TPCR_ac_DW.UnitDelay_DSTATE_po;
    }

    /* End of Switch: '<S128>/Switch1' */
    /* End of Outputs for SubSystem: '<S128>/EdgeRising' */

    /* Update for UnitDelay: '<S128>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_po = rtb_Switch1_l4;

    /* End of Outputs for SubSystem: '<S97>/TimerRetriggerResetTriggerEnabled' */

    /* Outputs for Atomic SubSystem: '<S98>/TimerRetriggerResetTriggerEnabled' */
    /* Outputs for Atomic SubSystem: '<S138>/EdgeRising' */
    /* Logic: '<S143>/OR1' incorporates:
     *  UnitDelay: '<S143>/UnitDelay'
     */
    rtb_Switch1_mw = !TPCR_ac_DW.UnitDelay_DSTATE_kzo;

    /* Update for UnitDelay: '<S143>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_kzo = VeTPCR_b_RS_NoCabPrecond_BattCritLtch;

    /* Switch: '<S138>/Switch1' incorporates:
     *  Logic: '<S143>/AND'
     *  Switch: '<S138>/Switch2'
     */
    if ((VeTPCR_b_RS_NoCabPrecond_BattCritLtch) && rtb_Switch1_mw)
    {
        /* Switch: '<S138>/Switch1' incorporates:
         *  Constant: '<S135>/Calib'
         */
        rtb_Switch1_ml1 = KeTPCR_t_LtchRSSt_ForETM;
    }
    else if (VeTPCR_b_RS_NoCabPrecond_BattCritLtch)
    {
        /* Switch: '<S138>/Switch2' incorporates:
         *  Constant: '<S136>/Calib'
         *  Constant: '<S138>/ConstantValue4'
         *  MinMax: '<S138>/Maximum'
         *  Sum: '<S138>/Subtraction'
         *  Switch: '<S138>/Switch1'
         *  UnitDelay: '<S138>/UnitDelay'
         */
        rtb_Switch1_ml1 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_mz -
                                KeTPCR_t_RS_CabPrec_dT, 0.0F);
    }
    else
    {
        /* Switch: '<S138>/Switch1' incorporates:
         *  Switch: '<S138>/Switch2'
         *  UnitDelay: '<S138>/UnitDelay'
         */
        rtb_Switch1_ml1 = TPCR_ac_DW.UnitDelay_DSTATE_mz;
    }

    /* End of Switch: '<S138>/Switch1' */
    /* End of Outputs for SubSystem: '<S138>/EdgeRising' */

    /* Update for UnitDelay: '<S138>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_mz = rtb_Switch1_ml1;

    /* End of Outputs for SubSystem: '<S98>/TimerRetriggerResetTriggerEnabled' */

    /* Outputs for Atomic SubSystem: '<S100>/TimerRetriggerResetTriggerEnabled' */
    /* Outputs for Atomic SubSystem: '<S164>/EdgeRising' */
    /* Logic: '<S165>/OR1' incorporates:
     *  UnitDelay: '<S165>/UnitDelay'
     */
    rtb_Switch1_mw = !TPCR_ac_DW.UnitDelay_DSTATE_jj;

    /* Update for UnitDelay: '<S165>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_jj = VeTPCC_b_RS_NoCabPrecond_SOCLtch;

    /* Switch: '<S164>/Switch1' incorporates:
     *  Logic: '<S165>/AND'
     *  Switch: '<S164>/Switch2'
     */
    if ((VeTPCC_b_RS_NoCabPrecond_SOCLtch) && rtb_Switch1_mw)
    {
        /* Switch: '<S164>/Switch1' incorporates:
         *  Constant: '<S161>/Calib'
         */
        rtb_Switch1_ko = KeTPCR_t_LtchRSSt_ForETM;
    }
    else if (VeTPCC_b_RS_NoCabPrecond_SOCLtch)
    {
        /* Switch: '<S164>/Switch2' incorporates:
         *  Constant: '<S162>/Calib'
         *  Constant: '<S164>/ConstantValue4'
         *  MinMax: '<S164>/Maximum'
         *  Sum: '<S164>/Subtraction'
         *  Switch: '<S164>/Switch1'
         *  UnitDelay: '<S164>/UnitDelay'
         */
        rtb_Switch1_ko = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_pb -
                               KeTPCR_t_RS_CabPrec_dT, 0.0F);
    }
    else
    {
        /* Switch: '<S164>/Switch1' incorporates:
         *  Switch: '<S164>/Switch2'
         *  UnitDelay: '<S164>/UnitDelay'
         */
        rtb_Switch1_ko = TPCR_ac_DW.UnitDelay_DSTATE_pb;
    }

    /* End of Switch: '<S164>/Switch1' */
    /* End of Outputs for SubSystem: '<S164>/EdgeRising' */

    /* Update for UnitDelay: '<S164>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_pb = rtb_Switch1_ko;

    /* End of Outputs for SubSystem: '<S100>/TimerRetriggerResetTriggerEnabled' */

    /* Outputs for Atomic SubSystem: '<S101>/TimerRetriggerResetTriggerEnabled' */
    /* Outputs for Atomic SubSystem: '<S174>/EdgeRising' */
    /* Logic: '<S175>/OR1' incorporates:
     *  UnitDelay: '<S175>/UnitDelay'
     */
    rtb_Switch1_mw = !TPCR_ac_DW.UnitDelay_DSTATE_iz5;

    /* Update for UnitDelay: '<S175>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_iz5 = VeTPCC_b_RS_NoCabPrecond_NoPlugLtch;

    /* Switch: '<S174>/Switch1' incorporates:
     *  Logic: '<S175>/AND'
     *  Switch: '<S174>/Switch2'
     */
    if ((VeTPCC_b_RS_NoCabPrecond_NoPlugLtch) && rtb_Switch1_mw)
    {
        /* Switch: '<S174>/Switch1' incorporates:
         *  Constant: '<S171>/Calib'
         */
        rtb_Switch1_e4x = KeTPCR_t_LtchRSSt_ForETM;
    }
    else if (VeTPCC_b_RS_NoCabPrecond_NoPlugLtch)
    {
        /* Switch: '<S174>/Switch2' incorporates:
         *  Constant: '<S172>/Calib'
         *  Constant: '<S174>/ConstantValue4'
         *  MinMax: '<S174>/Maximum'
         *  Sum: '<S174>/Subtraction'
         *  Switch: '<S174>/Switch1'
         *  UnitDelay: '<S174>/UnitDelay'
         */
        rtb_Switch1_e4x = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_ji -
                                KeTPCR_t_RS_CabPrec_dT, 0.0F);
    }
    else
    {
        /* Switch: '<S174>/Switch1' incorporates:
         *  Switch: '<S174>/Switch2'
         *  UnitDelay: '<S174>/UnitDelay'
         */
        rtb_Switch1_e4x = TPCR_ac_DW.UnitDelay_DSTATE_ji;
    }

    /* End of Switch: '<S174>/Switch1' */
    /* End of Outputs for SubSystem: '<S174>/EdgeRising' */

    /* Update for UnitDelay: '<S174>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ji = rtb_Switch1_e4x;

    /* End of Outputs for SubSystem: '<S101>/TimerRetriggerResetTriggerEnabled' */

    /* Outputs for Atomic SubSystem: '<S104>/TimerRetriggerResetTriggerEnabled' */
    /* Outputs for Atomic SubSystem: '<S195>/EdgeRising' */
    /* Logic: '<S270>/OR1' incorporates:
     *  UnitDelay: '<S270>/UnitDelay'
     */
    rtb_Switch1_mw = !TPCR_ac_DW.UnitDelay_DSTATE_cz;

    /* Update for UnitDelay: '<S270>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_cz = VeTPCR_b_RS_NoCabPrecond_CabPrecOffLtch;

    /* Switch: '<S195>/Switch1' incorporates:
     *  Logic: '<S270>/AND'
     *  Switch: '<S195>/Switch2'
     */
    if ((VeTPCR_b_RS_NoCabPrecond_CabPrecOffLtch) && rtb_Switch1_mw)
    {
        /* Switch: '<S195>/Switch1' incorporates:
         *  Constant: '<S191>/Calib'
         */
        rtb_Switch1_jb = KeTPCR_t_LtchRSSt_ForETM_PrecOff;
    }
    else if (VeTPCR_b_RS_NoCabPrecond_CabPrecOffLtch)
    {
        /* Switch: '<S195>/Switch2' incorporates:
         *  Constant: '<S192>/Calib'
         *  Constant: '<S195>/ConstantValue4'
         *  MinMax: '<S195>/Maximum'
         *  Sum: '<S195>/Subtraction'
         *  Switch: '<S195>/Switch1'
         *  UnitDelay: '<S195>/UnitDelay'
         */
        rtb_Switch1_jb = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_pnm -
                               KeTPCR_t_RS_CabPrec_dT, 0.0F);
    }
    else
    {
        /* Switch: '<S195>/Switch1' incorporates:
         *  Switch: '<S195>/Switch2'
         *  UnitDelay: '<S195>/UnitDelay'
         */
        rtb_Switch1_jb = TPCR_ac_DW.UnitDelay_DSTATE_pnm;
    }

    /* End of Switch: '<S195>/Switch1' */
    /* End of Outputs for SubSystem: '<S195>/EdgeRising' */

    /* Update for UnitDelay: '<S195>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_pnm = rtb_Switch1_jb;

    /* End of Outputs for SubSystem: '<S104>/TimerRetriggerResetTriggerEnabled' */

    /* Outputs for Atomic SubSystem: '<S241>/EdgeRising2' */
    /* Switch: '<S988>/Switch1' incorporates:
     *  UnitDelay: '<S254>/UnitDelay'
     */
    rtb_Switch1_cs = TPCR_ac_DW.UnitDelay_DSTATE_os;

    /* Update for UnitDelay: '<S254>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_os = VeTPCR_b_DepTimeZeroLtch;

    /* Outputs for Atomic SubSystem: '<S241>/TimerRetriggerResetEnabled3' */
    /* Switch: '<S269>/Switch1' incorporates:
     *  Logic: '<S241>/Logical18'
     *  Logic: '<S254>/AND'
     *  Logic: '<S254>/OR1'
     *  Switch: '<S269>/Switch2'
     */
    if ((VeTPCR_b_SetLongTimerCond_tmp || ((VeTPCR_b_DepTimeZeroLtch) &&
            (!rtb_Switch1_cs))) || rtb_Comparison1_pa)
    {
        /* Switch: '<S269>/Switch1' incorporates:
         *  Constant: '<S262>/Calib'
         *  Constant: '<S264>/Calib'
         *  Sum: '<S241>/Add1'
         */
        rtb_Switch1_kc2 = KeTPCR_t_PrecOffTm_AfterSC_RstLtch +
            KeTPCR_t_RS_CabPrec_dT;
    }
    else if (VeTPCR_b_DepTimeZeroLtch)
    {
        /* Switch: '<S269>/Switch2' incorporates:
         *  Constant: '<S264>/Calib'
         *  Constant: '<S269>/ConstantValue4'
         *  MinMax: '<S269>/Maximum'
         *  Sum: '<S269>/Subtraction'
         *  Switch: '<S269>/Switch1'
         *  UnitDelay: '<S269>/UnitDelay'
         */
        rtb_Switch1_kc2 = fmaxf(TPCR_ac_DW.UnitDelay_DSTATE_dp -
                                KeTPCR_t_RS_CabPrec_dT, 0.0F);
    }
    else
    {
        /* Switch: '<S269>/Switch1' incorporates:
         *  Switch: '<S269>/Switch2'
         *  UnitDelay: '<S269>/UnitDelay'
         */
        rtb_Switch1_kc2 = TPCR_ac_DW.UnitDelay_DSTATE_dp;
    }

    /* End of Switch: '<S269>/Switch1' */
    /* End of Outputs for SubSystem: '<S241>/EdgeRising2' */

    /* Update for UnitDelay: '<S269>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_dp = rtb_Switch1_kc2;

    /* End of Outputs for SubSystem: '<S241>/TimerRetriggerResetEnabled3' */

    /* Logic: '<S66>/Logical3' incorporates:
     *  Constant: '<S274>/Constant'
     *  Constant: '<S275>/Calib'
     *  Constant: '<S276>/Calib'
     *  Logic: '<S66>/Logical1'
     *  RelationalOperator: '<S66>/Comparison5'
     */
    VeTPCR_b_RmtStrtAbort_StrtVhclRq_BD = ((((((uint32)Switch_cl) ==
        CeTPCR_e_NoCabPrec_HV_BatCrit) && (VeTPCR_b_RmtVehStartReq)) &&
        (rtb_VariantMerge_For_Variant__2 || (KeTPCR_b_Enbl_SCWkup_BattCrit))) &&
        (KeTPCR_b_EnblMsg3_RSBattCrit));

    /* Switch: '<S338>/Switch' incorporates:
     *  Constant: '<S347>/Calib'
     */
    if (KeTPCR_b_SelOldHtrFlts)
    {
        /* Switch: '<S338>/Switch' */
        rtb_Switch_a5 = VeTPCC_b_HtrStsFlty_RawPrst;
    }

    /* End of Switch: '<S338>/Switch' */

    /* Switch: '<S340>/Switch' incorporates:
     *  Constant: '<S399>/Calib'
     */
    if (KeTPCR_b_SelOldCompFlts)
    {
        /* Switch: '<S340>/Switch' */
        rtb_Switch_e = VeTPCC_b_EAC_BatThrmlFlt_Prst;
    }

    /* End of Switch: '<S340>/Switch' */

    /* Logic: '<S68>/Logical1' */
    VeTPCC_b_Htr_EAC_RawFlt = (rtb_Switch_a5 || rtb_Switch_e);

    /* Sum: '<S13>/Sum4' incorporates:
     *  Lookup_n-D: '<S740>/Vector'
     *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
     */
    rtb_Sum4_l = look2_iflf_binlcapw(TPCR_ac_B.TmpSignalConversionAtTmpVM_F_du,
        TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d, ((const float32 *)
        &(KxTPCR_t_ProactiveActvCoolTime[0])), ((const float32 *)
        &(KyTPCR_t_ProactiveActvCoolTime[0])), ((const float32 *)
        &(KtTPCR_t_ProactiveActvCoolTime[0])), TPCR_ac_ConstP.pooled10, 7U);

    /* Outputs for Atomic SubSystem: '<S13>/EdgeRising3' */
    /* Logic: '<S704>/AND' incorporates:
     *  Logic: '<S704>/OR1'
     *  UnitDelay: '<S13>/UnitDelay6'
     *  UnitDelay: '<S704>/UnitDelay'
     */
    rtb_Switch_e = ((TPCR_ac_DW.UnitDelay6_DSTATE) &&
                    (!TPCR_ac_DW.UnitDelay_DSTATE_pu));

    /* Update for UnitDelay: '<S704>/UnitDelay' incorporates:
     *  UnitDelay: '<S13>/UnitDelay6'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_pu = TPCR_ac_DW.UnitDelay6_DSTATE;

    /* End of Outputs for SubSystem: '<S13>/EdgeRising3' */

    /* Outputs for Atomic SubSystem: '<S13>/SignalLatchOnWithReset1' */
    /* Logic: '<S745>/OR1' incorporates:
     *  Constant: '<S735>/Calib'
     *  Logic: '<S13>/Logical15'
     *  Logic: '<S13>/Logical27'
     *  Logic: '<S745>/NOT'
     *  Logic: '<S745>/OR'
     *  RelationalOperator: '<S13>/Comparison15'
     *  RelationalOperator: '<S13>/Comparison2'
     *  Sum: '<S13>/Sum1'
     *  UnitDelay: '<S13>/UnitDelay5'
     *  UnitDelay: '<S745>/UnitDelay'
     */
    rtb_Switch_e = (((((float32)TPCR_ac_B.TmpSignalConversionAtTmpVM_F_b4) <
                      rtb_Sum4_l) && (TPCR_ac_DW.UnitDelay5_DSTATE)) ||
                    (((((((float32)TPCR_ac_B.TmpSignalConversionAtTmpVM_F_b4) -
                         rtb_Sum4_l) < ((float32)KeTPCR_t_ProActvCoolTmDiff)) &&
                       (!rtb_Switch_e)) && (TPCR_ac_DW.UnitDelay5_DSTATE)) &&
                     (TPCR_ac_DW.UnitDelay_DSTATE_pk)));

    /* Update for UnitDelay: '<S745>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_pk = rtb_Switch_e;

    /* End of Outputs for SubSystem: '<S13>/SignalLatchOnWithReset1' */

    /* Lookup_n-D: '<S743>/Vector' incorporates:
     *  Lookup_n-D: '<S741>/Vector'
     *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
     *  Switch: '<S1770>/Switch'
     */
    rtb_Sum4_l = look2_iflf_binlcapw(TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lp,
        VeTPCR_P_PwrBdgtAvail, ((const float32 *)
        &(KxTPCR_t_ProactiveActvHeatTime[0])), ((const float32 *)
        &(KyTPCR_t_ProactiveActvHeatTime[0])), ((const float32 *)
        &(KtTPCR_t_ProactiveActvHeatTime[0])), TPCR_ac_ConstP.pooled10, 7U);

    /* Outputs for Atomic SubSystem: '<S13>/EdgeRising1' */
    /* Logic: '<S702>/AND' incorporates:
     *  Logic: '<S702>/OR1'
     *  UnitDelay: '<S13>/UnitDelay7'
     *  UnitDelay: '<S702>/UnitDelay'
     */
    rtb_Switch_a5 = ((TPCR_ac_DW.UnitDelay7_DSTATE) &&
                     (!TPCR_ac_DW.UnitDelay_DSTATE_mxt));

    /* Update for UnitDelay: '<S702>/UnitDelay' incorporates:
     *  UnitDelay: '<S13>/UnitDelay7'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_mxt = TPCR_ac_DW.UnitDelay7_DSTATE;

    /* End of Outputs for SubSystem: '<S13>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S13>/SignalLatchOnWithReset2' */
    /* Logic: '<S746>/OR1' incorporates:
     *  Constant: '<S736>/Calib'
     *  Logic: '<S13>/Logical30'
     *  Logic: '<S13>/Logical7'
     *  Logic: '<S746>/NOT'
     *  Logic: '<S746>/OR'
     *  RelationalOperator: '<S13>/Comparison16'
     *  RelationalOperator: '<S13>/Comparison3'
     *  Sum: '<S13>/Sum2'
     *  UnitDelay: '<S13>/UnitDelay5'
     *  UnitDelay: '<S746>/UnitDelay'
     */
    rtb_Switch_a5 = (((((float32)TPCR_ac_B.TmpSignalConversionAtTmpVM_F_b4) <
                       rtb_Sum4_l) && (TPCR_ac_DW.UnitDelay5_DSTATE)) ||
                     (((((((float32)TPCR_ac_B.TmpSignalConversionAtTmpVM_F_b4) -
                          rtb_Sum4_l) < ((float32)KeTPCR_t_ProActvHeatTmDiff)) &&
                        (!rtb_Switch_a5)) && (TPCR_ac_DW.UnitDelay5_DSTATE)) &&
                      (TPCR_ac_DW.UnitDelay_DSTATE_pr2)));

    /* Update for UnitDelay: '<S746>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_pr2 = rtb_Switch_a5;

    /* End of Outputs for SubSystem: '<S13>/SignalLatchOnWithReset2' */

    /* Lookup_n-D: '<S743>/Vector' incorporates:
     *  Lookup_n-D: '<S742>/Vector'
     *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
     */
    rtb_Sum4_l = look2_iflf_binlcapw(TPCR_ac_B.TmpSignalConversionAtTmpVM_F_du,
        TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d, ((const float32 *)
        &(KxTPCR_t_ProactivePsvCoolTime[0])), ((const float32 *)
        &(KyTPCR_t_ProactivePsvCoolTime[0])), ((const float32 *)
        &(KtTPCR_t_ProactivePsvCoolTime[0])), TPCR_ac_ConstP.pooled10, 7U);

    /* Outputs for Atomic SubSystem: '<S13>/EdgeRising2' */
    /* Logic: '<S703>/AND' incorporates:
     *  Logic: '<S703>/OR1'
     *  UnitDelay: '<S13>/UnitDelay8'
     *  UnitDelay: '<S703>/UnitDelay'
     */
    rtb_Switch1_mw = ((TPCR_ac_DW.UnitDelay8_DSTATE) &&
                      (!TPCR_ac_DW.UnitDelay_DSTATE_j5));

    /* Update for UnitDelay: '<S703>/UnitDelay' incorporates:
     *  UnitDelay: '<S13>/UnitDelay8'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_j5 = TPCR_ac_DW.UnitDelay8_DSTATE;

    /* End of Outputs for SubSystem: '<S13>/EdgeRising2' */

    /* Outputs for Atomic SubSystem: '<S13>/SignalLatchOnWithReset3' */
    /* Logic: '<S747>/OR1' incorporates:
     *  Constant: '<S737>/Calib'
     *  Logic: '<S13>/Logical28'
     *  Logic: '<S13>/Logical8'
     *  Logic: '<S747>/NOT'
     *  Logic: '<S747>/OR'
     *  RelationalOperator: '<S13>/Comparison17'
     *  RelationalOperator: '<S13>/Comparison4'
     *  Sum: '<S13>/Sum3'
     *  UnitDelay: '<S13>/UnitDelay5'
     *  UnitDelay: '<S747>/UnitDelay'
     */
    rtb_Comparison1_pa = (((((float32)TPCR_ac_B.TmpSignalConversionAtTmpVM_F_b4)
                            < rtb_Sum4_l) && (TPCR_ac_DW.UnitDelay5_DSTATE)) ||
                          (((((((float32)
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_b4) - rtb_Sum4_l) < ((float32)
        KeTPCR_t_ProPsvCoolTmDiff)) && (!rtb_Switch1_mw)) &&
                            (TPCR_ac_DW.UnitDelay5_DSTATE)) &&
                           (TPCR_ac_DW.UnitDelay_DSTATE_d1)));

    /* Update for UnitDelay: '<S747>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_d1 = rtb_Comparison1_pa;

    /* End of Outputs for SubSystem: '<S13>/SignalLatchOnWithReset3' */

    /* Lookup_n-D: '<S743>/Vector' incorporates:
     *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
     */
    rtb_Sum4_l = look2_iflf_binlcapw(TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lp,
        TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_p, ((const float32 *)
        &(KxTPCR_t_ProactivePsvHeatTime[0])), ((const float32 *)
        &(KyTPCR_t_ProactivePsvHeatTime[0])), ((const float32 *)
        &(KtTPCR_t_ProactivePsvHeatTime[0])), TPCR_ac_ConstP.pooled10, 7U);

    /* Outputs for Atomic SubSystem: '<S13>/EdgeRising4' */
    /* Logic: '<S705>/AND' incorporates:
     *  Logic: '<S705>/OR1'
     *  UnitDelay: '<S13>/UnitDelay9'
     *  UnitDelay: '<S705>/UnitDelay'
     */
    rtb_Switch1_mw = ((TPCR_ac_DW.UnitDelay9_DSTATE) &&
                      (!TPCR_ac_DW.UnitDelay_DSTATE_jr));

    /* Update for UnitDelay: '<S705>/UnitDelay' incorporates:
     *  UnitDelay: '<S13>/UnitDelay9'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_jr = TPCR_ac_DW.UnitDelay9_DSTATE;

    /* End of Outputs for SubSystem: '<S13>/EdgeRising4' */

    /* Outputs for Atomic SubSystem: '<S13>/SignalLatchOnWithReset4' */
    /* Logic: '<S748>/OR1' incorporates:
     *  Constant: '<S738>/Calib'
     *  Logic: '<S13>/Logical29'
     *  Logic: '<S13>/Logical9'
     *  Logic: '<S748>/NOT'
     *  Logic: '<S748>/OR'
     *  RelationalOperator: '<S13>/Comparison18'
     *  RelationalOperator: '<S13>/Comparison5'
     *  Sum: '<S13>/Sum4'
     *  UnitDelay: '<S13>/UnitDelay5'
     *  UnitDelay: '<S748>/UnitDelay'
     */
    rtb_UnitDelay_jk = (((((float32)TPCR_ac_B.TmpSignalConversionAtTmpVM_F_b4) <
                          rtb_Sum4_l) && (TPCR_ac_DW.UnitDelay5_DSTATE)) ||
                        (((((((float32)TPCR_ac_B.TmpSignalConversionAtTmpVM_F_b4)
        - rtb_Sum4_l) < ((float32)KeTPCR_t_ProPsvHeatTmDiff)) &&
                           (!rtb_Switch1_mw)) && (TPCR_ac_DW.UnitDelay5_DSTATE))
                         && (TPCR_ac_DW.UnitDelay_DSTATE_ei)));

    /* Update for UnitDelay: '<S748>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ei = rtb_UnitDelay_jk;

    /* End of Outputs for SubSystem: '<S13>/SignalLatchOnWithReset4' */

    /* Switch: '<S720>/Switch1' incorporates:
     *  Logic: '<S13>/Logical3'
     *  Logic: '<S13>/Logical4'
     *  Switch: '<S721>/Switch1'
     */
    if (rtb_Switch_e || rtb_Switch_a5)
    {
        /* Switch: '<S720>/Switch1' incorporates:
         *  Constant: '<S706>/Constant'
         */
        Switch1_d = CeTPCR_e_ActiveProactiveCond;
    }
    else if (rtb_Comparison1_pa || rtb_UnitDelay_jk)
    {
        /* Switch: '<S721>/Switch1' incorporates:
         *  Constant: '<S711>/Constant'
         *  Switch: '<S720>/Switch1'
         */
        Switch1_d = CeTPCR_e_PassiveProativeCond;
    }
    else
    {
        /* Switch: '<S720>/Switch1' incorporates:
         *  Constant: '<S712>/Constant'
         *  Switch: '<S721>/Switch1'
         */
        Switch1_d = CeTPCR_e_NoProactiveCond;
    }

    /* End of Switch: '<S720>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S13>/Hysteresis' */
    /* Switch: '<S718>/Switch1' incorporates:
     *  Constant: '<S727>/Calib'
     *  RelationalOperator: '<S718>/GreaterThan'
     */
    if (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_du >
            KeTPCR_T_ProactiveCoolSPR_Max)
    {
        /* Switch: '<S718>/Switch1' incorporates:
         *  Constant: '<S718>/ConstantValue'
         */
        rtb_Switch2_nq = true;
    }
    else
    {
        /* Switch: '<S718>/Switch1' incorporates:
         *  Constant: '<S728>/Calib'
         *  RelationalOperator: '<S718>/GreaterThan1'
         *  UnitDelay: '<S718>/UnitDelay'
         */
        rtb_Switch2_nq = ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_du >=
                           KeTPCR_T_ProactiveCoolSPR_Min) &&
                          (TPCR_ac_DW.UnitDelay_DSTATE_cc));
    }

    /* End of Switch: '<S718>/Switch1' */

    /* Update for UnitDelay: '<S718>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_cc = rtb_Switch2_nq;

    /* End of Outputs for SubSystem: '<S13>/Hysteresis' */

    /* Outputs for Atomic SubSystem: '<S13>/Hysteresis1' */
    /* Switch: '<S719>/Switch1' incorporates:
     *  Constant: '<S729>/Calib'
     *  RelationalOperator: '<S719>/GreaterThan'
     */
    if (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lp >
            KeTPCR_T_ProactiveHeatSPR_Max)
    {
        /* Switch: '<S719>/Switch1' incorporates:
         *  Constant: '<S719>/ConstantValue'
         */
        rtb_Switch1_mw = true;
    }
    else
    {
        /* Switch: '<S719>/Switch1' incorporates:
         *  Constant: '<S730>/Calib'
         *  RelationalOperator: '<S719>/GreaterThan1'
         *  UnitDelay: '<S719>/UnitDelay'
         */
        rtb_Switch1_mw = ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lp >=
                           KeTPCR_T_ProactiveHeatSPR_Min) &&
                          (TPCR_ac_DW.UnitDelay_DSTATE_d4));
    }

    /* End of Switch: '<S719>/Switch1' */

    /* Update for UnitDelay: '<S719>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_d4 = rtb_Switch1_mw;

    /* End of Outputs for SubSystem: '<S13>/Hysteresis1' */

    /* Logic: '<S13>/Logical22' incorporates:
     *  Logic: '<S13>/Logical12'
     */
    rtb_UnitDelay_l3 = !rtb_Switch2_nq;

    /* Outputs for Atomic SubSystem: '<S13>/SignalLatchOnWithReset' */
    /* Logic: '<S744>/OR1' incorporates:
     *  Logic: '<S13>/Logical12'
     *  Logic: '<S13>/Logical22'
     *  Logic: '<S13>/Logical23'
     *  Logic: '<S13>/Logical25'
     *  Logic: '<S744>/NOT'
     *  Logic: '<S744>/OR'
     *  UnitDelay: '<S13>/UnitDelay1'
     *  UnitDelay: '<S13>/UnitDelay2'
     *  UnitDelay: '<S13>/UnitDelay5'
     *  UnitDelay: '<S744>/UnitDelay'
     */
    rtb_Switch2_nq = ((((TPCR_ac_DW.UnitDelay1_DSTATE_no) ||
                        (TPCR_ac_DW.UnitDelay2_DSTATE_os)) && rtb_UnitDelay_l3) ||
                      ((rtb_UnitDelay_l3 && (TPCR_ac_DW.UnitDelay5_DSTATE)) &&
                       (TPCR_ac_DW.UnitDelay_DSTATE_hf)));

    /* Update for UnitDelay: '<S744>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_hf = rtb_Switch2_nq;

    /* End of Outputs for SubSystem: '<S13>/SignalLatchOnWithReset' */

    /* Outputs for Atomic SubSystem: '<S13>/SignalLatchOnWithReset5' */
    /* Logic: '<S749>/OR1' incorporates:
     *  Logic: '<S13>/Logical20'
     *  Logic: '<S13>/Logical24'
     *  Logic: '<S13>/Logical26'
     *  Logic: '<S13>/Logical32'
     *  Logic: '<S749>/NOT'
     *  Logic: '<S749>/OR'
     *  UnitDelay: '<S13>/UnitDelay3'
     *  UnitDelay: '<S13>/UnitDelay4'
     *  UnitDelay: '<S13>/UnitDelay5'
     *  UnitDelay: '<S749>/UnitDelay'
     */
    rtb_Switch1_mw = ((((TPCR_ac_DW.UnitDelay3_DSTATE_g) ||
                        (TPCR_ac_DW.UnitDelay4_DSTATE_bs)) && rtb_Switch1_mw) ||
                      ((rtb_Switch1_mw && (TPCR_ac_DW.UnitDelay5_DSTATE)) &&
                       (TPCR_ac_DW.UnitDelay_DSTATE_px)));

    /* Update for UnitDelay: '<S749>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_px = rtb_Switch1_mw;

    /* End of Outputs for SubSystem: '<S13>/SignalLatchOnWithReset5' */

    /* Logic: '<S13>/Logical5' */
    rtb_Switch2_nq = (rtb_Switch2_nq || rtb_Switch1_mw);

    /* Logic: '<S774>/Logical2' incorporates:
     *  Constant: '<S856>/Constant'
     *  Constant: '<S857>/Constant'
     *  Constant: '<S858>/Constant'
     *  Logic: '<S774>/Logical3'
     *  RelationalOperator: '<S774>/Comparison2'
     *  RelationalOperator: '<S774>/Comparison3'
     *  RelationalOperator: '<S774>/Comparison4'
     *  Switch: '<S1781>/Switch'
     *  Switch: '<S1781>/Switch1'
     */
    rtb_Switch1_mw = (((((uint32)VeTIMR_e_RacePrep_AD) ==
                        CeTIMR_e_RacePrep_Active) && ((((uint32)
                          VeTIMR_e_RacePrepRaceTypeSts_AD) ==
                         CeTIMR_e_RaceType_Track) || (((uint32)
                          VeTIMR_e_RacePrepRaceTypeSts_AD) ==
                         CeTIMR_e_RaceType_Drag))) && (VeTPCC_b_VhclPlgdIn));

    /* Switch: '<S777>/Switch1' incorporates:
     *  Constant: '<S767>/Calib'
     *  Switch: '<S776>/Switch1'
     */
    if (KeTPCR_b_RacePrep_CellTempAvgUsed)
    {
        /* Switch: '<S777>/Switch1' */
        rtb_Switch1 = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pm;

        /* Switch: '<S776>/Switch1' */
        rtb_Switch1_ox = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pm;
    }
    else
    {
        /* Switch: '<S777>/Switch1' */
        rtb_Switch1 = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_du;

        /* Switch: '<S776>/Switch1' */
        rtb_Switch1_ox = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lp;
    }

    /* End of Switch: '<S777>/Switch1' */

    /* Outputs for Enabled SubSystem: '<S14>/Track_Mode_Targets' incorporates:
     *  EnablePort: '<S775>/Enable'
     */
    if (rtb_Switch1_mw)
    {
        /* Outputs for Atomic SubSystem: '<S775>/Hysteresis1' */
        /* Switch: '<S859>/Switch1' incorporates:
         *  Constant: '<S864>/Calib'
         *  Constant: '<S866>/Calib'
         *  RelationalOperator: '<S859>/Greater  Than'
         *  Sum: '<S775>/Subtraction4'
         */
        if (rtb_Switch1 > (KeTPCR_T_RacePrep_TrackThrmlTgt +
                           KeTPCR_T_RacePrep_TrackCoolingHys))
        {
            /* Switch: '<S859>/Switch1' incorporates:
             *  Constant: '<S859>/Constant Value'
             */
            VeTPCR_b_TrackCooling = true;
        }
        else
        {
            /* Switch: '<S859>/Switch1' incorporates:
             *  RelationalOperator: '<S859>/Greater  Than1'
             *  UnitDelay: '<S859>/Unit Delay'
             */
            VeTPCR_b_TrackCooling = ((rtb_Switch1 >=
                KeTPCR_T_RacePrep_TrackThrmlTgt) &&
                (TPCR_ac_DW.UnitDelay_DSTATE_h2));
        }

        /* End of Switch: '<S859>/Switch1' */

        /* Update for UnitDelay: '<S859>/Unit Delay' */
        TPCR_ac_DW.UnitDelay_DSTATE_h2 = VeTPCR_b_TrackCooling;

        /* End of Outputs for SubSystem: '<S775>/Hysteresis1' */

        /* Outputs for Atomic SubSystem: '<S775>/Hysteresis2' */
        /* Switch: '<S860>/Switch1' incorporates:
         *  Constant: '<S866>/Calib'
         *  RelationalOperator: '<S860>/Greater  Than'
         */
        if (rtb_Switch1_ox > KeTPCR_T_RacePrep_TrackThrmlTgt)
        {
            /* Switch: '<S860>/Switch1' incorporates:
             *  Constant: '<S860>/Constant Value'
             */
            rtb_NotEqual_p = true;
        }
        else
        {
            /* Switch: '<S860>/Switch1' incorporates:
             *  Constant: '<S865>/Calib'
             *  RelationalOperator: '<S860>/Greater  Than1'
             *  Sum: '<S775>/Subtraction5'
             *  UnitDelay: '<S860>/Unit Delay'
             */
            rtb_NotEqual_p = ((rtb_Switch1_ox >=
                               (KeTPCR_T_RacePrep_TrackThrmlTgt -
                                KeTPCR_T_RacePrep_TrackHeatingHys)) &&
                              (TPCR_ac_DW.UnitDelay_DSTATE_p2));
        }

        /* End of Switch: '<S860>/Switch1' */

        /* Update for UnitDelay: '<S860>/Unit Delay' */
        TPCR_ac_DW.UnitDelay_DSTATE_p2 = rtb_NotEqual_p;

        /* End of Outputs for SubSystem: '<S775>/Hysteresis2' */

        /* Logic: '<S775>/NOT' */
        VeTPCR_b_TrackHeating = !rtb_NotEqual_p;

        /* Merge: '<S14>/Merge5' incorporates:
         *  Constant: '<S866>/Calib'
         *  SignalConversion generated from: '<S775>/VeTPCR_T_RacePrep_TrackThrmlTgt'
         */
        TPCR_ac_B.Merge5 = KeTPCR_T_RacePrep_TrackThrmlTgt;

        /* Sum: '<S775>/Subtraction1' incorporates:
         *  Constant: '<S866>/Calib'
         *  Sum: '<S775>/Subtraction'
         */
        rtb_Sum4_l = rtb_Switch1 - KeTPCR_T_RacePrep_TrackThrmlTgt;

        /* Switch: '<S867>/Switch1' incorporates:
         *  Constant: '<S867>/ConstantValue2'
         *  RelationalOperator: '<S867>/Comparison1'
         */
        if (rtb_Sum4_l >= 0.0F)
        {
            /* Merge: '<S14>/Merge1' */
            TPCR_ac_B.Merge1 = rtb_Sum4_l;
        }
        else
        {
            /* Merge: '<S14>/Merge1' incorporates:
             *  Constant: '<S867>/ConstantValue1'
             */
            TPCR_ac_B.Merge1 = 0.0F;
        }

        /* End of Switch: '<S867>/Switch1' */

        /* Sum: '<S775>/Subtraction1' incorporates:
         *  Constant: '<S866>/Calib'
         */
        rtb_Sum4_l = KeTPCR_T_RacePrep_TrackThrmlTgt - rtb_Switch1_ox;

        /* Switch: '<S868>/Switch1' incorporates:
         *  Constant: '<S868>/ConstantValue2'
         *  RelationalOperator: '<S868>/Comparison1'
         */
        if (rtb_Sum4_l >= 0.0F)
        {
            /* Merge: '<S14>/Merge2' */
            TPCR_ac_B.Merge2 = rtb_Sum4_l;
        }
        else
        {
            /* Merge: '<S14>/Merge2' incorporates:
             *  Constant: '<S868>/ConstantValue1'
             */
            TPCR_ac_B.Merge2 = 0.0F;
        }

        /* End of Switch: '<S868>/Switch1' */

        /* Outputs for Atomic SubSystem: '<S775>/Hysteresis6' */
        /* Switch: '<S861>/Switch1' incorporates:
         *  Constant: '<S862>/Calib'
         *  Constant: '<S863>/Calib'
         *  RelationalOperator: '<S861>/Greater  Than'
         *  Sum: '<S775>/Subtraction2'
         */
        if (VeTPCR_Pct_HVBatSOC > (KeTPCR_Pct_TrackSOCTgt -
                                   KeTPCR_Pct_TrackSOCHys))
        {
            /* Switch: '<S861>/Switch1' incorporates:
             *  Constant: '<S861>/Constant Value'
             */
            rtb_NotEqual_p = true;
        }
        else
        {
            /* Switch: '<S861>/Switch1' incorporates:
             *  RelationalOperator: '<S861>/Greater  Than1'
             *  UnitDelay: '<S861>/Unit Delay'
             */
            rtb_NotEqual_p = ((VeTPCR_Pct_HVBatSOC >= KeTPCR_Pct_TrackSOCTgt) &&
                              (TPCR_ac_DW.UnitDelay_DSTATE_hz));
        }

        /* End of Switch: '<S861>/Switch1' */

        /* Update for UnitDelay: '<S861>/Unit Delay' */
        TPCR_ac_DW.UnitDelay_DSTATE_hz = rtb_NotEqual_p;

        /* End of Outputs for SubSystem: '<S775>/Hysteresis6' */

        /* Logic: '<S775>/NOT1' */
        VeTPCR_b_TrackCharging = !rtb_NotEqual_p;

        /* Merge: '<S14>/Merge3' incorporates:
         *  Constant: '<S863>/Calib'
         *  SignalConversion generated from: '<S775>/VeTPCR_T_RacePrep_TrackSOCTgt'
         */
        TPCR_ac_B.Merge3 = KeTPCR_Pct_TrackSOCTgt;
    }

    /* End of Outputs for SubSystem: '<S14>/Track_Mode_Targets' */

    /* Outputs for Enabled SubSystem: '<S14>/CoolingPower' incorporates:
     *  EnablePort: '<S753>/Enable'
     */
    if (VeTPCR_b_TrackCooling)
    {
        /* Product: '<S753>/Product1' incorporates:
         *  Constant: '<S778>/Calib'
         *  Sum: '<S753>/Plus2'
         */
        rtb_Product1_d = (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pm -
                          TPCR_ac_B.TmpSignalConversionAtTmpVM_F_b1) *
            KeTPCR_K_RacePrep_HeatTransferCoeff;

        /* Product: '<S753>/Product3' incorporates:
         *  Constant: '<S778>/Calib'
         *  Constant: '<S779>/Calib'
         */
        rtb_Sum4_l = KeTPCR_K_RacePrep_HeatTransferCoeff *
            KeTPCR_T_RacePrep_MinBatteryCoolantDiff;

        /* Lookup_n-D: '<S782>/Vector' incorporates:
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        rtb_Vector_ap = look1_iflf_binlcapw
            (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d, ((const float32 *)
              &(KxTPCR_P_RacePrep_CoolPowerMax[0])), ((const float32 *)
              &(KtTPCR_P_RacePrep_CoolPowerMax[0])), 1U);

        /* Outputs for Atomic SubSystem: '<S753>/WindowedAverage' */
        /* Chart: '<S784>/Chart' */
        /* Gateway: Filters/Moving Average/Windowed Average/Chart */
        /* During: Filters/Moving Average/Windowed Average/Chart */
        /* Entry Internal: Filters/Moving Average/Windowed Average/Chart */
        /* Transition: '<S785>:1' */
        if ((100 != ((sint32)TPCR_ac_DW.prior_window_size_p)) &&
                (TPCR_ac_DW.first_pass_complete_c))
        {
            /* Transition: '<S785>:2' */
            /* Transition: '<S785>:4' */
            TPCR_ac_DW.count_b = 0U;
            TPCR_ac_DW.sum_p = 0.0F;
            TPCR_ac_DW.average_e = 0.0F;

            /* Transition: '<S785>:10' */
            /* Transition: '<S785>:7' */
        }
        else
        {
            /* Transition: '<S785>:9' */
            TPCR_ac_DW.sum_p += rtb_Product1_d;
            TPCR_ac_DW.count_b = (uint16)((sint32)(((sint32)TPCR_ac_DW.count_b)
                + 1));
            if (((sint32)TPCR_ac_DW.count_b) >= 100)
            {
                /* Transition: '<S785>:3' */
                /* Transition: '<S785>:5' */
                TPCR_ac_DW.average_e = TPCR_ac_DW.sum_p / ((float32)
                    TPCR_ac_DW.count_b);
                TPCR_ac_DW.sum_p = 0.0F;
                TPCR_ac_DW.count_b = 0U;

                /* Transition: '<S785>:7' */
            }
            else
            {
                /* Transition: '<S785>:6' */
            }
        }

        /* Transition: '<S785>:8' */
        TPCR_ac_DW.prior_window_size_p = 100U;
        TPCR_ac_DW.first_pass_complete_c = true;

        /* End of Outputs for SubSystem: '<S753>/WindowedAverage' */

        /* Product: '<S753>/Product2' incorporates:
         *  Gain: '<S753>/Gain'
         *  Lookup_n-D: '<S781>/Vector'
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         *  Sum: '<S753>/Plus'
         */
        VeTPCR_P_CoolPowerAvgRaw = ((rtb_Product1_d + rtb_Sum4_l) * 0.5F) *
            look1_iflf_binlcapw(TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d, ((
            const float32 *)&(KxTPCR_K_RacePrep_CoolPowerCorrection[0])), ((
            const float32 *)&(KtTPCR_K_RacePrep_CoolPowerCorrection[0])), 5U);

        /* Switch: '<S753>/Switch' incorporates:
         *  Constant: '<S780>/Calib'
         */
        if (KeTPCR_b_RacePrep_MovingAvgPcool)
        {
            /* Outputs for Atomic SubSystem: '<S753>/WindowedAverage' */
            /* Switch: '<S753>/Switch' incorporates:
             *  Chart: '<S784>/Chart'
             */
            rtb_Product1_d = TPCR_ac_DW.average_e;

            /* End of Outputs for SubSystem: '<S753>/WindowedAverage' */
        }
        else
        {
            /* Switch: '<S753>/Switch' */
            rtb_Product1_d = VeTPCR_P_CoolPowerAvgRaw;
        }

        /* End of Switch: '<S753>/Switch' */

        /* Outputs for Atomic SubSystem: '<S753>/Limiter1' */
        /* Switch: '<S783>/Switch1' incorporates:
         *  RelationalOperator: '<S783>/Relational Operator'
         */
        if (rtb_Vector_ap >= rtb_Product1_d)
        {
            /* Switch: '<S783>/Switch1' */
            rtb_Vector_ap = rtb_Product1_d;
        }

        /* End of Switch: '<S783>/Switch1' */

        /* Switch: '<S783>/Switch' incorporates:
         *  RelationalOperator: '<S783>/Relational Operator1'
         */
        if (rtb_Vector_ap > rtb_Sum4_l)
        {
            /* Merge: '<S14>/Merge4' */
            VeTPCR_P_RacePrepPower = rtb_Vector_ap;
        }
        else
        {
            /* Merge: '<S14>/Merge4' */
            VeTPCR_P_RacePrepPower = rtb_Sum4_l;
        }

        /* End of Switch: '<S783>/Switch' */
        /* End of Outputs for SubSystem: '<S753>/Limiter1' */
    }

    /* End of Outputs for SubSystem: '<S14>/CoolingPower' */

    /* Outputs for Enabled SubSystem: '<S14>/HeatingPower' incorporates:
     *  EnablePort: '<S758>/Enable'
     */
    if (VeTPCR_b_TrackHeating)
    {
        /* Product: '<S758>/Product1' incorporates:
         *  Constant: '<S826>/Calib'
         *  Sum: '<S758>/Plus2'
         */
        rtb_Sum4_l = (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pm -
                      TPCR_ac_B.TmpSignalConversionAtTmpVM_F_b1) *
            KeTPCR_K_RacePrep_HeatTransferCoeff;

        /* Gain: '<S758>/Gain' incorporates:
         *  Constant: '<S826>/Calib'
         *  Constant: '<S829>/Calib'
         *  Product: '<S758>/Product3'
         *  Sum: '<S758>/Plus'
         */
        VeTPCR_P_RP_HeatPowerAvgRaw = ((KeTPCR_K_RacePrep_HeatTransferCoeff *
            KeTPCR_T_RPM_TrgtBattCoolntDiff) + rtb_Sum4_l) * 0.5F;

        /* Outputs for Atomic SubSystem: '<S758>/WindowedAverage' */
        /* Chart: '<S832>/Chart' */
        /* Gateway: Filters/Moving Average/Windowed Average/Chart */
        /* During: Filters/Moving Average/Windowed Average/Chart */
        /* Entry Internal: Filters/Moving Average/Windowed Average/Chart */
        /* Transition: '<S833>:1' */
        if ((100 != ((sint32)TPCR_ac_DW.prior_window_size)) &&
                (TPCR_ac_DW.first_pass_complete))
        {
            /* Transition: '<S833>:2' */
            /* Transition: '<S833>:4' */
            TPCR_ac_DW.count = 0U;
            TPCR_ac_DW.sum = 0.0F;
            TPCR_ac_DW.average = 0.0F;

            /* Transition: '<S833>:10' */
            /* Transition: '<S833>:7' */
        }
        else
        {
            /* Transition: '<S833>:9' */
            TPCR_ac_DW.sum += rtb_Sum4_l;
            TPCR_ac_DW.count = (uint16)((sint32)(((sint32)TPCR_ac_DW.count) + 1));
            if (((sint32)TPCR_ac_DW.count) >= 100)
            {
                /* Transition: '<S833>:3' */
                /* Transition: '<S833>:5' */
                TPCR_ac_DW.average = TPCR_ac_DW.sum / ((float32)TPCR_ac_DW.count);
                TPCR_ac_DW.sum = 0.0F;
                TPCR_ac_DW.count = 0U;

                /* Transition: '<S833>:7' */
            }
            else
            {
                /* Transition: '<S833>:6' */
            }
        }

        /* Transition: '<S833>:8' */
        TPCR_ac_DW.prior_window_size = 100U;
        TPCR_ac_DW.first_pass_complete = true;

        /* End of Outputs for SubSystem: '<S758>/WindowedAverage' */

        /* Switch: '<S758>/Switch' incorporates:
         *  Constant: '<S830>/Calib'
         */
        if (KeTPCR_b_RacePrep_MovingAvgPcool)
        {
            /* Outputs for Atomic SubSystem: '<S758>/WindowedAverage' */
            /* Switch: '<S758>/Switch' incorporates:
             *  Chart: '<S832>/Chart'
             */
            rtb_Sum4_l = TPCR_ac_DW.average;

            /* End of Outputs for SubSystem: '<S758>/WindowedAverage' */
        }
        else
        {
            /* Switch: '<S758>/Switch' */
            rtb_Sum4_l = VeTPCR_P_RP_HeatPowerAvgRaw;
        }

        /* End of Switch: '<S758>/Switch' */

        /* Outputs for Atomic SubSystem: '<S758>/Limiter1' */
        /* Switch: '<S831>/Switch1' incorporates:
         *  Constant: '<S827>/Calib'
         *  RelationalOperator: '<S831>/Relational Operator'
         */
        if (KeTPCR_P_RacePrep_HeatPowerMax < rtb_Sum4_l)
        {
            /* Switch: '<S831>/Switch1' */
            rtb_Sum4_l = KeTPCR_P_RacePrep_HeatPowerMax;
        }

        /* End of Switch: '<S831>/Switch1' */

        /* Switch: '<S831>/Switch' incorporates:
         *  Constant: '<S828>/Calib'
         *  RelationalOperator: '<S831>/Relational Operator1'
         */
        if (rtb_Sum4_l > KeTPCR_P_RacePrep_HeatPowerMin)
        {
            /* Merge: '<S14>/Merge4' */
            VeTPCR_P_RacePrepPower = rtb_Sum4_l;
        }
        else
        {
            /* Merge: '<S14>/Merge4' */
            VeTPCR_P_RacePrepPower = KeTPCR_P_RacePrep_HeatPowerMin;
        }

        /* End of Switch: '<S831>/Switch' */
        /* End of Outputs for SubSystem: '<S758>/Limiter1' */
    }

    /* End of Outputs for SubSystem: '<S14>/HeatingPower' */

    /* MATLAB Function: '<S754>/TrackCurrentOptimization' incorporates:
     *  Constant: '<S791>/Calib'
     *  Constant: '<S792>/Calib'
     *  Constant: '<S793>/Calib'
     *  Constant: '<S794>/Calib'
     *  Constant: '<S795>/Calib'
     *  MATLAB Function: '<S14>/TrackTimeEstimation'
     */
    /* MATLAB Function 'TPCR_MedTEH/TPCC_Controls/RacePrep/CurrentOptimization/TrackCurrentOptimization': '<S797>:1' */
    /* '<S797>:1:3' */
    rtb_Sum4_a_tmp = KeTPCR_R_RacePrep_BattResistanceParam /
        KeTPCR_K_RacePrep_BatteryThermalCoeff;

    /* '<S797>:1:4' */
    if (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pm >
            KeTPCR_T_RacePrep_TrackThrmlTgt)
    {
        /* '<S797>:1:7' */
        if (VeTPCR_Pct_HVBatSOC < KeTPCR_Pct_TrackSOCTgt)
        {
            /* '<S797>:1:8' */
            /* '<S797>:1:9' */
            rtb_Vector_ap = ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pm -
                              KeTPCR_T_RacePrep_TrackThrmlTgt) *
                             KeTPCR_K_RacePrep_BatteryChargeCoeff) /
                (KeTPCR_Pct_TrackSOCTgt - VeTPCR_Pct_HVBatSOC);

            /* '<S797>:1:10' */
            rtb_Sum4_l = ((sqrtf(((4.0F * rtb_Sum4_a_tmp) *
                                  (VeTPCR_P_RacePrepPower /
                                   KeTPCR_K_RacePrep_BatteryThermalCoeff)) +
                                 (rtb_Vector_ap * rtb_Vector_ap)) +
                           (-rtb_Vector_ap)) * 0.5F) / rtb_Sum4_a_tmp;
        }
        else
        {
            /* '<S797>:1:12' */
            rtb_Sum4_l = sqrtf((VeTPCR_P_RacePrepPower /
                                KeTPCR_K_RacePrep_BatteryThermalCoeff) /
                               rtb_Sum4_a_tmp);
        }
    }
    else
    {
        /* '<S797>:1:15' */
        rtb_Sum4_l = 1000.0F;
    }

    /* End of MATLAB Function: '<S754>/TrackCurrentOptimization' */

    /* Logic: '<S756>/Logical1' incorporates:
     *  Constant: '<S803>/Constant'
     *  Constant: '<S804>/Constant'
     *  RelationalOperator: '<S756>/Comparison1'
     *  RelationalOperator: '<S756>/Comparison34'
     *  RelationalOperator: '<S774>/Comparison3'
     *  RelationalOperator: '<S774>/Comparison4'
     *  Switch: '<S1781>/Switch'
     *  Switch: '<S1781>/Switch1'
     */
    rtb_NotEqual_p = (((((uint32)VeTIMR_e_RacePrep_AD) ==
                        CeTIMR_e_RacePrep_Active) && (((uint32)
                         VeTIMR_e_RacePrepRaceTypeSts_AD) ==
                        CeTIMR_e_RaceType_Drag)) &&
                      VeTPCR_b_UnplugNoBattCond_SOC_t);

    /* Outputs for Enabled SubSystem: '<S14>/Drag_Mode_Targets' incorporates:
     *  EnablePort: '<S757>/Enable'
     */
    if (rtb_NotEqual_p)
    {
        /* Switch: '<S757>/Switch3' incorporates:
         *  Constant: '<S757>/ConstantValue2'
         *  Constant: '<S806>/Constant'
         *  Logic: '<S757>/NOT1'
         *  Lookup_n-D: '<S818>/Vector'
         *  RelationalOperator: '<S757>/Equal1'
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        if (((uint32)TPCR_ac_B.TmpSignalConversionAtTmpVM_F_il) !=
                CeTHMR_e_NoCabinHeating)
        {
            rtb_Product1_d = look2_iflf_binlcapw
                (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d,
                 TPCR_ac_B.TmpSignalConversionAtTmpVM_F_k0, ((const float32 *)
                  &(KyTPCR_T_HtrDragCorr[0])), ((const float32 *)
                  &(KxTPCR_Pct_HtrDragCorr[0])), ((const float32 *)
                  &(KtTPCR_k_HtDragCorr[0])), TPCR_ac_ConstP.pooled9, 5U);
        }
        else
        {
            rtb_Product1_d = 1.0F;
        }

        /* End of Switch: '<S757>/Switch3' */

        /* Switch: '<S757>/Switch2' incorporates:
         *  Constant: '<S757>/ConstantValue1'
         *  Constant: '<S805>/Constant'
         *  Lookup_n-D: '<S817>/Vector'
         *  RelationalOperator: '<S757>/Equal'
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        if (((uint32)TPCR_ac_B.TmpSignalConversionAtTmpVM_F_fy) ==
                CeTHMR_e_CabinActiveCooling)
        {
            rtb_Vector_ap = look2_iflf_binlcapw
                (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d,
                 TPCR_ac_B.TmpSignalConversionAtTmpVM_F_k0, ((const float32 *)
                  &(KyTPCR_T_ACDragCorr[0])), ((const float32 *)
                  &(KxTPCR_Pct_ACDragCorr[0])), ((const float32 *)
                  &(KtTPCR_k_ACDragCorr[0])), TPCR_ac_ConstP.pooled9, 5U);
        }
        else
        {
            rtb_Vector_ap = 1.0F;
        }

        /* End of Switch: '<S757>/Switch2' */

        /* Product: '<S757>/Product2' */
        rtb_Product1_d = (VeTPCR_P_ThrmlPwrBdgt * rtb_Product1_d) *
            rtb_Vector_ap;

        /* Sum: '<S757>/Subtraction' incorporates:
         *  Constant: '<S815>/Calib'
         *  Sum: '<S757>/Subtraction1'
         */
        rtb_Subtraction_p = KeTPCR_T_RacePrep_DragThrmlTgt - rtb_Switch1_ox;

        /* Switch: '<S820>/Switch1' incorporates:
         *  Constant: '<S820>/ConstantValue2'
         *  RelationalOperator: '<S820>/Comparison1'
         */
        if (rtb_Subtraction_p >= 0.0F)
        {
            /* Switch: '<S820>/Switch1' */
            rtb_Vector_ap = rtb_Subtraction_p;
        }
        else
        {
            /* Switch: '<S820>/Switch1' incorporates:
             *  Constant: '<S820>/ConstantValue1'
             */
            rtb_Vector_ap = 0.0F;
        }

        /* End of Switch: '<S820>/Switch1' */

        /* Outputs for Atomic SubSystem: '<S757>/Hysteresis2' */
        /* Switch: '<S810>/Switch1' incorporates:
         *  Constant: '<S815>/Calib'
         *  RelationalOperator: '<S810>/Greater  Than'
         */
        if (rtb_Switch1_ox > KeTPCR_T_RacePrep_DragThrmlTgt)
        {
            /* Switch: '<S810>/Switch1' incorporates:
             *  Constant: '<S810>/Constant Value'
             */
            rtb_OR1_ksz = true;
        }
        else
        {
            /* Switch: '<S810>/Switch1' incorporates:
             *  Constant: '<S814>/Calib'
             *  RelationalOperator: '<S810>/Greater  Than1'
             *  Sum: '<S757>/Subtraction5'
             *  UnitDelay: '<S810>/Unit Delay'
             */
            rtb_OR1_ksz = ((rtb_Switch1_ox >= (KeTPCR_T_RacePrep_DragThrmlTgt -
                             KeTPCR_T_RacePrep_DragHeatingHys)) &&
                           (TPCR_ac_DW.UnitDelay_DSTATE_nc));
        }

        /* End of Switch: '<S810>/Switch1' */

        /* Update for UnitDelay: '<S810>/Unit Delay' */
        TPCR_ac_DW.UnitDelay_DSTATE_nc = rtb_OR1_ksz;

        /* End of Outputs for SubSystem: '<S757>/Hysteresis2' */

        /* Logic: '<S757>/NOT' */
        VeTPCR_b_DragHeating = !rtb_OR1_ksz;

        /* Outputs for Enabled SubSystem: '<S757>/DragWarmingBattery' incorporates:
         *  EnablePort: '<S808>/Enable'
         */
        if (VeTPCR_b_DragHeating)
        {
            /* Lookup_n-D: '<S825>/Vector' incorporates:
             *  Product: '<S757>/Product2'
             *  Switch: '<S820>/Switch1'
             */
            rtb_Switch1_ox = look2_iflf_binlcapw(rtb_Product1_d, rtb_Vector_ap,
                ((const float32 *)&(KyTPCR_t_TimetoWarm_Drag[0])), ((const
                float32 *)&(KxTPCR_t_TimetoWarm_Drag[0])), ((const float32 *)
                &(KtTPCR_t_TimetoWarm_Drag[0])),
                TPCR_ac_ConstP.Vector_maxIndex_f, 8U);

            /* Merge: '<S757>/Merge5' incorporates:
             *  SignalConversion generated from: '<S808>/DragWarmTime'
             */
            TPCR_ac_B.Merge5_o = rtb_Switch1_ox;

            /* Merge: '<S757>/Merge1' incorporates:
             *  Lookup_n-D: '<S824>/Vector'
             *  Product: '<S808>/Product1'
             *  Switch: '<S820>/Switch1'
             */
            TPCR_ac_B.Merge1_n = rtb_Switch1_ox * look1_iflf_binlcapw
                (rtb_Vector_ap, ((const float32 *)&(KxTPCR_T_DragHotPwrNeed[0])),
                 ((const float32 *)&(KtTPCR_P_DragHotPwrNeed[0])), 5U);
        }

        /* End of Outputs for SubSystem: '<S757>/DragWarmingBattery' */

        /* Sum: '<S757>/Subtraction' incorporates:
         *  Constant: '<S815>/Calib'
         */
        rtb_Subtraction_p = rtb_Switch1 - KeTPCR_T_RacePrep_DragThrmlTgt;

        /* Switch: '<S819>/Switch1' incorporates:
         *  Constant: '<S819>/ConstantValue2'
         *  RelationalOperator: '<S819>/Comparison1'
         */
        if (rtb_Subtraction_p >= 0.0F)
        {
            /* Switch: '<S819>/Switch1' */
            rtb_Switch1_ox = rtb_Subtraction_p;
        }
        else
        {
            /* Switch: '<S819>/Switch1' incorporates:
             *  Constant: '<S819>/ConstantValue1'
             */
            rtb_Switch1_ox = 0.0F;
        }

        /* End of Switch: '<S819>/Switch1' */

        /* Outputs for Atomic SubSystem: '<S757>/Hysteresis1' */
        /* Switch: '<S809>/Switch1' incorporates:
         *  Constant: '<S813>/Calib'
         *  Constant: '<S815>/Calib'
         *  RelationalOperator: '<S809>/Greater  Than'
         *  Sum: '<S757>/Subtraction4'
         */
        if (rtb_Switch1 > (KeTPCR_T_RacePrep_DragThrmlTgt +
                           KeTPCR_T_RacePrep_DragCoolingHys))
        {
            /* Switch: '<S809>/Switch1' incorporates:
             *  Constant: '<S809>/Constant Value'
             */
            VeTPCR_b_DragCooling = true;
        }
        else
        {
            /* Switch: '<S809>/Switch1' incorporates:
             *  RelationalOperator: '<S809>/Greater  Than1'
             *  UnitDelay: '<S809>/Unit Delay'
             */
            VeTPCR_b_DragCooling = ((rtb_Switch1 >=
                KeTPCR_T_RacePrep_DragThrmlTgt) &&
                                    (TPCR_ac_DW.UnitDelay_DSTATE_nrk));
        }

        /* End of Switch: '<S809>/Switch1' */

        /* Update for UnitDelay: '<S809>/Unit Delay' */
        TPCR_ac_DW.UnitDelay_DSTATE_nrk = VeTPCR_b_DragCooling;

        /* End of Outputs for SubSystem: '<S757>/Hysteresis1' */

        /* Outputs for Enabled SubSystem: '<S757>/DragCoolingBattery' incorporates:
         *  EnablePort: '<S807>/Enable'
         */
        if (VeTPCR_b_DragCooling)
        {
            /* Lookup_n-D: '<S823>/Vector' incorporates:
             *  Lookup_n-D: '<S822>/Vector'
             *  Product: '<S757>/Product2'
             *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
             *  Switch: '<S819>/Switch1'
             */
            rtb_Switch1 = look2_iflf_binlcapw(rtb_Product1_d,
                look2_iflf_binlcapw(TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d,
                                    rtb_Switch1_ox, ((const float32 *)
                &(KyTPCR_T_MinTimetoCoolDrag[0])), ((const float32 *)
                &(KxTPCR_T_MinTimetoCoolDrag[0])), ((const float32 *)
                &(KtTPCR_t_MinTimetoCoolDrag[0])),
                                    TPCR_ac_ConstP.Vector_maxIndex_e, 5U), ((
                const float32 *)&(KyTPCR_P_TimetoCool_Drag[0])), ((const float32
                *)&(KxTPCR_t_TimetoCool_Drag[0])), ((const float32 *)
                &(KtTPCR_t_TimetoCool_Drag[0])),
                TPCR_ac_ConstP.Vector_maxIndex_o, 7U);

            /* Merge: '<S757>/Merge5' incorporates:
             *  SignalConversion generated from: '<S807>/DragCoolTime'
             */
            TPCR_ac_B.Merge5_o = rtb_Switch1;

            /* Merge: '<S757>/Merge1' incorporates:
             *  Lookup_n-D: '<S821>/Vector'
             *  Product: '<S807>/Product'
             *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
             *  Switch: '<S819>/Switch1'
             */
            TPCR_ac_B.Merge1_n = rtb_Switch1 * look2_iflf_binlcapw
                (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d, rtb_Switch1_ox, ((
                   const float32 *)&(KyTPCR_T_DragCoolPwrNeed[0])), ((const
                   float32 *)&(KxTPCR_T_DragCoolPwrNeed[0])), ((const float32 *)
                  &(KtTPCR_P_DragCoolPwrNeed[0])),
                 TPCR_ac_ConstP.Vector_maxIndex, 5U);
        }

        /* End of Outputs for SubSystem: '<S757>/DragCoolingBattery' */

        /* Merge: '<S14>/Merge1' incorporates:
         *  SignalConversion generated from: '<S757>/VeTPCR_T_ModulOverTemp'
         */
        TPCR_ac_B.Merge1 = rtb_Switch1_ox;

        /* Merge: '<S14>/Merge2' incorporates:
         *  SignalConversion generated from: '<S757>/VeTPCR_T_ModulUnderTemp'
         */
        TPCR_ac_B.Merge2 = rtb_Vector_ap;

        /* Merge: '<S14>/Merge5' incorporates:
         *  Constant: '<S815>/Calib'
         *  SignalConversion generated from: '<S757>/VeTPCR_T_RacePrep_DragThrmlTgt'
         */
        TPCR_ac_B.Merge5 = KeTPCR_T_RacePrep_DragThrmlTgt;

        /* Sum: '<S757>/Subtraction2' incorporates:
         *  Constant: '<S811>/Calib'
         *  Product: '<S757>/Divide'
         */
        VeTPCR_Pct_DragSOCTgt_EnergyMethod = VeTPCR_Pct_HVBatSOC -
            (TPCR_ac_B.Merge1_n / KeTPCR_E_BatteryCapacity);

        /* Sum: '<S757>/Subtraction6' incorporates:
         *  Constant: '<S812>/Calib'
         *  Product: '<S757>/Product3'
         */
        VeTPCR_Pct_DragSOCTgt_CurrentMethod =
            ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lh * TPCR_ac_B.Merge5_o) *
             KeTPCR_K_RacePrep_BatteryDischargeCoeff) + VeTPCR_Pct_HVBatSOC;

        /* Switch: '<S757>/Switch1' incorporates:
         *  Constant: '<S816>/Calib'
         */
        if (KeTPCR_b_RacePrep_SOC_CurrentUsed)
        {
            /* Merge: '<S14>/Merge3' */
            TPCR_ac_B.Merge3 = VeTPCR_Pct_DragSOCTgt_CurrentMethod;
        }
        else
        {
            /* Merge: '<S14>/Merge3' */
            TPCR_ac_B.Merge3 = VeTPCR_Pct_DragSOCTgt_EnergyMethod;
        }

        /* End of Switch: '<S757>/Switch1' */
    }

    /* End of Outputs for SubSystem: '<S14>/Drag_Mode_Targets' */

    /* Logic: '<S755>/Logical3' incorporates:
     *  Logic: '<S755>/Logical4'
     */
    rtb_OR1_ksz = (rtb_NotEqual_p && ((VeTPCR_b_DragCooling) ||
                    (VeTPCR_b_DragHeating)));

    /* Outputs for Atomic SubSystem: '<S755>/EdgeRising2' */
    /* Logic: '<S798>/AND' incorporates:
     *  Logic: '<S798>/OR1'
     *  UnitDelay: '<S798>/Unit Delay'
     */
    rtb_Switch3_c2 = (rtb_OR1_ksz && (!TPCR_ac_DW.UnitDelay_DSTATE_d2));

    /* Update for UnitDelay: '<S798>/Unit Delay' */
    TPCR_ac_DW.UnitDelay_DSTATE_d2 = rtb_OR1_ksz;

    /* End of Outputs for SubSystem: '<S755>/EdgeRising2' */

    /* Outputs for Atomic SubSystem: '<S755>/StopWatchResetEnabled' */
    /* Switch: '<S801>/Switch2' incorporates:
     *  Logic: '<S755>/NOT'
     *  Switch: '<S801>/Switch'
     */
    if (!rtb_OR1_ksz)
    {
        /* Switch: '<S801>/Switch' incorporates:
         *  Constant: '<S801>/ConstantValue2'
         */
        rtb_Switch1 = 0.0F;
    }
    else
    {
        /* Switch: '<S801>/Switch' incorporates:
         *  Constant: '<S799>/Calib'
         *  Sum: '<S801>/Subtraction'
         *  Switch: '<S801>/Switch2'
         *  UnitDelay: '<S801>/UnitDelay'
         */
        rtb_Switch1 = KeTPCR_t_DragTimerUnit + TPCR_ac_DW.UnitDelay_DSTATE_hk;
    }

    /* End of Switch: '<S801>/Switch2' */

    /* Update for UnitDelay: '<S801>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_hk = rtb_Switch1;

    /* End of Outputs for SubSystem: '<S755>/StopWatchResetEnabled' */

    /* Rounding: '<S755>/Floor' incorporates:
     *  Constant: '<S800>/Calib'
     *  Product: '<S755>/Divide'
     */
    rtb_Switch1 = floorf(rtb_Switch1 / KeTPCR_t_RacePrepTimerDiff);

    /* Outputs for Atomic SubSystem: '<S755>/TimerResetEnabled1' */
    /* Switch: '<S802>/Switch1' incorporates:
     *  Constant: '<S802>/ConstantValue'
     *  Delay: '<S755>/Delay'
     *  Logic: '<S755>/Logical1'
     *  Logic: '<S755>/Logical2'
     *  Logic: '<S802>/AND1'
     *  RelationalOperator: '<S755>/GreaterThan4'
     *  RelationalOperator: '<S802>/GreaterThan'
     *  Switch: '<S802>/Switch2'
     *  UnitDelay: '<S802>/UnitDelay'
     */
    if (rtb_Switch3_c2 || (rtb_OR1_ksz && (rtb_Switch1 > TPCR_ac_DW.Delay_DSTATE)))
    {
        /* Switch: '<S802>/Switch1' */
        rtb_Switch1_ox = TPCR_ac_B.Merge5_o;
    }
    else if (rtb_OR1_ksz && (TPCR_ac_DW.UnitDelay_DSTATE_m > 0.0F))
    {
        /* Switch: '<S802>/Switch2' incorporates:
         *  Constant: '<S799>/Calib'
         *  Sum: '<S802>/Subtraction'
         *  Switch: '<S802>/Switch1'
         *  UnitDelay: '<S802>/UnitDelay'
         */
        rtb_Switch1_ox = TPCR_ac_DW.UnitDelay_DSTATE_m - KeTPCR_t_DragTimerUnit;
    }
    else
    {
        /* Switch: '<S802>/Switch1' incorporates:
         *  Switch: '<S802>/Switch2'
         *  UnitDelay: '<S802>/UnitDelay'
         */
        rtb_Switch1_ox = TPCR_ac_DW.UnitDelay_DSTATE_m;
    }

    /* End of Switch: '<S802>/Switch1' */

    /* Update for UnitDelay: '<S802>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_m = rtb_Switch1_ox;

    /* End of Outputs for SubSystem: '<S755>/TimerResetEnabled1' */

    /* Logic: '<S773>/Logical3' incorporates:
     *  Logic: '<S773>/Logical4'
     */
    rtb_Switch3_c2 = (rtb_Switch1_mw && (((VeTPCR_b_TrackCooling) ||
                        (VeTPCR_b_TrackHeating)) || (VeTPCR_b_TrackCharging)));

    /* Outputs for Atomic SubSystem: '<S773>/EdgeRising2' */
    /* Logic: '<S851>/AND' incorporates:
     *  Logic: '<S851>/OR1'
     *  UnitDelay: '<S851>/Unit Delay'
     */
    Gain_fm = (rtb_Switch3_c2 && (!TPCR_ac_DW.UnitDelay_DSTATE_fn));

    /* Update for UnitDelay: '<S851>/Unit Delay' */
    TPCR_ac_DW.UnitDelay_DSTATE_fn = rtb_Switch3_c2;

    /* End of Outputs for SubSystem: '<S773>/EdgeRising2' */

    /* Outputs for Atomic SubSystem: '<S773>/StopWatchResetEnabled' */
    /* Switch: '<S854>/Switch2' incorporates:
     *  Logic: '<S773>/NOT'
     *  Switch: '<S854>/Switch'
     */
    if (!rtb_Switch3_c2)
    {
        /* Switch: '<S854>/Switch' incorporates:
         *  Constant: '<S854>/ConstantValue2'
         */
        rtb_Vector_ap = 0.0F;
    }
    else
    {
        /* Switch: '<S854>/Switch' incorporates:
         *  Constant: '<S853>/Calib'
         *  Sum: '<S854>/Subtraction'
         *  Switch: '<S854>/Switch2'
         *  UnitDelay: '<S854>/UnitDelay'
         */
        rtb_Vector_ap = KeTPCR_t_DragTimerUnit + TPCR_ac_DW.UnitDelay_DSTATE_dl;
    }

    /* End of Switch: '<S854>/Switch2' */

    /* Update for UnitDelay: '<S854>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_dl = rtb_Vector_ap;

    /* End of Outputs for SubSystem: '<S773>/StopWatchResetEnabled' */

    /* Rounding: '<S773>/Floor' incorporates:
     *  Constant: '<S852>/Calib'
     *  Product: '<S773>/Divide'
     */
    rtb_Vector_ap = floorf(rtb_Vector_ap / KeTPCR_t_RacePrepTimerDiff);

    /* MATLAB Function: '<S14>/TrackTimeEstimation' incorporates:
     *  Constant: '<S761>/Calib'
     *  Constant: '<S762>/Calib'
     *  Constant: '<S763>/Calib'
     *  Constant: '<S764>/Calib'
     */
    /* MATLAB Function 'TPCR_MedTEH/TPCC_Controls/RacePrep/TrackTimeEstimation': '<S772>:1' */
    /* '<S772>:1:7' */
    /* '<S772>:1:8' */
    rtb_Subtraction_p = KeTPCR_K_RacePrep_BattResistanceTemp /
        KeTPCR_K_RacePrep_BatteryThermalCoeff;

    /* '<S772>:1:9' */
    if (((float64)TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lh) > 0.1)
    {
        /* '<S772>:1:11' */
        /* '<S772>:1:12' */
        rtb_Product1_d = (KeTPCR_Pct_TrackSOCTgt - VeTPCR_Pct_HVBatSOC) /
            (KeTPCR_K_RacePrep_BatteryChargeCoeff *
             TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lh);

        /* '<S772>:1:14' */
        rtb_Switch1_bv_tmp = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lh *
            TPCR_ac_B.TmpSignalConversionAtTmpVM_F_lh;
        rtb_Switch1_g = expf(((-rtb_Switch1_bv_tmp) * rtb_Subtraction_p) *
                             rtb_Product1_d);
        rtb_Subtraction_p = (((((VeTPCR_P_RacePrepPower /
            KeTPCR_K_RacePrep_BatteryThermalCoeff) + 0.001F) - (rtb_Sum4_a_tmp *
                                rtb_Switch1_bv_tmp)) * (rtb_Switch1_g - 1.0F)) /
                             (rtb_Switch1_bv_tmp * rtb_Subtraction_p)) +
            (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pm * rtb_Switch1_g);
    }
    else
    {
        /* '<S772>:1:17' */
        rtb_Product1_d = 0.0F;

        /* '<S772>:1:18' */
        rtb_Subtraction_p = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_pm;
    }

    /* Outputs for Atomic SubSystem: '<S773>/TimerResetEnabled1' */
    /* Switch: '<S855>/Switch1' incorporates:
     *  Constant: '<S855>/ConstantValue'
     *  Delay: '<S773>/Delay'
     *  Logic: '<S773>/Logical1'
     *  Logic: '<S773>/Logical2'
     *  Logic: '<S855>/AND1'
     *  RelationalOperator: '<S773>/GreaterThan4'
     *  RelationalOperator: '<S855>/GreaterThan'
     *  Switch: '<S855>/Switch2'
     *  UnitDelay: '<S855>/UnitDelay'
     */
    /* '<S772>:1:20' */
    if (Gain_fm || (rtb_Switch3_c2 && (rtb_Vector_ap > TPCR_ac_DW.Delay_DSTATE_g)))
    {
        /* Switch: '<S855>/Switch1' incorporates:
         *  Constant: '<S763>/Calib'
         *  Constant: '<S766>/Calib'
         *  MATLAB Function: '<S14>/TrackTimeEstimation'
         *  MinMax: '<S14>/Max'
         */
        rtb_Product1_d = fmaxf(rtb_Product1_d, ((rtb_Subtraction_p -
            KeTPCR_T_RacePrep_TrackThrmlTgt) / ((VeTPCR_P_RacePrepPower /
            KeTPCR_K_RacePrep_BatteryThermalCoeff) + 0.001F)) + rtb_Product1_d);
    }
    else if (rtb_Switch3_c2 && (TPCR_ac_DW.UnitDelay_DSTATE_ag > 0.0F))
    {
        /* Switch: '<S855>/Switch2' incorporates:
         *  Constant: '<S853>/Calib'
         *  Sum: '<S855>/Subtraction'
         *  Switch: '<S855>/Switch1'
         *  UnitDelay: '<S855>/UnitDelay'
         */
        rtb_Product1_d = TPCR_ac_DW.UnitDelay_DSTATE_ag - KeTPCR_t_DragTimerUnit;
    }
    else
    {
        /* Switch: '<S855>/Switch1' incorporates:
         *  Switch: '<S855>/Switch2'
         *  UnitDelay: '<S855>/UnitDelay'
         */
        rtb_Product1_d = TPCR_ac_DW.UnitDelay_DSTATE_ag;
    }

    /* End of Switch: '<S855>/Switch1' */

    /* Update for UnitDelay: '<S855>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_ag = rtb_Product1_d;

    /* End of Outputs for SubSystem: '<S773>/TimerResetEnabled1' */

    /* Switch: '<S759>/Switch1' incorporates:
     *  Delay: '<S773>/Delay2'
     *  Delay: '<S773>/Delay3'
     *  Logic: '<S773>/AND2'
     *  RelationalOperator: '<S773>/GreaterThan1'
     *  RelationalOperator: '<S773>/GreaterThan6'
     *  Switch: '<S773>/Switch'
     */
    if (rtb_NotEqual_p)
    {
        /* Switch: '<S755>/Switch' incorporates:
         *  Delay: '<S755>/Delay2'
         *  Delay: '<S755>/Delay3'
         *  Logic: '<S755>/AND2'
         *  RelationalOperator: '<S755>/GreaterThan1'
         *  RelationalOperator: '<S755>/GreaterThan6'
         */
        if ((TPCR_ac_DW.Delay2_DSTATE == rtb_Switch1_ox) && (rtb_Switch1_ox ==
                TPCR_ac_DW.Delay3_DSTATE[0]))
        {
            /* Switch: '<S759>/Switch1' incorporates:
             *  Constant: '<S755>/Constant1'
             */
            rtb_Subtraction_p = 0.0F;
        }
        else
        {
            /* Switch: '<S759>/Switch1' */
            rtb_Subtraction_p = rtb_Switch1_ox;
        }

        /* End of Switch: '<S755>/Switch' */
    }
    else if ((TPCR_ac_DW.Delay2_DSTATE_o == rtb_Product1_d) && (rtb_Product1_d ==
              TPCR_ac_DW.Delay3_DSTATE_l[0]))
    {
        /* Switch: '<S773>/Switch' incorporates:
         *  Constant: '<S773>/Constant1'
         *  Switch: '<S759>/Switch1'
         */
        rtb_Subtraction_p = 0.0F;
    }
    else
    {
        /* Switch: '<S759>/Switch1' incorporates:
         *  Switch: '<S773>/Switch'
         */
        rtb_Subtraction_p = rtb_Product1_d;
    }

    /* End of Switch: '<S759>/Switch1' */

    /* Outputs for Enabled SubSystem: '<S14>/PreconditionChecks' incorporates:
     *  EnablePort: '<S770>/Enable'
     */
    /* Logic: '<S14>/Logical1' incorporates:
     *  Constant: '<S750>/Constant'
     *  Constant: '<S751>/Constant'
     *  Constant: '<S768>/Calib'
     *  RelationalOperator: '<S14>/Comparison1'
     *  RelationalOperator: '<S14>/Comparison34'
     *  RelationalOperator: '<S774>/Comparison4'
     *  Switch: '<S1781>/Switch'
     */
    if (((((uint32)VeTIMR_e_RacePrep_AD) == CeTIMR_e_RacePrep_Active) ||
            (((uint32)VeTIMR_e_RacePrep_AD) == CeTIMR_e_RacePrep_Enabled)) ||
            (KeTPCR_b_RacePrep_PrecondEnable))
    {
        /* Logic: '<S770>/Logical5' incorporates:
         *  Constant: '<S836>/Calib'
         *  Constant: '<S837>/Calib'
         *  RelationalOperator: '<S770>/Comparison5'
         *  RelationalOperator: '<S770>/Comparison6'
         */
        TPCR_ac_B.Logical5 = ((TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d <=
                               KeTPCR_T_MaxAmb_Thrshld_RacePrep) &&
                              (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_d >=
                               KeTPCR_T_MinAmb_Thrshld_RacePrep));

        /* RelationalOperator: '<S770>/GreaterThan2' incorporates:
         *  Constant: '<S840>/Calib'
         */
        Gain_fm = (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_p5 >
                   KeTPCR_v_DragMaxSpd);

        /* Outputs for Atomic SubSystem: '<S770>/TimerResetEnabled1' */
        /* Switch: '<S841>/Switch1' incorporates:
         *  Constant: '<S841>/ConstantValue'
         *  Logic: '<S770>/NOT3'
         *  RelationalOperator: '<S841>/GreaterThan'
         *  Switch: '<S841>/Switch2'
         *  UnitDelay: '<S841>/UnitDelay'
         */
        if (!Gain_fm)
        {
            /* Switch: '<S841>/Switch1' incorporates:
             *  Constant: '<S838>/Calib'
             */
            rtb_Switch1_g = KeTPCR_t_OverSpdDebounceTime;
        }
        else if (TPCR_ac_DW.UnitDelay_DSTATE_jg > 0.0F)
        {
            /* Switch: '<S841>/Switch2' incorporates:
             *  Constant: '<S839>/Calib'
             *  Sum: '<S841>/Subtraction'
             *  Switch: '<S841>/Switch1'
             *  UnitDelay: '<S841>/UnitDelay'
             */
            rtb_Switch1_g = TPCR_ac_DW.UnitDelay_DSTATE_jg -
                KeTPCR_t_OverSpdDebounceUnitTime;
        }
        else
        {
            /* Switch: '<S841>/Switch1' incorporates:
             *  Switch: '<S841>/Switch2'
             *  UnitDelay: '<S841>/UnitDelay'
             */
            rtb_Switch1_g = TPCR_ac_DW.UnitDelay_DSTATE_jg;
        }

        /* End of Switch: '<S841>/Switch1' */

        /* Update for UnitDelay: '<S841>/UnitDelay' */
        TPCR_ac_DW.UnitDelay_DSTATE_jg = rtb_Switch1_g;

        /* Logic: '<S770>/Logical1' incorporates:
         *  Constant: '<S835>/Constant'
         *  Constant: '<S841>/ConstantValue2'
         *  Logic: '<S770>/AND1'
         *  Logic: '<S770>/NOT1'
         *  Logic: '<S770>/NOT2'
         *  Logic: '<S770>/NOT4'
         *  RelationalOperator: '<S770>/Comparison34'
         *  RelationalOperator: '<S841>/GreaterThan1'
         *  SignalConversion generated from: '<Root>/TmpVM_FcnCallSubsysAtTPCR_MedTEHInport168'
         */
        TPCR_ac_B.Logical1 = (((rtb_VariantMerge_For_Variant__3 &&
                                (!TPCR_ac_B.TmpSignalConversionAtTmpVM_F_gq)) &&
                               ((!Gain_fm) || (rtb_Switch1_g > 0.0F))) &&
                              (((uint32)
                                TPCR_ac_B.TmpSignalConversionAtTmpVM_F_iq) ==
                               CeHMIR_e_HEV_LMP_OFF));

        /* End of Outputs for SubSystem: '<S770>/TimerResetEnabled1' */
    }

    /* End of Logic: '<S14>/Logical1' */
    /* End of Outputs for SubSystem: '<S14>/PreconditionChecks' */

    /* Switch: '<S14>/Switch3' incorporates:
     *  Logic: '<S14>/AND'
     */
    if (rtb_Switch1_mw && (VeTPCR_b_TrackCooling))
    {
        /* Outputs for Atomic SubSystem: '<S754>/LeftOpenInterval' */
        /* Switch: '<S787>/Switch1' incorporates:
         *  Constant: '<S789>/Calib'
         *  Constant: '<S790>/Calib'
         *  Logic: '<S796>/LogicalOperator'
         *  RelationalOperator: '<S796>/RelatonalOperator'
         *  RelationalOperator: '<S796>/RelatonalOperator1'
         */
        if ((rtb_Sum4_l <= KeTPCR_I_RacePrep_MinCurrent) || (rtb_Sum4_l >
                KeTPCR_I_RacePrep_MaxCurrent))
        {
            /* Switch: '<S14>/Switch3' incorporates:
             *  Constant: '<S788>/Calib'
             */
            rtb_Sum4_l = KeTPCR_I_RacePrep_DefaultCurrent;
        }

        /* End of Switch: '<S787>/Switch1' */
        /* End of Outputs for SubSystem: '<S754>/LeftOpenInterval' */
    }
    else
    {
        /* Switch: '<S14>/Switch3' incorporates:
         *  Constant: '<S760>/Calib'
         */
        rtb_Sum4_l = KeTPCR_I_RacePrep_NoLimitCurrent;
    }

    /* End of Switch: '<S14>/Switch3' */

    /* Logic: '<S15>/Logical1' incorporates:
     *  Constant: '<S869>/Constant'
     *  Constant: '<S870>/Constant'
     *  Constant: '<S871>/Constant'
     *  Constant: '<S876>/Calib'
     *  RelationalOperator: '<S15>/Comparison2'
     *  RelationalOperator: '<S15>/Comparison3'
     *  RelationalOperator: '<S15>/Comparison4'
     */
    VeTPCR_b_CabPrecNotOk = ((((((uint32)Switch_cl) != CeTPCR_e_OkCabinPrec) &&
        (((uint32)Switch_cl) != CeTPCR_e_CabinPrec_SP_Reached)) && (((uint32)
        Switch_cl) != CeTPCR_e_CabinPrec_Dflt)) &&
        (KeTPCR_b_EnblCabPrecStsChk_SCWkUp));

    /* Switch: '<S874>/Switch1' incorporates:
     *  Constant: '<S877>/Calib'
     *  Constant: '<S878>/Calib'
     *  Logic: '<S15>/Logical2'
     *  Logic: '<S15>/Logical4'
     *  Logic: '<S15>/Logical5'
     */
    VeTPCR_b_ArbSCWkUpReq = ((((!VeTPCR_b_CabPrecNotOk) &&
        ((!TPCR_ac_B.VeTPCC_b_RS_ThrmlRdyShtDwn_App1) ||
         (!KeTPCR_b_RdyForShtDwnChk_SCWkUp))) && ((!rtb_Comparison5) ||
        (!KeTPCR_b_EnblTmrExp_SCWkUp))) && (VeTPCR_b_SC_WakeUpReq));

    /* Outputs for Atomic SubSystem: '<S15>/TurnOnDelaySample' */
    /* Outputs for Atomic SubSystem: '<S879>/EdgeRising' */
    /* Switch: '<S988>/Switch1' incorporates:
     *  UnitDelay: '<S880>/UnitDelay'
     */
    rtb_Switch1_cs = TPCR_ac_DW.UnitDelay_DSTATE_bkz;

    /* Update for UnitDelay: '<S880>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_bkz = VeTPCR_b_ArbSCWkUpReq;

    /* Switch: '<S879>/Switch1' incorporates:
     *  Constant: '<S875>/Calib'
     *  Constant: '<S879>/ConstantValue'
     *  Logic: '<S879>/OR'
     *  Logic: '<S879>/OR1'
     *  Logic: '<S880>/AND'
     *  Logic: '<S880>/OR1'
     *  MinMax: '<S879>/Minimum'
     *  Sum: '<S879>/Summation'
     *  UnitDelay: '<S879>/UnitDelay'
     */
    if ((!VeTPCR_b_ArbSCWkUpReq) || ((VeTPCR_b_ArbSCWkUpReq) && (!rtb_Switch1_cs)))
    {
        /* Switch: '<S879>/Switch1' incorporates:
         *  Constant: '<S879>/ConstantValue1'
         */
        rtb_Switch1_g1 = 0U;
    }
    else if (KeTPCR_Cnt_SCWakeUp_Dly < ((uint16)(((uint32)
                TPCR_ac_DW.UnitDelay_DSTATE_k5b) + 1U)))
    {
        /* MinMax: '<S879>/Minimum' incorporates:
         *  Constant: '<S875>/Calib'
         *  Switch: '<S879>/Switch1'
         */
        rtb_Switch1_g1 = KeTPCR_Cnt_SCWakeUp_Dly;
    }
    else
    {
        /* Switch: '<S879>/Switch1' incorporates:
         *  Constant: '<S879>/ConstantValue'
         *  MinMax: '<S879>/Minimum'
         *  Sum: '<S879>/Summation'
         *  UnitDelay: '<S879>/UnitDelay'
         */
        rtb_Switch1_g1 = (uint16)(((uint32)TPCR_ac_DW.UnitDelay_DSTATE_k5b) + 1U);
    }

    /* End of Switch: '<S879>/Switch1' */
    /* End of Outputs for SubSystem: '<S879>/EdgeRising' */

    /* Logic: '<S879>/AND' incorporates:
     *  Constant: '<S875>/Calib'
     *  RelationalOperator: '<S879>/GreaterThan'
     */
    VeTPCR_b_SchCond_WakeUp = ((VeTPCR_b_ArbSCWkUpReq) && (rtb_Switch1_g1 >=
        KeTPCR_Cnt_SCWakeUp_Dly));

    /* Update for UnitDelay: '<S879>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_k5b = rtb_Switch1_g1;

    /* End of Outputs for SubSystem: '<S15>/TurnOnDelaySample' */

    /* Switch: '<S15>/Switch' */
    if (VeTPCR_b_SchCond_WakeUp)
    {
        /* Switch: '<S15>/Switch' incorporates:
         *  Constant: '<S872>/Constant'
         */
        VeTPCR_e_SchCond_WakeUp = CeTPCR_e_SC_WakeUp;
    }
    else
    {
        /* Switch: '<S15>/Switch' incorporates:
         *  Constant: '<S873>/Constant'
         */
        VeTPCR_e_SchCond_WakeUp = CeTPCR_e_SC_NotAwake;
    }

    /* End of Switch: '<S15>/Switch' */

    /* Outputs for Enabled SubSystem: '<S895>/EnabledSubsystem' incorporates:
     *  EnablePort: '<S958>/Enable'
     */
    if (rtb_VariantMerge_For_Variant__n)
    {
        /* DataStoreWrite: '<S958>/DataStoreWrite1' */
        TPCR_ac_DW.NeTPCR_Pct_WupSOC = VeTPCR_Pct_HVBatSOC;
    }

    /* End of Outputs for SubSystem: '<S895>/EnabledSubsystem' */

    /* Logic: '<S18>/Logical1' */
    VeTPCR_b_BothRdyForShtDwn = ((TPCR_ac_B.VeTPCC_b_RS_ThrmlRdyShtDwn_App1) &&
        (VeTPCC_b_PerWup_RdyShtDwn_BD));

    /* Logic: '<S18>/Logical2' */
    VeTPCR_b_BothCondWkUps = ((VeTPCR_b_HVBatPerWkUp) &&
        rtb_LogicalOperator1_kl_tmp);

    /* Logic: '<S18>/Logical4' */
    VeTPCR_b_ArbRdyForShtDwn = (((TPCR_ac_B.VeTPCC_b_RS_ThrmlRdyShtDwn_App1) ||
        (VeTPCC_b_PerWup_RdyShtDwn_BD)) || (VeTPCR_b_RdyForShtDwnDbnc_BattCond));

    /* Switch: '<S988>/Switch1' incorporates:
     *  Constant: '<S18>/FALSEConstant'
     *  Constant: '<S986>/Constant'
     *  Constant: '<S990>/Calib'
     *  Logic: '<S18>/Logical3'
     *  RelationalOperator: '<S18>/Comparison2'
     *  Switch: '<S18>/Switch'
     *  Switch: '<S987>/Switch1'
     */
    if (((uint32)rtb_Switch1_dk) == CeTPCR_e_Active)
    {
        VeTPCR_b_UnplugNoBattCond_SOC_t = false;
    }
    else if ((VeTPCR_b_BothCondWkUps) && (KeTPCR_b_EnblShtDwnChk))
    {
        /* Switch: '<S987>/Switch1' */
        VeTPCR_b_UnplugNoBattCond_SOC_t = VeTPCR_b_BothRdyForShtDwn;
    }
    else if (VeTPCR_b_CabPrecDny_BattCondLtch)
    {
        /* Switch: '<S18>/Switch' incorporates:
         *  Switch: '<S987>/Switch1'
         */
        VeTPCR_b_UnplugNoBattCond_SOC_t = VeTPCR_b_RdyForShtDwnDbnc_BattCond;
    }
    else
    {
        VeTPCR_b_UnplugNoBattCond_SOC_t = VeTPCR_b_ArbRdyForShtDwn;
    }

    /* End of Switch: '<S988>/Switch1' */

    /* Switch: '<S989>/Switch1' incorporates:
     *  Constant: '<S18>/FALSEConstant1'
     *  Logic: '<S18>/Logical7'
     *  Switch: '<S690>/Switch1'
     */
    if (rtb_LogicalOperator_h0 && rtb_VariantMerge_For_Variant__2)
    {
        rtb_LogicalOperator1_c = false;
    }
    else
    {
        rtb_LogicalOperator1_c = ((!VeTPCR_b_ComfortEnable) &&
            (VeTPCR_b_KHCRdyForShtDwn));
    }

    /* End of Switch: '<S989>/Switch1' */

    /* Logic: '<S18>/Logical6' */
    VeTPCR_b_FinRdyForShtDwn = (VeTPCR_b_UnplugNoBattCond_SOC_t ||
        rtb_LogicalOperator1_c);

    /* Update for UnitDelay: '<S4>/UnitDelay1' */
    TPCR_ac_DW.UnitDelay1_DSTATE_b = VeTPCR_b_FinRdyForShtDwn;

    /* Update for UnitDelay: '<S4>/UnitDelay2' incorporates:
     *  Switch: '<S15>/Switch'
     */
    TPCR_ac_DW.UnitDelay2_DSTATE_n = VeTPCR_e_SchCond_WakeUp;

    /* Update for UnitDelay: '<S612>/UnitDelay4' incorporates:
     *  Switch: '<S692>/Switch1'
     */
    TPCR_ac_DW.UnitDelay4_DSTATE_j = rtb_Switch1_dk;

    /* Update for UnitDelay: '<S518>/UnitDelay2' incorporates:
     *  Constant: '<S523>/Constant'
     *  RelationalOperator: '<S518>/Comparison1'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     */
    TPCR_ac_DW.UnitDelay2_DSTATE = (((uint32)VeTPCR_e_PMM_PowerMode_AD) !=
        CeSSDR_e_KeyOff);

    /* Update for UnitDelay: '<S519>/UnitDelay2' */
    TPCR_ac_DW.UnitDelay2_DSTATE_l = VeTPCR_b_PostCabinCond;

    /* Update for UnitDelay: '<S607>/UnitDelay3' */
    TPCR_ac_DW.UnitDelay3_DSTATE = rtb_VariantMerge_For_Variant__i;

    /* Update for UnitDelay: '<S607>/UnitDelay1' */
    TPCR_ac_DW.UnitDelay1_DSTATE_p = rtb_LogicalOperator_bpb;

    /* Update for UnitDelay: '<S608>/UnitDelay2' */
    TPCR_ac_DW.UnitDelay2_DSTATE_o = rtb_VariantMerge_For_Variant_So;

    /* Update for UnitDelay: '<S608>/UnitDelay1' */
    TPCR_ac_DW.UnitDelay1_DSTATE_c = rtb_LogicalOperator_bpb;

    /* Update for UnitDelay: '<S610>/UnitDelay2' */
    TPCR_ac_DW.UnitDelay2_DSTATE_g = rtb_VariantMerge_For_Variant_So;

    /* Update for UnitDelay: '<S610>/UnitDelay1' */
    TPCR_ac_DW.UnitDelay1_DSTATE_e = rtb_VariantMerge_For_Variant__i;

    /* Update for UnitDelay: '<S64>/UnitDelay4' */
    TPCR_ac_DW.UnitDelay4_DSTATE_lj = VeTPCR_b_RS_BattCondCmplt;

    /* Update for UnitDelay: '<S895>/UnitDelay1' */
    TPCR_ac_DW.UnitDelay1_DSTATE_d = rtb_VariantMerge_For_Variant__n;

    /* Update for UnitDelay: '<S895>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_di = rtb_AND_gq3;

    /* Update for UnitDelay: '<S1117>/UnitDelay4' */
    TPCR_ac_DW.UnitDelay4_DSTATE = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx;

    /* Outputs for Atomic SubSystem: '<S101>/TimerRetriggerResetTriggerEnabled' */
    /* Update for UnitDelay: '<S101>/UnitDelay' incorporates:
     *  Constant: '<S174>/ConstantValue2'
     *  Logic: '<S101>/Logical16'
     *  RelationalOperator: '<S174>/GreaterThan1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_bso = (rtb_Switch1_e4x <= 0.0F);

    /* End of Outputs for SubSystem: '<S101>/TimerRetriggerResetTriggerEnabled' */

    /* Outputs for Atomic SubSystem: '<S241>/TimerRetriggerResetEnabled3' */
    /* Update for UnitDelay: '<S241>/UnitDelay1' incorporates:
     *  Constant: '<S269>/ConstantValue2'
     *  Logic: '<S241>/Logical9'
     *  RelationalOperator: '<S269>/GreaterThan1'
     */
    TPCR_ac_DW.UnitDelay1_DSTATE_o = (rtb_Switch1_kc2 <= 0.0F);

    /* End of Outputs for SubSystem: '<S241>/TimerRetriggerResetEnabled3' */

    /* Update for UnitDelay: '<S241>/UnitDelay4' */
    TPCR_ac_DW.UnitDelay4_DSTATE_b = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx;

    /* Update for UnitDelay: '<S4>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_kj = VeTPCR_b_CabPrecDny_BattCondLtch;

    /* Update for UnitDelay: '<S194>/UnitDelay2' incorporates:
     *  Logic: '<S8>/Logical1'
     */
    TPCR_ac_DW.UnitDelay2_DSTATE_i = rtb_LogicalOperator_h0;

    /* Outputs for Atomic SubSystem: '<S104>/TimerRetriggerResetTriggerEnabled' */
    /* Update for UnitDelay: '<S104>/UnitDelay' incorporates:
     *  Constant: '<S195>/ConstantValue2'
     *  Logic: '<S104>/Logical4'
     *  RelationalOperator: '<S195>/GreaterThan1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_k0 = (rtb_Switch1_jb <= 0.0F);

    /* End of Outputs for SubSystem: '<S104>/TimerRetriggerResetTriggerEnabled' */

    /* Outputs for Atomic SubSystem: '<S98>/TimerRetriggerResetTriggerEnabled' */
    /* Update for UnitDelay: '<S98>/UnitDelay' incorporates:
     *  Constant: '<S138>/ConstantValue2'
     *  Logic: '<S98>/Logical6'
     *  RelationalOperator: '<S138>/GreaterThan1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_bx = (rtb_Switch1_ml1 <= 0.0F);

    /* End of Outputs for SubSystem: '<S98>/TimerRetriggerResetTriggerEnabled' */

    /* Outputs for Atomic SubSystem: '<S97>/TimerRetriggerResetTriggerEnabled' */
    /* Update for UnitDelay: '<S97>/UnitDelay' incorporates:
     *  Constant: '<S128>/ConstantValue2'
     *  Logic: '<S97>/Logical16'
     *  RelationalOperator: '<S128>/GreaterThan1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_br = (rtb_Switch1_l4 <= 0.0F);

    /* End of Outputs for SubSystem: '<S97>/TimerRetriggerResetTriggerEnabled' */

    /* Outputs for Atomic SubSystem: '<S100>/TimerRetriggerResetTriggerEnabled' */
    /* Update for UnitDelay: '<S100>/UnitDelay' incorporates:
     *  Constant: '<S164>/ConstantValue2'
     *  Logic: '<S100>/Logical16'
     *  RelationalOperator: '<S164>/GreaterThan1'
     */
    TPCR_ac_DW.UnitDelay_DSTATE_jgq = (rtb_Switch1_ko <= 0.0F);

    /* End of Outputs for SubSystem: '<S100>/TimerRetriggerResetTriggerEnabled' */

    /* Update for UnitDelay: '<S9>/UnitDelay1' */
    TPCR_ac_DW.UnitDelay1_DSTATE_pp = VeTPCR_b_KeyRunCheck;

    /* Update for UnitDelay: '<S612>/UnitDelay1' incorporates:
     *  UnitDelay: '<S612>/UnitDelay4'
     */
    TPCR_ac_DW.UnitDelay1_DSTATE_k = VeTPCR_e_KHCStatus;

    /* Update for UnitDelay: '<S519>/UnitDelay3' */
    TPCR_ac_DW.UnitDelay3_DSTATE_i = TPCR_ac_B.TmpSignalConversionAtTmpVM__m2t;

    /* Update for UnitDelay: '<S519>/UnitDelay1' incorporates:
     *  Constant: '<S543>/Constant'
     *  RelationalOperator: '<S519>/Comparison8'
     *  RelationalOperator: '<S607>/Comparison1'
     *  Switch: '<S1760>/Switch'
     */
    TPCR_ac_DW.UnitDelay1_DSTATE_n = (((uint32)VeTPCR_e_PMM_PowerMode_AD) !=
        CeSSDR_e_KeyOff);

    /* Update for UnitDelay: '<S520>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_iy = VeTPCR_b_HotEnableRequest;

    /* Update for UnitDelay: '<S19>/UnitDelay2' */
    TPCR_ac_DW.UnitDelay2_DSTATE_d = VeTPCR_b_WUpWaitBatCond_RSDndPrev;

    /* Update for UnitDelay: '<S19>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_cu = TPCR_ac_B.AND_b;

    /* Update for UnitDelay: '<S7>/UnitDelay' */
    TPCR_ac_DW.UnitDelay_DSTATE_i3 = rtb_OR1_d5;

    /* Update for UnitDelay: '<S19>/UnitDelay1' */
    TPCR_ac_DW.UnitDelay1_DSTATE_f = TPCR_ac_B.Merge5_b;

    /* Update for UnitDelay: '<S1124>/UnitDelay4' */
    TPCR_ac_DW.UnitDelay4_DSTATE_l = TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx;

    /* Update for UnitDelay: '<S1124>/UnitDelay1' */
    TPCR_ac_DW.UnitDelay1_DSTATE = VeTPCR_t_SchPrecTimer;

    /* Update for UnitDelay: '<S13>/UnitDelay5' incorporates:
     *  Constant: '<S714>/Constant'
     *  Constant: '<S715>/Constant'
     *  Constant: '<S725>/Calib'
     *  Constant: '<S726>/Calib'
     *  Constant: '<S731>/Calib'
     *  Constant: '<S732>/Calib'
     *  Constant: '<S733>/Calib'
     *  Constant: '<S734>/Calib'
     *  Constant: '<S739>/Calib'
     *  Logic: '<S13>/Logical'
     *  Logic: '<S13>/Logical1'
     *  Logic: '<S13>/Logical10'
     *  Logic: '<S13>/Logical11'
     *  Logic: '<S13>/Logical16'
     *  Logic: '<S13>/Logical2'
     *  Logic: '<S13>/Logical31'
     *  Logic: '<S13>/Logical33'
     *  RelationalOperator: '<S13>/Comparison'
     *  RelationalOperator: '<S13>/Comparison1'
     *  RelationalOperator: '<S13>/Comparison13'
     *  RelationalOperator: '<S13>/Comparison14'
     *  RelationalOperator: '<S13>/Comparison8'
     *  RelationalOperator: '<S13>/Comparison9'
     *  RelationalOperator: '<S519>/Comparison5'
     *  Sum: '<S13>/Sum'
     *  Switch: '<S1774>/Switch'
     */
    TPCR_ac_DW.UnitDelay5_DSTATE = ((((((((KeTPCR_b_EnblProCond) &&
        ((TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_i + KeTPCR_l_ProCondRngTol) >=
         ((float32)TPCR_ac_B.TmpSignalConversionAtTmpVM_F_l2))) &&
        ((TPCR_ac_B.TmpSignalConversionAtTmpVM_F_ok) &&
         (KeTPCR_b_ProCondBattAllChk))) &&
        ((TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_a > KeTPCR_P_DCChargingStation)
         && (TPCR_ac_B.TmpSignalConversionAtTmpVM_Fc_a !=
             KeTPCR_P_NoChargingStation))) && (((float32)
        TPCR_ac_B.TmpSignalConversionAtTmpVM_F_b4) != KeTPCR_t_TimeAtDestination))
        && ((((uint32)VeTPCR_e_TurtleMd) != CeDMDR_e_Turtle_Mode3) && (((uint32)
        VeTPCR_e_TurtleMd) != CeDMDR_e_Turtle_Mode4))) &&
        (TPCR_ac_B.TmpSignalConversionAtTmpVM__cvk)) &&
        ((((!TPCR_ac_B.TmpSignalConversionAtTmpVM_F_c5) &&
           (!TPCR_ac_B.TmpSignalConversionAtTmpVM_F_iz)) &&
          (!TPCR_ac_B.TmpSignalConversionAtTmpVM_F_h3)) ||
         (KeTPCR_b_ProCondFAChkDsbl)));

    /* Update for UnitDelay: '<S13>/UnitDelay6' */
    TPCR_ac_DW.UnitDelay6_DSTATE = rtb_Switch2_nq;

    /* Update for UnitDelay: '<S13>/UnitDelay7' */
    TPCR_ac_DW.UnitDelay7_DSTATE = rtb_Switch2_nq;

    /* Update for UnitDelay: '<S13>/UnitDelay8' */
    TPCR_ac_DW.UnitDelay8_DSTATE = rtb_Switch2_nq;

    /* Update for UnitDelay: '<S13>/UnitDelay9' */
    TPCR_ac_DW.UnitDelay9_DSTATE = rtb_Switch2_nq;

    /* Update for UnitDelay: '<S13>/UnitDelay1' */
    TPCR_ac_DW.UnitDelay1_DSTATE_no = rtb_Switch_e;

    /* Update for UnitDelay: '<S13>/UnitDelay2' */
    TPCR_ac_DW.UnitDelay2_DSTATE_os = rtb_Comparison1_pa;

    /* Update for UnitDelay: '<S13>/UnitDelay3' */
    TPCR_ac_DW.UnitDelay3_DSTATE_g = rtb_Switch_a5;

    /* Update for UnitDelay: '<S13>/UnitDelay4' */
    TPCR_ac_DW.UnitDelay4_DSTATE_bs = rtb_UnitDelay_jk;

    /* Update for Delay: '<S755>/Delay2' */
    TPCR_ac_DW.Delay2_DSTATE = rtb_Switch1_ox;

    /* Update for Delay: '<S755>/Delay' */
    TPCR_ac_DW.Delay_DSTATE = rtb_Switch1;

    /* Update for Delay: '<S755>/Delay3' */
    TPCR_ac_DW.Delay3_DSTATE[0] = TPCR_ac_DW.Delay3_DSTATE[1];
    TPCR_ac_DW.Delay3_DSTATE[1] = rtb_Switch1_ox;

    /* Update for Delay: '<S773>/Delay2' */
    TPCR_ac_DW.Delay2_DSTATE_o = rtb_Product1_d;

    /* Update for Delay: '<S773>/Delay' */
    TPCR_ac_DW.Delay_DSTATE_g = rtb_Vector_ap;

    /* Update for Delay: '<S773>/Delay3' */
    TPCR_ac_DW.Delay3_DSTATE_l[0] = TPCR_ac_DW.Delay3_DSTATE_l[1];
    TPCR_ac_DW.Delay3_DSTATE_l[1] = rtb_Product1_d;

    /* S-Function (fcgen): '<S1>/FcnCallGen' incorporates:
     *  SubSystem: '<S1>/TPCO_FUNC'
     */
    /* Switch: '<S1854>/Switch1' incorporates:
     *  Constant: '<S1853>/Calib'
     *  Switch: '<S1866>/Switch'
     *  Switch: '<S1880>/Switch'
     */
    if (KeTPCR_b_RU_Program_Selctd)
    {
        /* Switch: '<S1854>/Switch2' incorporates:
         *  Constant: '<S1887>/Calib'
         */
        if (KeTPCR_b_RdyForShtDwn_SD)
        {
            /* SignalConversion generated from: '<S1>/RdyForShtDwn' incorporates:
             *  Constant: '<S1885>/Calib'
             *  Outport: '<Root>/VeTPCR_b_RdyForShtDwn'
             */
            (void)Rte_Write_VeTPCR_b_RdyForShtDwn_Value(KeTPCR_b_RdyForShtDwn_D);
        }
        else
        {
            /* SignalConversion generated from: '<S1>/RdyForShtDwn' incorporates:
             *  Outport: '<Root>/VeTPCR_b_RdyForShtDwn'
             */
            (void)Rte_Write_VeTPCR_b_RdyForShtDwn_Value(VeTPCR_b_FinRdyForShtDwn);
        }

        /* End of Switch: '<S1854>/Switch2' */

        /* Switch: '<S1866>/Switch1' incorporates:
         *  Constant: '<S1911>/Calib'
         */
        if (KeTPCR_b_RSA_BatCrit_Msg3_SD)
        {
            /* SignalConversion generated from: '<S1>/RSA_BatCrit_Msg3' incorporates:
             *  Constant: '<S1910>/Calib'
             *  Outport: '<Root>/VeTPCR_b_RSA_BatCrit_Msg3'
             */
            (void)Rte_Write_VeTPCR_b_RSA_BatCrit_Msg3_Value
                (KeTPCR_b_RSA_BatCrit_Msg3_Dial);
        }
        else
        {
            /* SignalConversion generated from: '<S1>/RSA_BatCrit_Msg3' incorporates:
             *  Outport: '<Root>/VeTPCR_b_RSA_BatCrit_Msg3'
             */
            (void)Rte_Write_VeTPCR_b_RSA_BatCrit_Msg3_Value
                (VeTPCR_b_RmtStrtAbort_StrtVhclRq_BD);
        }

        /* End of Switch: '<S1866>/Switch1' */

        /* Switch: '<S1880>/Switch1' incorporates:
         *  Constant: '<S1939>/Calib'
         */
        if (KeTPCR_b_CabinPreCondReqStat_SD)
        {
            /* Switch: '<S1880>/Switch' incorporates:
             *  Constant: '<S1940>/Calib'
             */
            Switch_cl = KeTPCR_e_CabinPreCondReqStat_Dial;
        }
    }
    else
    {
        /* SignalConversion generated from: '<S1>/RdyForShtDwn' incorporates:
         *  Constant: '<S1886>/Calib'
         *  Outport: '<Root>/VeTPCR_b_RdyForShtDwn'
         */
        (void)Rte_Write_VeTPCR_b_RdyForShtDwn_Value
            (KeTPCR_b_RdyForShtDwn_Dum4BSG);

        /* SignalConversion generated from: '<S1>/RSA_BatCrit_Msg3' incorporates:
         *  Constant: '<S1912>/Calib'
         *  Outport: '<Root>/VeTPCR_b_RSA_BatCrit_Msg3'
         */
        (void)Rte_Write_VeTPCR_b_RSA_BatCrit_Msg3_Value
            (KeTPCR_b_RSA_StrtVhclRq_Dum4BSG);

        /* Switch: '<S1880>/Switch' incorporates:
         *  Constant: '<S1941>/Calib'
         */
        Switch_cl = KeTPCR_e_CabinPrecondSts_Dial_Dum4BSG;
    }

    /* End of Switch: '<S1854>/Switch1' */

    /* Switch: '<S1860>/Switch' incorporates:
     *  Constant: '<S1898>/Calib'
     */
    if (KeTPCR_b_BatPerWU_ThrmlCond_Timer_SD)
    {
        /* Outport: '<Root>/VeTPCR_t_BatPerWU_ThrmlCond_Timer' incorporates:
         *  Constant: '<S1899>/Calib'
         *  SignalConversion generated from: '<S1>/BatPerWU_ThrmlCond_Timer'
         */
        (void)Rte_Write_VeTPCR_t_BatPerWU_ThrmlCond_Timer_Value
            (KeTPCR_t_BatPerWU_ThrmlCond_Timer_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_t_BatPerWU_ThrmlCond_Timer' incorporates:
         *  SignalConversion generated from: '<S1>/BatPerWU_ThrmlCond_Timer'
         */
        (void)Rte_Write_VeTPCR_t_BatPerWU_ThrmlCond_Timer_Value
            (VeTPCC_t_BatPerWU_ThrmlCond_Timer_BD);
    }

    /* End of Switch: '<S1860>/Switch' */
    /* End of Outputs for S-Function (fcgen): '<S1>/FcnCallGen' */

    /* Outport: '<Root>/VeTPCR_e_CabinPreCondReqStat' incorporates:
     *  SignalConversion generated from: '<S1>/CabinPreCondReqStat'
     *  Switch: '<S1880>/Switch'
     */
    (void)Rte_Write_VeTPCR_e_CabinPreCondReqStat_Value(Switch_cl);

    /* S-Function (fcgen): '<S1>/FcnCallGen' incorporates:
     *  SubSystem: '<S1>/TPCO_FUNC'
     */
    /* Switch: '<S1858>/Switch' incorporates:
     *  Constant: '<S1895>/Calib'
     */
    if (KeTPCR_b_HtrOrEAC_FltRawPrst_SD)
    {
        /* Outport: '<Root>/VeTPCR_b_HtrOrEAC_FltRawPrst' incorporates:
         *  Constant: '<S1894>/Calib'
         *  SignalConversion generated from: '<S1>/HtrOrEAC_FltRawPrst'
         */
        (void)Rte_Write_VeTPCR_b_HtrOrEAC_FltRawPrst_Value
            (KeTPCR_b_HtrOrEAC_FltRawPrst_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_b_HtrOrEAC_FltRawPrst' incorporates:
         *  SignalConversion generated from: '<S1>/HtrOrEAC_FltRawPrst'
         */
        (void)Rte_Write_VeTPCR_b_HtrOrEAC_FltRawPrst_Value
            (VeTPCC_b_Htr_EAC_RawFlt);
    }

    /* End of Switch: '<S1858>/Switch' */

    /* Switch: '<S1857>/Switch' incorporates:
     *  Constant: '<S1893>/Calib'
     */
    if (KeTPCR_b_PerWpCond_BatTmpErr_SD)
    {
        /* Outport: '<Root>/VeTPCR_dT_PerWpCond_BatTmpErr' incorporates:
         *  Constant: '<S1892>/Calib'
         *  SignalConversion generated from: '<S1>/PerWpCond_BatTmpError'
         */
        (void)Rte_Write_VeTPCR_dT_PerWpCond_BatTmpErr_Value
            (KeTPCR_T_PerWpCond_BatTmpErr_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_dT_PerWpCond_BatTmpErr' incorporates:
         *  SignalConversion generated from: '<S1>/PerWpCond_BatTmpError'
         */
        (void)Rte_Write_VeTPCR_dT_PerWpCond_BatTmpErr_Value(TPCR_ac_B.Merge4);
    }

    /* End of Switch: '<S1857>/Switch' */

    /* Switch: '<S1856>/Switch' incorporates:
     *  Constant: '<S1891>/Calib'
     */
    if (KeTPCR_b_PerWpCond_EngTmpErr_SD)
    {
        /* Outport: '<Root>/VeTPCR_dT_PerWpCond_EngTmpErr' incorporates:
         *  Constant: '<S1890>/Calib'
         *  SignalConversion generated from: '<S1>/PerWpCond_EngTmpError'
         */
        (void)Rte_Write_VeTPCR_dT_PerWpCond_EngTmpErr_Value
            (KeTPCR_T_PerWpCond_EngTmpErr_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_dT_PerWpCond_EngTmpErr' incorporates:
         *  SignalConversion generated from: '<S1>/PerWpCond_EngTmpError'
         */
        (void)Rte_Write_VeTPCR_dT_PerWpCond_EngTmpErr_Value
            (TPCR_ac_B.OutportBufferForPerWpCond_Eng_i);
    }

    /* End of Switch: '<S1856>/Switch' */

    /* Switch: '<S1882>/Switch' incorporates:
     *  Constant: '<S1944>/Calib'
     *  Constant: '<S1945>/Calib'
     *  Merge: '<S19>/Merge3'
     */
    if (KeTPCR_b_PerWup_BattEngCond_St_SD)
    {
        rtb_Switch1_io = KeTPCR_e_PerWup_BattEngCond_St_Dial;
    }
    else
    {
        rtb_Switch1_io = TPCR_ac_B.Merge3_f;
    }

    /* Outport: '<Root>/VeTPCR_e_PerWup_BattEngCond_State' incorporates:
     *  SignalConversion generated from: '<S1>/PerWup_BattEngCondState'
     *  Switch: '<S1882>/Switch'
     */
    (void)Rte_Write_VeTPCR_e_PerWup_BattEngCond_State_Value(rtb_Switch1_io);

    /* Switch: '<S1855>/Switch' incorporates:
     *  Constant: '<S1889>/Calib'
     */
    if (KeTPCR_b_PeriodWup_Msg2_SD)
    {
        /* Outport: '<Root>/VeTPCR_b_PeriodWup_Msg2' incorporates:
         *  Constant: '<S1888>/Calib'
         *  SignalConversion generated from: '<S1>/Period_Wup_Msg'
         */
        (void)Rte_Write_VeTPCR_b_PeriodWup_Msg2_Value
            (KeTPCR_b_PeriodWup_Msg2_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_b_PeriodWup_Msg2' incorporates:
         *  SignalConversion generated from: '<S1>/Period_Wup_Msg'
         */
        (void)Rte_Write_VeTPCR_b_PeriodWup_Msg2_Value(VeTPCC_b_PeriodWup_Msg2);
    }

    /* End of Switch: '<S1855>/Switch' */

    /* Switch: '<S1881>/Switch' incorporates:
     *  Constant: '<S1942>/Calib'
     *  Constant: '<S1943>/Calib'
     *  Switch: '<S1109>/Switch1'
     */
    if (KeTPCR_b_ThrmPerWup_St_SD)
    {
        tmp_0 = KeTPCR_e_ThrmPerWup_St_Dial;
    }
    else
    {
        tmp_0 = VeTPCC_e_ThrmPerWup_State;
    }

    /* Outport: '<Root>/VeTPCR_e_ThrmPerWup_State' incorporates:
     *  SignalConversion generated from: '<S1>/Thrm_PerWup_State'
     *  Switch: '<S1881>/Switch'
     */
    (void)Rte_Write_VeTPCR_e_ThrmPerWup_State_Value(tmp_0);

    /* Switch: '<S1878>/Switch' incorporates:
     *  Constant: '<S1936>/Calib'
     */
    if (KeTPCR_b_RacePrepCurrentReq_SD)
    {
        /* Outport: '<Root>/VeTPCR_I_RacePrepCurrentLim' incorporates:
         *  Constant: '<S1935>/Calib'
         *  SignalConversion generated from: '<S1>/VeTPCR_I_RacePrepCurrentLim'
         */
        (void)Rte_Write_VeTPCR_I_RacePrepCurrentLim_Value
            (KeTPCR_I_RacePrepCurrentReq_D);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_I_RacePrepCurrentLim' incorporates:
         *  SignalConversion generated from: '<S1>/VeTPCR_I_RacePrepCurrentLim'
         */
        (void)Rte_Write_VeTPCR_I_RacePrepCurrentLim_Value(rtb_Sum4_l);
    }

    /* End of Switch: '<S1878>/Switch' */

    /* Switch: '<S1872>/Switch' incorporates:
     *  Constant: '<S1924>/Calib'
     */
    if (KeTPCR_b_RacePrep_SOCTrgt_SD)
    {
        /* Outport: '<Root>/VeTPCR_T_RacePrep_SOCTrgt' incorporates:
         *  Constant: '<S1923>/Calib'
         *  SignalConversion generated from: '<S1>/VeTPCR_Pct_RacePrep_SOCTrgt'
         */
        (void)Rte_Write_VeTPCR_T_RacePrep_SOCTrgt_Value
            (KeTPCR_Pct_RacePrep_SOCTrgt_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_T_RacePrep_SOCTrgt' incorporates:
         *  SignalConversion generated from: '<S1>/VeTPCR_Pct_RacePrep_SOCTrgt'
         */
        (void)Rte_Write_VeTPCR_T_RacePrep_SOCTrgt_Value(TPCR_ac_B.Merge3);
    }

    /* End of Switch: '<S1872>/Switch' */

    /* Switch: '<S1876>/Switch' incorporates:
     *  Constant: '<S1932>/Calib'
     */
    if (KeTPCR_b_CabTemp_SetPt_SD)
    {
        /* Outport: '<Root>/VeTPCR_T_CabinTempSetPt' incorporates:
         *  Constant: '<S1931>/Calib'
         *  SignalConversion generated from: '<S1>/VeTPCR_T_CabinTempSetPt'
         */
        (void)Rte_Write_VeTPCR_T_CabinTempSetPt_Value
            (KeTPCR_T_CabTemp_SetPt_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_T_CabinTempSetPt' incorporates:
         *  SignalConversion generated from: '<S1>/VeTPCR_T_CabinTempSetPt'
         */
        (void)Rte_Write_VeTPCR_T_CabinTempSetPt_Value(VeTPCR_T_CabSP);
    }

    /* End of Switch: '<S1876>/Switch' */

    /* Switch: '<S1870>/Switch' incorporates:
     *  Constant: '<S1920>/Calib'
     */
    if (KeTPCR_b_RacePrep_OverTmp_SD)
    {
        /* Outport: '<Root>/VeTPCR_T_RacePrep_ModulOverTmp' incorporates:
         *  Constant: '<S1919>/Calib'
         *  SignalConversion generated from: '<S1>/VeTPCR_T_RacePrep_ModulOverTemp'
         */
        (void)Rte_Write_VeTPCR_T_RacePrep_ModulOverTmp_Value
            (KeTPCR_T_RacePrep_OverTmp_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_T_RacePrep_ModulOverTmp' incorporates:
         *  SignalConversion generated from: '<S1>/VeTPCR_T_RacePrep_ModulOverTemp'
         */
        (void)Rte_Write_VeTPCR_T_RacePrep_ModulOverTmp_Value(TPCR_ac_B.Merge1);
    }

    /* End of Switch: '<S1870>/Switch' */

    /* Switch: '<S1871>/Switch' incorporates:
     *  Constant: '<S1922>/Calib'
     */
    if (KeTPCR_b_RacePrep_UnderTmp_SD)
    {
        /* Outport: '<Root>/VeTPCR_T_RacePrep_ModulUnderTmp' incorporates:
         *  Constant: '<S1921>/Calib'
         *  SignalConversion generated from: '<S1>/VeTPCR_T_RacePrep_ModulUnderTemp'
         */
        (void)Rte_Write_VeTPCR_T_RacePrep_ModulUnderTmp_Value
            (KeTPCR_T_RacePrep_UnderTmp_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_T_RacePrep_ModulUnderTmp' incorporates:
         *  SignalConversion generated from: '<S1>/VeTPCR_T_RacePrep_ModulUnderTemp'
         */
        (void)Rte_Write_VeTPCR_T_RacePrep_ModulUnderTmp_Value(TPCR_ac_B.Merge2);
    }

    /* End of Switch: '<S1871>/Switch' */

    /* Switch: '<S1875>/Switch' incorporates:
     *  Constant: '<S1930>/Calib'
     */
    if (KeTPCR_b_RacePrep_DeacTime_SD)
    {
        /* Outport: '<Root>/VeTPCR_T_RacePrep_ThrmlTrgt' incorporates:
         *  Constant: '<S1929>/Calib'
         *  SignalConversion generated from: '<S1>/VeTPCR_T_RacePrep_ThrmlTrgt'
         */
        (void)Rte_Write_VeTPCR_T_RacePrep_ThrmlTrgt_Value
            (KeTPCR_T_RacePrep_ThrmlTrgt_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_T_RacePrep_ThrmlTrgt' incorporates:
         *  SignalConversion generated from: '<S1>/VeTPCR_T_RacePrep_ThrmlTrgt'
         */
        (void)Rte_Write_VeTPCR_T_RacePrep_ThrmlTrgt_Value(TPCR_ac_B.Merge5);
    }

    /* End of Switch: '<S1875>/Switch' */

    /* Switch: '<S1863>/Switch' incorporates:
     *  Constant: '<S1905>/Calib'
     */
    if (KeTPCR_b_CabPrecDny_BattCond_SD)
    {
        /* Outport: '<Root>/VeTPCR_b_CabPrecDny_BattCond' incorporates:
         *  Constant: '<S1904>/Calib'
         *  SignalConversion generated from: '<S1>/VeTPCR_b_CabPrecDny_BattCond'
         */
        (void)Rte_Write_VeTPCR_b_CabPrecDny_BattCond_Value
            (KeTPCR_b_CabPrecDny_BattCond_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_b_CabPrecDny_BattCond' incorporates:
         *  SignalConversion generated from: '<S1>/VeTPCR_b_CabPrecDny_BattCond'
         */
        (void)Rte_Write_VeTPCR_b_CabPrecDny_BattCond_Value
            (VeTPCR_b_CabPrecDny_BattCondLtch);
    }

    /* End of Switch: '<S1863>/Switch' */

    /* Switch: '<S1865>/Switch' incorporates:
     *  Constant: '<S1908>/Calib'
     *  Constant: '<S1909>/Calib'
     *  Logic: '<S520>/Logical10'
     */
    if (KeTPCR_b_ClimateFail_SD)
    {
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = KeTPCR_b_ClimateFail_D;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S1>/TPCC_Controls' */
        VeTPCR_b_DoorAjarEnblLtch_Rst_t = ((VeTPCR_b_HotEnblReq_ClimateFail) ||
            (VeTPCR_b_CmftEnblReq_ClimateFail));

        /* End of Outputs for SubSystem: '<S1>/TPCC_Controls' */
    }

    /* End of Switch: '<S1865>/Switch' */
    /* End of Outputs for S-Function (fcgen): '<S1>/FcnCallGen' */

    /* Outport: '<Root>/VeTPCR_b_ClimateFail' incorporates:
     *  SignalConversion generated from: '<S1>/VeTPCR_b_ClimateFail'
     */
    (void)Rte_Write_VeTPCR_b_ClimateFail_Value(VeTPCR_b_DoorAjarEnblLtch_Rst_t);

    /* S-Function (fcgen): '<S1>/FcnCallGen' incorporates:
     *  SubSystem: '<S1>/TPCO_FUNC'
     */
    /* Switch: '<S1883>/Switch' incorporates:
     *  Constant: '<S1947>/Calib'
     */
    if (KeTPCR_b_KeyOffCabCond_SD)
    {
        /* Outport: '<Root>/VeTPCR_b_KeyOffCabCond' incorporates:
         *  Constant: '<S1946>/Calib'
         *  SignalConversion generated from: '<S1>/VeTPCR_b_KeyOffCabCond'
         */
        (void)Rte_Write_VeTPCR_b_KeyOffCabCond_Value(KeTPCR_b_KeyOffCabCond_D);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_b_KeyOffCabCond' incorporates:
         *  SignalConversion generated from: '<S1>/VeTPCR_b_KeyOffCabCond'
         */
        (void)Rte_Write_VeTPCR_b_KeyOffCabCond_Value(VeTPCR_b_PostCabinCond);
    }

    /* End of Switch: '<S1883>/Switch' */

    /* Switch: '<S1869>/Switch' incorporates:
     *  Constant: '<S1918>/Calib'
     */
    if (KeTPCR_b_AmbTempCheck_SD)
    {
        /* Outport: '<Root>/VeTPCR_b_RacePrepAmbCheck' incorporates:
         *  Constant: '<S1917>/Calib'
         *  SignalConversion generated from: '<S1>/VeTPCR_b_RacePrepAmbCheck'
         */
        (void)Rte_Write_VeTPCR_b_RacePrepAmbCheck_Value(KeTPCR_b_AmbTempCheck_D);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_b_RacePrepAmbCheck' incorporates:
         *  SignalConversion generated from: '<S1>/VeTPCR_b_RacePrepAmbCheck'
         */
        (void)Rte_Write_VeTPCR_b_RacePrepAmbCheck_Value(TPCR_ac_B.Logical5);
    }

    /* End of Switch: '<S1869>/Switch' */

    /* Switch: '<S1874>/Switch' incorporates:
     *  Constant: '<S1928>/Calib'
     */
    if (KeTPCR_b_RPMEVSystemStatus_SD)
    {
        /* Outport: '<Root>/VeTPCR_b_RacePrepEVSysStatus' incorporates:
         *  Constant: '<S1927>/Calib'
         *  SignalConversion generated from: '<S1>/VeTPCR_b_RacePrepEVSysStatus'
         */
        (void)Rte_Write_VeTPCR_b_RacePrepEVSysStatus_Value
            (KeTPCR_b_RPMEVSystemStatus_D);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_b_RacePrepEVSysStatus' incorporates:
         *  SignalConversion generated from: '<S1>/VeTPCR_b_RacePrepEVSysStatus'
         */
        (void)Rte_Write_VeTPCR_b_RacePrepEVSysStatus_Value(TPCR_ac_B.Logical1);
    }

    /* End of Switch: '<S1874>/Switch' */

    /* Switch: '<S1861>/Switch' incorporates:
     *  Constant: '<S1900>/Calib'
     *  Constant: '<S1901>/Calib'
     *  Switch: '<S15>/Switch'
     */
    if (KeTPCR_b_SCWakeUp_SD)
    {
        tmp_1 = KeTPCR_e_SCWakeUp_Dial;
    }
    else
    {
        tmp_1 = VeTPCR_e_SchCond_WakeUp;
    }

    /* Outport: '<Root>/VeTPCR_e_SC_WakeUp' incorporates:
     *  SignalConversion generated from: '<S1>/VeTPCR_b_SC_WakeUp'
     *  Switch: '<S1861>/Switch'
     */
    (void)Rte_Write_VeTPCR_e_SC_WakeUp_Value(tmp_1);

    /* Switch: '<S1867>/Switch' incorporates:
     *  Constant: '<S1913>/Calib'
     *  Constant: '<S1914>/Calib'
     *  Selector: '<S9>/Selector'
     */
    if (KeTPCR_b_CabReqMsg_SD)
    {
        Switch_cl = KeTPCR_e_CabReqMsg_Dial;
    }
    else
    {
        Switch_cl = VeTPCR_e_CabReqSt_MsgAftrMap;
    }

    /* Outport: '<Root>/VeTPCR_e_CabReqSt_Msgs' incorporates:
     *  SignalConversion generated from: '<S1>/VeTPCR_e_CabReqSt_Msgs'
     *  Switch: '<S1867>/Switch'
     */
    (void)Rte_Write_VeTPCR_e_CabReqSt_Msgs_Value(Switch_cl);

    /* Switch: '<S1879>/Switch' incorporates:
     *  Constant: '<S1937>/Calib'
     *  Constant: '<S1938>/Calib'
     *  Switch: '<S662>/Switch1'
     */
    if (KeTPCR_b_KeepHotColdHMI_SD)
    {
        tmp_2 = KeTPCR_e_KeepHotColdHMI_D;
    }
    else
    {
        tmp_2 = VeTPCR_e_KHCClusterMsg;
    }

    /* Outport: '<Root>/VeTPCR_e_KeepHotColdHMI' incorporates:
     *  SignalConversion generated from: '<S1>/VeTPCR_e_KeepHotColdHMI'
     *  Switch: '<S1879>/Switch'
     */
    (void)Rte_Write_VeTPCR_e_KeepHotColdHMI_Value(tmp_2);

    /* Switch: '<S1877>/Switch' incorporates:
     *  Constant: '<S1933>/Calib'
     *  Constant: '<S1934>/Calib'
     */
    if (KeTPCR_b_KeepHotColdSts_SD)
    {
        rtb_VariantMerge_For_Variant__1 = KeTPCR_e_KeepHotColdSts_D;
    }

    /* Outport: '<Root>/VeTPCR_e_KeepHotColdSts' incorporates:
     *  SignalConversion generated from: '<S1>/VeTPCR_e_KeepHotColdSts'
     *  Switch: '<S1877>/Switch'
     */
    (void)Rte_Write_VeTPCR_e_KeepHotColdSts_Value
        (rtb_VariantMerge_For_Variant__1);

    /* Switch: '<S1864>/Switch' incorporates:
     *  Constant: '<S1906>/Calib'
     *  Constant: '<S1907>/Calib'
     *  Switch: '<S720>/Switch1'
     */
    if (KeTPCR_b_ProactiveCondMode_SD)
    {
        tmp_3 = KeTPCR_e_ProactiveCondMode_D;
    }
    else
    {
        tmp_3 = Switch1_d;
    }

    /* Outport: '<Root>/VeTPCR_e_ProactiveCondMode' incorporates:
     *  SignalConversion generated from: '<S1>/VeTPCR_e_ProactiveCondMode'
     *  Switch: '<S1864>/Switch'
     */
    (void)Rte_Write_VeTPCR_e_ProactiveCondMode_Value(tmp_3);

    /* Switch: '<S1884>/Switch' incorporates:
     *  Constant: '<S1948>/Calib'
     *  Constant: '<S1949>/Calib'
     *  Constant: '<S707>/Constant'
     *  Constant: '<S716>/Constant'
     *  Constant: '<S717>/Constant'
     *  Logic: '<S13>/Logical6'
     *  RelationalOperator: '<S13>/Comparison10'
     *  RelationalOperator: '<S13>/Comparison7'
     *  Switch: '<S720>/Switch1'
     *  Switch: '<S722>/Switch1'
     *  Switch: '<S723>/Switch1'
     *  Switch: '<S724>/Switch1'
     */
    if (KeTPCR_b_ProactiveCondStat_SD)
    {
        tmp_4 = KeTPCR_e_ProactiveCondStat_D;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S1>/TPCC_Controls' */
        if ((((uint32)Switch1_d) == CeTPCR_e_ActiveProactiveCond) || (((uint32)
                Switch1_d) == CeTPCR_e_PassiveProativeCond))
        {
            /* Switch: '<S723>/Switch1' incorporates:
             *  Constant: '<S708>/Constant'
             */
            tmp_4 = CeTPCR_e_ProactiveCondOn;
        }
        else if (rtb_Switch2_nq)
        {
            /* Switch: '<S724>/Switch1' incorporates:
             *  Constant: '<S709>/Constant'
             *  Switch: '<S723>/Switch1'
             */
            tmp_4 = CeTPCR_e_ProactiveCondSPR;
        }
        else
        {
            tmp_4 = CeTPCR_e_ProactiveCondOff;
        }

        /* End of Outputs for SubSystem: '<S1>/TPCC_Controls' */
    }

    /* Outport: '<Root>/VeTPCR_e_ProactiveCondStat' incorporates:
     *  SignalConversion generated from: '<S1>/VeTPCR_e_ProactiveCondStat'
     *  Switch: '<S1884>/Switch'
     */
    (void)Rte_Write_VeTPCR_e_ProactiveCondStat_Value(tmp_4);

    /* Switch: '<S1868>/Switch' incorporates:
     *  Constant: '<S1915>/Calib'
     *  Constant: '<S1916>/Calib'
     *  Constant: '<S844>/Constant'
     *  Switch: '<S847>/Switch1'
     *  Switch: '<S848>/Switch1'
     */
    if (KeTPCR_b_RacePrepState_SD)
    {
        tmp_5 = KeTPCR_e_RacePrepState_D;
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S1>/TPCC_Controls' */
        if (rtb_NotEqual_p)
        {
            /* Switch: '<S849>/Switch1' incorporates:
             *  Constant: '<S843>/Constant'
             *  Constant: '<S845>/Constant'
             *  Logic: '<S755>/NOT1'
             *  Switch: '<S847>/Switch1'
             */
            if (!rtb_OR1_ksz)
            {
                tmp_5 = CeTPCR_e_RacePrepSPRDrag;
            }
            else
            {
                tmp_5 = CeTPCR_e_RacePrepActiveDrag;
            }

            /* End of Switch: '<S849>/Switch1' */
        }
        else if (rtb_Switch1_mw)
        {
            /* Switch: '<S850>/Switch1' incorporates:
             *  Constant: '<S842>/Constant'
             *  Constant: '<S846>/Constant'
             *  Logic: '<S773>/NOT1'
             *  Switch: '<S847>/Switch1'
             *  Switch: '<S848>/Switch1'
             */
            if (!rtb_Switch3_c2)
            {
                tmp_5 = CeTPCR_e_RacePrepSPRTrack;
            }
            else
            {
                tmp_5 = CeTPCR_e_RacePrepActiveTrack;
            }

            /* End of Switch: '<S850>/Switch1' */
        }
        else
        {
            tmp_5 = CeTPCR_e_NotRacePrep;
        }

        /* End of Outputs for SubSystem: '<S1>/TPCC_Controls' */
    }

    /* Outport: '<Root>/VeTPCR_e_RacePrepState' incorporates:
     *  SignalConversion generated from: '<S1>/VeTPCR_e_RacePrepState'
     *  Switch: '<S1868>/Switch'
     */
    (void)Rte_Write_VeTPCR_e_RacePrepState_Value(tmp_5);

    /* Switch: '<S1873>/Switch' incorporates:
     *  Constant: '<S1926>/Calib'
     */
    if (KeTPCR_b_RacePrep_DeacTime_SD)
    {
        /* Outport: '<Root>/VeTPCR_t_RacePrep_DeacTime' incorporates:
         *  Constant: '<S1925>/Calib'
         *  SignalConversion generated from: '<S1>/VeTPCR_t_RacePrep_DeacTime'
         */
        (void)Rte_Write_VeTPCR_t_RacePrep_DeacTime_Value
            (KeTPCR_t_RacePrep_DeacTime_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_t_RacePrep_DeacTime' incorporates:
         *  SignalConversion generated from: '<S1>/VeTPCR_t_RacePrep_DeacTime'
         */
        (void)Rte_Write_VeTPCR_t_RacePrep_DeacTime_Value(rtb_Subtraction_p);
    }

    /* End of Switch: '<S1873>/Switch' */

    /* Switch: '<S1859>/Switch' incorporates:
     *  Constant: '<S1896>/Calib'
     */
    if (KeTPCR_b_PrecTimer_SD)
    {
        /* Outport: '<Root>/VeTPCR_t_SC_PrecTimer' incorporates:
         *  Constant: '<S1897>/Calib'
         *  SignalConversion generated from: '<S1>/VeTPCR_t_SC_PrecTimer'
         */
        (void)Rte_Write_VeTPCR_t_SC_PrecTimer_Value(KeTPCR_t_PrecTimer_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_t_SC_PrecTimer' incorporates:
         *  SignalConversion generated from: '<S1>/VeTPCR_t_SC_PrecTimer'
         */
        (void)Rte_Write_VeTPCR_t_SC_PrecTimer_Value(VeTPCR_t_SchPrecTimer);
    }

    /* End of Switch: '<S1859>/Switch' */

    /* Switch: '<S1862>/Switch' incorporates:
     *  Constant: '<S1902>/Calib'
     */
    if (KeTPCR_b_TimeToDeparture_SD)
    {
        /* Outport: '<Root>/VeTPCR_t_TimeToDeparture' incorporates:
         *  Constant: '<S1903>/Calib'
         *  SignalConversion generated from: '<S1>/VeTPCR_t_TimeToDeparture'
         */
        (void)Rte_Write_VeTPCR_t_TimeToDeparture_Value
            (KeTPCR_t_TimeToDeparture_Dial);
    }
    else
    {
        /* Outport: '<Root>/VeTPCR_t_TimeToDeparture' incorporates:
         *  SignalConversion generated from: '<S1>/VeTPCR_t_TimeToDeparture'
         */
        (void)Rte_Write_VeTPCR_t_TimeToDeparture_Value
            (TPCR_ac_B.TmpSignalConversionAtTmpVM_F_nx);
    }

    /* End of Switch: '<S1862>/Switch' */
    /* End of Outputs for S-Function (fcgen): '<S1>/FcnCallGen' */
    /* End of Outputs for SubSystem: '<Root>/TPCR_MedTEH' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */
#endif

}

#endif

/* Output function */
FUNC(void, TPCR_CODE) TPCR_PwrOff(void)
{
    /* RootInportFunctionCallGenerator generated from: '<Root>/PwrOff' incorporates:
     *  SubSystem: '<Root>/TPCR_PwrOff'
     */
    /* Outport: '<Root>/NeTPCR_b_RS_CabPrecDeny_Prev_PM_Out' incorporates:
     *  DataStoreRead: '<S2>/NeTPCR_b_RS_CabPrecDeny_Prev'
     */
    (void)Rte_Write_NeTPCR_b_RS_CabPrecDeny_Prev_NeTPCR_b_RS_CabPrecDeny_Prev
        (TPCR_ac_DW.NeTPCR_b_RS_CabPrecDeny_Prev);

    /* Outport: '<Root>/NeTPCR_b_HoldCabPrecFailLtch_PM_Out' incorporates:
     *  DataStoreRead: '<S2>/NeTPCR_b_HoldCabPrecFailLtch'
     */
    (void)Rte_Write_NeTPCR_b_HoldCabPrecFailLtch_NeTPCR_b_HoldCabPrecFailLtch
        (TPCR_ac_DW.NeTPCR_b_HoldCabPrecFailLtch);

    /* Outport: '<Root>/EeTPCR_e_HoldClusterMsg_PM_Out' incorporates:
     *  DataStoreRead: '<S2>/EeTPCR_e_HoldClusterMsg'
     */
    (void)Rte_Write_EeTPCR_e_HoldClusterMsg_EeTPCR_e_HoldClusterMsg
        (EeTPCR_e_HoldClusterMsg);

    /* Outport: '<Root>/EeTPCR_e_HoldClusterMsg_KHC_PM_Out' incorporates:
     *  DataStoreRead: '<S2>/EeTPCR_e_HoldClusterMsg_KHC'
     */
    (void)Rte_Write_EeTPCR_e_HoldClusterMsg_KHC_EeTPCR_e_HoldClusterMsg_KHC
        (EeTPCR_e_HoldClusterMsg_KHC);

    /* Outport: '<Root>/NeTPCR_Pct_WupSOC_PM_Out' incorporates:
     *  DataStoreRead: '<S2>/NeTPCR_Pct_WupSOC'
     */
    (void)Rte_Write_NeTPCR_Pct_WupSOC_NeTPCR_Pct_WupSOC
        (TPCR_ac_DW.NeTPCR_Pct_WupSOC);

    /* Outport: '<Root>/NeTPCR_b_12VloadShed_PM_Out' incorporates:
     *  DataStoreRead: '<S2>/NeTPCR_b_12VloadShed'
     */
    (void)Rte_Write_NeTPCR_b_12VloadShed_NeTPCR_b_12VloadShed
        (TPCR_ac_DW.NeTPCR_b_12VloadShed);

    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/PwrOff' */
}

/* Output function */
FUNC(void, TPCR_CODE) TPCR_PwrOn(void)
{
    /* RootInportFunctionCallGenerator generated from: '<Root>/PwrOn' incorporates:
     *  SubSystem: '<Root>/TPCR_PwrOn'
     */
    /* S-Function (fcgen): '<S3>/FcnCallGen' incorporates:
     *  SubSystem: '<S3>/DSM_Init'
     */
    /* DataStoreWrite: '<S1950>/NeTPCR_b_12VloadShed' incorporates:
     *  Inport: '<Root>/NeTPCR_b_12VloadShed_PM_In'
     */
    (void)Rte_Read_NeTPCR_b_12VloadShed_Rx_NeTPCR_b_12VloadShed
        (&TPCR_ac_DW.NeTPCR_b_12VloadShed);

    /* DataStoreWrite: '<S1950>/NeTPCR_Pct_WupSOC' incorporates:
     *  Inport: '<Root>/NeTPCR_Pct_WupSOC_PM_In'
     */
    (void)Rte_Read_NeTPCR_Pct_WupSOC_Rx_NeTPCR_Pct_WupSOC
        (&TPCR_ac_DW.NeTPCR_Pct_WupSOC);

    /* DataStoreWrite: '<S1950>/EeTPCR_e_HoldClusterMsg_KHC' incorporates:
     *  Inport: '<Root>/EeTPCR_e_HoldClusterMsg_KHC_PM_In'
     */
    (void)Rte_Read_EeTPCR_e_HoldClusterMsg_KHC_Rx_EeTPCR_e_HoldClusterMsg_KHC
        ((&(EeTPCR_e_HoldClusterMsg_KHC)));

    /* DataStoreWrite: '<S1950>/EeTPCR_e_HoldClusterMsg' incorporates:
     *  Inport: '<Root>/EeTPCR_e_HoldClusterMsg_PM_In'
     */
    (void)Rte_Read_EeTPCR_e_HoldClusterMsg_Rx_EeTPCR_e_HoldClusterMsg
        ((&(EeTPCR_e_HoldClusterMsg)));

    /* DataStoreWrite: '<S1950>/NeTPCR_b_HoldCabPrecFailLtch' incorporates:
     *  Inport: '<Root>/NeTPCR_b_HoldCabPrecFailLtch_PM_In'
     */
    (void)Rte_Read_NeTPCR_b_HoldCabPrecFailLtch_Rx_NeTPCR_b_HoldCabPrecFailLtch(
        &TPCR_ac_DW.NeTPCR_b_HoldCabPrecFailLtch);

    /* DataStoreWrite: '<S1950>/NeTPCR_b_RS_CabPrecDeny_Prev' incorporates:
     *  Inport: '<Root>/NeTPCR_b_RS_CabPrecDeny_Prev_PM_In'
     */
    (void)Rte_Read_NeTPCR_b_RS_CabPrecDeny_Prev_Rx_NeTPCR_b_RS_CabPrecDeny_Prev(
        &TPCR_ac_DW.NeTPCR_b_RS_CabPrecDeny_Prev);

    /* SignalConversion generated from: '<S3>/AmbTempCheck' incorporates:
     *  SignalConversion generated from: '<S3>/BatPerWU_ThrmlCond_Timer'
     *  SignalConversion generated from: '<S3>/CabPrecDny_BattCond'
     *  SignalConversion generated from: '<S3>/CabReqSt_Msgs'
     *  SignalConversion generated from: '<S3>/CabinPreCondReqStat'
     *  SignalConversion generated from: '<S3>/CabinTempSetPt'
     *  SignalConversion generated from: '<S3>/ClimateFail'
     *  SignalConversion generated from: '<S3>/DeactTime'
     *  SignalConversion generated from: '<S3>/HtrOrEAC_FltRawPrst'
     *  SignalConversion generated from: '<S3>/KeepHotColdHMI'
     *  SignalConversion generated from: '<S3>/KeepHotColdSts'
     *  SignalConversion generated from: '<S3>/KeyOffCabCond'
     *  SignalConversion generated from: '<S3>/PerWpCond_BatTmpErr'
     *  SignalConversion generated from: '<S3>/PerWpCond_EngTmpErr'
     *  SignalConversion generated from: '<S3>/PerWpCond_ModulOverTemp'
     *  SignalConversion generated from: '<S3>/PerWup_BattEngCondState'
     *  SignalConversion generated from: '<S3>/Period_Wup_Msg'
     *  SignalConversion generated from: '<S3>/ProactiveCondMode'
     *  SignalConversion generated from: '<S3>/ProactiveCondStat'
     *  SignalConversion generated from: '<S3>/RPMEV_SystemStatus'
     *  SignalConversion generated from: '<S3>/RSA_BatCrit_Msg3'
     *  SignalConversion generated from: '<S3>/RacePrepState'
     *  SignalConversion generated from: '<S3>/RacePrep_CurrentLim'
     *  SignalConversion generated from: '<S3>/RacePrep_ModulUnderTemp'
     *  SignalConversion generated from: '<S3>/RacePrep_SOCTrgt'
     *  SignalConversion generated from: '<S3>/RacePrep_ThrmlTrgt'
     *  SignalConversion generated from: '<S3>/RdyForShtDwn'
     *  SignalConversion generated from: '<S3>/SC_PrecTimer'
     *  SignalConversion generated from: '<S3>/SC_WakeUp'
     *  SignalConversion generated from: '<S3>/Thrm_PerWup_State'
     *  SignalConversion generated from: '<S3>/TimeToDeparture'
     */
#if Rte_SysCon_Variant_TPCR_4

    /* Outputs for Function Call SubSystem: '<S3>/TPCO_NF' */
    /* DataTypeConversion: '<S1951>/DataTypeConversion' incorporates:
     *  Constant: '<S1979>/Calib'
     */
    TPCR_ac_B.DataTypeConversion = (float32)
        KeTPCR_t_BatPerWU_ThrmlCondTmr_NFdial;

    /* SignalConversion generated from: '<S1951>/Period_Wup_Msg' incorporates:
     *  Constant: '<S1964>/Calib'
     */
    TPCR_ac_B.OutportBufferForPeriod_Wup_Msg = KeTPCR_b_PeriodWup_Msg2_NFdial;

    /* SignalConversion generated from: '<S1951>/CabinPreCondReqStat' incorporates:
     *  Constant: '<S1970>/Calib'
     */
    TPCR_ac_B.OutportBufferForCabinPreCondReq =
        KeTPCR_e_CabinPreCondReqStat_NFdial;

    /* SignalConversion generated from: '<S1951>/RSA_BatCrit_Msg3' incorporates:
     *  Constant: '<S1959>/Calib'
     */
    TPCR_ac_B.OutportBufferForRSA_BatCrit_Msg = KeTPCR_b_BatCritMsg3_NFdial;

    /* SignalConversion generated from: '<S1951>/RdyForShtDwn' incorporates:
     *  Constant: '<S1966>/Calib'
     */
    TPCR_ac_B.OutportBufferForRdyForShtDwn = KeTPCR_b_RdyForShtDwn_NFdial;

    /* SignalConversion generated from: '<S1951>/Thrm_PerWup_State' incorporates:
     *  Constant: '<S1978>/Calib'
     */
    TPCR_ac_B.OutportBufferForThrm_PerWup_Sta = KeTPCR_e_ThrmPerWupState_NFdial;

    /* SignalConversion generated from: '<S1951>/PerWup_BattEngCondState' incorporates:
     *  Constant: '<S1973>/Calib'
     */
    TPCR_ac_B.OutportBufferForPerWup_BattEngC =
        KeTPCR_e_PerWup_BattEngCondSt_NFdial;

    /* SignalConversion generated from: '<S1951>/HtrOrEAC_FltRawPrst' incorporates:
     *  Constant: '<S1962>/Calib'
     */
    TPCR_ac_B.OutportBufferForHtrOrEAC_FltRaw =
        KeTPCR_b_HtrOrEAC_FltRawPrst_NFdial;

    /* SignalConversion generated from: '<S1951>/PerWpCond_EngTmpErr' incorporates:
     *  Constant: '<S1968>/Calib'
     */
    TPCR_ac_B.OutportBufferForPerWpCond_EngTm =
        KeTPCR_dT_PerWpCond_EngTmpErr_NFdial;

    /* SignalConversion generated from: '<S1951>/PerWpCond_BatTmpErr' incorporates:
     *  Constant: '<S1967>/Calib'
     */
    TPCR_ac_B.OutportBufferForPerWpCond_BatTm =
        KeTPCR_dT_PerWpCond_BatTmpErr_NFdial;

    /* SignalConversion generated from: '<S1951>/SC_PrecTimer' incorporates:
     *  Constant: '<S1981>/Calib'
     */
    TPCR_ac_B.OutportBufferForSC_PrecTimer = KeTPCR_t_PrecTimer_NFDial;

    /* SignalConversion generated from: '<S1951>/SC_WakeUp' incorporates:
     *  Constant: '<S1977>/Calib'
     */
    TPCR_ac_B.OutportBufferForSC_WakeUp = KeTPCR_e_SCWakeUp_NFDial;

    /* SignalConversion generated from: '<S1951>/TimeToDeparture' incorporates:
     *  Constant: '<S1982>/Calib'
     */
    TPCR_ac_B.OutportBufferForTimeToDeparture = KeTPCR_t_TimeToDeparture_NFDial;

    /* SignalConversion generated from: '<S1951>/CabPrecDny_BattCond' incorporates:
     *  Constant: '<S1960>/Calib'
     */
    TPCR_ac_B.OutportBufferForCabPrecDny_Batt =
        KeTPCR_b_CabPrecDny_BattCond_NFdial;

    /* SignalConversion generated from: '<S1951>/CabReqSt_Msgs' incorporates:
     *  Constant: '<S1969>/Calib'
     */
    TPCR_ac_B.OutportBufferForCabReqSt_Msgs = KeTPCR_e_CabReqSt_Msgs_NFDial;

    /* SignalConversion generated from: '<S1951>/KeepHotColdSts' incorporates:
     *  Constant: '<S1972>/Calib'
     */
    TPCR_ac_B.OutportBufferForKeepHotColdSts = KeTPCR_e_KeepHotColdSts_NFdial;

    /* SignalConversion generated from: '<S1951>/KeepHotColdHMI' incorporates:
     *  Constant: '<S1971>/Calib'
     */
    TPCR_ac_B.OutportBufferForKeepHotColdHMI = KeTPCR_e_KeepHotColdHMI_NFdial;

    /* SignalConversion generated from: '<S1951>/KeyOffCabCond' incorporates:
     *  Constant: '<S1963>/Calib'
     */
    TPCR_ac_B.OutportBufferForKeyOffCabCond = KeTPCR_b_KeyOffCabCond_NFdial;

    /* SignalConversion generated from: '<S1951>/ProactiveCondStat' incorporates:
     *  Constant: '<S1975>/Calib'
     */
    TPCR_ac_B.OutportBufferForProactiveCondSt =
        KeTPCR_e_ProactiveCondStat_NFdial;

    /* SignalConversion generated from: '<S1951>/ProactiveCondMode' incorporates:
     *  Constant: '<S1974>/Calib'
     */
    TPCR_ac_B.OutportBufferForProactiveCondMo =
        KeTPCR_e_ProactiveCondMode_NFdial;

    /* SignalConversion generated from: '<S1951>/ClimateFail' incorporates:
     *  Constant: '<S1961>/Calib'
     */
    TPCR_ac_B.OutportBufferForClimateFail = KeTPCR_b_ClimateFail_NFdial;

    /* SignalConversion generated from: '<S1951>/RacePrepState' incorporates:
     *  Constant: '<S1976>/Calib'
     */
    TPCR_ac_B.OutportBufferForRacePrepState = KeTPCR_e_RacePrepState_NFdial;

    /* SignalConversion generated from: '<S1951>/AmbTempCheck' incorporates:
     *  Constant: '<S1958>/Calib'
     */
    TPCR_ac_B.OutportBufferForAmbTempCheck = KeTPCR_b_AmbTempCheck_NFdial;

    /* SignalConversion generated from: '<S1951>/RacePrep_ModulUnderTmp' incorporates:
     *  Constant: '<S1955>/Calib'
     */
    TPCR_ac_B.OutportBufferForRacePrep_ModulU =
        KeTPCR_T_RacePrep_ModulUnderTmp_NFdial;

    /* SignalConversion generated from: '<S1951>/RacePrep_ModulOverTmp' incorporates:
     *  Constant: '<S1954>/Calib'
     */
    TPCR_ac_B.OutportBufferForRacePrep_ModulO =
        KeTPCR_T_RacePrep_ModulOverTmp_NFdial;

    /* SignalConversion generated from: '<S1951>/RacePrep_SOCTrgt' incorporates:
     *  Constant: '<S1956>/Calib'
     */
    TPCR_ac_B.OutportBufferForRacePrep_SOCTrg = KeTPCR_T_RacePrep_SOCTrgt_NFdial;

    /* SignalConversion generated from: '<S1951>/RPMEV_System_Status' incorporates:
     *  Constant: '<S1965>/Calib'
     */
    TPCR_ac_B.OutportBufferForRPMEV_System_St =
        KeTPCR_b_RPMEVSystemStatus_NFDial;

    /* SignalConversion generated from: '<S1951>/RacePrep_ThrmlTrgt' incorporates:
     *  Constant: '<S1957>/Calib'
     */
    TPCR_ac_B.OutportBufferForRacePrep_ThrmlT =
        KeTPCR_T_RacePrep_ThrmlTrgt_NFdial;

    /* SignalConversion generated from: '<S1951>/DeactTime' incorporates:
     *  Constant: '<S1980>/Calib'
     */
    TPCR_ac_B.OutportBufferForDeactTime = KeTPCR_t_DeacTime_NFDial;

    /* SignalConversion generated from: '<S1951>/CabinTempSetPt' incorporates:
     *  Constant: '<S1952>/Calib'
     */
    TPCR_ac_B.OutportBufferForCabinTempSetPt = KeTPCR_T_CabTemp_SetPt_NFDial;

    /* SignalConversion generated from: '<S1951>/RacePrep_CurrentLim' incorporates:
     *  Constant: '<S1953>/Calib'
     */
    TPCR_ac_B.OutportBufferForRacePrep_Curren =
        KeTPCR_T_RacePrep_CurrentLim_NFdial;

    /* End of Outputs for SubSystem: '<S3>/TPCO_NF' */

    /* Outport: '<Root>/VeTPCR_b_RacePrepAmbCheck' */
    (void)Rte_Write_VeTPCR_b_RacePrepAmbCheck_Value
        (TPCR_ac_B.OutportBufferForAmbTempCheck);

    /* Outport: '<Root>/VeTPCR_t_BatPerWU_ThrmlCond_Timer' */
    (void)Rte_Write_VeTPCR_t_BatPerWU_ThrmlCond_Timer_Value
        (TPCR_ac_B.DataTypeConversion);

    /* Outport: '<Root>/VeTPCR_b_CabPrecDny_BattCond' */
    (void)Rte_Write_VeTPCR_b_CabPrecDny_BattCond_Value
        (TPCR_ac_B.OutportBufferForCabPrecDny_Batt);

    /* Outport: '<Root>/VeTPCR_e_CabReqSt_Msgs' incorporates:
     *  SignalConversion generated from: '<S1951>/CabReqSt_Msgs'
     */
    (void)Rte_Write_VeTPCR_e_CabReqSt_Msgs_Value
        (TPCR_ac_B.OutportBufferForCabReqSt_Msgs);

    /* Outport: '<Root>/VeTPCR_e_CabinPreCondReqStat' incorporates:
     *  SignalConversion generated from: '<S1951>/CabinPreCondReqStat'
     */
    (void)Rte_Write_VeTPCR_e_CabinPreCondReqStat_Value
        (TPCR_ac_B.OutportBufferForCabinPreCondReq);

    /* Outport: '<Root>/VeTPCR_T_CabinTempSetPt' */
    (void)Rte_Write_VeTPCR_T_CabinTempSetPt_Value
        (TPCR_ac_B.OutportBufferForCabinTempSetPt);

    /* Outport: '<Root>/VeTPCR_b_ClimateFail' */
    (void)Rte_Write_VeTPCR_b_ClimateFail_Value
        (TPCR_ac_B.OutportBufferForClimateFail);

    /* Outport: '<Root>/VeTPCR_t_RacePrep_DeacTime' */
    (void)Rte_Write_VeTPCR_t_RacePrep_DeacTime_Value
        (TPCR_ac_B.OutportBufferForDeactTime);

    /* Outport: '<Root>/VeTPCR_b_HtrOrEAC_FltRawPrst' */
    (void)Rte_Write_VeTPCR_b_HtrOrEAC_FltRawPrst_Value
        (TPCR_ac_B.OutportBufferForHtrOrEAC_FltRaw);

    /* Outport: '<Root>/VeTPCR_e_KeepHotColdHMI' incorporates:
     *  SignalConversion generated from: '<S1951>/KeepHotColdHMI'
     */
    (void)Rte_Write_VeTPCR_e_KeepHotColdHMI_Value
        (TPCR_ac_B.OutportBufferForKeepHotColdHMI);

    /* Outport: '<Root>/VeTPCR_e_KeepHotColdSts' incorporates:
     *  SignalConversion generated from: '<S1951>/KeepHotColdSts'
     */
    (void)Rte_Write_VeTPCR_e_KeepHotColdSts_Value
        (TPCR_ac_B.OutportBufferForKeepHotColdSts);

    /* Outport: '<Root>/VeTPCR_b_KeyOffCabCond' */
    (void)Rte_Write_VeTPCR_b_KeyOffCabCond_Value
        (TPCR_ac_B.OutportBufferForKeyOffCabCond);

    /* Outport: '<Root>/VeTPCR_dT_PerWpCond_BatTmpErr' */
    (void)Rte_Write_VeTPCR_dT_PerWpCond_BatTmpErr_Value
        (TPCR_ac_B.OutportBufferForPerWpCond_BatTm);

    /* Outport: '<Root>/VeTPCR_dT_PerWpCond_EngTmpErr' */
    (void)Rte_Write_VeTPCR_dT_PerWpCond_EngTmpErr_Value
        (TPCR_ac_B.OutportBufferForPerWpCond_EngTm);

    /* Outport: '<Root>/VeTPCR_T_RacePrep_ModulOverTmp' */
    (void)Rte_Write_VeTPCR_T_RacePrep_ModulOverTmp_Value
        (TPCR_ac_B.OutportBufferForRacePrep_ModulO);

    /* Outport: '<Root>/VeTPCR_e_PerWup_BattEngCond_State' incorporates:
     *  SignalConversion generated from: '<S1951>/PerWup_BattEngCondState'
     */
    (void)Rte_Write_VeTPCR_e_PerWup_BattEngCond_State_Value
        (TPCR_ac_B.OutportBufferForPerWup_BattEngC);

    /* Outport: '<Root>/VeTPCR_b_PeriodWup_Msg2' */
    (void)Rte_Write_VeTPCR_b_PeriodWup_Msg2_Value
        (TPCR_ac_B.OutportBufferForPeriod_Wup_Msg);

    /* Outport: '<Root>/VeTPCR_e_ProactiveCondMode' incorporates:
     *  SignalConversion generated from: '<S1951>/ProactiveCondMode'
     */
    (void)Rte_Write_VeTPCR_e_ProactiveCondMode_Value
        (TPCR_ac_B.OutportBufferForProactiveCondMo);

    /* Outport: '<Root>/VeTPCR_e_ProactiveCondStat' incorporates:
     *  SignalConversion generated from: '<S1951>/ProactiveCondStat'
     */
    (void)Rte_Write_VeTPCR_e_ProactiveCondStat_Value
        (TPCR_ac_B.OutportBufferForProactiveCondSt);

    /* Outport: '<Root>/VeTPCR_b_RacePrepEVSysStatus' */
    (void)Rte_Write_VeTPCR_b_RacePrepEVSysStatus_Value
        (TPCR_ac_B.OutportBufferForRPMEV_System_St);

    /* Outport: '<Root>/VeTPCR_b_RSA_BatCrit_Msg3' */
    (void)Rte_Write_VeTPCR_b_RSA_BatCrit_Msg3_Value
        (TPCR_ac_B.OutportBufferForRSA_BatCrit_Msg);

    /* Outport: '<Root>/VeTPCR_e_RacePrepState' incorporates:
     *  SignalConversion generated from: '<S1951>/RacePrepState'
     */
    (void)Rte_Write_VeTPCR_e_RacePrepState_Value
        (TPCR_ac_B.OutportBufferForRacePrepState);

    /* Outport: '<Root>/VeTPCR_I_RacePrepCurrentLim' */
    (void)Rte_Write_VeTPCR_I_RacePrepCurrentLim_Value
        (TPCR_ac_B.OutportBufferForRacePrep_Curren);

    /* Outport: '<Root>/VeTPCR_T_RacePrep_ModulUnderTmp' */
    (void)Rte_Write_VeTPCR_T_RacePrep_ModulUnderTmp_Value
        (TPCR_ac_B.OutportBufferForRacePrep_ModulU);

    /* Outport: '<Root>/VeTPCR_T_RacePrep_SOCTrgt' */
    (void)Rte_Write_VeTPCR_T_RacePrep_SOCTrgt_Value
        (TPCR_ac_B.OutportBufferForRacePrep_SOCTrg);

    /* Outport: '<Root>/VeTPCR_T_RacePrep_ThrmlTrgt' */
    (void)Rte_Write_VeTPCR_T_RacePrep_ThrmlTrgt_Value
        (TPCR_ac_B.OutportBufferForRacePrep_ThrmlT);

    /* Outport: '<Root>/VeTPCR_b_RdyForShtDwn' */
    (void)Rte_Write_VeTPCR_b_RdyForShtDwn_Value
        (TPCR_ac_B.OutportBufferForRdyForShtDwn);

    /* Outport: '<Root>/VeTPCR_t_SC_PrecTimer' */
    (void)Rte_Write_VeTPCR_t_SC_PrecTimer_Value
        (TPCR_ac_B.OutportBufferForSC_PrecTimer);

    /* Outport: '<Root>/VeTPCR_e_SC_WakeUp' incorporates:
     *  SignalConversion generated from: '<S1951>/SC_WakeUp'
     */
    (void)Rte_Write_VeTPCR_e_SC_WakeUp_Value(TPCR_ac_B.OutportBufferForSC_WakeUp);

    /* Outport: '<Root>/VeTPCR_e_ThrmPerWup_State' incorporates:
     *  SignalConversion generated from: '<S1951>/Thrm_PerWup_State'
     */
    (void)Rte_Write_VeTPCR_e_ThrmPerWup_State_Value
        (TPCR_ac_B.OutportBufferForThrm_PerWup_Sta);

    /* Outport: '<Root>/VeTPCR_t_TimeToDeparture' */
    (void)Rte_Write_VeTPCR_t_TimeToDeparture_Value
        (TPCR_ac_B.OutportBufferForTimeToDeparture);

    /* End of Outputs for S-Function (fcgen): '<S3>/FcnCallGen' */
#endif

    /* End of SignalConversion generated from: '<S3>/AmbTempCheck' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/PwrOn' */
}

/* Model initialize function */
FUNC(void, TPCR_CODE) TPCR_ac_Init(void)
{
    /* Start for DataStoreMemory: '<Root>/DSM_5' */
    TPCR_ac_DW.NeTPCR_Pct_WupSOC = 60.0F;

#if Rte_SysCon_Variant_TPCR_1

    /* SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */
    /* SystemInitialize for Function Call SubSystem: '<Root>/TPCR_MedTEH' */
    /* SystemInitialize for S-Function (fcgen): '<S1>/FcnCallGen' incorporates:
     *  SubSystem: '<S1>/TPCC_Controls'
     */
    /* Start for If: '<S19>/If' */
    TPCR_ac_DW.If_ActiveSubsystem = -1;

    /* SystemInitialize for IfAction SubSystem: '<S19>/Wup_WaitBatCond' */
    /* SystemInitialize for IfAction SubSystem: '<S1028>/Subsystem6' */
    /* SystemInitialize for Enabled SubSystem: '<S1657>/Subsystem2' */
    /* SystemInitialize for SignalConversion generated from: '<S1667>/Out1' incorporates:
     *  Outport: '<S1667>/Out1'
     */
    TPCR_ac_B.OutportBufferForOut1_b = true;

    /* End of SystemInitialize for SubSystem: '<S1657>/Subsystem2' */
    /* End of SystemInitialize for SubSystem: '<S1028>/Subsystem6' */

    /* SystemInitialize for IfAction SubSystem: '<S1028>/Subsystem1' */
    /* SystemInitialize for Enabled SubSystem: '<S1561>/Subsystem2' */
    /* SystemInitialize for SignalConversion generated from: '<S1568>/Out1' incorporates:
     *  Outport: '<S1568>/Out1'
     */
    TPCR_ac_B.OutportBufferForOut1 = true;

    /* End of SystemInitialize for SubSystem: '<S1561>/Subsystem2' */
    /* End of SystemInitialize for SubSystem: '<S1028>/Subsystem1' */
    /* End of SystemInitialize for SubSystem: '<S19>/Wup_WaitBatCond' */

    /* SystemInitialize for Enabled SubSystem: '<S8>/RemoteStart_States' */
    /* Start for If: '<S67>/If' */
    TPCR_ac_DW.If_ActiveSubsystem_j = -1;

    /* End of SystemInitialize for SubSystem: '<S8>/RemoteStart_States' */
    /* End of SystemInitialize for S-Function (fcgen): '<S1>/FcnCallGen' */
    /* End of SystemInitialize for SubSystem: '<Root>/TPCR_MedTEH' */
    /* End of SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/MedTEH' */
#endif

    /* SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/PwrOn' incorporates:
     *  SubSystem: '<Root>/TPCR_PwrOn'
     */
#if Rte_SysCon_Variant_TPCR_4

    /* SystemInitialize for S-Function (fcgen): '<S3>/FcnCallGen' */
    /* SystemInitialize for Function Call SubSystem: '<S3>/TPCO_NF' */
    /* SystemInitialize for SignalConversion generated from: '<S1951>/Period_Wup_Msg' incorporates:
     *  Constant: '<S1964>/Calib'
     */
    TPCR_ac_B.OutportBufferForPeriod_Wup_Msg = KeTPCR_b_PeriodWup_Msg2_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/CabinPreCondReqStat' incorporates:
     *  Constant: '<S1970>/Calib'
     */
    TPCR_ac_B.OutportBufferForCabinPreCondReq =
        KeTPCR_e_CabinPreCondReqStat_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/RSA_BatCrit_Msg3' incorporates:
     *  Constant: '<S1959>/Calib'
     */
    TPCR_ac_B.OutportBufferForRSA_BatCrit_Msg = KeTPCR_b_BatCritMsg3_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/RdyForShtDwn' incorporates:
     *  Constant: '<S1966>/Calib'
     */
    TPCR_ac_B.OutportBufferForRdyForShtDwn = KeTPCR_b_RdyForShtDwn_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/Thrm_PerWup_State' incorporates:
     *  Constant: '<S1978>/Calib'
     */
    TPCR_ac_B.OutportBufferForThrm_PerWup_Sta = KeTPCR_e_ThrmPerWupState_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/PerWup_BattEngCondState' incorporates:
     *  Constant: '<S1973>/Calib'
     */
    TPCR_ac_B.OutportBufferForPerWup_BattEngC =
        KeTPCR_e_PerWup_BattEngCondSt_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/HtrOrEAC_FltRawPrst' incorporates:
     *  Constant: '<S1962>/Calib'
     */
    TPCR_ac_B.OutportBufferForHtrOrEAC_FltRaw =
        KeTPCR_b_HtrOrEAC_FltRawPrst_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/PerWpCond_EngTmpErr' incorporates:
     *  Constant: '<S1968>/Calib'
     */
    TPCR_ac_B.OutportBufferForPerWpCond_EngTm =
        KeTPCR_dT_PerWpCond_EngTmpErr_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/PerWpCond_BatTmpErr' incorporates:
     *  Constant: '<S1967>/Calib'
     */
    TPCR_ac_B.OutportBufferForPerWpCond_BatTm =
        KeTPCR_dT_PerWpCond_BatTmpErr_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/SC_PrecTimer' incorporates:
     *  Constant: '<S1981>/Calib'
     */
    TPCR_ac_B.OutportBufferForSC_PrecTimer = KeTPCR_t_PrecTimer_NFDial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/SC_WakeUp' incorporates:
     *  Constant: '<S1977>/Calib'
     */
    TPCR_ac_B.OutportBufferForSC_WakeUp = KeTPCR_e_SCWakeUp_NFDial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/TimeToDeparture' incorporates:
     *  Constant: '<S1982>/Calib'
     */
    TPCR_ac_B.OutportBufferForTimeToDeparture = KeTPCR_t_TimeToDeparture_NFDial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/CabPrecDny_BattCond' incorporates:
     *  Constant: '<S1960>/Calib'
     */
    TPCR_ac_B.OutportBufferForCabPrecDny_Batt =
        KeTPCR_b_CabPrecDny_BattCond_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/CabReqSt_Msgs' incorporates:
     *  Constant: '<S1969>/Calib'
     */
    TPCR_ac_B.OutportBufferForCabReqSt_Msgs = KeTPCR_e_CabReqSt_Msgs_NFDial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/KeepHotColdSts' incorporates:
     *  Constant: '<S1972>/Calib'
     */
    TPCR_ac_B.OutportBufferForKeepHotColdSts = KeTPCR_e_KeepHotColdSts_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/KeepHotColdHMI' incorporates:
     *  Constant: '<S1971>/Calib'
     */
    TPCR_ac_B.OutportBufferForKeepHotColdHMI = KeTPCR_e_KeepHotColdHMI_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/KeyOffCabCond' incorporates:
     *  Constant: '<S1963>/Calib'
     */
    TPCR_ac_B.OutportBufferForKeyOffCabCond = KeTPCR_b_KeyOffCabCond_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/ProactiveCondStat' incorporates:
     *  Constant: '<S1975>/Calib'
     */
    TPCR_ac_B.OutportBufferForProactiveCondSt =
        KeTPCR_e_ProactiveCondStat_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/ProactiveCondMode' incorporates:
     *  Constant: '<S1974>/Calib'
     */
    TPCR_ac_B.OutportBufferForProactiveCondMo =
        KeTPCR_e_ProactiveCondMode_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/ClimateFail' incorporates:
     *  Constant: '<S1961>/Calib'
     */
    TPCR_ac_B.OutportBufferForClimateFail = KeTPCR_b_ClimateFail_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/RacePrepState' incorporates:
     *  Constant: '<S1976>/Calib'
     */
    TPCR_ac_B.OutportBufferForRacePrepState = KeTPCR_e_RacePrepState_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/AmbTempCheck' incorporates:
     *  Constant: '<S1958>/Calib'
     */
    TPCR_ac_B.OutportBufferForAmbTempCheck = KeTPCR_b_AmbTempCheck_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/RacePrep_ModulUnderTmp' incorporates:
     *  Constant: '<S1955>/Calib'
     */
    TPCR_ac_B.OutportBufferForRacePrep_ModulU =
        KeTPCR_T_RacePrep_ModulUnderTmp_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/RacePrep_ModulOverTmp' incorporates:
     *  Constant: '<S1954>/Calib'
     */
    TPCR_ac_B.OutportBufferForRacePrep_ModulO =
        KeTPCR_T_RacePrep_ModulOverTmp_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/RacePrep_SOCTrgt' incorporates:
     *  Constant: '<S1956>/Calib'
     */
    TPCR_ac_B.OutportBufferForRacePrep_SOCTrg = KeTPCR_T_RacePrep_SOCTrgt_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/RPMEV_System_Status' incorporates:
     *  Constant: '<S1965>/Calib'
     */
    TPCR_ac_B.OutportBufferForRPMEV_System_St =
        KeTPCR_b_RPMEVSystemStatus_NFDial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/RacePrep_ThrmlTrgt' incorporates:
     *  Constant: '<S1957>/Calib'
     */
    TPCR_ac_B.OutportBufferForRacePrep_ThrmlT =
        KeTPCR_T_RacePrep_ThrmlTrgt_NFdial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/DeactTime' incorporates:
     *  Constant: '<S1980>/Calib'
     */
    TPCR_ac_B.OutportBufferForDeactTime = KeTPCR_t_DeacTime_NFDial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/CabinTempSetPt' incorporates:
     *  Constant: '<S1952>/Calib'
     */
    TPCR_ac_B.OutportBufferForCabinTempSetPt = KeTPCR_T_CabTemp_SetPt_NFDial;

    /* SystemInitialize for SignalConversion generated from: '<S1951>/RacePrep_CurrentLim' incorporates:
     *  Constant: '<S1953>/Calib'
     */
    TPCR_ac_B.OutportBufferForRacePrep_Curren =
        KeTPCR_T_RacePrep_CurrentLim_NFdial;

    /* End of SystemInitialize for SubSystem: '<S3>/TPCO_NF' */
    /* End of SystemInitialize for S-Function (fcgen): '<S3>/FcnCallGen' */
#endif

    /* End of SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/PwrOn' */

    /* SystemInitialize for Merge: '<Root>/Merge_1' incorporates:
     *  Merge: '<Root>/Merge_10'
     *  Merge: '<Root>/Merge_11'
     *  Merge: '<Root>/Merge_12'
     *  Merge: '<Root>/Merge_13'
     *  Merge: '<Root>/Merge_14'
     *  Merge: '<Root>/Merge_15'
     *  Merge: '<Root>/Merge_16'
     *  Merge: '<Root>/Merge_17'
     *  Merge: '<Root>/Merge_18'
     *  Merge: '<Root>/Merge_19'
     *  Merge: '<Root>/Merge_2'
     *  Merge: '<Root>/Merge_20'
     *  Merge: '<Root>/Merge_21'
     *  Merge: '<Root>/Merge_22'
     *  Merge: '<Root>/Merge_23'
     *  Merge: '<Root>/Merge_24'
     *  Merge: '<Root>/Merge_25'
     *  Merge: '<Root>/Merge_26'
     *  Merge: '<Root>/Merge_27'
     *  Merge: '<Root>/Merge_28'
     *  Merge: '<Root>/Merge_29'
     *  Merge: '<Root>/Merge_3'
     *  Merge: '<Root>/Merge_30'
     *  Merge: '<Root>/Merge_31'
     *  Merge: '<Root>/Merge_4'
     *  Merge: '<Root>/Merge_5'
     *  Merge: '<Root>/Merge_6'
     *  Merge: '<Root>/Merge_7'
     *  Merge: '<Root>/Merge_8'
     *  Merge: '<Root>/Merge_9'
     */
#if Rte_SysCon_Variant_TPCR_1 || Rte_SysCon_Variant_TPCR_4

    /* SystemInitialize for Outport: '<Root>/VeTPCR_e_CabinPreCondReqStat' */
    (void)Rte_Write_VeTPCR_e_CabinPreCondReqStat_Value(CeTPCR_e_CabinPrec_Dflt);

    /* SystemInitialize for Outport: '<Root>/VeTPCR_e_ThrmPerWup_State' */
    (void)Rte_Write_VeTPCR_e_ThrmPerWup_State_Value
        (CeTPCR_e_NoWup_Set_ShortTim_RS_Denied);

    /* SystemInitialize for Outport: '<Root>/VeTPCR_e_PerWup_BattEngCond_State' */
    (void)Rte_Write_VeTPCR_e_PerWup_BattEngCond_State_Value
        (CeTPCR_e_NoneOfEngBatt_Cond);

    /* SystemInitialize for Outport: '<Root>/VeTPCR_e_SC_WakeUp' */
    (void)Rte_Write_VeTPCR_e_SC_WakeUp_Value(CeTPCR_e_SC_NotAwake);

    /* SystemInitialize for Outport: '<Root>/VeTPCR_e_CabReqSt_Msgs' */
    (void)Rte_Write_VeTPCR_e_CabReqSt_Msgs_Value(CeTPCR_e_CabinPrec_Dflt);

    /* SystemInitialize for Outport: '<Root>/VeTPCR_e_KeepHotColdSts' */
    (void)Rte_Write_VeTPCR_e_KeepHotColdSts_Value(CeTPCR_e_NotActive);

    /* SystemInitialize for Outport: '<Root>/VeTPCR_e_KeepHotColdHMI' */
    (void)Rte_Write_VeTPCR_e_KeepHotColdHMI_Value(CeTPCR_e_NoRequest);

    /* SystemInitialize for Outport: '<Root>/VeTPCR_e_ProactiveCondStat' */
    (void)Rte_Write_VeTPCR_e_ProactiveCondStat_Value(CeTPCR_e_ProactiveCondOff);

    /* SystemInitialize for Outport: '<Root>/VeTPCR_e_ProactiveCondMode' */
    (void)Rte_Write_VeTPCR_e_ProactiveCondMode_Value(CeTPCR_e_NoProactiveCond);

    /* SystemInitialize for Outport: '<Root>/VeTPCR_e_RacePrepState' */
    (void)Rte_Write_VeTPCR_e_RacePrepState_Value(CeTPCR_e_NotRacePrep);

#endif

    /* End of SystemInitialize for Merge: '<Root>/Merge_1' */
}

/*
 * File trailer for generated code.
 *
 * [EOF]
 */
