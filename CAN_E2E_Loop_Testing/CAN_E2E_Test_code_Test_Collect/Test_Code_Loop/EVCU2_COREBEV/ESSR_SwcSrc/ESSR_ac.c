/*
 * File: ESSR_ac.c
 *
 * Code generated for Simulink model 'ESSR_ac'.
 *
 * Model version                  : 9.209
 * Simulink Coder version         : 9.4 (R2020b) 29-Jul-2020
 * C/C++ source code generated on : Fri Apr  5 13:43:14 2024
 *
 * Target selection: autosar.tlc
 * Embedded hardware selection: Freescale->MPC55xx
 * Emulation hardware selection:
 *    Differs from embedded hardware (Generic->MATLAB Host Computer)
 * Code generation objectives: Unspecified
 * Validation result: Not run
 */

#include "ESSR_ac.h"
#include "look1_iflf_binlcapw.h"
#include "look2_iflf_binlcapw.h"

/* Named constants for Chart: '<S13>/ESSC_EngStartStopSTM' */
#if Rte_SysCon_Variant_ESSR_Func
#define ESSR__IN_SpinUpFireEng_BumpStrt ((uint8)21U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_a_IN_SpinUpFireEng_12vStrt ((uint8)20U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_AchEngIdle          ((uint8)1U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_AchEngIdle_12vStrt  ((uint8)2U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_AchEngIdle_BumpStrt ((uint8)3U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_AchEngIdle_EMLowPwr ((uint8)4U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_CoastDown           ((uint8)1U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_ColdCrank           ((uint8)5U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_DisableFuel         ((uint8)1U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_ESSC_SpinUp_CS      ((uint8)6U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_ESSC_SpinUp_EM      ((uint8)7U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_ESSC_SpinUp_EMLowPwr ((uint8)8U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_ESSC_StartEng_CS    ((uint8)9U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_ESSC_StartEng_EM    ((uint8)10U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_EngOff              ((uint8)2U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_EngRunning          ((uint8)3U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_EngStartCtrl        ((uint8)4U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_EngStopCtrl         ((uint8)5U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_FinishStop          ((uint8)2U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_ImmedStop           ((uint8)6U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_InitEngSpin_1       ((uint8)11U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_InitEngSpin_2       ((uint8)12U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_InitEngSpin_3       ((uint8)13U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_InitEngSpin_4       ((uint8)14U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_InitEngSpin_5       ((uint8)15U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_InitEngSpin_6       ((uint8)16U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_InitEngSpin_7       ((uint8)17U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_NO_ACTIVE_CHILD     ((uint8)0U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_PrepForStop         ((uint8)3U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_RampDown            ((uint8)4U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_RestartPrep         ((uint8)18U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_SpinUpEng_SFS       ((uint8)19U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_SpinUpFireEng_CKS   ((uint8)22U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_StartEng            ((uint8)23U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_StartEngP1fLmt      ((uint8)24U)
#endif

#if Rte_SysCon_Variant_ESSR_Func
#define ESSR_ac_IN_StartEngPFS         ((uint8)25U)
#endif

/* user code (top of source file) */
/*
   PRODUCTION CONFIGURATION
 */

/* Exported data definition */
#define START_SEC_CALIB_UNSPECIFIED_ESSR
#include "MemMap.h"

/* Definition for custom storage class: FCALocalParameter */
#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HaESSR_b_DisableMtrA[29] =
{
    1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1,
    1, 1, 1
} ;                                    /* Referenced by: '<S3155>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HaESSR_b_HCPFuelDisable[15] =
{
    1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S3189>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HaESSR_b_HybProducingTorque[15] =
{
    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S3190>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HaESSR_b_OptimdEngOnOffCmd[15] =
{
    0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0
} ;                                    /* Referenced by: '<S3191>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_EngStrtType, ESSR_VAR_INIT)
    HaESSR_e_OptimdEngStrtStpType[15] =
{
    CeESSR_e_NoStrt, CeESSR_e_ImmedStop, CeESSR_e_AStrtNormal,
    CeESSR_e_AStrtNormal, CeESSR_e_EngTrqStrt, CeESSR_e_NoStrt,
    CeESSR_e_ControlledStop, CeESSR_e_ControlledStop, CeESSR_e_ImmedStop,
    CeESSR_e_CompressTst, CeESSR_e_NoStrt, CeESSR_e_NoStrt, CeESSR_e_NoStrt,
    CeESSR_e_NoStrt, CeESSR_e_NoStrt
};                                     /* Referenced by: '<S3192>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_12vBSGLowPwr = 1;/* Referenced by:
                                                                      * '<S13>/ESSC_EngStartStopSTM'
                                                                      * '<S823>/Calib'
                                                                      * '<S1249>/Calib'
                                                                      * '<S1289>/Calib'
                                                                      * '<S1405>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_12vStrtrEquipped = 1;/* Referenced by:
                                                                      * '<S13>/ESSC_EngStartStopSTM'
                                                                      * '<S374>/Calib'
                                                                      * '<S1038>/Calib'
                                                                      * '<S1123>/Calib'
                                                                      * '<S1150>/Calib'
                                                                      * '<S1159>/Calib'
                                                                      * '<S1166>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_48VEngStrtExitSpd = 1;/* Referenced by:
                                                                      * '<S627>/Calib'
                                                                      * '<S1915>/Calib'
                                                                      * '<S2120>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_AEMDMtrBGain = 0;/* Referenced by:
                                                                      * '<S471>/Calib'
                                                                      * '<S662>/Calib'
                                                                      * '<S1124>/Calib'
                                                                      * '<S1550>/Calib'
                                                                      * '<S2065>/Calib'
                                                                      * '<S2220>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_BumpStrtEquipped = 0;/* Referenced by:
                                                                      * '<S13>/ESSC_EngStartStopSTM'
                                                                      * '<S1039>/Calib'
                                                                      * '<S1125>/Calib'
                                                                      * '<S333>/Calib'
                                                                      * '<S1160>/Calib'
                                                                      * '<S1167>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_BypassNChkEngStall = 0;/* Referenced by: '<S195>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_CltchStrtEquipped = 0;/* Referenced by:
                                                                      * '<S13>/ESSC_EngStartStopSTM'
                                                                      * '<S256>/Calib'
                                                                      * '<S1126>/Calib'
                                                                      * '<S2583>/Calib'
                                                                      * '<S2811>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_DisableNi = 0;/* Referenced by:
                                                                      * '<S545>/Calib'
                                                                      * '<S1127>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_DisableNiSpeedMdECM = 0;/* Referenced by: '<S508>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_DtrmnEngRunExtra = 1;/* Referenced by:
                                                                      * '<S1905>/Calib'
                                                                      * '<S2365>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_DtrmnEngRunExtraPFS = 0;/* Referenced by:
                                                                      * '<S618>/Calib'
                                                                      * '<S2111>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_EnblEngStallEV = 1;/* Referenced by: '<S318>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_EnblLQRConfig = 1;/* Referenced by:
                                                                      * '<S1420>/Calib'
                                                                      * '<S2046>/Calib'
                                                                      * '<S2189>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_EnblMaxJerkSpinUp = 1;/* Referenced by:
                                                                      * '<S1488>/Calib'
                                                                      * '<S1803>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_EngStallReAttmpts = 1;/* Referenced by: '<S3156>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_EngStpEnbNiTrqMd = 0;/* Referenced by:
                                                                      * '<S2555>/Calib'
                                                                      * '<S2626>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_EngStrtTorq = 0;/* Referenced by:
                                                                      * '<S219>/Calib'
                                                                      * '<S297>/Calib'
                                                                      * '<S356>/Calib'
                                                                      * '<S540>/Calib'
                                                                      * '<S824>/Calib'
                                                                      * '<S1040>/Calib'
                                                                      * '<S1128>/Calib'
                                                                      * '<S1233>/Calib'
                                                                      * '<S1290>/Calib'
                                                                      * '<S1406>/Calib'
                                                                      * '<S1551>/Calib'
                                                                      * '<S1853>/Calib'
                                                                      * '<S2066>/Calib'
                                                                      * '<S2221>/Calib'
                                                                      * '<S2443>/Calib'
                                                                      * '<S2556>/Calib'
                                                                      * '<S2627>/Calib'
                                                                      * '<S2781>/Calib'
                                                                      * '<S2960>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_EngTrqOnlyCOM = 1;/* Referenced by:
                                                                      * '<S2464>/Calib'
                                                                      * '<S2812>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_InputAccelOverride = 0;/* Referenced by: '<S3182>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_LimphomeEnbl = 1;/* Referenced by:
                                                                      * '<S1041>/Calib'
                                                                      * '<S1456>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_NiDotLmt4JerkOvrdEnbl = 1;/* Referenced by:
                                                                      * '<S721>/Calib'
                                                                      * '<S1221>/Calib'
                                                                      * '<S1530>/Calib'
                                                                      * '<S1838>/Calib'
                                                                      * '<S2427>/Calib'
                                                                      * '<S2764>/Calib'
                                                                      * '<S2905>/Calib'
                                                                      * '<S439>/Calib'
                                                                      * '<S802>/Calib'
                                                                      * '<S1659>/Calib'
                                                                      * '<S1710>/Calib'
                                                                      * '<S2035>/Calib'
                                                                      * '<S2178>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_NiDotLmtBypsLoopJerk = 1;/* Referenced by:
                                                                      * '<S697>/Calib'
                                                                      * '<S1197>/Calib'
                                                                      * '<S1506>/Calib'
                                                                      * '<S1814>/Calib'
                                                                      * '<S2403>/Calib'
                                                                      * '<S2740>/Calib'
                                                                      * '<S2881>/Calib'
                                                                      * '<S415>/Calib'
                                                                      * '<S778>/Calib'
                                                                      * '<S1635>/Calib'
                                                                      * '<S1686>/Calib'
                                                                      * '<S2011>/Calib'
                                                                      * '<S2154>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_NiLmtBypsLoopJerk = 1;/* Referenced by:
                                                                      * '<S698>/Calib'
                                                                      * '<S1198>/Calib'
                                                                      * '<S1507>/Calib'
                                                                      * '<S1815>/Calib'
                                                                      * '<S2404>/Calib'
                                                                      * '<S2741>/Calib'
                                                                      * '<S2882>/Calib'
                                                                      * '<S416>/Calib'
                                                                      * '<S779>/Calib'
                                                                      * '<S1636>/Calib'
                                                                      * '<S1687>/Calib'
                                                                      * '<S2012>/Calib'
                                                                      * '<S2155>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_NiLmtForAccelByps = 0;/* Referenced by:
                                                                      * '<S699>/Calib'
                                                                      * '<S1199>/Calib'
                                                                      * '<S1508>/Calib'
                                                                      * '<S1816>/Calib'
                                                                      * '<S2405>/Calib'
                                                                      * '<S2742>/Calib'
                                                                      * '<S2883>/Calib'
                                                                      * '<S417>/Calib'
                                                                      * '<S780>/Calib'
                                                                      * '<S1637>/Calib'
                                                                      * '<S1688>/Calib'
                                                                      * '<S2013>/Calib'
                                                                      * '<S2156>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_NiPrfOptSpd = 0;/* Referenced by: '<S3183>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_NiTrgtIdleSpdSpnUp = 1;/* Referenced by: '<S1481>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_NiTrgtIdleSpdStrtEng = 0;/* Referenced by:
                                                                      * '<S2141>/Calib'
                                                                      * '<S1991>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_P2Equipped = 1;/* Referenced by: '<S196>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_PrepStpDisableNiSpeedMd =
    0;                                 /* Referenced by: '<S2782>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_RampMinStartTorq = 0;/* Referenced by:
                                                                      * '<S1938>/Calib'
                                                                      * '<S2197>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_ReevEquipped = 0;/* Referenced by: '<S1457>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_RmpDwnDisableNiSpeedMd =
    0;                                 /* Referenced by:
                                        * '<S2813>/Calib'
                                        * '<S2961>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_SpinupAirflwChkEnbl = 0;/* Referenced by: '<S1458>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_StrtEngSpeedMdECM = 0;/* Referenced by:
                                                                      * '<S2067>/Calib'
                                                                      * '<S2222>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) HeESSR_b_TrnstnJerkByps = 0;/* Referenced by:
                                                                      * '<S700>/Calib'
                                                                      * '<S1200>/Calib'
                                                                      * '<S1509>/Calib'
                                                                      * '<S1817>/Calib'
                                                                      * '<S2406>/Calib'
                                                                      * '<S2743>/Calib'
                                                                      * '<S2884>/Calib'
                                                                      * '<S418>/Calib'
                                                                      * '<S781>/Calib'
                                                                      * '<S1638>/Calib'
                                                                      * '<S1689>/Calib'
                                                                      * '<S2014>/Calib'
                                                                      * '<S2157>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) HeESSR_dn_NiDotLmt4JerkOvrdVal =
    20000.0F;                          /* Referenced by:
                                        * '<S722>/Calib'
                                        * '<S1222>/Calib'
                                        * '<S1531>/Calib'
                                        * '<S1839>/Calib'
                                        * '<S2428>/Calib'
                                        * '<S2765>/Calib'
                                        * '<S2906>/Calib'
                                        * '<S440>/Calib'
                                        * '<S803>/Calib'
                                        * '<S1660>/Calib'
                                        * '<S1711>/Calib'
                                        * '<S2036>/Calib'
                                        * '<S2179>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(TeESSR_e_EngStartStopSt, ESSR_VAR_INIT)
    HeESSR_e_StrtStpSt_TCMmax = CeESSR_e_ImmedStopSt;/* Referenced by: '<S3185>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(TeESSR_e_EngStartStopSt, ESSR_VAR_INIT)
    HeESSR_e_StrtStpSt_TCMmin = CeESSR_e_EngRunning;/* Referenced by: '<S3186>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_AStopCoastDwnEnbl1 = 0U;/* Referenced by: '<S126>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_AStopCoastDwnEnbl2 = 0U;/* Referenced by: '<S127>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_AStopEngCOMEnbl1 = 64U;/* Referenced by: '<S128>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_AStopEngCOMEnbl2 = 0U;/* Referenced by: '<S129>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_AStopReStrtPrepEnbl1 = 0U;/* Referenced by: '<S130>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_AStopReStrtPrepEnbl2 = 0U;/* Referenced by: '<S131>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_ClthErlyExitEnbl1 = 0U;/* Referenced by: '<S146>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_ClthErlyExitEnbl2 = 0U;/* Referenced by: '<S147>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_ClthLwrThresEnbl1 = 0U;/* Referenced by: '<S148>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_ClthLwrThresEnbl2 = 0U;/* Referenced by: '<S149>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_EMErlyExitEnbl1 = 0U;/* Referenced by: '<S152>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_EMErlyExitEnbl2 = 0U;/* Referenced by: '<S153>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_ErlyExitEnbl1 = 64U;/* Referenced by: '<S136>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_ErlyExitEnbl2 = 0U;/* Referenced by: '<S137>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_LwrThresEnbl1 = 0U;/* Referenced by: '<S138>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(uint32, ESSR_VAR_INIT) HeESSR_g_LwrThresEnbl2 = 0U;/* Referenced by: '<S139>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) HeESSR_t_MedTEB_dT = 0.01F;/* Referenced by:
                                                                      * '<S3196>/Calib'
                                                                      * '<S197>/Calib'
                                                                      * '<S257>/Calib'
                                                                      * '<S319>/Calib'
                                                                      * '<S375>/Calib'
                                                                      * '<S472>/Calib'
                                                                      * '<S517>/Calib'
                                                                      * '<S584>/Calib'
                                                                      * '<S676>/Calib'
                                                                      * '<S750>/Calib'
                                                                      * '<S852>/Calib'
                                                                      * '<S942>/Calib'
                                                                      * '<S1042>/Calib'
                                                                      * '<S1180>/Calib'
                                                                      * '<S1250>/Calib'
                                                                      * '<S1313>/Calib'
                                                                      * '<S1368>/Calib'
                                                                      * '<S1421>/Calib'
                                                                      * '<S1574>/Calib'
                                                                      * '<S1736>/Calib'
                                                                      * '<S1771>/Calib'
                                                                      * '<S1869>/Calib'
                                                                      * '<S2086>/Calib'
                                                                      * '<S2240>/Calib'
                                                                      * '<S2309>/Calib'
                                                                      * '<S2465>/Calib'
                                                                      * '<S2584>/Calib'
                                                                      * '<S2646>/Calib'
                                                                      * '<S2814>/Calib'
                                                                      * '<S2962>/Calib'
                                                                      * '<S339>/Calib'
                                                                      * '<S396>/Calib'
                                                                      * '<S485>/Calib'
                                                                      * '<S490>/Calib'
                                                                      * '<S528>/Calib'
                                                                      * '<S533>/Calib'
                                                                      * '<S642>/Calib'
                                                                      * '<S652>/Calib'
                                                                      * '<S759>/Calib'
                                                                      * '<S882>/Calib'
                                                                      * '<S904>/Calib'
                                                                      * '<S913>/Calib'
                                                                      * '<S991>/Calib'
                                                                      * '<S996>/Calib'
                                                                      * '<S1057>/Calib'
                                                                      * '<S1063>/Calib'
                                                                      * '<S1264>/Calib'
                                                                      * '<S1278>/Calib'
                                                                      * '<S1336>/Calib'
                                                                      * '<S1389>/Calib'
                                                                      * '<S1395>/Calib'
                                                                      * '<S1459>/Calib'
                                                                      * '<S1489>/Calib'
                                                                      * '<S1619>/Calib'
                                                                      * '<S1671>/Calib'
                                                                      * '<S1804>/Calib'
                                                                      * '<S1889>/Calib'
                                                                      * '<S1930>/Calib'
                                                                      * '<S1939>/Calib'
                                                                      * '<S1982>/Calib'
                                                                      * '<S2132>/Calib'
                                                                      * '<S2917>/Calib'
                                                                      * '<S628>/Calib'
                                                                      * '<S638>/Calib'
                                                                      * '<S1274>/Calib'
                                                                      * '<S1916>/Calib'
                                                                      * '<S1926>/Calib'
                                                                      * '<S2121>/Calib'
                                                                      * '<S2269>/Calib'
                                                                      * '<S2281>/Calib'
                                                                      * '<S2374>/Calib'
                                                                      * '<S2383>/Calib'
                                                                      * '<S2501>/Calib'
                                                                      * '<S2707>/Calib'
                                                                      * '<S2921>/Calib'
                                                                      * '<S970>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_Cnt_StrtTypInitSpinEndPnt
    [10] =
{
    0.5F, 0.7F, 0.5F, 0.3F, 0.3F, 0.3F, 0.5F, 0.3F, 0.3F, 0.3F
} ;                                    /* Referenced by:
                                        * '<S3022>/Calib'
                                        * '<S3112>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_M_StrtTypInitImmedTorq[10] =
{
    55.0F, 55.0F, 55.0F, 55.0F, 55.0F, 55.0F, 10.0F, 10.0F, 10.0F, 10.0F
} ;                                    /* Referenced by:
                                        * '<S3023>/Calib'
                                        * '<S3113>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_M_StrtTypInitPredTorq[10] =
{
    55.0F, 55.0F, 55.0F, 55.0F, 55.0F, 55.0F, 15.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3024>/Calib'
                                        * '<S3114>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KaESSR_M_StrtTypMinImmedExitTorqDelta[10] =
{
    999.0F, 999.0F, 999.0F, 999.0F, 999.0F, 999.0F, 999.0F, 999.0F, 999.0F,
    999.0F
} ;                                    /* Referenced by:
                                        * '<S3025>/Calib'
                                        * '<S3115>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_dn_StrtTypJerkMax[10] =
{
    900.0F, 900.0F, 900.0F, 900.0F, 900.0F, 900.0F, 900.0F, 900.0F, 900.0F,
    900.0F
} ;                                    /* Referenced by:
                                        * '<S3026>/Calib'
                                        * '<S3116>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_dn_StrtTypJerkMaxStartEng
    [10] =
{
    900.0F, 900.0F, 900.0F, 900.0F, 900.0F, 900.0F, 900.0F, 900.0F, 900.0F,
    900.0F
} ;                                    /* Referenced by:
                                        * '<S3027>/Calib'
                                        * '<S3117>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_dn_StrtTypJerkMin[10] =
{
    -750.0F, -750.0F, -750.0F, -750.0F, -750.0F, -750.0F, -750.0F, -750.0F,
    -750.0F, -750.0F
} ;                                    /* Referenced by:
                                        * '<S3028>/Calib'
                                        * '<S3118>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_dn_StrtTypJerkMinStartEng
    [10] =
{
    -750.0F, -750.0F, -750.0F, -750.0F, -750.0F, -750.0F, -750.0F, -750.0F,
    -750.0F, -750.0F
} ;                                    /* Referenced by:
                                        * '<S3029>/Calib'
                                        * '<S3119>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_dn_StrtTypNiDotMax[10] =
{
    4500.0F, 4500.0F, 4500.0F, 3500.0F, 5500.0F, 5500.0F, 3500.0F, 4500.0F,
    4500.0F, 4500.0F
} ;                                    /* Referenced by:
                                        * '<S3030>/Calib'
                                        * '<S3120>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_dn_StrtTypNiDotMax_EngStrt
    [10] =
{
    4500.0F, 4500.0F, 4500.0F, 3500.0F, 5500.0F, 5500.0F, 3500.0F, 4500.0F,
    4500.0F, 4500.0F
} ;                                    /* Referenced by:
                                        * '<S3031>/Calib'
                                        * '<S3121>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_dn_StrtTypNiDotMin[10] =
{
    -3000.0F, -3000.0F, -3000.0F, -3000.0F, -3000.0F, -3000.0F, -3000.0F,
    -3000.0F, -3000.0F, -3000.0F
} ;                                    /* Referenced by:
                                        * '<S3032>/Calib'
                                        * '<S3122>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_EngStrtType, ESSR_VAR_INIT)
    KaESSR_e_EngStrtTypeMap[18] =
{
    CeESSR_e_NoStrt, CeESSR_e_HybTrqStrt, CeESSR_e_EngTrqStrt,
    CeESSR_e_KeyCrnkLowPwrB, CeESSR_e_KeyCrnkGeneric, CeESSR_e_AStrtSmooth,
    CeESSR_e_AStrtNormal, CeESSR_e_AStrtAggrsv, CeESSR_e_AStrtGeneric,
    CeESSR_e_CompressTst, CeESSR_e_HybTrqStrt, CeESSR_e_NoStrt, CeESSR_e_NoStrt,
    CeESSR_e_AStrtReverse, CeESSR_e_AStrtCltchStrt, CeESSR_e_AStrtImpStrt,
    CeESSR_e_AStrtEMStrt, CeESSR_e_EngTrqStrt
};                                     /* Referenced by:
                                        * '<S199>/Calib'
                                        * '<S501>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TePTAR_e_ImmediateTorqRespType, ESSR_VAR_INIT)
    KaESSR_e_StrtStpType_TrqRspTypMap[18] =
{
    CePTAR_e_Inactive, CePTAR_e_Inactive, CePTAR_e_Inactive, CePTAR_e_Inactive,
    CePTAR_e_Inactive, CePTAR_e_Inactive, CePTAR_e_Inactive, CePTAR_e_Inactive,
    CePTAR_e_Inactive, CePTAR_e_Inactive, CePTAR_e_Inactive, CePTAR_e_Inactive,
    CePTAR_e_Inactive, CePTAR_e_Inactive, CePTAR_e_Inactive, CePTAR_e_Inactive,
    CePTAR_e_Inactive, CePTAR_e_Inactive
};                                     /* Referenced by: '<S3014>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_StrtType, ESSR_VAR_INIT)
    KaESSR_e_StrtTypeProfMap[18] =
{
    CeESSR_e_NoStart, CeESSR_e_AStrtAlgo, CeESSR_e_LowPwrAlgo,
    CeESSR_e_LowPwrAlgo, CeESSR_e_KeyCrnkAlgo, CeESSR_e_KeyCrnkAlgo,
    CeESSR_e_AStrtAlgo, CeESSR_e_AStrtAlgo, CeESSR_e_AStrtAlgo,
    CeESSR_e_AStrtAlgo, CeESSR_e_AStrtAlgo, CeESSR_e_NoStart, CeESSR_e_NoStart,
    CeESSR_e_AStrtAlgo, CeESSR_e_CltchStrtAlgo, CeESSR_e_ImplStrtAlgo,
    CeESSR_e_EMStrtAlgo, CeESSR_e_EMLwPwrStrtAlgo
};                                     /* Referenced by: '<S3015>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(TeESSR_e_TCM_StartStopType, ESSR_VAR_INIT)
    KaESSR_e_TCM_StartStopTypeMap[18] =
{
    CeESSR_e_NoAction, CeESSR_e_NormalStart, CeESSR_e_BumpStart,
    CeESSR_e_BumpStart, CeESSR_e_NormalStart, CeESSR_e_NormalStart,
    CeESSR_e_NormalStart, CeESSR_e_NormalStart, CeESSR_e_NormalStart,
    CeESSR_e_NormalStart, CeESSR_e_NormalStart, CeESSR_e_NormalStop,
    CeESSR_e_NormalStop, CeESSR_e_NormalStart, CeESSR_e_CltchStrt,
    CeESSR_e_CltchStrt, CeESSR_e_EMStrt, CeESSR_e_EMStrt
};                                     /* Referenced by: '<S3187>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_EngineState, ESSR_VAR_INIT)
    KaESSR_e_eTPU_TargetSyncStatus[29] =
{
    CeESSR_e_Stopped, CeESSR_e_Running, CeESSR_e_NoPstnMntr, CeESSR_e_Starting,
    CeESSR_e_Starting, CeESSR_e_Starting, CeESSR_e_Starting, CeESSR_e_Starting,
    CeESSR_e_Starting, CeESSR_e_Starting, CeESSR_e_Starting, CeESSR_e_Starting,
    CeESSR_e_NoPstnMntr, CeESSR_e_NoPstnMntr, CeESSR_e_Starting,
    CeESSR_e_Starting, CeESSR_e_Running, CeESSR_e_Running, CeESSR_e_Running,
    CeESSR_e_Starting, CeESSR_e_Starting, CeESSR_e_NoPstnMntr,
    CeESSR_e_NoPstnMntr, CeESSR_e_Stopping, CeESSR_e_Stopping, CeESSR_e_Stopping,
    CeESSR_e_Stopping, CeESSR_e_Stopping, CeESSR_e_Stopping
};                                     /* Referenced by: '<S3197>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(uint8, ESSR_VAR_INIT) KaESSR_i_OptInputSpdSelect[10] =
{
    0U, 1U, 2U, 1U, 2U, 2U, 2U, 2U, 2U, 2U
} ;                                    /* Referenced by: '<S26>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_k_StrtTypEngTorqReqFltT[10]
    =
{
    0.25F, 0.05F, 0.125F, 0.125F, 0.275F, 0.275F, 0.05F, 0.25F, 0.25F, 0.25F
} ;                                    /* Referenced by:
                                        * '<S3033>/Calib'
                                        * '<S3123>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KaESSR_k_StrtTypEngTorqReqImmedFltD[10] =
{
    0.8F, 0.8F, 0.98F, 0.98F, 0.8F, 0.8F, 0.98F, 0.85F, 0.85F, 0.85F
} ;                                    /* Referenced by:
                                        * '<S3034>/Calib'
                                        * '<S3124>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_k_StrtTypFrstOrdLwPassT[10]
    =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3035>/Calib'
                                        * '<S3125>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_k_StrtTypInitSpinScaler[10]
    =
{
    2.5F, 5.0F, 3.0F, 2.5F, 3.75F, 3.75F, 3.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3036>/Calib'
                                        * '<S3126>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_k_StrtTypScndOrdLwPassT[10]
    =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3037>/Calib'
                                        * '<S3127>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_n_StrtTypAStrtSpinUpExtSpd
    [10] =
{
    250.0F, 250.0F, 250.0F, 250.0F, 250.0F, 250.0F, 250.0F, 250.0F, 250.0F,
    250.0F
} ;                                    /* Referenced by:
                                        * '<S3038>/Calib'
                                        * '<S3128>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_n_StrtTypMaxStrtNiNoFuel[10]
    =
{
    5600.0F, 5600.0F, 5600.0F, 5600.0F, 5600.0F, 5600.0F, 5600.0F, 5600.0F,
    5600.0F, 5600.0F
} ;                                    /* Referenced by:
                                        * '<S3039>/Calib'
                                        * '<S3129>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_p_StrtTypMaxManPrs[10] =
{
    200.0F, 200.0F, 200.0F, 200.0F, 200.0F, 200.0F, 200.0F, 200.0F, 200.0F,
    200.0F
} ;                                    /* Referenced by:
                                        * '<S3040>/Calib'
                                        * '<S3130>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_phi_StrtTypInitSpinBrkAng
    [10] =
{
    11.0F, 5.0F, 5.0F, 5.0F, 5.0F, 5.0F, 11.0F, 5.0F, 5.0F, 5.0F
} ;                                    /* Referenced by:
                                        * '<S3041>/Calib'
                                        * '<S3131>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_phi_TgtEngParkAngle[8] =
{
    60.0F, 180.0F, 300.0F, 420.0F, 540.0F, 660.0F, 660.0F, 660.0F
} ;                                    /* Referenced by: '<S2615>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KaESSR_scl_StrtTypPulseCnclTorqScaler[10] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3042>/Calib'
                                        * '<S3132>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_t_StrtTypAirflowTrqMaxTm[10]
    =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S3043>/Calib'
                                        * '<S3133>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_t_StrtTypGasFlwActrDlyTm[10]
    =
{
    7.0F, 7.0F, 7.0F, 7.0F, 7.0F, 3.0F, 3.0F, 3.0F, 7.0F, 7.0F
} ;                                    /* Referenced by:
                                        * '<S3044>/Calib'
                                        * '<S3134>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_t_StrtTypManPrsTm[10] =
{
    1.0F, 0.0F, 1.0F, 0.125F, 0.125F, 0.125F, 1.0F, 0.75F, 0.75F, 0.75F
} ;                                    /* Referenced by:
                                        * '<S3045>/Calib'
                                        * '<S3135>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_t_StrtTypNiPredFilter[10] =
{
    0.25F, 0.25F, 0.25F, 0.25F, 0.25F, 0.25F, 0.25F, 0.25F, 0.25F, 0.25F
} ;                                    /* Referenced by:
                                        * '<S3046>/Calib'
                                        * '<S3136>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KaESSR_t_StrtTypPhaserDelayTm[10] =
{
    -1.0F, -1.0F, -1.0F, -1.0F, -1.0F, -1.0F, -1.0F, -1.0F, -1.0F, -1.0F
} ;                                    /* Referenced by:
                                        * '<S3047>/Calib'
                                        * '<S3137>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSD_b_P1C68_DF_Enbl = 0;/* Referenced by: '<S2486>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSD_b_P1C68_PFS_Enbl = 0;/* Referenced by: '<S2701>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSD_b_StrtStopDiagEnbl = 1;/* Referenced by: '<S3205>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(uint8, ESSR_VAR_INIT) KeESSR_Cnt_AStrtFailMaxAttmpts = 2U;/* Referenced by:
                                                                      * '<S590>/Calib'
                                                                      * '<S1877>/Calib'
                                                                      * '<S2093>/Calib'
                                                                      * '<S2246>/Calib'
                                                                      * '<S2318>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(uint16, ESSR_VAR_INIT) KeESSR_Cnt_AdptInitWord = 5555U;/* Referenced by:
                                                                      * '<S3293>/Calib'
                                                                      * '<S3295>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(uint8, ESSR_VAR_INIT) KeESSR_Cnt_BackupStrtMaxAttmpts = 1U;/* Referenced by:
                                                                      * '<S3157>/Calib'
                                                                      * '<S307>/Calib'
                                                                      * '<S357>/Calib'
                                                                      * '<S520>/Calib'
                                                                      * '<S1045>/Calib'
                                                                      * '<S1462>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(uint8, ESSR_VAR_INIT) KeESSR_Cnt_BumpStrtMaxAttmpts = 0U;/* Referenced by:
                                                                      * '<S3158>/Calib'
                                                                      * '<S308>/Calib'
                                                                      * '<S358>/Calib'
                                                                      * '<S521>/Calib'
                                                                      * '<S1046>/Calib'
                                                                      * '<S1463>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(uint8, ESSR_VAR_INIT) KeESSR_Cnt_CSSpinupMaxAttmpts = 10U;/* Referenced by: '<S1749>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(uint8, ESSR_VAR_INIT) KeESSR_Cnt_DelayOptNi = 1U;/* Referenced by:
                                                                      * '<S701>/Calib'
                                                                      * '<S1201>/Calib'
                                                                      * '<S1510>/Calib'
                                                                      * '<S1818>/Calib'
                                                                      * '<S2407>/Calib'
                                                                      * '<S2744>/Calib'
                                                                      * '<S2885>/Calib'
                                                                      * '<S419>/Calib'
                                                                      * '<S782>/Calib'
                                                                      * '<S1639>/Calib'
                                                                      * '<S1690>/Calib'
                                                                      * '<S2015>/Calib'
                                                                      * '<S2158>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(uint8, ESSR_VAR_INIT) KeESSR_Cnt_EMSpinupMaxAttmpts = 10U;/* Referenced by: '<S1790>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(uint8, ESSR_VAR_INIT) KeESSR_Cnt_EngCylTotal = 4U;/* Referenced by:
                                                                      * '<S2593>/Calib'
                                                                      * '<S2616>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(uint8, ESSR_VAR_INIT) KeESSR_Cnt_EngStallMaxReAttmpts = 2U;/* Referenced by:
                                                                      * '<S3159>/Calib'
                                                                      * '<S335>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_AStopTorqCancelGain =
    0.0F;                              /* Referenced by: '<S534>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_K_AchIdle12vStrtETRQEngCmdFlt = 0.08F;/* Referenced by: '<S756>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_K_AchIdle12vStrtNiClsdLoopEngCmdFlt = 0.08F;/* Referenced by: '<S760>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_K_AchIdleBumpStrtETRQEngCmdFlt = 0.5F;/* Referenced by: '<S857>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_AchIdleEngCmdFlt = 0.08F;/* Referenced by: '<S678>/Calib' */

#endif

#if (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func) || (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func)

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_BlendTitoTo = 0.1F;/* Referenced by:
                                                                      * '<S901>/Calib'
                                                                      * '<S2436>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_CCDropMtrAZeroPGain =
    0.3F;                              /* Referenced by: '<S951>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_CCFiltCoefD = 1.1F;/* Referenced by: '<S997>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_CCHoldTqPGain = 0.2F;/* Referenced by: '<S964>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_CCRunTqPGain = 0.3F;/* Referenced by: '<S952>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_CKSEcmTorqFactor = 0.75F;/* Referenced by: '<S1620>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_CKSSpdCtlPgain = 0.0F;/* Referenced by: '<S1594>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_EMBlendStartThresh = 0.8F;/* Referenced by: '<S2319>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_EMLPSBlendStartThresh =
    0.8F;                              /* Referenced by: '<S1373>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_EngSprkCtrl = 0.75F;/* Referenced by: '<S948>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_EngStartTargetTi = 0.5F;/* Referenced by: '<S3266>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_EngStrtPFSSpdCtlPgain =
    0.01F;                             /* Referenced by: '<S2192>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_EngStrtSpdCtlPgain =
    0.01F;                             /* Referenced by: '<S2054>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_EngStrtTrigFiltCoef =
    1.0F;                              /* Referenced by: '<S2993>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_EngTrqBlendHys = 0.1F;/* Referenced by: '<S858>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_EngTrqBlendThresh = 0.8F;/* Referenced by: '<S859>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_EngTrqReqImmedFltRP =
    0.2F;                              /* Referenced by: '<S1182>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_EngTrqReqPrdtFltRP = 0.2F;/* Referenced by: '<S1183>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_FinishStpFlt = 1.0F;/* Referenced by: '<S2594>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_FinishStpFltNoPark = 1.0F;/* Referenced by: '<S2595>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_MtrAEnblBlendHys = 0.1F;/* Referenced by: '<S887>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_MtrAEnblBlendThres = 0.8F;/* Referenced by: '<S888>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_NiDotLimEffInertia =
    3.6434E-6F;                        /* Referenced by:
                                        * '<S1492>/Calib'
                                        * '<S1993>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_P1fLmtSpdCtlIgain = 0.5F;/* Referenced by: '<S653>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_P1fLmtSpdCtlPgain = 2.0F;/* Referenced by: '<S654>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_P1fLmtWindupIgain = 0.5F;/* Referenced by: '<S655>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_SpinDwnAddtlTorq = 0.022F;/* Referenced by: '<S97>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_SpinUp12VSpdCtlIgain =
    0.5F;                              /* Referenced by: '<S1279>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_SpinUp12VSpdCtlPgain =
    2.0F;                              /* Referenced by: '<S1280>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_SpinUp12VWindupIgain =
    0.5F;                              /* Referenced by: '<S1281>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_SpinUpAddtlTorq = 0.0F;/* Referenced by: '<S105>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_SpinUpEMLPS_SpdCtlIgain =
    1.0F;                              /* Referenced by: '<S1396>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_SpinUpEMLPS_SpdCtlPgain =
    1.0F;                              /* Referenced by: '<S1397>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_SpinUpEMLPS_WindupIgain =
    0.5F;                              /* Referenced by: '<S1398>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_SpinUpEMSpdCtlPgain =
    0.05F;                             /* Referenced by: '<S1846>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_SpinUpSpdCtlPgain =
    -0.01F;                            /* Referenced by: '<S1539>/Calib' */

#endif

#if (!Rte_SysCon_Variant_ESSR_BlueNexus && !Rte_SysCon_Variant_ESSR_LQIR && Rte_SysCon_Variant_ESSR_Func) || (Rte_SysCon_Variant_ESSR_BlueNexus && Rte_SysCon_Variant_ESSR_Func) || (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func)

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_StartEngTiPredCoefMult =
    0.8F;                              /* Referenced by:
                                        * '<S2320>/Calib'
                                        * '<S1949>/Calib'
                                        * '<S1957>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_StrtEngCSTiPredCoefMult =
    1.2F;                              /* Referenced by: '<S2247>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_TiEstBlndAchIdle12vStrt =
    0.001F;                            /* Referenced by: '<S757>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_TiEstBlndDsblFuel = 0.95F;/* Referenced by: '<S2468>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_TiEstBlndEMspinup = 0.25F;/* Referenced by: '<S1774>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_TiEstBlndImdStp = 0.2F;/* Referenced by: '<S397>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_TiEstBlndP1fLmtd = 0.025F;/* Referenced by: '<S591>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_TiEstBlndPrepStp = 0.9F;/* Referenced by: '<S2649>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_TiEstBlndRestrt = 0.4F;/* Referenced by: '<S1184>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_TiEstBlndRmpDwn = 0.95F;/* Referenced by: '<S2818>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_TiEstBlndSFS = 0.125F;/* Referenced by:
                                                                      * '<S1424>/Calib'
                                                                      * '<S1738>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_TiEstBlndStrtEngPFS =
    0.4F;                              /* Referenced by: '<S2190>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_TitoEngTrqBlendHys = 0.1F;/* Referenced by: '<S2321>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_TitoEngTrqBlendThresh =
    0.8F;                              /* Referenced by: '<S2322>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_TitoZeroBlendHys = 0.09F;/* Referenced by: '<S2323>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_TitoZeroBlendThresh =
    0.2F;                              /* Referenced by: '<S2324>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_ToBlendHys = 0.09F;/* Referenced by: '<S860>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_ToBlendThresh = 0.2F;/* Referenced by: '<S861>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_K_TransInSpdFiltCoef = 1.0F;/* Referenced by: '<S27>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_AStopImmedTrqTgtCD =
    -50.0F;                            /* Referenced by: '<S220>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_AStopPrdtTrqTgt = -100.0F;/* Referenced by:
                                                                      * '<S2469>/Calib'
                                                                      * '<S2963>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_AStopPrdtdTrqTgtCD =
    -50.0F;                            /* Referenced by: '<S221>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_AchIdleBumpSpdCtlMinTi =
    -100.0F;                           /* Referenced by: '<S877>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_CCDragTorqInc = 15.0F;/* Referenced by: '<S980>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_CCEngFricHoldTq = -10.0F;/* Referenced by: '<S965>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_CCMaxDragIncTot = 100.0F;/* Referenced by: '<S972>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_CKSEngStartTorq = 180.0F;/* Referenced by: '<S1722>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_CKSSpdCtlMaxTi = 50.0F;/* Referenced by: '<S1595>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_CKSTiPrdtImmedDelta =
    10.0F;                             /* Referenced by: '<S1723>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_CoMTrqDeltaMax = 100.0F;/* Referenced by: '<S2650>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_ECMCmdDurOff = 0.0F;/* Referenced by: '<S298>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_EMLPSMtrBHys = 2.0F;/* Referenced by: '<S1374>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_EMLPSMtrBThres = 2.0F;/* Referenced by: '<S1375>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_EMStrtMtrBHys = 2.0F;/* Referenced by: '<S2325>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_EMStrtMtrBThres = 2.0F;/* Referenced by: '<S2326>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_EngOffEngPulseEngStrtTorq
    = 10.0F;                           /* Referenced by: '<S275>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_EngStrtPFSSpdCtlMinTi =
    -100.0F;                           /* Referenced by: '<S2193>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_EngStrtSpdCtlMaxTi =
    100.0F;                            /* Referenced by: '<S2055>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_EngStrtSpdCtlMinTi =
    -100.0F;                           /* Referenced by: '<S2056>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_EngStrtTrigInitTorq =
    -20.0F;                            /* Referenced by: '<S2994>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_EngTrqReqImmed_EMLPS =
    50.0F;                             /* Referenced by: '<S1407>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_EngTrqReqPrdtd_EMLPS =
    50.0F;                             /* Referenced by: '<S1408>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_MaxEngTorqError = 150.0F;/* Referenced by:
                                                                      * '<S619>/Calib'
                                                                      * '<S1906>/Calib'
                                                                      * '<S2112>/Calib'
                                                                      * '<S2366>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_MinEngReStrtTorqSnsd =
    -15.0F;                            /* Referenced by: '<S1907>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_MinEngRunTorq = 0.0F;/* Referenced by: '<S2651>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_MinEngStrtTorqSnsd =
    -15.0F;                            /* Referenced by:
                                        * '<S620>/Calib'
                                        * '<S1908>/Calib'
                                        * '<S2113>/Calib'
                                        * '<S2367>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_MinEngTorq = -40.0F;/* Referenced by: '<S452>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_MinReStartDetectTorq =
    -60.0F;                            /* Referenced by: '<S1941>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_MinStartDetectTorq =
    -60.0F;                            /* Referenced by:
                                        * '<S679>/Calib'
                                        * '<S753>/Calib'
                                        * '<S862>/Calib'
                                        * '<S2327>/Calib'
                                        * '<S1942>/Calib'
                                        * '<S2198>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_MinStartDetectTorqP1fLmt =
    15.0F;                             /* Referenced by: '<S592>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_MtrAMax_Default = 9999.0F;/* Referenced by:
                                                                      * '<S299>/Calib'
                                                                      * '<S359>/Calib'
                                                                      * '<S453>/Calib'
                                                                      * '<S541>/Calib'
                                                                      * '<S663>/Calib'
                                                                      * '<S734>/Calib'
                                                                      * '<S828>/Calib'
                                                                      * '<S1008>/Calib'
                                                                      * '<S1234>/Calib'
                                                                      * '<S1291>/Calib'
                                                                      * '<S1552>/Calib'
                                                                      * '<S1724>/Calib'
                                                                      * '<S2068>/Calib'
                                                                      * '<S2223>/Calib'
                                                                      * '<S2557>/Calib'
                                                                      * '<S2628>/Calib'
                                                                      * '<S2783>/Calib'
                                                                      * '<S2964>/Calib'
                                                                      * '<S907>/Calib'
                                                                      * '<S1148>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_MtrAMin_Default =
    -9999.0F;                          /* Referenced by:
                                        * '<S300>/Calib'
                                        * '<S360>/Calib'
                                        * '<S454>/Calib'
                                        * '<S542>/Calib'
                                        * '<S664>/Calib'
                                        * '<S735>/Calib'
                                        * '<S829>/Calib'
                                        * '<S1009>/Calib'
                                        * '<S1235>/Calib'
                                        * '<S1292>/Calib'
                                        * '<S1553>/Calib'
                                        * '<S1725>/Calib'
                                        * '<S2069>/Calib'
                                        * '<S2224>/Calib'
                                        * '<S2558>/Calib'
                                        * '<S2629>/Calib'
                                        * '<S2784>/Calib'
                                        * '<S2965>/Calib'
                                        * '<S916>/Calib'
                                        * '<S1149>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_NidotCalc_TiOvrrd = 0.0F;/* Referenced by: '<S3227>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_NidotCalc_ToOvrrd = 0.0F;/* Referenced by: '<S3228>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_RespTypeLSP = -20.0F;/* Referenced by: '<S1976>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_RespTypeRSP = 50.0F;/* Referenced by: '<S1977>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpinDwnInitOffst = 0.0F;/* Referenced by: '<S3296>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpinDwnMaxAddtl = 0.0F;/* Referenced by: '<S98>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpinDwnMaxOffst = -20.0F;/* Referenced by: '<S99>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpinDwnMinAddtl = 0.0F;/* Referenced by: '<S100>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpinDwnMinOffst = -20.0F;/* Referenced by: '<S101>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpinDwnOffstInc = 0.1F;/* Referenced by: '<S46>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpinUpInitOffst = 0.0F;/* Referenced by: '<S3297>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpinUpMaxAddtl = 15.0F;/* Referenced by: '<S106>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpinUpMaxOffst = 0.0F;/* Referenced by: '<S107>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpinUpMinAddtl = -15.0F;/* Referenced by: '<S108>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpinUpMinOffst = 0.0F;/* Referenced by: '<S109>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpinUpOffstInc = 0.1F;/* Referenced by: '<S47>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpinUpSpdCtlMaxTi = 0.0F;/* Referenced by: '<S1540>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpinUpSpdCtlMinTi =
    -100.0F;                           /* Referenced by: '<S1541>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpnDwnEngCLDeltaThres =
    0.5F;                              /* Referenced by: '<S48>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpnDwnTiMaxError = 0.5F;/* Referenced by: '<S49>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpnUpEngCLDeltaThres =
    0.5F;                              /* Referenced by: '<S50>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_SpnUpTiMaxError = 0.5F;/* Referenced by: '<S51>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_StrtEngCSEngTrqThrsh =
    35.0F;                             /* Referenced by: '<S2248>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_StrtEngCSMaxNegCltchTrq =
    100.0F;                            /* Referenced by: '<S2270>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_StrtEngCSMinStrtDtctTorq =
    20.0F;                             /* Referenced by: '<S2249>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_StrtEngCSTqExitDelta =
    10.0F;                             /* Referenced by: '<S2265>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_StrtEngTqExitDelta =
    50.0F;                             /* Referenced by:
                                        * '<S621>/Calib'
                                        * '<S1909>/Calib'
                                        * '<S2114>/Calib'
                                        * '<S2368>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_M_TiEstMinLimVal = 0.0F;/* Referenced by: '<S3239>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_P_CCBatMaxChrg = 8.0F;/* Referenced by: '<S1015>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_P_CCBatMaxDischrg = 9.0F;/* Referenced by: '<S1016>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_P_CCBatMinChrg = 2.0F;/* Referenced by: '<S1017>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_P_CCBatMinDischrg = 5.0F;/* Referenced by: '<S1018>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_P_DsblNiClsdLoopChrgLmt =
    -3.3F;                             /* Referenced by: '<S1151>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_P_DsblNiClsdLoopDschrgLmt =
    3.3F;                              /* Referenced by: '<S1152>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_U_BatVoltModMin_ExitSpin =
    0.1F;                              /* Referenced by:
                                        * '<S1464>/Calib'
                                        * '<S1791>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_AStopParkEngEnable = 0;/* Referenced by:
                                                                      * '<S2596>/Calib'
                                                                      * '<S2819>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_AllowEV_StrtFailed = 1;/* Referenced by:
                                                                      * '<S593>/Calib'
                                                                      * '<S1878>/Calib'
                                                                      * '<S2094>/Calib'
                                                                      * '<S2250>/Calib'
                                                                      * '<S2328>/Calib'
                                                                      * '<S1465>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_AllowStopAbrts = 1;/* Referenced by:
                                                                      * '<S2597>/Calib'
                                                                      * '<S2820>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_AllowStopAbrtsDFA = 1;/* Referenced by: '<S2470>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_AllowStopAbrtsPFS = 1;/* Referenced by: '<S2652>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_AuxPumpRunEnbl = 1;/* Referenced by: '<S2653>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ByBassGainLtch = 1;/* Referenced by: '<S889>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_CCDragAdaptEnab = 0;/* Referenced by: '<S973>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_CCUseEngActforHold = 1;/* Referenced by: '<S966>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_CheckGearForStart = 0;/* Referenced by: '<S261>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_DsblCltchStrtRsrvChk = 0;/* Referenced by:
                                                                      * '<S2598>/Calib'
                                                                      * '<S2821>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_DsblEVStrtFailed_InPlant =
    1;                                 /* Referenced by:
                                        * '<S594>/Calib'
                                        * '<S1879>/Calib'
                                        * '<S2095>/Calib'
                                        * '<S2251>/Calib'
                                        * '<S2329>/Calib'
                                        * '<S1466>/Calib'
                                        * '<S1792>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EnblActvBeltSlpCtrl = 1;/* Referenced by:
                                                                      * '<S1467>/Calib'
                                                                      * '<S1890>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EnblFtrBackupStrt = 1;/* Referenced by:
                                                                      * '<S240>/Calib'
                                                                      * '<S309>/Calib'
                                                                      * '<S361>/Calib'
                                                                      * '<S522>/Calib'
                                                                      * '<S1047>/Calib'
                                                                      * '<S1468>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EnblFtrBumpStrt = 0;/* Referenced by:
                                                                      * '<S241>/Calib'
                                                                      * '<S310>/Calib'
                                                                      * '<S362>/Calib'
                                                                      * '<S523>/Calib'
                                                                      * '<S1048>/Calib'
                                                                      * '<S1469>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EnblFtrEarlyExitSpinUp =
    1;                                 /* Referenced by:
                                        * '<S1470>/Calib'
                                        * '<S1750>/Calib'
                                        * '<S1793>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EnblP1C64Diag = 1;/* Referenced by: '<S3214>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EnblP1C65Diag = 1;/* Referenced by: '<S3215>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EnblP1C68Diag = 1;/* Referenced by: '<S3216>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EnblPotForRespType = 1;/* Referenced by: '<S1978>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EnblStrtStpChngMind = 0;/* Referenced by: '<S474>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EnblSyncLrnChk_DF = 0;/* Referenced by: '<S2526>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EnblTiEstFltLim = 0;/* Referenced by:
                                                                      * '<S2303>/KeESSR_b_EnblTiEstFltLim'
                                                                      * '<S2047>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EnblTo4TiEstBmpStrt = 1;/* Referenced by:
                                                                      * '<S922>/Calib'
                                                                      * '<S1318>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_Enbl_KeyOffIS = 0;/* Referenced by: '<S379>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EngCombCmd_Dsbl = 0;/* Referenced by:
                                                                      * '<S1880>/Calib'
                                                                      * '<S2252>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EngStallReattmptDTC = 1;/* Referenced by: '<S336>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EngStpProfUseAngAdpt = 0;/* Referenced by:
                                                                      * '<S2851>/Calib'
                                                                      * '<S2918>/Calib'
                                                                      * '<S2978>/Calib'
                                                                      * '<S2684>/Calib'
                                                                      * '<S2496>/Calib'
                                                                      * '<S2931>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_EngStpProfUseNiDotGain =
    0;                                 /* Referenced by: '<S2923>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ForceETRQIdleCtrl_12vStrt
    = 1;                               /* Referenced by: '<S830>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT)
    KeESSR_b_ForceNiClsdLoopIdleCtrl_12vStrt = 0;/* Referenced by: '<S831>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_FtrAStrtNormalInterp = 1;/* Referenced by: '<S3110>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_InitSpnTmrChkOnly = 0;/* Referenced by: '<S1049>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_KeyCrnkDsblNiClsdLp = 0;/* Referenced by: '<S1153>/Calib' */

#endif

#if (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func) || (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func)

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_LmtEngTrqAct = 1;/* Referenced by:
                                                                      * '<S863>/Calib'
                                                                      * '<S2330>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_LmtEngTrqAct_Enbl = 1;/* Referenced by: '<S81>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_LowPwrBUseLowPwrCals = 0;/* Referenced by: '<S3111>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_LowPwrDsblNiClsdLp = 1;/* Referenced by: '<S1154>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_MinEngRunTorqOvrrd = 0;/* Referenced by: '<S2654>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_NiDotMaxOvrrd = 0;/* Referenced by: '<S159>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_NiDotMinOvrrd = 0;/* Referenced by: '<S160>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_NidotCalc_NoEnbl = 0;/* Referenced by: '<S3229>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_NidotCalc_NodotEnbl = 0;/* Referenced by: '<S3230>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_NidotCalc_TiEnbl = 0;/* Referenced by: '<S3231>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_NidotCalc_ToEnbl = 0;/* Referenced by: '<S3232>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_NoEngComb_SpdSrc = 0;/* Referenced by:
                                                                      * '<S2331>/Calib'
                                                                      * '<S1983>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_P1C68_RD_CoastDownEnbl =
    1;                                 /* Referenced by: '<S2822>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_P2_0TrqActv = 1;/* Referenced by: '<S200>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ResetAStrtFailed = 0;/* Referenced by: '<S286>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_RstHybStpStrtFault = 0;/* Referenced by: '<S2997>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtAchIdle12vStrtSt
    = 0;                               /* Referenced by: '<S832>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(boolean, ESSR_VAR_INIT)
    KeESSR_b_ShftInhbtAchIdleBumpStrtSt = 1;/* Referenced by: '<S923>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtAchIdleSt = 0;/* Referenced by: '<S736>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtDisFuelSt = 0;/* Referenced by: '<S2559>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtEngOff = 0;/* Referenced by: '<S301>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtEngOn = 0;/* Referenced by: '<S363>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtFinStopSt = 0;/* Referenced by: '<S2630>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtImmedStopSt = 0;/* Referenced by: '<S455>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtInitSpinSt = 0;/* Referenced by: '<S1132>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtLowPwrSt = 0;/* Referenced by: '<S1010>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtPrepStopSt = 0;/* Referenced by: '<S2785>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtRampDownSt = 0;/* Referenced by: '<S2966>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtRestartPrepSt =
    0;                                 /* Referenced by: '<S1236>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtSpnUp12vStrtSt =
    0;                                 /* Referenced by: '<S1293>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtSpnUpAutoSt = 0;/* Referenced by: '<S1554>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtSpnUpBumpStrtSt =
    1;                                 /* Referenced by: '<S1355>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtSpnUpKeySt = 0;/* Referenced by: '<S1726>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtStrtEngEnd = 0;/* Referenced by:
                                                                      * '<S595>/Calib'
                                                                      * '<S1881>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtStrtEngPFSEnd =
    0;                                 /* Referenced by: '<S2096>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtStrtEngPFSStrt =
    0;                                 /* Referenced by: '<S2097>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_ShftInhbtStrtEngStrt = 0;/* Referenced by:
                                                                      * '<S596>/Calib'
                                                                      * '<S1882>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_SpnUpBmpStrtFailEV_Enbl =
    0;                                 /* Referenced by:
                                        * '<S475>/Calib'
                                        * '<S1319>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_StrtStpFailRsnReset = 0;/* Referenced by: '<S3002>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_TgtM2SpdSpinupBumpStrt =
    1;                                 /* Referenced by: '<S1320>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_TiEstMinLimEna = 0;/* Referenced by: '<S3240>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_TrgtAngCntrl = 0;/* Referenced by:
                                                                      * '<S2823>/Calib'
                                                                      * '<S2717>/Calib'
                                                                      * '<S2727>/Calib'
                                                                      * '<S2527>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_UseActlTrqCKS = 0;/* Referenced by: '<S1580>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_UseCalEngTrqsCD = 1;/* Referenced by: '<S222>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_UseDamperLockout = 0;/* Referenced by: '<S390>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_UseShpNiForAstop = 1;/* Referenced by: '<S2824>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_UseSnsdTrqCKS = 0;/* Referenced by: '<S1581>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_UseZeroTiEstFinishStp = 1;/* Referenced by: '<S2599>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(boolean, ESSR_VAR_INIT) KeESSR_b_UseZeroTiEstImmedStp = 1;/* Referenced by: '<S398>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dM_EngCapMinRunImmedLD =
    -50.0F;                            /* Referenced by: '<S3267>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dM_EngCapMinRunImmedLU =
    50.0F;                             /* Referenced by: '<S3268>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dM_EngOffEngStrtTorqLD =
    0.0F;                              /* Referenced by: '<S276>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dM_EngOffEngStrtTorqLU =
    80.0F;                             /* Referenced by: '<S277>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dM_EngTrqActlFueled = 50.0F;/* Referenced by: '<S1608>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dM_InitSpinEngStrtTorqLD =
    0.0F;                              /* Referenced by: '<S1064>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dM_InitSpinEngStrtTorqLU =
    80.0F;                             /* Referenced by: '<S1065>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dM_PrepStopPredTiRmpRt =
    -70.0F;                            /* Referenced by: '<S2655>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dM_PrepStopTiRmpRt = -70.0F;/* Referenced by:
                                                                      * '<S2471>/Calib'
                                                                      * '<S2656>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dM_SpinUpEngStrtTorqLD =
    0.0F;                              /* Referenced by: '<S1337>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dM_SpinUpEngStrtTorqLU =
    80.0F;                             /* Referenced by: '<S1338>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(uint16, ESSR_VAR_INIT) KeESSR_d_TCMFailures_MaskVal = 160U;/* Referenced by: '<S1351>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_12VPtgtLD = -30.0F;/* Referenced by: '<S1254>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_12VPtgtLU = 30.0F;/* Referenced by: '<S1255>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_AStp_PFS_NiDotMax =
    15000.0F;                          /* Referenced by: '<S2657>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_AStp_PFS_NiDotMin =
    -15000.0F;                         /* Referenced by: '<S2658>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_AStp_RmpDwn_NiDotMax =
    4000.0F;                           /* Referenced by: '<S2825>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_AStp_RmpDwn_NiDotMin =
    -3800.0F;                          /* Referenced by: '<S2826>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_EM_LPS_PtgtLD = -30.0F;/* Referenced by: '<S1376>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_EM_LPS_PtgtLU = 30.0F;/* Referenced by: '<S1377>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_ImmedStpJerkMax = 750.0F;/* Referenced by: '<S399>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_ImmedStpJerkMin =
    -250.0F;                           /* Referenced by: '<S400>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_InitJerkMaxSpinup =
    2000.0F;                           /* Referenced by:
                                        * '<S1490>/Calib'
                                        * '<S1805>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_MaxNidotCalc = 100.0F;/* Referenced by: '<S3233>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_MinNidotCalc = 0.0F;/* Referenced by: '<S3234>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_NiDotMaxVal = 6500.0F;/* Referenced by: '<S161>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_NiDotMinVal = -6500.0F;/* Referenced by: '<S162>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_NiTargetJerkLimit =
    750.0F;                            /* Referenced by:
                                        * '<S680>/Calib'
                                        * '<S1185>/Calib'
                                        * '<S1425>/Calib'
                                        * '<S1775>/Calib'
                                        * '<S2332>/Calib'
                                        * '<S2659>/Calib'
                                        * '<S2827>/Calib'
                                        * '<S401>/Calib'
                                        * '<S761>/Calib'
                                        * '<S1621>/Calib'
                                        * '<S1672>/Calib'
                                        * '<S1984>/Calib'
                                        * '<S2142>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_NidotCalc_NodotOvrrd =
    0.0F;                              /* Referenced by: '<S3235>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_P1fLmtTrgtLD = -50.0F;/* Referenced by: '<S597>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_P1fLmtTrgtLU = 30.0F;/* Referenced by: '<S598>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_PFSJerkMax = 900.0F;/* Referenced by: '<S2660>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_PFSJerkMin = -900.0F;/* Referenced by: '<S2661>/Calib' */

#endif

#if (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func) || (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func)

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_PtgtLD = -30.0F;/* Referenced by:
                                                                      * '<S890>/Calib'
                                                                      * '<S2390>/Calib'
                                                                      */

#endif

#if (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func) || (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func)

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_PtgtLU = 30.0F;/* Referenced by:
                                                                      * '<S891>/Calib'
                                                                      * '<S2391>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_RmpDwnJerkMax = 500.0F;/* Referenced by: '<S2828>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dn_RmpDwnJerkMin = -40.0F;/* Referenced by: '<S2829>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dphi_EngStpProfCntrIncMax =
    0.025F;                            /* Referenced by: '<S2945>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dphi_EngStpProfCntrIncMin =
    0.001F;                            /* Referenced by: '<S2946>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dscl_RampDownRate = -50.0F;/* Referenced by:
                                                                      * '<S262>/Calib'
                                                                      * '<S2600>/Calib'
                                                                      * '<S2830>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dscl_RampUpRate = 4.0F;/* Referenced by:
                                                                      * '<S599>/Calib'
                                                                      * '<S1426>/Calib'
                                                                      * '<S1883>/Calib'
                                                                      * '<S2098>/Calib'
                                                                      * '<S762>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dscl_RampUpRtAchIdle = 1.0F;/* Referenced by: '<S681>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dscl_RampUpRtCKS = 1.0F;/* Referenced by: '<S1582>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dscl_TorqCancelRampInRt =
    20.0F;                             /* Referenced by:
                                        * '<S491>/Calib'
                                        * '<S535>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_dscl_TorqCancelRampOutRt =
    8.0F;                              /* Referenced by:
                                        * '<S263>/Calib'
                                        * '<S486>/Calib'
                                        * '<S529>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(TePTAR_e_ImmediateTorqRespType, ESSR_VAR_INIT)
    KeESSR_e_AchEngIdleBumpStrtRespType = CePTAR_e_Inactive;/* Referenced by: '<S924>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_EngStrtActuatorTyp, ESSR_VAR_INIT)
    KeESSR_e_EngStartActrType = CeESSR_e_P1f;/* Referenced by:
                                              * '<S456>/Calib'
                                              * '<S543>/Calib'
                                              * '<S1143>/Calib'
                                              * '<S1162>/Calib'
                                              * '<S1169>/Calib'
                                              */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(TePTAR_e_ImmediateTorqRespType, ESSR_VAR_INIT)
    KeESSR_e_EngTrqRespTypP1fLmt = CePTAR_e_Inactive;/* Referenced by: '<S665>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(TePTAR_e_ImmediateTorqRespType, ESSR_VAR_INIT)
    KeESSR_e_EngTrqRespTyp_EMLPS = CePTAR_e_Inactive;/* Referenced by: '<S1409>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_EngStrtStpMd, ESSR_VAR_INIT)
    KeESSR_e_MdInAchEngIdle12vStrtSt = CeESSR_e_ProducingTorque;/* Referenced by: '<S833>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(TeESSR_e_EngStrtStpMd, ESSR_VAR_INIT)
    KeESSR_e_MdInAchEngIdleBumpStrtSt = CeESSR_e_EngineTorqueStart;/* Referenced by: '<S925>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_EngStrtStpMd, ESSR_VAR_INIT)
    KeESSR_e_MdInAchEngIdleSt = CeESSR_e_ProducingTorque;/* Referenced by: '<S737>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_EngStrtStpMd, ESSR_VAR_INIT)
    KeESSR_e_MdInCoastDownStPT = CeESSR_e_Stop;/* Referenced by: '<S232>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_EngStrtStpMd, ESSR_VAR_INIT)
    KeESSR_e_MdInDisFuelSt = CeESSR_e_DisableFuel;/* Referenced by: '<S2560>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_EngStrtStpMd, ESSR_VAR_INIT)
    KeESSR_e_MdInPrepStopSt = CeESSR_e_StopPending;/* Referenced by: '<S2786>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TCM_StartStopType, ESSR_VAR_INIT)
    KeESSR_e_TCM_StartStopType_CoastDown = CeESSR_e_NormalStop;/* Referenced by: '<S223>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TCM_StartStopType, ESSR_VAR_INIT)
    KeESSR_e_TCM_StartStopType_DsblFuel = CeESSR_e_NormalStop;/* Referenced by: '<S2561>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TCM_StartStopType, ESSR_VAR_INIT)
    KeESSR_e_TCM_StartStopType_FinishStop = CeESSR_e_NormalStop;/* Referenced by: '<S2631>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TCM_StartStopType, ESSR_VAR_INIT)
    KeESSR_e_TCM_StartStopType_ImmedStop = CeESSR_e_NormalStop;/* Referenced by: '<S457>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TCM_StartStopType, ESSR_VAR_INIT)
    KeESSR_e_TCM_StartStopType_PFS = CeESSR_e_NormalStop;/* Referenced by: '<S2787>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TCM_StartStopType, ESSR_VAR_INIT)
    KeESSR_e_TCM_StartStopType_RampDown = CeESSR_e_NormalStop;/* Referenced by: '<S2967>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TCM_TransitionStatus, ESSR_VAR_INIT)
    KeESSR_e_TCM_TransitionStatus_ImmedStop = CeESSR_e_Stopng;/* Referenced by: '<S458>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelAchEngIdle12vStrtSt = CeESSR_e_Off;/* Referenced by: '<S834>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelAchEngIdleBumpStrtSt = CeESSR_e_Off;/* Referenced by: '<S926>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelAchEngIdleSt = CeESSR_e_Off;/* Referenced by: '<S738>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelDisableFuelSt = CeESSR_e_Off;/* Referenced by: '<S2562>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelEngOff = CeESSR_e_Off;/* Referenced by: '<S302>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelEngRunning = CeESSR_e_Off;/* Referenced by: '<S364>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelFinishStopSt = CeESSR_e_Off;/* Referenced by: '<S2632>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelImmedStop = CeESSR_e_Off;/* Referenced by: '<S459>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelInitEngSpinSt = CeESSR_e_Off;/* Referenced by: '<S1133>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelKeyOff = CeESSR_e_Off;/* Referenced by: '<S303>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelPrepForStopSt = CeESSR_e_Off;/* Referenced by: '<S2788>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelRampDownSt = CeESSR_e_Off;/* Referenced by: '<S2968>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelRestartPrepSt = CeESSR_e_Off;/* Referenced by: '<S1237>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelSpinUp12vStrtSt = CeESSR_e_Off;/* Referenced by: '<S1294>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelSpinUpAutoStrtSt = CeESSR_e_Off;/* Referenced by: '<S1555>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelSpinUpBumpStrtSt = CeESSR_e_Off;/* Referenced by: '<S1356>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelSpinUpKeyStrtSt = CeESSR_e_Off;/* Referenced by: '<S1727>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelSpinUpLowPwrStrtSt = CeESSR_e_Off;/* Referenced by: '<S1011>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelStartEngPFSSt = CeESSR_e_Off;/* Referenced by: '<S2225>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT)
    KeESSR_e_TransFldPmpSelStartEngSt = CeESSR_e_Off;/* Referenced by: '<S2070>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(uint32, ESSR_VAR_INIT) KeESSR_g_BSGStrtFailRsnClr = 0U;/* Referenced by: '<S365>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(uint32, ESSR_VAR_INIT) KeESSR_g_SpnDwnAdptESSRFailSel =
    1835008U;                          /* Referenced by: '<S52>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(uint32, ESSR_VAR_INIT) KeESSR_g_SpnUpAdptESSRFailSel =
    5216U;                             /* Referenced by: '<S53>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(uint32, ESSR_VAR_INIT) KeESSR_g_StrtStpFailPhaseSelect =
    11312U;                            /* Referenced by: '<S2998>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_AStopFrstOrdLwPassT =
    0.08F;                             /* Referenced by: '<S2662>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_AStopScndOrdLwPassT =
    0.05F;                             /* Referenced by: '<S2663>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_AsFrstOrdLwPassT = 0.05F;/* Referenced by: '<S2831>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_AsScndOrdLwPassT = 0.1F;/* Referenced by: '<S2832>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_BCTiMarginRampOutFlt =
    0.3F;                              /* Referenced by: '<S3168>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_CombstDelay = 4.0F;/* Referenced by:
                                                                      * '<S639>/Calib'
                                                                      * '<S1927>/Calib'
                                                                      * '<S2282>/Calib'
                                                                      * '<S2384>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_EMStrtEngTqPredXNFlt =
    0.5F;                              /* Referenced by: '<S2333>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_k_EngStpProfNiDotGainAdpt_Inc = 0.1F;/* Referenced by:
                                                 * '<S2855>/Calib'
                                                 * '<S2862>/Calib'
                                                 */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_k_EngStpProfNiDotGainAdpt_Max = 1.0F;/* Referenced by:
                                                 * '<S2789>/Calib'
                                                 * '<S2969>/Calib'
                                                 * '<S2856>/Calib'
                                                 * '<S2863>/Calib'
                                                 */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_k_EngStpProfNiDotGainAdpt_Min = 1.0F;/* Referenced by:
                                                 * '<S2790>/Calib'
                                                 * '<S2970>/Calib'
                                                 * '<S2857>/Calib'
                                                 * '<S2864>/Calib'
                                                 */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_EngStpProfNiDotGainMax =
    1.25F;                             /* Referenced by: '<S2937>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_EngStpProfNiDotGainMin =
    0.99F;                             /* Referenced by: '<S2938>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_k_EngStpProfNiDotGainRtLmDwn = -0.05F;/* Referenced by: '<S2939>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_EngStpProfNiDotGainRtLmUp
    = 0.05F;                           /* Referenced by: '<S2940>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_ImmedStpFrstOrdLwPassT =
    0.05F;                             /* Referenced by: '<S402>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_ImmedStpScndOrdLwPassT =
    0.08F;                             /* Referenced by: '<S403>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_LQIR

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_LQRStartEngTiFltD = 1.0F;/* Referenced by:
                                                                      * '<S1965>/Calib'
                                                                      * '<S2210>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_LQIR

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_LQRStartEngTiFltT =
    0.0125F;                           /* Referenced by:
                                        * '<S1966>/Calib'
                                        * '<S2211>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_NiDotTargetFilt = 1.0F;/* Referenced by:
                                                                      * '<S682>/Calib'
                                                                      * '<S1186>/Calib'
                                                                      * '<S1427>/Calib'
                                                                      * '<S1776>/Calib'
                                                                      * '<S2334>/Calib'
                                                                      * '<S2664>/Calib'
                                                                      * '<S2833>/Calib'
                                                                      * '<S404>/Calib'
                                                                      * '<S763>/Calib'
                                                                      * '<S1622>/Calib'
                                                                      * '<S1673>/Calib'
                                                                      * '<S1985>/Calib'
                                                                      * '<S2143>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(uint8, ESSR_VAR_INIT) KeESSR_k_NidotCalcConstrnIdx = 1U;/* Referenced by: '<S3236>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_P1fLmtEngTorqReqImmedFltD
    = 1.0F;                            /* Referenced by: '<S600>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_P1fLmtEngTorqReqImmedFltT
    = 0.15F;                           /* Referenced by: '<S601>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_k_P1fLmtEngTorqReqPrdFltT =
    0.1F;                              /* Referenced by: '<S602>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_12vLPSCDDeltaSpd = 10.0F;/* Referenced by: '<S1275>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_12vLPSCDSpd = 300.0F;/* Referenced by: '<S1276>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_12vStrtrEngageSpd = 50.0F;/* Referenced by: '<S201>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_AStpMaxCancelRPM = 500.0F;/* Referenced by: '<S524>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_AchIdleBumpSpdCtlNegDdBnd
    = 0.0F;                            /* Referenced by: '<S878>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_AchIdleBumpSpdCtlPosDdBnd
    = 15.0F;                           /* Referenced by: '<S879>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_ActNiDeltaLQIR = 10.0F;/* Referenced by:
                                                                      * '<S28>/Calib'
                                                                      * '<S1428>/Calib'
                                                                      * '<S2002>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_ActvBeltSlpCtrlMtrASpd =
    0.0F;                              /* Referenced by:
                                        * '<S1471>/Calib'
                                        * '<S1891>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_n_BumpStrtStateExitIntgrlVal = 50.0F;/* Referenced by: '<S883>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_CCDropMtrATqSpd = 600.0F;/* Referenced by: '<S953>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_CCSpdErrAdptIntgrlVal =
    -50.0F;                            /* Referenced by: '<S974>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_CCSpdMinErr = -25.0F;/* Referenced by: '<S975>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_CCStateExitIntgrlVal =
    50.0F;                             /* Referenced by: '<S992>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_CCStateExitSpdDelta =
    -175.0F;                           /* Referenced by:
                                        * '<S993>/Calib'
                                        * '<S954>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_CKSSpdCtlNegDdBnd = 25.0F;/* Referenced by: '<S1596>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_CKSSpdCtlPosDdBnd =
    200.0F;                            /* Referenced by: '<S1597>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_DeltaIdleSpd = 150.0F;/* Referenced by:
                                                                      * '<S2144>/Calib'
                                                                      * '<S1482>/Calib'
                                                                      * '<S1992>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_EngReleaseSpd = 50.0F;/* Referenced by: '<S2834>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_EngReleaseSpdForEngPark =
    1.0F;                              /* Referenced by: '<S2835>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_EngSpd_EngTrqLmtSwtch =
    300.0F;                            /* Referenced by: '<S95>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_EngStallIntgrlVal = 70.0F;/* Referenced by: '<S340>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_EngStallRngEqn = 400.0F;/* Referenced by: '<S322>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_EngStallSpd = 100.0F;/* Referenced by: '<S341>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_EngStrCoastDwnIntgrlVal =
    50.0F;                             /* Referenced by: '<S1892>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_EngStrtCoastDwnThres =
    150.0F;                            /* Referenced by: '<S1893>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_EngStrtExitIntgrlVal =
    1.0F;                              /* Referenced by:
                                        * '<S629>/Calib'
                                        * '<S1917>/Calib'
                                        * '<S2122>/Calib'
                                        * '<S2375>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_EngStrtExitSpd = 500.0F;/* Referenced by:
                                                                      * '<S630>/Calib'
                                                                      * '<S1918>/Calib'
                                                                      * '<S2123>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_EngStrtExitSpdDelta =
    -25.0F;                            /* Referenced by:
                                        * '<S1919>/Calib'
                                        * '<S2124>/Calib'
                                        * '<S2376>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_EngStrtPFSSpdCtlPosDdBnd =
    15.0F;                             /* Referenced by: '<S2194>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_EngStrtSpdCtlNegDdBnd =
    -15.0F;                            /* Referenced by: '<S2057>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_EngStrtSpdCtlPosDdBnd =
    15.0F;                             /* Referenced by: '<S2058>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_EngTrqOnlySpdMin = 250.0F;/* Referenced by:
                                                                      * '<S2472>/Calib'
                                                                      * '<S2836>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_FastSpinDelta = -400.0F;/* Referenced by: '<S1583>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_FastSpinTgt = 1000.0F;/* Referenced by:
                                                                      * '<S1584>/Calib'
                                                                      * '<S1623>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_FinishStpCmpltSpd = 10.0F;/* Referenced by:
                                                                      * '<S202>/Calib'
                                                                      * '<S2601>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_ImmedStpCmpltSpd = 30.0F;/* Referenced by: '<S380>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_LmpHmCSSpinUpExtSpd =
    300.0F;                            /* Referenced by: '<S1751>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_LmpHmSpinUpExtSpd =
    300.0F;                            /* Referenced by: '<S1472>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_MaxCancelRPM = 600.0F;/* Referenced by: '<S476>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_MaxDeltaAchIdleSpdThres =
    500.0F;                            /* Referenced by: '<S884>/Calib' */

#endif

#if (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func) || (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func)

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_MaxOffstEngMinTgt =
    600.0F;                            /* Referenced by:
                                        * '<S892>/Calib'
                                        * '<S2392>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_MinNbTgt = 400.0F;/* Referenced by:
                                                                      * '<S893>/Calib'
                                                                      * '<S1344>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_MinSpdFuelOn = 250.0F;/* Referenced by:
                                                                      * '<S1473>/Calib'
                                                                      * '<S1752>/Calib'
                                                                      * '<S1794>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_NbTgtOffset = 100.0F;/* Referenced by: '<S1345>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_NbTgt_Default = 800.0F;/* Referenced by:
                                                                      * '<S224>/Calib'
                                                                      * '<S264>/Calib'
                                                                      * '<S366>/Calib'
                                                                      * '<S544>/Calib'
                                                                      * '<S666>/Calib'
                                                                      * '<S739>/Calib'
                                                                      * '<S835>/Calib'
                                                                      * '<S1012>/Calib'
                                                                      * '<S1134>/Calib'
                                                                      * '<S1238>/Calib'
                                                                      * '<S1295>/Calib'
                                                                      * '<S1410>/Calib'
                                                                      * '<S1556>/Calib'
                                                                      * '<S1728>/Calib'
                                                                      * '<S2071>/Calib'
                                                                      * '<S2226>/Calib'
                                                                      * '<S2563>/Calib'
                                                                      * '<S2633>/Calib'
                                                                      * '<S2791>/Calib'
                                                                      * '<S2971>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_NiTargetEMStrt = 600.0F;/* Referenced by:
                                                                      * '<S2335>/Calib'
                                                                      * '<S1795>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_NiTrgtOffst12VStrt =
    100.0F;                            /* Referenced by:
                                        * '<S1256>/Calib'
                                        * '<S1378>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_NidotCalc_NoOvrrd = 0.0F;/* Referenced by: '<S3237>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_NoEngComb_SpdTgt = 740.0F;/* Referenced by:
                                                                      * '<S2336>/Calib'
                                                                      * '<S1986>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_OptInputSpdDflt = 900.0F;/* Referenced by: '<S29>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_OverRunSpdDelta = 500.0F;/* Referenced by: '<S982>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_P1fLmtEngStrtExitSpdDelta
    = 100.0F;                          /* Referenced by: '<S631>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_PFS_ProfTgtTol = 10.0F;/* Referenced by: '<S2702>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_PrepStopDsrdEngSpd =
    900.0F;                            /* Referenced by:
                                        * '<S3274>/Calib'
                                        * '<S2797>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_PrepStopIdleSpdDB =
    3000.0F;                           /* Referenced by:
                                        * '<S3275>/Calib'
                                        * '<S2798>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_PrepStopTargIdleDB =
    75.0F;                             /* Referenced by:
                                        * '<S2503>/Calib'
                                        * '<S2709>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_SlowSpinDelta = 0.0F;/* Referenced by: '<S1585>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_SlowSpinTgt = 0.0F;/* Referenced by:
                                                                      * '<S1586>/Calib'
                                                                      * '<S1674>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_SpinUpSpdCtlNegDdBnd =
    -15.0F;                            /* Referenced by: '<S1542>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_SpinUpSpdCtlPosDdBnd =
    15.0F;                             /* Referenced by: '<S1543>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_SpnUpBmpStrtCDDeltaSpd =
    10.0F;                             /* Referenced by: '<S1321>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_SpnUpBmpStrtCoastDwnSpd =
    0.0F;                              /* Referenced by: '<S1322>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_n_SpnUpBmpStrtEngRunDeltaSpd = 0.0F;/* Referenced by: '<S1323>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_SpnUpBmpStrtOptNiDeltaSpd
    = 0.0F;                            /* Referenced by: '<S1324>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_Start2RunTgt = 500.0F;/* Referenced by:
                                                                      * '<S1257>/Calib'
                                                                      * '<S1379>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_StopAbrtMinSpd = 300.0F;/* Referenced by:
                                                                      * '<S2602>/Calib'
                                                                      * '<S2837>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_Strt2RunExitIntgrlVal =
    1.0F;                              /* Referenced by:
                                        * '<S1265>/Calib'
                                        * '<S1390>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_Strt2RunExitSpdDelta =
    25.0F;                             /* Referenced by:
                                        * '<S1266>/Calib'
                                        * '<S1391>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_StrtEngCSExitSpdIngrl =
    100.0F;                            /* Referenced by: '<S2271>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_StrtEngCSMaxIntgrlVal =
    150.0F;                            /* Referenced by: '<S2272>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_StrtEngCSMinIntgrlVal =
    -50.0F;                            /* Referenced by: '<S2273>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_StrtEngCSSpdTgt = 600.0F;/* Referenced by: '<S2253>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_StrtEngP1fLmtTrgt =
    500.0F;                            /* Referenced by: '<S603>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_TiMarginToZero = 1200.0F;/* Referenced by: '<S3169>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_n_TrgtStpAngRmpDwnExit =
    130.0F;                            /* Referenced by: '<S2914>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_phi_CombstDelay = 40.0F;/* Referenced by:
                                                                      * '<S640>/Calib'
                                                                      * '<S1928>/Calib'
                                                                      * '<S2283>/Calib'
                                                                      * '<S2385>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_phi_EngStpTgtAngle = 250.0F;/* Referenced by:
                                                                      * '<S2972>/Calib'
                                                                      * '<S2680>/Calib'
                                                                      * '<S2493>/Calib'
                                                                      * '<S2529>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_phi_FinishStopEngAngDiffThres = 5.0F;/* Referenced by: '<S2603>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_phi_FuelBurnOutAngle =
    300.0F;                            /* Referenced by: '<S2681>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_r_NiDtoTiMargin =
    0.00730943913F;                    /* Referenced by: '<S1074>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_AEMDMtrAGain_CoastDown =
    0.0F;                              /* Referenced by: '<S203>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_AEMDMtrAGain_EngOff =
    1.0F;                              /* Referenced by: '<S265>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_AEMDMtrAGain_EngRun =
    1.0F;                              /* Referenced by: '<S323>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_AEMDMtrAGain_ImmedStop =
    0.0F;                              /* Referenced by: '<S381>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_AEMDMtrAGain_MainStart =
    0.0F;                              /* Referenced by: '<S477>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_AEMDMtrAGain_MainStop =
    0.0F;                              /* Referenced by: '<S525>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_scl_AEMDMtrBGain_AchIdle12VStrtSt = 1.0F;/* Referenced by: '<S836>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_AEMDMtrBGain_CoastDown =
    0.0F;                              /* Referenced by: '<S204>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_AEMDMtrBGain_EngOff =
    1.0F;                              /* Referenced by: '<S266>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_AEMDMtrBGain_EngRun =
    1.0F;                              /* Referenced by: '<S324>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_AEMDMtrBGain_ImmedStop =
    0.0F;                              /* Referenced by: '<S382>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_scl_AEMDMtrBGain_InitSpnAutoSt = 1.0F;/* Referenced by: '<S1135>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_scl_AEMDMtrBGain_InitSpnClchSt = 1.0F;/* Referenced by: '<S1136>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_AEMDMtrBGain_MainStart =
    1.0F;                              /* Referenced by: '<S478>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_AEMDMtrBGain_MainStop =
    1.0F;                              /* Referenced by: '<S526>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_scl_AEMDMtrBGain_SpnUp12VStrtSt = 1.0F;/* Referenced by: '<S1296>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_scl_AEMDMtrBGain_SpnUpAutoSt = 1.0F;/* Referenced by: '<S1557>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_AEMDMtrBGain_SpnUpClSt =
    1.0F;                              /* Referenced by: '<S1764>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_scl_AEMDMtrBGain_StrtEngAutoSt = 1.0F;/* Referenced by:
                                                  * '<S667>/Calib'
                                                  * '<S2072>/Calib'
                                                  * '<S2227>/Calib'
                                                  */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_scl_AEMDMtrBGain_StrtEngClSt = 1.0F;/* Referenced by: '<S2293>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_CKSTiEstLim = 1.0F;/* Referenced by: '<S1598>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_RampDownHold = 1.0F;/* Referenced by:
                                                                      * '<S2604>/Calib'
                                                                      * '<S2838>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_RampDownNiMultiply =
    1.18F;                             /* Referenced by: '<S2924>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_RampUpAchIdle = 0.5F;/* Referenced by: '<S683>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_RampUpCKS = 0.5F;/* Referenced by: '<S1587>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_RampUpHold = 1.0F;/* Referenced by: '<S1429>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_SpdCtlImmedStpVal =
    0.25F;                             /* Referenced by: '<S460>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_SpdCtrlColdCrnk = 0.0F;/* Referenced by: '<S1013>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_SpdCtrlEngOff = 0.0F;/* Referenced by:
                                                                      * '<S267>/Calib'
                                                                      * '<S2605>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_scl_SpdCtrlEngOffEnt = 0.0F;/* Referenced by: '<S304>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_AStopAllCylWaitTm = 0.1F;/* Referenced by: '<S2703>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_AStrtPBatBoostDelay =
    0.75F;                             /* Referenced by:
                                        * '<S645>/Calib'
                                        * '<S1933>/Calib'
                                        * '<S2135>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_ActvBeltSlpCtrlAchvdTmr =
    0.2F;                              /* Referenced by:
                                        * '<S1474>/Calib'
                                        * '<S1894>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_AngleLrnWaitTmPFS =
    0.0125F;                           /* Referenced by:
                                        * '<S2718>/Calib'
                                        * '<S2728>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_AuxPumpWaitTm = 0.5F;/* Referenced by: '<S2665>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_CombChkDlyTm = 1.0F;/* Referenced by:
                                                                      * '<S2337>/Calib'
                                                                      * '<S1987>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_DF_CmbstnCmdTm = 0.05F;/* Referenced by: '<S2487>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_DF_SpdTgtTm = 0.35F;/* Referenced by: '<S2488>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_EMLPSStartTime = 0.05F;/* Referenced by: '<S1380>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_EMStartTime = 0.05F;/* Referenced by: '<S2338>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_Exit2StpCoastDownTm =
    0.1F;                              /* Referenced by: '<S205>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_Exit2StpEngStalCoastDwn =
    0.1F;                              /* Referenced by: '<S206>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_Exit2StrtCoastDownTm =
    0.1F;                              /* Referenced by: '<S207>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_FuelTmDelayHold = 0.0F;/* Referenced by:
                                                                      * '<S635>/Calib'
                                                                      * '<S1923>/Calib'
                                                                      * '<S2128>/Calib'
                                                                      * '<S2278>/Calib'
                                                                      * '<S2380>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_HoldStartStateTime = 3.0F;/* Referenced by:
                                                                      * '<S622>/Calib'
                                                                      * '<S1910>/Calib'
                                                                      * '<S2115>/Calib'
                                                                      * '<S2369>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_HoldStartStateTimeMin =
    0.3F;                              /* Referenced by:
                                        * '<S623>/Calib'
                                        * '<S1911>/Calib'
                                        * '<S2116>/Calib'
                                        * '<S2370>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_ImmedStopMdHoldDelay =
    0.05F;                             /* Referenced by: '<S268>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_ImmedStpAllCylWaitTm =
    0.0F;                              /* Referenced by: '<S391>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_ImmedStpDmprDelay = 0.0F;/* Referenced by: '<S392>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_InitSpnInitAngTm =
    0.0375F;                           /* Referenced by: '<S1072>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxAngleWaitTm = 0.0125F;/* Referenced by:
                                                                      * '<S2666>/Calib'
                                                                      * '<S2489>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxCancelTime = 0.8F;/* Referenced by: '<S479>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxCompressTm = 15.0F;/* Referenced by: '<S1438>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxDSO2CmpltTm = 2.5F;/* Referenced by: '<S2507>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxDSO2InitTm = 0.1F;/* Referenced by: '<S2508>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxDSO2TrqTm = 0.1F;/* Referenced by: '<S2509>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxPositionEngTm = 0.12F;/* Referenced by: '<S2606>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxRmpDwnStrtAngWait =
    0.3F;                              /* Referenced by: '<S2528>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmAchIdle_BumpStrt =
    5.0F;                              /* Referenced by: '<S864>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmCoastDown = 10.0F;/* Referenced by: '<S208>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmColdCrnk = 5.0F;/* Referenced by: '<S946>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmDsblFuel = 5.0F;/* Referenced by: '<S2473>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmFnshStp = 5.0F;/* Referenced by: '<S2607>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmImmedStp = 5.0F;/* Referenced by: '<S383>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmInitSpin = 16.0F;/* Referenced by: '<S1050>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmP1fLmtStartEng =
    5.0F;                              /* Referenced by: '<S604>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmPrepStp = 5.0F;/* Referenced by: '<S2667>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmPrepStpMtrAFlt =
    0.1F;                              /* Referenced by: '<S2668>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmRmpDwn = 5.0F;/* Referenced by: '<S2839>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmSpinUp_12vStrt =
    100.0F;                            /* Referenced by: '<S1258>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmSpinUp_BumpStrt =
    5.0F;                              /* Referenced by: '<S1325>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmSpinUp_CKS = 5.0F;/* Referenced by: '<S1588>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmSpinUp_CS = 5.0F;/* Referenced by: '<S1753>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmSpinUp_EM = 5.0F;/* Referenced by: '<S1796>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmSpinUp_EMLPS =
    5.0F;                              /* Referenced by: '<S1381>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmSpinUp_SFS = 5.0F;/* Referenced by: '<S1475>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmStartEng = 4.0F;/* Referenced by:
                                                                      * '<S1884>/Calib'
                                                                      * '<S1895>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmStartEngCS = 5.0F;/* Referenced by: '<S2254>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmStartEngEM = 5.0F;/* Referenced by: '<S2339>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MaxStTmStartEngPFS = 5.0F;/* Referenced by: '<S2099>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KeESSR_t_MaxTmEngCapMinRunImmedDecay = 0.2F;/* Referenced by: '<S2704>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MinEngIdleTm = 0.35F;/* Referenced by:
                                                                      * '<S2504>/Calib'
                                                                      * '<S2710>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MinFinishStpPrkTm = 0.25F;/* Referenced by: '<S2608>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MinFinishStpTm = 0.25F;/* Referenced by: '<S2609>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MinKneePtTm = -1.0F;/* Referenced by: '<S1589>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MinRestartPrepTm = 0.4F;/* Referenced by: '<S1187>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MinRun2StpTm = 0.5F;/* Referenced by: '<S325>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MinTmDsblFuel = 0.0125F;/* Referenced by: '<S2474>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MinTmEngOff = 0.0375F;/* Referenced by: '<S269>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MinTmEngOffCltchStrt =
    0.1F;                              /* Referenced by: '<S270>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_MinTmImmedStp = 0.5F;/* Referenced by: '<S384>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_NiDotLimNiProfLead =
    0.05F;                             /* Referenced by:
                                        * '<S1493>/Calib'
                                        * '<S1994>/Calib'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_PFS_ProfTgtTm = 0.05F;/* Referenced by: '<S2705>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_PFS_SpdTgtTm = 0.05F;/* Referenced by: '<S2706>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_ProfRmpStrtDelay = 0.012F;/* Referenced by:
                                                                      * '<S2682>/Calib'
                                                                      * '<S2494>/Calib'
                                                                      * '<S2530>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_PstnMntrExtndTm = 0.05F;/* Referenced by: '<S3198>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_ResetFailTm = 0.0125F;/* Referenced by: '<S271>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_RmpDwnAbrtTm = 6.0F;/* Referenced by: '<S2840>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_ShftInhbtStrtEngPFSTm =
    0.5F;                              /* Referenced by: '<S2100>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_ShftInhbtStrtEngTm = 0.5F;/* Referenced by:
                                                                      * '<S605>/Calib'
                                                                      * '<S1885>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_SpinupAirflwChkMaxTm =
    0.2F;                              /* Referenced by: '<S1476>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_SpnUpBmpStrtFailTmr =
    0.0F;                              /* Referenced by: '<S1326>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_StopPhsrPrkMaxTm =
    0.0125F;                           /* Referenced by: '<S2490>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_StrtEngCSHoldTm = 1.0F;/* Referenced by: '<S2266>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_StrtEngCSHoldTmMin = 1.0F;/* Referenced by: '<S2267>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_t_TrqLmtRampTm = 0.1F;/* Referenced by:
                                                                      * '<S908>/Calib'
                                                                      * '<S917>/Calib'
                                                                      */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KeESSR_v_RampDownEntrySpd = -1.0F;/* Referenced by: '<S2925>/Calib' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSRR_dn_NiRtLim[4] =
{
    8400.0F, 8400.0F, 8400.0F, 8400.0F
} ;                                    /* Referenced by: '<S2145>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_K_AchIdleBumpSpdCtlPgain[5]
    =
{
    0.3F, 0.25F, 0.2F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S865>/Vector' */

#endif

#if (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func) || (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func)

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_K_BlendTitoEngTrq[7] =
{
    0.0F, 0.0F, 0.1F, 0.2F, 0.5F, 0.9F, 1.0F
} ;                                    /* Referenced by:
                                        * '<S900>/Vector'
                                        * '<S2435>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_K_CCFiltCoefT[4] =
{
    0.025F, 0.03F, 0.04F, 0.05F
} ;                                    /* Referenced by: '<S998>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_K_CCNiDotGain[17] =
{
    0.0F, 1.0F, 1.8F, 2.2F, 2.4F, 2.4F, 2.4F, 2.4F, 2.4F, 2.4F, 2.4F, 2.3F, 2.0F,
    1.5F, 0.75F, 0.25F, 0.0F
} ;                                    /* Referenced by: '<S955>/Vector' */

#endif

#if (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func) || (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func)

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_K_DeltaGainMult[5] =
{
    1.0F, 1.0F, 0.7F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S894>/Vector'
                                        * '<S2393>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_K_EMStrtEngPgain[5] =
{
    0.3F, 0.25F, 0.2F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2341>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_K_InitSpinEngStrtTorqGain[5]
    =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S1066>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_K_InitSpinTiProf[7] =
{
    0.0F, 2.0F, 4.0F, 6.0F, 8.0F, 10.0F, 12.0F
} ;                                    /* Referenced by: '<S1075>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_K_SpinUpEngStrtTorqGain[5] =
{
    0.0F, 1.0F, 1.2F, 1.5F, 2.0F
} ;                                    /* Referenced by: '<S1339>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_K_SpinUpSpdCtlPgainComp[6] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S1544>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_K_TiEstBlndAchIdle[7] =
{
    0.3F, 0.3F, 0.3F, 0.3F, 0.3F, 0.3F, 0.3F
} ;                                    /* Referenced by: '<S684>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_K_TiEstBlndAchIdle12vStrt[7]
    =
{
    0.1F, 0.1F, 0.1F, 0.1F, 0.1F, 0.1F, 0.1F
} ;                                    /* Referenced by: '<S764>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_K_TiEstBlndAchIdleBumpStrt
    [7] =
{
    0.0F, 0.0F, 0.0F, 0.1F, 0.2F, 0.9F, 1.0F
} ;                                    /* Referenced by: '<S866>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_K_TiEstCKSFastSpin[6] =
{
    0.15F, 0.3F, 0.85F, 0.3F, 0.25F, 0.1F
} ;                                    /* Referenced by: '<S1624>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_K_TiEstCKSSlowSpin[6] =
{
    0.15F, 0.3F, 0.85F, 0.3F, 0.25F, 0.1F
} ;                                    /* Referenced by: '<S1675>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_M_AddtlDragTorq_SpinDwn[3] =
{
    0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S34>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_M_AddtlDragTorq_SpinUp[9] =
{
    143.4F, 143.4F, 143.4F, 143.4F, 143.4F, 143.4F, 143.4F, 143.4F, 143.4F
} ;                                    /* Referenced by: '<S35>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_M_CCEngImmedTrq[4] =
{
    30.0F, 20.0F, 60.0F, 65.0F
} ;                                    /* Referenced by: '<S983>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_M_CCEngPrdtdTrq[4] =
{
    40.0F, 40.0F, 60.0F, 110.0F
} ;                                    /* Referenced by: '<S984>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_M_ECTAddtlEngStrtTorq[7] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S278>/Vector'
                                        * '<S1067>/Vector'
                                        * '<S1340>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_M_EngTrqReqBumpStrtErrBsd[9]
    =
{
    50.0F, 20.0F, 5.0F, 80.0F, 30.0F, 10.0F, 100.0F, 60.0F, 20.0F
} ;                                    /* Referenced by: '<S1327>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_M_EngTrqReqBumpStrtTmrBsd
    [12] =
{
    0.0F, 30.0F, 10.0F, 5.0F, 0.0F, 40.0F, 20.0F, 10.0F, 0.0F, 60.0F, 40.0F,
    20.0F
} ;                                    /* Referenced by: '<S1328>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_M_InitImmedTorq_ECT[3] =
{
    0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S2073>/Vector'
                                        * '<S2444>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KtESSR_M_InitSpinEngStrtTorqOffset[5] =
{
    0.0F, 10.0F, 20.0F, 50.0F, 100.0F
} ;                                    /* Referenced by: '<S1068>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_M_MinEngStrtTqSnsdCKS[16] =
{
    1.0F, 0.0F, 1.0F, 0.0F, 0.0F, 1.0F, 0.0F, 1.0F, 0.0F, 1.0F, 0.0F, 0.0F, 1.0F,
    0.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S1613>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_M_MinStartDetectTorq[7] =
{
    10.0F, 10.0F, 10.0F, 20.0F, 20.0F, 25.0F, 25.0F
} ;                                    /* Referenced by:
                                        * '<S1943>/Vector'
                                        * '<S2199>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_M_NiBsdTiEstFinishStp[7] =
{
    -150.0F, -150.0F, -200.0F, -200.0F, -250.0F, -250.0F, -250.0F
} ;                                    /* Referenced by: '<S2610>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_M_NiBsdTiEstImmedStp[7] =
{
    -150.0F, -150.0F, -200.0F, -200.0F, -2000.0F, -2000.0F, -2000.0F
} ;                                    /* Referenced by: '<S405>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_M_PrepStpImmedTrgt[3] =
{
    -1.0F, -1.0F, -1.0F
} ;                                    /* Referenced by: '<S2792>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_M_SpinUpEngStrtTorqOffset[5]
    =
{
    0.0F, 10.0F, 20.0F, 50.0F, 100.0F
} ;                                    /* Referenced by: '<S1341>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KtESSR_M_StrtEngCSInitImmedTorq_ECT[3] =
{
    25.0F, 10.0F, 0.0F
} ;                                    /* Referenced by: '<S2294>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_P_NiDotLimPowerLim[3] =
{
    120.0F, 120.0F, 120.0F
} ;                                    /* Referenced by:
                                        * '<S1494>/Vector'
                                        * '<S1995>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KtESSR_dn_NiDotMax_EngStrt_VoltDep[5] =
{
    4500.0F, 5000.0F, 5500.0F, 6000.0F, 6500.0F
} ;                                    /* Referenced by: '<S3144>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_dn_TrajectoryNidot[7] =
{
    5000.0F, 5000.0F, 5000.0F, 5000.0F, 5000.0F, 5000.0F, 5000.0F
} ;                                    /* Referenced by: '<S1495>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_k_AStrtNormalInterpMult[21]
    =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S3048>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_k_AStrtNormalInterpMultRv
    [21] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S3049>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KtESSR_k_AStrtNormalInterpPedalPstnMult[21] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.2F, 0.4F, 0.6F, 0.8F,
    1.0F, 0.0F, 0.0F, 0.2F, 0.4F, 0.6F, 0.8F, 1.0F
} ;                                    /* Referenced by: '<S3050>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KtESSR_k_AStrtNormalInterpPedalPstnMultRv[21] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.2F, 0.4F, 0.6F, 0.8F,
    1.0F, 0.0F, 0.0F, 0.2F, 0.4F, 0.6F, 0.8F, 1.0F
} ;                                    /* Referenced by: '<S3051>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_k_EngStpAngleFactor[41] =
{
    1.86662853F, 1.73401201F, 1.60201478F, 1.4715215F, 1.34341693F, 1.2186743F,
    1.09808958F, 0.982459307F, 0.872933507F, 0.770042896F, 0.674318314F,
    0.585671425F, 0.504190505F, 0.429787248F, 0.362461597F, 0.302301973F,
    0.249219984F, 0.203127116F, 0.16375798F, 0.130493239F, 0.102625199F,
    0.0795345306F, 0.060601946F, 0.0452966392F, 0.0329108387F, 0.0229137298F,
    0.0149514293F, 0.008847F, 0.0044235F, 0.00168093F, 0.00035388F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by:
                                        * '<S2979>/Vector'
                                        * '<S2685>/Vector'
                                        * '<S2497>/Vector'
                                        * '<S2932>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_k_EngStpNiFactor[41] =
{
    1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 0.996333361F, 0.9846F, 0.964677751F,
    0.936016679F, 0.898616672F, 0.857366681F, 0.812755585F, 0.766280532F,
    0.718797207F, 0.67055F, 0.62196666F, 0.573138893F, 0.524983346F, 0.4775F,
    0.430138886F, 0.38277778F, 0.336333334F, 0.291569442F, 0.248852775F,
    0.209161118F, 0.172494441F, 0.137172222F, 0.103194445F, 0.069583334F,
    0.0359722227F, 0.00236111111F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2948>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_k_StrtEngCSCltchTrqMult[7] =
{
    0.3F, 0.3F, 0.3F, 0.3F, 1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S2274>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_k_TiEstBlndStrtEng[9] =
{
    0.25F, 0.3F, 0.35F, 0.4F, 0.4F, 0.4F, 0.4F, 0.4F, 0.4F
} ;                                    /* Referenced by:
                                        * '<S2255>/Vector'
                                        * '<S2048>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_n_DsrdCrankSpd[3] =
{
    200.0F, 200.0F, 200.0F
} ;                                    /* Referenced by: '<S985>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_n_MinEngAutoStrtSpd[3] =
{
    800.0F, 800.0F, 800.0F
} ;                                    /* Referenced by: '<S504>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_n_MinEngKeyStrtSpd[3] =
{
    800.0F, 800.0F, 800.0F
} ;                                    /* Referenced by: '<S505>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_n_TargetRunSpd[3] =
{
    1400.0F, 1000.0F, 1000.0F
} ;                                    /* Referenced by: '<S986>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_phi_TotalTravelAng[9] =
{
    1395.0F, 1567.0F, 1738.0F, 1919.0F, 2106.0F, 2298.0F, 2497.0F, 2700.0F,
    2909.0F
} ;                                    /* Referenced by: '<S2531>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_r_CCTiRamp[16] =
{
    0.0F, 0.1F, 0.2F, 0.3F, 0.4F, 0.5F, 0.6F, 0.7F, 0.8F, 0.9F, 1.0F, 1.0F, 1.0F,
    1.0F, 1.0F, 1.0F
} ;                                    /* Referenced by: '<S958>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_t_AchIdleTime[3] =
{
    1.25F, 1.0F, 0.5F
} ;                                    /* Referenced by:
                                        * '<S685>/Vector'
                                        * '<S754>/Vector'
                                        * '<S867>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_t_AuxPumpRunningDelay[20] =
{
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F
} ;                                    /* Referenced by: '<S2669>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KtESSR_t_MaxCmbstnDlyTm[100] =
{
    0.0F, 0.2F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.3F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.6F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.9F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.7F, 0.0F, 0.0F,
    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.8F
} ;                                    /* Referenced by: '<S1610>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSRR_dn_NiRtLim[4] =
{
    -30.0F, -10.0F, 10.0F, 30.0F
} ;                                    /* Referenced by: '<S2145>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_K_AchIdleBumpSpdCtlPgain[5]
    =
{
    0.0F, 50.0F, 100.0F, 200.0F, 201.0F
} ;                                    /* Referenced by: '<S865>/Vector' */

#endif

#if (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func) || (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func)

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_K_BlendTitoEngTrq[7] =
{
    0.0F, 0.2F, 0.4F, 0.8F, 0.85F, 0.9F, 0.95F
} ;                                    /* Referenced by:
                                        * '<S900>/Vector'
                                        * '<S2435>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_K_CCFiltCoefT[4] =
{
    -30.0F, 0.0F, 40.0F, 90.0F
} ;                                    /* Referenced by: '<S998>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_K_CCNiDotGain[17] =
{
    0.0F, 0.0005F, 0.025F, 0.0375F, 0.05F, 0.0625F, 0.075F, 0.0875F, 0.1F,
    0.1125F, 0.125F, 0.1375F, 0.15F, 0.1625F, 0.175F, 0.1875F, 0.4F
} ;                                    /* Referenced by: '<S955>/Vector' */

#endif

#if (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func) || (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func)

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_K_DeltaGainMult[5] =
{
    -201.0F, -200.0F, -100.0F, 0.0F, 5.0F
} ;                                    /* Referenced by:
                                        * '<S894>/Vector'
                                        * '<S2393>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_K_EMStrtEngPgain[5] =
{
    0.0F, 50.0F, 100.0F, 200.0F, 201.0F
} ;                                    /* Referenced by: '<S2341>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_K_InitSpinEngStrtTorqGain[5]
    =
{
    0.0F, 1.0F, 5.0F, 10.0F, 20.0F
} ;                                    /* Referenced by: '<S1066>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_K_InitSpinTiProf[7] =
{
    0.0F, 0.075F, 0.15F, 0.225000009F, 0.3F, 0.412500024F, 0.525F
} ;                                    /* Referenced by: '<S1075>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_K_SpinUpEngStrtTorqGain[5] =
{
    0.0F, 1.0F, 5.0F, 10.0F, 20.0F
} ;                                    /* Referenced by: '<S1339>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_K_SpinUpSpdCtlPgainComp[6] =
{
    0.0F, 0.02F, 0.04F, 0.05F, 0.1F, 0.2F
} ;                                    /* Referenced by: '<S1544>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_K_TiEstBlndAchIdle[7] =
{
    -25.0F, -10.0F, -5.0F, 0.0F, 5.0F, 10.0F, 25.0F
} ;                                    /* Referenced by: '<S684>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_K_TiEstBlndAchIdle12vStrt[7]
    =
{
    -25.0F, -10.0F, -5.0F, 0.0F, 5.0F, 10.0F, 25.0F
} ;                                    /* Referenced by: '<S764>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_K_TiEstBlndAchIdleBumpStrt
    [7] =
{
    0.0F, 0.2F, 0.4F, 0.6F, 0.8F, 0.9F, 1.0F
} ;                                    /* Referenced by: '<S866>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_K_TiEstCKSFastSpin[6] =
{
    -50.0F, -10.0F, 0.0F, 10.0F, 50.0F, 100.0F
} ;                                    /* Referenced by: '<S1624>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_K_TiEstCKSSlowSpin[6] =
{
    -50.0F, -10.0F, 0.0F, 10.0F, 50.0F, 100.0F
} ;                                    /* Referenced by: '<S1675>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_M_AddtlDragTorq_SpinDwn[3] =
{
    40.0F, 60.0F, 90.0F
} ;                                    /* Referenced by: '<S34>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_M_AddtlDragTorq_SpinUp[9] =
{
    -10.0F, 0.0F, 10.0F, 20.0F, 45.0F, 60.0F, 75.0F, 90.0F, 105.0F
} ;                                    /* Referenced by: '<S35>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_M_CCEngImmedTrq[4] =
{
    -30.0F, 0.0F, 40.0F, 80.0F
} ;                                    /* Referenced by: '<S983>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_M_CCEngPrdtdTrq[4] =
{
    -30.0F, 0.0F, 40.0F, 80.0F
} ;                                    /* Referenced by: '<S984>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_M_ECTAddtlEngStrtTorq[7] =
{
    -25.0F, -10.0F, -5.0F, 0.0F, 5.0F, 10.0F, 25.0F
} ;                                    /* Referenced by:
                                        * '<S278>/Vector'
                                        * '<S1067>/Vector'
                                        * '<S1340>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_M_EngTrqReqBumpStrtErrBsd[3]
    =
{
    -10.0F, 0.0F, 50.0F
} ;                                    /* Referenced by: '<S1327>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_M_EngTrqReqBumpStrtTmrBsd[4]
    =
{
    5.0F, 50.0F, 100.0F, 400.0F
} ;                                    /* Referenced by: '<S1328>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_M_InitImmedTorq_ECT[3] =
{
    45.0F, 66.0F, 85.0F
} ;                                    /* Referenced by:
                                        * '<S2073>/Vector'
                                        * '<S2444>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KxESSR_M_InitSpinEngStrtTorqOffset[5] =
{
    0.0F, 1.0F, 5.0F, 10.0F, 20.0F
} ;                                    /* Referenced by: '<S1068>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_M_MinEngStrtTqSnsdCKS[4] =
{
    -10.0F, -5.0F, 10.0F, 20.0F
} ;                                    /* Referenced by: '<S1613>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_M_MinStartDetectTorq[7] =
{
    0.0F, 0.25F, 0.501F, 0.75F, 1.0F, 1.25F, 1.5F
} ;                                    /* Referenced by:
                                        * '<S1943>/Vector'
                                        * '<S2199>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_M_NiBsdTiEstFinishStp[7] =
{
    0.0F, 40.0F, 100.0F, 150.0F, 200.0F, 250.0F, 300.0F
} ;                                    /* Referenced by: '<S2610>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_M_NiBsdTiEstImmedStp[7] =
{
    0.0F, 40.0F, 100.0F, 150.0F, 200.0F, 250.0F, 300.0F
} ;                                    /* Referenced by: '<S405>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_M_PrepStpImmedTrgt[3] =
{
    30.0F, 60.0F, 100.0F
} ;                                    /* Referenced by: '<S2792>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_M_SpinUpEngStrtTorqOffset[5]
    =
{
    0.0F, 1.0F, 5.0F, 10.0F, 20.0F
} ;                                    /* Referenced by: '<S1341>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KxESSR_M_StrtEngCSInitImmedTorq_ECT[3] =
{
    45.0F, 65.1F, 85.0F
} ;                                    /* Referenced by: '<S2294>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_P_NiDotLimPowerLim[3] =
{
    0.0F, 1000.0F, 3000.0F
} ;                                    /* Referenced by:
                                        * '<S1494>/Vector'
                                        * '<S1995>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KxESSR_dn_NiDotMax_EngStrt_VoltDep[5] =
{
    125.0F, 150.0F, 175.0F, 200.0F, 250.0F
} ;                                    /* Referenced by: '<S3144>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_dn_TrajectoryNidot[7] =
{
    0.0F, 0.01F, 0.04F, 0.08F, 0.12F, 0.16F, 0.3F
} ;                                    /* Referenced by: '<S1495>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_k_AStrtNormalInterpMult[7] =
{
    180.0F, 200.0F, 210.0F, 220.0F, 230.0F, 250.0F, 300.0F
} ;                                    /* Referenced by: '<S3048>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_k_AStrtNormalInterpMultRv[7]
    =
{
    180.0F, 200.0F, 210.0F, 220.0F, 230.0F, 240.0F, 250.0F
} ;                                    /* Referenced by: '<S3049>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KxESSR_k_AStrtNormalInterpPedalPstnMult[7] =
{
    0.0F, 2.0F, 4.0F, 6.0F, 8.0F, 10.0F, 12.0F
} ;                                    /* Referenced by: '<S3050>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KxESSR_k_AStrtNormalInterpPedalPstnMultRv[7] =
{
    0.0F, 2.0F, 4.0F, 6.0F, 8.0F, 10.0F, 12.0F
} ;                                    /* Referenced by: '<S3051>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_k_EngStpAngleFactor[41] =
{
    0.0F, 0.0251F, 0.05F, 0.075F, 0.1F, 0.125F, 0.15F, 0.175F, 0.2F, 0.225F,
    0.25F, 0.275F, 0.3F, 0.325F, 0.35F, 0.375F, 0.4F, 0.425F, 0.45F, 0.475F,
    0.5F, 0.525F, 0.55F, 0.575F, 0.6F, 0.625F, 0.65F, 0.675F, 0.7F, 0.725F,
    0.75F, 0.775F, 0.8F, 0.825F, 0.85F, 0.875F, 0.9F, 0.925F, 0.95F, 0.975F,
    1.0F
} ;                                    /* Referenced by:
                                        * '<S2979>/Vector'
                                        * '<S2685>/Vector'
                                        * '<S2497>/Vector'
                                        * '<S2932>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_k_EngStpNiFactor[41] =
{
    0.0F, 0.0251F, 0.05F, 0.075F, 0.1F, 0.125F, 0.15F, 0.175F, 0.2F, 0.225F,
    0.25F, 0.275F, 0.3F, 0.325F, 0.35F, 0.375F, 0.4F, 0.425F, 0.45F, 0.475F,
    0.5F, 0.525F, 0.55F, 0.575F, 0.6F, 0.625F, 0.65F, 0.675F, 0.7F, 0.725F,
    0.75F, 0.775F, 0.8F, 0.825F, 0.85F, 0.875F, 0.9F, 0.925F, 0.95F, 0.975F,
    1.0F
} ;                                    /* Referenced by: '<S2948>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_k_StrtEngCSCltchTrqMult[7] =
{
    -25.0F, -10.0F, -5.0F, 0.0F, 5.0F, 10.0F, 25.0F
} ;                                    /* Referenced by: '<S2274>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_k_TiEstBlndStrtEng[9] =
{
    -40.0F, -30.0F, -20.0F, -10.0F, 20.0F, 40.0F, 60.0F, 80.0F, 100.0F
} ;                                    /* Referenced by:
                                        * '<S2255>/Vector'
                                        * '<S2048>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_n_DsrdCrankSpd[3] =
{
    -40.0F, -15.0F, 10.0F
} ;                                    /* Referenced by: '<S985>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_n_MinEngAutoStrtSpd[3] =
{
    -30.0F, 0.0F, 40.0F
} ;                                    /* Referenced by: '<S504>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_n_MinEngKeyStrtSpd[3] =
{
    -30.0F, 0.0F, 40.0F
} ;                                    /* Referenced by: '<S505>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_n_TargetRunSpd[3] =
{
    -30.0F, 0.0F, 40.0F
} ;                                    /* Referenced by: '<S986>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_phi_TotalTravelAng[9] =
{
    600.0F, 651.0F, 700.0F, 750.0F, 800.0F, 850.0F, 900.0F, 950.0F, 1000.0F
} ;                                    /* Referenced by: '<S2531>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_r_CCTiRamp[16] =
{
    0.0F, 0.02F, 0.04F, 0.06F, 0.08F, 0.1F, 0.12F, 0.14F, 0.16F, 0.181F, 0.2F,
    0.22F, 0.24F, 0.26F, 0.28F, 0.3F
} ;                                    /* Referenced by: '<S958>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_t_AchIdleTime[3] =
{
    -30.0F, 0.0F, 40.0F
} ;                                    /* Referenced by:
                                        * '<S685>/Vector'
                                        * '<S754>/Vector'
                                        * '<S867>/Vector'
                                        */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_t_AuxPumpRunningDelay[4] =
{
    0.0F, 20.0F, 39.0F, 61.0F
} ;                                    /* Referenced by: '<S2669>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KxESSR_t_MaxCmbstnDlyTm[10] =
{
    15.0F, 30.0F, 45.0F, 60.0F, 75.0F, 90.0F, 100.0F, 110.0F, 115.0F, 120.0F
} ;                                    /* Referenced by: '<S1610>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KyESSR_M_EngTrqReqBumpStrtErrBsd[3]
    =
{
    10.0F, 100.0F, 400.0F
} ;                                    /* Referenced by: '<S1327>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static volatile CONST(float32, ESSR_VAR_INIT) KyESSR_M_EngTrqReqBumpStrtTmrBsd[3]
    =
{
    10.0F, 80.0F, 240.0F
} ;                                    /* Referenced by: '<S1328>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KyESSR_M_MinEngStrtTqSnsdCKS[4] =
{
    1.0F, 30.0F, 50.0F, 60.0F
} ;                                    /* Referenced by: '<S1613>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KyESSR_k_AStrtNormalInterpMult[3] =
{
    0.05F, 80.0F, 120.0F
} ;                                    /* Referenced by: '<S3048>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KyESSR_k_AStrtNormalInterpMultRv[3]
    =
{
    8.0F, 90.0F, 100.0F
} ;                                    /* Referenced by: '<S3049>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KyESSR_k_AStrtNormalInterpPedalPstnMult[3] =
{
    0.05F, 15.0F, 120.0F
} ;                                    /* Referenced by: '<S3050>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT)
    KyESSR_k_AStrtNormalInterpPedalPstnMultRv[3] =
{
    0.05F, 15.0F, 120.0F
} ;                                    /* Referenced by: '<S3051>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KyESSR_t_AuxPumpRunningDelay[5] =
{
    -17.0F, -10.0F, -7.0F, 0.0F, 20.0F
} ;                                    /* Referenced by: '<S2669>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static volatile CONST(float32, ESSR_VAR_INIT) KyESSR_t_MaxCmbstnDlyTm[10] =
{
    1.0F, 30.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F, 100.0F, 115.0F, 120.0F
} ;                                    /* Referenced by: '<S1610>/Vector' */

#endif

#define STOP_SEC_CALIB_UNSPECIFIED_ESSR
#include "MemMap.h"
#define START_SEC_VAR_CLEARED_UNSPECIFIED_ESSR
#include "MemMap.h"

/* Definition for custom storage class: FCALocalSignal */
#if Rte_SysCon_Variant_ESSR_Func

static VAR(uint8, ESSR_VAR_INIT) VeESSR_Cnt_AStrtFailAttmptCntr_DS;/* '<Root>/DSM_20' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(uint16, ESSR_VAR_INIT) VeESSR_Cnt_AccumPark;/* '<S2567>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(uint8, ESSR_VAR_INIT) VeESSR_Cnt_BackupStrtAttmptCntr_DS;/* '<Root>/DSM_29' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(uint8, ESSR_VAR_INIT) VeESSR_Cnt_BumpStrtAttmptCntr_DS;/* '<Root>/DSM_30' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(uint8, ESSR_VAR_INIT) VeESSR_Cnt_CSSpinupAttmptCntr_DS;/* '<Root>/DSM_21' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(uint8, ESSR_VAR_INIT) VeESSR_Cnt_EMSpinupAttmptCntr_DS;/* '<Root>/DSM_22' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(uint8, ESSR_VAR_INIT) VeESSR_Cnt_EngStallReattmptCntr_DS;/* '<Root>/DSM_13' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_Cnt_EngStpProfCntrInit_DS;/* '<Root>/DSM_56' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_Cnt_EngStpProfCntr_DS;/* '<Root>/DSM_55' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_Cnt_EngStpProfCntr_Inc_DS;/* '<Root>/DSM_57' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_Cnt_InitSpnStepPt;/* '<S1077>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;/* '<Root>/DSM_118' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_K_AchIdleBumpSpdCtlPgain;/* '<S865>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_K_BlendRatio;/* '<S868>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_K_DeltaGainMult;/* '<S870>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_K_DeltaGainMultEM;/* '<S2393>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_K_EMLPS_StrtBlendRatio;/* '<S1383>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_K_EMStrtBlendRatio;/* '<S2342>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_K_EMStrtEngSpdCtlPgain;/* '<S2341>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_K_EMTiEstBlndCoeff;/* '<S2297>/Merge2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_K_TiEstBlndCoeff;/* '<S838>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_AchIdleBumpPSpdCtl;/* '<S880>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_AdptEngActTrq;/* '<S31>/Switch2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_AdptEngCLDeltaThrsh;/* '<S31>/Switch6' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_AdptEngCLTrq;/* '<S31>/Switch10' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_AdptEngCLTrqLtch;/* '<S77>/Switch23' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_AdptEngEstTrq;/* '<S31>/Switch3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_AdptFrctTrqErr;/* '<S76>/Switch23' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_AdptNVRamVal;/* '<S31>/Switch8' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_AdptOffsetInc;/* '<S31>/Switch4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_AdptTiMaxErr;/* '<S31>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_AdptTrqOffset;/* '<S54>/Switch21' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_CCChrgPowerLimit;/* '<S989>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_CCDragAdapt;/* '<S968>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_CCDschrgPowerLimit;/* '<S988>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_CCDschrgTq;/* '<S960>/Subtraction1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_CKSSpdCtlTi;/* '<S1599>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_CKSTiEstLim;/* '<S1568>/Product' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_CoMTrqDelta;/* '<S2634>/Sum3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EMEngTorqEstOpnLoop;/* '<S2303>/Merge' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EMTrgtEngTrqEst;/* '<S2297>/Merge1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngCapacityMinRunImmed;/* '<S3265>/Sum3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngOffECTEngStrtTorq;/* '<S278>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngOffEngFricEngStrtTorq;/* '<S246>/MinMax' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngOffEngStrtTorqLmtd;
                               /* '<S246>/SigConvForSigProp_Variant_Source_0' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngOffEngStrtTorqRaw;/* '<S246>/Summation1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngStrtEMPSpdCtl;/* '<S2304>/MinMax' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngStrtTorqSnsd;/* '<S2992>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngStrtTorq_DS;/* '<Root>/DSM_63' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngTorqEstOpnLoop;/* '<S848>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngTorqEstTmp_DS;/* '<Root>/DSM_67' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngTorqEst_DS;/* '<Root>/DSM_66' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngTrqAct_Lmtd;/* '<S80>/Switch1' */

#endif

#if !Rte_SysCon_Variant_ESSR_BlueNexus && !Rte_SysCon_Variant_ESSR_LQIR && Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngTrqReqImmedFltrOP;/* '<S1960>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_BlueNexus && Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngTrqReqImmedFltrOP;/* '<S1953>/Switch' */

#endif

#if !Rte_SysCon_Variant_ESSR_BlueNexus && !Rte_SysCon_Variant_ESSR_LQIR && Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngTrqReqImmedFltrPFS;/* '<S2207>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_BlueNexus && Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngTrqReqImmedFltrPFS;/* '<S2204>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngTrqReqImmed_DS;/* '<Root>/DSM_68' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngTrqReqPrdtdMax;/* '<S1944>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngTrqReqPrdtdMaxPFS;/* '<S2200>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngTrqReqPrdtdMin;/* '<S1944>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngTrqReqPrdtdMinPFS;/* '<S2200>/Switch2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngTrqReqPrdtd_DS;/* '<Root>/DSM_69' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_EngineLosses_DS;/* '<Root>/DSM_17' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_FastSpinInputTorq;/* '<S1618>/Subtraction1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_InitSpinECTEngStrtTorq;/* '<S1067>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_InitSpinEngFricEngStrtTorq;/* '<S1030>/Summation2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_InitSpinEngPulseEngStrtTorq;/* '<S1030>/Abs' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_InitSpinEngStrtTorqLmtd;/* '<S1062>/Sum3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_InitSpinEngStrtTorqRaw;/* '<S1030>/Summation1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_MaxSparkAuthority_DS;/* '<Root>/DSM_16' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_MinImmedExitTorqDelta_DS;/* '<Root>/DSM_83' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_MinStartDetectTorq;/* '<S1867>/Switch7' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_MinStartDetectTorqPFS;/* '<S2103>/Switch3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_MtrA_MaxTorq_DS;/* '<Root>/DSM_84' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_MtrA_MinTorq_DS;/* '<Root>/DSM_87' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_MtrBTorqCmndPrev_DS;/* '<Root>/DSM_64' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_MtrB_MaxTorq_DS;/* '<Root>/DSM_85' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_MtrB_MinTorq_DS;/* '<Root>/DSM_88' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_MtrC_MaxTorq_DS;/* '<Root>/DSM_86' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_MtrC_MinTorq_DS;/* '<Root>/DSM_89' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_MtrSpdCtrl;/* '<S935>/MinMax3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_OptEngTrqReq;/* '<S3263>/Subtraction1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_OptEngTrqReqPred;/* '<S3262>/Sum1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_P1fLmtISpdCtl;/* '<S610>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_P1fLmtPSpdCtl;/* '<S610>/proportional_term' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_P1fLmtSpdCtlPost;/* '<S610>/MinMax' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_P1fLmtSpdCtlPre;/* '<S610>/Sum//Sub1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_PrepStpImmedTgt_DS;/* '<Root>/DSM_95' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SlowSpinInputTorq;/* '<S1670>/Subtraction1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUp12VISpdCtl;/* '<S1262>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUp12VPSpdCtl;/* '<S1262>/proportional_term' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUp12VSpdCtlPost;/* '<S1282>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUp12VSpdCtlPre;/* '<S1262>/Sum//Sub1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUpECTEngStrtTorq;/* '<S1340>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUpEMLPS_ISpdCtl;/* '<S1386>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUpEMLPS_PSpdCtl;/* '<S1386>/proportional_term' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUpEMLPS_SpdCtlPost;/* '<S1399>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUpEMLPS_SpdCtlPre;/* '<S1386>/Sum//Sub1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUpEMPSpdCtl;/* '<S1779>/MinMax' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUpEM_ISpdCtl;/* '<S1770>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUpEngFricEngStrtTorq;/* '<S1309>/Summation2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUpEngPulseEngStrtTorq;/* '<S1309>/Abs' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUpEngStrtTorqLmtd;/* '<S1335>/Sum3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUpEngStrtTorqRaw;/* '<S1309>/Summation1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUpISpdCtl;/* '<S1416>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpinUpPSpdCtl;/* '<S1545>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpnDwnAddtlOffset;/* '<S10>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpnDwnAddtlTorq;/* '<S10>/Sum1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpnDwnAddtlTorqRaw;/* '<S103>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpnUpAddtlOffset;/* '<S10>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpnUpAddtlTorq;/* '<S10>/Sum' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SpnUpAddtlTorqRaw;/* '<S111>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_SprkTorqCtrl_DurRun;/* '<S935>/MinMax2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_StrEngISpdCtl;/* '<S2044>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_StrtEngPFSISpdCtl;/* '<S2186>/Subtraction1' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_StrtEngPFSPSpdCtl;/* '<S2195>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_StrtEngPSpdCtl;/* '<S2059>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_StrtTypEngSnsdTorqAchvd_DS;/* '<Root>/DSM_111' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_StrtTypInitImmedTorq_DS;/* '<Root>/DSM_115' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_StrtTypInitPredTorq_DS;/* '<Root>/DSM_116' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_TiEstEMOpnLp;/* '<Root>/DSM_11' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_TiEstMin;/* '<S21>/Merge' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_TiEstP1fOpLp;/* '<Root>/DSM_10' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_M_TrgtEngTrqEst;/* '<S838>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_P_BatMaxLim;/* '<S1019>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_P_BatMinLim;/* '<S1020>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AStopCoastDwnLmp;/* synthesized block */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AStopEngCOMLmp;/* synthesized block */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AStopReStrtPrepLmp;/* synthesized block */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AStrtFailed_DS;/* '<Root>/DSM_23' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AStrtPBatBoostReq_DS;/* '<Root>/DSM_24' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AStrtReattmptAllowed_DS;/* '<Root>/DSM_25' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ActvBeltSlpCtrlAchvd;/* '<S1418>/Logical Operator24' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ActvBeltSlpCtrlAchvdStrtEng;/* '<S1861>/Logical Operator24' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ActvBeltSlpCtrlAchvdTmrExpired;/* '<S1418>/Greater  Than13' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ActvBeltSlpCtrlCndnsSet;/* '<S1418>/Logical Operator23' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ActvBeltSlpCtrlCndnsSetStrtEng;/* '<S1861>/Logical Operator23' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ActvBeltSlpCtrlTmrStrtEng;/* '<S1861>/Greater  Than13' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptAbrt;/* '<S74>/Switch23' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptActv;/* '<S75>/Switch23' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptEngCLFall;/* '<S73>/Switch23' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptEngCLFallRaw;/* '<S71>/Switch23' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptEngCLRaise;/* '<S72>/Switch23' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptEngCLRaiseRaw;/* '<S70>/Switch23' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptLrnErrRaise;/* '<S69>/Switch23' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptLrnErrRaw;/* '<S68>/Switch23' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptSpnDwnESSRFails;/* '<S31>/Comparison7' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptSpnDwnTrg;/* '<S31>/Logical2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptSpnDwnUpdtAllwd;/* '<S10>/Logical9' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptSpnDwnUpdtRaw;/* '<S31>/Comparison2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptSpnUpESSRFails;/* '<S31>/Comparison1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptSpnUpTrg;/* '<S31>/Logical1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptSpnUpUpdtAllwd;/* '<S10>/Logical8' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptSpnUpUpdtRaw;/* '<S31>/Comparison9' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptStpUpdtTrg;/* '<S31>/Logical5' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptStrtUpdtTrg;/* '<S31>/Logical4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptTrg;/* '<S31>/Logical3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptUpdtActv;/* '<S33>/Logical3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AdptUpdtTrg;/* '<S31>/Logical8' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AngleLrnWaitTmPFS;/* '<S2642>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_AuxPumpRunning;/* '<S2634>/AND3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_BSGStrtFailed_DS;/* '<Root>/DSM_28' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_BackUpStartEng_DS;/* '<Root>/DSM_4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_BackupStrtEngOn;/* '<S2999>/Gain' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_BumpStrtFailed_DS;/* '<Root>/DSM_1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_BumpStrtSpdChk;/* '<S845>/Comparison4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_CltchStckOn_DS;/* '<Root>/DSM_32' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ClthErlyExitLmp;/* synthesized block */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ClthLwrThresLmp;/* synthesized block */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_CmbstnDlyHold;/* '<S1604>/Equal1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_CoastDownTrigger_DS;/* '<Root>/DSM_33' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_CoastDwnStopMet;/* '<S178>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_CompressTstOn_DS;/* '<Root>/DSM_35' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_DSO2Mon_Chk;/* '<S2483>/Logical3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_DSO2Mon_Cmplt;/* '<S2514>/OR1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_DSO2Mon_Cmplt_Chk;/* '<S2483>/Greater  Than6' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_DSO2Mon_Cmplt_DS;/* '<Root>/DSM_36' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_DSO2Mon_Enbld;/* '<S2506>/Logical Operator2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_DSO2Mon_Enbld_Chk;/* '<S2483>/Logical Operator6' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_DSO2Mon_Enbld_DS;/* '<Root>/DSM_37' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_DSO2Mon_Enbld_FE;/* '<S2513>/AND' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_DSO2Mon_InitTm_Chk;/* '<S2483>/Greater  Than5' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_DSO2Mon_TrqTm_Chk;/* '<S2483>/Greater  Than7' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_DSO2Mon_Trq_Chk;/* '<S2483>/Logical Operator1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_DisableNc1DotLim_DS;/* '<Root>/DSM_38' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_DsblFuelReq_DS;/* '<Root>/DSM_39' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_DsblNc1ClsdLoopCntrl_DS;/* '<Root>/DSM_140' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_DsblNiClsdLoopCntrl_DS;/* '<Root>/DSM_40' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_EMErlyExitLmp;/* synthesized block */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ETRQEMStrtEng;/* '<S2305>/Logical13' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ETRQStrtEng;/* '<S1863>/Logical13' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ETRQStrtEngP1fLmt;/* '<S578>/Logical13' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ETRQStrtEngPFS;/* '<S2081>/Logical13' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ETSDsblFuelReq_DS;/* '<Root>/DSM_6' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_EngParking;/* '<S2591>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_EngReStrtAttmpt_DS;/* '<Root>/DSM_141' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_EngReStrtInDrvOK;/* '<S178>/Logical5' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_EngRestartReq_DS;/* '<Root>/DSM_47' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_EngStallDet;/* '<S316>/Comparison4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_EngStartAbort_DS;/* '<Root>/DSM_48' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_EngTrqAct_LmtdLtchd;/* '<S1609>/OR1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ErlyExitLmp;/* synthesized block */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_FinishPosEng;/* '<S2564>/Logical3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_FinishStopEngParkAngleFound;
                                 /* '<S2577>/FinishStopTgtEngParkAngle_Chart' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_FuelDlyHold;/* '<S1571>/Logical Operator2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_HCP_StopStart_Fault_DS;/* '<Root>/DSM_71' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ImmedStpAllCylActCmplt;/* '<S373>/AND2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ImmedStpDmprDelayCmplt;/* '<S389>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_InhibitShiftToMode_DS;/* '<Root>/DSM_72' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_InitSpin_48VP2CoastDown;/* '<S1054>/Logical4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_InitSpin_CoastDownTrig;/* '<S1022>/Logical Operator3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_InitSpnEngMvmntDet;/* '<S1029>/AND' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_InitSpnTmrCmplt;/* '<S1034>/Greater  Than2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_InputTorqOverride_DS;/* '<Root>/DSM_78' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_KeyStrtEngModing_DS;/* '<Root>/DSM_79' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_KeyType;/* '<S3011>/Merge1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_LmtP1fRestartReq_DS;/* '<Root>/DSM_5' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_LwrThresLmp;/* synthesized block */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_MinRun2StpTm_DS;/* '<Root>/DSM_9' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_MtrAZeroTrq;/* '<S849>/Logical1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_NbTgtReq_DS;/* '<Root>/DSM_7' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_NiDotMaxActive_DS;/* '<Root>/DSM_2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_NiDotMinActive_DS;/* '<Root>/DSM_3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_NiMaxActive_DS;/* '<Root>/DSM_51' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_P1f12VStrtFailCoastDownDtct;/* synthesized block */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_PFSRunReq_DS;/* '<Root>/DSM_94' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_ParamInterp;/* '<S3011>/Merge2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_RampNiBfrChk;/* '<S1876>/Logical4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_RmpDwnReq_DS;/* '<Root>/DSM_96' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_RmpDwnStrtAngInRng;/* '<S2525>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_RmpDwnStrtAngInRngFnl;/* '<S2491>/AND3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SE_EngFuelOn_DS;/* '<Root>/DSM_97' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SlowSpinActv;/* '<S1669>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SnsdChkCmplt;/* '<S1607>/Logical Operator2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SnsdChkCmpltLtchd;/* '<S1607>/Logical Operator1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SpdChk_EMStrtEng;/* '<S2361>/Comparison4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SpdChk_PiFLmtStrtEng;/* '<S615>/Comparison4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SpdChk_StrtEng;/* '<S1902>/Comparison4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SpdChk_StrtEngPFS;/* '<S2108>/Comparison4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SpinUp_CoastDownTrig;/* '<S1418>/Logical Operator14' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SpnUpBmpStrtFailCnfrmd;/* '<S1299>/Logical Operator4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SpnUpBmpStrtFailCoastDownDtct;/* '<S1299>/Comparison4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SpnUpBmpStrtFailEngRunAccmTrg;/* '<S1299>/Comparison1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SpnUpBmpStrtFailFinTmrExpd;/* '<S1299>/Logical Operator6' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SpnUpBmpStrtFailPend;/* '<S1299>/Logical Operator15' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SpnUpBmpStrtFailRaw;/* '<S1299>/Logical Operator9' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SpnUpBmpStrtFailTCM;/* '<S1332>/Logical6' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_SpnUpLowPwrFail;/* '<S928>/Logical Operator2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_StrEngBeltSlipCstDwn;/* '<S1861>/Logical Operator1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_StrEngSpdChkCSFnl;/* '<S2262>/Logical' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_Strt2RunSpdChk;/* '<S1248>/Comparison4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_Strt2RunSpdChk_EMLPS;/* '<S1365>/Comparison4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_StrtEngCSCltchTrqChk;/* '<S2262>/Comparison1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_StrtEngCSRunDtct;/* '<S2237>/AND' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_StrtEngCSSpdChk;/* '<S2262>/Comparison4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_StrtEngCoastDwnSpd;/* '<S1861>/Comparison4' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_StrtStopFail_DS;/* '<Root>/DSM_103' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_StrtTypChngDisbl;/* '<S1023>/Logical6' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_TCMOpenDisconnctCltch_DS;/* '<Root>/DSM_139' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_TgtAngleAboveCrnt;/* '<S2612>/OR1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_TgtStpAngRmpDwnExtSpd;/* '<S2845>/Logical2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(boolean, ESSR_VAR_INIT) VeESSR_b_UseECMTorqForStartEngInit_DS;/* '<Root>/DSM_136' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(uint16, ESSR_VAR_INIT) VeESSR_d_TCMFailuresMasked;/* '<S1332>/Bitwise Logical Operator6' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_DtrmnNidot;/* '<S3238>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_InputAcceltnProf_DS;/* '<Root>/DSM_74' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_InputJerkProfAchIdle;/* '<S692>/Sum17' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_InputJerkProfAchIdle12V;/* '<S773>/Sum17' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_InputJerkProfImmedStop;/* '<S410>/Sum17' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_InputJerkProfPrepStop;/* '<S2735>/Sum17' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_InputJerkProfRampDwn;/* '<S2876>/Sum17' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_InputJerkProfRestartPrep;/* '<S1192>/Sum17' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_InputJerkProfSpinUpCKSSlow;/* '<S1681>/Sum17' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_InputJerkProfSpinUpEMEng;/* '<S1809>/Sum17' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_InputJerkProfSpinUpEng;/* '<S1501>/Sum17' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_InputJerkProfSpinupCKSFast;/* '<S1630>/Sum17' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_InputJerkProfStartEng;/* '<S2006>/Sum17' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_InputJerkProfStartEngEM;/* '<S2398>/Sum17' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_InputJerkProfStartEngPFS;/* '<S2149>/Sum17' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_JerkMaxSpinup;/* '<S1423>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_JerkMaxSpinupEM;/* '<S1773>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_NiDotMax;/* '<S158>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_NiDotMaxForAStop;/* '<S2799>/Switch3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_NiDotMaxForPFS;/* '<S2634>/MinMax1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_NiDotMaxShaped;/* '<S1431>/MinMax' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_NiDotMax_SpinUp;/* '<S1496>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_NiDotMax_StartEng;/* '<S1996>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_NiDotMin;/* '<S157>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_NiDotMinForAStop;/* '<S2799>/Switch5' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_NiDotMinForPFS;/* '<S2634>/MinMax2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_StrtTypJerkMaxStartEng_DS;/* '<Root>/DSM_120' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_StrtTypJerkMax_DS;/* '<Root>/DSM_122' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_StrtTypJerkMinStartEng_DS;/* '<Root>/DSM_123' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_StrtTypJerkMin_DS;/* '<Root>/DSM_121' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_StrtTypNiDotMax_DS;/* '<Root>/DSM_126' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_StrtTypNiDotMax_EngStrt_DS;/* '<Root>/DSM_127' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_StrtTypNiDotMin_DS;/* '<Root>/DSM_128' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_dn_TargetAcceltn_DS;/* '<Root>/DSM_77' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeTRAR_e_EngCntrlMode, ESSR_VAR_INIT) VeESSR_e_EngCntrlMode_DS;/* '<Root>/DSM_43' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeHSER_e_RngEqnSel, ESSR_VAR_INIT) VeESSR_e_EngStallRngEqn_DS;/* '<Root>/DSM_45' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeESSR_e_EngStartStopSt, ESSR_VAR_INIT) VeESSR_e_EngStartStopStPrev;/* '<S167>/Dsr_EngStartStopSt' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeESSR_e_EngStartStopSt, ESSR_VAR_INIT)
    VeESSR_e_EngStartStopStPrev_DS;    /* '<Root>/DSM_50' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeESSR_e_EngStartStopSt, ESSR_VAR_INIT) VeESSR_e_EngStartStopSt_DS;/* '<Root>/DSM_49' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeESSR_e_EngStrtActuatorTyp, ESSR_VAR_INIT)
    VeESSR_e_EngStrtActuatorTyp;       /* '<Root>/DSM_8' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeESSR_e_StrtType, ESSR_VAR_INIT) VeESSR_e_EngStrtProfType_DS;/* '<Root>/DSM_61' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeESSR_e_EngStrtStpMd, ESSR_VAR_INIT) VeESSR_e_EngStrtStpMd_DS;/* '<Root>/DSM_62' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeESSR_e_EngStrtType, ESSR_VAR_INIT) VeESSR_e_EngStrtType_DS;/* '<Root>/DSM_65' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TePTAR_e_ImmediateTorqRespType, ESSR_VAR_INIT)
    VeESSR_e_EngTrqRespType_DS;        /* '<Root>/DSM_70' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeESSR_e_HybEngSysActv, ESSR_VAR_INIT) VeESSR_e_HybEngSysActv_DS;/* '<Root>/DSM_12' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeESSR_e_IdleCtrlrSelect, ESSR_VAR_INIT)
    VeESSR_e_IdleCtrlrSelect_12vStrt;  /* '<S825>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeESSR_e_STMTrigger, ESSR_VAR_INIT) VeESSR_e_STMTrigger_DS;/* '<Root>/DSM_99' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(TeESSR_e_STMTrigger, ESSR_VAR_INIT) VeESSR_e_SpnUpBmpStrtFailArbTrg;/* '<S1315>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeESSR_e_StrtStpFailDTC, ESSR_VAR_INIT) VeESSR_e_StrtStpFailDTC;/* '<Root>/DSM_104' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TePTAR_e_ImmediateTorqRespType, ESSR_VAR_INIT)
    VeESSR_e_StrtStpTypEngTorqRespType_DS;/* '<Root>/DSM_107' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeESSR_e_TCM_StartStopType, ESSR_VAR_INIT)
    VeESSR_e_TCM_StartStopType_DS;     /* '<Root>/DSM_132' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeESSR_e_TCM_TransitionStatus, ESSR_VAR_INIT)
    VeESSR_e_TCM_TransitionStatus_DS;  /* '<Root>/DSM_44' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(TeESSR_e_TransFldPumpSel, ESSR_VAR_INIT) VeESSR_e_TransFldPmpSel_DS;/* '<Root>/DSM_135' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(uint32, ESSR_VAR_INIT) VeESSR_g_BSGStrtFailRsn_DS;/* '<Root>/DSM_27' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(uint32, ESSR_VAR_INIT) VeESSR_g_StrtStpFailPhaseSelect_DS;/* '<Root>/DSM_106' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(uint32, ESSR_VAR_INIT) VeESSR_g_StrtStpFailPhase_DS;/* '<Root>/DSM_105' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(uint8, ESSR_VAR_INIT) VeESSR_i_CalLoader_DS;/* '<Root>/DSM_31' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(uint8, ESSR_VAR_INIT) VeESSR_i_CalLoader_Local;/* '<S3011>/Merge3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_i_DsrdCrkSpd_DS;/* '<Root>/DSM_41' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(uint8, ESSR_VAR_INIT) VeESSR_i_OptInputSpdIndx;/* '<S9>/Selector1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_k_AStrtNormalInterp;/* '<S3020>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_k_AStrtNormalInterpFwd;/* '<S3010>/MinMax2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_k_AStrtNormalInterpRev;/* '<S3010>/Sum1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_k_AngleRatioRaw;/* '<S2915>/Merge2' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_k_EngStpProfNiDotGain;/* '<S2915>/Merge1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_k_EngStpProfNiDotGain_DS;/* '<Root>/DSM_58' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_k_StrtTypEngTorqReqFltT_DS;/* '<Root>/DSM_112' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_k_StrtTypEngTorqReqImmedFltD_DS;/* '<Root>/DSM_113' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_k_StrtTypFrstOrdLwPassT_DS;/* '<Root>/DSM_114' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_k_StrtTypInitSpinScaler_DS;/* '<Root>/DSM_119' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_k_StrtTypScndOrdLwPassT_DS;/* '<Root>/DSM_131' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_k_TorqCancelGain_DS;/* '<Root>/DSM_134' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_AchIdleBumpSpdError;/* '<S841>/Summation5' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_BumpStrtExitIntgrlVal;/* '<S881>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_BumpStrtTrgtRunSpd;/* '<S845>/Sum3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_CCSpdErrIntgl;/* '<S969>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_CCTargetRunSpd;/* '<S986>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_CCTransInSpdFlt;/* '<S999>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_CKSSpdError;/* '<S1568>/Summation5' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_DsrdCrankSpd;/* '<S985>/Vector' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_EMEngMinTgtPCtrl;/* '<S2346>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_EngMinTgtAchIdle;/* '<S870>/MinMax1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_EngMinTgtPCtrl;/* '<S870>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_EngStrtEMSpdError;/* '<S2304>/Summation5' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_EngStrtPFSSpdError;/* '<S2188>/Summation5' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_EngStrtSpdError;/* '<S2045>/Summation5' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_InputSpdLead_SpinUp;/* '<S1431>/Sum' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_InputSpdLead_StartEng;/* '<S1988>/Sum' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_InputSpeedProfile_DS;/* '<Root>/DSM_75' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_MinEngStrtSpd_DS;/* '<Root>/DSM_82' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_NbTgtBattPwr;/* '<S1348>/Gain' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_NbTgtBattPwrAchIdle;/* '<S899>/Gain' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_NbTgt_DS;/* '<Root>/DSM_90' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_Ni1stFlt_DS;/* '<Root>/DSM_91' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_NiAfterCombEM;/* '<S2297>/Switch3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_NiAfterCombustion;/* '<S1876>/Switch3' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_NiPred_DS;/* '<Root>/DSM_14' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_NiTargetSpinUp;/* '<S1413>/Merge' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_NiTargetStrtEng_PFS;/* '<S2092>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_OptInputSpd_DS;/* '<Root>/DSM_92' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_OptInputSpd_Local;/* '<S9>/Multiport_Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_P1f12VStrtCDAccmIn;/* '<S1271>/Product1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_P1f12VStrtFailCDAccm;/* '<S1273>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_P1fLmtSpdError;/* '<S610>/Summation5' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_SpinUp12VSpdError;/* '<S1262>/Summation5' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_SpinUpEMLPS_SpdError;/* '<S1386>/Summation5' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_SpinUpEMSpdError;/* '<S1779>/Summation5' */

#endif

#if Rte_SysCon_Variant_ESSR_12vBSG && Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_SpinUpSpdError;/* '<S1434>/Summation5' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_SpnUpBmpStrtEngRunAccmIn;/* '<S1299>/Summation5' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_SpnUpBmpStrtFailCDAccm;/* '<S1302>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_SpnUpBmpStrtFailEngRunAccm;/* '<S1301>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_StrtEngCSErr;/* '<S2262>/Product' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_StrtTypAStrtSpinUpExtSpd_DS;/* '<Root>/DSM_108' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_StrtTypMaxStrtNiNoFuel_DS;/* '<Root>/DSM_125' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_TargetSpeed_DS;/* '<Root>/DSM_76' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_TgtIdleSpd_DS;/* '<Root>/DSM_133' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_TransInSpdFlt;/* '<S22>/Subtraction1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_n_TransInSpdFlt_DS;/* '<Root>/DSM_15' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_p_StrtTypAStrtSpinUpManPrs_DS;/* '<Root>/DSM_109' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_phi_ActAngRemainingRaw;/* '<S2915>/Subtraction' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_phi_CombstDelay_DS;/* '<Root>/DSM_34' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_phi_EngAng720EstOld_DS;/* '<Root>/DSM_42' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_phi_EngStpAngleElpsdDes_DS;/* '<Root>/DSM_53' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_phi_EngStpAngleElpsd_DS;/* '<Root>/DSM_52' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_phi_EngStpRmpDwnStrtAng_DS;/* '<Root>/DSM_60' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_phi_FinishStopParkEngAngDiff;/* '<S2585>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_phi_FinishStopTgtEngParkAngle;
                                 /* '<S2577>/FinishStopTgtEngParkAngle_Chart' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_phi_InitEngAng720_DS;/* '<Root>/DSM_73' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_phi_ProfAngRemaining;/* '<S2915>/Multiplication' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_phi_RmpDwnStrtAng;/* '<S2532>/Multiplication' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_phi_SpinDwnInitAngle;/* '<S2974>/Multiplication' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_phi_StrtTypInitSpinBrkAng_DS;/* '<Root>/DSM_117' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_scl_AEMDMtrAGain_DS;/* '<Root>/DSM_18' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_scl_AEMDMtrBGain_DS;/* '<Root>/DSM_19' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_scl_SpdCtlGainMod_DS;/* '<Root>/DSM_100' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_scl_StrtTypPulseCnclTorqScaler_DS;/* '<Root>/DSM_130' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_t_ActvBeltSlpCtrlAchvStrtEng;/* '<S1896>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_t_ActvBeltSlpCtrlAchvdTmr;/* '<S1480>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_t_CmbstnDlyTm;/* '<S1612>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_t_DSO2Mon_EnbldTm;/* '<S2510>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_t_DSO2Mon_TrqTm;/* '<S2511>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_t_EngIdleTm_DS;/* '<Root>/DSM_46' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_t_KneePtTm_DS;/* '<Root>/DSM_80' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_t_MainSTMTmr_DS;/* '<Root>/DSM_81' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_t_MaxStTm_PFS;/* '<S2670>/Switch' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_t_PBatBoostTm_DS;/* '<Root>/DSM_93' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_t_STMTmr_DS;/* '<Root>/DSM_98' */

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_t_SpnUpBmpStrtFailTmr;/* '<S1331>/Switch1' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_t_StrtTypAirflowTrqMaxTm_DS;/* '<Root>/DSM_110' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_t_StrtTypManPrsMaxTm_DS;/* '<Root>/DSM_124' */

#endif

#if Rte_SysCon_Variant_ESSR_Func

static VAR(float32, ESSR_VAR_INIT) VeESSR_t_StrtTypPhaserDelayTm_DS;/* '<Root>/DSM_129' */

#endif

#define STOP_SEC_VAR_CLEARED_UNSPECIFIED_ESSR
#include "MemMap.h"

/* Invariant block signals (default storage) */
#define START_SEC_CONST_UNSPECIFIED_ESSR
#include "MemMap.h"

CONST(ConstB_ESSR_ac_T, ESSR_VAR_INIT) ESSR_ac_ConstB =
{

#if Rte_SysCon_Variant_ESSR_NF

    CeTRAR_e_TorqueMode,               /* '<S3286>/Constant' */

#define CONSTB_ESSR_AC_T_VARIANT_EXISTS
#endif

#if Rte_SysCon_Variant_ESSR_NF

    CePTAR_e_Inactive,                 /* '<S3287>/Constant' */

#define CONSTB_ESSR_AC_T_VARIANT_EXISTS
#endif

#if Rte_SysCon_Variant_ESSR_NF

    CeESSR_e_Off,                      /* '<S3288>/Constant' */

#define CONSTB_ESSR_AC_T_VARIANT_EXISTS
#endif

#if Rte_SysCon_Variant_ESSR_NF

    CeESSR_e_Trans_Stat_Off,           /* '<S3285>/Constant' */

#define CONSTB_ESSR_AC_T_VARIANT_EXISTS
#endif

#if Rte_SysCon_Variant_ESSR_NF

    CeESSR_e_NoAction,                 /* '<S3290>/Constant' */

#define CONSTB_ESSR_AC_T_VARIANT_EXISTS
#endif

#if Rte_SysCon_Variant_ESSR_NF

    CeESSR_e_NoStart,                  /* '<S3284>/Constant' */

#define CONSTB_ESSR_AC_T_VARIANT_EXISTS
#endif

#if Rte_SysCon_Variant_ESSR_NF

    CeESSR_e_HybEngDisabled,           /* '<S3276>/Const1' */

#define CONSTB_ESSR_AC_T_VARIANT_EXISTS
#endif

#if Rte_SysCon_Variant_ESSR_NF

    CeESSR_e_Stopped,                  /* '<S3289>/Constant' */

#define CONSTB_ESSR_AC_T_VARIANT_EXISTS
#endif

#if Rte_SysCon_Variant_ESSR_NF

    CeESSR_e_NoStrt,                   /* '<S3280>/Constant' */

#define CONSTB_ESSR_AC_T_VARIANT_EXISTS
#endif

#if Rte_SysCon_Variant_ESSR_NF

    CeESSR_e_NoStrt,                   /* '<S3281>/Constant' */

#define CONSTB_ESSR_AC_T_VARIANT_EXISTS
#endif

#if Rte_SysCon_Variant_ESSR_NF

    CeESSR_e_Stop,                     /* '<S3283>/Constant' */

#define CONSTB_ESSR_AC_T_VARIANT_EXISTS
#endif

#if Rte_SysCon_Variant_ESSR_NF

    CeESSR_e_NoActTyp,                 /* '<S3282>/Constant' */

#define CONSTB_ESSR_AC_T_VARIANT_EXISTS
#endif

#if Rte_SysCon_Variant_ESSR_NF

    CeESSR_e_EngOff                    /* '<S3279>/Constant' */
#define CONSTB_ESSR_AC_T_VARIANT_EXISTS
#endif
#ifndef CONSTB_ESSR_AC_T_VARIANT_EXISTS
    0
#endif                           /* CONSTB_ESSR_AC_T_VARIANT_EXISTS undefined */
};

#define STOP_SEC_CONST_UNSPECIFIED_ESSR
#include "MemMap.h"

/* Constant parameters (default storage) */
#define START_SEC_CONST_UNSPECIFIED_ESSR
#include "MemMap.h"

CONST(ConstP_ESSR_ac_T, ESSR_VAR_INIT) ESSR_ac_ConstP =
{

#if Rte_SysCon_Variant_ESSR_Func

    /* Pooled Parameter (Expression: )
     * Referenced by:
     *   '<S3048>/Vector'
     *   '<S3049>/Vector'
     *   '<S3050>/Vector'
     *   '<S3051>/Vector'
     */
    {
        6U, 2U
    },

#endif

#if Rte_SysCon_Variant_ESSR_Func

    /* Computed Parameter: Vector_maxIndex
     * Referenced by: '<S1610>/Vector'
     */
    {
        9U, 9U
    },

#endif

#if Rte_SysCon_Variant_ESSR_Func

    /* Computed Parameter: Vector_maxIndex_g
     * Referenced by: '<S1613>/Vector'
     */
    {
        3U, 3U
    },

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

    /* Computed Parameter: Vector_maxIndex_a
     * Referenced by: '<S1327>/Vector'
     */
    {
        2U, 2U
    },

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

    /* Computed Parameter: Vector_maxIndex_n
     * Referenced by: '<S1328>/Vector'
     */
    {
        3U, 2U
    },

#endif

#if Rte_SysCon_Variant_ESSR_Func

    /* Computed Parameter: Vector_maxIndex_l
     * Referenced by: '<S2669>/Vector'
     */
    {
        3U, 4U
    },

#endif

#ifndef CONSTP_ESSR_AC_T_VARIANT_EXISTS

    0
#endif
};

#define STOP_SEC_CONST_UNSPECIFIED_ESSR
#include "MemMap.h"

/* Block signals (default storage) */
#define START_SEC_VAR_CLEARED_UNSPECIFIED_ESSR
#include "MemMap.h"

VAR(B_ESSR_ac_T, ESSR_VAR_INIT) ESSR_ac_B;

#define STOP_SEC_VAR_CLEARED_UNSPECIFIED_ESSR
#include "MemMap.h"

/* Block states (default storage) */
#define START_SEC_VAR_CLEARED_UNSPECIFIED_ESSR
#include "MemMap.h"

VAR(DW_ESSR_ac_T, ESSR_VAR_INIT) ESSR_ac_DW;

#define STOP_SEC_VAR_CLEARED_UNSPECIFIED_ESSR
#include "MemMap.h"

/* Previous zero-crossings (trigger) states */
#define START_SEC_VAR_CLEARED_UNSPECIFIED_ESSR
#include "MemMap.h"

VAR(PrevZCX_ESSR_ac_T, ESSR_VAR_INIT) ESSR_ac_PrevZCX;

#define STOP_SEC_VAR_CLEARED_UNSPECIFIED_ESSR
#include "MemMap.h"
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESS_AStrtSmooth_iCalLoader_Four(P2VAR(uint8,
    AUTOMATIC, ESSR_VAR_INIT) rty_i_CalLoader, P2VAR(boolean, AUTOMATIC,
    ESSR_VAR_INIT) rty_b_KeyType, P2VAR(boolean, AUTOMATIC, ESSR_VAR_INIT)
    rty_Interp);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_TkFrstPtMin(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Out1);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_EngOffEnt(VAR
    (TeSTRR_e_HybStrtrSt, AUTOMATIC) rtu_HybStrtrSt);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_EngRunEnt(void);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_EngRunDur(VAR(boolean, AUTOMATIC)
    rtu_EngOnReq, VAR(float32, AUTOMATIC) rtu_TransInSpdFlt, VAR(float32,
    AUTOMATIC) rtu_InputAccelProfile, VAR(float32, AUTOMATIC)
    rtu_InputSpeedProfile, VAR(TeSTRR_e_EngStrtStopType, AUTOMATIC)
    rtu_EngStrtStopType, VAR(float32, AUTOMATIC) rtu_EngTrqActual, VAR(boolean,
    AUTOMATIC) rtu_EngineStallDetected, VAR(TeHSER_e_RngEqnSel, AUTOMATIC)
    rtu_VeHSER_e_RngEqnSel, P2VAR(DW_ESSC_EngRunDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_VeESSR_M_BCTiMargin_DS);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_MainEngStartEntry(VAR
    (TeSTRR_e_EngStrtStopType, AUTOMATIC) rtu_VeSTRR_e_EngStrtStopType, VAR
    (float32, AUTOMATIC) rtu_VeENGR_T_EngCoolantTemp);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_MainEngStartExit(void);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_MainEngStopEntry(void);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_MainEngStopExit(void);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_ImmedStopEnt(VAR(float32,
    AUTOMATIC) rtu_Ni, VAR(TeTRAR_e_HybCmndEngTorqRespTyp, AUTOMATIC)
    rtu_TRAR_TrqRespType, VAR(float32, AUTOMATIC) rtu_HybCmndEngTorqImmed);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_If_RampDown_P1C68(void);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_ImmedStopDur_Init(P2VAR
    (DW_ESSC_ImmedStopDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_ImmedStopDur(VAR(float32,
    AUTOMATIC) rtu_Ni, VAR(float32, AUTOMATIC) rtu_NiDotMax, VAR(float32,
    AUTOMATIC) rtu_NiDotMin, VAR(TeENGR_e_CylinderDeacModes, AUTOMATIC)
    rtu_CylinderDeacMode, VAR(float32, AUTOMATIC) rtu_EngTrqActual, VAR(float32,
    AUTOMATIC) rtu_SpinDownDragCorr, VAR(boolean, AUTOMATIC) rtu_PSAActv, VAR
    (boolean, AUTOMATIC) rtu_PTCrnkActv, VAR(float32, AUTOMATIC)
    rtu_VeHSER_n_NiMax, P2VAR(DW_ESSC_ImmedStopDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(ZCE_ESSC_ImmedStopDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localZCE, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_CoastDownEnt(VAR(boolean,
    AUTOMATIC) rtu_VeESSR_b_EngOnReq);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_CoastDownDur(VAR(float32,
    AUTOMATIC) rtu_TransInSpdFlt, VAR(TeSTRR_e_EngStrtStopType, AUTOMATIC)
    rtu_VeSTRR_e_EngStrtStopType, VAR(boolean, AUTOMATIC) rtu_VeESSR_b_EngOnReq,
    VAR(boolean, AUTOMATIC) rtu_P20Trq, VAR(uint32, AUTOMATIC) rtu_AStpInhbtRsn2,
    VAR(boolean, AUTOMATIC) rtu_BmpStrtEngOn, VAR(boolean, AUTOMATIC)
    rtu_VeSTRR_b_BumpStrtInhbt, VAR(TeTRNR_e_TCMGearStat, AUTOMATIC)
    rtu_VeTRNR_e_ActualGear, VAR(TeHCCR_e_ClutchStatus, AUTOMATIC)
    rtu_VeTRNR_e_ILEStat);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_CoastDownExit(VAR(boolean,
    AUTOMATIC) rtu_VeESSR_b_EngOnReq, VAR(boolean, AUTOMATIC) rtu_PSAActv);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_RestartPrepDur_Init(P2VAR
    (DW_RestartPrepDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_RestartPrepDur(VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_OptInputSpd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_AddtlDragTorq, VAR(float32, AUTOMATIC) rtu_VeHSER_n_NiMax, VAR
    (float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMax, VAR(float32, AUTOMATIC)
    rtu_VeHSER_dn_NiDotMin, VAR(float32, AUTOMATIC) rtu_HTDR_TiMin, P2VAR
    (DW_RestartPrepDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR
    (ZCE_RestartPrepDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localZCE);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_LowPower(P2VAR
    (TeESSR_e_EngStrtActuatorTyp, AUTOMATIC, ESSR_VAR_INIT) rty_Out1);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_InitEngSpinEnt(VAR(float32, AUTOMATIC)
    rtu_VeEPCR_phi_EngAngle720Est, VAR(float32, AUTOMATIC)
    rtu_VeESMR_P_BatSTMaxLim, VAR(float32, AUTOMATIC) rtu_VeESMR_P_BatSTMinLim,
    VAR(boolean, AUTOMATIC) rtu_VeSTRR_b_BumpStrtEngOn);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpinUpEng_SFS_Ent(void);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_If_AutoStrt_P1C65(P2VAR
    (TeESSR_e_StrtStpFailDTC, AUTOMATIC, ESSR_VAR_INIT) rty_Out1);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_If_AutoStrt_NoFault(P2VAR
    (TeESSR_e_StrtStpFailDTC, AUTOMATIC, ESSR_VAR_INIT) rty_Out1);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpinUpEng_SFS_Dur_Init(P2VAR
    (DW_SpinUpEng_SFS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpinUpEng_SFS_Dur(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_AddtlDragTorq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_TransInSpdFlt, VAR(float32, AUTOMATIC) rtu_VeESSR_n_OptInputSpd,
    VAR(float32, AUTOMATIC) rtu_VeETQR_M_EngCapacityMinRunI, VAR(float32,
    AUTOMATIC) rtu_VeCSVR_n_PrimNoSgndFltrd, VAR(float32, AUTOMATIC)
    rtu_VeESPR_n_MaxEngSpdCap, VAR(TeENGR_e_Cam_Phsr_Stat, AUTOMATIC)
    rtu_VeENGR_e_Cam_Phsr_Stat, VAR(float32, AUTOMATIC) rtu_BatVoltModMin, VAR
    (float32, AUTOMATIC) rtu_VeETQR_M_EngTrqActual, VAR(float32, AUTOMATIC)
    rtu_VeETQR_r_MaxSparkAuthority, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngineLosses, VAR(boolean, AUTOMATIC)
    rtu_VeSTRR_b_BackupStrtEngOn, VAR(float32, AUTOMATIC)
    rtu_VeENGR_p_EngManfldAbsPrs, VAR(boolean, AUTOMATIC)
    rtu_VeRTMR_b_InPlantMode, VAR(boolean, AUTOMATIC) rtu_PosSlipDtcdLtch4STRR,
    VAR(boolean, AUTOMATIC) rtu_VeBCPR_b_PosSlipDetected, VAR(float32, AUTOMATIC)
    rtu_VeTISR_n_NiFromMtr, VAR(float32, AUTOMATIC) rtu_VeOHSR_n_IdleSpdBlended,
    VAR(boolean, AUTOMATIC) rtu_VeSTRR_b_BumpStrtEngOn, VAR(float32, AUTOMATIC)
    rtu_VeHSER_n_NiMax, VAR(float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMax, VAR
    (float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMin, VAR(boolean, AUTOMATIC)
    rtu_VeSTRR_b_BumpStrtInhbt, VAR(boolean, AUTOMATIC) rtu_ErlyExitLmp, VAR
    (boolean, AUTOMATIC) rtu_LwrThresLmp, VAR(float32, AUTOMATIC) rtu_HTDR_TiMin,
    VAR(float32, AUTOMATIC) rtu_EngTrqAirflow, VAR(boolean, AUTOMATIC)
    rtu_PNLimActv, VAR(float32, AUTOMATIC) rtu_PNLimTrq, VAR(float32, AUTOMATIC)
    rtu_TactTiMin, VAR(boolean, AUTOMATIC) rtu_REEV_GasFlowActr, P2VAR
    (DW_SpinUpEng_SFS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR
    (ZCE_SpinUpEng_SFS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localZCE, P2VAR
    (uint32, AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_g_StrtStpFailRsn, P2VAR(uint32,
    AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_g_StrtStpFailRsn2, P2VAR(float32,
    AUTOMATIC, ESSR_VAR_INIT) rtd_VeESSR_t_StrtTypGasFlwActrD);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_CmbstnNoDelay(P2VAR(boolean,
    AUTOMATIC, ESSR_VAR_INIT) rty_OutputParameter);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_If_KeyCrank_P1C65(P2VAR
    (TeESSR_e_StrtStpFailDTC, AUTOMATIC, ESSR_VAR_INIT) rty_DTC);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_If_KeyCrank_NoFault(P2VAR
    (TeESSR_e_StrtStpFailDTC, AUTOMATIC, ESSR_VAR_INIT) rty_NoDTC);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpinUp_CKS_Dur_Init(P2VAR
    (DW_SpinUp_CKS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpinUp_CKS_Dur(VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_TransInSpdFlt, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_AddtlDragTorq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeESMR_P_BatSTMaxLim, VAR(float32, AUTOMATIC)
    rtu_VeESMR_P_BatEstdVoltMaxLim, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngStrtTrqSnsd, VAR(float32, AUTOMATIC)
    rtu_VeENGR_T_EngCoolantTemp, VAR(float32, AUTOMATIC) rtu_VeENGR_t_EngOffTime,
    VAR(float32, AUTOMATIC) rtu_VeHSER_n_NiMax, VAR(float32, AUTOMATIC)
    rtu_VeHSER_dn_NiDotMax, VAR(float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMin, VAR
    (float32, AUTOMATIC) rtu_VeABCR_P_HV_AccPwr, P2VAR
    (DW_SpinUp_CKS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR
    (ZCE_SpinUp_CKS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localZCE, P2VAR
    (uint32, AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_g_StrtStpFailRsn);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_PBatBoostReset(void);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_CombstDelay(P2VAR(boolean,
    AUTOMATIC, ESSR_VAR_INIT) rty_OutputParameter);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_If_StartEng_P1C64(P2VAR
    (TeESSR_e_StrtStpFailDTC, AUTOMATIC, ESSR_VAR_INIT) rty_DTC);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Subsystem(VAR(float32, AUTOMATIC)
    rtu_TiMin, VAR(float32, AUTOMATIC) rtu_y, VAR(float32, AUTOMATIC) rtu_TqAct,
    P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Out1);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Subsystem1_Reset(P2VAR
    (DW_Subsystem1_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Subsystem1(VAR(float32, AUTOMATIC)
    rtu_TiMin, VAR(float32, AUTOMATIC) rtu_y, VAR(float32, AUTOMATIC) rtu_TqAct,
    VAR(boolean, AUTOMATIC) rtu_CmbCmd, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT)
    rty_Out1, P2VAR(DW_Subsystem1_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_StartEngDur_Init(P2VAR
    (DW_ESSC_StartEngDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_StartEngDur(VAR(float32,
    AUTOMATIC) rtu_VeESSR_n_OptInputSpd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngStrtTorqSnsd, VAR(float32, AUTOMATIC)
    rtu_VeCSVR_n_PrimNoSgndFltrd, VAR(boolean, AUTOMATIC)
    rtu_VeENGR_b_EngCombustionCmnd, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngTrqActual, VAR(boolean, AUTOMATIC) rtu_VeRTMR_b_InPlantMode,
    VAR(float32, AUTOMATIC) rtu_VeESSR_M_OptEngTrqReqPred, VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_OptEngTrqReqImmed, VAR(float32, AUTOMATIC)
    rtu_VeETQR_r_MaxSparkAuthority, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngineLosses, VAR(boolean, AUTOMATIC)
    rtu_VeSTRR_b_BackupStrtEngOn, VAR(TeENGR_e_ETRQ_Mode, AUTOMATIC)
    rtu_VeENGR_e_ETRQ_Mode, VAR(float32, AUTOMATIC) rtu_VeESSR_n_TransInSpdFlt,
    VAR(float32, AUTOMATIC) rtu_VeOHSR_n_IdleSpdBlended, VAR(float32, AUTOMATIC)
    rtu_EngCltTmp, VAR(float32, AUTOMATIC) rtu_VeHSER_n_NiMax, VAR(float32,
    AUTOMATIC) rtu_VeHSER_dn_NiDotMax, VAR(float32, AUTOMATIC)
    rtu_VeHSER_dn_NiDotMin, VAR(boolean, AUTOMATIC) rtu_VeSTRR_b_BumpStrtEngOn,
    VAR(boolean, AUTOMATIC) rtu_ErlyExitLmp, VAR(boolean, AUTOMATIC)
    rtu_LwrThresLmp, VAR(float32, AUTOMATIC) rtu_HTDR_TiMin, VAR(boolean,
    AUTOMATIC) rtu_PosSlipDtcdLtch4STRR, VAR(boolean, AUTOMATIC)
    rtu_VeBCPR_b_PosSlipDetected, VAR(float32, AUTOMATIC) rtu_VeTISR_n_NiFromMtr,
    VAR(float32, AUTOMATIC) rtu_VeETQR_M_EngCapacityMinRunI, VAR(boolean,
    AUTOMATIC) rtu_PNLimActv, VAR(float32, AUTOMATIC) rtu_PNLimTrq, VAR(float32,
    AUTOMATIC) rtu_TactTiMin, VAR(float32, AUTOMATIC) rtu_ImmedCal, VAR(float32,
    AUTOMATIC) rtu_AirflowTq, P2VAR(DW_ESSC_StartEngDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(ZCE_ESSC_StartEngDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localZCE, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_AchEngIdleEnt(void);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_AchEngIdleDur_Init(P2VAR
    (DW_ESSC_AchEngIdleDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_AchEngIdleDur(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_OptEngTrqReq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_OptInputSpd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeENGR_T_EngCoolantTemp, VAR(float32, AUTOMATIC) rtu_VeHSER_n_NiMax, VAR
    (float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMax, VAR(float32, AUTOMATIC)
    rtu_VeHSER_dn_NiDotMin, P2VAR(DW_ESSC_AchEngIdleDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(ZCE_ESSC_AchEngIdleDur_ESSR_a_T, AUTOMATIC,
    ESSR_VAR_INIT) localZCE);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpnUp_12v_Du(VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_TransInSpdFlt, VAR(boolean, AUTOMATIC) rtu_PSAActv, VAR(float32,
    AUTOMATIC) rtu_HTDR_TiMin, VAR(float32, AUTOMATIC) rtu_EngTrqAct, P2VAR
    (DW_SpnUp_12v_Du_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR(uint32,
    AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_g_StrtStpFailRsn);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_AchIdle_12vStrt_En(VAR(boolean,
    AUTOMATIC) rtu_VeSTRR_b_FirstStartActv, VAR(TeHPMR_e_PropSysMode, AUTOMATIC)
    rtu_VeHPMR_e_PropSysMode);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_AchIdle_12vStrt_Du_Init(P2VAR
    (DW_AchIdle_12vStrt_Du_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_AchIdle_12vStrt_Du(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_OptEngTrqReq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_OptInputSpd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeENGR_T_EngCoolantTemp, VAR(TeESSR_e_IdleCtrlrSelect, AUTOMATIC)
    rtu_VeESSR_e_IdleCtrlrSelect, VAR(float32, AUTOMATIC) rtu_VeHSER_n_NiMax,
    VAR(float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMax, VAR(float32, AUTOMATIC)
    rtu_VeHSER_dn_NiDotMin, P2VAR(DW_AchIdle_12vStrt_Du_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(ZCE_AchIdle_12vStrt_Du_ESSR_a_T, AUTOMATIC,
    ESSR_VAR_INIT) localZCE);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_StartEngPFS_Dur_Init(P2VAR
    (DW_StartEngPFS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_StartEngPFS_Dur(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_OptEngTrqReq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_OptInputSpd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngStrtTorqSnsd, VAR(boolean, AUTOMATIC)
    rtu_VeENGR_b_EngCombustionCmnd, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngTrqActual, VAR(boolean, AUTOMATIC) rtu_VeRTMR_b_InPlantMode,
    VAR(float32, AUTOMATIC) rtu_BatModTmp, VAR(boolean, AUTOMATIC)
    rtu_VeSTRR_b_BackupStrtEngOn, VAR(TeENGR_e_ETRQ_Mode, AUTOMATIC)
    rtu_VeENGR_e_ETRQ_Mode, VAR(float32, AUTOMATIC) rtu_VeESSR_n_TransInSpdFlt,
    VAR(float32, AUTOMATIC) rtu_VeOHSR_n_IdleSpdBlended, VAR(float32, AUTOMATIC)
    rtu_VeHSER_n_NiMax, VAR(float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMax, VAR
    (float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMin, VAR(float32, AUTOMATIC)
    rtu_HTDR_TiMin, VAR(boolean, AUTOMATIC) rtu_PNLimActv, VAR(float32,
    AUTOMATIC) rtu_PNLimTrq, VAR(float32, AUTOMATIC) rtu_TactTiMin, P2VAR
    (DW_StartEngPFS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR
    (ZCE_StartEngPFS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localZCE, P2VAR
    (uint32, AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_g_StrtStpFailRsn);

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpnUpFreEng_Bmp_Du(VAR(float32,
    AUTOMATIC) rtu_VeESSR_n_TransInSpdFlt, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeEPCR_M_EngPulseTorqEst, VAR(float32, AUTOMATIC)
    rtu_VeENGR_T_EngCoolantTemp, VAR(float32, AUTOMATIC)
    rtu_VeOHSR_n_InputSpeedDsrdM2, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_OptInputSpd, VAR(float32, AUTOMATIC)
    rtu_VeESMR_P_BatEstdVoltMaxLim, VAR(float32, AUTOMATIC)
    rtu_VeTISR_n_TransMinInputSpd, VAR(TeHSER_e_RngEqnSel, AUTOMATIC)
    rtu_VeHSER_e_RngEqnSel, VAR(float32, AUTOMATIC) rtu_VeESSR_dn_DtrmnNidot,
    VAR(uint16, AUTOMATIC) rtu_VeTINR_d_TCMFailures, VAR(boolean, AUTOMATIC)
    rtu_PSA_Actv, VAR(boolean, AUTOMATIC) rtu_EngCombustionCmnd, VAR(float32,
    AUTOMATIC) rtu_VeHTDR_M_MtrB_TorqCmnd, VAR(float32, AUTOMATIC)
    rtu_VeATRR_M_OutputTorqReqImmed, P2VAR(DW_SpnUpFreEng_Bmp_Du_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn);

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_AchIdle_BmpStrt_Du(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_OptEngTrqReq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeENGR_T_EngCoolantTemp, VAR(float32, AUTOMATIC)
    rtu_VeMTQR_M_MtrA_MaxTorq, VAR(float32, AUTOMATIC) rtu_VeMTQR_M_MtrA_MinTorq,
    VAR(float32, AUTOMATIC) rtu_VeOHSR_n_InputSpeedDsrdM2, VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_OptEngTrqReqPred, VAR(float32, AUTOMATIC)
    rtu_VeESMR_P_BatEstdVoltMaxLim, VAR(float32, AUTOMATIC)
    rtu_VeTISR_n_TransMinInputSpd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_TransInSpdFlt, VAR(float32, AUTOMATIC) rtu_VeMSPR_n_MtrB_Spd,
    VAR(float32, AUTOMATIC) rtu_VeETQR_M_EngCapacityMinOff, VAR
    (TeTRGR_e_TransRangeState, AUTOMATIC) rtu_VeTRGR_e_VldtdTransRngSt, VAR
    (float32, AUTOMATIC) rtu_VeATRR_M_OutputTorqReqImmed, VAR(float32, AUTOMATIC)
    rtu_VeOITR_M_InputTorqMaxTact, P2VAR(B_AchIdle_BmpStrt_Du_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localB, P2VAR(DW_AchIdle_BmpStrt_Du_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localDW);

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpinUp_CS_Dur(VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_AddtlDragTorq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_TransInSpdFlt, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngCapacityMinRunI, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngTrqActual, VAR(float32, AUTOMATIC)
    rtu_VeETQR_r_MaxSparkAuthority, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngineLosses, VAR(float32, AUTOMATIC)
    rtu_VeENGR_p_EngManfldAbsPrs, VAR(boolean, AUTOMATIC) rtu_ClthLwrThresLmp,
    VAR(boolean, AUTOMATIC) rtu_ClthErlyExitLmp, P2VAR
    (DW_SpinUp_CS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR(uint32,
    AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_g_StrtStpFailRsn);

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_CombstDelay_l(VAR(float32,
    AUTOMATIC) rtu_Ni, P2VAR(boolean, AUTOMATIC, ESSR_VAR_INIT)
    rty_OutputParameter);

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_StartEngCS_Dur(VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(boolean, AUTOMATIC)
    rtu_VeENGR_b_EngCombustionCmnd, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngTrqActual, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_OptEngTrqReqPred, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_OptEngTrqReqImmed, VAR(float32, AUTOMATIC)
    rtu_VeETQR_r_MaxSparkAuthority, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngineLosses, VAR(TeENGR_e_ETRQ_Mode, AUTOMATIC)
    rtu_VeENGR_e_ETRQ_Mode, VAR(float32, AUTOMATIC) rtu_VeESSR_n_TransInSpdFlt,
    VAR(float32, AUTOMATIC) rtu_EngCltTmp, VAR(float32, AUTOMATIC)
    rtu_HSER_Cltch1Trq, VAR(float32, AUTOMATIC) rtu_HSER_Cltch3Trq, VAR(boolean,
    AUTOMATIC) rtu_VeRTMR_b_InPlantMode, VAR(boolean, AUTOMATIC)
    rtu_ClthSpinupErlyExitLmp, P2VAR(DW_StartEngCS_Dur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn);

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_SpinUp_EM_Dur_Init(P2VAR
    (DW_ESSC_SpinUp_EM_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW);

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_SpinUp_EM_Dur(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_AddtlDragTorq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_TransInSpdFlt, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngCapacityMinRunI, VAR(float32, AUTOMATIC) rtu_BatVoltModMin,
    VAR(float32, AUTOMATIC) rtu_VeETQR_M_EngTrqActual, VAR(float32, AUTOMATIC)
    rtu_VeETQR_r_MaxSparkAuthority, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngineLosses, VAR(float32, AUTOMATIC)
    rtu_VeENGR_p_EngManfldAbsPrs, VAR(boolean, AUTOMATIC)
    rtu_VeRTMR_b_InPlantMode, VAR(float32, AUTOMATIC) rtu_VeHSER_n_NiMax, VAR
    (float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMax, VAR(float32, AUTOMATIC)
    rtu_VeHSER_dn_NiDotMin, VAR(boolean, AUTOMATIC) rtu_EMErlyExitLmp, VAR
    (float32, AUTOMATIC) rtu_TiEStMin, P2VAR(DW_ESSC_SpinUp_EM_Dur_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR(ZCE_ESSC_SpinUp_EM_Dur_ESSR_a_T,
    AUTOMATIC, ESSR_VAR_INIT) localZCE, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn);

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_StartEng_EM_Dur_Init(P2VAR
    (DW_StartEng_EM_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW);

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_StartEng_EM_Dur(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_EngStrtTorqSnsd, VAR(boolean, AUTOMATIC)
    rtu_VeENGR_b_EngCombustionCmnd, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngTrqActual, VAR(boolean, AUTOMATIC) rtu_VeRTMR_b_InPlantMode,
    VAR(float32, AUTOMATIC) rtu_VeESSR_M_OptEngTrqReqPred, VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_OptEngTrqReqImmed, VAR(float32, AUTOMATIC)
    rtu_VeETQR_r_MaxSparkAuthority, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngineLosses, VAR(TeENGR_e_ETRQ_Mode, AUTOMATIC)
    rtu_VeENGR_e_ETRQ_Mode, VAR(float32, AUTOMATIC) rtu_VeESSR_n_TransInSpdFlt,
    VAR(float32, AUTOMATIC) rtu_VeOHSR_n_IdleSpdBlended, VAR(float32, AUTOMATIC)
    rtu_VeHSER_n_NiMax, VAR(float32, AUTOMATIC) rtu_VeMSPR_n_MtrB_Spd, VAR
    (float32, AUTOMATIC) rtu_VeETQR_M_EngCapacityMinOff, VAR(float32, AUTOMATIC)
    rtu_VeOITR_M_InputTorqMaxTact, VAR(float32, AUTOMATIC)
    rtu_VeHTDR_M_MtrB_TorqCmnd, VAR(float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMax,
    VAR(float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMin, VAR(boolean, AUTOMATIC)
    rtu_EMErlyExitLmp, VAR(TeHSER_e_RngSt, AUTOMATIC) rtu_VeHSER_e_RngSt, VAR
    (float32, AUTOMATIC) rtu_TiEstMin, P2VAR(DW_StartEng_EM_Dur_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR(ZCE_StartEng_EM_Dur_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localZCE, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn);

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_StartEngP1fLmt_Dur(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_EngStrtTorqSnsd, VAR(boolean, AUTOMATIC)
    rtu_VeENGR_b_EngCombustionCmnd, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngTrqActual, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_OptEngTrqReqPred, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_OptEngTrqReqImmed, VAR(float32, AUTOMATIC)
    rtu_VeETQR_r_MaxSparkAuthority, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngineLosses, VAR(TeENGR_e_ETRQ_Mode, AUTOMATIC)
    rtu_VeENGR_e_ETRQ_Mode, VAR(float32, AUTOMATIC) rtu_VeESSR_n_TransInSpdFlt,
    VAR(boolean, AUTOMATIC) rtu_VeRTMR_b_InPlantMode, VAR(boolean, AUTOMATIC)
    rtu_ErlyExitLmp, VAR(boolean, AUTOMATIC) rtu_LwrThresLmp, VAR(float32,
    AUTOMATIC) rtu_HTDR_TiMin, P2VAR(DW_StartEngP1fLmt_Dur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn);

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpinUp_EMLowPwr_Du(VAR(float32,
    AUTOMATIC) rtu_VeESSR_n_TransInSpdFlt, VAR(float32, AUTOMATIC)
    rtu_VeHTDR_M_MtrB_TorqCmnd, VAR(float32, AUTOMATIC)
    rtu_VeOHSR_n_IdleSpdBlended, VAR(boolean, AUTOMATIC)
    rtu_VeENGR_b_EngCombustionCmnd, VAR(float32, AUTOMATIC) rtu_TiEstMin, VAR
    (float32, AUTOMATIC) rtu_EngTrqAct, P2VAR(DW_SpinUp_EMLowPwr_Du_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_UsingAdapt(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Out1, P2VAR(float32,
    AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_k_EngStpProfAngAdpt);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_PassThrough(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Out1);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Subtract720(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Out1);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_PrepForStopDur_Init(P2VAR
    (DW_PrepForStopDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_PrepForStopDur(VAR(float32, AUTOMATIC)
    rtu_TransInSpdFlt, VAR(float32, AUTOMATIC) rtu_NiDotMax, VAR(float32,
    AUTOMATIC) rtu_NiDotMin, VAR(float32, AUTOMATIC) rtu_EngTrqActual, VAR
    (float32, AUTOMATIC) rtu_EngCapacityMinRun, VAR(boolean, AUTOMATIC)
    rtu_EngOnReq, VAR(float32, AUTOMATIC) rtu_EngAng720Est, VAR
    (TeENGR_e_CylinderDeacModes, AUTOMATIC) rtu_CylinderDeacMode, VAR(boolean,
    AUTOMATIC) rtu_AuxPumpRunning, VAR(float32, AUTOMATIC) rtu_OAT, VAR(float32,
    AUTOMATIC) rtu_TFT, VAR(float32, AUTOMATIC) rtu_EngCapacityMinRunImmed, VAR
    (float32, AUTOMATIC) rtu_OptInputTorq, VAR(float32, AUTOMATIC)
    rtu_VeHSER_n_NiMax, VAR(boolean, AUTOMATIC) rtu_EngAngle720SyncFA, VAR
    (boolean, AUTOMATIC) rtu_EngAngle720SyncLrn, VAR(boolean, AUTOMATIC)
    rtu_AStopEngCOMLmp, VAR(float32, AUTOMATIC) rtu_EngCapacityMinOff, VAR
    (TeENGR_e_EngDFSO_St, AUTOMATIC) rtu_DFCOSt, VAR(TeINVR_e_MtrInvrtrSt,
    AUTOMATIC) rtu_VeINVR_e_MtrA_InvrtrSt, P2VAR(DW_PrepForStopDur_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR(ZCE_PrepForStopDur_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localZCE, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_k_EngStpProfAngAdpt);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_DisableFuelEnt(void);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_If_DisableFuel_NoFault(void);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Restart1(void);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_DisableFuelDur(VAR(float32, AUTOMATIC)
    rtu_EngTrqActual, VAR(boolean, AUTOMATIC) rtu_EngOnReq, VAR(float32,
    AUTOMATIC) rtu_EngAng720Est, VAR(TeENGR_e_Cam_Phsr_Stat, AUTOMATIC)
    rtu_CamPhaserStat, VAR(TeENGR_e_EngDFSO_St, AUTOMATIC) rtu_EngDFSO_Req, VAR
    (boolean, AUTOMATIC) rtu_EngTLCLearnReq, VAR(float32, AUTOMATIC)
    rtu_EngCapacityMinRunImmed, VAR(boolean, AUTOMATIC) rtu_EngCmbstCmnd, VAR
    (float32, AUTOMATIC) rtu_TransInSpdFlt, VAR(float32, AUTOMATIC)
    rtu_EngCapacityMinOff, VAR(float32, AUTOMATIC) rtu_EngAngle720Sync, VAR
    (boolean, AUTOMATIC) rtu_EngAngle720SyncFA, VAR(boolean, AUTOMATIC)
    rtu_EngAngle720SyncLrn, VAR(boolean, AUTOMATIC) rtu_AStopEngCOMLmp, P2VAR
    (DW_DisableFuelDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR
    (uint32, AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_g_StrtStpFailRsn, P2VAR
    (float32, AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_k_EngStpProfAngAdpt);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Sub720(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Out1);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Add720(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Out1);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_RampDownEnt(VAR(float32,
    AUTOMATIC) rtu_EngAngle720Est, VAR(float32, AUTOMATIC) rtu_EngCapacityMinOff,
    P2VAR(B_ESSC_RampDownEnt_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localB, P2VAR
    (float32, AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_k_EngStpProfAngAdpt, P2VAR
    (float32, AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_k_EngStpProfNiDotGai);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_AdaptUp(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Positive);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_AdaptDown(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Negative);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_CoastDown(void);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Restart(void);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_EngFail(void);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Use_ShapeNi(VAR(float32, AUTOMATIC)
    rtu_InputSpdProfile, VAR(float32, AUTOMATIC) rtu_InputSpdProfDn, P2VAR
    (float32, AUTOMATIC, ESSR_VAR_INIT) rty_InpSpdProf, P2VAR(float32, AUTOMATIC,
    ESSR_VAR_INIT) rty_InpSpdDn);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_RampDownDur_Init(P2VAR
    (DW_ESSC_RampDownDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_RampDownDur(VAR(float32,
    AUTOMATIC) rtu_InitEngSpd, VAR(float32, AUTOMATIC) rtu_TransInSpdFlt, VAR
    (float32, AUTOMATIC) rtu_EngTrqActual, VAR(float32, AUTOMATIC)
    rtu_SpinDownDragCorr, VAR(float32, AUTOMATIC) rtu_EngAngle720Est, VAR
    (boolean, AUTOMATIC) rtu_EngOnReq, VAR(float32, AUTOMATIC) rtu_EntrySpd, VAR
    (float32, AUTOMATIC) rtu_NiDotMax, VAR(float32, AUTOMATIC) rtu_NiDotMin, VAR
    (float32, AUTOMATIC) rtu_VeHSER_n_NiMax, VAR(boolean, AUTOMATIC)
    rtu_InCltchStrtZn, VAR(boolean, AUTOMATIC) rtu_CltchStrtRsrvAvail, VAR
    (boolean, AUTOMATIC) rtu_AStopEngCOMLmp, VAR(boolean, AUTOMATIC)
    rtu_AStopReStrtPrepLmp, P2VAR(B_ESSC_RampDownDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localB, P2VAR(DW_ESSC_RampDownDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(ZCE_ESSC_RampDownDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localZCE, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_k_EngStpProfAngAdpt, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_k_EngStpProfNiDotGai);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_FinishStopDur(VAR(float32,
    AUTOMATIC) rtu_Ni, VAR(boolean, AUTOMATIC) rtu_EngOnReq, VAR(float32,
    AUTOMATIC) rtu_EngAngle720Est, VAR(float32, AUTOMATIC) rtu_EngTrqActual, VAR
    (float32, AUTOMATIC) rtu_SpinDownDragCorr, VAR(boolean, AUTOMATIC)
    rtu_CltchStrtRsrvAvail, VAR(boolean, AUTOMATIC) rtu_InCltchStrtZn, VAR
    (boolean, AUTOMATIC) rtu_AStopEngCOMLmp, VAR(boolean, AUTOMATIC)
    rtu_AStopReStrtPrepLmp, P2VAR(DW_ESSC_FinishStopDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_ResetVars(void);

#endif

/* Forward declaration for local functions */
#if Rte_SysCon_Variant_ESSR_Func

static void ESS_enter_internal_EngStartCtrl(const boolean *Dsr_EngRestartReq,
    const boolean *Dsr_PFSRunReq, const boolean *BmpStrtFailed, const boolean
    *Dsr_PFSRunReq1, const TeESSR_e_StrtType *Dsr_EngStrtType);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static void ESSR_enter_internal_EngStopCtrl(const boolean *Dsr_DsblFuelReq,
    const boolean *Dsr_RmpDwnReq);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static void ESSR_exit_internal_EngStartCtrl(void);

#endif

#if Rte_SysCon_Variant_ESSR_Func

static void ESSR_ac_EngStartCtrl(const boolean *Dsr_DsblFuelReq, const boolean
    *Dsr_RmpDwnReq, const TeESSR_e_STMTrigger *Dsr_STMTrigger, const
    TeESSR_e_StrtType *Dsr_EngStrtType);

#endif

/*
 * Output and update for action system:
 *    '<S3011>/AStrtSmooth_iCalLoader_Four'
 *    '<S3011>/CompressTst_iCalLoader_Four'
 *    '<S3011>/Default_iCalLoader_Four'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESS_AStrtSmooth_iCalLoader_Four(P2VAR(uint8,
    AUTOMATIC, ESSR_VAR_INIT) rty_i_CalLoader, P2VAR(boolean, AUTOMATIC,
    ESSR_VAR_INIT) rty_b_KeyType, P2VAR(boolean, AUTOMATIC, ESSR_VAR_INIT)
    rty_Interp)
{
    /* SignalConversion generated from: '<S3086>/i_CalLoader' incorporates:
     *  Constant: '<S3086>/Constant Value'
     */
    *rty_i_CalLoader = 4U;

    /* SignalConversion generated from: '<S3086>/b_KeyType' incorporates:
     *  Constant: '<S3086>/FALSE Constant'
     */
    *rty_b_KeyType = false;

    /* SignalConversion generated from: '<S3086>/Interp' incorporates:
     *  Constant: '<S3086>/Constant Value1'
     */
    *rty_Interp = false;
}

#endif

/*
 * Output and update for action system:
 *    '<S3245>/TkFrstPtMin'
 *    '<S3245>/TkFirstPtMax'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_TkFrstPtMin(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Out1)
{
    /* Gain: '<S3253>/Gain' */
    *rty_Out1 = rtu_In1;
}

#endif

/* Output and update for function-call system: '<S173>/ESSC_EngOffEnt' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_EngOffEnt(VAR
    (TeSTRR_e_HybStrtrSt, AUTOMATIC) rtu_HybStrtrSt)
{
    /* Switch: '<S243>/Switch' incorporates:
     *  Constant: '<S294>/Constant'
     *  Constant: '<S302>/Calib'
     *  Constant: '<S303>/Calib'
     *  DataStoreWrite: '<S243>/Dsw_TransFldPmpSel'
     *  RelationalOperator: '<S243>/Comparison2'
     */
    if (((uint32)rtu_HybStrtrSt) == CeSTRR_e_KeyOffSt)
    {
        VeESSR_e_TransFldPmpSel_DS = KeESSR_e_TransFldPmpSelKeyOff;
    }
    else
    {
        VeESSR_e_TransFldPmpSel_DS = KeESSR_e_TransFldPmpSelEngOff;
    }

    /* End of Switch: '<S243>/Switch' */

    /* DataStoreWrite: '<S243>/Dsw_DsblNiClsdLoopCntrl3' incorporates:
     *  Constant: '<S243>/Constant Value'
     */
    VeESSR_M_MtrB_MaxTorq_DS = 9999.0F;

    /* DataStoreWrite: '<S243>/Dsw_DsblNiClsdLoopCntrl4' */
    VeESSR_M_MtrB_MinTorq_DS = -9999.0F;

    /* DataStoreWrite: '<S243>/Dsw_DsblNiClsdLoopCntrl6' incorporates:
     *  Constant: '<S243>/Constant Value'
     */
    VeESSR_M_MtrC_MaxTorq_DS = 9999.0F;

    /* DataStoreWrite: '<S243>/Dsw_DsblNiClsdLoopCntrl7' */
    VeESSR_M_MtrC_MinTorq_DS = -9999.0F;

    /* DataStoreWrite: '<S243>/Dsw_MainSTMTmr' incorporates:
     *  Constant: '<S243>/Constant Value1'
     */
    VeESSR_t_MainSTMTmr_DS = 0.0F;

    /* DataStoreWrite: '<S243>/Dsw_EngTrqRespType' incorporates:
     *  Constant: '<S288>/Constant'
     */
    VeESSR_e_EngTrqRespType_DS = CePTAR_e_Inactive;

    /* DataStoreWrite: '<S243>/Dsw_EngTrqReqImmed' incorporates:
     *  Constant: '<S243>/Constant Value3'
     */
    VeESSR_M_EngTrqReqImmed_DS = 0.0F;

    /* Switch: '<S243>/Switch1' incorporates:
     *  Constant: '<S243>/Constant Value4'
     *  Constant: '<S297>/Calib'
     *  DataStoreWrite: '<S243>/Data Store Write2'
     */
    if (!HeESSR_b_EngStrtTorq)
    {
        VeESSR_M_EngStrtTorq_DS = 0.0F;
    }

    /* End of Switch: '<S243>/Switch1' */

    /* DataStoreWrite: '<S243>/Dsw_InputAcceltnProf' incorporates:
     *  Constant: '<S243>/Constant Value5'
     */
    VeESSR_dn_InputAcceltnProf_DS = 0.0F;

    /* DataStoreWrite: '<S243>/Dsw_InputSpeedProfile' incorporates:
     *  Constant: '<S243>/Constant Value5'
     */
    VeESSR_n_InputSpeedProfile_DS = 0.0F;

    /* DataStoreWrite: '<S243>/Dsw_InputTorqEst' incorporates:
     *  Constant: '<S243>/Constant Value5'
     */
    VeESSR_M_EngTorqEst_DS = 0.0F;

    /* DataStoreWrite: '<S243>/Data Store Write' incorporates:
     *  Constant: '<S296>/Constant'
     */
    VeESSR_e_EngStrtActuatorTyp = CeESSR_e_NoActTyp;

    /* Switch: '<S243>/Switch2' incorporates:
     *  Constant: '<S291>/Constant'
     *  Constant: '<S295>/Constant'
     *  DataStoreRead: '<S243>/Dsr_StrtStopFail'
     *  DataStoreWrite: '<S243>/Dsw_EngStrtStpMd2'
     */
    if (VeESSR_b_StrtStopFail_DS)
    {
        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_StartFailed;
    }
    else
    {
        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_Stop;
    }

    /* End of Switch: '<S243>/Switch2' */

    /* DataStoreWrite: '<S243>/Dsw_AStrtFailed3' incorporates:
     *  Constant: '<S243>/FALSE Constant2'
     */
    VeESSR_b_BackUpStartEng_DS = false;

    /* DataStoreWrite: '<S243>/Dsw_AStrtPBatBoostReq' incorporates:
     *  Constant: '<S243>/FALSE Constant'
     */
    VeESSR_b_AStrtPBatBoostReq_DS = false;

    /* DataStoreWrite: '<S243>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
     *  Constant: '<S299>/Calib'
     */
    VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

    /* DataStoreWrite: '<S243>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
     *  Constant: '<S300>/Calib'
     */
    VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

    /* DataStoreWrite: '<S243>/Dsw_EngStartStopSt' incorporates:
     *  Constant: '<S289>/Constant'
     */
    VeESSR_e_EngStartStopSt_DS = CeESSR_e_EngOff;

    /* DataStoreWrite: '<S243>/Dsw_EngStrtType' incorporates:
     *  Constant: '<S290>/Constant'
     */
    VeESSR_e_EngStrtType_DS = CeESSR_e_NoStrt;

    /* DataStoreWrite: '<S243>/Dsw_EngStrtType1' incorporates:
     *  Constant: '<S292>/Constant'
     */
    VeESSR_e_TCM_StartStopType_DS = CeESSR_e_NoAction;

    /* DataStoreWrite: '<S243>/Dsw_EngStrtType2' incorporates:
     *  Constant: '<S293>/Constant'
     */
    VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Trans_Stat_Off;

    /* DataStoreWrite: '<S243>/Dsw_EngTrqReqPrdtd' incorporates:
     *  Constant: '<S298>/Calib'
     */
    VeESSR_M_EngTrqReqPrdtd_DS = KeESSR_M_ECMCmdDurOff;

    /* DataStoreWrite: '<S243>/Dsw_InhibitShiftToMode' incorporates:
     *  Constant: '<S301>/Calib'
     */
    VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtEngOff;

    /* DataStoreWrite: '<S243>/Dsw_InhibitShiftToMode1' incorporates:
     *  Constant: '<S243>/FALSE Constant3'
     */
    VeESSR_b_DsblNc1ClsdLoopCntrl_DS = false;

    /* DataStoreWrite: '<S243>/Dsw_InputSpeedProfile1' incorporates:
     *  Constant: '<S243>/FALSE Constant4'
     */
    VeESSR_b_NiDotMaxActive_DS = false;

    /* DataStoreWrite: '<S243>/Dsw_InputSpeedProfile4' incorporates:
     *  Constant: '<S243>/FALSE Constant5'
     */
    VeESSR_b_NiDotMinActive_DS = false;

    /* DataStoreWrite: '<S243>/Dsw_InputSpeedProfile5' incorporates:
     *  Constant: '<S243>/FALSE Constant6'
     */
    VeESSR_b_NiMaxActive_DS = false;

    /* DataStoreWrite: '<S243>/Dsw_InputTorqOverride' incorporates:
     *  Constant: '<S243>/TRUE Constant'
     */
    VeESSR_b_InputTorqOverride_DS = true;

    /* DataStoreWrite: '<S243>/Dsw_SpdCtlGainMod1' incorporates:
     *  Constant: '<S304>/Calib'
     */
    VeESSR_scl_SpdCtlGainMod_DS = KeESSR_scl_SpdCtrlEngOffEnt;

    /* DataStoreWrite: '<S243>/TCMOpenDiscCltch' incorporates:
     *  Constant: '<S243>/FALSE Constant1'
     */
    VeESSR_b_TCMOpenDisconnctCltch_DS = false;
}

#endif

/* Output and update for function-call system: '<S174>/ESSC_EngRunEnt' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_EngRunEnt(void)
{
    boolean rtb_LogicalOperator2_m;

    /* Logic: '<S312>/Logical Operator2' incorporates:
     *  Constant: '<S312>/Constant Value9'
     *  Constant: '<S357>/Calib'
     *  Constant: '<S358>/Calib'
     *  Constant: '<S361>/Calib'
     *  Constant: '<S362>/Calib'
     *  Constant: '<S365>/Calib'
     *  DataStoreRead: '<S312>/Data Store Read1'
     *  DataStoreRead: '<S312>/Data Store Read18'
     *  DataStoreRead: '<S312>/Data Store Read4'
     *  DataStoreRead: '<S312>/Data Store Read5'
     *  Logic: '<S312>/Logical Operator1'
     *  Logic: '<S312>/Logical Operator9'
     *  RelationalOperator: '<S312>/Comparison'
     *  RelationalOperator: '<S312>/Greater  Than1'
     *  RelationalOperator: '<S312>/Greater  Than2'
     *  S-Function (sfix_bitop): '<S312>/Bitwise Logical Operator'
     */
    rtb_LogicalOperator2_m = ((KeESSR_g_BSGStrtFailRsnClr &
        VeESSR_g_BSGStrtFailRsn_DS) == 0U);
    rtb_LogicalOperator2_m = (((((KeESSR_b_EnblFtrBumpStrt) &&
        (VeESSR_Cnt_BumpStrtAttmptCntr_DS < KeESSR_Cnt_BumpStrtMaxAttmpts)) &&
        rtb_LogicalOperator2_m) && (VeESSR_b_BSGStrtFailed_DS)) ||
        ((((VeESSR_b_BSGStrtFailed_DS) && rtb_LogicalOperator2_m) &&
          (VeESSR_Cnt_BackupStrtAttmptCntr_DS < KeESSR_Cnt_BackupStrtMaxAttmpts))
         && (KeESSR_b_EnblFtrBackupStrt)));

    /* Switch: '<S312>/Switch1' incorporates:
     *  Constant: '<S312>/Constant Value11'
     *  Constant: '<S312>/FALSE Constant1'
     *  DataStoreWrite: '<S312>/Data Store Write'
     *  DataStoreWrite: '<S312>/Data Store Write4'
     *  Switch: '<S312>/Switch2'
     */
    if (rtb_LogicalOperator2_m)
    {
        VeESSR_b_BSGStrtFailed_DS = false;
        VeESSR_g_BSGStrtFailRsn_DS = 0U;
    }

    /* End of Switch: '<S312>/Switch1' */

    /* DataStoreWrite: '<S312>/Dsw_AStrtFailed3' incorporates:
     *  Constant: '<S312>/Constant Value'
     */
    VeESSR_Cnt_AStrtFailAttmptCntr_DS = 0U;

    /* DataStoreWrite: '<S312>/Dsw_TorqCancelDsrd1' incorporates:
     *  Constant: '<S312>/Constant Value1'
     */
    VeESSR_k_TorqCancelGain_DS = 0.0F;

    /* DataStoreWrite: '<S312>/Dsw_EngTrqReqPrdtd' incorporates:
     *  Constant: '<S312>/Constant Value2'
     */
    VeESSR_M_EngTrqReqPrdtd_DS = 0.0F;

    /* DataStoreWrite: '<S312>/Dsw_SpdCtlGainMod' incorporates:
     *  Constant: '<S312>/Constant Value3'
     */
    VeESSR_scl_SpdCtlGainMod_DS = 1.0F;

    /* DataStoreWrite: '<S312>/Dsw_MainSTMTmr' incorporates:
     *  Constant: '<S312>/Constant Value4'
     */
    VeESSR_t_MainSTMTmr_DS = 0.0F;

    /* DataStoreWrite: '<S312>/Dsw_EngTrqReqImmed' incorporates:
     *  Constant: '<S312>/Constant Value6'
     */
    VeESSR_M_EngTrqReqImmed_DS = 0.0F;

    /* Switch: '<S312>/Switch3' incorporates:
     *  Constant: '<S312>/Constant Value7'
     *  Constant: '<S356>/Calib'
     *  DataStoreWrite: '<S312>/Data Store Write2'
     */
    if (!HeESSR_b_EngStrtTorq)
    {
        VeESSR_M_EngStrtTorq_DS = 0.0F;
    }

    /* End of Switch: '<S312>/Switch3' */

    /* DataStoreWrite: '<S312>/Dsw_EngTrqRespType' incorporates:
     *  Constant: '<S347>/Constant'
     */
    VeESSR_e_EngTrqRespType_DS = CePTAR_e_Inactive;

    /* DataStoreWrite: '<S312>/Data Store Write1' incorporates:
     *  Constant: '<S353>/Constant'
     */
    VeESSR_e_EngStrtActuatorTyp = CeESSR_e_NoActTyp;

    /* DataStoreWrite: '<S312>/Data Store Write3' incorporates:
     *  Constant: '<S355>/Constant'
     */
    VeESSR_e_HybEngSysActv_DS = CeESSR_e_HybEngEnabledOn;

    /* DataStoreWrite: '<S312>/Data Store Write5' incorporates:
     *  Constant: '<S312>/FALSE Constant4'
     */
    VeESSR_b_TCMOpenDisconnctCltch_DS = false;

    /* DataStoreWrite: '<S312>/Dsw_AStrtFailed1' incorporates:
     *  Constant: '<S312>/FALSE Constant2'
     */
    VeESSR_b_BackUpStartEng_DS = false;

    /* DataStoreWrite: '<S312>/Dsw_AStrtFailed4' incorporates:
     *  Constant: '<S312>/TRUE Constant'
     */
    VeESSR_b_AStrtReattmptAllowed_DS = true;

    /* DataStoreWrite: '<S312>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
     *  Constant: '<S359>/Calib'
     */
    VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

    /* DataStoreWrite: '<S312>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
     *  Constant: '<S360>/Calib'
     */
    VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

    /* DataStoreWrite: '<S312>/Dsw_DsblNiClsdLoopCntrl3' incorporates:
     *  Constant: '<S312>/FALSE Constant3'
     */
    VeESSR_b_EngReStrtAttmpt_DS = false;

    /* DataStoreWrite: '<S312>/Dsw_EngStartStopSt' incorporates:
     *  Constant: '<S348>/Constant'
     */
    VeESSR_e_EngStartStopSt_DS = CeESSR_e_EngRunning;

    /* DataStoreWrite: '<S312>/Dsw_EngStrtStpMd2' incorporates:
     *  Constant: '<S352>/Constant'
     */
    VeESSR_e_EngStrtStpMd_DS = CeESSR_e_ProducingTorque;

    /* DataStoreWrite: '<S312>/Dsw_EngStrtType' incorporates:
     *  Constant: '<S349>/Constant'
     */
    VeESSR_e_EngStrtType_DS = CeESSR_e_NoStrt;

    /* DataStoreWrite: '<S312>/Dsw_EngStrtType1' incorporates:
     *  Constant: '<S351>/Constant'
     */
    VeESSR_e_TCM_StartStopType_DS = CeESSR_e_NoAction;

    /* DataStoreWrite: '<S312>/Dsw_EngStrtType2' incorporates:
     *  Constant: '<S354>/Constant'
     */
    VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_TransTrq;

    /* DataStoreWrite: '<S312>/Dsw_InhibitShiftToMode' incorporates:
     *  Constant: '<S363>/Calib'
     */
    VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtEngOn;

    /* DataStoreWrite: '<S312>/Dsw_InputSpeedProfile1' incorporates:
     *  Constant: '<S366>/Calib'
     */
    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

    /* DataStoreWrite: '<S312>/Dsw_InputSpeedProfile2' incorporates:
     *  Constant: '<S312>/FALSE Constant5'
     */
    VeESSR_b_NiDotMaxActive_DS = false;

    /* DataStoreWrite: '<S312>/Dsw_InputSpeedProfile4' incorporates:
     *  Constant: '<S312>/FALSE Constant6'
     */
    VeESSR_b_NiDotMinActive_DS = false;

    /* DataStoreWrite: '<S312>/Dsw_InputSpeedProfile5' incorporates:
     *  Constant: '<S312>/FALSE Constant7'
     */
    VeESSR_b_NiMaxActive_DS = false;

    /* DataStoreWrite: '<S312>/Dsw_InputTorqOverride' incorporates:
     *  Constant: '<S312>/FALSE Constant'
     */
    VeESSR_b_InputTorqOverride_DS = false;

    /* DataStoreWrite: '<S312>/Dsw_StrtStpFailDTC' incorporates:
     *  Constant: '<S350>/Constant'
     */
    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

    /* DataStoreWrite: '<S312>/Dsw_TransFldPmpSel' incorporates:
     *  Constant: '<S364>/Calib'
     */
    VeESSR_e_TransFldPmpSel_DS = KeESSR_e_TransFldPmpSelEngRunning;
}

#endif

/* Output and update for function-call system: '<S174>/ESSC_EngRunDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_EngRunDur(VAR(boolean, AUTOMATIC)
    rtu_EngOnReq, VAR(float32, AUTOMATIC) rtu_TransInSpdFlt, VAR(float32,
    AUTOMATIC) rtu_InputAccelProfile, VAR(float32, AUTOMATIC)
    rtu_InputSpeedProfile, VAR(TeSTRR_e_EngStrtStopType, AUTOMATIC)
    rtu_EngStrtStopType, VAR(float32, AUTOMATIC) rtu_EngTrqActual, VAR(boolean,
    AUTOMATIC) rtu_EngineStallDetected, VAR(TeHSER_e_RngEqnSel, AUTOMATIC)
    rtu_VeHSER_e_RngEqnSel, P2VAR(DW_ESSC_EngRunDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_VeESSR_M_BCTiMargin_DS)
{
    float32 rtb_Dsr_STMTmr_cl;
    uint8 rtb_Sum3_giv;
    boolean rtb_Logical_gb;
    boolean rtb_NOT2;

    /* RelationalOperator: '<S311>/Comparison1' incorporates:
     *  Constant: '<S325>/Calib'
     *  DataStoreRead: '<S311>/Dsr_STMTmr1'
     *  DataStoreWrite: '<S311>/Data Store Write'
     */
    VeESSR_b_MinRun2StpTm_DS = (VeESSR_t_STMTmr_DS >= KeESSR_t_MinRun2StpTm);

    /* Switch: '<S311>/Switch' incorporates:
     *  Constant: '<S322>/Calib'
     *  DataStoreWrite: '<S311>/Dsw_InputTorqEst1'
     *  RelationalOperator: '<S311>/Comparison'
     */
    if (rtu_TransInSpdFlt > KeESSR_n_EngStallRngEqn)
    {
        VeESSR_e_EngStallRngEqn_DS = rtu_VeHSER_e_RngEqnSel;
    }

    /* End of Switch: '<S311>/Switch' */

    /* DataStoreRead: '<S311>/Dsr_STMTmr' */
    rtb_Dsr_STMTmr_cl = VeESSR_t_STMTmr_DS;

    /* Sum: '<S311>/Summation' incorporates:
     *  Constant: '<S319>/Calib'
     *  DataStoreRead: '<S311>/Dsr_STMTmr'
     *  DataStoreWrite: '<S311>/Dsw_STMTmr'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* DataStoreWrite: '<S311>/Dsw_STMTmr1' incorporates:
     *  Constant: '<S319>/Calib'
     *  DataStoreRead: '<S311>/Dsr_STMTmr4'
     *  Sum: '<S311>/Summation2'
     */
    VeESSR_t_MainSTMTmr_DS = VeESSR_t_MainSTMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Logic: '<S311>/NOT2' */
    rtb_NOT2 = !rtu_EngOnReq;

    /* Logic: '<S311>/Logical' incorporates:
     *  Constant: '<S318>/Calib'
     */
    rtb_Logical_gb = (rtu_EngineStallDetected && (HeESSR_b_EnblEngStallEV));

    /* Outputs for Atomic SubSystem: '<S316>/Accumulator Reset Limited' */
    /* Switch: '<S337>/Switch1' incorporates:
     *  Constant: '<S311>/Constant Value1'
     *  RelationalOperator: '<S311>/Comparison4'
     */
    if (0.0F == rtb_Dsr_STMTmr_cl)
    {
        /* Switch: '<S337>/Switch1' incorporates:
         *  Constant: '<S316>/Constant Value1'
         */
        rtb_Dsr_STMTmr_cl = 0.0F;
    }
    else
    {
        /* Sum: '<S337>/Summation' incorporates:
         *  Constant: '<S339>/Calib'
         *  Constant: '<S341>/Calib'
         *  Product: '<S316>/Product'
         *  Sum: '<S316>/Sum1'
         *  UnitDelay: '<S337>/Unit Delay'
         */
        rtb_Dsr_STMTmr_cl = ((KeESSR_n_EngStallSpd - rtu_TransInSpdFlt) *
                             HeESSR_t_MedTEB_dT) + localDW->UnitDelay_DSTATE;

        /* Outputs for Atomic SubSystem: '<S337>/Limiter' */
        /* Switch: '<S342>/Switch1' incorporates:
         *  Constant: '<S340>/Calib'
         *  RelationalOperator: '<S342>/Relational Operator'
         */
        if (KeESSR_n_EngStallIntgrlVal < rtb_Dsr_STMTmr_cl)
        {
            /* Switch: '<S342>/Switch1' */
            rtb_Dsr_STMTmr_cl = KeESSR_n_EngStallIntgrlVal;
        }

        /* End of Switch: '<S342>/Switch1' */

        /* Switch: '<S342>/Switch' incorporates:
         *  Constant: '<S316>/Constant Value1'
         *  RelationalOperator: '<S342>/Relational Operator1'
         */
        if (rtb_Dsr_STMTmr_cl <= 0.0F)
        {
            /* Switch: '<S337>/Switch1' */
            rtb_Dsr_STMTmr_cl = 0.0F;
        }

        /* End of Switch: '<S342>/Switch' */
        /* End of Outputs for SubSystem: '<S337>/Limiter' */
    }

    /* End of Switch: '<S337>/Switch1' */

    /* Update for UnitDelay: '<S337>/Unit Delay' */
    localDW->UnitDelay_DSTATE = rtb_Dsr_STMTmr_cl;

    /* End of Outputs for SubSystem: '<S316>/Accumulator Reset Limited' */

    /* RelationalOperator: '<S316>/Comparison4' incorporates:
     *  Constant: '<S340>/Calib'
     */
    VeESSR_b_EngStallDet = (rtb_Dsr_STMTmr_cl == KeESSR_n_EngStallIntgrlVal);

    /* If: '<S311>/If' incorporates:
     *  Constant: '<S315>/Constant'
     *  DataStoreWrite: '<S311>/Data Store Write'
     *  RelationalOperator: '<S311>/Equal'
     */
    if ((((uint32)rtu_EngStrtStopType) == CeSTRR_e_StopImmed) && rtb_NOT2)
    {
        /* Outputs for IfAction SubSystem: '<S311>/ImmedStop' incorporates:
         *  ActionPort: '<S320>/Action Port'
         */
        /* DataStoreWrite: '<S311>/Dsw_STMTrigger' incorporates:
         *  Constant: '<S345>/Constant'
         *  Merge: '<S311>/Merge'
         *  SignalConversion generated from: '<S320>/ImmedStopReq'
         */
        VeESSR_e_STMTrigger_DS = CeESSR_e_ImmedStopReq;

        /* End of Outputs for SubSystem: '<S311>/ImmedStop' */
    }
    else if (rtb_NOT2 && (VeESSR_b_MinRun2StpTm_DS))
    {
        /* Outputs for IfAction SubSystem: '<S311>/StopReq' incorporates:
         *  ActionPort: '<S326>/Action Port'
         */
        /* DataStoreWrite: '<S311>/Dsw_STMTrigger' incorporates:
         *  Constant: '<S346>/Constant'
         *  Merge: '<S311>/Merge'
         *  SignalConversion generated from: '<S326>/StopReq'
         */
        VeESSR_e_STMTrigger_DS = CeESSR_e_StopReq;

        /* End of Outputs for SubSystem: '<S311>/StopReq' */
    }
    else if (rtb_Logical_gb)
    {
        /* Outputs for IfAction SubSystem: '<S311>/CoastDown' incorporates:
         *  ActionPort: '<S314>/Action Port'
         */
        /* DataStoreWrite: '<S314>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
         *  Constant: '<S314>/Constant Value1'
         */
        VeESSR_M_MtrA_MaxTorq_DS = 0.0F;

        /* DataStoreWrite: '<S314>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
         *  Constant: '<S314>/Constant Value1'
         */
        VeESSR_M_MtrA_MinTorq_DS = 0.0F;

        /* Sum: '<S314>/Sum3' incorporates:
         *  Constant: '<S314>/Constant Value2'
         *  DataStoreRead: '<S314>/Data Store Read'
         */
        rtb_Sum3_giv = (uint8)(((uint32)VeESSR_Cnt_EngStallReattmptCntr_DS) + 1U);

        /* DataStoreWrite: '<S314>/Data Store Write1' incorporates:
         *  Constant: '<S314>/Constant Value2'
         *  DataStoreRead: '<S314>/Data Store Read'
         *  Sum: '<S314>/Sum3'
         */
        VeESSR_Cnt_EngStallReattmptCntr_DS = (uint8)(((uint32)
            VeESSR_Cnt_EngStallReattmptCntr_DS) + 1U);

        /* Switch: '<S334>/Switch1' incorporates:
         *  Constant: '<S330>/Constant'
         *  Constant: '<S335>/Calib'
         *  Constant: '<S336>/Calib'
         *  DataStoreWrite: '<S314>/Dsw_StrtStpFailDTC'
         *  Logic: '<S314>/Logical Operator'
         *  RelationalOperator: '<S314>/Greater  Than3'
         */
        if ((rtb_Sum3_giv > KeESSR_Cnt_EngStallMaxReAttmpts) &&
                (KeESSR_b_EngStallReattmptDTC))
        {
            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C64;
        }

        /* End of Switch: '<S334>/Switch1' */

        /* DataStoreWrite: '<S314>/Dsw_DsblNiClsdLoopCntrl' incorporates:
         *  Constant: '<S314>/TRUE Constant1'
         */
        VeESSR_b_DsblNiClsdLoopCntrl_DS = true;

        /* DataStoreWrite: '<S314>/Dsw_DsblNiClsdLoopCntrl3' incorporates:
         *  Constant: '<S314>/TRUE Constant2'
         */
        VeESSR_b_EngReStrtAttmpt_DS = true;

        /* DataStoreWrite: '<S314>/TCMOpenDiscCltch' incorporates:
         *  Constant: '<S314>/TRUE Constant'
         */
        VeESSR_b_TCMOpenDisconnctCltch_DS = true;

        /* DataStoreWrite: '<S311>/Dsw_STMTrigger' incorporates:
         *  Constant: '<S327>/Constant'
         *  Merge: '<S311>/Merge'
         *  SignalConversion generated from: '<S314>/CoastDown'
         */
        VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

        /* If: '<S314>/If1' incorporates:
         *  Constant: '<S331>/Constant'
         *  Constant: '<S332>/Constant'
         *  Constant: '<S333>/Calib'
         *  DataStoreRead: '<S314>/Dsr_EngTrqRespType3'
         *  Logic: '<S314>/Logical1'
         *  Logic: '<S314>/Logical2'
         *  RelationalOperator: '<S314>/Comparison1'
         *  RelationalOperator: '<S314>/Comparison4'
         */
        if ((HeESSR_b_BumpStrtEquipped) && ((CeHSER_e_UseM2Eqn == ((uint32)
                VeESSR_e_EngStallRngEqn_DS)) || (((uint32)
                VeESSR_e_EngStallRngEqn_DS) == CeHSER_e_UseG2Eqn)))
        {
            /* Outputs for IfAction SubSystem: '<S314>/DisableMtrBandNc1CL' incorporates:
             *  ActionPort: '<S328>/Action Port'
             */
            /* DataStoreWrite: '<S328>/Dsw_DsblNiClsdLoopCntrl3' incorporates:
             *  Constant: '<S328>/Constant Value'
             */
            VeESSR_M_MtrB_MaxTorq_DS = 0.0F;

            /* DataStoreWrite: '<S328>/Dsw_DsblNiClsdLoopCntrl4' incorporates:
             *  Constant: '<S328>/Constant Value'
             */
            VeESSR_M_MtrB_MinTorq_DS = 0.0F;

            /* DataStoreWrite: '<S328>/Dsw_InhibitShiftToMode1' incorporates:
             *  Constant: '<S328>/TRUE Constant'
             */
            VeESSR_b_DsblNc1ClsdLoopCntrl_DS = true;

            /* End of Outputs for SubSystem: '<S314>/DisableMtrBandNc1CL' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S314>/EnableMtrBandNc1CL' incorporates:
             *  ActionPort: '<S329>/Action Port'
             */
            /* DataStoreWrite: '<S329>/Dsw_DsblNiClsdLoopCntrl3' incorporates:
             *  Constant: '<S329>/Constant Value'
             */
            VeESSR_M_MtrB_MaxTorq_DS = 9999.0F;

            /* DataStoreWrite: '<S329>/Dsw_DsblNiClsdLoopCntrl4' */
            VeESSR_M_MtrB_MinTorq_DS = -9999.0F;

            /* DataStoreWrite: '<S329>/Dsw_InhibitShiftToMode1' incorporates:
             *  Constant: '<S329>/FALSE Constant3'
             */
            VeESSR_b_DsblNc1ClsdLoopCntrl_DS = false;

            /* End of Outputs for SubSystem: '<S314>/EnableMtrBandNc1CL' */
        }

        /* End of If: '<S314>/If1' */
        /* End of Outputs for SubSystem: '<S311>/CoastDown' */
    }
    else
    {
        if (VeESSR_b_EngStallDet)
        {
            /* Outputs for IfAction SubSystem: '<S311>/EngFail' incorporates:
             *  ActionPort: '<S317>/Action Port'
             */
            /* DataStoreWrite: '<S317>/Dsw_StrtStpFailDTC' incorporates:
             *  Constant: '<S344>/Constant'
             */
            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C64;

            /* DataStoreWrite: '<S311>/Dsw_STMTrigger' incorporates:
             *  Constant: '<S343>/Constant'
             *  Merge: '<S311>/Merge'
             *  SignalConversion generated from: '<S317>/EngFail'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

            /* End of Outputs for SubSystem: '<S311>/EngFail' */
        }
    }

    /* End of If: '<S311>/If' */

    /* Switch: '<S311>/Switch4' incorporates:
     *  Constant: '<S311>/Constant Value6'
     *  DataStoreRead: '<S311>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S311>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S311>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S311>/Logical21'
     *  Logic: '<S311>/Logical3'
     *  RelationalOperator: '<S311>/Comparison5'
     *  S-Function (sfix_bitop): '<S311>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S313>/FixPt Bitwise Operator1'
     */
    if ((rtb_Logical_gb || (VeESSR_b_EngStallDet)) &&
            ((VeESSR_g_StrtStpFailPhaseSelect_DS & 2U) > 0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 2U;
    }

    /* End of Switch: '<S311>/Switch4' */

    /* Switch: '<S316>/Switch' incorporates:
     *  S-Function (sfix_bitop): '<S338>/FixPt Bitwise Operator1'
     */
    if (VeESSR_b_EngStallDet)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 1U;
    }

    /* End of Switch: '<S316>/Switch' */

    /* DataStoreWrite: '<S311>/Dsw_InputAcceltnProf' */
    VeESSR_dn_InputAcceltnProf_DS = rtu_InputAccelProfile;

    /* DataStoreWrite: '<S311>/Dsw_InputSpeedProfile' */
    VeESSR_n_InputSpeedProfile_DS = rtu_InputSpeedProfile;

    /* DataStoreWrite: '<S311>/Dsw_InputTorqEst' */
    VeESSR_M_EngTorqEst_DS = rtu_EngTrqActual;

    /* DataStoreWrite: '<S311>/Data Store Write1' incorporates:
     *  Constant: '<S311>/Constant'
     */
    *rtd_VeESSR_M_BCTiMargin_DS = 0.0F;

    /* DataStoreWrite: '<S311>/Dsw_AEMDMtrAGain' incorporates:
     *  Constant: '<S323>/Calib'
     */
    VeESSR_scl_AEMDMtrAGain_DS = KeESSR_scl_AEMDMtrAGain_EngRun;

    /* DataStoreWrite: '<S311>/Dsw_AEMDMtrBGain' incorporates:
     *  Constant: '<S324>/Calib'
     */
    VeESSR_scl_AEMDMtrBGain_DS = KeESSR_scl_AEMDMtrBGain_EngRun;
}

#endif

/* Output and update for function-call system: '<S176>/MainEngStartEntry' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_MainEngStartEntry(VAR
    (TeSTRR_e_EngStrtStopType, AUTOMATIC) rtu_VeSTRR_e_EngStrtStopType, VAR
    (float32, AUTOMATIC) rtu_VeENGR_T_EngCoolantTemp)
{
    /* RelationalOperator: '<S462>/Comparison4' incorporates:
     *  Constant: '<S499>/Constant'
     *  DataStoreWrite: '<S462>/Dsw_CompressTstOn'
     */
    VeESSR_b_CompressTstOn_DS = (((uint32)rtu_VeSTRR_e_EngStrtStopType) ==
        CeSTRR_e_CompressTst);

    /* Selector: '<S462>/Selector4' incorporates:
     *  Constant: '<S501>/Calib'
     *  DataStoreWrite: '<S462>/Dsw_EngStrtType'
     */
    VeESSR_e_EngStrtType_DS = KaESSR_e_EngStrtTypeMap
        [(rtu_VeSTRR_e_EngStrtStopType)];

    /* If: '<S462>/If1' incorporates:
     *  DataStoreRead: '<S462>/Dsr_KeyStrtEngModing'
     */
    if (VeESSR_b_KeyStrtEngModing_DS)
    {
        /* Outputs for IfAction SubSystem: '<S462>/KeyStrt' incorporates:
         *  ActionPort: '<S502>/Action Port'
         */
        /* DataStoreWrite: '<S462>/Dsw_AStrtPBatBoostReq' incorporates:
         *  Constant: '<S502>/TRUE Constant'
         *  Merge: '<S503>/Merge3'
         *  SignalConversion generated from: '<S502>/PbatBstRq'
         */
        VeESSR_b_AStrtPBatBoostReq_DS = true;

        /* DataStoreWrite: '<S462>/Dsw_MinEngStrtSpd' incorporates:
         *  Lookup_n-D: '<S505>/Vector'
         *  Merge: '<S503>/Merge4'
         */
        VeESSR_n_MinEngStrtSpd_DS = look1_iflf_binlcapw
            (rtu_VeENGR_T_EngCoolantTemp, ((const float32 *)
              &(KxESSR_n_MinEngKeyStrtSpd[0])), ((const float32 *)
              &(KtESSR_n_MinEngKeyStrtSpd[0])), 2U);

        /* End of Outputs for SubSystem: '<S462>/KeyStrt' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S462>/AutoStrt' incorporates:
         *  ActionPort: '<S498>/Action Port'
         */
        /* DataStoreWrite: '<S462>/Dsw_AStrtPBatBoostReq' incorporates:
         *  Constant: '<S498>/TRUE Constant'
         *  Merge: '<S503>/Merge3'
         *  SignalConversion generated from: '<S498>/PbatBstRq'
         */
        VeESSR_b_AStrtPBatBoostReq_DS = true;

        /* DataStoreWrite: '<S462>/Dsw_MinEngStrtSpd' incorporates:
         *  Lookup_n-D: '<S504>/Vector'
         *  Merge: '<S503>/Merge4'
         */
        VeESSR_n_MinEngStrtSpd_DS = look1_iflf_binlcapw
            (rtu_VeENGR_T_EngCoolantTemp, ((const float32 *)
              &(KxESSR_n_MinEngAutoStrtSpd[0])), ((const float32 *)
              &(KtESSR_n_MinEngAutoStrtSpd[0])), 2U);

        /* End of Outputs for SubSystem: '<S462>/AutoStrt' */
    }

    /* End of If: '<S462>/If1' */

    /* DataStoreWrite: '<S462>/Dsw_MainSTMTmr' incorporates:
     *  Constant: '<S462>/Constant Value1'
     */
    VeESSR_t_MainSTMTmr_DS = 0.0F;

    /* DataStoreWrite: '<S462>/Dsw_PBatBoostTm' incorporates:
     *  Constant: '<S462>/Constant Value1'
     */
    VeESSR_t_PBatBoostTm_DS = 0.0F;

    /* DataStoreWrite: '<S462>/Data Store Write2' incorporates:
     *  Constant: '<S462>/FALSE Constant1'
     */
    VeESSR_b_TCMOpenDisconnctCltch_DS = false;

    /* DataStoreWrite: '<S462>/Dsw_InputTorqOverride' incorporates:
     *  Constant: '<S462>/TRUE Constant'
     */
    VeESSR_b_InputTorqOverride_DS = true;

    /* DataStoreWrite: '<S462>/Dsw_StrtStopFail' incorporates:
     *  Constant: '<S462>/FALSE Constant'
     */
    VeESSR_b_StrtStopFail_DS = false;

    /* DataStoreWrite: '<S462>/Dsw_StrtStpFailDTC' incorporates:
     *  Constant: '<S500>/Constant'
     */
    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
}

#endif

/* Output and update for function-call system: '<S176>/MainEngStartExit' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_MainEngStartExit(void)
{
    /* DataStoreWrite: '<S463>/Dsw_DisableNc1DotLim' incorporates:
     *  Constant: '<S463>/FALSE Constant4'
     */
    VeESSR_b_DisableNc1DotLim_DS = false;

    /* DataStoreWrite: '<S463>/Dsw_InputSpeedProfile2' incorporates:
     *  Constant: '<S463>/Constant Value1'
     */
    VeESSR_n_TargetSpeed_DS = 0.0F;

    /* DataStoreWrite: '<S463>/Dsw_InputSpeedProfile3' incorporates:
     *  Constant: '<S463>/Constant Value1'
     */
    VeESSR_dn_TargetAcceltn_DS = 0.0F;

    /* DataStoreWrite: '<S463>/Dsw_Ni1stFlt_DS' incorporates:
     *  Constant: '<S463>/Constant Value4'
     */
    VeESSR_n_Ni1stFlt_DS = 0.0F;

    /* DataStoreWrite: '<S463>/Dsw_AStrtPBatBoostReq' incorporates:
     *  Constant: '<S463>/FALSE Constant3'
     */
    VeESSR_b_AStrtPBatBoostReq_DS = false;

    /* DataStoreWrite: '<S463>/Dsw_CompressTstOn' incorporates:
     *  Constant: '<S463>/FALSE Constant1'
     */
    VeESSR_b_CompressTstOn_DS = false;

    /* Switch: '<S463>/Switch1' incorporates:
     *  Constant: '<S508>/Calib'
     *  DataStoreWrite: '<S463>/Dsw_Dsbl_ICSRFor12vStart'
     */
    VeESSR_b_DsblNiClsdLoopCntrl_DS = HeESSR_b_DisableNiSpeedMdECM;

    /* Switch: '<S463>/Switch' incorporates:
     *  Constant: '<S506>/Constant'
     *  Constant: '<S507>/Constant'
     *  Constant: '<S508>/Calib'
     *  DataStoreWrite: '<S463>/Dsw_EngCntrlMode_DS'
     */
    if (HeESSR_b_DisableNiSpeedMdECM)
    {
        VeESSR_e_EngCntrlMode_DS = CeTRAR_e_SpeedMode;
    }
    else
    {
        VeESSR_e_EngCntrlMode_DS = CeTRAR_e_TorqueMode;
    }

    /* End of Switch: '<S463>/Switch' */

    /* DataStoreWrite: '<S463>/Dsw_InputTorqOverride' incorporates:
     *  Constant: '<S463>/FALSE Constant'
     */
    VeESSR_b_InputTorqOverride_DS = false;
}

#endif

/* Output and update for function-call system: '<S177>/MainEngStopEntry' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_MainEngStopEntry(void)
{
    /* DataStoreWrite: '<S510>/Dsw_MainSTMTmr' incorporates:
     *  Constant: '<S510>/Constant Value1'
     */
    VeESSR_t_MainSTMTmr_DS = 0.0F;

    /* Switch: '<S510>/Switch1' incorporates:
     *  Constant: '<S510>/Constant Value3'
     *  Constant: '<S540>/Calib'
     *  DataStoreWrite: '<S510>/Data Store Write1'
     */
    if (!HeESSR_b_EngStrtTorq)
    {
        VeESSR_M_EngStrtTorq_DS = 0.0F;
    }

    /* End of Switch: '<S510>/Switch1' */

    /* DataStoreWrite: '<S510>/Data Store Write' incorporates:
     *  Constant: '<S543>/Calib'
     */
    VeESSR_e_EngStrtActuatorTyp = KeESSR_e_EngStartActrType;

    /* DataStoreWrite: '<S510>/Data Store Write2' incorporates:
     *  Constant: '<S510>/TRUE Constant'
     */
    VeESSR_b_TCMOpenDisconnctCltch_DS = true;

    /* DataStoreWrite: '<S510>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
     *  Constant: '<S541>/Calib'
     */
    VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

    /* DataStoreWrite: '<S510>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
     *  Constant: '<S542>/Calib'
     */
    VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

    /* DataStoreWrite: '<S510>/Dsw_EngStrtType' incorporates:
     *  Constant: '<S538>/Constant'
     */
    VeESSR_e_EngStrtType_DS = CeESSR_e_NoStrt;

    /* DataStoreWrite: '<S510>/Dsw_InputSpeedProfile1' incorporates:
     *  Constant: '<S544>/Calib'
     */
    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

    /* DataStoreWrite: '<S510>/Dsw_InputTorqOverride' incorporates:
     *  Constant: '<S510>/TRUE Constant1'
     */
    VeESSR_b_InputTorqOverride_DS = true;

    /* DataStoreWrite: '<S510>/Dsw_StrtStpFailDTC' incorporates:
     *  Constant: '<S539>/Constant'
     */
    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
}

#endif

/* Output and update for function-call system: '<S177>/MainEngStopExit' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_MainEngStopExit(void)
{
    /* DataStoreWrite: '<S511>/Dsw_InputSpeedProfile2' incorporates:
     *  Constant: '<S511>/Constant Value1'
     */
    VeESSR_n_TargetSpeed_DS = 0.0F;

    /* DataStoreWrite: '<S511>/Dsw_InputSpeedProfile3' incorporates:
     *  Constant: '<S511>/Constant Value1'
     */
    VeESSR_dn_TargetAcceltn_DS = 0.0F;

    /* Switch: '<S511>/Switch1' incorporates:
     *  Constant: '<S545>/Calib'
     *  DataStoreWrite: '<S511>/Dsw_Dsbl_ICSRFor12vStart'
     */
    VeESSR_b_DsblNiClsdLoopCntrl_DS = ((HeESSR_b_DisableNi) ||
        (VeESSR_b_DsblNiClsdLoopCntrl_DS));

    /* DataStoreWrite: '<S511>/Dsw_EngRestartReq' incorporates:
     *  Constant: '<S511>/FALSE Constant'
     */
    VeESSR_b_DsblFuelReq_DS = false;

    /* DataStoreWrite: '<S511>/Dsw_EngRestartReq1' incorporates:
     *  Constant: '<S511>/FALSE Constant1'
     */
    VeESSR_b_RmpDwnReq_DS = false;

    /* DataStoreWrite: '<S511>/Dsw_InputTorqOverride' incorporates:
     *  Constant: '<S511>/TRUE Constant'
     */
    VeESSR_b_InputTorqOverride_DS = true;
}

#endif

/* Output and update for function-call system: '<S175>/ESSC_ImmedStopEnt' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_ImmedStopEnt(VAR(float32,
    AUTOMATIC) rtu_Ni, VAR(TeTRAR_e_HybCmndEngTorqRespTyp, AUTOMATIC)
    rtu_TRAR_TrqRespType, VAR(float32, AUTOMATIC) rtu_HybCmndEngTorqImmed)
{
    /* DataStoreWrite: '<S368>/Dsw_InputSpeedProfile1' */
    VeESSR_n_InputSpeedProfile_DS = rtu_Ni;

    /* MinMax: '<S368>/MinMax1' incorporates:
     *  DataStoreRead: '<S368>/Dsr_STMTmr4'
     *  DataTypeConversion: '<S368>/Data Type Conversion'
     *  DataTypeConversion: '<S368>/Data Type Conversion1'
     */
    if (VeESSR_e_StrtStpTypEngTorqRespType_DS > ((TePTAR_e_ImmediateTorqRespType)
            rtu_TRAR_TrqRespType))
    {
        /* DataTypeConversion: '<S450>/DataTypeConversion' incorporates:
         *  DataStoreWrite: '<S368>/Dsw_EngTrqRespType'
         */
        VeESSR_e_EngTrqRespType_DS = VeESSR_e_StrtStpTypEngTorqRespType_DS;
    }
    else
    {
        /* DataTypeConversion: '<S450>/DataTypeConversion' incorporates:
         *  DataStoreWrite: '<S368>/Dsw_EngTrqRespType'
         */
        VeESSR_e_EngTrqRespType_DS = rtu_TRAR_TrqRespType;
    }

    /* End of MinMax: '<S368>/MinMax1' */

    /* MinMax: '<S368>/MinMax2' incorporates:
     *  Constant: '<S452>/Calib'
     *  DataStoreWrite: '<S368>/Dsw_EngTrqReqImmed'
     */
    VeESSR_M_EngTrqReqImmed_DS = fminf(KeESSR_M_MinEngTorq,
        rtu_HybCmndEngTorqImmed);

    /* DataStoreWrite: '<S368>/Dsw_EngTrqReqPrdtd' incorporates:
     *  Constant: '<S452>/Calib'
     */
    VeESSR_M_EngTrqReqPrdtd_DS = KeESSR_M_MinEngTorq;

    /* DataStoreWrite: '<S368>/Dsw_DsblNiClsdLoopCntrl4' incorporates:
     *  Constant: '<S368>/Constant Value'
     */
    VeESSR_M_MtrB_MaxTorq_DS = 9999.0F;

    /* DataStoreWrite: '<S368>/Dsw_DsblNiClsdLoopCntrl5' */
    VeESSR_M_MtrB_MinTorq_DS = -9999.0F;

    /* DataStoreWrite: '<S368>/Dsw_DsblNiClsdLoopCntrl6' incorporates:
     *  Constant: '<S368>/Constant Value'
     */
    VeESSR_M_MtrC_MaxTorq_DS = 9999.0F;

    /* DataStoreWrite: '<S368>/Dsw_DsblNiClsdLoopCntrl7' */
    VeESSR_M_MtrC_MinTorq_DS = -9999.0F;

    /* DataStoreWrite: '<S368>/Data Store Write2' incorporates:
     *  Constant: '<S368>/Constant Value1'
     */
    VeESSR_M_EngStrtTorq_DS = 0.0F;

    /* DataStoreWrite: '<S368>/Dsw_InputSpeedProfile2' incorporates:
     *  Constant: '<S368>/Constant Value2'
     */
    VeESSR_n_NbTgt_DS = 0.0F;

    /* DataStoreWrite: '<S368>/Dsw_TorqCancelDsrd1' incorporates:
     *  Constant: '<S368>/Constant Value3'
     */
    VeESSR_k_TorqCancelGain_DS = 0.0F;

    /* DataStoreWrite: '<S368>/Dsw_EngStartStopSt' incorporates:
     *  Constant: '<S448>/Constant'
     */
    VeESSR_e_EngStartStopSt_DS = CeESSR_e_ImmedStopSt;

    /* DataStoreWrite: '<S368>/Data Store Write' incorporates:
     *  Constant: '<S456>/Calib'
     */
    VeESSR_e_EngStrtActuatorTyp = KeESSR_e_EngStartActrType;

    /* DataStoreWrite: '<S368>/Data Store Write3' incorporates:
     *  Constant: '<S451>/Constant'
     */
    VeESSR_e_HybEngSysActv_DS = CeESSR_e_HybEngEnabledOnIS;

    /* DataStoreWrite: '<S368>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
     *  Constant: '<S453>/Calib'
     */
    VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

    /* DataStoreWrite: '<S368>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
     *  Constant: '<S454>/Calib'
     */
    VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

    /* DataStoreWrite: '<S368>/Dsw_DsblNiClsdLoopCntrl3' incorporates:
     *  Constant: '<S368>/FALSE Constant3'
     */
    VeESSR_b_EngReStrtAttmpt_DS = false;

    /* DataStoreWrite: '<S368>/Dsw_EngStrtType' incorporates:
     *  Constant: '<S449>/Constant'
     */
    VeESSR_e_EngStrtType_DS = CeESSR_e_NoStrt;

    /* DataStoreWrite: '<S368>/Dsw_EngStrtType1' incorporates:
     *  Constant: '<S457>/Calib'
     */
    VeESSR_e_TCM_StartStopType_DS = KeESSR_e_TCM_StartStopType_ImmedStop;

    /* DataStoreWrite: '<S368>/Dsw_EngStrtType2' incorporates:
     *  Constant: '<S458>/Calib'
     */
    VeESSR_e_TCM_TransitionStatus_DS = KeESSR_e_TCM_TransitionStatus_ImmedStop;

    /* DataStoreWrite: '<S368>/Dsw_InhibitShiftToMode' incorporates:
     *  Constant: '<S455>/Calib'
     */
    VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtImmedStopSt;

    /* DataStoreWrite: '<S368>/Dsw_InhibitShiftToMode1' incorporates:
     *  Constant: '<S368>/FALSE Constant1'
     */
    VeESSR_b_DsblNc1ClsdLoopCntrl_DS = false;

    /* DataStoreWrite: '<S368>/Dsw_InhibitShiftToMode2' incorporates:
     *  Constant: '<S368>/TRUE Constant2'
     */
    VeESSR_b_NbTgtReq_DS = true;

    /* DataStoreWrite: '<S368>/Dsw_InputTorqOverride' incorporates:
     *  Constant: '<S368>/TRUE Constant1'
     */
    VeESSR_b_InputTorqOverride_DS = true;

    /* DataStoreWrite: '<S368>/Dsw_SpdCtlGainMod' incorporates:
     *  Constant: '<S460>/Calib'
     */
    VeESSR_scl_SpdCtlGainMod_DS = KeESSR_scl_SpdCtlImmedStpVal;

    /* DataStoreWrite: '<S368>/Dsw_TransFldPmpSel' incorporates:
     *  Constant: '<S459>/Calib'
     */
    VeESSR_e_TransFldPmpSel_DS = KeESSR_e_TransFldPmpSelImmedStop;

    /* DataStoreWrite: '<S368>/TCMOpenDiscCltch' incorporates:
     *  Constant: '<S368>/TRUE Constant'
     */
    VeESSR_b_TCMOpenDisconnctCltch_DS = true;
}

#endif

/*
 * Output and update for action system:
 *    '<S367>/If_RampDown_P1C68'
 *    '<S2451>/If_DisableFuel_P1C68'
 *    '<S2799>/If_RampDown_P1C68'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_If_RampDown_P1C68(void)
{
    /* DataStoreWrite: '<S378>/Dsw_StrtStpFailDTC' incorporates:
     *  Constant: '<S393>/Constant'
     */
    VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C68;
}

#endif

/* System initialize for function-call system: '<S175>/ESSC_ImmedStopDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_ImmedStopDur_Init(P2VAR
    (DW_ESSC_ImmedStopDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW)
{
    /* SystemInitialize for IfAction SubSystem: '<S367>/Ramp' */
    /* InitializeConditions for Delay: '<S410>/IntegerDelay' */
    localDW->icLoad = 1U;

    /* End of SystemInitialize for SubSystem: '<S367>/Ramp' */
}

#endif

/* Output and update for function-call system: '<S175>/ESSC_ImmedStopDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_ImmedStopDur(VAR(float32,
    AUTOMATIC) rtu_Ni, VAR(float32, AUTOMATIC) rtu_NiDotMax, VAR(float32,
    AUTOMATIC) rtu_NiDotMin, VAR(TeENGR_e_CylinderDeacModes, AUTOMATIC)
    rtu_CylinderDeacMode, VAR(float32, AUTOMATIC) rtu_EngTrqActual, VAR(float32,
    AUTOMATIC) rtu_SpinDownDragCorr, VAR(boolean, AUTOMATIC) rtu_PSAActv, VAR
    (boolean, AUTOMATIC) rtu_PTCrnkActv, VAR(float32, AUTOMATIC)
    rtu_VeHSER_n_NiMax, P2VAR(DW_ESSC_ImmedStopDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(ZCE_ESSC_ImmedStopDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localZCE, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn)
{
    sint32 i;
    float32 rtb_Abs2_mb;
    float32 rtb_Gain1_e;
    float32 rtb_Gain_cmo;
    float32 rtb_Gain_gz;
    float32 rtb_IntegerDelay;
    float32 rtb_MinMax1_a0;
    float32 rtb_Product4;
    float32 rtb_Product4_h;
    float32 rtb_Sum15;
    float32 rtb_Sum2_bi3;
    float32 rtb_Sum6_ca;
    float32 rtb_Summation1_c1;
    float32 rtb_Summation_k;
    float32 rtb_Switch1_bg;
    float32 rtb_Switch1_ik2;
    float32 rtb_Switch1_khq;
    float32 rtb_Switch_and;
    uint16 rtb_Switch1_eb0;
    uint8 tmp;
    boolean rtb_AND_o4;
    boolean rtb_GreaterThan_nw;
    boolean rtb_Logical2_bpk;
    boolean rtb_RelationalOperator_j4;
    boolean rtb_UnitDelay_ou;

    /* Logic: '<S367>/AND' incorporates:
     *  Constant: '<S380>/Calib'
     *  Constant: '<S384>/Calib'
     *  DataStoreRead: '<S367>/Dsr_STMTmr'
     *  RelationalOperator: '<S367>/Less Than  or Equal'
     *  RelationalOperator: '<S367>/Less Than  or Equal1'
     */
    rtb_AND_o4 = ((VeESSR_t_STMTmr_DS > KeESSR_t_MinTmImmedStp) && (rtu_Ni <=
                   KeESSR_n_ImmedStpCmpltSpd));

    /* RelationalOperator: '<S367>/Greater  Than' incorporates:
     *  Constant: '<S383>/Calib'
     *  DataStoreRead: '<S367>/Dsr_STMTmr'
     */
    rtb_GreaterThan_nw = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmImmedStp);

    /* UnitDelay: '<S447>/Unit Delay' incorporates:
     *  Logic: '<S367>/Logical Operator1'
     *  Logic: '<S367>/Logical5'
     */
    rtb_UnitDelay_ou = ((!rtb_AND_o4) && rtb_GreaterThan_nw);

    /* Switch: '<S367>/Switch' incorporates:
     *  S-Function (sfix_bitop): '<S369>/FixPt Bitwise Operator1'
     */
    if (rtb_UnitDelay_ou)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 16777216U;
    }

    /* End of Switch: '<S367>/Switch' */

    /* Sum: '<S367>/Summation1' incorporates:
     *  Constant: '<S375>/Calib'
     *  DataStoreRead: '<S367>/Dsr_STMTmr1'
     */
    rtb_Summation1_c1 = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* DataStoreWrite: '<S367>/Dsw_STMTmr' */
    VeESSR_t_STMTmr_DS = rtb_Summation1_c1;

    /* Switch: '<S376>/Switch1' incorporates:
     *  Constant: '<S372>/Constant'
     *  Constant: '<S374>/Calib'
     *  Constant: '<S379>/Calib'
     *  DataStoreWrite: '<S367>/Dsw_STMTrigger'
     *  Logic: '<S367>/AND1'
     *  Logic: '<S367>/AND2'
     *  Logic: '<S367>/AND3'
     *  Switch: '<S376>/Switch2'
     */
    if (rtb_AND_o4 || ((((!rtu_PSAActv) && rtu_PTCrnkActv) &&
                        (HeESSR_b_12vStrtrEquipped)) && (KeESSR_b_Enbl_KeyOffIS)))
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngStop;
    }
    else
    {
        if (rtb_GreaterThan_nw)
        {
            /* Switch: '<S376>/Switch1' incorporates:
             *  Constant: '<S371>/Constant'
             *  DataStoreWrite: '<S367>/Dsw_STMTrigger'
             *  Switch: '<S376>/Switch2'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;
        }
    }

    /* End of Switch: '<S376>/Switch1' */

    /* Switch: '<S367>/Switch4' incorporates:
     *  Constant: '<S367>/Constant Value6'
     *  DataStoreRead: '<S367>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S367>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S367>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S367>/Logical21'
     *  RelationalOperator: '<S367>/Comparison5'
     *  S-Function (sfix_bitop): '<S367>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S370>/FixPt Bitwise Operator1'
     */
    if (rtb_UnitDelay_ou && ((VeESSR_g_StrtStpFailPhaseSelect_DS & 1048576U) >
                             0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 1048576U;
    }

    /* End of Switch: '<S367>/Switch4' */

    /* DataStoreWrite: '<S367>/Dsw_AEMDMtrAGain' incorporates:
     *  Constant: '<S381>/Calib'
     */
    VeESSR_scl_AEMDMtrAGain_DS = KeESSR_scl_AEMDMtrAGain_ImmedStop;

    /* DataStoreWrite: '<S367>/Dsw_AEMDMtrBGain' incorporates:
     *  Constant: '<S382>/Calib'
     */
    VeESSR_scl_AEMDMtrBGain_DS = KeESSR_scl_AEMDMtrBGain_ImmedStop;

    /* If: '<S367>/If1' */
    if (rtb_UnitDelay_ou)
    {
        /* Outputs for IfAction SubSystem: '<S367>/If_RampDown_P1C68' incorporates:
         *  ActionPort: '<S378>/Action Port'
         */
        ESSR_ac_If_RampDown_P1C68();

        /* End of Outputs for SubSystem: '<S367>/If_RampDown_P1C68' */
    }

    /* End of If: '<S367>/If1' */

    /* Switch: '<S389>/Switch1' incorporates:
     *  Constant: '<S390>/Calib'
     */
    if (KeESSR_b_UseDamperLockout)
    {
        /* Switch: '<S389>/Switch1' incorporates:
         *  Constant: '<S392>/Calib'
         *  RelationalOperator: '<S373>/Comparison'
         */
        VeESSR_b_ImmedStpDmprDelayCmplt = (rtb_Summation1_c1 >=
            KeESSR_t_ImmedStpDmprDelay);
    }
    else
    {
        /* Switch: '<S389>/Switch1' incorporates:
         *  Constant: '<S373>/TRUE Constant'
         */
        VeESSR_b_ImmedStpDmprDelayCmplt = true;
    }

    /* End of Switch: '<S389>/Switch1' */

    /* Logic: '<S373>/AND2' incorporates:
     *  Constant: '<S388>/Constant'
     *  Constant: '<S391>/Calib'
     *  RelationalOperator: '<S373>/Comparison1'
     *  RelationalOperator: '<S373>/Comparison4'
     */
    VeESSR_b_ImmedStpAllCylActCmplt = ((((uint32)rtu_CylinderDeacMode) ==
        CeENGR_e_AllCylindersActive) || (rtb_Summation1_c1 >=
        KeESSR_t_ImmedStpAllCylWaitTm));

    /* Logic: '<S373>/Logical' */
    rtb_GreaterThan_nw = ((VeESSR_b_ImmedStpDmprDelayCmplt) &&
                          (VeESSR_b_ImmedStpAllCylActCmplt));

    /* Outputs for Atomic SubSystem: '<S367>/TurnOnDelaySample' */
    /* Outputs for Atomic SubSystem: '<S386>/EdgeRising' */
    /* Logic: '<S447>/AND' incorporates:
     *  Logic: '<S447>/OR1'
     *  UnitDelay: '<S447>/Unit Delay'
     */
    rtb_AND_o4 = (rtb_GreaterThan_nw && (!localDW->UnitDelay_DSTATE_k));

    /* Update for UnitDelay: '<S447>/Unit Delay' */
    localDW->UnitDelay_DSTATE_k = rtb_GreaterThan_nw;

    /* End of Outputs for SubSystem: '<S386>/EdgeRising' */

    /* Logic: '<S386>/OR1' incorporates:
     *  Logic: '<S386>/AND'
     */
    rtb_UnitDelay_ou = !rtb_GreaterThan_nw;

    /* Switch: '<S386>/Switch1' incorporates:
     *  Constant: '<S386>/Constant Value'
     *  Logic: '<S386>/OR'
     *  Logic: '<S386>/OR1'
     *  MinMax: '<S386>/Minimum'
     *  Sum: '<S386>/Summation'
     *  UnitDelay: '<S386>/Unit Delay'
     */
    if (rtb_UnitDelay_ou || rtb_AND_o4)
    {
        /* Switch: '<S386>/Switch1' incorporates:
         *  Constant: '<S386>/Constant Value1'
         */
        rtb_Switch1_eb0 = 0U;
    }
    else if (2 < ((sint32)((uint16)(((uint32)localDW->UnitDelay_DSTATE_g) + 1U))))
    {
        /* MinMax: '<S386>/Minimum' incorporates:
         *  Switch: '<S386>/Switch1'
         */
        rtb_Switch1_eb0 = 2U;
    }
    else
    {
        /* Switch: '<S386>/Switch1' incorporates:
         *  Constant: '<S386>/Constant Value'
         *  MinMax: '<S386>/Minimum'
         *  Sum: '<S386>/Summation'
         *  UnitDelay: '<S386>/Unit Delay'
         */
        rtb_Switch1_eb0 = (uint16)(((uint32)localDW->UnitDelay_DSTATE_g) + 1U);
    }

    /* End of Switch: '<S386>/Switch1' */

    /* Update for UnitDelay: '<S386>/Unit Delay' */
    localDW->UnitDelay_DSTATE_g = rtb_Switch1_eb0;

    /* Logic: '<S367>/Logical2' incorporates:
     *  Constant: '<S367>/Constant Value2'
     *  Logic: '<S386>/AND'
     *  RelationalOperator: '<S386>/Greater  Than'
     */
    rtb_AND_o4 = (rtb_UnitDelay_ou || (((sint32)rtb_Switch1_eb0) < 2));

    /* End of Outputs for SubSystem: '<S367>/TurnOnDelaySample' */

    /* If: '<S367>/If' */
    if (rtb_GreaterThan_nw)
    {
        /* Outputs for IfAction SubSystem: '<S367>/Ramp' incorporates:
         *  ActionPort: '<S385>/Action Port'
         */
        /* Gain: '<S406>/Gain' incorporates:
         *  Abs: '<S406>/Abs1'
         *  Constant: '<S400>/Calib'
         */
        rtb_Gain_cmo = -fabsf(KeESSR_dn_ImmedStpJerkMin);

        /* Product: '<S410>/Product4' incorporates:
         *  Constant: '<S396>/Calib'
         */
        rtb_Product4 = rtb_Gain_cmo / HeESSR_t_MedTEB_dT;

        /* DataStoreRead: '<S385>/Dsr_InputSpeedProfile1' */
        rtb_Summation1_c1 = VeESSR_n_InputSpeedProfile_DS;

        /* Switch: '<S407>/Switch1' */
        if (rtb_AND_o4)
        {
            /* Switch: '<S407>/Switch1' incorporates:
             *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile1'
             */
            rtb_Switch1_bg = VeESSR_n_InputSpeedProfile_DS;
        }
        else
        {
            /* Switch: '<S407>/Switch1' incorporates:
             *  UnitDelay: '<S407>/Unit Delay'
             */
            rtb_Switch1_bg = localDW->UnitDelay_DSTATE;
        }

        /* End of Switch: '<S407>/Switch1' */

        /* Outputs for Atomic SubSystem: '<S406>/LowpassT Reset Enabled' */
        /* Sum: '<S408>/Summation' incorporates:
         *  Constant: '<S385>/Constant Value2'
         *  Constant: '<S396>/Calib'
         *  Constant: '<S403>/Calib'
         *  MinMax: '<S408>/Maximum'
         *  Product: '<S408>/Multiplication'
         *  Product: '<S408>/Multiplication1'
         *  Sum: '<S408>/Subtraction'
         */
        rtb_Switch1_bg += ((0.0F - rtb_Switch1_bg) * HeESSR_t_MedTEB_dT) * (1.0F
            / fmaxf(KeESSR_k_ImmedStpScndOrdLwPassT, HeESSR_t_MedTEB_dT));

        /* End of Outputs for SubSystem: '<S406>/LowpassT Reset Enabled' */

        /* Outputs for Atomic SubSystem: '<S406>/LowpassT Reset Enabled1' */
        /* Sum: '<S409>/Summation' incorporates:
         *  Constant: '<S396>/Calib'
         *  Constant: '<S402>/Calib'
         *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile3'
         *  MinMax: '<S409>/Maximum'
         *  Product: '<S409>/Multiplication'
         *  Product: '<S409>/Multiplication1'
         *  Sum: '<S409>/Subtraction'
         */
        rtb_Summation_k = (((rtb_Switch1_bg - VeESSR_n_InputSpeedProfile_DS) *
                            HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                            (KeESSR_k_ImmedStpFrstOrdLwPassT, HeESSR_t_MedTEB_dT)))
            + VeESSR_n_InputSpeedProfile_DS;

        /* End of Outputs for SubSystem: '<S406>/LowpassT Reset Enabled1' */

        /* Switch: '<S429>/Switch1' incorporates:
         *  UnitDelay: '<S429>/Unit Delay'
         */
        if (rtb_AND_o4)
        {
            rtb_Gain1_e = rtb_Summation_k;
        }
        else
        {
            rtb_Gain1_e = localDW->UnitDelay_DSTATE_h;
        }

        /* End of Switch: '<S429>/Switch1' */

        /* Gain: '<S410>/Gain1' incorporates:
         *  Sum: '<S410>/Sum18'
         */
        rtb_Gain1_e = (rtb_Summation_k + rtb_Gain1_e) * 0.5F;

        /* Delay: '<S410>/IntegerDelay' incorporates:
         *  Constant: '<S419>/Calib'
         */
        if (rtb_AND_o4 && (((sint32)localZCE->IntegerDelay_Reset_ZCE_oe) != 1))
        {
            localDW->icLoad = 1U;
        }

        localZCE->IntegerDelay_Reset_ZCE_oe = rtb_AND_o4 ? ((ZCSigState)1) :
            ((ZCSigState)0);
        if (((sint32)localDW->icLoad) != 0)
        {
            for (i = 0; i < 16; i++)
            {
                localDW->IntegerDelay_DSTATE[i] = rtb_Gain1_e;
            }
        }

        if (((sint32)KeESSR_Cnt_DelayOptNi) <= 0)
        {
            /* Delay: '<S410>/IntegerDelay' */
            rtb_IntegerDelay = rtb_Gain1_e;
        }
        else
        {
            if (((sint32)KeESSR_Cnt_DelayOptNi) > 16)
            {
                tmp = 16U;
            }
            else
            {
                tmp = KeESSR_Cnt_DelayOptNi;
            }

            /* Delay: '<S410>/IntegerDelay' */
            rtb_IntegerDelay = localDW->IntegerDelay_DSTATE[(uint8)(16U -
                ((uint32)tmp))];
        }

        /* End of Delay: '<S410>/IntegerDelay' */

        /* Sum: '<S410>/Sum15' incorporates:
         *  Abs: '<S410>/Abs4'
         *  Constant: '<S401>/Calib'
         *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile5'
         */
        rtb_Sum15 = fabsf(VeESSR_dn_TargetAcceltn_DS) +
            KeESSR_dn_NiTargetJerkLimit;

        /* Outputs for Atomic SubSystem: '<S410>/GradientLimiter' */
        /* Sum: '<S412>/Sum2' incorporates:
         *  Constant: '<S396>/Calib'
         *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile4'
         *  Product: '<S410>/Product6'
         *  Sum: '<S410>/Sum14'
         *  UnitDelay: '<S412>/Unit Delay'
         */
        rtb_Sum2_bi3 = ((rtb_Gain1_e - VeESSR_n_TargetSpeed_DS) /
                        HeESSR_t_MedTEB_dT) - localDW->UnitDelay_DSTATE_j;

        /* Outputs for Atomic SubSystem: '<S412>/Limiter' */
        /* Switch: '<S430>/Switch1' incorporates:
         *  RelationalOperator: '<S430>/Relational Operator'
         */
        if (rtb_Sum15 < rtb_Sum2_bi3)
        {
            /* MinMax: '<S413>/MinMax1' */
            rtb_MinMax1_a0 = rtb_Sum15;
        }
        else
        {
            /* MinMax: '<S413>/MinMax1' */
            rtb_MinMax1_a0 = rtb_Sum2_bi3;
        }

        /* End of Switch: '<S430>/Switch1' */

        /* Switch: '<S430>/Switch' incorporates:
         *  Gain: '<S410>/Gain'
         *  RelationalOperator: '<S430>/Relational Operator1'
         */
        if (rtb_MinMax1_a0 <= (-rtb_Sum15))
        {
            rtb_MinMax1_a0 = -rtb_Sum15;
        }

        /* End of Switch: '<S430>/Switch' */
        /* End of Outputs for SubSystem: '<S412>/Limiter' */

        /* Sum: '<S412>/Sum3' incorporates:
         *  UnitDelay: '<S412>/Unit Delay'
         */
        rtb_Gain_gz = rtb_MinMax1_a0 + localDW->UnitDelay_DSTATE_j;

        /* Update for UnitDelay: '<S412>/Unit Delay' */
        localDW->UnitDelay_DSTATE_j = rtb_Gain_gz;

        /* End of Outputs for SubSystem: '<S410>/GradientLimiter' */

        /* Sum: '<S411>/Subtraction1' incorporates:
         *  Constant: '<S404>/Calib'
         *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile5'
         *  Product: '<S411>/Multiplication'
         *  Sum: '<S411>/Subtraction'
         */
        rtb_Gain_gz = ((rtb_Gain_gz - VeESSR_dn_TargetAcceltn_DS) *
                       KeESSR_k_NiDotTargetFilt) + VeESSR_dn_TargetAcceltn_DS;

        /* DataStoreRead: '<S385>/Dsr_InputSpeedProfile2' */
        rtb_Sum15 = VeESSR_dn_InputAcceltnProf_DS;

        /* Abs: '<S406>/Abs' incorporates:
         *  Constant: '<S399>/Calib'
         */
        rtb_MinMax1_a0 = fabsf(KeESSR_dn_ImmedStpJerkMax);

        /* Switch: '<S441>/Switch1' incorporates:
         *  Constant: '<S439>/Calib'
         */
        if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
        {
            /* Switch: '<S441>/Switch1' incorporates:
             *  Constant: '<S440>/Calib'
             */
            rtb_Switch1_ik2 = HeESSR_dn_NiDotLmt4JerkOvrdVal;
        }
        else
        {
            /* Sum: '<S428>/Sum6' incorporates:
             *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile2'
             *  Sum: '<S428>/Sum8'
             */
            rtb_Switch1_ik2 = VeESSR_dn_InputAcceltnProf_DS - rtb_Gain_gz;

            /* Abs: '<S428>/Abs' incorporates:
             *  Sum: '<S428>/Sum6'
             */
            rtb_Sum2_bi3 = (rtb_Switch1_ik2 - rtb_Gain_cmo) + rtb_MinMax1_a0;

            /* MinMax: '<S428>/MinMax2' incorporates:
             *  Abs: '<S428>/Abs1'
             *  Constant: '<S396>/Calib'
             *  Constant: '<S428>/Constant Value'
             *  Constant: '<S428>/Constant Value3'
             *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile3'
             *  Product: '<S428>/Product2'
             *  Product: '<S428>/Product7'
             *  Product: '<S443>/Prod'
             *  Sum: '<S428>/Sum3'
             *  Sum: '<S428>/Sum5'
             */
            rtb_Sum2_bi3 = fmaxf((fabsf((rtb_IntegerDelay -
                                    VeESSR_n_InputSpeedProfile_DS) -
                                   (HeESSR_t_MedTEB_dT * rtb_Gain_gz)) *
                                  (rtb_Product4 * -2.0F)) - (rtb_Sum2_bi3 *
                                  rtb_Sum2_bi3), 0.0F);

            /* Switch: '<S445>/Switch' incorporates:
             *  Sqrt: '<S445>/Sqrt'
             */
            rtb_Sum2_bi3 = sqrtf(rtb_Sum2_bi3);

            /* Switch: '<S441>/Switch1' incorporates:
             *  Abs: '<S428>/Abs'
             *  Sum: '<S428>/Sum7'
             *  Sum: '<S428>/Sum8'
             */
            rtb_Switch1_ik2 = fabsf(rtb_Switch1_ik2 + rtb_Gain_cmo) +
                (rtb_Sum2_bi3 + rtb_Gain_gz);
        }

        /* End of Switch: '<S441>/Switch1' */

        /* Product: '<S410>/Product1' incorporates:
         *  Constant: '<S396>/Calib'
         */
        rtb_Sum2_bi3 = rtb_MinMax1_a0 / HeESSR_t_MedTEB_dT;

        /* Switch: '<S442>/Switch1' incorporates:
         *  Constant: '<S439>/Calib'
         */
        if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
        {
            /* Switch: '<S442>/Switch1' incorporates:
             *  Constant: '<S440>/Calib'
             *  Gain: '<S428>/Gain1'
             */
            rtb_Switch1_khq = -HeESSR_dn_NiDotLmt4JerkOvrdVal;
        }
        else
        {
            /* Sum: '<S428>/Sum11' incorporates:
             *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile2'
             *  Sum: '<S428>/Sum13'
             */
            rtb_Switch_and = VeESSR_dn_InputAcceltnProf_DS - rtb_Gain_gz;

            /* Abs: '<S428>/Abs2' incorporates:
             *  Sum: '<S428>/Sum11'
             */
            rtb_Abs2_mb = (rtb_Switch_and - rtb_MinMax1_a0) + rtb_Gain_cmo;

            /* MinMax: '<S428>/MinMax1' incorporates:
             *  Abs: '<S428>/Abs3'
             *  Constant: '<S396>/Calib'
             *  Constant: '<S428>/Constant Value1'
             *  Constant: '<S428>/Constant Value2'
             *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile3'
             *  Product: '<S428>/Product5'
             *  Product: '<S428>/Product8'
             *  Product: '<S446>/Prod'
             *  Sum: '<S428>/Sum10'
             *  Sum: '<S428>/Sum9'
             */
            rtb_Abs2_mb = fmaxf((fabsf((rtb_IntegerDelay -
                                   VeESSR_n_InputSpeedProfile_DS) -
                                  (HeESSR_t_MedTEB_dT * rtb_Gain_gz)) *
                                 (rtb_Sum2_bi3 * 2.0F)) - (rtb_Abs2_mb *
                                 rtb_Abs2_mb), 0.0F);

            /* Switch: '<S444>/Switch' incorporates:
             *  Sqrt: '<S444>/Sqrt'
             */
            rtb_Abs2_mb = sqrtf(rtb_Abs2_mb);

            /* Switch: '<S442>/Switch1' incorporates:
             *  Abs: '<S428>/Abs2'
             *  Sum: '<S428>/Sum12'
             *  Sum: '<S428>/Sum13'
             */
            rtb_Switch1_khq = (rtb_Gain_gz - rtb_Abs2_mb) - fabsf(rtb_Switch_and
                + rtb_MinMax1_a0);
        }

        /* End of Switch: '<S442>/Switch1' */

        /* Switch: '<S410>/Switch1' incorporates:
         *  Constant: '<S415>/Calib'
         *  Constant: '<S416>/Calib'
         *  DataStoreRead: '<S385>/Data Store Read'
         *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile6'
         *  Logic: '<S410>/Logical1'
         *  Logic: '<S410>/Logical6'
         *  Logic: '<S410>/Logical8'
         */
        if (((HeESSR_b_NiLmtBypsLoopJerk) && (VeESSR_b_NiMaxActive_DS)) ||
                ((VeESSR_b_NiDotMaxActive_DS) && (HeESSR_b_NiDotLmtBypsLoopJerk)))
        {
            /* Switch: '<S410>/Switch1' */
            rtb_MinMax1_a0 = rtb_Switch1_ik2;
        }
        else
        {
            /* Switch: '<S410>/Switch1' incorporates:
             *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile2'
             *  Sum: '<S410>/Sum1'
             */
            rtb_MinMax1_a0 += VeESSR_dn_InputAcceltnProf_DS;
        }

        /* End of Switch: '<S410>/Switch1' */

        /* Outputs for Atomic SubSystem: '<S410>/Limiter2' */
        /* Switch: '<S423>/Switch1' incorporates:
         *  RelationalOperator: '<S423>/Relational Operator'
         */
        if (rtb_Switch1_ik2 < rtb_MinMax1_a0)
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtb_Switch1_ik2;
        }
        else
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtb_MinMax1_a0;
        }

        /* End of Switch: '<S423>/Switch1' */

        /* Switch: '<S423>/Switch' incorporates:
         *  RelationalOperator: '<S423>/Relational Operator1'
         */
        if (rtb_Abs2_mb > rtb_Switch1_khq)
        {
            /* Switch: '<S423>/Switch' */
            rtb_MinMax1_a0 = rtb_Abs2_mb;
        }
        else
        {
            /* Switch: '<S423>/Switch' */
            rtb_MinMax1_a0 = rtb_Switch1_khq;
        }

        /* End of Switch: '<S423>/Switch' */
        /* End of Outputs for SubSystem: '<S410>/Limiter2' */

        /* Outputs for Atomic SubSystem: '<S410>/Limiter4' */
        /* Switch: '<S425>/Switch1' incorporates:
         *  RelationalOperator: '<S425>/Relational Operator'
         */
        if (rtu_NiDotMax < rtb_MinMax1_a0)
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtu_NiDotMax;
        }
        else
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtb_MinMax1_a0;
        }

        /* End of Switch: '<S425>/Switch1' */

        /* Switch: '<S425>/Switch' incorporates:
         *  RelationalOperator: '<S425>/Relational Operator1'
         */
        if (rtb_Abs2_mb > rtu_NiDotMin)
        {
            /* Switch: '<S425>/Switch' */
            rtb_Switch_and = rtb_Abs2_mb;
        }
        else
        {
            /* Switch: '<S425>/Switch' */
            rtb_Switch_and = rtu_NiDotMin;
        }

        /* End of Switch: '<S425>/Switch' */
        /* End of Outputs for SubSystem: '<S410>/Limiter4' */

        /* Sum: '<S414>/Sum6' incorporates:
         *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile3'
         */
        rtb_Sum6_ca = rtu_VeHSER_n_NiMax - VeESSR_n_InputSpeedProfile_DS;

        /* Abs: '<S414>/Abs2' */
        rtb_Abs2_mb = fabsf(rtb_Sum6_ca);

        /* Switch: '<S414>/Switch' incorporates:
         *  Constant: '<S414>/Constant Value7'
         *  RelationalOperator: '<S414>/Comparison2'
         */
        if (rtb_Sum6_ca < 0.0F)
        {
            /* MinMax: '<S413>/MinMax1' incorporates:
             *  Abs: '<S414>/Abs'
             */
            rtb_MinMax1_a0 = fabsf(rtb_Sum2_bi3);
        }
        else
        {
            /* MinMax: '<S413>/MinMax1' incorporates:
             *  Abs: '<S414>/Abs1'
             *  Gain: '<S414>/Gain'
             */
            rtb_MinMax1_a0 = -fabsf(rtb_Product4);
        }

        /* End of Switch: '<S414>/Switch' */

        /* Product: '<S414>/Product4' incorporates:
         *  Constant: '<S396>/Calib'
         */
        rtb_Product4_h = (rtb_MinMax1_a0 * HeESSR_t_MedTEB_dT) *
            HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S414>/Protected Division1' */
        /* Switch: '<S437>/Switch1' incorporates:
         *  Constant: '<S437>/Constant Value'
         *  Constant: '<S437>/Constant Value1'
         *  Constant: '<S437>/Constant Value2'
         *  Logic: '<S437>/AND'
         *  RelationalOperator: '<S437>/Greater Than or Equal '
         *  RelationalOperator: '<S437>/Not Equal'
         *  RelationalOperator: '<S437>/Not Equal1'
         *  Switch: '<S437>/Switch2'
         */
        if ((rtb_Abs2_mb != 0.0F) && (rtb_Product4_h != 0.0F))
        {
            /* Switch: '<S437>/Switch1' incorporates:
             *  Product: '<S437>/Division'
             */
            rtb_Abs2_mb /= rtb_Product4_h;
        }
        else if (rtb_Abs2_mb > 0.0F)
        {
            /* Switch: '<S437>/Switch2' incorporates:
             *  Constant: '<S437>/MAXFLOAT'
             *  Switch: '<S437>/Switch1'
             */
            rtb_Abs2_mb = 3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S437>/Switch1' incorporates:
             *  Constant: '<S437>/Constant Value4'
             *  Switch: '<S437>/Switch2'
             *  Switch: '<S437>/Switch3'
             */
            rtb_Abs2_mb = 0.0F;
        }

        /* End of Switch: '<S437>/Switch1' */
        /* End of Outputs for SubSystem: '<S414>/Protected Division1' */

        /* Sum: '<S414>/Sum4' incorporates:
         *  Abs: '<S414>/Abs3'
         *  Constant: '<S414>/Constant Value3'
         *  Constant: '<S414>/Constant Value5'
         *  Product: '<S414>/Product3'
         */
        rtb_Abs2_mb = (fabsf(rtb_Abs2_mb) * 8.0F) + 1.0F;

        /* Switch: '<S438>/Switch' */
        if (rtb_Abs2_mb >= 0.0F)
        {
            /* Switch: '<S385>/Switch' incorporates:
             *  Sqrt: '<S438>/Sqrt'
             */
            rtb_Abs2_mb = sqrtf(rtb_Abs2_mb);
        }
        else
        {
            /* Switch: '<S385>/Switch' incorporates:
             *  Constant: '<S438>/Zero'
             */
            rtb_Abs2_mb = 0.0F;
        }

        /* End of Switch: '<S438>/Switch' */

        /* Switch: '<S385>/Switch' incorporates:
         *  Constant: '<S414>/Constant Value'
         *  Constant: '<S414>/Constant Value4'
         *  Constant: '<S414>/Constant Value6'
         *  MinMax: '<S414>/MinMax1'
         *  Product: '<S414>/Product2'
         *  Rounding: '<S414>/Rounding1'
         *  Sum: '<S414>/Sum3'
         */
        rtb_Abs2_mb = fmaxf(ceilf((rtb_Abs2_mb - 1.0F) * 0.5F), 1.0F);

        /* Product: '<S414>/Product' incorporates:
         *  Constant: '<S396>/Calib'
         */
        rtb_Product4_h = rtb_Abs2_mb * HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S414>/Protected Division' */
        /* Switch: '<S436>/Switch1' incorporates:
         *  Constant: '<S436>/Constant Value'
         *  Constant: '<S436>/Constant Value1'
         *  Constant: '<S436>/Constant Value2'
         *  Constant: '<S436>/Constant Value3'
         *  Logic: '<S436>/AND'
         *  RelationalOperator: '<S436>/Greater Than or Equal '
         *  RelationalOperator: '<S436>/Greater Than or Equal 1'
         *  RelationalOperator: '<S436>/Not Equal'
         *  RelationalOperator: '<S436>/Not Equal1'
         *  Switch: '<S436>/Switch2'
         *  Switch: '<S436>/Switch3'
         */
        if ((rtb_Sum6_ca != 0.0F) && (rtb_Product4_h != 0.0F))
        {
            /* Switch: '<S436>/Switch1' incorporates:
             *  Product: '<S436>/Division'
             */
            rtb_Sum6_ca /= rtb_Product4_h;
        }
        else if (rtb_Sum6_ca > 0.0F)
        {
            /* Switch: '<S436>/Switch2' incorporates:
             *  Constant: '<S436>/MAXFLOAT'
             *  Switch: '<S436>/Switch1'
             */
            rtb_Sum6_ca = 3.402823466E+38F;
        }
        else if (rtb_Sum6_ca < 0.0F)
        {
            /* Switch: '<S436>/Switch3' incorporates:
             *  Constant: '<S436>/MINFLOAT'
             *  Switch: '<S436>/Switch1'
             *  Switch: '<S436>/Switch2'
             */
            rtb_Sum6_ca = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S436>/Switch1' incorporates:
             *  Constant: '<S436>/Constant Value4'
             *  Switch: '<S436>/Switch2'
             *  Switch: '<S436>/Switch3'
             */
            rtb_Sum6_ca = 0.0F;
        }

        /* End of Switch: '<S436>/Switch1' */
        /* End of Outputs for SubSystem: '<S414>/Protected Division' */

        /* Sum: '<S414>/Sum' incorporates:
         *  Constant: '<S396>/Calib'
         *  Constant: '<S414>/Constant Value1'
         *  Constant: '<S414>/Constant Value2'
         *  Product: '<S414>/Product1'
         *  Sum: '<S414>/Sum2'
         */
        rtb_MinMax1_a0 = rtb_Sum6_ca - (((0.5F * rtb_MinMax1_a0) * (rtb_Abs2_mb
            - 1.0F)) * HeESSR_t_MedTEB_dT);

        /* Switch: '<S410>/Switch4' incorporates:
         *  Constant: '<S417>/Calib'
         */
        if (!HeESSR_b_NiLmtForAccelByps)
        {
            /* Switch: '<S410>/Switch4' incorporates:
             *  MinMax: '<S410>/MinMax1'
             */
            rtb_Switch_and = fminf(rtb_MinMax1_a0, rtb_Switch_and);
        }

        /* End of Switch: '<S410>/Switch4' */

        /* Outputs for Atomic SubSystem: '<S410>/Limiter13' */
        /* RelationalOperator: '<S422>/Relational Operator' */
        rtb_GreaterThan_nw = (rtu_NiDotMax <= rtb_Switch_and);

        /* Switch: '<S422>/Switch1' */
        if (rtb_GreaterThan_nw)
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtu_NiDotMax;
        }
        else
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtb_Switch_and;
        }

        /* End of Switch: '<S422>/Switch1' */

        /* Switch: '<S422>/Switch' incorporates:
         *  RelationalOperator: '<S422>/Relational Operator1'
         */
        if (rtb_Abs2_mb <= rtu_NiDotMin)
        {
            rtb_Abs2_mb = rtu_NiDotMin;
        }

        /* End of Switch: '<S422>/Switch' */
        /* End of Outputs for SubSystem: '<S410>/Limiter13' */

        /* Product: '<S410>/Product9' incorporates:
         *  Constant: '<S396>/Calib'
         */
        rtb_Switch_and = rtb_Abs2_mb * HeESSR_t_MedTEB_dT;

        /* Switch: '<S410>/Switch2' incorporates:
         *  Constant: '<S415>/Calib'
         *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile7'
         *  Logic: '<S410>/Logical3'
         */
        if ((HeESSR_b_NiDotLmtBypsLoopJerk) && (VeESSR_b_NiDotMinActive_DS))
        {
            /* Switch: '<S410>/Switch2' */
            rtb_Gain_cmo = rtb_Switch1_khq;
        }
        else
        {
            /* Switch: '<S410>/Switch2' incorporates:
             *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile2'
             *  Sum: '<S410>/Sum16'
             */
            rtb_Gain_cmo += VeESSR_dn_InputAcceltnProf_DS;
        }

        /* End of Switch: '<S410>/Switch2' */

        /* Outputs for Atomic SubSystem: '<S410>/Limiter' */
        /* Switch: '<S420>/Switch1' incorporates:
         *  RelationalOperator: '<S420>/Relational Operator'
         */
        if (rtb_Switch1_ik2 < rtb_Gain_cmo)
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtb_Switch1_ik2;
        }
        else
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtb_Gain_cmo;
        }

        /* End of Switch: '<S420>/Switch1' */

        /* Switch: '<S420>/Switch' incorporates:
         *  RelationalOperator: '<S420>/Relational Operator1'
         */
        if (rtb_Abs2_mb > rtb_Switch1_khq)
        {
            /* Switch: '<S420>/Switch' */
            rtb_Gain_cmo = rtb_Abs2_mb;
        }
        else
        {
            /* Switch: '<S420>/Switch' */
            rtb_Gain_cmo = rtb_Switch1_khq;
        }

        /* End of Switch: '<S420>/Switch' */
        /* End of Outputs for SubSystem: '<S410>/Limiter' */

        /* Outputs for Atomic SubSystem: '<S410>/Limiter3' */
        /* Switch: '<S424>/Switch1' incorporates:
         *  RelationalOperator: '<S424>/Relational Operator'
         */
        if (rtu_NiDotMax < rtb_Gain_cmo)
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtu_NiDotMax;
        }
        else
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtb_Gain_cmo;
        }

        /* End of Switch: '<S424>/Switch1' */
        /* End of Outputs for SubSystem: '<S410>/Limiter3' */

        /* Switch: '<S410>/Switch5' incorporates:
         *  Constant: '<S417>/Calib'
         *  RelationalOperator: '<S424>/Relational Operator1'
         *  Switch: '<S424>/Switch'
         */
        if (HeESSR_b_NiLmtForAccelByps)
        {
            /* Outputs for Atomic SubSystem: '<S410>/Limiter3' */
            /* Switch: '<S424>/Switch' incorporates:
             *  RelationalOperator: '<S424>/Relational Operator1'
             */
            if (rtb_Abs2_mb > rtu_NiDotMin)
            {
                /* Switch: '<S410>/Switch5' */
                rtb_Gain_cmo = rtb_Abs2_mb;
            }
            else
            {
                /* Switch: '<S410>/Switch5' */
                rtb_Gain_cmo = rtu_NiDotMin;
            }

            /* End of Outputs for SubSystem: '<S410>/Limiter3' */
        }
        else
        {
            /* Outputs for Atomic SubSystem: '<S410>/Limiter3' */
            if (rtb_Abs2_mb <= rtu_NiDotMin)
            {
                /* Switch: '<S424>/Switch' */
                rtb_Abs2_mb = rtu_NiDotMin;
            }

            /* End of Outputs for SubSystem: '<S410>/Limiter3' */

            /* Switch: '<S410>/Switch5' incorporates:
             *  MinMax: '<S410>/MinMax2'
             */
            rtb_Gain_cmo = fminf(rtb_MinMax1_a0, rtb_Abs2_mb);
        }

        /* End of Switch: '<S410>/Switch5' */

        /* Outputs for Atomic SubSystem: '<S410>/Limiter9' */
        /* Switch: '<S427>/Switch1' incorporates:
         *  RelationalOperator: '<S427>/Relational Operator'
         */
        if (rtu_NiDotMax <= rtb_Gain_cmo)
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtu_NiDotMax;
        }
        else
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtb_Gain_cmo;
        }

        /* End of Switch: '<S427>/Switch1' */

        /* RelationalOperator: '<S426>/Relational Operator1' incorporates:
         *  RelationalOperator: '<S427>/Relational Operator1'
         */
        rtb_UnitDelay_ou = (rtb_Abs2_mb > rtu_NiDotMin);

        /* Logic: '<S427>/Logical2' */
        rtb_Logical2_bpk = !rtb_UnitDelay_ou;

        /* Switch: '<S427>/Switch' */
        if (!rtb_UnitDelay_ou)
        {
            rtb_Abs2_mb = rtu_NiDotMin;
        }

        /* End of Switch: '<S427>/Switch' */
        /* End of Outputs for SubSystem: '<S410>/Limiter9' */

        /* Product: '<S410>/Product10' incorporates:
         *  Constant: '<S396>/Calib'
         */
        rtb_Gain_cmo = rtb_Abs2_mb * HeESSR_t_MedTEB_dT;

        /* Sum: '<S410>/Sum2' incorporates:
         *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile3'
         */
        rtb_Switch1_ik2 = rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS;

        /* Sum: '<S413>/Sum6' incorporates:
         *  Constant: '<S396>/Calib'
         *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile3'
         *  Product: '<S413>/Product7'
         *  Sum: '<S410>/Sum6'
         *  Switch: '<S410>/Switch3'
         */
        rtb_IntegerDelay = (rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS) -
            (rtb_Gain_gz * HeESSR_t_MedTEB_dT);

        /* Abs: '<S413>/Abs2' incorporates:
         *  Sum: '<S413>/Sum6'
         */
        rtb_MinMax1_a0 = fabsf(rtb_IntegerDelay);

        /* Switch: '<S413>/Switch' incorporates:
         *  Constant: '<S413>/Constant Value7'
         *  RelationalOperator: '<S413>/Comparison2'
         *  Sum: '<S413>/Sum6'
         */
        if (rtb_IntegerDelay < 0.0F)
        {
            /* Switch: '<S385>/Switch' incorporates:
             *  Abs: '<S413>/Abs'
             */
            rtb_Abs2_mb = fabsf(rtb_Sum2_bi3);
        }
        else
        {
            /* Switch: '<S385>/Switch' incorporates:
             *  Abs: '<S413>/Abs1'
             *  Gain: '<S413>/Gain'
             */
            rtb_Abs2_mb = -fabsf(rtb_Product4);
        }

        /* End of Switch: '<S413>/Switch' */

        /* Product: '<S413>/Product4' incorporates:
         *  Constant: '<S396>/Calib'
         */
        rtb_Product4 = (rtb_Abs2_mb * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S413>/Protected Division1' */
        /* Switch: '<S433>/Switch1' incorporates:
         *  Constant: '<S433>/Constant Value'
         *  Constant: '<S433>/Constant Value1'
         *  Constant: '<S433>/Constant Value2'
         *  Logic: '<S433>/AND'
         *  RelationalOperator: '<S433>/Greater Than or Equal '
         *  RelationalOperator: '<S433>/Not Equal'
         *  RelationalOperator: '<S433>/Not Equal1'
         *  Switch: '<S433>/Switch2'
         */
        if ((rtb_MinMax1_a0 != 0.0F) && (rtb_Product4 != 0.0F))
        {
            /* Switch: '<S433>/Switch1' incorporates:
             *  Product: '<S433>/Division'
             */
            rtb_Product4 = rtb_MinMax1_a0 / rtb_Product4;
        }
        else if (rtb_MinMax1_a0 > 0.0F)
        {
            /* Switch: '<S433>/Switch2' incorporates:
             *  Constant: '<S433>/MAXFLOAT'
             *  Switch: '<S433>/Switch1'
             */
            rtb_Product4 = 3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S433>/Switch1' incorporates:
             *  Constant: '<S433>/Constant Value4'
             *  Switch: '<S433>/Switch2'
             *  Switch: '<S433>/Switch3'
             */
            rtb_Product4 = 0.0F;
        }

        /* End of Switch: '<S433>/Switch1' */
        /* End of Outputs for SubSystem: '<S413>/Protected Division1' */

        /* Sum: '<S413>/Sum4' incorporates:
         *  Abs: '<S413>/Abs3'
         *  Constant: '<S413>/Constant Value3'
         *  Constant: '<S413>/Constant Value5'
         *  Product: '<S413>/Product3'
         */
        rtb_Product4 = (fabsf(rtb_Product4) * 8.0F) + 1.0F;

        /* Switch: '<S434>/Switch' incorporates:
         *  Constant: '<S434>/Zero'
         *  Sqrt: '<S434>/Sqrt'
         */
        if (rtb_Product4 >= 0.0F)
        {
            rtb_Product4 = sqrtf(rtb_Product4);
        }
        else
        {
            rtb_Product4 = 0.0F;
        }

        /* End of Switch: '<S434>/Switch' */

        /* MinMax: '<S413>/MinMax1' incorporates:
         *  Constant: '<S413>/Constant Value'
         *  Constant: '<S413>/Constant Value4'
         *  Constant: '<S413>/Constant Value6'
         *  Product: '<S413>/Product2'
         *  Rounding: '<S413>/Rounding1'
         *  Sum: '<S413>/Sum3'
         */
        rtb_MinMax1_a0 = fmaxf(ceilf((rtb_Product4 - 1.0F) * 0.5F), 1.0F);

        /* Product: '<S413>/Product' incorporates:
         *  Constant: '<S396>/Calib'
         */
        rtb_Product4 = rtb_MinMax1_a0 * HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S413>/Protected Division' */
        /* Switch: '<S432>/Switch1' incorporates:
         *  Constant: '<S432>/Constant Value'
         *  Constant: '<S432>/Constant Value1'
         *  Constant: '<S432>/Constant Value2'
         *  Constant: '<S432>/Constant Value3'
         *  Logic: '<S432>/AND'
         *  RelationalOperator: '<S432>/Greater Than or Equal '
         *  RelationalOperator: '<S432>/Greater Than or Equal 1'
         *  RelationalOperator: '<S432>/Not Equal'
         *  RelationalOperator: '<S432>/Not Equal1'
         *  Sum: '<S413>/Sum6'
         *  Switch: '<S432>/Switch2'
         *  Switch: '<S432>/Switch3'
         */
        if ((rtb_IntegerDelay != 0.0F) && (rtb_Product4 != 0.0F))
        {
            /* Switch: '<S432>/Switch1' incorporates:
             *  Product: '<S432>/Division'
             */
            rtb_Product4 = rtb_IntegerDelay / rtb_Product4;
        }
        else if (rtb_IntegerDelay > 0.0F)
        {
            /* Switch: '<S432>/Switch2' incorporates:
             *  Constant: '<S432>/MAXFLOAT'
             *  Switch: '<S432>/Switch1'
             */
            rtb_Product4 = 3.402823466E+38F;
        }
        else if (rtb_IntegerDelay < 0.0F)
        {
            /* Switch: '<S432>/Switch3' incorporates:
             *  Constant: '<S432>/MINFLOAT'
             *  Switch: '<S432>/Switch1'
             *  Switch: '<S432>/Switch2'
             */
            rtb_Product4 = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S432>/Switch1' incorporates:
             *  Constant: '<S432>/Constant Value4'
             *  Switch: '<S432>/Switch2'
             *  Switch: '<S432>/Switch3'
             */
            rtb_Product4 = 0.0F;
        }

        /* End of Switch: '<S432>/Switch1' */
        /* End of Outputs for SubSystem: '<S413>/Protected Division' */

        /* Switch: '<S410>/Switch3' incorporates:
         *  Constant: '<S418>/Calib'
         */
        if (!HeESSR_b_TrnstnJerkByps)
        {
            /* Switch: '<S410>/Switch8' incorporates:
             *  Constant: '<S410>/Constant Value7'
             *  RelationalOperator: '<S410>/Comparison'
             */
            if (rtb_IntegerDelay > 0.0F)
            {
                /* Switch: '<S410>/Switch3' incorporates:
                 *  Constant: '<S396>/Calib'
                 *  Constant: '<S413>/Constant Value1'
                 *  Constant: '<S413>/Constant Value2'
                 *  MinMax: '<S410>/MinMax4'
                 *  Product: '<S410>/Product5'
                 *  Product: '<S413>/Product1'
                 *  Sum: '<S413>/Sum'
                 *  Sum: '<S413>/Sum2'
                 *  Switch: '<S410>/Switch8'
                 */
                rtb_Switch1_ik2 = fminf(rtb_Switch1_ik2, ((rtb_Product4 +
                    rtb_Gain_gz) - (((0.5F * rtb_Abs2_mb) * (rtb_MinMax1_a0 -
                    1.0F)) * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
            }
            else
            {
                /* Switch: '<S410>/Switch3' incorporates:
                 *  Constant: '<S396>/Calib'
                 *  Constant: '<S413>/Constant Value1'
                 *  Constant: '<S413>/Constant Value2'
                 *  MinMax: '<S410>/MinMax5'
                 *  Product: '<S410>/Product2'
                 *  Product: '<S413>/Product1'
                 *  Sum: '<S413>/Sum'
                 *  Sum: '<S413>/Sum2'
                 *  Switch: '<S410>/Switch8'
                 */
                rtb_Switch1_ik2 = fmaxf(rtb_Switch1_ik2, ((rtb_Product4 +
                    rtb_Gain_gz) - (((0.5F * rtb_Abs2_mb) * (rtb_MinMax1_a0 -
                    1.0F)) * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
            }

            /* End of Switch: '<S410>/Switch8' */
        }

        /* Outputs for Atomic SubSystem: '<S410>/Limiter6' */
        /* RelationalOperator: '<S426>/Relational Operator' */
        rtb_RelationalOperator_j4 = (rtb_Switch_and <= rtb_Switch1_ik2);

        /* Switch: '<S426>/Switch1' */
        if (rtb_RelationalOperator_j4)
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtb_Switch_and;
        }
        else
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtb_Switch1_ik2;
        }

        /* End of Switch: '<S426>/Switch1' */

        /* RelationalOperator: '<S426>/Relational Operator1' */
        rtb_UnitDelay_ou = (rtb_Abs2_mb > rtb_Gain_cmo);

        /* Switch: '<S426>/Switch' */
        if (rtb_UnitDelay_ou)
        {
            rtb_Gain_cmo = rtb_Abs2_mb;
        }

        /* End of Switch: '<S426>/Switch' */
        /* End of Outputs for SubSystem: '<S410>/Limiter6' */

        /* Sum: '<S410>/Sum4' incorporates:
         *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile3'
         */
        rtb_IntegerDelay = rtb_Gain_cmo + VeESSR_n_InputSpeedProfile_DS;

        /* Outputs for Atomic SubSystem: '<S410>/Limiter1' */
        /* RelationalOperator: '<S421>/Relational Operator' incorporates:
         *  DataStoreWrite: '<S385>/Dsw_InputSpeedProfile6'
         */
        VeESSR_b_NiMaxActive_DS = (rtu_VeHSER_n_NiMax <= rtb_IntegerDelay);

        /* Switch: '<S421>/Switch1' incorporates:
         *  DataStoreWrite: '<S385>/Dsw_InputSpeedProfile6'
         */
        if (VeESSR_b_NiMaxActive_DS)
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtu_VeHSER_n_NiMax;
        }
        else
        {
            /* Switch: '<S385>/Switch' */
            rtb_Abs2_mb = rtb_IntegerDelay;
        }

        /* End of Switch: '<S421>/Switch1' */

        /* Switch: '<S421>/Switch' incorporates:
         *  Constant: '<S410>/Constant Value4'
         *  RelationalOperator: '<S421>/Relational Operator1'
         */
        if (rtb_Abs2_mb > 0.0F)
        {
            /* Switch: '<S421>/Switch' */
            rtb_IntegerDelay = rtb_Abs2_mb;
        }
        else
        {
            /* Switch: '<S421>/Switch' */
            rtb_IntegerDelay = 0.0F;
        }

        /* End of Switch: '<S421>/Switch' */
        /* End of Outputs for SubSystem: '<S410>/Limiter1' */

        /* Product: '<S410>/Product3' incorporates:
         *  Constant: '<S396>/Calib'
         *  DataStoreRead: '<S385>/Dsr_InputSpeedProfile3'
         *  DataStoreWrite: '<S385>/Dsw_InputAcceltnProf1'
         *  Sum: '<S410>/Sum'
         */
        VeESSR_dn_InputAcceltnProf_DS = (rtb_IntegerDelay -
            VeESSR_n_InputSpeedProfile_DS) / HeESSR_t_MedTEB_dT;

        /* DataStoreWrite: '<S385>/Dsw_InputSpeedProfile1' */
        VeESSR_n_InputSpeedProfile_DS = rtb_IntegerDelay;

        /* DataStoreWrite: '<S385>/Dsw_InputSpeedProfile2' */
        VeESSR_n_TargetSpeed_DS = rtb_Gain1_e;

        /* DataStoreWrite: '<S385>/Dsw_InputSpeedProfile3' */
        VeESSR_dn_TargetAcceltn_DS = rtb_Gain_gz;

        /* Logic: '<S410>/Logical2' incorporates:
         *  DataStoreWrite: '<S385>/Dsw_InputSpeedProfile4'
         */
        VeESSR_b_NiDotMaxActive_DS = (rtb_GreaterThan_nw &&
            rtb_RelationalOperator_j4);

        /* Outputs for Atomic SubSystem: '<S410>/Limiter6' */
        /* Logic: '<S410>/Logical' incorporates:
         *  DataStoreWrite: '<S385>/Dsw_InputSpeedProfile5'
         *  Logic: '<S426>/Logical2'
         */
        VeESSR_b_NiDotMinActive_DS = (rtb_Logical2_bpk && (!rtb_UnitDelay_ou));

        /* End of Outputs for SubSystem: '<S410>/Limiter6' */

        /* Switch: '<S385>/Switch' incorporates:
         *  Constant: '<S385>/Constant Value1'
         *  Constant: '<S398>/Calib'
         *  Lookup_n-D: '<S405>/Vector'
         *  MinMax: '<S385>/MinMax1'
         *  Sum: '<S385>/Summation2'
         */
        if (KeESSR_b_UseZeroTiEstImmedStp)
        {
            rtb_Gain_cmo = 0.0F;
        }
        else
        {
            rtb_Gain_cmo = fmaxf(rtu_EngTrqActual - rtu_SpinDownDragCorr,
                                 look1_iflf_binlcapw(rtu_Ni, ((const float32 *)
                                   &(KxESSR_M_NiBsdTiEstImmedStp[0])), ((const
                                    float32 *)&(KtESSR_M_NiBsdTiEstImmedStp[0])),
                                  6U));
        }

        /* End of Switch: '<S385>/Switch' */

        /* DataStoreWrite: '<S385>/Dsw_InputTorqEst1' incorporates:
         *  Constant: '<S397>/Calib'
         *  DataStoreRead: '<S385>/Dsr_InputTorqEst1'
         *  Product: '<S394>/Multiplication'
         *  Sum: '<S394>/Subtraction'
         *  Sum: '<S394>/Subtraction1'
         */
        VeESSR_M_EngTorqEst_DS = ((rtb_Gain_cmo - VeESSR_M_EngTorqEst_DS) *
            KeESSR_K_TiEstBlndImdStp) + VeESSR_M_EngTorqEst_DS;

        /* DataStoreWrite: '<S385>/Dsw_EngStrtStpMd2' incorporates:
         *  Constant: '<S395>/Constant'
         */
        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_ImmediateStop;

        /* Sum: '<S410>/Sum17' incorporates:
         *  DataStoreWrite: '<S385>/Dsw_InputAcceltnProf1'
         */
        VeESSR_dn_InputJerkProfImmedStop = VeESSR_dn_InputAcceltnProf_DS -
            rtb_Sum15;

        /* Switch: '<S407>/Switch3' */
        if (rtb_AND_o4)
        {
            /* Update for UnitDelay: '<S407>/Unit Delay' */
            localDW->UnitDelay_DSTATE = rtb_Summation1_c1;
        }
        else
        {
            /* Update for UnitDelay: '<S407>/Unit Delay' */
            localDW->UnitDelay_DSTATE = rtb_Switch1_bg;
        }

        /* End of Switch: '<S407>/Switch3' */

        /* Update for UnitDelay: '<S429>/Unit Delay' incorporates:
         *  Switch: '<S429>/Switch3'
         */
        localDW->UnitDelay_DSTATE_h = rtb_Summation_k;

        /* Update for Delay: '<S410>/IntegerDelay' */
        localDW->icLoad = 0U;
        for (i = 0; i < 15; i++)
        {
            localDW->IntegerDelay_DSTATE[i] = localDW->IntegerDelay_DSTATE[i + 1];
        }

        localDW->IntegerDelay_DSTATE[15] = rtb_Gain1_e;

        /* End of Update for Delay: '<S410>/IntegerDelay' */
        /* End of Outputs for SubSystem: '<S367>/Ramp' */
    }

    /* End of If: '<S367>/If' */
}

#endif

/* Output and update for function-call system: '<S171>/ESSC_CoastDownEnt' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_CoastDownEnt(VAR(boolean,
    AUTOMATIC) rtu_VeESSR_b_EngOnReq)
{
    /* DataStoreWrite: '<S179>/Dsw_MainSTMTmr' incorporates:
     *  Constant: '<S179>/Constant Value1'
     */
    VeESSR_t_MainSTMTmr_DS = 0.0F;

    /* DataStoreWrite: '<S179>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
     *  Constant: '<S179>/Constant Value2'
     */
    VeESSR_M_MtrA_MaxTorq_DS = 0.0F;

    /* Switch: '<S179>/Switch3' incorporates:
     *  Constant: '<S179>/Constant Value3'
     *  Constant: '<S219>/Calib'
     *  DataStoreWrite: '<S179>/Data Store Write5'
     */
    if (!HeESSR_b_EngStrtTorq)
    {
        VeESSR_M_EngStrtTorq_DS = 0.0F;
    }

    /* End of Switch: '<S179>/Switch3' */

    /* DataStoreWrite: '<S179>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
     *  Constant: '<S179>/Constant Value4'
     */
    VeESSR_M_MtrA_MinTorq_DS = 0.0F;

    /* DataStoreWrite: '<S179>/Data Store Write1' incorporates:
     *  Constant: '<S215>/Constant'
     */
    VeESSR_e_EngStrtActuatorTyp = CeESSR_e_NoActTyp;

    /* Switch: '<S179>/Switch' incorporates:
     *  Constant: '<S220>/Calib'
     *  Constant: '<S221>/Calib'
     *  Constant: '<S222>/Calib'
     *  DataStoreRead: '<S179>/Dsr_StrtTypInitImmedTorq'
     *  DataStoreRead: '<S179>/Dsr_StrtTypInitPredTorq'
     *  DataStoreWrite: '<S179>/Data Store Write2'
     *  DataStoreWrite: '<S179>/Data Store Write3'
     *  Switch: '<S179>/Switch1'
     */
    if (KeESSR_b_UseCalEngTrqsCD)
    {
        VeESSR_M_EngTrqReqPrdtd_DS = KeESSR_M_AStopPrdtdTrqTgtCD;
        VeESSR_M_EngTrqReqImmed_DS = KeESSR_M_AStopImmedTrqTgtCD;
    }
    else
    {
        VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;
        VeESSR_M_EngTrqReqImmed_DS = VeESSR_M_StrtTypInitImmedTorq_DS;
    }

    /* End of Switch: '<S179>/Switch' */

    /* DataStoreWrite: '<S179>/Dsw_EngStrtType1' incorporates:
     *  Constant: '<S223>/Calib'
     */
    VeESSR_e_TCM_StartStopType_DS = KeESSR_e_TCM_StartStopType_CoastDown;

    /* DataStoreWrite: '<S179>/Dsw_InputSpeedProfile1' incorporates:
     *  Constant: '<S224>/Calib'
     */
    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

    /* DataStoreWrite: '<S179>/Dsw_InputTorqOverride' incorporates:
     *  Constant: '<S179>/TRUE Constant'
     */
    VeESSR_b_InputTorqOverride_DS = true;

    /* If: '<S179>/If1' incorporates:
     *  Constant: '<S213>/Constant'
     *  Constant: '<S214>/Constant'
     *  Constant: '<S216>/Constant'
     *  Constant: '<S217>/Constant'
     *  Constant: '<S218>/Constant'
     *  DataStoreRead: '<S179>/Data Store Read1'
     *  DataStoreRead: '<S179>/Data Store Read2'
     *  DataStoreRead: '<S179>/Data Store Read3'
     *  Logic: '<S179>/AND'
     *  Logic: '<S179>/AND1'
     *  RelationalOperator: '<S179>/Comparison1'
     *  RelationalOperator: '<S179>/Comparison2'
     *  RelationalOperator: '<S179>/Comparison3'
     *  RelationalOperator: '<S179>/Comparison4'
     *  RelationalOperator: '<S179>/Comparison5'
     */
    if ((((rtu_VeESSR_b_EngOnReq && (((uint32)VeESSR_e_EngStrtStpMd_DS) ==
            CeESSR_e_DisableFuel)) || (VeESSR_b_ETSDsblFuelReq_DS)) || (((uint32)
            VeESSR_e_EngStartStopSt_DS) == CeESSR_e_SpinUp12vStrtSt)) ||
            (((uint32)VeESSR_e_EngStrtStpMd_DS) == CeESSR_e_EnableFuel))
    {
        /* Outputs for IfAction SubSystem: '<S179>/DisableFuel' incorporates:
         *  ActionPort: '<S209>/Action Port'
         */
        /* DataStoreWrite: '<S209>/Data Store Write' incorporates:
         *  Constant: '<S209>/FALSE Constant'
         */
        VeESSR_b_ETSDsblFuelReq_DS = false;

        /* DataStoreWrite: '<S209>/Data Store Write1' incorporates:
         *  Constant: '<S228>/Constant'
         */
        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_DisableFuel;

        /* DataStoreWrite: '<S209>/Data Store Write2' incorporates:
         *  Constant: '<S227>/Constant'
         */
        VeESSR_e_EngStartStopSt_DS = CeESSR_e_CoastDownSt;

        /* End of Outputs for SubSystem: '<S179>/DisableFuel' */
    }
    else if (((uint32)VeESSR_e_EngStrtStpMd_DS) == CeESSR_e_ProducingTorque)
    {
        /* Outputs for IfAction SubSystem: '<S179>/EngineStall' incorporates:
         *  ActionPort: '<S212>/Action Port'
         */
        /* DataStoreWrite: '<S212>/Data Store Write1' incorporates:
         *  Constant: '<S232>/Calib'
         */
        VeESSR_e_EngStrtStpMd_DS = KeESSR_e_MdInCoastDownStPT;

        /* DataStoreWrite: '<S212>/Data Store Write2' incorporates:
         *  Constant: '<S231>/Constant'
         */
        VeESSR_e_EngStartStopSt_DS = CeESSR_e_CoastDownSt;

        /* End of Outputs for SubSystem: '<S179>/EngineStall' */
    }
    else if (((uint32)VeESSR_e_EngStrtStpMd_DS) == CeESSR_e_EngineTorqueStart)
    {
        /* Outputs for IfAction SubSystem: '<S179>/ETS' incorporates:
         *  ActionPort: '<S211>/Action Port'
         */
        /* DataStoreWrite: '<S211>/Data Store Write1' incorporates:
         *  Constant: '<S230>/Constant'
         */
        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_EngineTorqueStart;

        /* DataStoreWrite: '<S211>/Data Store Write2' incorporates:
         *  Constant: '<S229>/Constant'
         */
        VeESSR_e_EngStartStopSt_DS = CeESSR_e_CoastDownSt;

        /* End of Outputs for SubSystem: '<S179>/ETS' */
    }
    else if (rtu_VeESSR_b_EngOnReq)
    {
        /* Outputs for IfAction SubSystem: '<S179>/StartPending' incorporates:
         *  ActionPort: '<S225>/Action Port'
         */
        /* DataStoreWrite: '<S225>/Data Store Write1' incorporates:
         *  Constant: '<S234>/Constant'
         */
        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_StartPending;

        /* DataStoreWrite: '<S225>/Data Store Write2' incorporates:
         *  Constant: '<S233>/Constant'
         */
        VeESSR_e_EngStartStopSt_DS = CeESSR_e_CoastDownSt;

        /* End of Outputs for SubSystem: '<S179>/StartPending' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S179>/Stopped' incorporates:
         *  ActionPort: '<S226>/Action Port'
         */
        /* DataStoreWrite: '<S226>/Data Store Write1' incorporates:
         *  Constant: '<S236>/Constant'
         */
        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_Stop;

        /* DataStoreWrite: '<S226>/Data Store Write2' incorporates:
         *  Constant: '<S235>/Constant'
         */
        VeESSR_e_EngStartStopSt_DS = CeESSR_e_CoastDownSt;

        /* End of Outputs for SubSystem: '<S179>/Stopped' */
    }

    /* End of If: '<S179>/If1' */
}

#endif

/* Output and update for function-call system: '<S171>/ESSC_CoastDownDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_CoastDownDur(VAR(float32,
    AUTOMATIC) rtu_TransInSpdFlt, VAR(TeSTRR_e_EngStrtStopType, AUTOMATIC)
    rtu_VeSTRR_e_EngStrtStopType, VAR(boolean, AUTOMATIC) rtu_VeESSR_b_EngOnReq,
    VAR(boolean, AUTOMATIC) rtu_P20Trq, VAR(uint32, AUTOMATIC) rtu_AStpInhbtRsn2,
    VAR(boolean, AUTOMATIC) rtu_BmpStrtEngOn, VAR(boolean, AUTOMATIC)
    rtu_VeSTRR_b_BumpStrtInhbt, VAR(TeTRNR_e_TCMGearStat, AUTOMATIC)
    rtu_VeTRNR_e_ActualGear, VAR(TeHCCR_e_ClutchStatus, AUTOMATIC)
    rtu_VeTRNR_e_ILEStat)
{
    float32 rtb_Comparison7_k;
    boolean rtb_Comparison7_lm;
    boolean rtb_Comparison_b4;
    boolean rtb_NOT_fc;

    /* Selector: '<S178>/Selector4' incorporates:
     *  Constant: '<S199>/Calib'
     *  DataStoreWrite: '<S178>/Data Store Write4'
     *  DataTypeConversion: '<S178>/Data Type Conversion1'
     */
    VeESSR_e_EngStrtType_DS = KaESSR_e_EngStrtTypeMap
        [(rtu_VeSTRR_e_EngStrtStopType)];

    /* DataStoreWrite: '<S178>/Dsw_InputSpeedProfile' */
    VeESSR_n_InputSpeedProfile_DS = rtu_TransInSpdFlt;

    /* Logic: '<S178>/NOT' */
    rtb_NOT_fc = !rtu_VeESSR_b_EngOnReq;

    /* Logic: '<S178>/Logical5' incorporates:
     *  Constant: '<S192>/Constant'
     *  Constant: '<S193>/Constant'
     *  Constant: '<S194>/Constant'
     *  Constant: '<S196>/Calib'
     *  DataStoreRead: '<S178>/Data Store Read4'
     *  DataStoreRead: '<S178>/Dsr_EngTrqRespType3'
     *  Logic: '<S178>/Logical3'
     *  Logic: '<S178>/Logical4'
     *  RelationalOperator: '<S178>/Comparison8'
     *  RelationalOperator: '<S178>/Comparison9'
     *  RelationalOperator: '<S178>/Greater  Than3'
     */
    VeESSR_b_EngReStrtInDrvOK = ((HeESSR_b_P2Equipped) &&
        ((((VeESSR_b_DsblNc1ClsdLoopCntrl_DS) && (((uint32)rtu_VeTRNR_e_ILEStat)
        == CeHCCR_e_ClReleased)) || (CeHSER_e_UseM1Eqn == ((uint32)
        VeESSR_e_EngStallRngEqn_DS))) || (((uint32)VeESSR_e_EngStallRngEqn_DS) ==
        CeHSER_e_UseNeutralEqn)));

    /* RelationalOperator: '<S178>/Comparison7' incorporates:
     *  Constant: '<S189>/Constant'
     *  DataStoreRead: '<S178>/Data Store Read2'
     */
    rtb_Comparison7_lm = (((uint32)VeESSR_e_EngStartStopStPrev_DS) ==
                          CeESSR_e_EngRunning);

    /* Switch: '<S178>/Switch' */
    if (rtb_Comparison7_lm)
    {
        /* Switch: '<S178>/Switch' incorporates:
         *  Constant: '<S190>/Constant'
         *  Constant: '<S191>/Constant'
         *  Constant: '<S195>/Calib'
         *  Constant: '<S202>/Calib'
         *  Logic: '<S178>/Logical'
         *  Logic: '<S178>/Logical1'
         *  RelationalOperator: '<S178>/Comparison3'
         *  RelationalOperator: '<S178>/Greater  Than1'
         *  RelationalOperator: '<S178>/Greater  Than2'
         */
        VeESSR_b_CoastDwnStopMet = (((((VeESSR_b_EngReStrtInDrvOK) ||
            (CeTRNR_e_Park == ((uint32)rtu_VeTRNR_e_ActualGear))) || (((uint32)
            rtu_VeTRNR_e_ActualGear) == CeTRNR_e_Neutral)) ||
            (HeESSR_b_BypassNChkEngStall)) && (rtu_TransInSpdFlt <=
            KeESSR_n_FinishStpCmpltSpd));
    }
    else
    {
        /* Switch: '<S178>/Switch' incorporates:
         *  Constant: '<S202>/Calib'
         *  RelationalOperator: '<S178>/Comparison3'
         */
        VeESSR_b_CoastDwnStopMet = (rtu_TransInSpdFlt <=
            KeESSR_n_FinishStpCmpltSpd);
    }

    /* End of Switch: '<S178>/Switch' */

    /* RelationalOperator: '<S178>/Comparison' incorporates:
     *  Constant: '<S208>/Calib'
     *  DataStoreRead: '<S178>/Dsr_STMTmr2'
     */
    rtb_Comparison_b4 = (VeESSR_t_MainSTMTmr_DS > KeESSR_t_MaxStTmCoastDown);

    /* Switch: '<S198>/Switch1' incorporates:
     *  Constant: '<S182>/Constant'
     *  Constant: '<S183>/Constant'
     *  DataStoreWrite: '<S178>/Dsw_STMTrigger'
     *  Logic: '<S178>/AND'
     *  RelationalOperator: '<S178>/Equal'
     *  Switch: '<S178>/Switch2'
     */
    if ((((uint32)rtu_VeSTRR_e_EngStrtStopType) == CeSTRR_e_StopImmed) &&
            rtb_NOT_fc)
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_ImmedStopReq;
    }
    else
    {
        if (rtb_Comparison7_lm)
        {
            /* Switch: '<S178>/Switch2' incorporates:
             *  Constant: '<S206>/Calib'
             */
            rtb_Comparison7_k = KeESSR_t_Exit2StpEngStalCoastDwn;
        }
        else
        {
            /* Switch: '<S178>/Switch2' incorporates:
             *  Constant: '<S205>/Calib'
             */
            rtb_Comparison7_k = KeESSR_t_Exit2StpCoastDownTm;
        }

        /* Switch: '<S198>/Switch2' incorporates:
         *  Constant: '<S201>/Calib'
         *  Constant: '<S207>/Calib'
         *  DataStoreRead: '<S178>/Dsr_STMTmr1'
         *  DataStoreRead: '<S178>/Dsr_STMTmr3'
         *  Logic: '<S178>/AND1'
         *  Logic: '<S178>/Logical2'
         *  Logic: '<S178>/NOT1'
         *  RelationalOperator: '<S178>/Comparison1'
         *  RelationalOperator: '<S178>/Comparison2'
         *  RelationalOperator: '<S178>/Comparison4'
         *  Switch: '<S198>/Switch3'
         *  Switch: '<S198>/Switch4'
         */
        if ((rtb_NOT_fc && (VeESSR_b_CoastDwnStopMet)) &&
                (VeESSR_t_MainSTMTmr_DS >= rtb_Comparison7_k))
        {
            /* Switch: '<S198>/Switch1' incorporates:
             *  Constant: '<S184>/Constant'
             *  DataStoreWrite: '<S178>/Dsw_STMTrigger'
             *  Switch: '<S198>/Switch2'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_EngStop;
        }
        else if (((rtu_VeESSR_b_EngOnReq && (rtu_TransInSpdFlt <
                    KeESSR_n_12vStrtrEngageSpd)) && (VeESSR_t_MainSTMTmr_DS >=
                   KeESSR_t_Exit2StrtCoastDownTm)) &&
                 (!rtu_VeSTRR_b_BumpStrtInhbt))
        {
            /* Switch: '<S198>/Switch1' incorporates:
             *  Constant: '<S187>/Constant'
             *  DataStoreWrite: '<S178>/Dsw_STMTrigger'
             *  Switch: '<S198>/Switch2'
             *  Switch: '<S198>/Switch3'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_StartReq;
        }
        else
        {
            if (rtb_Comparison_b4)
            {
                /* Switch: '<S198>/Switch1' incorporates:
                 *  Constant: '<S188>/Constant'
                 *  DataStoreWrite: '<S178>/Dsw_STMTrigger'
                 *  Switch: '<S198>/Switch2'
                 *  Switch: '<S198>/Switch3'
                 *  Switch: '<S198>/Switch4'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;
            }
        }

        /* End of Switch: '<S198>/Switch2' */
    }

    /* End of Switch: '<S198>/Switch1' */

    /* Switch: '<S178>/Switch4' incorporates:
     *  Constant: '<S178>/Constant Value6'
     *  DataStoreRead: '<S178>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S178>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S178>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S178>/Logical21'
     *  RelationalOperator: '<S178>/Comparison5'
     *  S-Function (sfix_bitop): '<S178>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S181>/FixPt Bitwise Operator1'
     */
    if (rtb_Comparison_b4 && ((VeESSR_g_StrtStpFailPhaseSelect_DS & 2097152U) >
                              0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 2097152U;
    }

    /* End of Switch: '<S178>/Switch4' */

    /* Switch: '<S178>/Switch1' incorporates:
     *  Constant: '<S178>/Constant'
     *  Constant: '<S178>/Constant1'
     *  Constant: '<S200>/Calib'
     *  DataStoreRead: '<S178>/Data Store Read'
     *  DataStoreWrite: '<S178>/Data Store Write1'
     *  Logic: '<S178>/AND2'
     *  Logic: '<S178>/AND3'
     *  Logic: '<S178>/AND4'
     *  Logic: '<S178>/AND5'
     *  RelationalOperator: '<S178>/Comparison6'
     *  S-Function (sfix_bitop): '<S178>/Bitwise Logical Operator'
     */
    if (!VeESSR_b_BumpStrtFailed_DS)
    {
        VeESSR_b_BumpStrtFailed_DS = (((rtu_BmpStrtEngOn && ((rtu_AStpInhbtRsn2
            & 8192U) <= 0U)) && rtu_P20Trq) && (KeESSR_b_P2_0TrqActv));
    }

    /* End of Switch: '<S178>/Switch1' */

    /* DataStoreWrite: '<S178>/Dsw_InputTorqEst' incorporates:
     *  Constant: '<S178>/Constant Value'
     */
    VeESSR_M_EngTorqEst_DS = 0.0F;

    /* DataStoreWrite: '<S178>/Dsw_InputAcceltnProf' incorporates:
     *  Constant: '<S178>/Constant Value1'
     */
    VeESSR_dn_InputAcceltnProf_DS = 0.0F;

    /* DataStoreWrite: '<S178>/Dsw_SpdCtlGainMod1' incorporates:
     *  Constant: '<S178>/Constant Value2'
     */
    VeESSR_scl_SpdCtlGainMod_DS = 0.0F;

    /* DataStoreWrite: '<S178>/Dsw_STMTmr' incorporates:
     *  Constant: '<S197>/Calib'
     *  DataStoreRead: '<S178>/Dsr_STMTmr'
     *  Sum: '<S178>/Summation'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* DataStoreWrite: '<S178>/Dsw_STMTmr1' incorporates:
     *  Constant: '<S197>/Calib'
     *  DataStoreRead: '<S178>/Dsr_STMTmr4'
     *  Sum: '<S178>/Summation2'
     */
    VeESSR_t_MainSTMTmr_DS = VeESSR_t_MainSTMTmr_DS + HeESSR_t_MedTEB_dT;

    /* DataStoreWrite: '<S178>/Dsw_AEMDMtrAGain' incorporates:
     *  Constant: '<S203>/Calib'
     */
    VeESSR_scl_AEMDMtrAGain_DS = KeESSR_scl_AEMDMtrAGain_CoastDown;

    /* DataStoreWrite: '<S178>/Dsw_AEMDMtrBGain' incorporates:
     *  Constant: '<S204>/Calib'
     */
    VeESSR_scl_AEMDMtrBGain_DS = KeESSR_scl_AEMDMtrBGain_CoastDown;
}

#endif

/* Output and update for function-call system: '<S171>/ESSC_CoastDownExit' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_CoastDownExit(VAR(boolean,
    AUTOMATIC) rtu_VeESSR_b_EngOnReq, VAR(boolean, AUTOMATIC) rtu_PSAActv)
{
    sint32 tmp;

    /* If: '<S180>/If1' incorporates:
     *  Constant: '<S240>/Calib'
     *  Constant: '<S241>/Calib'
     *  Logic: '<S180>/AND'
     *  Logic: '<S180>/AND1'
     */
    if ((rtu_VeESSR_b_EngOnReq && (KeESSR_b_EnblFtrBackupStrt)) && rtu_PSAActv)
    {
        /* Outputs for IfAction SubSystem: '<S180>/BackupStart' incorporates:
         *  ActionPort: '<S237>/Action Port'
         */
        /* Sum: '<S237>/Summation1' incorporates:
         *  Constant: '<S237>/Constant Value1'
         *  DataStoreRead: '<S237>/Data Store Read1'
         */
        tmp = (sint32)((uint32)(((uint32)VeESSR_Cnt_BackupStrtAttmptCntr_DS) +
                                1U));
        if ((((uint32)VeESSR_Cnt_BackupStrtAttmptCntr_DS) + 1U) > 255U)
        {
            tmp = 255;
        }

        /* DataStoreWrite: '<S237>/Data Store Write' incorporates:
         *  Sum: '<S237>/Summation1'
         */
        VeESSR_Cnt_BackupStrtAttmptCntr_DS = (uint8)tmp;

        /* End of Outputs for SubSystem: '<S180>/BackupStart' */
    }
    else
    {
        if ((rtu_PSAActv && rtu_VeESSR_b_EngOnReq) && (KeESSR_b_EnblFtrBumpStrt))
        {
            /* Outputs for IfAction SubSystem: '<S180>/BumpStart' incorporates:
             *  ActionPort: '<S238>/Action Port'
             */
            /* Sum: '<S238>/Summation2' incorporates:
             *  Constant: '<S238>/Constant Value2'
             *  DataStoreRead: '<S238>/Data Store Read2'
             */
            tmp = (sint32)((uint32)(((uint32)VeESSR_Cnt_BumpStrtAttmptCntr_DS) +
                                    1U));
            if ((((uint32)VeESSR_Cnt_BumpStrtAttmptCntr_DS) + 1U) > 255U)
            {
                tmp = 255;
            }

            /* DataStoreWrite: '<S238>/Data Store Write1' incorporates:
             *  Sum: '<S238>/Summation2'
             */
            VeESSR_Cnt_BumpStrtAttmptCntr_DS = (uint8)tmp;

            /* End of Outputs for SubSystem: '<S180>/BumpStart' */
        }
    }

    /* End of If: '<S180>/If1' */
}

#endif

/* System initialize for function-call system: '<S561>/RestartPrepDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_RestartPrepDur_Init(P2VAR
    (DW_RestartPrepDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW)
{
    /* InitializeConditions for Delay: '<S1192>/IntegerDelay' */
    localDW->icLoad = 1U;
}

#endif

/* Output and update for function-call system: '<S561>/RestartPrepDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_RestartPrepDur(VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_OptInputSpd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_AddtlDragTorq, VAR(float32, AUTOMATIC) rtu_VeHSER_n_NiMax, VAR
    (float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMax, VAR(float32, AUTOMATIC)
    rtu_VeHSER_dn_NiDotMin, VAR(float32, AUTOMATIC) rtu_HTDR_TiMin, P2VAR
    (DW_RestartPrepDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR
    (ZCE_RestartPrepDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localZCE)
{
    sint32 i;
    float32 rtb_Abs2_kp;
    float32 rtb_Gain1_ez;
    float32 rtb_Gain_aq;
    float32 rtb_Gain_bl;
    float32 rtb_IntegerDelay;
    float32 rtb_MinMax1_fx;
    float32 rtb_Product4;
    float32 rtb_Product4_h;
    float32 rtb_Sum15;
    float32 rtb_Sum2_jri;
    float32 rtb_Sum6_aee;
    float32 rtb_Summation_fg;
    float32 rtb_Summation_k;
    float32 rtb_Switch1_by;
    float32 rtb_Switch1_dyk;
    float32 rtb_Switch_jis;
    uint8 tmp;
    boolean rtb_Comparison_hy;
    boolean rtb_Logical2_hy;
    boolean rtb_RelationalOperator1_hg;
    boolean rtb_RelationalOperator_o;

    /* Gain: '<S1189>/Gain' incorporates:
     *  Abs: '<S1189>/Abs1'
     *  DataStoreRead: '<S1173>/Dsr_NiProfGenDNiDLim1'
     */
    rtb_Gain_bl = -fabsf(VeESSR_dn_StrtTypJerkMin_DS);

    /* Product: '<S1192>/Product4' incorporates:
     *  Constant: '<S1180>/Calib'
     */
    rtb_Product4 = rtb_Gain_bl / HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1189>/LowpassT Reset Enabled' */
    /* Sum: '<S1190>/Summation' incorporates:
     *  Constant: '<S1180>/Calib'
     *  DataStoreRead: '<S1173>/Dsr_Ni1stFlt_DS'
     *  DataStoreRead: '<S1173>/Dsr_NiProfGenT2Gain'
     *  DataStoreRead: '<S1179>/Dsr_MinEngStrtSpd'
     *  DataStoreRead: '<S1179>/Dsr_StrtNiNoFuel'
     *  MinMax: '<S1179>/Maximum'
     *  MinMax: '<S1179>/MinMax'
     *  MinMax: '<S1190>/Maximum'
     *  Product: '<S1190>/Multiplication'
     *  Product: '<S1190>/Multiplication1'
     *  Sum: '<S1190>/Subtraction'
     */
    rtb_Summation_k = (((fminf(fmaxf(rtu_VeESSR_n_OptInputSpd,
                           VeESSR_n_MinEngStrtSpd_DS),
                          VeESSR_n_StrtTypMaxStrtNiNoFuel_DS) -
                         VeESSR_n_Ni1stFlt_DS) * HeESSR_t_MedTEB_dT) * (1.0F /
                        fmaxf(VeESSR_k_StrtTypScndOrdLwPassT_DS,
                         HeESSR_t_MedTEB_dT))) + VeESSR_n_Ni1stFlt_DS;

    /* End of Outputs for SubSystem: '<S1189>/LowpassT Reset Enabled' */

    /* Outputs for Atomic SubSystem: '<S1189>/LowpassT Reset Enabled1' */
    /* Sum: '<S1191>/Summation' incorporates:
     *  Constant: '<S1180>/Calib'
     *  DataStoreRead: '<S1173>/Dsr_InputSpeedProfile1'
     *  DataStoreRead: '<S1173>/Dsr_NiProfGenT1Gain'
     *  MinMax: '<S1191>/Maximum'
     *  Product: '<S1191>/Multiplication'
     *  Product: '<S1191>/Multiplication1'
     *  Sum: '<S1191>/Subtraction'
     */
    rtb_Summation_fg = (((rtb_Summation_k - VeESSR_n_InputSpeedProfile_DS) *
                         HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                         (VeESSR_k_StrtTypFrstOrdLwPassT_DS, HeESSR_t_MedTEB_dT)))
        + VeESSR_n_InputSpeedProfile_DS;

    /* End of Outputs for SubSystem: '<S1189>/LowpassT Reset Enabled1' */

    /* RelationalOperator: '<S1173>/Comparison' incorporates:
     *  Constant: '<S1180>/Calib'
     *  DataStoreRead: '<S1173>/Dsr_STMTmr'
     */
    rtb_Comparison_hy = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

    /* Switch: '<S1211>/Switch1' incorporates:
     *  UnitDelay: '<S1211>/Unit Delay'
     */
    if (rtb_Comparison_hy)
    {
        rtb_Gain1_ez = rtb_Summation_fg;
    }
    else
    {
        rtb_Gain1_ez = localDW->UnitDelay_DSTATE;
    }

    /* End of Switch: '<S1211>/Switch1' */

    /* Gain: '<S1192>/Gain1' incorporates:
     *  Sum: '<S1192>/Sum18'
     */
    rtb_Gain1_ez = (rtb_Summation_fg + rtb_Gain1_ez) * 0.5F;

    /* Delay: '<S1192>/IntegerDelay' incorporates:
     *  Constant: '<S1201>/Calib'
     */
    if (rtb_Comparison_hy && (((uint32)localZCE->IntegerDelay_Reset_ZCE_g) !=
                              POS_ZCSIG))
    {
        localDW->icLoad = 1U;
    }

    localZCE->IntegerDelay_Reset_ZCE_g = rtb_Comparison_hy ? ((ZCSigState)1) :
        ((ZCSigState)0);
    if (((sint32)localDW->icLoad) != 0)
    {
        for (i = 0; i < 16; i++)
        {
            localDW->IntegerDelay_DSTATE[i] = rtb_Gain1_ez;
        }
    }

    if (((sint32)KeESSR_Cnt_DelayOptNi) <= 0)
    {
        /* Delay: '<S1192>/IntegerDelay' */
        rtb_IntegerDelay = rtb_Gain1_ez;
    }
    else
    {
        if (((sint32)KeESSR_Cnt_DelayOptNi) > 16)
        {
            tmp = 16U;
        }
        else
        {
            tmp = KeESSR_Cnt_DelayOptNi;
        }

        /* Delay: '<S1192>/IntegerDelay' */
        rtb_IntegerDelay = localDW->IntegerDelay_DSTATE[(uint8)(16U - ((uint32)
            tmp))];
    }

    /* End of Delay: '<S1192>/IntegerDelay' */

    /* Sum: '<S1192>/Sum15' incorporates:
     *  Abs: '<S1192>/Abs4'
     *  Constant: '<S1185>/Calib'
     *  DataStoreRead: '<S1173>/Dsr_InputSpeedProfile5'
     */
    rtb_Sum15 = fabsf(VeESSR_dn_TargetAcceltn_DS) + KeESSR_dn_NiTargetJerkLimit;

    /* Outputs for Atomic SubSystem: '<S1192>/GradientLimiter' */
    /* Sum: '<S1194>/Sum2' incorporates:
     *  Constant: '<S1180>/Calib'
     *  DataStoreRead: '<S1173>/Dsr_InputSpeedProfile4'
     *  Product: '<S1192>/Product6'
     *  Sum: '<S1192>/Sum14'
     *  UnitDelay: '<S1194>/Unit Delay'
     */
    rtb_Sum2_jri = ((rtb_Gain1_ez - VeESSR_n_TargetSpeed_DS) /
                    HeESSR_t_MedTEB_dT) - localDW->UnitDelay_DSTATE_b;

    /* Outputs for Atomic SubSystem: '<S1194>/Limiter' */
    /* Switch: '<S1212>/Switch1' incorporates:
     *  RelationalOperator: '<S1212>/Relational Operator'
     */
    if (rtb_Sum15 < rtb_Sum2_jri)
    {
        /* MinMax: '<S1195>/MinMax1' */
        rtb_MinMax1_fx = rtb_Sum15;
    }
    else
    {
        /* MinMax: '<S1195>/MinMax1' */
        rtb_MinMax1_fx = rtb_Sum2_jri;
    }

    /* End of Switch: '<S1212>/Switch1' */

    /* Switch: '<S1212>/Switch' incorporates:
     *  Gain: '<S1192>/Gain'
     *  RelationalOperator: '<S1212>/Relational Operator1'
     */
    if (rtb_MinMax1_fx <= (-rtb_Sum15))
    {
        rtb_MinMax1_fx = -rtb_Sum15;
    }

    /* End of Switch: '<S1212>/Switch' */
    /* End of Outputs for SubSystem: '<S1194>/Limiter' */

    /* Sum: '<S1194>/Sum3' incorporates:
     *  UnitDelay: '<S1194>/Unit Delay'
     */
    rtb_Gain_aq = rtb_MinMax1_fx + localDW->UnitDelay_DSTATE_b;

    /* Update for UnitDelay: '<S1194>/Unit Delay' */
    localDW->UnitDelay_DSTATE_b = rtb_Gain_aq;

    /* End of Outputs for SubSystem: '<S1192>/GradientLimiter' */

    /* Sum: '<S1193>/Subtraction1' incorporates:
     *  Constant: '<S1186>/Calib'
     *  DataStoreRead: '<S1173>/Dsr_InputSpeedProfile5'
     *  Product: '<S1193>/Multiplication'
     *  Sum: '<S1193>/Subtraction'
     */
    rtb_Gain_aq = ((rtb_Gain_aq - VeESSR_dn_TargetAcceltn_DS) *
                   KeESSR_k_NiDotTargetFilt) + VeESSR_dn_TargetAcceltn_DS;

    /* DataStoreRead: '<S1173>/Dsr_InputAcceltnProf' */
    rtb_Sum15 = VeESSR_dn_InputAcceltnProf_DS;

    /* Abs: '<S1189>/Abs' incorporates:
     *  DataStoreRead: '<S1173>/Dsr_NiProfGenDNiDLim'
     */
    rtb_MinMax1_fx = fabsf(VeESSR_dn_StrtTypJerkMax_DS);

    /* Switch: '<S1223>/Switch1' incorporates:
     *  Constant: '<S1221>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S1223>/Switch1' incorporates:
         *  Constant: '<S1222>/Calib'
         */
        rtb_Switch1_dyk = HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S1210>/Sum6' incorporates:
         *  DataStoreRead: '<S1173>/Dsr_InputAcceltnProf'
         *  Sum: '<S1210>/Sum8'
         */
        rtb_Switch1_dyk = VeESSR_dn_InputAcceltnProf_DS - rtb_Gain_aq;

        /* Abs: '<S1210>/Abs' incorporates:
         *  Sum: '<S1210>/Sum6'
         */
        rtb_Sum2_jri = (rtb_Switch1_dyk - rtb_Gain_bl) + rtb_MinMax1_fx;

        /* MinMax: '<S1210>/MinMax2' incorporates:
         *  Abs: '<S1210>/Abs1'
         *  Constant: '<S1180>/Calib'
         *  Constant: '<S1210>/Constant Value'
         *  Constant: '<S1210>/Constant Value3'
         *  DataStoreRead: '<S1173>/Dsr_InputSpeedProfile1'
         *  Product: '<S1210>/Product2'
         *  Product: '<S1210>/Product7'
         *  Product: '<S1225>/Prod'
         *  Sum: '<S1210>/Sum3'
         *  Sum: '<S1210>/Sum5'
         */
        rtb_Sum2_jri = fmaxf((fabsf((rtb_IntegerDelay -
                                VeESSR_n_InputSpeedProfile_DS) -
                               (HeESSR_t_MedTEB_dT * rtb_Gain_aq)) *
                              (rtb_Product4 * -2.0F)) - (rtb_Sum2_jri *
                              rtb_Sum2_jri), 0.0F);

        /* Switch: '<S1227>/Switch' incorporates:
         *  Sqrt: '<S1227>/Sqrt'
         */
        rtb_Sum2_jri = sqrtf(rtb_Sum2_jri);

        /* Switch: '<S1223>/Switch1' incorporates:
         *  Abs: '<S1210>/Abs'
         *  Sum: '<S1210>/Sum7'
         *  Sum: '<S1210>/Sum8'
         */
        rtb_Switch1_dyk = fabsf(rtb_Switch1_dyk + rtb_Gain_bl) + (rtb_Sum2_jri +
            rtb_Gain_aq);
    }

    /* End of Switch: '<S1223>/Switch1' */

    /* Product: '<S1192>/Product1' incorporates:
     *  Constant: '<S1180>/Calib'
     */
    rtb_Sum2_jri = rtb_MinMax1_fx / HeESSR_t_MedTEB_dT;

    /* Switch: '<S1224>/Switch1' incorporates:
     *  Constant: '<S1221>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S1224>/Switch1' incorporates:
         *  Constant: '<S1222>/Calib'
         *  Gain: '<S1210>/Gain1'
         */
        rtb_Switch1_by = -HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S1210>/Sum11' incorporates:
         *  DataStoreRead: '<S1173>/Dsr_InputAcceltnProf'
         *  Sum: '<S1210>/Sum13'
         */
        rtb_Switch_jis = VeESSR_dn_InputAcceltnProf_DS - rtb_Gain_aq;

        /* Abs: '<S1210>/Abs2' incorporates:
         *  Sum: '<S1210>/Sum11'
         */
        rtb_Abs2_kp = (rtb_Switch_jis - rtb_MinMax1_fx) + rtb_Gain_bl;

        /* MinMax: '<S1210>/MinMax1' incorporates:
         *  Abs: '<S1210>/Abs3'
         *  Constant: '<S1180>/Calib'
         *  Constant: '<S1210>/Constant Value1'
         *  Constant: '<S1210>/Constant Value2'
         *  DataStoreRead: '<S1173>/Dsr_InputSpeedProfile1'
         *  Product: '<S1210>/Product5'
         *  Product: '<S1210>/Product8'
         *  Product: '<S1228>/Prod'
         *  Sum: '<S1210>/Sum10'
         *  Sum: '<S1210>/Sum9'
         */
        rtb_Abs2_kp = fmaxf((fabsf((rtb_IntegerDelay -
                               VeESSR_n_InputSpeedProfile_DS) -
                              (HeESSR_t_MedTEB_dT * rtb_Gain_aq)) *
                             (rtb_Sum2_jri * 2.0F)) - (rtb_Abs2_kp * rtb_Abs2_kp),
                            0.0F);

        /* Switch: '<S1226>/Switch' incorporates:
         *  Sqrt: '<S1226>/Sqrt'
         */
        rtb_Abs2_kp = sqrtf(rtb_Abs2_kp);

        /* Switch: '<S1224>/Switch1' incorporates:
         *  Abs: '<S1210>/Abs2'
         *  Sum: '<S1210>/Sum12'
         *  Sum: '<S1210>/Sum13'
         */
        rtb_Switch1_by = (rtb_Gain_aq - rtb_Abs2_kp) - fabsf(rtb_Switch_jis +
            rtb_MinMax1_fx);
    }

    /* End of Switch: '<S1224>/Switch1' */

    /* Switch: '<S1192>/Switch1' incorporates:
     *  Constant: '<S1197>/Calib'
     *  Constant: '<S1198>/Calib'
     *  DataStoreRead: '<S1173>/Data Store Read'
     *  DataStoreRead: '<S1173>/Dsr_InputSpeedProfile2'
     *  Logic: '<S1192>/Logical1'
     *  Logic: '<S1192>/Logical6'
     *  Logic: '<S1192>/Logical8'
     */
    if (((HeESSR_b_NiLmtBypsLoopJerk) && (VeESSR_b_NiMaxActive_DS)) ||
            ((VeESSR_b_NiDotMaxActive_DS) && (HeESSR_b_NiDotLmtBypsLoopJerk)))
    {
        /* Switch: '<S1192>/Switch1' */
        rtb_MinMax1_fx = rtb_Switch1_dyk;
    }
    else
    {
        /* Switch: '<S1192>/Switch1' incorporates:
         *  DataStoreRead: '<S1173>/Dsr_InputAcceltnProf'
         *  Sum: '<S1192>/Sum1'
         */
        rtb_MinMax1_fx += VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S1192>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S1192>/Limiter2' */
    /* Switch: '<S1205>/Switch1' incorporates:
     *  RelationalOperator: '<S1205>/Relational Operator'
     */
    if (rtb_Switch1_dyk < rtb_MinMax1_fx)
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = rtb_Switch1_dyk;
    }
    else
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = rtb_MinMax1_fx;
    }

    /* End of Switch: '<S1205>/Switch1' */

    /* Switch: '<S1205>/Switch' incorporates:
     *  RelationalOperator: '<S1205>/Relational Operator1'
     */
    if (rtb_Abs2_kp > rtb_Switch1_by)
    {
        /* Switch: '<S1205>/Switch' */
        rtb_MinMax1_fx = rtb_Abs2_kp;
    }
    else
    {
        /* Switch: '<S1205>/Switch' */
        rtb_MinMax1_fx = rtb_Switch1_by;
    }

    /* End of Switch: '<S1205>/Switch' */
    /* End of Outputs for SubSystem: '<S1192>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S1192>/Limiter4' */
    /* Switch: '<S1207>/Switch1' incorporates:
     *  DataStoreRead: '<S1173>/Dsr_NiProfGenNiDMax'
     *  RelationalOperator: '<S1207>/Relational Operator'
     */
    if (VeESSR_dn_StrtTypNiDotMax_DS < rtb_MinMax1_fx)
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = VeESSR_dn_StrtTypNiDotMax_DS;
    }
    else
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = rtb_MinMax1_fx;
    }

    /* End of Switch: '<S1207>/Switch1' */

    /* Switch: '<S1207>/Switch' incorporates:
     *  DataStoreRead: '<S1173>/Dsr_NiProfGenNiDMin'
     *  RelationalOperator: '<S1207>/Relational Operator1'
     */
    if (rtb_Abs2_kp > VeESSR_dn_StrtTypNiDotMin_DS)
    {
        /* Switch: '<S1207>/Switch' */
        rtb_Switch_jis = rtb_Abs2_kp;
    }
    else
    {
        /* Switch: '<S1207>/Switch' */
        rtb_Switch_jis = VeESSR_dn_StrtTypNiDotMin_DS;
    }

    /* End of Switch: '<S1207>/Switch' */
    /* End of Outputs for SubSystem: '<S1192>/Limiter4' */

    /* Sum: '<S1196>/Sum6' incorporates:
     *  DataStoreRead: '<S1173>/Dsr_InputSpeedProfile1'
     */
    rtb_Sum6_aee = rtu_VeHSER_n_NiMax - VeESSR_n_InputSpeedProfile_DS;

    /* Abs: '<S1196>/Abs2' */
    rtb_Abs2_kp = fabsf(rtb_Sum6_aee);

    /* Switch: '<S1196>/Switch' incorporates:
     *  Constant: '<S1196>/Constant Value7'
     *  RelationalOperator: '<S1196>/Comparison2'
     */
    if (rtb_Sum6_aee < 0.0F)
    {
        /* MinMax: '<S1195>/MinMax1' incorporates:
         *  Abs: '<S1196>/Abs'
         */
        rtb_MinMax1_fx = fabsf(rtb_Sum2_jri);
    }
    else
    {
        /* MinMax: '<S1195>/MinMax1' incorporates:
         *  Abs: '<S1196>/Abs1'
         *  Gain: '<S1196>/Gain'
         */
        rtb_MinMax1_fx = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S1196>/Switch' */

    /* Product: '<S1196>/Product4' incorporates:
     *  Constant: '<S1180>/Calib'
     */
    rtb_Product4_h = (rtb_MinMax1_fx * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1196>/Protected Division1' */
    /* Switch: '<S1219>/Switch1' incorporates:
     *  Constant: '<S1219>/Constant Value'
     *  Constant: '<S1219>/Constant Value1'
     *  Constant: '<S1219>/Constant Value2'
     *  Logic: '<S1219>/AND'
     *  RelationalOperator: '<S1219>/Greater Than or Equal '
     *  RelationalOperator: '<S1219>/Not Equal'
     *  RelationalOperator: '<S1219>/Not Equal1'
     *  Switch: '<S1219>/Switch2'
     */
    if ((rtb_Abs2_kp != 0.0F) && (rtb_Product4_h != 0.0F))
    {
        /* Switch: '<S1219>/Switch1' incorporates:
         *  Product: '<S1219>/Division'
         */
        rtb_Abs2_kp /= rtb_Product4_h;
    }
    else if (rtb_Abs2_kp > 0.0F)
    {
        /* Switch: '<S1219>/Switch2' incorporates:
         *  Constant: '<S1219>/MAXFLOAT'
         *  Switch: '<S1219>/Switch1'
         */
        rtb_Abs2_kp = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1219>/Switch1' incorporates:
         *  Constant: '<S1219>/Constant Value4'
         *  Switch: '<S1219>/Switch2'
         *  Switch: '<S1219>/Switch3'
         */
        rtb_Abs2_kp = 0.0F;
    }

    /* End of Switch: '<S1219>/Switch1' */
    /* End of Outputs for SubSystem: '<S1196>/Protected Division1' */

    /* Sum: '<S1196>/Sum4' incorporates:
     *  Abs: '<S1196>/Abs3'
     *  Constant: '<S1196>/Constant Value3'
     *  Constant: '<S1196>/Constant Value5'
     *  Product: '<S1196>/Product3'
     */
    rtb_Abs2_kp = (fabsf(rtb_Abs2_kp) * 8.0F) + 1.0F;

    /* Switch: '<S1220>/Switch' */
    if (rtb_Abs2_kp >= 0.0F)
    {
        /* Sum: '<S1175>/Subtraction1' incorporates:
         *  Sqrt: '<S1220>/Sqrt'
         */
        rtb_Abs2_kp = sqrtf(rtb_Abs2_kp);
    }
    else
    {
        /* Sum: '<S1175>/Subtraction1' incorporates:
         *  Constant: '<S1220>/Zero'
         */
        rtb_Abs2_kp = 0.0F;
    }

    /* End of Switch: '<S1220>/Switch' */

    /* Sum: '<S1175>/Subtraction1' incorporates:
     *  Constant: '<S1196>/Constant Value'
     *  Constant: '<S1196>/Constant Value4'
     *  Constant: '<S1196>/Constant Value6'
     *  MinMax: '<S1196>/MinMax1'
     *  Product: '<S1196>/Product2'
     *  Rounding: '<S1196>/Rounding1'
     *  Sum: '<S1196>/Sum3'
     */
    rtb_Abs2_kp = fmaxf(ceilf((rtb_Abs2_kp - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S1196>/Product' incorporates:
     *  Constant: '<S1180>/Calib'
     */
    rtb_Product4_h = rtb_Abs2_kp * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1196>/Protected Division' */
    /* Switch: '<S1218>/Switch1' incorporates:
     *  Constant: '<S1218>/Constant Value'
     *  Constant: '<S1218>/Constant Value1'
     *  Constant: '<S1218>/Constant Value2'
     *  Constant: '<S1218>/Constant Value3'
     *  Logic: '<S1218>/AND'
     *  RelationalOperator: '<S1218>/Greater Than or Equal '
     *  RelationalOperator: '<S1218>/Greater Than or Equal 1'
     *  RelationalOperator: '<S1218>/Not Equal'
     *  RelationalOperator: '<S1218>/Not Equal1'
     *  Switch: '<S1218>/Switch2'
     *  Switch: '<S1218>/Switch3'
     */
    if ((rtb_Sum6_aee != 0.0F) && (rtb_Product4_h != 0.0F))
    {
        /* Switch: '<S1218>/Switch1' incorporates:
         *  Product: '<S1218>/Division'
         */
        rtb_Sum6_aee /= rtb_Product4_h;
    }
    else if (rtb_Sum6_aee > 0.0F)
    {
        /* Switch: '<S1218>/Switch2' incorporates:
         *  Constant: '<S1218>/MAXFLOAT'
         *  Switch: '<S1218>/Switch1'
         */
        rtb_Sum6_aee = 3.402823466E+38F;
    }
    else if (rtb_Sum6_aee < 0.0F)
    {
        /* Switch: '<S1218>/Switch3' incorporates:
         *  Constant: '<S1218>/MINFLOAT'
         *  Switch: '<S1218>/Switch1'
         *  Switch: '<S1218>/Switch2'
         */
        rtb_Sum6_aee = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1218>/Switch1' incorporates:
         *  Constant: '<S1218>/Constant Value4'
         *  Switch: '<S1218>/Switch2'
         *  Switch: '<S1218>/Switch3'
         */
        rtb_Sum6_aee = 0.0F;
    }

    /* End of Switch: '<S1218>/Switch1' */
    /* End of Outputs for SubSystem: '<S1196>/Protected Division' */

    /* Sum: '<S1196>/Sum' incorporates:
     *  Constant: '<S1180>/Calib'
     *  Constant: '<S1196>/Constant Value1'
     *  Constant: '<S1196>/Constant Value2'
     *  Product: '<S1196>/Product1'
     *  Sum: '<S1196>/Sum2'
     */
    rtb_MinMax1_fx = rtb_Sum6_aee - (((0.5F * rtb_MinMax1_fx) * (rtb_Abs2_kp -
        1.0F)) * HeESSR_t_MedTEB_dT);

    /* Switch: '<S1192>/Switch4' incorporates:
     *  Constant: '<S1199>/Calib'
     */
    if (!HeESSR_b_NiLmtForAccelByps)
    {
        /* Switch: '<S1192>/Switch4' incorporates:
         *  MinMax: '<S1192>/MinMax1'
         */
        rtb_Switch_jis = fminf(rtb_MinMax1_fx, rtb_Switch_jis);
    }

    /* End of Switch: '<S1192>/Switch4' */

    /* Outputs for Atomic SubSystem: '<S1192>/Limiter13' */
    /* RelationalOperator: '<S1204>/Relational Operator' */
    rtb_Comparison_hy = (rtu_VeHSER_dn_NiDotMax <= rtb_Switch_jis);

    /* Switch: '<S1204>/Switch1' */
    if (rtb_Comparison_hy)
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = rtu_VeHSER_dn_NiDotMax;
    }
    else
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = rtb_Switch_jis;
    }

    /* End of Switch: '<S1204>/Switch1' */

    /* Switch: '<S1204>/Switch' incorporates:
     *  RelationalOperator: '<S1204>/Relational Operator1'
     */
    if (rtb_Abs2_kp <= rtu_VeHSER_dn_NiDotMin)
    {
        rtb_Abs2_kp = rtu_VeHSER_dn_NiDotMin;
    }

    /* End of Switch: '<S1204>/Switch' */
    /* End of Outputs for SubSystem: '<S1192>/Limiter13' */

    /* Product: '<S1192>/Product9' incorporates:
     *  Constant: '<S1180>/Calib'
     */
    rtb_Switch_jis = rtb_Abs2_kp * HeESSR_t_MedTEB_dT;

    /* Switch: '<S1192>/Switch2' incorporates:
     *  Constant: '<S1197>/Calib'
     *  DataStoreRead: '<S1173>/Dsr_InputSpeedProfile3'
     *  Logic: '<S1192>/Logical3'
     */
    if ((HeESSR_b_NiDotLmtBypsLoopJerk) && (VeESSR_b_NiDotMinActive_DS))
    {
        /* Switch: '<S1192>/Switch2' */
        rtb_Gain_bl = rtb_Switch1_by;
    }
    else
    {
        /* Switch: '<S1192>/Switch2' incorporates:
         *  DataStoreRead: '<S1173>/Dsr_InputAcceltnProf'
         *  Sum: '<S1192>/Sum16'
         */
        rtb_Gain_bl += VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S1192>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S1192>/Limiter' */
    /* Switch: '<S1202>/Switch1' incorporates:
     *  RelationalOperator: '<S1202>/Relational Operator'
     */
    if (rtb_Switch1_dyk < rtb_Gain_bl)
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = rtb_Switch1_dyk;
    }
    else
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = rtb_Gain_bl;
    }

    /* End of Switch: '<S1202>/Switch1' */

    /* Switch: '<S1202>/Switch' incorporates:
     *  RelationalOperator: '<S1202>/Relational Operator1'
     */
    if (rtb_Abs2_kp > rtb_Switch1_by)
    {
        /* Switch: '<S1202>/Switch' */
        rtb_Gain_bl = rtb_Abs2_kp;
    }
    else
    {
        /* Switch: '<S1202>/Switch' */
        rtb_Gain_bl = rtb_Switch1_by;
    }

    /* End of Switch: '<S1202>/Switch' */
    /* End of Outputs for SubSystem: '<S1192>/Limiter' */

    /* Outputs for Atomic SubSystem: '<S1192>/Limiter3' */
    /* Switch: '<S1206>/Switch1' incorporates:
     *  DataStoreRead: '<S1173>/Dsr_NiProfGenNiDMax'
     *  RelationalOperator: '<S1206>/Relational Operator'
     */
    if (VeESSR_dn_StrtTypNiDotMax_DS < rtb_Gain_bl)
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = VeESSR_dn_StrtTypNiDotMax_DS;
    }
    else
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = rtb_Gain_bl;
    }

    /* End of Switch: '<S1206>/Switch1' */
    /* End of Outputs for SubSystem: '<S1192>/Limiter3' */

    /* Switch: '<S1192>/Switch5' incorporates:
     *  Constant: '<S1199>/Calib'
     *  DataStoreRead: '<S1173>/Dsr_NiProfGenNiDMin'
     *  RelationalOperator: '<S1206>/Relational Operator1'
     *  Switch: '<S1206>/Switch'
     */
    if (HeESSR_b_NiLmtForAccelByps)
    {
        /* Outputs for Atomic SubSystem: '<S1192>/Limiter3' */
        /* Switch: '<S1206>/Switch' incorporates:
         *  DataStoreRead: '<S1173>/Dsr_NiProfGenNiDMin'
         *  RelationalOperator: '<S1206>/Relational Operator1'
         */
        if (rtb_Abs2_kp > VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S1192>/Switch5' */
            rtb_Gain_bl = rtb_Abs2_kp;
        }
        else
        {
            /* Switch: '<S1192>/Switch5' */
            rtb_Gain_bl = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Outputs for SubSystem: '<S1192>/Limiter3' */
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S1192>/Limiter3' */
        if (rtb_Abs2_kp <= VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S1206>/Switch' incorporates:
             *  DataStoreRead: '<S1173>/Dsr_NiProfGenNiDMin'
             */
            rtb_Abs2_kp = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Outputs for SubSystem: '<S1192>/Limiter3' */

        /* Switch: '<S1192>/Switch5' incorporates:
         *  MinMax: '<S1192>/MinMax2'
         */
        rtb_Gain_bl = fminf(rtb_MinMax1_fx, rtb_Abs2_kp);
    }

    /* End of Switch: '<S1192>/Switch5' */

    /* Outputs for Atomic SubSystem: '<S1192>/Limiter9' */
    /* Switch: '<S1209>/Switch1' incorporates:
     *  RelationalOperator: '<S1209>/Relational Operator'
     */
    if (rtu_VeHSER_dn_NiDotMax <= rtb_Gain_bl)
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = rtu_VeHSER_dn_NiDotMax;
    }
    else
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = rtb_Gain_bl;
    }

    /* End of Switch: '<S1209>/Switch1' */

    /* RelationalOperator: '<S1208>/Relational Operator1' incorporates:
     *  RelationalOperator: '<S1209>/Relational Operator1'
     */
    rtb_RelationalOperator1_hg = (rtb_Abs2_kp > rtu_VeHSER_dn_NiDotMin);

    /* Logic: '<S1209>/Logical2' */
    rtb_Logical2_hy = !rtb_RelationalOperator1_hg;

    /* Switch: '<S1209>/Switch' */
    if (!rtb_RelationalOperator1_hg)
    {
        rtb_Abs2_kp = rtu_VeHSER_dn_NiDotMin;
    }

    /* End of Switch: '<S1209>/Switch' */
    /* End of Outputs for SubSystem: '<S1192>/Limiter9' */

    /* Product: '<S1192>/Product10' incorporates:
     *  Constant: '<S1180>/Calib'
     */
    rtb_Gain_bl = rtb_Abs2_kp * HeESSR_t_MedTEB_dT;

    /* Sum: '<S1192>/Sum2' incorporates:
     *  DataStoreRead: '<S1173>/Dsr_InputSpeedProfile1'
     */
    rtb_Switch1_dyk = rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS;

    /* Sum: '<S1195>/Sum6' incorporates:
     *  Constant: '<S1180>/Calib'
     *  DataStoreRead: '<S1173>/Dsr_InputSpeedProfile1'
     *  Product: '<S1195>/Product7'
     *  Sum: '<S1192>/Sum6'
     *  Switch: '<S1192>/Switch3'
     */
    rtb_IntegerDelay = (rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS) -
        (rtb_Gain_aq * HeESSR_t_MedTEB_dT);

    /* Abs: '<S1195>/Abs2' incorporates:
     *  Sum: '<S1195>/Sum6'
     */
    rtb_MinMax1_fx = fabsf(rtb_IntegerDelay);

    /* Switch: '<S1195>/Switch' incorporates:
     *  Constant: '<S1195>/Constant Value7'
     *  RelationalOperator: '<S1195>/Comparison2'
     *  Sum: '<S1195>/Sum6'
     */
    if (rtb_IntegerDelay < 0.0F)
    {
        /* Sum: '<S1175>/Subtraction1' incorporates:
         *  Abs: '<S1195>/Abs'
         */
        rtb_Abs2_kp = fabsf(rtb_Sum2_jri);
    }
    else
    {
        /* Sum: '<S1175>/Subtraction1' incorporates:
         *  Abs: '<S1195>/Abs1'
         *  Gain: '<S1195>/Gain'
         */
        rtb_Abs2_kp = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S1195>/Switch' */

    /* Product: '<S1195>/Product4' incorporates:
     *  Constant: '<S1180>/Calib'
     */
    rtb_Product4 = (rtb_Abs2_kp * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1195>/Protected Division1' */
    /* Switch: '<S1215>/Switch1' incorporates:
     *  Constant: '<S1215>/Constant Value'
     *  Constant: '<S1215>/Constant Value1'
     *  Constant: '<S1215>/Constant Value2'
     *  Logic: '<S1215>/AND'
     *  RelationalOperator: '<S1215>/Greater Than or Equal '
     *  RelationalOperator: '<S1215>/Not Equal'
     *  RelationalOperator: '<S1215>/Not Equal1'
     *  Switch: '<S1215>/Switch2'
     */
    if ((rtb_MinMax1_fx != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S1215>/Switch1' incorporates:
         *  Product: '<S1215>/Division'
         */
        rtb_Product4 = rtb_MinMax1_fx / rtb_Product4;
    }
    else if (rtb_MinMax1_fx > 0.0F)
    {
        /* Switch: '<S1215>/Switch2' incorporates:
         *  Constant: '<S1215>/MAXFLOAT'
         *  Switch: '<S1215>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1215>/Switch1' incorporates:
         *  Constant: '<S1215>/Constant Value4'
         *  Switch: '<S1215>/Switch2'
         *  Switch: '<S1215>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S1215>/Switch1' */
    /* End of Outputs for SubSystem: '<S1195>/Protected Division1' */

    /* Sum: '<S1195>/Sum4' incorporates:
     *  Abs: '<S1195>/Abs3'
     *  Constant: '<S1195>/Constant Value3'
     *  Constant: '<S1195>/Constant Value5'
     *  Product: '<S1195>/Product3'
     */
    rtb_Product4 = (fabsf(rtb_Product4) * 8.0F) + 1.0F;

    /* Switch: '<S1216>/Switch' incorporates:
     *  Constant: '<S1216>/Zero'
     *  Sqrt: '<S1216>/Sqrt'
     */
    if (rtb_Product4 >= 0.0F)
    {
        rtb_Product4 = sqrtf(rtb_Product4);
    }
    else
    {
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S1216>/Switch' */

    /* MinMax: '<S1195>/MinMax1' incorporates:
     *  Constant: '<S1195>/Constant Value'
     *  Constant: '<S1195>/Constant Value4'
     *  Constant: '<S1195>/Constant Value6'
     *  Product: '<S1195>/Product2'
     *  Rounding: '<S1195>/Rounding1'
     *  Sum: '<S1195>/Sum3'
     */
    rtb_MinMax1_fx = fmaxf(ceilf((rtb_Product4 - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S1195>/Product' incorporates:
     *  Constant: '<S1180>/Calib'
     */
    rtb_Product4 = rtb_MinMax1_fx * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1195>/Protected Division' */
    /* Switch: '<S1214>/Switch1' incorporates:
     *  Constant: '<S1214>/Constant Value'
     *  Constant: '<S1214>/Constant Value1'
     *  Constant: '<S1214>/Constant Value2'
     *  Constant: '<S1214>/Constant Value3'
     *  Logic: '<S1214>/AND'
     *  RelationalOperator: '<S1214>/Greater Than or Equal '
     *  RelationalOperator: '<S1214>/Greater Than or Equal 1'
     *  RelationalOperator: '<S1214>/Not Equal'
     *  RelationalOperator: '<S1214>/Not Equal1'
     *  Sum: '<S1195>/Sum6'
     *  Switch: '<S1214>/Switch2'
     *  Switch: '<S1214>/Switch3'
     */
    if ((rtb_IntegerDelay != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S1214>/Switch1' incorporates:
         *  Product: '<S1214>/Division'
         */
        rtb_Product4 = rtb_IntegerDelay / rtb_Product4;
    }
    else if (rtb_IntegerDelay > 0.0F)
    {
        /* Switch: '<S1214>/Switch2' incorporates:
         *  Constant: '<S1214>/MAXFLOAT'
         *  Switch: '<S1214>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else if (rtb_IntegerDelay < 0.0F)
    {
        /* Switch: '<S1214>/Switch3' incorporates:
         *  Constant: '<S1214>/MINFLOAT'
         *  Switch: '<S1214>/Switch1'
         *  Switch: '<S1214>/Switch2'
         */
        rtb_Product4 = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1214>/Switch1' incorporates:
         *  Constant: '<S1214>/Constant Value4'
         *  Switch: '<S1214>/Switch2'
         *  Switch: '<S1214>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S1214>/Switch1' */
    /* End of Outputs for SubSystem: '<S1195>/Protected Division' */

    /* Switch: '<S1192>/Switch3' incorporates:
     *  Constant: '<S1200>/Calib'
     */
    if (!HeESSR_b_TrnstnJerkByps)
    {
        /* Switch: '<S1192>/Switch8' incorporates:
         *  Constant: '<S1192>/Constant Value7'
         *  RelationalOperator: '<S1192>/Comparison'
         */
        if (rtb_IntegerDelay > 0.0F)
        {
            /* Switch: '<S1192>/Switch3' incorporates:
             *  Constant: '<S1180>/Calib'
             *  Constant: '<S1195>/Constant Value1'
             *  Constant: '<S1195>/Constant Value2'
             *  MinMax: '<S1192>/MinMax4'
             *  Product: '<S1192>/Product5'
             *  Product: '<S1195>/Product1'
             *  Sum: '<S1195>/Sum'
             *  Sum: '<S1195>/Sum2'
             *  Switch: '<S1192>/Switch8'
             */
            rtb_Switch1_dyk = fminf(rtb_Switch1_dyk, ((rtb_Product4 +
                rtb_Gain_aq) - (((0.5F * rtb_Abs2_kp) * (rtb_MinMax1_fx - 1.0F))
                                * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }
        else
        {
            /* Switch: '<S1192>/Switch3' incorporates:
             *  Constant: '<S1180>/Calib'
             *  Constant: '<S1195>/Constant Value1'
             *  Constant: '<S1195>/Constant Value2'
             *  MinMax: '<S1192>/MinMax5'
             *  Product: '<S1192>/Product2'
             *  Product: '<S1195>/Product1'
             *  Sum: '<S1195>/Sum'
             *  Sum: '<S1195>/Sum2'
             *  Switch: '<S1192>/Switch8'
             */
            rtb_Switch1_dyk = fmaxf(rtb_Switch1_dyk, ((rtb_Product4 +
                rtb_Gain_aq) - (((0.5F * rtb_Abs2_kp) * (rtb_MinMax1_fx - 1.0F))
                                * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }

        /* End of Switch: '<S1192>/Switch8' */
    }

    /* Outputs for Atomic SubSystem: '<S1192>/Limiter6' */
    /* RelationalOperator: '<S1208>/Relational Operator' */
    rtb_RelationalOperator_o = (rtb_Switch_jis <= rtb_Switch1_dyk);

    /* Switch: '<S1208>/Switch1' */
    if (rtb_RelationalOperator_o)
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = rtb_Switch_jis;
    }
    else
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = rtb_Switch1_dyk;
    }

    /* End of Switch: '<S1208>/Switch1' */

    /* RelationalOperator: '<S1208>/Relational Operator1' */
    rtb_RelationalOperator1_hg = (rtb_Abs2_kp > rtb_Gain_bl);

    /* Switch: '<S1208>/Switch' */
    if (rtb_RelationalOperator1_hg)
    {
        rtb_Gain_bl = rtb_Abs2_kp;
    }

    /* End of Switch: '<S1208>/Switch' */
    /* End of Outputs for SubSystem: '<S1192>/Limiter6' */

    /* Sum: '<S1192>/Sum4' incorporates:
     *  DataStoreRead: '<S1173>/Dsr_InputSpeedProfile1'
     */
    rtb_IntegerDelay = rtb_Gain_bl + VeESSR_n_InputSpeedProfile_DS;

    /* Outputs for Atomic SubSystem: '<S1192>/Limiter1' */
    /* RelationalOperator: '<S1203>/Relational Operator' incorporates:
     *  DataStoreWrite: '<S1173>/Dsw_InputSpeedProfile5'
     */
    VeESSR_b_NiMaxActive_DS = (rtu_VeHSER_n_NiMax <= rtb_IntegerDelay);

    /* Switch: '<S1203>/Switch1' incorporates:
     *  DataStoreWrite: '<S1173>/Dsw_InputSpeedProfile5'
     */
    if (VeESSR_b_NiMaxActive_DS)
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = rtu_VeHSER_n_NiMax;
    }
    else
    {
        /* Sum: '<S1175>/Subtraction1' */
        rtb_Abs2_kp = rtb_IntegerDelay;
    }

    /* End of Switch: '<S1203>/Switch1' */

    /* Switch: '<S1203>/Switch' incorporates:
     *  Constant: '<S1192>/Constant Value4'
     *  RelationalOperator: '<S1203>/Relational Operator1'
     */
    if (rtb_Abs2_kp > 0.0F)
    {
        /* Switch: '<S1203>/Switch' */
        rtb_IntegerDelay = rtb_Abs2_kp;
    }
    else
    {
        /* Switch: '<S1203>/Switch' */
        rtb_IntegerDelay = 0.0F;
    }

    /* End of Switch: '<S1203>/Switch' */
    /* End of Outputs for SubSystem: '<S1192>/Limiter1' */

    /* Product: '<S1192>/Product3' incorporates:
     *  Constant: '<S1180>/Calib'
     *  DataStoreRead: '<S1173>/Dsr_InputSpeedProfile1'
     *  DataStoreWrite: '<S1173>/Dsw_InputAcceltnProf'
     *  Sum: '<S1192>/Sum'
     */
    VeESSR_dn_InputAcceltnProf_DS = (rtb_IntegerDelay -
        VeESSR_n_InputSpeedProfile_DS) / HeESSR_t_MedTEB_dT;

    /* DataStoreWrite: '<S1173>/Dsw_InputSpeedProfile' */
    VeESSR_n_InputSpeedProfile_DS = rtb_IntegerDelay;

    /* Logic: '<S1192>/Logical2' incorporates:
     *  DataStoreWrite: '<S1173>/Dsw_InputSpeedProfile1'
     */
    VeESSR_b_NiDotMaxActive_DS = (rtb_Comparison_hy && rtb_RelationalOperator_o);

    /* DataStoreWrite: '<S1173>/Dsw_InputSpeedProfile2' */
    VeESSR_n_TargetSpeed_DS = rtb_Gain1_ez;

    /* DataStoreWrite: '<S1173>/Dsw_InputSpeedProfile3' */
    VeESSR_dn_TargetAcceltn_DS = rtb_Gain_aq;

    /* Outputs for Atomic SubSystem: '<S1192>/Limiter6' */
    /* Logic: '<S1192>/Logical' incorporates:
     *  DataStoreWrite: '<S1173>/Dsw_InputSpeedProfile4'
     *  Logic: '<S1208>/Logical2'
     */
    VeESSR_b_NiDotMinActive_DS = (rtb_Logical2_hy &&
        (!rtb_RelationalOperator1_hg));

    /* End of Outputs for SubSystem: '<S1192>/Limiter6' */

    /* DataStoreWrite: '<S1173>/Dsw_Ni1stFlt_DS' */
    VeESSR_n_Ni1stFlt_DS = rtb_Summation_k;

    /* DataStoreWrite: '<S1173>/Dsw_STMTmr' incorporates:
     *  Constant: '<S1180>/Calib'
     *  DataStoreRead: '<S1173>/Dsr_STMTmr'
     *  Sum: '<S1173>/Summation'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* MinMax: '<S1173>/MinMax' incorporates:
     *  Constant: '<S1184>/Calib'
     *  DataStoreRead: '<S1173>/Dsr_InputTorqEst'
     *  DataStoreWrite: '<S1173>/Dsw_InputTorqEst'
     *  Product: '<S1175>/Multiplication'
     *  Sum: '<S1173>/Sum1'
     *  Sum: '<S1175>/Subtraction'
     *  Sum: '<S1175>/Subtraction1'
     */
    VeESSR_M_EngTorqEst_DS = fmaxf(rtu_HTDR_TiMin,
        (((rtu_VeESSR_M_EngTrqAct_Lmtd - rtu_VeESSR_M_AddtlDragTorq) -
          VeESSR_M_EngTorqEst_DS) * KeESSR_K_TiEstBlndRestrt) +
        VeESSR_M_EngTorqEst_DS);

    /* DataStoreWrite: '<S1173>/Dsw_EngTrqReqPrdtd1' incorporates:
     *  Constant: '<S1183>/Calib'
     *  DataStoreRead: '<S1173>/Data Store Read1'
     *  DataStoreRead: '<S1173>/Dsr_StrtTypInitPredTorq'
     *  Product: '<S1176>/Multiplication'
     *  Sum: '<S1176>/Subtraction'
     *  Sum: '<S1176>/Subtraction1'
     */
    VeESSR_M_EngTrqReqPrdtd_DS = ((VeESSR_M_StrtTypInitPredTorq_DS -
        VeESSR_M_EngTrqReqPrdtd_DS) * KeESSR_K_EngTrqReqPrdtFltRP) +
        VeESSR_M_EngTrqReqPrdtd_DS;

    /* DataStoreWrite: '<S1173>/Dsw_EngTrqReqImmed' incorporates:
     *  Constant: '<S1182>/Calib'
     *  DataStoreRead: '<S1173>/Data Store Read2'
     *  DataStoreRead: '<S1173>/Dsr_StrtTypInitImmedTorq'
     *  Product: '<S1177>/Multiplication'
     *  Sum: '<S1177>/Subtraction'
     *  Sum: '<S1177>/Subtraction1'
     */
    VeESSR_M_EngTrqReqImmed_DS = ((VeESSR_M_StrtTypInitImmedTorq_DS -
        VeESSR_M_EngTrqReqImmed_DS) * KeESSR_K_EngTrqReqImmedFltRP) +
        VeESSR_M_EngTrqReqImmed_DS;

    /* Switch: '<S1181>/Switch1' incorporates:
     *  Constant: '<S1178>/Constant'
     *  Constant: '<S1187>/Calib'
     *  DataStoreRead: '<S1173>/Dsr_STMTmr1'
     *  DataStoreWrite: '<S1173>/Dsw_STMTrigger1'
     *  RelationalOperator: '<S1173>/Greater  Than1'
     */
    if (VeESSR_t_STMTmr_DS > KeESSR_t_MinRestartPrepTm)
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngSpdTgtAch;
    }

    /* End of Switch: '<S1181>/Switch1' */

    /* Sum: '<S1192>/Sum17' incorporates:
     *  DataStoreWrite: '<S1173>/Dsw_InputAcceltnProf'
     */
    VeESSR_dn_InputJerkProfRestartPrep = VeESSR_dn_InputAcceltnProf_DS -
        rtb_Sum15;

    /* Update for UnitDelay: '<S1211>/Unit Delay' incorporates:
     *  Switch: '<S1211>/Switch3'
     */
    localDW->UnitDelay_DSTATE = rtb_Summation_fg;

    /* Update for Delay: '<S1192>/IntegerDelay' */
    localDW->icLoad = 0U;
    for (i = 0; i < 15; i++)
    {
        localDW->IntegerDelay_DSTATE[i] = localDW->IntegerDelay_DSTATE[i + 1];
    }

    localDW->IntegerDelay_DSTATE[15] = rtb_Gain1_ez;

    /* End of Update for Delay: '<S1192>/IntegerDelay' */
}

#endif

/*
 * Output and update for action system:
 *    '<S1023>/LowPower'
 *    '<S1023>/KeyCrank'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_LowPower(P2VAR
    (TeESSR_e_EngStrtActuatorTyp, AUTOMATIC, ESSR_VAR_INIT) rty_Out1)
{
    /* Switch: '<S1168>/Switch1' incorporates:
     *  Constant: '<S1165>/Constant'
     *  Constant: '<S1166>/Calib'
     *  Constant: '<S1167>/Calib'
     *  Switch: '<S1168>/Switch2'
     */
    if (HeESSR_b_12vStrtrEquipped)
    {
        *rty_Out1 = CeESSR_e_Ext12VStarter;
    }
    else if (HeESSR_b_BumpStrtEquipped)
    {
        /* Switch: '<S1138>/Switch' incorporates:
         *  DataStoreRead: '<S1138>/BmpStrtFailed'
         *  Switch: '<S1168>/Switch2'
         */
        if (VeESSR_b_BumpStrtFailed_DS)
        {
            /* Switch: '<S1168>/Switch2' incorporates:
             *  Constant: '<S1164>/Constant'
             */
            *rty_Out1 = CeESSR_e_P1f;
        }
        else
        {
            /* Switch: '<S1168>/Switch2' incorporates:
             *  Constant: '<S1163>/Constant'
             */
            *rty_Out1 = CeESSR_e_P2;
        }

        /* End of Switch: '<S1138>/Switch' */
    }
    else
    {
        /* Switch: '<S1168>/Switch2' incorporates:
         *  Constant: '<S1169>/Calib'
         */
        *rty_Out1 = KeESSR_e_EngStartActrType;
    }

    /* End of Switch: '<S1168>/Switch1' */
}

#endif

/* Output and update for function-call system: '<S559>/InitEngSpinEnt' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_InitEngSpinEnt(VAR(float32, AUTOMATIC)
    rtu_VeEPCR_phi_EngAngle720Est, VAR(float32, AUTOMATIC)
    rtu_VeESMR_P_BatSTMaxLim, VAR(float32, AUTOMATIC) rtu_VeESMR_P_BatSTMinLim,
    VAR(boolean, AUTOMATIC) rtu_VeSTRR_b_BumpStrtEngOn)
{
    boolean rtb_Comparison1_by;
    boolean rtb_Comparison6_m2;
    boolean rtb_Logical10;
    boolean rtb_Logical1_nr;
    boolean rtb_LogicalOperator3_e;

    /* RelationalOperator: '<S1023>/Comparison6' incorporates:
     *  Constant: '<S1100>/Constant'
     *  DataStoreRead: '<S1023>/Dsr_EngStrtType'
     */
    rtb_Comparison6_m2 = (CeESSR_e_CltchStrtAlgo == ((uint32)
                           VeESSR_e_EngStrtProfType_DS));

    /* Switch: '<S1023>/Switch1' incorporates:
     *  Constant: '<S1124>/Calib'
     */
    if (HeESSR_b_AEMDMtrBGain)
    {
        /* Switch: '<S1023>/Switch2' incorporates:
         *  Constant: '<S1135>/Calib'
         *  Constant: '<S1136>/Calib'
         *  DataStoreWrite: '<S1023>/Dsw_AEMDMtrBGain'
         */
        if (rtb_Comparison6_m2)
        {
            VeESSR_scl_AEMDMtrBGain_DS = KeESSR_scl_AEMDMtrBGain_InitSpnClchSt;
        }
        else
        {
            VeESSR_scl_AEMDMtrBGain_DS = KeESSR_scl_AEMDMtrBGain_InitSpnAutoSt;
        }

        /* End of Switch: '<S1023>/Switch2' */
    }

    /* End of Switch: '<S1023>/Switch1' */

    /* RelationalOperator: '<S1023>/Comparison1' incorporates:
     *  Constant: '<S1110>/Constant'
     *  DataStoreRead: '<S1023>/Dsr_EngStrtType'
     *  RelationalOperator: '<S1023>/Comparison6'
     */
    rtb_Comparison1_by = (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                          CeESSR_e_LowPwrAlgo);

    /* Logic: '<S1023>/Logical1' incorporates:
     *  Constant: '<S1099>/Constant'
     *  DataStoreRead: '<S1023>/Dsr_EngStrtType'
     *  RelationalOperator: '<S1023>/Comparison4'
     *  RelationalOperator: '<S1023>/Comparison6'
     */
    rtb_Logical1_nr = (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                       CeESSR_e_KeyCrnkAlgo);

    /* Logic: '<S1023>/Logical Operator3' incorporates:
     *  Constant: '<S1150>/Calib'
     *  Constant: '<S1151>/Calib'
     *  Constant: '<S1152>/Calib'
     *  Constant: '<S1153>/Calib'
     *  Constant: '<S1154>/Calib'
     *  Logic: '<S1095>/Logical1'
     *  Logic: '<S1095>/Logical2'
     *  Logic: '<S1095>/Logical3'
     *  Logic: '<S1095>/Logical4'
     *  Logic: '<S1095>/Logical5'
     *  Logic: '<S1095>/Logical6'
     *  Logic: '<S1095>/Logical7'
     *  Logic: '<S1095>/Logical8'
     *  RelationalOperator: '<S1095>/Comparison2'
     *  RelationalOperator: '<S1095>/Comparison3'
     */
    rtb_LogicalOperator3_e = ((((HeESSR_b_12vStrtrEquipped) &&
        (rtb_Comparison1_by || rtb_Logical1_nr)) || (rtb_Logical1_nr &&
        (KeESSR_b_KeyCrnkDsblNiClsdLp))) || ((rtb_Comparison1_by &&
        (KeESSR_b_LowPwrDsblNiClsdLp)) || (rtb_Comparison1_by &&
        ((rtu_VeESMR_P_BatSTMaxLim < KeESSR_P_DsblNiClsdLoopDschrgLmt) ||
         (rtu_VeESMR_P_BatSTMinLim > KeESSR_P_DsblNiClsdLoopChrgLmt)))));

    /* Switch: '<S1131>/Switch1' incorporates:
     *  Constant: '<S1127>/Calib'
     *  DataStoreWrite: '<S1023>/Dsw_DsblNiClsdLoopCntrl'
     *  Logic: '<S1023>/Logical9'
     */
    VeESSR_b_DsblNiClsdLoopCntrl_DS = (rtb_LogicalOperator3_e ||
        (HeESSR_b_DisableNi));

    /* Logic: '<S1023>/Logical10' incorporates:
     *  Constant: '<S1101>/Constant'
     *  DataStoreRead: '<S1023>/Dsr_EngStrtType'
     *  RelationalOperator: '<S1023>/Comparison5'
     *  RelationalOperator: '<S1023>/Comparison6'
     */
    rtb_Logical10 = (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                     CeESSR_e_EMLwPwrStrtAlgo);

    /* Logic: '<S1023>/Logical1' */
    rtb_Logical1_nr = ((rtb_Logical1_nr || rtb_Comparison1_by) || rtb_Logical10);

    /* Logic: '<S1023>/Logical10' incorporates:
     *  Constant: '<S1102>/Constant'
     *  Constant: '<S1105>/Constant'
     *  DataStoreRead: '<S1023>/Dsr_EngStrtType'
     *  RelationalOperator: '<S1023>/Comparison6'
     *  RelationalOperator: '<S1023>/Comparison7'
     *  RelationalOperator: '<S1023>/Comparison8'
     */
    rtb_Logical10 = (((rtb_Comparison6_m2 || (((uint32)
                         VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMStrtAlgo)) ||
                      (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                       CeESSR_e_ImplStrtAlgo)) || rtb_Logical10);

    /* If: '<S1023>/If' incorporates:
     *  Constant: '<S1125>/Calib'
     *  Logic: '<S1023>/Logical3'
     *  Logic: '<S1023>/Logical7'
     */
    if (((HeESSR_b_BumpStrtEquipped) && rtb_Logical1_nr) || rtb_Logical10)
    {
        /* Outputs for IfAction SubSystem: '<S1023>/ZeroLimits' incorporates:
         *  ActionPort: '<S1142>/Action Port'
         */
        /* DataStoreWrite: '<S1023>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
         *  Constant: '<S1142>/Constant Value2'
         *  Merge: '<S1023>/Merge'
         *  SignalConversion generated from: '<S1142>/Out1'
         */
        VeESSR_M_MtrA_MaxTorq_DS = 0.0F;

        /* DataStoreWrite: '<S1023>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
         *  Constant: '<S1142>/Constant Value1'
         *  Merge: '<S1023>/Merge1'
         *  SignalConversion generated from: '<S1142>/Out2'
         */
        VeESSR_M_MtrA_MinTorq_DS = 0.0F;

        /* End of Outputs for SubSystem: '<S1023>/ZeroLimits' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1023>/DefaultLimits' incorporates:
         *  ActionPort: '<S1094>/Action Port'
         */
        /* DataStoreWrite: '<S1023>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
         *  Constant: '<S1148>/Calib'
         *  Merge: '<S1023>/Merge'
         *  SignalConversion generated from: '<S1094>/Out1'
         */
        VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

        /* DataStoreWrite: '<S1023>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
         *  Constant: '<S1149>/Calib'
         *  Merge: '<S1023>/Merge1'
         *  SignalConversion generated from: '<S1094>/Out2'
         */
        VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

        /* End of Outputs for SubSystem: '<S1023>/DefaultLimits' */
    }

    /* End of If: '<S1023>/If' */

    /* Switch: '<S1130>/Switch1' incorporates:
     *  Constant: '<S1113>/Constant'
     *  Constant: '<S1114>/Constant'
     *  DataStoreWrite: '<S1023>/Dsw_EngCntrlMode_DS'
     *  Logic: '<S1023>/Logical2'
     */
    if (rtb_LogicalOperator3_e || rtu_VeSTRR_b_BumpStrtEngOn)
    {
        VeESSR_e_EngCntrlMode_DS = CeTRAR_e_SpeedMode;
    }
    else
    {
        VeESSR_e_EngCntrlMode_DS = CeTRAR_e_TorqueMode;
    }

    /* End of Switch: '<S1130>/Switch1' */

    /* Switch: '<S1129>/Switch1' incorporates:
     *  Constant: '<S1121>/Constant'
     *  Constant: '<S1122>/Constant'
     *  DataStoreWrite: '<S1023>/Dsw_EngStrtStpMd2'
     */
    if (rtb_Logical1_nr)
    {
        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_EngineTorqueStart;
    }
    else
    {
        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_StartPending;
    }

    /* End of Switch: '<S1129>/Switch1' */

    /* Logic: '<S1023>/Logical Operator3' incorporates:
     *  DataStoreRead: '<S1023>/BmpStrtFailed'
     */
    rtb_LogicalOperator3_e = !VeESSR_b_BumpStrtFailed_DS;

    /* If: '<S1023>/If1' incorporates:
     *  Constant: '<S1103>/Constant'
     *  Constant: '<S1115>/Constant'
     *  Constant: '<S1116>/Constant'
     *  Constant: '<S1117>/Constant'
     *  Constant: '<S1118>/Constant'
     *  Constant: '<S1119>/Constant'
     *  Constant: '<S1125>/Calib'
     *  DataStoreRead: '<S1023>/Dsr_EngStrtType'
     *  Logic: '<S1023>/Logical11'
     *  Logic: '<S1023>/Logical14'
     *  Logic: '<S1023>/Logical4'
     *  Logic: '<S1023>/Logical5'
     *  RelationalOperator: '<S1023>/Comparison10'
     *  RelationalOperator: '<S1023>/Comparison11'
     *  RelationalOperator: '<S1023>/Comparison12'
     *  RelationalOperator: '<S1023>/Comparison2'
     *  RelationalOperator: '<S1023>/Comparison3'
     *  RelationalOperator: '<S1023>/Comparison6'
     *  RelationalOperator: '<S1023>/Comparison9'
     */
    if (((HeESSR_b_BumpStrtEquipped) && (((uint32)VeESSR_e_EngStrtProfType_DS) ==
          CeESSR_e_KeyCrnkAlgo)) && rtb_LogicalOperator3_e)
    {
        /* Outputs for IfAction SubSystem: '<S1023>/BumpStrt' incorporates:
         *  ActionPort: '<S1090>/Action Port'
         */
        /* DataStoreWrite: '<S1023>/Dsw_EngStrtType1' incorporates:
         *  Constant: '<S1144>/Constant'
         *  SignalConversion generated from: '<S1090>/Out1'
         */
        VeESSR_e_TCM_StartStopType_DS = CeESSR_e_BumpStart;

        /* End of Outputs for SubSystem: '<S1023>/BumpStrt' */
    }
    else if ((rtb_LogicalOperator3_e && (HeESSR_b_BumpStrtEquipped)) &&
             (((uint32)VeESSR_e_EngStrtProfType_DS) == CeESSR_e_LowPwrAlgo))
    {
        /* Outputs for IfAction SubSystem: '<S1023>/ColdBumpStrt' incorporates:
         *  ActionPort: '<S1092>/Action Port'
         */
        /* DataStoreWrite: '<S1023>/Dsw_EngStrtType1' incorporates:
         *  Constant: '<S1146>/Constant'
         *  SignalConversion generated from: '<S1092>/Out1'
         */
        VeESSR_e_TCM_StartStopType_DS = CeESSR_e_ColdBumpStart;

        /* End of Outputs for SubSystem: '<S1023>/ColdBumpStrt' */
    }
    else if ((CeESSR_e_CltchStrtAlgo == ((uint32)VeESSR_e_EngStrtProfType_DS)) ||
             (((uint32)VeESSR_e_EngStrtProfType_DS) == CeESSR_e_ImplStrtAlgo))
    {
        /* Outputs for IfAction SubSystem: '<S1023>/ClutchStrt' incorporates:
         *  ActionPort: '<S1091>/Action Port'
         */
        /* DataStoreWrite: '<S1023>/Dsw_EngStrtType1' incorporates:
         *  Constant: '<S1145>/Constant'
         *  SignalConversion generated from: '<S1091>/Out1'
         */
        VeESSR_e_TCM_StartStopType_DS = CeESSR_e_CltchStrt;

        /* End of Outputs for SubSystem: '<S1023>/ClutchStrt' */
    }
    else if ((CeESSR_e_EMStrtAlgo == ((uint32)VeESSR_e_EngStrtProfType_DS)) ||
             (((uint32)VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo))
    {
        /* Outputs for IfAction SubSystem: '<S1023>/EMStrt' incorporates:
         *  ActionPort: '<S1096>/Action Port'
         */
        /* DataStoreWrite: '<S1023>/Dsw_EngStrtType1' incorporates:
         *  Constant: '<S1155>/Constant'
         *  SignalConversion generated from: '<S1096>/Out1'
         */
        VeESSR_e_TCM_StartStopType_DS = CeESSR_e_EMStrt;

        /* End of Outputs for SubSystem: '<S1023>/EMStrt' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1023>/P1Strt' incorporates:
         *  ActionPort: '<S1141>/Action Port'
         */
        /* DataStoreWrite: '<S1023>/Dsw_EngStrtType1' incorporates:
         *  Constant: '<S1171>/Constant'
         *  SignalConversion generated from: '<S1141>/Out1'
         */
        VeESSR_e_TCM_StartStopType_DS = CeESSR_e_NormalStart;

        /* End of Outputs for SubSystem: '<S1023>/P1Strt' */
    }

    /* End of If: '<S1023>/If1' */

    /* DataStoreWrite: '<S1023>/Dsw_InitEngAng720' */
    VeESSR_phi_InitEngAng720_DS = rtu_VeEPCR_phi_EngAngle720Est;

    /* If: '<S1023>/If2' incorporates:
     *  DataStoreRead: '<S1023>/Dsr_EngStrtType'
     *  RelationalOperator: '<S1023>/Comparison6'
     */
    if (((sint32)VeESSR_e_EngStrtProfType_DS) == 1)
    {
        /* Outputs for IfAction SubSystem: '<S1023>/AStrt' incorporates:
         *  ActionPort: '<S1089>/Action Port'
         */
        /* DataStoreWrite: '<S1023>/Data Store Write' incorporates:
         *  Constant: '<S1143>/Calib'
         *  Merge: '<S1023>/Merge3'
         *  SignalConversion generated from: '<S1089>/Out1'
         */
        VeESSR_e_EngStrtActuatorTyp = KeESSR_e_EngStartActrType;

        /* End of Outputs for SubSystem: '<S1023>/AStrt' */
    }
    else if (((sint32)VeESSR_e_EngStrtProfType_DS) == 2)
    {
        /* Outputs for IfAction SubSystem: '<S1023>/LowPower' incorporates:
         *  ActionPort: '<S1138>/Action Port'
         */
        /* DataStoreWrite: '<S1023>/Data Store Write' */
        ESSR_ac_LowPower((&(VeESSR_e_EngStrtActuatorTyp)));

        /* End of Outputs for SubSystem: '<S1023>/LowPower' */
    }
    else if (((sint32)VeESSR_e_EngStrtProfType_DS) == 3)
    {
        /* Outputs for IfAction SubSystem: '<S1023>/KeyCrank' incorporates:
         *  ActionPort: '<S1137>/Action Port'
         */
        /* DataStoreWrite: '<S1023>/Data Store Write' */
        ESSR_ac_LowPower((&(VeESSR_e_EngStrtActuatorTyp)));

        /* End of Outputs for SubSystem: '<S1023>/KeyCrank' */
    }
    else if ((((((sint32)VeESSR_e_EngStrtProfType_DS) == 4) || (((sint32)
                 VeESSR_e_EngStrtProfType_DS) == 5)) || (((sint32)
                VeESSR_e_EngStrtProfType_DS) == 6)) || (((sint32)
               VeESSR_e_EngStrtProfType_DS) == 7))
    {
        /* Outputs for IfAction SubSystem: '<S1023>/P1P2p5_starts' incorporates:
         *  ActionPort: '<S1140>/Action Port'
         */
        /* DataStoreWrite: '<S1023>/Data Store Write' incorporates:
         *  Constant: '<S1170>/Constant'
         *  Merge: '<S1023>/Merge3'
         *  SignalConversion generated from: '<S1140>/Out1'
         */
        VeESSR_e_EngStrtActuatorTyp = CeESSR_e_P2;

        /* End of Outputs for SubSystem: '<S1023>/P1P2p5_starts' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1023>/Default' incorporates:
         *  ActionPort: '<S1093>/Action Port'
         */
        /* DataStoreWrite: '<S1023>/Data Store Write' incorporates:
         *  Constant: '<S1147>/Constant'
         *  Merge: '<S1023>/Merge3'
         *  SignalConversion generated from: '<S1093>/Out1'
         */
        VeESSR_e_EngStrtActuatorTyp = CeESSR_e_NoActTyp;

        /* End of Outputs for SubSystem: '<S1023>/Default' */
    }

    /* End of If: '<S1023>/If2' */

    /* Switch: '<S1023>/Switch3' incorporates:
     *  Constant: '<S1023>/Constant Value1'
     *  Constant: '<S1128>/Calib'
     *  DataStoreWrite: '<S1023>/Data Store Write1'
     */
    if (!HeESSR_b_EngStrtTorq)
    {
        VeESSR_M_EngStrtTorq_DS = 0.0F;
    }

    /* End of Switch: '<S1023>/Switch3' */

    /* DataStoreWrite: '<S1023>/Dsw_InputAcceltnProf1' incorporates:
     *  Constant: '<S1023>/Constant Value1'
     */
    VeESSR_dn_InputAcceltnProf_DS = 0.0F;

    /* DataStoreWrite: '<S1023>/Dsw_InputSpeedProfile1' incorporates:
     *  Constant: '<S1023>/Constant Value1'
     */
    VeESSR_n_InputSpeedProfile_DS = 0.0F;

    /* DataStoreWrite: '<S1023>/Dsw_InputTorqEst' incorporates:
     *  Constant: '<S1023>/Constant Value1'
     */
    VeESSR_M_EngTorqEst_DS = 0.0F;

    /* DataStoreWrite: '<S1023>/Dsw_TorqCancelGain' incorporates:
     *  Constant: '<S1023>/Constant Value2'
     */
    VeESSR_k_TorqCancelGain_DS = 0.0F;

    /* DataStoreWrite: '<S1023>/Dsw_EngStartStopSt' incorporates:
     *  Constant: '<S1097>/Constant'
     */
    VeESSR_e_EngStartStopSt_DS = CeESSR_e_InitEngSpinSt;

    /* DataStoreWrite: '<S1023>/Dsw_EngStrtType2' incorporates:
     *  Constant: '<S1120>/Constant'
     */
    VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Cranking;

    /* DataStoreWrite: '<S1023>/Dsw_EngTrqRespType' incorporates:
     *  DataStoreRead: '<S1023>/VeESSR_e_StrtStpTypEngTorqRespType_DS'
     */
    VeESSR_e_EngTrqRespType_DS = VeESSR_e_StrtStpTypEngTorqRespType_DS;

    /* DataStoreWrite: '<S1023>/Dsw_InhibitShiftToMode' incorporates:
     *  Constant: '<S1132>/Calib'
     */
    VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtInitSpinSt;

    /* DataStoreWrite: '<S1023>/Dsw_InputSpeedProfile2' incorporates:
     *  Constant: '<S1134>/Calib'
     */
    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

    /* DataStoreWrite: '<S1023>/Dsw_StrtStpFailDTC' incorporates:
     *  Constant: '<S1098>/Constant'
     */
    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

    /* DataStoreWrite: '<S1023>/Dsw_TransFldPmpSel' incorporates:
     *  Constant: '<S1133>/Calib'
     */
    VeESSR_e_TransFldPmpSel_DS = KeESSR_e_TransFldPmpSelInitEngSpinSt;

    /* Logic: '<S1023>/Logical6' incorporates:
     *  Constant: '<S1123>/Calib'
     *  Constant: '<S1125>/Calib'
     *  Constant: '<S1126>/Calib'
     *  Logic: '<S1023>/Logical12'
     *  Logic: '<S1023>/Logical13'
     *  Logic: '<S1023>/Logical8'
     */
    VeESSR_b_StrtTypChngDisbl = ((rtb_Logical1_nr &&
        (((HeESSR_b_BumpStrtEquipped) || (HeESSR_b_12vStrtrEquipped)) ||
         (HeESSR_b_CltchStrtEquipped))) || ((HeESSR_b_CltchStrtEquipped) &&
        rtb_Logical10));
}

#endif

/* Output and update for function-call system: '<S565>/SpinUpEng_SFS_Ent' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpinUpEng_SFS_Ent(void)
{
    /* DataStoreWrite: '<S1414>/Dsw_EngStartStopSt' incorporates:
     *  Constant: '<S1546>/Constant'
     */
    VeESSR_e_EngStartStopSt_DS = CeESSR_e_SpinUpAutoStrtSt;

    /* Switch: '<S1414>/Switch2' incorporates:
     *  Constant: '<S1414>/Constant Value3'
     *  Constant: '<S1551>/Calib'
     *  DataStoreWrite: '<S1414>/Data Store Write1'
     */
    if (!HeESSR_b_EngStrtTorq)
    {
        VeESSR_M_EngStrtTorq_DS = 0.0F;
    }

    /* End of Switch: '<S1414>/Switch2' */

    /* If: '<S1414>/If' incorporates:
     *  DataStoreRead: '<S1414>/Dsr_CompressTstOn'
     */
    if (VeESSR_b_CompressTstOn_DS)
    {
        /* Outputs for IfAction SubSystem: '<S1414>/MdInCompTst' incorporates:
         *  ActionPort: '<S1560>/Action Port'
         */
        /* DataStoreWrite: '<S1414>/Dsw_EngStrtStpMd2' incorporates:
         *  Constant: '<S1562>/Constant'
         *  SignalConversion generated from: '<S1560>/ModeInAutoSt'
         */
        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_CompressionTest;

        /* End of Outputs for SubSystem: '<S1414>/MdInCompTst' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1414>/MdInAutoStrt' incorporates:
         *  ActionPort: '<S1559>/Action Port'
         */
        /* DataStoreWrite: '<S1414>/Dsw_EngStrtStpMd2' incorporates:
         *  Constant: '<S1561>/Constant'
         *  SignalConversion generated from: '<S1559>/ModeInAutoSt'
         */
        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_StartPending;

        /* End of Outputs for SubSystem: '<S1414>/MdInAutoStrt' */
    }

    /* End of If: '<S1414>/If' */

    /* Switch: '<S1414>/Switch1' incorporates:
     *  Constant: '<S1550>/Calib'
     *  Constant: '<S1557>/Calib'
     *  DataStoreWrite: '<S1414>/Dsw_AEMDMtrBGain'
     */
    if (HeESSR_b_AEMDMtrBGain)
    {
        VeESSR_scl_AEMDMtrBGain_DS = KeESSR_scl_AEMDMtrBGain_SpnUpAutoSt;
    }

    /* End of Switch: '<S1414>/Switch1' */

    /* DataStoreWrite: '<S1414>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
     *  Constant: '<S1552>/Calib'
     */
    VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

    /* DataStoreWrite: '<S1414>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
     *  Constant: '<S1553>/Calib'
     */
    VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

    /* DataStoreWrite: '<S1414>/Dsw_EngStrtType1' incorporates:
     *  Constant: '<S1548>/Constant'
     */
    VeESSR_e_TCM_StartStopType_DS = CeESSR_e_NormalStart;

    /* DataStoreWrite: '<S1414>/Dsw_EngStrtType2' incorporates:
     *  Constant: '<S1549>/Constant'
     */
    VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Cranking;

    /* DataStoreWrite: '<S1414>/Dsw_EngTrqRespType' incorporates:
     *  DataStoreRead: '<S1414>/VeESSR_e_StrtStpTypEngTorqRespType_DS'
     */
    VeESSR_e_EngTrqRespType_DS = VeESSR_e_StrtStpTypEngTorqRespType_DS;

    /* DataStoreWrite: '<S1414>/Dsw_InhibitShiftToMode' incorporates:
     *  Constant: '<S1554>/Calib'
     */
    VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtSpnUpAutoSt;

    /* DataStoreWrite: '<S1414>/Dsw_InputSpeedProfile1' incorporates:
     *  Constant: '<S1556>/Calib'
     */
    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

    /* DataStoreWrite: '<S1414>/Dsw_StrtStpFailDTC' incorporates:
     *  Constant: '<S1547>/Constant'
     */
    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

    /* DataStoreWrite: '<S1414>/Dsw_TransFldPmpSel' incorporates:
     *  Constant: '<S1555>/Calib'
     */
    VeESSR_e_TransFldPmpSel_DS = KeESSR_e_TransFldPmpSelSpinUpAutoStrtSt;
}

#endif

/*
 * Output and update for action system:
 *    '<S1418>/If_AutoStrt_P1C65'
 *    '<S928>/If_ColdCrank_P1C65'
 *    '<S1734>/If_AutoStrt_P1C65'
 *    '<S1769>/If_AutoStrt_P1C65'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_If_AutoStrt_P1C65(P2VAR
    (TeESSR_e_StrtStpFailDTC, AUTOMATIC, ESSR_VAR_INIT) rty_Out1)
{
    /* SignalConversion generated from: '<S1461>/Out1' incorporates:
     *  Constant: '<S1484>/Constant'
     */
    *rty_Out1 = CeESSR_e_P1C65;
}

#endif

/*
 * Output and update for action system:
 *    '<S1418>/If_AutoStrt_NoFault'
 *    '<S928>/If_ColdCrank_NoFault'
 *    '<S1734>/If_AutoStrt_NoFault'
 *    '<S1769>/If_AutoStrt_NoFault'
 *    '<S2639>/If_PrepForStop_NoFault'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_If_AutoStrt_NoFault(P2VAR
    (TeESSR_e_StrtStpFailDTC, AUTOMATIC, ESSR_VAR_INIT) rty_Out1)
{
    /* SignalConversion generated from: '<S1460>/Out1' incorporates:
     *  Constant: '<S1483>/Constant'
     */
    *rty_Out1 = CeESSR_e_NoFault;
}

#endif

/* System initialize for function-call system: '<S565>/SpinUpEng_SFS_Dur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpinUpEng_SFS_Dur_Init(P2VAR
    (DW_SpinUpEng_SFS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW)
{
    /* InitializeConditions for Delay: '<S1501>/IntegerDelay' */
    localDW->icLoad = 1U;
}

#endif

/* Output and update for function-call system: '<S565>/SpinUpEng_SFS_Dur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpinUpEng_SFS_Dur(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_AddtlDragTorq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_TransInSpdFlt, VAR(float32, AUTOMATIC) rtu_VeESSR_n_OptInputSpd,
    VAR(float32, AUTOMATIC) rtu_VeETQR_M_EngCapacityMinRunI, VAR(float32,
    AUTOMATIC) rtu_VeCSVR_n_PrimNoSgndFltrd, VAR(float32, AUTOMATIC)
    rtu_VeESPR_n_MaxEngSpdCap, VAR(TeENGR_e_Cam_Phsr_Stat, AUTOMATIC)
    rtu_VeENGR_e_Cam_Phsr_Stat, VAR(float32, AUTOMATIC) rtu_BatVoltModMin, VAR
    (float32, AUTOMATIC) rtu_VeETQR_M_EngTrqActual, VAR(float32, AUTOMATIC)
    rtu_VeETQR_r_MaxSparkAuthority, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngineLosses, VAR(boolean, AUTOMATIC)
    rtu_VeSTRR_b_BackupStrtEngOn, VAR(float32, AUTOMATIC)
    rtu_VeENGR_p_EngManfldAbsPrs, VAR(boolean, AUTOMATIC)
    rtu_VeRTMR_b_InPlantMode, VAR(boolean, AUTOMATIC) rtu_PosSlipDtcdLtch4STRR,
    VAR(boolean, AUTOMATIC) rtu_VeBCPR_b_PosSlipDetected, VAR(float32, AUTOMATIC)
    rtu_VeTISR_n_NiFromMtr, VAR(float32, AUTOMATIC) rtu_VeOHSR_n_IdleSpdBlended,
    VAR(boolean, AUTOMATIC) rtu_VeSTRR_b_BumpStrtEngOn, VAR(float32, AUTOMATIC)
    rtu_VeHSER_n_NiMax, VAR(float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMax, VAR
    (float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMin, VAR(boolean, AUTOMATIC)
    rtu_VeSTRR_b_BumpStrtInhbt, VAR(boolean, AUTOMATIC) rtu_ErlyExitLmp, VAR
    (boolean, AUTOMATIC) rtu_LwrThresLmp, VAR(float32, AUTOMATIC) rtu_HTDR_TiMin,
    VAR(float32, AUTOMATIC) rtu_EngTrqAirflow, VAR(boolean, AUTOMATIC)
    rtu_PNLimActv, VAR(float32, AUTOMATIC) rtu_PNLimTrq, VAR(float32, AUTOMATIC)
    rtu_TactTiMin, VAR(boolean, AUTOMATIC) rtu_REEV_GasFlowActr, P2VAR
    (DW_SpinUpEng_SFS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR
    (ZCE_SpinUpEng_SFS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localZCE, P2VAR
    (uint32, AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_g_StrtStpFailRsn, P2VAR(uint32,
    AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_g_StrtStpFailRsn2, P2VAR(float32,
    AUTOMATIC, ESSR_VAR_INIT) rtd_VeESSR_t_StrtTypGasFlwActrD)
{
    sint32 i;
    float32 rtb_Abs2_h;
    float32 rtb_Gain_k;
    float32 rtb_Gain_lw;
    float32 rtb_IntegerDelay;
    float32 rtb_MinMax1_cn;
    float32 rtb_Product2_jm;
    float32 rtb_Product4;
    float32 rtb_Product4_j;
    float32 rtb_Sum15;
    float32 rtb_Sum1_ih;
    float32 rtb_Sum2_h5z;
    float32 rtb_Sum6_do;
    float32 rtb_Switch1_cqe;
    float32 rtb_Switch1_gd;
    float32 rtb_Switch1_l3;
    float32 rtb_Switch_kx;
    float32 rtb_UnitDelay_fx;
    TeESSR_e_STMTrigger rtb_Merge1_d;
    TeESSR_e_STMTrigger rtb_Merge2_h;
    TeESSR_e_STMTrigger rtb_Merge5_n;
    uint8 tmp;
    boolean VeESSR_b_ActvBeltSlpCtrlCndnsSe;
    boolean rtb_Equal2_p3;
    boolean rtb_GreaterThan3_b;
    boolean rtb_GreaterThan_kf;
    boolean rtb_Logical8_gu;
    boolean rtb_LogicalOperator21;
    boolean rtb_LogicalOperator21_tmp;
    boolean rtb_LogicalOperator3_ap;
    boolean rtb_LogicalOperator4_ou;
    boolean rtb_LogicalOperator5_ml;
    boolean rtb_OR1_fs;
    boolean rtb_OR2_p;
    boolean rtb_OR3;
    boolean rtb_OR_dp;
    boolean rtb_Switch13_p;

    /* RelationalOperator: '<S1413>/Equal2' incorporates:
     *  Constant: '<S1421>/Calib'
     *  DataStoreRead: '<S1413>/Dsr_STMTmr'
     */
    rtb_Equal2_p3 = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

    /* Outputs for Atomic SubSystem: '<S1413>/Digital Lowpass Reset Enabled' */
    /* Switch: '<S1416>/Switch1' */
    if (rtb_Equal2_p3)
    {
        /* Switch: '<S1416>/Switch1' incorporates:
         *  DataStoreRead: '<S1413>/Dsr_InputSpeedProfile7'
         */
        VeESSR_M_SpinUpISpdCtl = VeESSR_M_EngTorqEst_DS;
    }
    else
    {
        /* Switch: '<S1416>/Switch1' incorporates:
         *  Constant: '<S1424>/Calib'
         *  Product: '<S1416>/Multiplication'
         *  Sum: '<S1413>/Sum1'
         *  Sum: '<S1416>/Subtraction'
         *  Sum: '<S1416>/Summation'
         *  UnitDelay: '<S1416>/Unit Delay'
         */
        VeESSR_M_SpinUpISpdCtl = (((rtu_VeESSR_M_EngTrqAct_Lmtd -
            rtu_VeESSR_M_AddtlDragTorq) - VeESSR_M_SpinUpISpdCtl) *
            KeESSR_K_TiEstBlndSFS) + VeESSR_M_SpinUpISpdCtl;
    }

    /* End of Switch: '<S1416>/Switch1' */
    /* End of Outputs for SubSystem: '<S1413>/Digital Lowpass Reset Enabled' */

    /* DataStoreWrite: '<S1413>/Data Store Write' */
    VeESSR_M_TiEstP1fOpLp = VeESSR_M_SpinUpISpdCtl;

    /* MinMax: '<S1413>/MinMax4' */
    rtb_UnitDelay_fx = fmaxf(rtu_PNLimTrq, rtu_TactTiMin);

    /* Switch: '<S1413>/Switch' */
    if (rtu_PNLimActv)
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = rtb_UnitDelay_fx;
    }
    else
    {
        /* Switch: '<S1545>/Switch1' incorporates:
         *  Constant: '<S1413>/Constant Value2'
         */
        rtb_Switch1_gd = 9999.0F;
    }

    /* End of Switch: '<S1413>/Switch' */

    /* MinMax: '<S1413>/MinMax' incorporates:
     *  DataStoreRead: '<S1413>/Dsr_InputSpeedProfile2'
     *  DataStoreRead: '<S1413>/Dsr_StrtTypInitImmedTorq'
     *  DataStoreWrite: '<S1413>/Dsw_EngTrqReqImmed'
     *  Sum: '<S1413>/Summation2'
     */
    VeESSR_M_EngTrqReqImmed_DS = fminf(fminf(VeESSR_M_StrtTypInitImmedTorq_DS,
        rtu_VeETQR_M_EngTrqActual + VeESSR_M_MinImmedExitTorqDelta_DS),
        rtb_Switch1_gd);

    /* MinMax: '<S1413>/MinMax1' incorporates:
     *  DataStoreRead: '<S1413>/Dsr_InputSpeedProfile3'
     *  DataStoreRead: '<S1413>/Dsr_StrtTypInitPredTorq'
     *  DataStoreWrite: '<S1413>/Dsw_EngTrqReqPrdtd1'
     *  Product: '<S1413>/Product'
     *  Sum: '<S1413>/Summation3'
     *  Sum: '<S1413>/Summation4'
     */
    VeESSR_M_EngTrqReqPrdtd_DS = fminf(fminf(rtb_Switch1_gd,
        VeESSR_M_StrtTypInitPredTorq_DS), ((VeESSR_M_EngTrqReqImmed_DS +
        rtu_VeETQR_M_EngineLosses) * rtu_VeETQR_r_MaxSparkAuthority) -
        rtu_VeETQR_M_EngineLosses);

    /* MinMax: '<S1431>/MinMax' incorporates:
     *  DataStoreRead: '<S1413>/Dsr_NiProfGenNiDMax'
     *  DataStoreRead: '<S1431>/Data Store Read'
     *  Lookup_n-D: '<S1495>/Vector'
     */
    VeESSR_dn_NiDotMaxShaped = fminf(look1_iflf_binlcapw(VeESSR_t_STMTmr_DS, ((
        const float32 *)&(KxESSR_dn_TrajectoryNidot[0])), ((const float32 *)
        &(KtESSR_dn_TrajectoryNidot[0])), 6U), VeESSR_dn_StrtTypNiDotMax_DS);

    /* Sum: '<S1431>/Sum' incorporates:
     *  Constant: '<S1493>/Calib'
     *  DataStoreRead: '<S1431>/Dsr_InputAcceltnProf'
     *  DataStoreRead: '<S1431>/Dsr_InputSpeedProfile1'
     *  Product: '<S1431>/Product'
     */
    VeESSR_n_InputSpdLead_SpinUp = (VeESSR_dn_InputAcceltnProf_DS *
        KeESSR_t_NiDotLimNiProfLead) + VeESSR_n_InputSpeedProfile_DS;

    /* Sum: '<S1431>/Sum1' incorporates:
     *  Constant: '<S1431>/Constant Value2'
     *  DataStoreRead: '<S1431>/Dsr_InputTorqEst'
     *  Lookup_n-D: '<S1494>/Vector'
     *  Product: '<S1431>/Product1'
     */
    rtb_Sum1_ih = ((VeESSR_M_EngTorqEst_DS * 0.0001F) *
                   VeESSR_n_InputSpdLead_SpinUp) + look1_iflf_binlcapw
        (rtu_VeCSVR_n_PrimNoSgndFltrd, ((const float32 *)
          &(KxESSR_P_NiDotLimPowerLim[0])), ((const float32 *)
          &(KtESSR_P_NiDotLimPowerLim[0])), 2U);

    /* Product: '<S1431>/Product2' incorporates:
     *  Constant: '<S1492>/Calib'
     */
    rtb_Product2_jm = VeESSR_n_InputSpdLead_SpinUp * KeESSR_K_NiDotLimEffInertia;

    /* Outputs for Atomic SubSystem: '<S1431>/Protected Division' */
    /* Switch: '<S1498>/Switch1' incorporates:
     *  Constant: '<S1498>/Constant Value'
     *  Constant: '<S1498>/Constant Value1'
     *  Constant: '<S1498>/Constant Value2'
     *  Constant: '<S1498>/Constant Value3'
     *  Logic: '<S1498>/AND'
     *  RelationalOperator: '<S1498>/Greater Than or Equal '
     *  RelationalOperator: '<S1498>/Greater Than or Equal 1'
     *  RelationalOperator: '<S1498>/Not Equal'
     *  RelationalOperator: '<S1498>/Not Equal1'
     *  Switch: '<S1498>/Switch2'
     *  Switch: '<S1498>/Switch3'
     */
    if ((rtb_Sum1_ih != 0.0F) && (rtb_Product2_jm != 0.0F))
    {
        /* Switch: '<S1498>/Switch1' incorporates:
         *  Product: '<S1498>/Division'
         */
        rtb_Sum1_ih /= rtb_Product2_jm;
    }
    else if (rtb_Sum1_ih > 0.0F)
    {
        /* Switch: '<S1498>/Switch2' incorporates:
         *  Constant: '<S1498>/MAXFLOAT'
         *  Switch: '<S1498>/Switch1'
         */
        rtb_Sum1_ih = 3.402823466E+38F;
    }
    else if (rtb_Sum1_ih < 0.0F)
    {
        /* Switch: '<S1498>/Switch3' incorporates:
         *  Constant: '<S1498>/MINFLOAT'
         *  Switch: '<S1498>/Switch1'
         *  Switch: '<S1498>/Switch2'
         */
        rtb_Sum1_ih = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1498>/Switch1' incorporates:
         *  Constant: '<S1498>/Constant Value4'
         *  Switch: '<S1498>/Switch2'
         *  Switch: '<S1498>/Switch3'
         */
        rtb_Sum1_ih = 0.0F;
    }

    /* End of Switch: '<S1498>/Switch1' */
    /* End of Outputs for SubSystem: '<S1431>/Protected Division' */

    /* Outputs for Atomic SubSystem: '<S1431>/Limiter1' */
    /* Switch: '<S1496>/Switch1' incorporates:
     *  RelationalOperator: '<S1496>/Relational Operator'
     */
    if (VeESSR_dn_NiDotMaxShaped < rtb_Sum1_ih)
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = VeESSR_dn_NiDotMaxShaped;
    }
    else
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = rtb_Sum1_ih;
    }

    /* End of Switch: '<S1496>/Switch1' */

    /* Switch: '<S1496>/Switch' incorporates:
     *  Constant: '<S1431>/Constant Value1'
     *  RelationalOperator: '<S1496>/Relational Operator1'
     */
    if (rtb_Switch1_gd > 300.0F)
    {
        /* Switch: '<S1496>/Switch' */
        VeESSR_dn_NiDotMax_SpinUp = rtb_Switch1_gd;
    }
    else
    {
        /* Switch: '<S1496>/Switch' */
        VeESSR_dn_NiDotMax_SpinUp = 300.0F;
    }

    /* End of Switch: '<S1496>/Switch' */
    /* End of Outputs for SubSystem: '<S1431>/Limiter1' */

    /* Gain: '<S1433>/Gain' incorporates:
     *  Abs: '<S1433>/Abs1'
     *  DataStoreRead: '<S1413>/Dsr_NiProfGenDNiDLim1'
     */
    rtb_Gain_lw = -fabsf(VeESSR_dn_StrtTypJerkMin_DS);

    /* Product: '<S1501>/Product4' incorporates:
     *  Constant: '<S1421>/Calib'
     */
    rtb_Product4 = rtb_Gain_lw / HeESSR_t_MedTEB_dT;

    /* If: '<S1413>/If' incorporates:
     *  DataStoreRead: '<S1413>/Dsr_CompressTstOn'
     *  Switch: '<S1418>/Switch9'
     */
    if (VeESSR_b_CompressTstOn_DS)
    {
        /* Outputs for IfAction SubSystem: '<S1413>/ESSC_ChkCompressTst' incorporates:
         *  ActionPort: '<S1417>/Action Port'
         */
        /* Merge: '<S1413>/Merge' incorporates:
         *  Inport: '<S1417>/MaxEngSpdCap'
         */
        VeESSR_n_NiTargetSpinUp = rtu_VeESPR_n_MaxEngSpdCap;

        /* Merge: '<S1432>/Merge' incorporates:
         *  Constant: '<S1438>/Calib'
         *  DataStoreRead: '<S1417>/Dsr_STMTmr2'
         *  RelationalOperator: '<S1417>/Greater  Than1'
         */
        rtb_GreaterThan_kf = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxCompressTm);

        /* Merge: '<S1432>/Merge1' incorporates:
         *  Constant: '<S1435>/Constant'
         *  SignalConversion generated from: '<S1417>/NormalExitTrigger'
         */
        rtb_Merge1_d = CeESSR_e_StartAbort;

        /* Merge: '<S1432>/Merge3' incorporates:
         *  Constant: '<S1417>/FALSE Constant'
         *  SignalConversion generated from: '<S1417>/CoastDownExitFlag'
         */
        rtb_Logical8_gu = false;

        /* Merge: '<S1432>/Merge2' incorporates:
         *  Constant: '<S1436>/Constant'
         *  SignalConversion generated from: '<S1417>/CoastDownExitTrigger'
         */
        rtb_Merge2_h = CeESSR_e_Inactive;

        /* Merge: '<S1432>/Merge4' incorporates:
         *  Constant: '<S1417>/FALSE Constant1'
         *  SignalConversion generated from: '<S1417>/TimeOutExitFlag'
         */
        rtb_GreaterThan3_b = false;

        /* Merge: '<S1432>/Merge5' incorporates:
         *  Constant: '<S1437>/Constant'
         *  SignalConversion generated from: '<S1417>/TimeOutExitTrigger'
         */
        rtb_Merge5_n = CeESSR_e_Inactive;

        /* End of Outputs for SubSystem: '<S1413>/ESSC_ChkCompressTst' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1413>/ESSC_ChkSpinUpEng_SFS' incorporates:
         *  ActionPort: '<S1418>/Action Port'
         */
        if (rtu_LwrThresLmp)
        {
            /* Switch: '<S1418>/Switch9' incorporates:
             *  Constant: '<S1472>/Calib'
             */
            rtb_Product2_jm = KeESSR_n_LmpHmSpinUpExtSpd;
        }
        else
        {
            /* Switch: '<S1418>/Switch9' incorporates:
             *  DataStoreRead: '<S1418>/Dsr_AStrtSpinUpExtSpd'
             */
            rtb_Product2_jm = VeESSR_n_StrtTypAStrtSpinUpExtSpd_DS;
        }

        /* RelationalOperator: '<S1418>/Greater  Than' */
        rtb_GreaterThan_kf = (rtu_VeESSR_n_TransInSpdFlt > rtb_Product2_jm);

        /* RelationalOperator: '<S1418>/Greater  Than3' incorporates:
         *  Constant: '<S1475>/Calib'
         *  DataStoreRead: '<S1418>/Dsr_STMTmr1'
         */
        rtb_GreaterThan3_b = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmSpinUp_SFS);

        /* Logic: '<S1418>/Logical8' */
        rtb_Logical8_gu = (rtu_VeSTRR_b_BumpStrtEngOn ||
                           rtu_VeSTRR_b_BumpStrtInhbt);

        /* Logic: '<S1418>/Logical1' incorporates:
         *  Logic: '<S1418>/Logical4'
         */
        VeESSR_b_ActvBeltSlpCtrlCndnsSe = (rtb_Logical8_gu ||
            rtu_VeSTRR_b_BackupStrtEngOn);

        /* Logic: '<S1418>/Logical Operator23' incorporates:
         *  Constant: '<S1467>/Calib'
         *  Logic: '<S1418>/Logical1'
         */
        VeESSR_b_ActvBeltSlpCtrlCndnsSet = ((VeESSR_b_ActvBeltSlpCtrlCndnsSe &&
            rtu_PosSlipDtcdLtch4STRR) && (KeESSR_b_EnblActvBeltSlpCtrl));

        /* Logic: '<S1418>/Logical10' incorporates:
         *  Logic: '<S1418>/Logical Operator25'
         *  Logic: '<S1418>/Logical Operator28'
         *  Logic: '<S1418>/Logical Operator30'
         */
        rtb_LogicalOperator21_tmp = !VeESSR_b_ActvBeltSlpCtrlCndnsSet;

        /* Logic: '<S1418>/Logical Operator21' incorporates:
         *  Logic: '<S1418>/Logical Operator27'
         *  Logic: '<S1418>/Logical10'
         */
        rtb_LogicalOperator21 = ((!rtu_LwrThresLmp) && rtb_LogicalOperator21_tmp);

        /* Logic: '<S1418>/Logical Operator3' incorporates:
         *  Logic: '<S1418>/Logical Operator'
         */
        rtb_LogicalOperator3_ap = (((!rtb_GreaterThan_kf) && rtb_GreaterThan3_b)
            && rtb_LogicalOperator21);

        /* Switch: '<S1418>/Switch' */
        if (rtb_LogicalOperator3_ap)
        {
            /* DataStoreWrite: '<S1418>/Data Store Write' incorporates:
             *  S-Function (sfix_bitop): '<S1440>/FixPt Bitwise Operator1'
             *  Switch: '<S1418>/Switch'
             */
            *rtd_NeESSR_g_StrtStpFailRsn |= 32U;
        }

        /* End of Switch: '<S1418>/Switch' */

        /* Logic: '<S1418>/OR' incorporates:
         *  Constant: '<S1464>/Calib'
         *  DataStoreRead: '<S1418>/Dsr_InputSpeedProfile2'
         *  DataStoreRead: '<S1418>/Dsr_STMTmr2'
         *  DataStoreRead: '<S1418>/Dsr_StrtTypMapTargetMaxTm'
         *  Logic: '<S1418>/Logical Operator6'
         *  RelationalOperator: '<S1418>/Greater  Than1'
         *  RelationalOperator: '<S1418>/Greater  Than2'
         *  RelationalOperator: '<S1418>/Greater  Than6'
         */
        rtb_OR_dp = (((rtu_VeETQR_M_EngCapacityMinRunI <=
                       VeESSR_M_EngTrqReqImmed_DS) || ((VeESSR_t_STMTmr_DS >
                        VeESSR_t_StrtTypAirflowTrqMaxTm_DS) ||
                       rtb_GreaterThan3_b)) || (rtu_BatVoltModMin <
                      KeESSR_U_BatVoltModMin_ExitSpin));

        /* Logic: '<S1418>/Logical Operator4' incorporates:
         *  Logic: '<S1418>/Logical Operator1'
         */
        rtb_LogicalOperator4_ou = (((!rtb_OR_dp) && rtb_GreaterThan3_b) &&
            rtb_LogicalOperator21);

        /* Switch: '<S1418>/Switch2' */
        if (rtb_LogicalOperator4_ou)
        {
            /* DataStoreWrite: '<S1418>/Data Store Write1' incorporates:
             *  S-Function (sfix_bitop): '<S1441>/FixPt Bitwise Operator1'
             *  Switch: '<S1418>/Switch2'
             */
            *rtd_NeESSR_g_StrtStpFailRsn |= 64U;
        }

        /* End of Switch: '<S1418>/Switch2' */

        /* Switch: '<S1418>/Switch13' incorporates:
         *  Constant: '<S1457>/Calib'
         */
        if (HeESSR_b_ReevEquipped)
        {
            /* Switch: '<S1418>/Switch13' incorporates:
             *  DataStoreRead: '<S1418>/Dsr_STMTmr6'
             *  Logic: '<S1418>/OR4'
             *  RelationalOperator: '<S1418>/Greater  Than17'
             */
            rtb_Switch13_p = (rtu_REEV_GasFlowActr || (VeESSR_t_STMTmr_DS >
                               (*rtd_VeESSR_t_StrtTypGasFlwActrD)));
        }
        else
        {
            /* Switch: '<S1418>/Switch13' incorporates:
             *  Constant: '<S1418>/TRUE Constant1'
             */
            rtb_Switch13_p = true;
        }

        /* End of Switch: '<S1418>/Switch13' */

        /* Switch: '<S1418>/Switch12' incorporates:
         *  Logic: '<S1418>/Logical Operator7'
         *  Logic: '<S1418>/Logical Operator8'
         */
        if ((!rtb_Switch13_p) && rtb_GreaterThan3_b)
        {
            /* DataStoreWrite: '<S1418>/Data Store Write10' incorporates:
             *  S-Function (sfix_bitop): '<S1449>/FixPt Bitwise Operator1'
             *  Switch: '<S1418>/Switch12'
             */
            *rtd_NeESSR_g_StrtStpFailRsn2 |= 1U;
        }

        /* End of Switch: '<S1418>/Switch12' */

        /* Logic: '<S1418>/OR1' incorporates:
         *  Constant: '<S1452>/Constant'
         *  DataStoreRead: '<S1418>/Dsr_STMTmr3'
         *  DataStoreRead: '<S1418>/Dsr_StrtTypMapTargetMaxTm1'
         *  Logic: '<S1418>/Logical Operator10'
         *  RelationalOperator: '<S1418>/Greater  Than4'
         *  RelationalOperator: '<S1418>/Greater  Than5'
         */
        rtb_OR1_fs = ((((uint32)rtu_VeENGR_e_Cam_Phsr_Stat) ==
                       CeENGR_e_NoPhasersParked) || ((VeESSR_t_STMTmr_DS >
                        VeESSR_t_StrtTypPhaserDelayTm_DS) || rtb_GreaterThan3_b));

        /* Logic: '<S1418>/Logical Operator5' incorporates:
         *  Logic: '<S1418>/Logical Operator2'
         */
        rtb_LogicalOperator5_ml = (((!rtb_OR1_fs) && rtb_GreaterThan3_b) &&
            rtb_LogicalOperator21);

        /* Switch: '<S1418>/Switch4' */
        if (rtb_LogicalOperator5_ml)
        {
            /* DataStoreWrite: '<S1418>/Data Store Write2' incorporates:
             *  S-Function (sfix_bitop): '<S1442>/FixPt Bitwise Operator1'
             *  Switch: '<S1418>/Switch4'
             */
            *rtd_NeESSR_g_StrtStpFailRsn |= 128U;
        }

        /* End of Switch: '<S1418>/Switch4' */

        /* Switch: '<S1418>/Switch1' incorporates:
         *  DataStoreRead: '<S1418>/Data Store Read1'
         *  DataStoreWrite: '<S1418>/Data Store Write3'
         *  S-Function (sfix_bitop): '<S1443>/FixPt Bitwise Operator1'
         */
        if (rtb_LogicalOperator3_ap)
        {
            VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS | 2U;
        }

        /* End of Switch: '<S1418>/Switch1' */

        /* Switch: '<S1418>/Switch3' incorporates:
         *  DataStoreRead: '<S1418>/Data Store Read7'
         *  DataStoreWrite: '<S1418>/Data Store Write4'
         *  S-Function (sfix_bitop): '<S1444>/FixPt Bitwise Operator1'
         */
        if (rtb_LogicalOperator4_ou)
        {
            VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS | 4U;
        }

        /* End of Switch: '<S1418>/Switch3' */

        /* Switch: '<S1418>/Switch5' incorporates:
         *  DataStoreRead: '<S1418>/Data Store Read10'
         *  DataStoreWrite: '<S1418>/Data Store Write5'
         *  S-Function (sfix_bitop): '<S1445>/FixPt Bitwise Operator1'
         */
        if (rtb_LogicalOperator5_ml)
        {
            VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS | 8U;
        }

        /* End of Switch: '<S1418>/Switch5' */

        /* Logic: '<S1418>/OR2' incorporates:
         *  DataStoreRead: '<S1418>/Dsr_STMTmr4'
         *  DataStoreRead: '<S1418>/Dsr_StrtTypAStrtSpinUpManPrs'
         *  DataStoreRead: '<S1418>/Dsr_StrtTypMapTargetMaxTm2'
         *  Logic: '<S1418>/Logical Operator16'
         *  RelationalOperator: '<S1418>/Greater  Than10'
         *  RelationalOperator: '<S1418>/Greater  Than9'
         */
        rtb_OR2_p = ((rtu_VeENGR_p_EngManfldAbsPrs <
                      VeESSR_p_StrtTypAStrtSpinUpManPrs_DS) ||
                     ((VeESSR_t_STMTmr_DS > VeESSR_t_StrtTypManPrsMaxTm_DS) ||
                      rtb_GreaterThan3_b));

        /* Logic: '<S1418>/Logical Operator21' incorporates:
         *  Logic: '<S1418>/Logical Operator19'
         */
        rtb_LogicalOperator21 = (((!rtb_OR2_p) && rtb_GreaterThan3_b) &&
            rtb_LogicalOperator21);

        /* Switch: '<S1418>/Switch6' incorporates:
         *  DataStoreRead: '<S1418>/Data Store Read16'
         *  DataStoreWrite: '<S1418>/Data Store Write8'
         *  S-Function (sfix_bitop): '<S1447>/FixPt Bitwise Operator1'
         *  Switch: '<S1418>/Switch7'
         */
        if (rtb_LogicalOperator21)
        {
            /* DataStoreWrite: '<S1418>/Data Store Write7' incorporates:
             *  S-Function (sfix_bitop): '<S1446>/FixPt Bitwise Operator1'
             *  Switch: '<S1418>/Switch6'
             */
            *rtd_NeESSR_g_StrtStpFailRsn |= 33554432U;
            VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS | 16U;
        }

        /* End of Switch: '<S1418>/Switch6' */

        /* Switch: '<S1418>/Switch10' incorporates:
         *  Constant: '<S1418>/TRUE Constant'
         *  Constant: '<S1458>/Calib'
         *  Logic: '<S1418>/Logical Operator32'
         *  RelationalOperator: '<S1418>/Greater  Than7'
         */
        if (rtu_PNLimActv && (HeESSR_b_SpinupAirflwChkEnbl))
        {
            rtb_OR3 = (rtu_EngTrqAirflow <= rtb_UnitDelay_fx);
        }
        else
        {
            rtb_OR3 = true;
        }

        /* End of Switch: '<S1418>/Switch10' */

        /* Logic: '<S1418>/OR3' incorporates:
         *  Constant: '<S1476>/Calib'
         *  DataStoreRead: '<S1418>/Dsr_STMTmr5'
         *  RelationalOperator: '<S1418>/Greater  Than16'
         */
        rtb_OR3 = (rtb_OR3 || (VeESSR_t_STMTmr_DS >
                               KeESSR_t_SpinupAirflwChkMaxTm));

        /* Switch: '<S1418>/Switch11' incorporates:
         *  Logic: '<S1418>/Logical Operator35'
         *  Logic: '<S1418>/Logical Operator36'
         */
        if ((!rtb_OR3) && rtb_GreaterThan3_b)
        {
            /* DataStoreWrite: '<S1418>/Data Store Write9' incorporates:
             *  S-Function (sfix_bitop): '<S1448>/FixPt Bitwise Operator1'
             *  Switch: '<S1418>/Switch11'
             */
            *rtd_NeESSR_g_StrtStpFailRsn |= 1073741824U;
        }

        /* End of Switch: '<S1418>/Switch11' */

        /* Logic: '<S1418>/Logical Operator13' incorporates:
         *  Constant: '<S1470>/Calib'
         *  Constant: '<S1473>/Calib'
         *  DataStoreWrite: '<S1418>/Dsw_AStrtFailed3'
         *  Logic: '<S1418>/Logical4'
         *  RelationalOperator: '<S1418>/Greater  Than8'
         */
        VeESSR_b_BackUpStartEng_DS = (((KeESSR_b_EnblFtrEarlyExitSpinUp) &&
            (VeESSR_b_ActvBeltSlpCtrlCndnsSe || rtu_ErlyExitLmp)) &&
            (rtu_VeESSR_n_TransInSpdFlt > KeESSR_n_MinSpdFuelOn));

        /* If: '<S1418>/If' */
        if (rtb_LogicalOperator3_ap)
        {
            /* Outputs for IfAction SubSystem: '<S1418>/If_AutoStrt_P1C65' incorporates:
             *  ActionPort: '<S1461>/Action Port'
             */
            /* DataStoreWrite: '<S1418>/Dsw_StrtStpFailDTC' */
            ESSR_ac_If_AutoStrt_P1C65((&(VeESSR_e_StrtStpFailDTC)));

            /* End of Outputs for SubSystem: '<S1418>/If_AutoStrt_P1C65' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S1418>/If_AutoStrt_NoFault' incorporates:
             *  ActionPort: '<S1460>/Action Port'
             */
            /* DataStoreWrite: '<S1418>/Dsw_StrtStpFailDTC' */
            ESSR_ac_If_AutoStrt_NoFault((&(VeESSR_e_StrtStpFailDTC)));

            /* End of Outputs for SubSystem: '<S1418>/If_AutoStrt_NoFault' */
        }

        /* End of If: '<S1418>/If' */

        /* RelationalOperator: '<S1418>/Equal1' incorporates:
         *  Constant: '<S1418>/Constant Value3'
         *  DataStoreRead: '<S1418>/Data Store Read13'
         *  DataStoreWrite: '<S1418>/Data Store Write6'
         */
        VeESSR_b_BSGStrtFailed_DS = (VeESSR_g_BSGStrtFailRsn_DS != 0U);

        /* Switch: '<S1454>/Switch' incorporates:
         *  Constant: '<S1481>/Calib'
         *  Constant: '<S1482>/Calib'
         *  Sum: '<S1454>/Sum1'
         */
        if (HeESSR_b_NiTrgtIdleSpdSpnUp)
        {
            rtb_Switch1_gd = rtu_VeOHSR_n_IdleSpdBlended - KeESSR_n_DeltaIdleSpd;
        }
        else
        {
            rtb_Switch1_gd = rtu_VeESSR_n_OptInputSpd;
        }

        /* End of Switch: '<S1454>/Switch' */

        /* Merge: '<S1413>/Merge' incorporates:
         *  DataStoreRead: '<S1454>/Dsr_MinEngStrtSpd'
         *  DataStoreRead: '<S1454>/Dsr_StrtNiNoFuel'
         *  MinMax: '<S1454>/Maximum'
         *  MinMax: '<S1454>/MinMax'
         */
        VeESSR_n_NiTargetSpinUp = fminf(fmaxf(rtb_Switch1_gd,
            VeESSR_n_MinEngStrtSpd_DS), VeESSR_n_StrtTypMaxStrtNiNoFuel_DS);

        /* Outputs for Atomic SubSystem: '<S1418>/Stop Watch Reset Enabled' */
        /* Switch: '<S1480>/Switch1' incorporates:
         *  Constant: '<S1459>/Calib'
         *  DataStoreRead: '<S1418>/Dsr_STMTmr'
         *  Logic: '<S1418>/Logical Operator31'
         *  RelationalOperator: '<S1418>/Greater  Than12'
         *  Switch: '<S1480>/Switch2'
         */
        if (rtb_LogicalOperator21_tmp || (VeESSR_t_STMTmr_DS <
                HeESSR_t_MedTEB_dT))
        {
            /* Switch: '<S1480>/Switch1' incorporates:
             *  Constant: '<S1480>/Constant Value2'
             */
            VeESSR_t_ActvBeltSlpCtrlAchvdTmr = 0.0F;
        }
        else
        {
            if (VeESSR_b_ActvBeltSlpCtrlCndnsSet)
            {
                /* Switch: '<S1480>/Switch1' incorporates:
                 *  Sum: '<S1480>/Subtraction'
                 *  Switch: '<S1480>/Switch2'
                 *  UnitDelay: '<S1480>/Unit Delay'
                 */
                VeESSR_t_ActvBeltSlpCtrlAchvdTmr = HeESSR_t_MedTEB_dT +
                    VeESSR_t_ActvBeltSlpCtrlAchvdTmr;
            }
        }

        /* End of Switch: '<S1480>/Switch1' */
        /* End of Outputs for SubSystem: '<S1418>/Stop Watch Reset Enabled' */

        /* RelationalOperator: '<S1418>/Greater  Than13' incorporates:
         *  Constant: '<S1474>/Calib'
         */
        VeESSR_b_ActvBeltSlpCtrlAchvdTmrExpired =
            (VeESSR_t_ActvBeltSlpCtrlAchvdTmr >=
             KeESSR_t_ActvBeltSlpCtrlAchvdTmr);

        /* Logic: '<S1418>/Logical Operator24' incorporates:
         *  Constant: '<S1471>/Calib'
         *  Logic: '<S1418>/Logical Operator26'
         *  Logic: '<S1418>/Logical Operator29'
         *  RelationalOperator: '<S1418>/Greater  Than14'
         */
        VeESSR_b_ActvBeltSlpCtrlAchvd = ((VeESSR_b_ActvBeltSlpCtrlCndnsSet) &&
            (((VeESSR_b_ActvBeltSlpCtrlAchvdTmrExpired) ||
              (!rtu_VeBCPR_b_PosSlipDetected)) || (rtu_VeTISR_n_NiFromMtr <=
            KeESSR_n_ActvBeltSlpCtrlMtrASpd)));

        /* Logic: '<S1418>/Logical Operator14' incorporates:
         *  Constant: '<S1456>/Calib'
         *  Constant: '<S1462>/Calib'
         *  Constant: '<S1463>/Calib'
         *  Constant: '<S1468>/Calib'
         *  Constant: '<S1469>/Calib'
         *  DataStoreRead: '<S1418>/Data Store Read18'
         *  DataStoreRead: '<S1418>/Data Store Read19'
         *  Logic: '<S1418>/Logical Operator22'
         *  Logic: '<S1418>/Logical Operator9'
         *  Logic: '<S1418>/Logical6'
         *  Logic: '<S1418>/Logical7'
         *  Logic: '<S1418>/Logical9'
         *  RelationalOperator: '<S1418>/Greater  Than11'
         *  RelationalOperator: '<S1418>/Greater  Than15'
         */
        VeESSR_b_SpinUp_CoastDownTrig = ((((((((rtu_VeSTRR_b_BackupStrtEngOn ||
            rtb_LogicalOperator3_ap) || rtb_LogicalOperator4_ou) ||
            rtb_LogicalOperator5_ml) || rtb_LogicalOperator21) ||
            rtb_Logical8_gu) || rtu_ErlyExitLmp) &&
            ((((KeESSR_b_EnblFtrBackupStrt) &&
               (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
                KeESSR_Cnt_BackupStrtMaxAttmpts)) || ((KeESSR_b_EnblFtrBumpStrt)
            && (VeESSR_Cnt_BumpStrtAttmptCntr_DS < KeESSR_Cnt_BumpStrtMaxAttmpts)))
             || (HeESSR_b_LimphomeEnbl))) && ((VeESSR_b_ActvBeltSlpCtrlAchvd) ||
            rtb_LogicalOperator21_tmp));

        /* Merge: '<S1432>/Merge' incorporates:
         *  DataStoreWrite: '<S1418>/Dsw_AStrtFailed3'
         *  Logic: '<S1418>/AND'
         *  Logic: '<S1418>/Logical Operator15'
         */
        rtb_GreaterThan_kf = ((VeESSR_b_BackUpStartEng_DS) ||
                              (((((rtb_GreaterThan_kf && rtb_OR_dp) &&
            rtb_OR1_fs) && rtb_OR2_p) && rtb_OR3) && rtb_Switch13_p));

        /* Merge: '<S1432>/Merge4' incorporates:
         *  Gain: '<S1478>/Gain'
         *  Logic: '<S1418>/Logical Operator33'
         */
        rtb_GreaterThan3_b = (rtb_LogicalOperator21_tmp && rtb_GreaterThan3_b);

        /* Merge: '<S1432>/Merge3' incorporates:
         *  Gain: '<S1479>/Gain'
         */
        rtb_Logical8_gu = VeESSR_b_SpinUp_CoastDownTrig;

        /* Switch: '<S1418>/Switch8' incorporates:
         *  Constant: '<S1465>/Calib'
         *  Constant: '<S1466>/Calib'
         *  Logic: '<S1418>/Logical Operator34'
         *  Logic: '<S1418>/Logical2'
         *  Logic: '<S1418>/Logical3'
         *  Logic: '<S1418>/Logical5'
         */
        if ((rtu_LwrThresLmp || (KeESSR_b_AllowEV_StrtFailed)) &&
                ((!KeESSR_b_DsblEVStrtFailed_InPlant) ||
                 (!rtu_VeRTMR_b_InPlantMode)))
        {
            /* Merge: '<S1432>/Merge5' incorporates:
             *  Constant: '<S1453>/Constant'
             */
            rtb_Merge5_n = CeESSR_e_CoastDown;
        }
        else
        {
            /* Merge: '<S1432>/Merge5' incorporates:
             *  Constant: '<S1450>/Constant'
             */
            rtb_Merge5_n = CeESSR_e_EngFail;
        }

        /* End of Switch: '<S1418>/Switch8' */

        /* Merge: '<S1432>/Merge1' incorporates:
         *  Constant: '<S1451>/Constant'
         *  SignalConversion generated from: '<S1418>/NormalExitTrigger'
         */
        rtb_Merge1_d = CeESSR_e_EngSpdTgtAch;

        /* Merge: '<S1432>/Merge2' incorporates:
         *  Constant: '<S1455>/Constant'
         *  SignalConversion generated from: '<S1418>/CoastDownExitTrigger'
         */
        rtb_Merge2_h = CeESSR_e_CoastDown;

        /* End of Outputs for SubSystem: '<S1413>/ESSC_ChkSpinUpEng_SFS' */
    }

    /* End of If: '<S1413>/If' */

    /* Outputs for Atomic SubSystem: '<S1433>/LowpassT Reset Enabled' */
    /* Sum: '<S1499>/Summation' incorporates:
     *  Constant: '<S1421>/Calib'
     *  DataStoreRead: '<S1413>/Dsr_Ni1stFlt_DS'
     *  DataStoreRead: '<S1413>/Dsr_NiProfGenT2Gain'
     *  MinMax: '<S1499>/Maximum'
     *  Product: '<S1499>/Multiplication'
     *  Product: '<S1499>/Multiplication1'
     *  Sum: '<S1499>/Subtraction'
     */
    rtb_Product2_jm = (((VeESSR_n_NiTargetSpinUp - VeESSR_n_Ni1stFlt_DS) *
                        HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                        (VeESSR_k_StrtTypScndOrdLwPassT_DS, HeESSR_t_MedTEB_dT)))
        + VeESSR_n_Ni1stFlt_DS;

    /* End of Outputs for SubSystem: '<S1433>/LowpassT Reset Enabled' */

    /* Delay: '<S1413>/Integer Delay' */
    if (rtb_Equal2_p3 && (((uint32)localZCE->IntegerDelay_Reset_ZCE_p) !=
                          POS_ZCSIG))
    {
        localDW->IntegerDelay_DSTATE = 0.0F;
    }

    localZCE->IntegerDelay_Reset_ZCE_p = rtb_Equal2_p3 ? ((ZCSigState)1) :
        ((ZCSigState)0);

    /* Outputs for Atomic SubSystem: '<S1433>/LowpassT Reset Enabled1' */
    /* Sum: '<S1500>/Summation' incorporates:
     *  Constant: '<S1421>/Calib'
     *  DataStoreRead: '<S1413>/Dsr_NiProfGenT1Gain'
     *  Delay: '<S1413>/Integer Delay'
     *  MinMax: '<S1500>/Maximum'
     *  Product: '<S1500>/Multiplication'
     *  Product: '<S1500>/Multiplication1'
     *  Sum: '<S1500>/Subtraction'
     */
    rtb_UnitDelay_fx = (((rtb_Product2_jm - localDW->IntegerDelay_DSTATE) *
                         HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                         (VeESSR_k_StrtTypFrstOrdLwPassT_DS, HeESSR_t_MedTEB_dT)))
        + localDW->IntegerDelay_DSTATE;

    /* End of Outputs for SubSystem: '<S1433>/LowpassT Reset Enabled1' */

    /* Switch: '<S1520>/Switch1' incorporates:
     *  UnitDelay: '<S1520>/Unit Delay'
     */
    if (rtb_Equal2_p3)
    {
        rtb_Sum1_ih = rtb_UnitDelay_fx;
    }
    else
    {
        rtb_Sum1_ih = localDW->UnitDelay_DSTATE;
    }

    /* End of Switch: '<S1520>/Switch1' */

    /* Gain: '<S1501>/Gain1' incorporates:
     *  Sum: '<S1501>/Sum18'
     */
    rtb_Sum1_ih = (rtb_UnitDelay_fx + rtb_Sum1_ih) * 0.5F;

    /* Delay: '<S1501>/IntegerDelay' incorporates:
     *  Constant: '<S1510>/Calib'
     */
    if (rtb_Equal2_p3 && (((uint32)localZCE->IntegerDelay_Reset_ZCE_i) !=
                          POS_ZCSIG))
    {
        localDW->icLoad = 1U;
    }

    localZCE->IntegerDelay_Reset_ZCE_i = rtb_Equal2_p3 ? ((ZCSigState)1) :
        ((ZCSigState)0);
    if (((sint32)localDW->icLoad) != 0)
    {
        for (i = 0; i < 16; i++)
        {
            localDW->IntegerDelay_DSTATE_p[i] = rtb_Sum1_ih;
        }
    }

    if (((sint32)KeESSR_Cnt_DelayOptNi) <= 0)
    {
        /* Delay: '<S1501>/IntegerDelay' */
        rtb_IntegerDelay = rtb_Sum1_ih;
    }
    else
    {
        if (((sint32)KeESSR_Cnt_DelayOptNi) > 16)
        {
            tmp = 16U;
        }
        else
        {
            tmp = KeESSR_Cnt_DelayOptNi;
        }

        /* Delay: '<S1501>/IntegerDelay' */
        rtb_IntegerDelay = localDW->IntegerDelay_DSTATE_p[(uint8)(16U - ((uint32)
            tmp))];
    }

    /* End of Delay: '<S1501>/IntegerDelay' */

    /* Sum: '<S1501>/Sum15' incorporates:
     *  Abs: '<S1501>/Abs4'
     *  Constant: '<S1425>/Calib'
     *  DataStoreRead: '<S1413>/Dsr_InputSpeedProfile5'
     */
    rtb_Sum15 = fabsf(VeESSR_dn_TargetAcceltn_DS) + KeESSR_dn_NiTargetJerkLimit;

    /* Outputs for Atomic SubSystem: '<S1501>/GradientLimiter' */
    /* Sum: '<S1503>/Sum2' incorporates:
     *  Constant: '<S1421>/Calib'
     *  DataStoreRead: '<S1413>/Dsr_InputSpeedProfile4'
     *  Product: '<S1501>/Product6'
     *  Sum: '<S1501>/Sum14'
     *  UnitDelay: '<S1503>/Unit Delay'
     */
    rtb_Sum2_h5z = ((rtb_Sum1_ih - VeESSR_n_TargetSpeed_DS) / HeESSR_t_MedTEB_dT)
        - localDW->UnitDelay_DSTATE_h;

    /* Outputs for Atomic SubSystem: '<S1503>/Limiter' */
    /* Switch: '<S1521>/Switch1' incorporates:
     *  RelationalOperator: '<S1521>/Relational Operator'
     */
    if (rtb_Sum15 < rtb_Sum2_h5z)
    {
        /* MinMax: '<S1504>/MinMax1' */
        rtb_MinMax1_cn = rtb_Sum15;
    }
    else
    {
        /* MinMax: '<S1504>/MinMax1' */
        rtb_MinMax1_cn = rtb_Sum2_h5z;
    }

    /* End of Switch: '<S1521>/Switch1' */

    /* Switch: '<S1521>/Switch' incorporates:
     *  Gain: '<S1501>/Gain'
     *  RelationalOperator: '<S1521>/Relational Operator1'
     */
    if (rtb_MinMax1_cn <= (-rtb_Sum15))
    {
        rtb_MinMax1_cn = -rtb_Sum15;
    }

    /* End of Switch: '<S1521>/Switch' */
    /* End of Outputs for SubSystem: '<S1503>/Limiter' */

    /* Sum: '<S1503>/Sum3' incorporates:
     *  UnitDelay: '<S1503>/Unit Delay'
     */
    rtb_Gain_k = rtb_MinMax1_cn + localDW->UnitDelay_DSTATE_h;

    /* Update for UnitDelay: '<S1503>/Unit Delay' */
    localDW->UnitDelay_DSTATE_h = rtb_Gain_k;

    /* End of Outputs for SubSystem: '<S1501>/GradientLimiter' */

    /* Sum: '<S1502>/Subtraction1' incorporates:
     *  Constant: '<S1427>/Calib'
     *  DataStoreRead: '<S1413>/Dsr_InputSpeedProfile5'
     *  Product: '<S1502>/Multiplication'
     *  Sum: '<S1502>/Subtraction'
     */
    rtb_Sum15 = ((rtb_Gain_k - VeESSR_dn_TargetAcceltn_DS) *
                 KeESSR_k_NiDotTargetFilt) + VeESSR_dn_TargetAcceltn_DS;

    /* DataStoreRead: '<S1413>/Dsr_InputAcceltnProf' */
    rtb_Gain_k = VeESSR_dn_InputAcceltnProf_DS;

    /* Switch: '<S1423>/Switch1' incorporates:
     *  Constant: '<S1487>/Constant'
     *  Constant: '<S1488>/Calib'
     *  DataStoreRead: '<S1423>/Data Store Read'
     *  Logic: '<S1423>/Logical Operator'
     *  RelationalOperator: '<S1423>/Comparison4'
     */
    if ((((uint32)VeESSR_e_EngStartStopStPrev_DS) == CeESSR_e_InitEngSpinSt) &&
            (HeESSR_b_EnblMaxJerkSpinUp))
    {
        /* Outputs for Atomic SubSystem: '<S1423>/Protected Division' */
        /* Switch: '<S1491>/Switch1' incorporates:
         *  Constant: '<S1490>/Calib'
         *  Constant: '<S1491>/Constant Value'
         *  Constant: '<S1491>/Constant Value1'
         *  Constant: '<S1491>/Constant Value2'
         *  Constant: '<S1491>/Constant Value3'
         *  DataStoreRead: '<S1423>/Dsr_NiProfGenNiDMax'
         *  Logic: '<S1491>/AND'
         *  RelationalOperator: '<S1491>/Greater Than or Equal '
         *  RelationalOperator: '<S1491>/Greater Than or Equal 1'
         *  RelationalOperator: '<S1491>/Not Equal'
         *  RelationalOperator: '<S1491>/Not Equal1'
         *  Switch: '<S1491>/Switch2'
         *  Switch: '<S1491>/Switch3'
         */
        if ((VeESSR_dn_StrtTypNiDotMax_DS != 0.0F) &&
                (KeESSR_dn_InitJerkMaxSpinup != 0.0F))
        {
            /* Switch: '<S1491>/Switch1' incorporates:
             *  Product: '<S1491>/Division'
             */
            rtb_Sum2_h5z = VeESSR_dn_StrtTypNiDotMax_DS /
                KeESSR_dn_InitJerkMaxSpinup;
        }
        else if (VeESSR_dn_StrtTypNiDotMax_DS > 0.0F)
        {
            /* Switch: '<S1491>/Switch2' incorporates:
             *  Constant: '<S1491>/MAXFLOAT'
             *  Switch: '<S1491>/Switch1'
             */
            rtb_Sum2_h5z = 3.402823466E+38F;
        }
        else if (VeESSR_dn_StrtTypNiDotMax_DS < 0.0F)
        {
            /* Switch: '<S1491>/Switch3' incorporates:
             *  Constant: '<S1491>/MINFLOAT'
             *  Switch: '<S1491>/Switch1'
             *  Switch: '<S1491>/Switch2'
             */
            rtb_Sum2_h5z = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1491>/Switch1' incorporates:
             *  Constant: '<S1491>/Constant Value4'
             *  Switch: '<S1491>/Switch2'
             *  Switch: '<S1491>/Switch3'
             */
            rtb_Sum2_h5z = 0.0F;
        }

        /* End of Switch: '<S1491>/Switch1' */
        /* End of Outputs for SubSystem: '<S1423>/Protected Division' */

        /* Switch: '<S1423>/Switch' incorporates:
         *  Constant: '<S1489>/Calib'
         *  DataStoreRead: '<S1423>/Dsr_STMTmr1'
         *  Product: '<S1423>/Product'
         *  RelationalOperator: '<S1423>/Greater  Than3'
         *  Rounding: '<S1423>/Rounding1'
         */
        if (VeESSR_t_STMTmr_DS > (ceilf(rtb_Sum2_h5z) * HeESSR_t_MedTEB_dT))
        {
            /* Switch: '<S1423>/Switch1' incorporates:
             *  DataStoreRead: '<S1423>/Dsr_NiProfGenDNiDLim'
             *  Switch: '<S1423>/Switch'
             */
            VeESSR_dn_JerkMaxSpinup = VeESSR_dn_StrtTypJerkMax_DS;
        }
        else
        {
            /* Switch: '<S1423>/Switch1' incorporates:
             *  Constant: '<S1490>/Calib'
             *  Switch: '<S1423>/Switch'
             */
            VeESSR_dn_JerkMaxSpinup = KeESSR_dn_InitJerkMaxSpinup;
        }

        /* End of Switch: '<S1423>/Switch' */
    }
    else
    {
        /* Switch: '<S1423>/Switch1' incorporates:
         *  DataStoreRead: '<S1423>/Dsr_NiProfGenDNiDLim1'
         */
        VeESSR_dn_JerkMaxSpinup = VeESSR_dn_StrtTypJerkMax_DS;
    }

    /* End of Switch: '<S1423>/Switch1' */

    /* Abs: '<S1433>/Abs' */
    rtb_Switch1_gd = fabsf(VeESSR_dn_JerkMaxSpinup);

    /* Switch: '<S1532>/Switch1' incorporates:
     *  Constant: '<S1530>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S1532>/Switch1' incorporates:
         *  Constant: '<S1531>/Calib'
         */
        rtb_Switch1_cqe = HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S1519>/Sum6' incorporates:
         *  DataStoreRead: '<S1413>/Dsr_InputAcceltnProf'
         *  Sum: '<S1519>/Sum8'
         */
        rtb_MinMax1_cn = VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15;

        /* Abs: '<S1519>/Abs' incorporates:
         *  Sum: '<S1519>/Sum6'
         */
        rtb_Sum2_h5z = (rtb_MinMax1_cn - rtb_Gain_lw) + rtb_Switch1_gd;

        /* MinMax: '<S1519>/MinMax2' incorporates:
         *  Abs: '<S1519>/Abs1'
         *  Constant: '<S1421>/Calib'
         *  Constant: '<S1519>/Constant Value'
         *  Constant: '<S1519>/Constant Value3'
         *  Delay: '<S1413>/Integer Delay'
         *  Product: '<S1519>/Product2'
         *  Product: '<S1519>/Product7'
         *  Product: '<S1534>/Prod'
         *  Sum: '<S1519>/Sum3'
         *  Sum: '<S1519>/Sum5'
         */
        rtb_Sum2_h5z = fmaxf((fabsf((rtb_IntegerDelay -
                                localDW->IntegerDelay_DSTATE) -
                               (HeESSR_t_MedTEB_dT * rtb_Sum15)) * (rtb_Product4
                               * -2.0F)) - (rtb_Sum2_h5z * rtb_Sum2_h5z), 0.0F);

        /* Switch: '<S1536>/Switch' incorporates:
         *  Sqrt: '<S1536>/Sqrt'
         */
        rtb_Sum2_h5z = sqrtf(rtb_Sum2_h5z);

        /* Switch: '<S1532>/Switch1' incorporates:
         *  Abs: '<S1519>/Abs'
         *  Sum: '<S1519>/Sum7'
         *  Sum: '<S1519>/Sum8'
         */
        rtb_Switch1_cqe = fabsf(rtb_MinMax1_cn + rtb_Gain_lw) + (rtb_Sum2_h5z +
            rtb_Sum15);
    }

    /* End of Switch: '<S1532>/Switch1' */

    /* Product: '<S1501>/Product1' incorporates:
     *  Constant: '<S1421>/Calib'
     */
    rtb_Sum2_h5z = rtb_Switch1_gd / HeESSR_t_MedTEB_dT;

    /* Switch: '<S1533>/Switch1' incorporates:
     *  Constant: '<S1530>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S1533>/Switch1' incorporates:
         *  Constant: '<S1531>/Calib'
         *  Gain: '<S1519>/Gain1'
         */
        rtb_Abs2_h = -HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S1519>/Sum11' incorporates:
         *  DataStoreRead: '<S1413>/Dsr_InputAcceltnProf'
         *  Sum: '<S1519>/Sum13'
         */
        rtb_Sum6_do = VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15;

        /* Abs: '<S1519>/Abs2' incorporates:
         *  Sum: '<S1519>/Sum11'
         */
        rtb_Abs2_h = (rtb_Sum6_do - rtb_Switch1_gd) + rtb_Gain_lw;

        /* MinMax: '<S1519>/MinMax1' incorporates:
         *  Abs: '<S1519>/Abs3'
         *  Constant: '<S1421>/Calib'
         *  Constant: '<S1519>/Constant Value1'
         *  Constant: '<S1519>/Constant Value2'
         *  Delay: '<S1413>/Integer Delay'
         *  Product: '<S1519>/Product5'
         *  Product: '<S1519>/Product8'
         *  Product: '<S1537>/Prod'
         *  Sum: '<S1519>/Sum10'
         *  Sum: '<S1519>/Sum9'
         */
        rtb_Abs2_h = fmaxf((fabsf((rtb_IntegerDelay -
                              localDW->IntegerDelay_DSTATE) -
                             (HeESSR_t_MedTEB_dT * rtb_Sum15)) * (rtb_Sum2_h5z *
                             2.0F)) - (rtb_Abs2_h * rtb_Abs2_h), 0.0F);

        /* Switch: '<S1535>/Switch' incorporates:
         *  Sqrt: '<S1535>/Sqrt'
         */
        rtb_Abs2_h = sqrtf(rtb_Abs2_h);

        /* Switch: '<S1533>/Switch1' incorporates:
         *  Abs: '<S1519>/Abs2'
         *  Sum: '<S1519>/Sum12'
         *  Sum: '<S1519>/Sum13'
         */
        rtb_Abs2_h = (rtb_Sum15 - rtb_Abs2_h) - fabsf(rtb_Sum6_do +
            rtb_Switch1_gd);
    }

    /* End of Switch: '<S1533>/Switch1' */

    /* Switch: '<S1501>/Switch1' incorporates:
     *  Constant: '<S1506>/Calib'
     *  Constant: '<S1507>/Calib'
     *  DataStoreRead: '<S1413>/Data Store Read'
     *  DataStoreRead: '<S1413>/Dsr_InputSpeedProfile8'
     *  Logic: '<S1501>/Logical1'
     *  Logic: '<S1501>/Logical6'
     *  Logic: '<S1501>/Logical8'
     */
    if (((HeESSR_b_NiLmtBypsLoopJerk) && (VeESSR_b_NiMaxActive_DS)) ||
            ((VeESSR_b_NiDotMaxActive_DS) && (HeESSR_b_NiDotLmtBypsLoopJerk)))
    {
        /* Switch: '<S1501>/Switch1' */
        rtb_Switch1_gd = rtb_Switch1_cqe;
    }
    else
    {
        /* Switch: '<S1501>/Switch1' incorporates:
         *  DataStoreRead: '<S1413>/Dsr_InputAcceltnProf'
         *  Sum: '<S1501>/Sum1'
         */
        rtb_Switch1_gd += VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S1501>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S1501>/Limiter2' */
    /* Switch: '<S1514>/Switch1' incorporates:
     *  RelationalOperator: '<S1514>/Relational Operator'
     */
    if (rtb_Switch1_cqe < rtb_Switch1_gd)
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = rtb_Switch1_cqe;
    }

    /* End of Switch: '<S1514>/Switch1' */

    /* Switch: '<S1514>/Switch' incorporates:
     *  RelationalOperator: '<S1514>/Relational Operator1'
     */
    if (rtb_Switch1_gd <= rtb_Abs2_h)
    {
        /* Switch: '<S1514>/Switch' */
        rtb_Switch1_gd = rtb_Abs2_h;
    }

    /* End of Switch: '<S1514>/Switch' */
    /* End of Outputs for SubSystem: '<S1501>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S1501>/Limiter4' */
    /* Switch: '<S1516>/Switch1' incorporates:
     *  RelationalOperator: '<S1516>/Relational Operator'
     */
    if (VeESSR_dn_NiDotMax_SpinUp < rtb_Switch1_gd)
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = VeESSR_dn_NiDotMax_SpinUp;
    }

    /* End of Switch: '<S1516>/Switch1' */

    /* Switch: '<S1516>/Switch' incorporates:
     *  DataStoreRead: '<S1413>/Dsr_NiProfGenNiDMin'
     *  RelationalOperator: '<S1516>/Relational Operator1'
     */
    if (rtb_Switch1_gd > VeESSR_dn_StrtTypNiDotMin_DS)
    {
        /* Switch: '<S1516>/Switch' */
        rtb_Switch_kx = rtb_Switch1_gd;
    }
    else
    {
        /* Switch: '<S1516>/Switch' */
        rtb_Switch_kx = VeESSR_dn_StrtTypNiDotMin_DS;
    }

    /* End of Switch: '<S1516>/Switch' */
    /* End of Outputs for SubSystem: '<S1501>/Limiter4' */

    /* Sum: '<S1505>/Sum6' incorporates:
     *  Delay: '<S1413>/Integer Delay'
     */
    rtb_Sum6_do = rtu_VeHSER_n_NiMax - localDW->IntegerDelay_DSTATE;

    /* Abs: '<S1505>/Abs2' */
    rtb_MinMax1_cn = fabsf(rtb_Sum6_do);

    /* Switch: '<S1505>/Switch' incorporates:
     *  Constant: '<S1505>/Constant Value7'
     *  RelationalOperator: '<S1505>/Comparison2'
     */
    if (rtb_Sum6_do < 0.0F)
    {
        /* Switch: '<S1545>/Switch1' incorporates:
         *  Abs: '<S1505>/Abs'
         */
        rtb_Switch1_gd = fabsf(rtb_Sum2_h5z);
    }
    else
    {
        /* Switch: '<S1545>/Switch1' incorporates:
         *  Abs: '<S1505>/Abs1'
         *  Gain: '<S1505>/Gain'
         */
        rtb_Switch1_gd = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S1505>/Switch' */

    /* Product: '<S1505>/Product4' incorporates:
     *  Constant: '<S1421>/Calib'
     */
    rtb_Product4_j = (rtb_Switch1_gd * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1505>/Protected Division1' */
    /* Switch: '<S1528>/Switch1' incorporates:
     *  Constant: '<S1528>/Constant Value'
     *  Constant: '<S1528>/Constant Value1'
     *  Constant: '<S1528>/Constant Value2'
     *  Logic: '<S1528>/AND'
     *  RelationalOperator: '<S1528>/Greater Than or Equal '
     *  RelationalOperator: '<S1528>/Not Equal'
     *  RelationalOperator: '<S1528>/Not Equal1'
     *  Switch: '<S1528>/Switch2'
     */
    if ((rtb_MinMax1_cn != 0.0F) && (rtb_Product4_j != 0.0F))
    {
        /* Switch: '<S1528>/Switch1' incorporates:
         *  Product: '<S1528>/Division'
         */
        rtb_MinMax1_cn /= rtb_Product4_j;
    }
    else if (rtb_MinMax1_cn > 0.0F)
    {
        /* Switch: '<S1528>/Switch2' incorporates:
         *  Constant: '<S1528>/MAXFLOAT'
         *  Switch: '<S1528>/Switch1'
         */
        rtb_MinMax1_cn = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1528>/Switch1' incorporates:
         *  Constant: '<S1528>/Constant Value4'
         *  Switch: '<S1528>/Switch2'
         *  Switch: '<S1528>/Switch3'
         */
        rtb_MinMax1_cn = 0.0F;
    }

    /* End of Switch: '<S1528>/Switch1' */
    /* End of Outputs for SubSystem: '<S1505>/Protected Division1' */

    /* Sum: '<S1505>/Sum4' incorporates:
     *  Abs: '<S1505>/Abs3'
     *  Constant: '<S1505>/Constant Value3'
     *  Constant: '<S1505>/Constant Value5'
     *  Product: '<S1505>/Product3'
     */
    rtb_MinMax1_cn = (fabsf(rtb_MinMax1_cn) * 8.0F) + 1.0F;

    /* Switch: '<S1529>/Switch' */
    if (rtb_MinMax1_cn >= 0.0F)
    {
        /* MinMax: '<S1504>/MinMax1' incorporates:
         *  Sqrt: '<S1529>/Sqrt'
         */
        rtb_MinMax1_cn = sqrtf(rtb_MinMax1_cn);
    }
    else
    {
        /* MinMax: '<S1504>/MinMax1' incorporates:
         *  Constant: '<S1529>/Zero'
         */
        rtb_MinMax1_cn = 0.0F;
    }

    /* End of Switch: '<S1529>/Switch' */

    /* MinMax: '<S1504>/MinMax1' incorporates:
     *  Constant: '<S1505>/Constant Value'
     *  Constant: '<S1505>/Constant Value4'
     *  Constant: '<S1505>/Constant Value6'
     *  MinMax: '<S1505>/MinMax1'
     *  Product: '<S1505>/Product2'
     *  Rounding: '<S1505>/Rounding1'
     *  Sum: '<S1505>/Sum3'
     */
    rtb_MinMax1_cn = fmaxf(ceilf((rtb_MinMax1_cn - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S1505>/Product' incorporates:
     *  Constant: '<S1421>/Calib'
     */
    rtb_Product4_j = rtb_MinMax1_cn * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1505>/Protected Division' */
    /* Switch: '<S1527>/Switch1' incorporates:
     *  Constant: '<S1527>/Constant Value'
     *  Constant: '<S1527>/Constant Value1'
     *  Constant: '<S1527>/Constant Value2'
     *  Constant: '<S1527>/Constant Value3'
     *  Logic: '<S1527>/AND'
     *  RelationalOperator: '<S1527>/Greater Than or Equal '
     *  RelationalOperator: '<S1527>/Greater Than or Equal 1'
     *  RelationalOperator: '<S1527>/Not Equal'
     *  RelationalOperator: '<S1527>/Not Equal1'
     *  Switch: '<S1527>/Switch2'
     *  Switch: '<S1527>/Switch3'
     */
    if ((rtb_Sum6_do != 0.0F) && (rtb_Product4_j != 0.0F))
    {
        /* Switch: '<S1527>/Switch1' incorporates:
         *  Product: '<S1527>/Division'
         */
        rtb_Sum6_do /= rtb_Product4_j;
    }
    else if (rtb_Sum6_do > 0.0F)
    {
        /* Switch: '<S1527>/Switch2' incorporates:
         *  Constant: '<S1527>/MAXFLOAT'
         *  Switch: '<S1527>/Switch1'
         */
        rtb_Sum6_do = 3.402823466E+38F;
    }
    else if (rtb_Sum6_do < 0.0F)
    {
        /* Switch: '<S1527>/Switch3' incorporates:
         *  Constant: '<S1527>/MINFLOAT'
         *  Switch: '<S1527>/Switch1'
         *  Switch: '<S1527>/Switch2'
         */
        rtb_Sum6_do = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1527>/Switch1' incorporates:
         *  Constant: '<S1527>/Constant Value4'
         *  Switch: '<S1527>/Switch2'
         *  Switch: '<S1527>/Switch3'
         */
        rtb_Sum6_do = 0.0F;
    }

    /* End of Switch: '<S1527>/Switch1' */
    /* End of Outputs for SubSystem: '<S1505>/Protected Division' */

    /* Sum: '<S1505>/Sum' incorporates:
     *  Constant: '<S1421>/Calib'
     *  Constant: '<S1505>/Constant Value1'
     *  Constant: '<S1505>/Constant Value2'
     *  Product: '<S1505>/Product1'
     *  Sum: '<S1505>/Sum2'
     */
    rtb_MinMax1_cn = rtb_Sum6_do - (((0.5F * rtb_Switch1_gd) * (rtb_MinMax1_cn -
        1.0F)) * HeESSR_t_MedTEB_dT);

    /* Switch: '<S1501>/Switch4' incorporates:
     *  Constant: '<S1508>/Calib'
     */
    if (!HeESSR_b_NiLmtForAccelByps)
    {
        /* Switch: '<S1501>/Switch4' incorporates:
         *  MinMax: '<S1501>/MinMax1'
         */
        rtb_Switch_kx = fminf(rtb_MinMax1_cn, rtb_Switch_kx);
    }

    /* End of Switch: '<S1501>/Switch4' */

    /* Outputs for Atomic SubSystem: '<S1501>/Limiter13' */
    /* RelationalOperator: '<S1513>/Relational Operator' */
    rtb_Equal2_p3 = (rtu_VeHSER_dn_NiDotMax <= rtb_Switch_kx);

    /* Switch: '<S1513>/Switch1' */
    if (rtb_Equal2_p3)
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = rtu_VeHSER_dn_NiDotMax;
    }
    else
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = rtb_Switch_kx;
    }

    /* End of Switch: '<S1513>/Switch1' */

    /* Switch: '<S1513>/Switch' incorporates:
     *  RelationalOperator: '<S1513>/Relational Operator1'
     */
    if (rtb_Switch1_gd <= rtu_VeHSER_dn_NiDotMin)
    {
        rtb_Switch1_gd = rtu_VeHSER_dn_NiDotMin;
    }

    /* End of Switch: '<S1513>/Switch' */
    /* End of Outputs for SubSystem: '<S1501>/Limiter13' */

    /* Product: '<S1501>/Product9' incorporates:
     *  Constant: '<S1421>/Calib'
     */
    rtb_Switch_kx = rtb_Switch1_gd * HeESSR_t_MedTEB_dT;

    /* Switch: '<S1501>/Switch2' incorporates:
     *  Constant: '<S1506>/Calib'
     *  DataStoreRead: '<S1413>/Dsr_InputSpeedProfile9'
     *  Logic: '<S1501>/Logical3'
     */
    if ((HeESSR_b_NiDotLmtBypsLoopJerk) && (VeESSR_b_NiDotMinActive_DS))
    {
        /* Switch: '<S1501>/Switch2' */
        rtb_Gain_lw = rtb_Abs2_h;
    }
    else
    {
        /* Switch: '<S1501>/Switch2' incorporates:
         *  DataStoreRead: '<S1413>/Dsr_InputAcceltnProf'
         *  Sum: '<S1501>/Sum16'
         */
        rtb_Gain_lw += VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S1501>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S1501>/Limiter' */
    /* Switch: '<S1511>/Switch1' incorporates:
     *  RelationalOperator: '<S1511>/Relational Operator'
     */
    if (rtb_Switch1_cqe < rtb_Gain_lw)
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = rtb_Switch1_cqe;
    }
    else
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = rtb_Gain_lw;
    }

    /* End of Switch: '<S1511>/Switch1' */

    /* Switch: '<S1511>/Switch' incorporates:
     *  RelationalOperator: '<S1511>/Relational Operator1'
     */
    if (rtb_Switch1_gd > rtb_Abs2_h)
    {
        /* Switch: '<S1511>/Switch' */
        rtb_Gain_lw = rtb_Switch1_gd;
    }
    else
    {
        /* Switch: '<S1511>/Switch' */
        rtb_Gain_lw = rtb_Abs2_h;
    }

    /* End of Switch: '<S1511>/Switch' */
    /* End of Outputs for SubSystem: '<S1501>/Limiter' */

    /* Outputs for Atomic SubSystem: '<S1501>/Limiter3' */
    /* Switch: '<S1515>/Switch1' incorporates:
     *  RelationalOperator: '<S1515>/Relational Operator'
     */
    if (VeESSR_dn_NiDotMax_SpinUp < rtb_Gain_lw)
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = VeESSR_dn_NiDotMax_SpinUp;
    }
    else
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = rtb_Gain_lw;
    }

    /* End of Switch: '<S1515>/Switch1' */
    /* End of Outputs for SubSystem: '<S1501>/Limiter3' */

    /* Switch: '<S1501>/Switch5' incorporates:
     *  Constant: '<S1508>/Calib'
     *  DataStoreRead: '<S1413>/Dsr_NiProfGenNiDMin'
     *  RelationalOperator: '<S1515>/Relational Operator1'
     *  Switch: '<S1515>/Switch'
     */
    if (HeESSR_b_NiLmtForAccelByps)
    {
        /* Outputs for Atomic SubSystem: '<S1501>/Limiter3' */
        /* Switch: '<S1515>/Switch' incorporates:
         *  DataStoreRead: '<S1413>/Dsr_NiProfGenNiDMin'
         *  RelationalOperator: '<S1515>/Relational Operator1'
         */
        if (rtb_Switch1_gd > VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S1501>/Switch5' */
            rtb_Gain_lw = rtb_Switch1_gd;
        }
        else
        {
            /* Switch: '<S1501>/Switch5' */
            rtb_Gain_lw = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Outputs for SubSystem: '<S1501>/Limiter3' */
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S1501>/Limiter3' */
        if (rtb_Switch1_gd <= VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S1515>/Switch' incorporates:
             *  DataStoreRead: '<S1413>/Dsr_NiProfGenNiDMin'
             */
            rtb_Switch1_gd = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Outputs for SubSystem: '<S1501>/Limiter3' */

        /* Switch: '<S1501>/Switch5' incorporates:
         *  MinMax: '<S1501>/MinMax2'
         */
        rtb_Gain_lw = fminf(rtb_MinMax1_cn, rtb_Switch1_gd);
    }

    /* End of Switch: '<S1501>/Switch5' */

    /* Outputs for Atomic SubSystem: '<S1501>/Limiter9' */
    /* Switch: '<S1518>/Switch1' incorporates:
     *  RelationalOperator: '<S1518>/Relational Operator'
     */
    if (rtu_VeHSER_dn_NiDotMax <= rtb_Gain_lw)
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = rtu_VeHSER_dn_NiDotMax;
    }
    else
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = rtb_Gain_lw;
    }

    /* End of Switch: '<S1518>/Switch1' */

    /* RelationalOperator: '<S1517>/Relational Operator1' incorporates:
     *  RelationalOperator: '<S1518>/Relational Operator1'
     */
    rtb_LogicalOperator21 = (rtb_Switch1_gd > rtu_VeHSER_dn_NiDotMin);

    /* Logic: '<S1518>/Logical2' */
    rtb_LogicalOperator3_ap = !rtb_LogicalOperator21;

    /* Switch: '<S1518>/Switch' */
    if (!rtb_LogicalOperator21)
    {
        rtb_Switch1_gd = rtu_VeHSER_dn_NiDotMin;
    }

    /* End of Switch: '<S1518>/Switch' */
    /* End of Outputs for SubSystem: '<S1501>/Limiter9' */

    /* Product: '<S1501>/Product10' incorporates:
     *  Constant: '<S1421>/Calib'
     */
    rtb_Gain_lw = rtb_Switch1_gd * HeESSR_t_MedTEB_dT;

    /* Sum: '<S1501>/Sum2' incorporates:
     *  Delay: '<S1413>/Integer Delay'
     */
    rtb_Switch1_cqe = rtb_IntegerDelay - localDW->IntegerDelay_DSTATE;

    /* Sum: '<S1504>/Sum6' incorporates:
     *  Constant: '<S1421>/Calib'
     *  Delay: '<S1413>/Integer Delay'
     *  Product: '<S1504>/Product7'
     *  Sum: '<S1501>/Sum6'
     *  Switch: '<S1501>/Switch3'
     */
    rtb_Sum6_do = (rtb_IntegerDelay - localDW->IntegerDelay_DSTATE) - (rtb_Sum15
        * HeESSR_t_MedTEB_dT);

    /* Abs: '<S1504>/Abs2' incorporates:
     *  Sum: '<S1504>/Sum6'
     */
    rtb_MinMax1_cn = fabsf(rtb_Sum6_do);

    /* Switch: '<S1504>/Switch' incorporates:
     *  Constant: '<S1504>/Constant Value7'
     *  RelationalOperator: '<S1504>/Comparison2'
     *  Sum: '<S1504>/Sum6'
     */
    if (rtb_Sum6_do < 0.0F)
    {
        /* Switch: '<S1545>/Switch1' incorporates:
         *  Abs: '<S1504>/Abs'
         */
        rtb_Switch1_gd = fabsf(rtb_Sum2_h5z);
    }
    else
    {
        /* Switch: '<S1545>/Switch1' incorporates:
         *  Abs: '<S1504>/Abs1'
         *  Gain: '<S1504>/Gain'
         */
        rtb_Switch1_gd = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S1504>/Switch' */

    /* Product: '<S1504>/Product4' incorporates:
     *  Constant: '<S1421>/Calib'
     */
    rtb_Product4 = (rtb_Switch1_gd * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1504>/Protected Division1' */
    /* Switch: '<S1524>/Switch1' incorporates:
     *  Constant: '<S1524>/Constant Value'
     *  Constant: '<S1524>/Constant Value1'
     *  Constant: '<S1524>/Constant Value2'
     *  Logic: '<S1524>/AND'
     *  RelationalOperator: '<S1524>/Greater Than or Equal '
     *  RelationalOperator: '<S1524>/Not Equal'
     *  RelationalOperator: '<S1524>/Not Equal1'
     *  Switch: '<S1524>/Switch2'
     */
    if ((rtb_MinMax1_cn != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S1524>/Switch1' incorporates:
         *  Product: '<S1524>/Division'
         */
        rtb_Product4 = rtb_MinMax1_cn / rtb_Product4;
    }
    else if (rtb_MinMax1_cn > 0.0F)
    {
        /* Switch: '<S1524>/Switch2' incorporates:
         *  Constant: '<S1524>/MAXFLOAT'
         *  Switch: '<S1524>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1524>/Switch1' incorporates:
         *  Constant: '<S1524>/Constant Value4'
         *  Switch: '<S1524>/Switch2'
         *  Switch: '<S1524>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S1524>/Switch1' */
    /* End of Outputs for SubSystem: '<S1504>/Protected Division1' */

    /* Sum: '<S1504>/Sum4' incorporates:
     *  Abs: '<S1504>/Abs3'
     *  Constant: '<S1504>/Constant Value3'
     *  Constant: '<S1504>/Constant Value5'
     *  Product: '<S1504>/Product3'
     */
    rtb_Product4 = (fabsf(rtb_Product4) * 8.0F) + 1.0F;

    /* Switch: '<S1525>/Switch' incorporates:
     *  Constant: '<S1525>/Zero'
     *  Sqrt: '<S1525>/Sqrt'
     */
    if (rtb_Product4 >= 0.0F)
    {
        rtb_Product4 = sqrtf(rtb_Product4);
    }
    else
    {
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S1525>/Switch' */

    /* MinMax: '<S1504>/MinMax1' incorporates:
     *  Constant: '<S1504>/Constant Value'
     *  Constant: '<S1504>/Constant Value4'
     *  Constant: '<S1504>/Constant Value6'
     *  Product: '<S1504>/Product2'
     *  Rounding: '<S1504>/Rounding1'
     *  Sum: '<S1504>/Sum3'
     */
    rtb_MinMax1_cn = fmaxf(ceilf((rtb_Product4 - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S1504>/Product' incorporates:
     *  Constant: '<S1421>/Calib'
     */
    rtb_Product4 = rtb_MinMax1_cn * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1504>/Protected Division' */
    /* Switch: '<S1523>/Switch1' incorporates:
     *  Constant: '<S1523>/Constant Value'
     *  Constant: '<S1523>/Constant Value1'
     *  Constant: '<S1523>/Constant Value2'
     *  Constant: '<S1523>/Constant Value3'
     *  Logic: '<S1523>/AND'
     *  RelationalOperator: '<S1523>/Greater Than or Equal '
     *  RelationalOperator: '<S1523>/Greater Than or Equal 1'
     *  RelationalOperator: '<S1523>/Not Equal'
     *  RelationalOperator: '<S1523>/Not Equal1'
     *  Sum: '<S1504>/Sum6'
     *  Switch: '<S1523>/Switch2'
     *  Switch: '<S1523>/Switch3'
     */
    if ((rtb_Sum6_do != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S1523>/Switch1' incorporates:
         *  Product: '<S1523>/Division'
         */
        rtb_Product4 = rtb_Sum6_do / rtb_Product4;
    }
    else if (rtb_Sum6_do > 0.0F)
    {
        /* Switch: '<S1523>/Switch2' incorporates:
         *  Constant: '<S1523>/MAXFLOAT'
         *  Switch: '<S1523>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else if (rtb_Sum6_do < 0.0F)
    {
        /* Switch: '<S1523>/Switch3' incorporates:
         *  Constant: '<S1523>/MINFLOAT'
         *  Switch: '<S1523>/Switch1'
         *  Switch: '<S1523>/Switch2'
         */
        rtb_Product4 = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1523>/Switch1' incorporates:
         *  Constant: '<S1523>/Constant Value4'
         *  Switch: '<S1523>/Switch2'
         *  Switch: '<S1523>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S1523>/Switch1' */
    /* End of Outputs for SubSystem: '<S1504>/Protected Division' */

    /* Switch: '<S1501>/Switch3' incorporates:
     *  Constant: '<S1509>/Calib'
     */
    if (!HeESSR_b_TrnstnJerkByps)
    {
        /* Switch: '<S1501>/Switch8' incorporates:
         *  Constant: '<S1501>/Constant Value7'
         *  RelationalOperator: '<S1501>/Comparison'
         */
        if (rtb_Sum6_do > 0.0F)
        {
            /* Switch: '<S1501>/Switch3' incorporates:
             *  Constant: '<S1421>/Calib'
             *  Constant: '<S1504>/Constant Value1'
             *  Constant: '<S1504>/Constant Value2'
             *  MinMax: '<S1501>/MinMax4'
             *  Product: '<S1501>/Product5'
             *  Product: '<S1504>/Product1'
             *  Sum: '<S1504>/Sum'
             *  Sum: '<S1504>/Sum2'
             *  Switch: '<S1501>/Switch8'
             */
            rtb_Switch1_cqe = fminf(rtb_Switch1_cqe, ((rtb_Product4 + rtb_Sum15)
                - (((0.5F * rtb_Switch1_gd) * (rtb_MinMax1_cn - 1.0F)) *
                   HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }
        else
        {
            /* Switch: '<S1501>/Switch3' incorporates:
             *  Constant: '<S1421>/Calib'
             *  Constant: '<S1504>/Constant Value1'
             *  Constant: '<S1504>/Constant Value2'
             *  MinMax: '<S1501>/MinMax5'
             *  Product: '<S1501>/Product2'
             *  Product: '<S1504>/Product1'
             *  Sum: '<S1504>/Sum'
             *  Sum: '<S1504>/Sum2'
             *  Switch: '<S1501>/Switch8'
             */
            rtb_Switch1_cqe = fmaxf(rtb_Switch1_cqe, ((rtb_Product4 + rtb_Sum15)
                - (((0.5F * rtb_Switch1_gd) * (rtb_MinMax1_cn - 1.0F)) *
                   HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }

        /* End of Switch: '<S1501>/Switch8' */
    }

    /* Outputs for Atomic SubSystem: '<S1501>/Limiter6' */
    /* RelationalOperator: '<S1517>/Relational Operator' */
    rtb_OR_dp = (rtb_Switch_kx <= rtb_Switch1_cqe);

    /* Switch: '<S1517>/Switch1' */
    if (rtb_OR_dp)
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = rtb_Switch_kx;
    }
    else
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = rtb_Switch1_cqe;
    }

    /* End of Switch: '<S1517>/Switch1' */

    /* RelationalOperator: '<S1517>/Relational Operator1' */
    rtb_LogicalOperator21 = (rtb_Switch1_gd > rtb_Gain_lw);

    /* Switch: '<S1517>/Switch' */
    if (rtb_LogicalOperator21)
    {
        rtb_Gain_lw = rtb_Switch1_gd;
    }

    /* End of Switch: '<S1517>/Switch' */
    /* End of Outputs for SubSystem: '<S1501>/Limiter6' */

    /* Sum: '<S1501>/Sum4' incorporates:
     *  Delay: '<S1413>/Integer Delay'
     */
    rtb_IntegerDelay = rtb_Gain_lw + localDW->IntegerDelay_DSTATE;

    /* Outputs for Atomic SubSystem: '<S1501>/Limiter1' */
    /* RelationalOperator: '<S1512>/Relational Operator' incorporates:
     *  DataStoreWrite: '<S1413>/Dsw_InputSpeedProfile5'
     */
    VeESSR_b_NiMaxActive_DS = (rtu_VeHSER_n_NiMax <= rtb_IntegerDelay);

    /* Switch: '<S1512>/Switch1' incorporates:
     *  DataStoreWrite: '<S1413>/Dsw_InputSpeedProfile5'
     */
    if (VeESSR_b_NiMaxActive_DS)
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = rtu_VeHSER_n_NiMax;
    }
    else
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = rtb_IntegerDelay;
    }

    /* End of Switch: '<S1512>/Switch1' */

    /* Switch: '<S1512>/Switch' incorporates:
     *  Constant: '<S1501>/Constant Value4'
     *  RelationalOperator: '<S1512>/Relational Operator1'
     */
    if (rtb_Switch1_gd > 0.0F)
    {
        /* Switch: '<S1512>/Switch' */
        rtb_IntegerDelay = rtb_Switch1_gd;
    }
    else
    {
        /* Switch: '<S1512>/Switch' */
        rtb_IntegerDelay = 0.0F;
    }

    /* End of Switch: '<S1512>/Switch' */
    /* End of Outputs for SubSystem: '<S1501>/Limiter1' */

    /* Product: '<S1501>/Product3' incorporates:
     *  Constant: '<S1421>/Calib'
     *  DataStoreWrite: '<S1413>/Dsw_InputAcceltnProf'
     *  Delay: '<S1413>/Integer Delay'
     *  Sum: '<S1501>/Sum'
     */
    VeESSR_dn_InputAcceltnProf_DS = (rtb_IntegerDelay -
        localDW->IntegerDelay_DSTATE) / HeESSR_t_MedTEB_dT;

    /* Switch: '<S1413>/Switch2' incorporates:
     *  Constant: '<S1420>/Calib'
     *  Constant: '<S1428>/Calib'
     *  DataStoreWrite: '<S1413>/Dsw_InputSpeedProfile'
     *  Sum: '<S1413>/Add'
     */
    if (HeESSR_b_EnblLQRConfig)
    {
        VeESSR_n_InputSpeedProfile_DS = rtu_VeESSR_n_TransInSpdFlt +
            KeESSR_n_ActNiDeltaLQIR;
    }
    else
    {
        VeESSR_n_InputSpeedProfile_DS = rtb_IntegerDelay;
    }

    /* End of Switch: '<S1413>/Switch2' */

    /* Logic: '<S1501>/Logical2' incorporates:
     *  DataStoreWrite: '<S1413>/Dsw_InputSpeedProfile1'
     */
    VeESSR_b_NiDotMaxActive_DS = (rtb_Equal2_p3 && rtb_OR_dp);

    /* DataStoreWrite: '<S1413>/Dsw_InputSpeedProfile2' */
    VeESSR_n_TargetSpeed_DS = rtb_Sum1_ih;

    /* DataStoreWrite: '<S1413>/Dsw_InputSpeedProfile3' */
    VeESSR_dn_TargetAcceltn_DS = rtb_Sum15;

    /* Outputs for Atomic SubSystem: '<S1501>/Limiter6' */
    /* Logic: '<S1501>/Logical' incorporates:
     *  DataStoreWrite: '<S1413>/Dsw_InputSpeedProfile4'
     *  Logic: '<S1517>/Logical2'
     */
    VeESSR_b_NiDotMinActive_DS = (rtb_LogicalOperator3_ap &&
        (!rtb_LogicalOperator21));

    /* End of Outputs for SubSystem: '<S1501>/Limiter6' */

    /* SignalConversion generated from: '<S1413>/Variant Source' incorporates:
     *  Lookup_n-D: '<S1544>/Vector'
     *  MinMax: '<S1434>/MinMax'
     *  Product: '<S1434>/Multiplication'
     *  Sum: '<S1434>/Summation5'
     */
#if !Rte_SysCon_Variant_ESSR_12vBSG

    /* Switch: '<S1486>/Switch1' incorporates:
     *  Constant: '<S1413>/Constant Value1'
     */
    rtb_Switch1_l3 = 0.0F;

#else

    /* Outputs for Atomic SubSystem: '<S1434>/Limiter' */
    /* Outputs for Atomic SubSystem: '<S1434>/DeadBand' */
    /* Sum: '<S1434>/Summation5' incorporates:
     *  MinMax: '<S1434>/MinMax'
     */
    VeESSR_n_SpinUpSpdError = fmaxf(rtb_IntegerDelay, rtu_VeESSR_n_TransInSpdFlt)
        - rtu_VeESSR_n_TransInSpdFlt;

    /* Switch: '<S1538>/Switch1' incorporates:
     *  Constant: '<S1538>/Constant Value'
     *  Constant: '<S1542>/Calib'
     *  Constant: '<S1543>/Calib'
     *  RelationalOperator: '<S1538>/Greater  Than'
     *  RelationalOperator: '<S1538>/Greater  Than1'
     *  Sum: '<S1538>/Subtraction'
     *  Switch: '<S1538>/Switch2'
     */
    if (VeESSR_n_SpinUpSpdError >= KeESSR_n_SpinUpSpdCtlPosDdBnd)
    {
        rtb_Switch1_gd = VeESSR_n_SpinUpSpdError - KeESSR_n_SpinUpSpdCtlPosDdBnd;
    }
    else if (VeESSR_n_SpinUpSpdError <= KeESSR_n_SpinUpSpdCtlNegDdBnd)
    {
        /* Switch: '<S1538>/Switch2' incorporates:
         *  Constant: '<S1542>/Calib'
         *  Sum: '<S1538>/Subtraction1'
         */
        rtb_Switch1_gd = VeESSR_n_SpinUpSpdError - KeESSR_n_SpinUpSpdCtlNegDdBnd;
    }
    else
    {
        rtb_Switch1_gd = 0.0F;
    }

    /* End of Switch: '<S1538>/Switch1' */

    /* Product: '<S1434>/Multiplication' incorporates:
     *  Constant: '<S1539>/Calib'
     *  DataStoreRead: '<S1434>/Dsr_STMTmr3'
     *  Lookup_n-D: '<S1544>/Vector'
     */
    rtb_Switch1_l3 = (rtb_Switch1_gd * KeESSR_K_SpinUpSpdCtlPgain) *
        look1_iflf_binlcapw(VeESSR_t_STMTmr_DS, ((const float32 *)
        &(KxESSR_K_SpinUpSpdCtlPgainComp[0])), ((const float32 *)
        &(KtESSR_K_SpinUpSpdCtlPgainComp[0])), 5U);

    /* Switch: '<S1545>/Switch1' incorporates:
     *  Constant: '<S1540>/Calib'
     *  RelationalOperator: '<S1545>/Relational Operator'
     */
    if (KeESSR_M_SpinUpSpdCtlMaxTi < rtb_Switch1_l3)
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = KeESSR_M_SpinUpSpdCtlMaxTi;
    }
    else
    {
        /* Switch: '<S1545>/Switch1' */
        rtb_Switch1_gd = rtb_Switch1_l3;
    }

    /* End of Switch: '<S1545>/Switch1' */

    /* Switch: '<S1545>/Switch' incorporates:
     *  Constant: '<S1541>/Calib'
     *  RelationalOperator: '<S1545>/Relational Operator1'
     */
    if (rtb_Switch1_gd > KeESSR_M_SpinUpSpdCtlMinTi)
    {
        /* Switch: '<S1545>/Switch' */
        VeESSR_M_SpinUpPSpdCtl = rtb_Switch1_gd;
    }
    else
    {
        /* Switch: '<S1545>/Switch' */
        VeESSR_M_SpinUpPSpdCtl = KeESSR_M_SpinUpSpdCtlMinTi;
    }

    /* End of Switch: '<S1545>/Switch' */

    /* Switch: '<S1486>/Switch1' */
    rtb_Switch1_l3 = VeESSR_M_SpinUpPSpdCtl;

    /* End of Outputs for SubSystem: '<S1434>/DeadBand' */
    /* End of Outputs for SubSystem: '<S1434>/Limiter' */
#endif

    /* Switch: '<S1486>/Switch1' incorporates:
     *  Sum: '<S1413>/Summation5'
     */
    rtb_Switch1_l3 += VeESSR_M_SpinUpISpdCtl;

    /* MinMax: '<S1413>/MinMax2' incorporates:
     *  DataStoreWrite: '<S1413>/Dsw_InputTorqEst'
     */
    VeESSR_M_EngTorqEst_DS = fmaxf(rtu_HTDR_TiMin, rtb_Switch1_l3);

    /* DataStoreWrite: '<S1413>/Dsw_Ni1stFlt_DS' */
    VeESSR_n_Ni1stFlt_DS = rtb_Product2_jm;

    /* DataStoreWrite: '<S1413>/Dsw_STMTmr' incorporates:
     *  Constant: '<S1421>/Calib'
     *  DataStoreRead: '<S1413>/Dsr_STMTmr'
     *  Sum: '<S1413>/Summation1'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Switch: '<S1422>/Switch1' incorporates:
     *  DataStoreWrite: '<S1413>/Dsw_STMTrigger'
     *  Merge: '<S1432>/Merge1'
     *  Switch: '<S1422>/Switch2'
     *  Switch: '<S1422>/Switch3'
     */
    if (rtb_GreaterThan_kf)
    {
        VeESSR_e_STMTrigger_DS = rtb_Merge1_d;
    }
    else if (rtb_Logical8_gu)
    {
        /* Switch: '<S1422>/Switch1' incorporates:
         *  DataStoreWrite: '<S1413>/Dsw_STMTrigger'
         *  Merge: '<S1432>/Merge2'
         *  Switch: '<S1422>/Switch2'
         */
        VeESSR_e_STMTrigger_DS = rtb_Merge2_h;
    }
    else
    {
        if (rtb_GreaterThan3_b)
        {
            /* Switch: '<S1422>/Switch1' incorporates:
             *  DataStoreWrite: '<S1413>/Dsw_STMTrigger'
             *  Merge: '<S1432>/Merge5'
             *  Switch: '<S1422>/Switch2'
             *  Switch: '<S1422>/Switch3'
             */
            VeESSR_e_STMTrigger_DS = rtb_Merge5_n;
        }
    }

    /* End of Switch: '<S1422>/Switch1' */

    /* Abs: '<S1419>/Abs' incorporates:
     *  Constant: '<S1421>/Calib'
     *  Constant: '<S1426>/Calib'
     *  Product: '<S1419>/Multiplication'
     */
    rtb_Switch1_l3 = fabsf(KeESSR_dscl_RampUpRate * HeESSR_t_MedTEB_dT);

    /* Gain: '<S1419>/Gain' */
    rtb_Product2_jm = -rtb_Switch1_l3;

    /* Sum: '<S1419>/Sum' incorporates:
     *  Constant: '<S1429>/Calib'
     *  DataStoreRead: '<S1413>/Dsr_SpdCtlGainMod1'
     */
    rtb_Sum15 = KeESSR_scl_RampUpHold - VeESSR_scl_SpdCtlGainMod_DS;

    /* Outputs for Atomic SubSystem: '<S1419>/Limiter1' */
    /* Switch: '<S1485>/Switch1' incorporates:
     *  RelationalOperator: '<S1485>/Relational Operator'
     */
    if (rtb_Switch1_l3 >= rtb_Sum15)
    {
        /* Switch: '<S1486>/Switch1' */
        rtb_Switch1_l3 = rtb_Sum15;
    }

    /* End of Switch: '<S1485>/Switch1' */

    /* Switch: '<S1485>/Switch' incorporates:
     *  RelationalOperator: '<S1485>/Relational Operator1'
     */
    if (rtb_Switch1_l3 > rtb_Product2_jm)
    {
        rtb_Product2_jm = rtb_Switch1_l3;
    }

    /* End of Switch: '<S1485>/Switch' */
    /* End of Outputs for SubSystem: '<S1419>/Limiter1' */

    /* Sum: '<S1419>/Sum1' incorporates:
     *  DataStoreRead: '<S1413>/Dsr_SpdCtlGainMod1'
     */
    rtb_Switch1_l3 = rtb_Product2_jm + VeESSR_scl_SpdCtlGainMod_DS;

    /* Outputs for Atomic SubSystem: '<S1419>/Limiter2' */
    /* Switch: '<S1486>/Switch1' incorporates:
     *  Constant: '<S1413>/Constant Value7'
     *  RelationalOperator: '<S1486>/Relational Operator'
     */
    if (2.0F < rtb_Switch1_l3)
    {
        /* Switch: '<S1486>/Switch1' */
        rtb_Switch1_l3 = 2.0F;
    }

    /* End of Switch: '<S1486>/Switch1' */

    /* Switch: '<S1486>/Switch' incorporates:
     *  Constant: '<S1413>/Constant Value6'
     *  DataStoreWrite: '<S1413>/Dsw_SpdCtlGainMod1'
     *  RelationalOperator: '<S1486>/Relational Operator1'
     */
    if (rtb_Switch1_l3 > 0.0F)
    {
        VeESSR_scl_SpdCtlGainMod_DS = rtb_Switch1_l3;
    }
    else
    {
        VeESSR_scl_SpdCtlGainMod_DS = 0.0F;
    }

    /* End of Switch: '<S1486>/Switch' */
    /* End of Outputs for SubSystem: '<S1419>/Limiter2' */

    /* Switch: '<S1413>/Switch4' incorporates:
     *  Constant: '<S1413>/Constant Value'
     *  DataStoreRead: '<S1413>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S1413>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S1413>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S1413>/Logical1'
     *  Logic: '<S1413>/Logical21'
     *  RelationalOperator: '<S1413>/Comparison'
     *  S-Function (sfix_bitop): '<S1413>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S1415>/FixPt Bitwise Operator1'
     */
    if ((rtb_Logical8_gu || rtb_GreaterThan3_b) &&
            ((VeESSR_g_StrtStpFailPhaseSelect_DS & 32U) > 0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 32U;
    }

    /* End of Switch: '<S1413>/Switch4' */

    /* Sum: '<S1501>/Sum17' incorporates:
     *  DataStoreWrite: '<S1413>/Dsw_InputAcceltnProf'
     */
    VeESSR_dn_InputJerkProfSpinUpEng = VeESSR_dn_InputAcceltnProf_DS -
        rtb_Gain_k;

    /* Update for Delay: '<S1413>/Integer Delay' */
    localDW->IntegerDelay_DSTATE = rtb_IntegerDelay;

    /* Update for UnitDelay: '<S1520>/Unit Delay' incorporates:
     *  Switch: '<S1520>/Switch3'
     */
    localDW->UnitDelay_DSTATE = rtb_UnitDelay_fx;

    /* Update for Delay: '<S1501>/IntegerDelay' */
    localDW->icLoad = 0U;
    for (i = 0; i < 15; i++)
    {
        localDW->IntegerDelay_DSTATE_p[i] = localDW->IntegerDelay_DSTATE_p[i + 1];
    }

    localDW->IntegerDelay_DSTATE_p[15] = rtb_Sum1_ih;

    /* End of Update for Delay: '<S1501>/IntegerDelay' */
}

#endif

/*
 * Output and update for action system:
 *    '<S1571>/ESSC_CmbstnNoDelay'
 *    '<S1864>/ESSC_CombstNoDelay'
 *    '<S2082>/ESSC_CombstNoDelay'
 *    '<S2238>/ESSC_CombstNoDelay'
 *    '<S2306>/ESSC_CombstNoDelay'
 *    '<S579>/ESSC_CombstNoDelay'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_CmbstnNoDelay(P2VAR(boolean,
    AUTOMATIC, ESSR_VAR_INIT) rty_OutputParameter)
{
    /* SignalConversion generated from: '<S1605>/OutputParameter' incorporates:
     *  Constant: '<S1605>/FALSE Constant'
     */
    *rty_OutputParameter = false;
}

#endif

/*
 * Output and update for action system:
 *    '<S1564>/If_KeyCrank_P1C65'
 *    '<S1299>/If_KeyCrank_P1C65'
 *    '<S1359>/If_KeyCrank_P1C65'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_If_KeyCrank_P1C65(P2VAR
    (TeESSR_e_StrtStpFailDTC, AUTOMATIC, ESSR_VAR_INIT) rty_DTC)
{
    /* SignalConversion generated from: '<S1579>/DTC' incorporates:
     *  Constant: '<S1668>/Constant'
     */
    *rty_DTC = CeESSR_e_P1C65;
}

#endif

/*
 * Output and update for action system:
 *    '<S1564>/If_KeyCrank_NoFault'
 *    '<S1855>/If_StartEng_NoFault'
 *    '<S1241>/If_KeyCrank_NoFault'
 *    '<S2076>/If_StartEng_NoFault'
 *    '<S1299>/If_KeyCrank_NoFault'
 *    '<S2230>/If_StartEng_NoFault'
 *    '<S2297>/If_StartEng_NoFault'
 *    '<S573>/If_StartEng_NoFault'
 *    '<S1359>/If_KeyCrank_NoFault'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_If_KeyCrank_NoFault(P2VAR
    (TeESSR_e_StrtStpFailDTC, AUTOMATIC, ESSR_VAR_INIT) rty_NoDTC)
{
    /* SignalConversion generated from: '<S1578>/NoDTC' incorporates:
     *  Constant: '<S1667>/Constant'
     */
    *rty_NoDTC = CeESSR_e_NoFault;
}

#endif

/* System initialize for function-call system: '<S566>/SpinUp_CKS_Dur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpinUp_CKS_Dur_Init(P2VAR
    (DW_SpinUp_CKS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW)
{
    /* SystemInitialize for IfAction SubSystem: '<S1564>/FastSpin' */
    /* InitializeConditions for Delay: '<S1630>/IntegerDelay' */
    localDW->icLoad_f = 1U;

    /* End of SystemInitialize for SubSystem: '<S1564>/FastSpin' */

    /* SystemInitialize for IfAction SubSystem: '<S1564>/SlowSpin' */
    /* InitializeConditions for Delay: '<S1681>/IntegerDelay' */
    localDW->icLoad = 1U;

    /* End of SystemInitialize for SubSystem: '<S1564>/SlowSpin' */
}

#endif

/* Output and update for function-call system: '<S566>/SpinUp_CKS_Dur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpinUp_CKS_Dur(VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_TransInSpdFlt, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_AddtlDragTorq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeESMR_P_BatSTMaxLim, VAR(float32, AUTOMATIC)
    rtu_VeESMR_P_BatEstdVoltMaxLim, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngStrtTrqSnsd, VAR(float32, AUTOMATIC)
    rtu_VeENGR_T_EngCoolantTemp, VAR(float32, AUTOMATIC) rtu_VeENGR_t_EngOffTime,
    VAR(float32, AUTOMATIC) rtu_VeHSER_n_NiMax, VAR(float32, AUTOMATIC)
    rtu_VeHSER_dn_NiDotMax, VAR(float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMin, VAR
    (float32, AUTOMATIC) rtu_VeABCR_P_HV_AccPwr, P2VAR
    (DW_SpinUp_CKS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR
    (ZCE_SpinUp_CKS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localZCE, P2VAR
    (uint32, AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_g_StrtStpFailRsn)
{
    sint32 i;
    float32 rtb_Abs2_h;
    float32 rtb_Gain1_e1;
    float32 rtb_Gain_my;
    float32 rtb_Gain_o;
    float32 rtb_IntegerDelay;
    float32 rtb_Product4;
    float32 rtb_Product4_o;
    float32 rtb_Sum15;
    float32 rtb_Sum2_h5;
    float32 rtb_Sum6_ax;
    float32 rtb_SumSub_j;
    float32 rtb_Summation_eb;
    float32 rtb_Summation_np;
    float32 rtb_Switch1_fz;
    float32 rtb_Switch1_lp;
    float32 rtb_Switch_hy;
    float32 rtb_UnitDelay_b4;
    uint8 tmp;
    boolean rtb_Equal_n;
    boolean rtb_GreaterThan1_ix;
    boolean rtb_GreaterThan3_e;
    boolean rtb_Logical2_bmg;
    boolean rtb_LogicalOperator1_ny;
    boolean rtb_Merge_hn;
    boolean rtb_RelationalOperator_a2;
    boolean rtb_Switch1_oq;

    /* RelationalOperator: '<S1564>/Greater  Than3' incorporates:
     *  Constant: '<S1583>/Calib'
     *  Constant: '<S1584>/Calib'
     *  Sum: '<S1564>/Summation3'
     */
    rtb_GreaterThan3_e = (rtu_VeESSR_n_TransInSpdFlt > (KeESSR_n_FastSpinTgt +
                           KeESSR_n_FastSpinDelta));

    /* RelationalOperator: '<S1564>/Greater  Than1' incorporates:
     *  Constant: '<S1588>/Calib'
     *  DataStoreRead: '<S1564>/Dsr_STMTmr1'
     */
    rtb_GreaterThan1_ix = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmSpinUp_CKS);

    /* Logic: '<S1564>/Logical Operator1' incorporates:
     *  Logic: '<S1564>/Logical Operator'
     */
    rtb_LogicalOperator1_ny = ((!rtb_GreaterThan3_e) && rtb_GreaterThan1_ix);

    /* Switch: '<S1564>/Switch' incorporates:
     *  S-Function (sfix_bitop): '<S1566>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator1_ny)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 16U;
    }

    /* End of Switch: '<S1564>/Switch' */

    /* Switch: '<S1575>/Switch1' incorporates:
     *  Constant: '<S1564>/Constant Value'
     *  Constant: '<S1574>/Calib'
     *  Constant: '<S1585>/Calib'
     *  Constant: '<S1586>/Calib'
     *  DataStoreRead: '<S1564>/Dsr_KneePtTm'
     *  DataStoreWrite: '<S1564>/Dsw_KneePtTm'
     *  RelationalOperator: '<S1564>/Greater  Than'
     *  Sum: '<S1564>/Summation1'
     *  Sum: '<S1564>/Summation2'
     */
    if (rtu_VeESSR_n_TransInSpdFlt > (KeESSR_n_SlowSpinTgt +
            KeESSR_n_SlowSpinDelta))
    {
        VeESSR_t_KneePtTm_DS = HeESSR_t_MedTEB_dT + VeESSR_t_KneePtTm_DS;
    }
    else
    {
        VeESSR_t_KneePtTm_DS = 0.0F;
    }

    /* End of Switch: '<S1575>/Switch1' */

    /* RelationalOperator: '<S1564>/Equal' incorporates:
     *  Constant: '<S1564>/Constant Value1'
     *  DataStoreRead: '<S1564>/Dsr_STMTmr'
     */
    rtb_Equal_n = (0.0F == VeESSR_t_STMTmr_DS);

    /* Switch: '<S1669>/Switch1' */
    if (rtb_Equal_n)
    {
        /* Switch: '<S1669>/Switch1' incorporates:
         *  Constant: '<S1589>/Calib'
         *  DataStoreWrite: '<S1564>/Dsw_KneePtTm'
         *  RelationalOperator: '<S1564>/Greater  Than2'
         */
        VeESSR_b_SlowSpinActv = (VeESSR_t_KneePtTm_DS > KeESSR_t_MinKneePtTm);
    }
    else
    {
        /* Switch: '<S1669>/Switch1' incorporates:
         *  Constant: '<S1589>/Calib'
         *  DataStoreWrite: '<S1564>/Dsw_KneePtTm'
         *  Logic: '<S1590>/OR'
         *  RelationalOperator: '<S1564>/Greater  Than2'
         *  UnitDelay: '<S1590>/Unit Delay'
         */
        VeESSR_b_SlowSpinActv = ((VeESSR_t_KneePtTm_DS > KeESSR_t_MinKneePtTm) ||
            (VeESSR_b_SlowSpinActv));
    }

    /* End of Switch: '<S1669>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S1571>/DeltaOneStep' */
    /* Sum: '<S1603>/Sum//Sub' incorporates:
     *  UnitDelay: '<S1603>/Unit Delay'
     */
    rtb_SumSub_j = rtu_VeESSR_M_EngTrqAct_Lmtd - localDW->UnitDelay_DSTATE_e;

    /* Update for UnitDelay: '<S1603>/Unit Delay' */
    localDW->UnitDelay_DSTATE_e = rtu_VeESSR_M_EngTrqAct_Lmtd;

    /* End of Outputs for SubSystem: '<S1571>/DeltaOneStep' */

    /* Outputs for Atomic SubSystem: '<S1571>/Signal Latch On With Reset' */
    /* Logic: '<S1609>/OR1' incorporates:
     *  Constant: '<S1608>/Calib'
     *  Logic: '<S1609>/NOT'
     *  Logic: '<S1609>/OR'
     *  RelationalOperator: '<S1571>/Comparison'
     *  UnitDelay: '<S1609>/Unit Delay'
     */
    VeESSR_b_EngTrqAct_LmtdLtchd = ((rtb_SumSub_j > KeESSR_dM_EngTrqActlFueled) ||
        ((!rtb_Equal_n) && (VeESSR_b_EngTrqAct_LmtdLtchd)));

    /* End of Outputs for SubSystem: '<S1571>/Signal Latch On With Reset' */

    /* Outputs for Atomic SubSystem: '<S1571>/EdgeRising' */
    /* Merge: '<S1571>/Merge' incorporates:
     *  UnitDelay: '<S1606>/Unit Delay'
     */
    rtb_Merge_hn = localDW->UnitDelay_DSTATE_f;

    /* Update for UnitDelay: '<S1606>/Unit Delay' */
    localDW->UnitDelay_DSTATE_f = VeESSR_b_EngTrqAct_LmtdLtchd;

    /* End of Outputs for SubSystem: '<S1571>/EdgeRising' */

    /* If: '<S1571>/If1' */
    if (VeESSR_b_EngTrqAct_LmtdLtchd)
    {
        /* Outputs for IfAction SubSystem: '<S1571>/ESSC_CmbstnDelay' incorporates:
         *  ActionPort: '<S1604>/Action Port'
         */
        /* Outputs for Atomic SubSystem: '<S1604>/Stop Watch Reset Enabled' */
        /* Outputs for Atomic SubSystem: '<S1571>/EdgeRising' */
        /* Switch: '<S1612>/Switch1' incorporates:
         *  Logic: '<S1606>/AND'
         *  Logic: '<S1606>/OR1'
         */
        if ((VeESSR_b_EngTrqAct_LmtdLtchd) && (!rtb_Merge_hn))
        {
            /* Switch: '<S1612>/Switch1' incorporates:
             *  Constant: '<S1612>/Constant Value2'
             */
            VeESSR_t_CmbstnDlyTm = 0.0F;
        }
        else
        {
            /* Switch: '<S1612>/Switch1' incorporates:
             *  Constant: '<S1574>/Calib'
             *  Sum: '<S1612>/Subtraction'
             *  UnitDelay: '<S1612>/Unit Delay'
             */
            VeESSR_t_CmbstnDlyTm = HeESSR_t_MedTEB_dT + VeESSR_t_CmbstnDlyTm;
        }

        /* End of Switch: '<S1612>/Switch1' */
        /* End of Outputs for SubSystem: '<S1571>/EdgeRising' */
        /* End of Outputs for SubSystem: '<S1604>/Stop Watch Reset Enabled' */

        /* RelationalOperator: '<S1604>/Equal1' incorporates:
         *  Lookup_n-D: '<S1610>/Vector'
         */
        VeESSR_b_CmbstnDlyHold = (VeESSR_t_CmbstnDlyTm <= look2_iflf_binlcapw
            (rtu_VeENGR_T_EngCoolantTemp, rtu_VeENGR_t_EngOffTime, ((const
            float32 *)&(KxESSR_t_MaxCmbstnDlyTm[0])), ((const float32 *)
            &(KyESSR_t_MaxCmbstnDlyTm[0])), ((const float32 *)
            &(KtESSR_t_MaxCmbstnDlyTm[0])), ESSR_ac_ConstP.Vector_maxIndex, 10U));

        /* Merge: '<S1571>/Merge' incorporates:
         *  Gain: '<S1611>/Gain'
         */
        rtb_Merge_hn = VeESSR_b_CmbstnDlyHold;

        /* End of Outputs for SubSystem: '<S1571>/ESSC_CmbstnDelay' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1571>/ESSC_CmbstnNoDelay' incorporates:
         *  ActionPort: '<S1605>/Action Port'
         */
        ESSR_ac_ESSC_CmbstnNoDelay(&rtb_Merge_hn);

        /* End of Outputs for SubSystem: '<S1571>/ESSC_CmbstnNoDelay' */
    }

    /* End of If: '<S1571>/If1' */

    /* Logic: '<S1607>/Logical Operator2' incorporates:
     *  Lookup_n-D: '<S1613>/Vector'
     *  RelationalOperator: '<S1607>/Equal2'
     */
    VeESSR_b_SnsdChkCmplt = ((rtu_VeESSR_M_EngStrtTrqSnsd > look2_iflf_binlcapw
        (rtu_VeENGR_T_EngCoolantTemp, rtu_VeENGR_t_EngOffTime, ((const float32 *)
        &(KxESSR_M_MinEngStrtTqSnsdCKS[0])), ((const float32 *)
        &(KyESSR_M_MinEngStrtTqSnsdCKS[0])), ((const float32 *)
        &(KtESSR_M_MinEngStrtTqSnsdCKS[0])), ESSR_ac_ConstP.Vector_maxIndex_g,
         4U)) && (VeESSR_b_EngTrqAct_LmtdLtchd));

    /* Switch: '<S1615>/Switch1' */
    if (rtb_Equal_n)
    {
        /* Switch: '<S1615>/Switch1' */
        rtb_Switch1_oq = VeESSR_b_SnsdChkCmplt;
    }
    else
    {
        /* Switch: '<S1615>/Switch1' incorporates:
         *  Logic: '<S1614>/OR'
         *  UnitDelay: '<S1614>/Unit Delay'
         */
        rtb_Switch1_oq = ((VeESSR_b_SnsdChkCmplt) ||
                          (localDW->UnitDelay_DSTATE_oj));
    }

    /* End of Switch: '<S1615>/Switch1' */

    /* Logic: '<S1607>/Logical Operator1' */
    VeESSR_b_SnsdChkCmpltLtchd = (rtb_Switch1_oq || rtb_Equal_n);

    /* Logic: '<S1571>/Logical Operator2' incorporates:
     *  Logic: '<S1571>/Logical Operator1'
     *  Logic: '<S1571>/Logical Operator9'
     */
    VeESSR_b_FuelDlyHold = (rtb_Merge_hn && (!VeESSR_b_SnsdChkCmpltLtchd));

    /* Switch: '<S1577>/Switch1' incorporates:
     *  Constant: '<S1580>/Calib'
     *  Constant: '<S1581>/Calib'
     *  Logic: '<S1564>/Logical1'
     *  Logic: '<S1564>/Logical2'
     *  Switch: '<S1577>/Switch2'
     */
    if ((KeESSR_b_UseActlTrqCKS) && (VeESSR_b_FuelDlyHold))
    {
        /* Switch: '<S1577>/Switch1' */
        rtb_SumSub_j = rtu_VeESSR_M_EngTrqAct_Lmtd;
    }
    else if ((VeESSR_b_FuelDlyHold) && (KeESSR_b_UseSnsdTrqCKS))
    {
        /* Switch: '<S1577>/Switch2' incorporates:
         *  Switch: '<S1577>/Switch1'
         */
        rtb_SumSub_j = rtu_VeESSR_M_EngStrtTrqSnsd;
    }
    else
    {
        /* Switch: '<S1577>/Switch1' incorporates:
         *  Switch: '<S1577>/Switch2'
         */
        rtb_SumSub_j = rtu_VeESSR_M_EngTrqAct_Lmtd;
    }

    /* End of Switch: '<S1577>/Switch1' */

    /* If: '<S1564>/If' */
    if (VeESSR_b_SlowSpinActv)
    {
        /* Outputs for IfAction SubSystem: '<S1564>/FastSpin' incorporates:
         *  ActionPort: '<S1573>/Action Port'
         */
        /* Gain: '<S1627>/Gain' incorporates:
         *  Abs: '<S1627>/Abs1'
         *  DataStoreRead: '<S1573>/Dsr_NiProfGenDNiDLim1'
         */
        rtb_Gain_o = -fabsf(VeESSR_dn_StrtTypJerkMin_DS);

        /* Product: '<S1630>/Product4' incorporates:
         *  Constant: '<S1619>/Calib'
         */
        rtb_Product4 = rtb_Gain_o / HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S1627>/LowpassT Reset Enabled' */
        /* Sum: '<S1628>/Summation' incorporates:
         *  Constant: '<S1619>/Calib'
         *  Constant: '<S1623>/Calib'
         *  DataStoreRead: '<S1573>/Dsr_Ni1stFlt_DS'
         *  DataStoreRead: '<S1573>/Dsr_NiProfGenT2Gain'
         *  MinMax: '<S1628>/Maximum'
         *  Product: '<S1628>/Multiplication'
         *  Product: '<S1628>/Multiplication1'
         *  Sum: '<S1628>/Subtraction'
         */
        rtb_Summation_np = (((KeESSR_n_FastSpinTgt - VeESSR_n_Ni1stFlt_DS) *
                             HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                             (VeESSR_k_StrtTypScndOrdLwPassT_DS,
                              HeESSR_t_MedTEB_dT))) + VeESSR_n_Ni1stFlt_DS;

        /* End of Outputs for SubSystem: '<S1627>/LowpassT Reset Enabled' */

        /* Outputs for Atomic SubSystem: '<S1627>/LowpassT Reset Enabled1' */
        /* Sum: '<S1629>/Summation' incorporates:
         *  Constant: '<S1619>/Calib'
         *  DataStoreRead: '<S1573>/Dsr_InputSpeedProfile2'
         *  DataStoreRead: '<S1573>/Dsr_NiProfGenT1Gain'
         *  MinMax: '<S1629>/Maximum'
         *  Product: '<S1629>/Multiplication'
         *  Product: '<S1629>/Multiplication1'
         *  Sum: '<S1629>/Subtraction'
         */
        rtb_Summation_eb = (((rtb_Summation_np - VeESSR_n_InputSpeedProfile_DS) *
                             HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                             (VeESSR_k_StrtTypFrstOrdLwPassT_DS,
                              HeESSR_t_MedTEB_dT))) +
            VeESSR_n_InputSpeedProfile_DS;

        /* End of Outputs for SubSystem: '<S1627>/LowpassT Reset Enabled1' */

        /* Switch: '<S1649>/Switch1' incorporates:
         *  UnitDelay: '<S1649>/Unit Delay'
         */
        if (rtb_Equal_n)
        {
            rtb_Gain1_e1 = rtb_Summation_eb;
        }
        else
        {
            rtb_Gain1_e1 = localDW->UnitDelay_DSTATE_c;
        }

        /* End of Switch: '<S1649>/Switch1' */

        /* Gain: '<S1630>/Gain1' incorporates:
         *  Sum: '<S1630>/Sum18'
         */
        rtb_Gain1_e1 = (rtb_Summation_eb + rtb_Gain1_e1) * 0.5F;

        /* Delay: '<S1630>/IntegerDelay' incorporates:
         *  Constant: '<S1639>/Calib'
         */
        if (rtb_Equal_n && (((uint32)localZCE->IntegerDelay_Reset_ZCE_h) !=
                            POS_ZCSIG))
        {
            localDW->icLoad_f = 1U;
        }

        localZCE->IntegerDelay_Reset_ZCE_h = rtb_Equal_n ? ((ZCSigState)1) :
            ((ZCSigState)0);
        if (((sint32)localDW->icLoad_f) != 0)
        {
            for (i = 0; i < 16; i++)
            {
                localDW->IntegerDelay_DSTATE_e[i] = rtb_Gain1_e1;
            }
        }

        if (((sint32)KeESSR_Cnt_DelayOptNi) <= 0)
        {
            /* Delay: '<S1630>/IntegerDelay' */
            rtb_IntegerDelay = rtb_Gain1_e1;
        }
        else
        {
            if (((sint32)KeESSR_Cnt_DelayOptNi) > 16)
            {
                tmp = 16U;
            }
            else
            {
                tmp = KeESSR_Cnt_DelayOptNi;
            }

            /* Delay: '<S1630>/IntegerDelay' */
            rtb_IntegerDelay = localDW->IntegerDelay_DSTATE_e[(uint8)(16U -
                ((uint32)tmp))];
        }

        /* End of Delay: '<S1630>/IntegerDelay' */

        /* Sum: '<S1630>/Sum15' incorporates:
         *  Abs: '<S1630>/Abs4'
         *  Constant: '<S1621>/Calib'
         *  DataStoreRead: '<S1573>/Dsr_InputSpeedProfile5'
         */
        rtb_Sum15 = fabsf(VeESSR_dn_TargetAcceltn_DS) +
            KeESSR_dn_NiTargetJerkLimit;

        /* Outputs for Atomic SubSystem: '<S1630>/GradientLimiter' */
        /* Sum: '<S1632>/Sum2' incorporates:
         *  Constant: '<S1619>/Calib'
         *  DataStoreRead: '<S1573>/Dsr_InputSpeedProfile4'
         *  Product: '<S1630>/Product6'
         *  Sum: '<S1630>/Sum14'
         *  UnitDelay: '<S1632>/Unit Delay'
         */
        rtb_Sum2_h5 = ((rtb_Gain1_e1 - VeESSR_n_TargetSpeed_DS) /
                       HeESSR_t_MedTEB_dT) - localDW->UnitDelay_DSTATE_k;

        /* Outputs for Atomic SubSystem: '<S1632>/Limiter' */
        /* Switch: '<S1650>/Switch1' incorporates:
         *  RelationalOperator: '<S1650>/Relational Operator'
         */
        if (rtb_Sum15 < rtb_Sum2_h5)
        {
            /* UnitDelay: '<S1573>/Unit Delay' */
            rtb_UnitDelay_b4 = rtb_Sum15;
        }
        else
        {
            /* UnitDelay: '<S1573>/Unit Delay' */
            rtb_UnitDelay_b4 = rtb_Sum2_h5;
        }

        /* End of Switch: '<S1650>/Switch1' */

        /* Switch: '<S1650>/Switch' incorporates:
         *  Gain: '<S1630>/Gain'
         *  RelationalOperator: '<S1650>/Relational Operator1'
         */
        if (rtb_UnitDelay_b4 <= (-rtb_Sum15))
        {
            rtb_UnitDelay_b4 = -rtb_Sum15;
        }

        /* End of Switch: '<S1650>/Switch' */
        /* End of Outputs for SubSystem: '<S1632>/Limiter' */

        /* Sum: '<S1632>/Sum3' incorporates:
         *  UnitDelay: '<S1632>/Unit Delay'
         */
        rtb_Gain_my = rtb_UnitDelay_b4 + localDW->UnitDelay_DSTATE_k;

        /* Update for UnitDelay: '<S1632>/Unit Delay' */
        localDW->UnitDelay_DSTATE_k = rtb_Gain_my;

        /* End of Outputs for SubSystem: '<S1630>/GradientLimiter' */

        /* Sum: '<S1631>/Subtraction1' incorporates:
         *  Constant: '<S1622>/Calib'
         *  DataStoreRead: '<S1573>/Dsr_InputSpeedProfile5'
         *  Product: '<S1631>/Multiplication'
         *  Sum: '<S1631>/Subtraction'
         */
        rtb_Sum15 = ((rtb_Gain_my - VeESSR_dn_TargetAcceltn_DS) *
                     KeESSR_k_NiDotTargetFilt) + VeESSR_dn_TargetAcceltn_DS;

        /* DataStoreRead: '<S1573>/Dsr_InputAcceltnProf' */
        rtb_Gain_my = VeESSR_dn_InputAcceltnProf_DS;

        /* Abs: '<S1627>/Abs' incorporates:
         *  DataStoreRead: '<S1573>/Dsr_NiProfGenDNiDLim'
         */
        rtb_UnitDelay_b4 = fabsf(VeESSR_dn_StrtTypJerkMax_DS);

        /* Switch: '<S1661>/Switch1' incorporates:
         *  Constant: '<S1659>/Calib'
         */
        if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
        {
            /* Switch: '<S1661>/Switch1' incorporates:
             *  Constant: '<S1660>/Calib'
             */
            rtb_Switch1_lp = HeESSR_dn_NiDotLmt4JerkOvrdVal;
        }
        else
        {
            /* Abs: '<S1648>/Abs' incorporates:
             *  DataStoreRead: '<S1573>/Dsr_InputAcceltnProf'
             *  Sum: '<S1648>/Sum6'
             */
            rtb_Sum2_h5 = ((VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15) -
                           rtb_Gain_o) + rtb_UnitDelay_b4;

            /* MinMax: '<S1648>/MinMax2' incorporates:
             *  Abs: '<S1648>/Abs1'
             *  Constant: '<S1619>/Calib'
             *  Constant: '<S1648>/Constant Value'
             *  Constant: '<S1648>/Constant Value3'
             *  DataStoreRead: '<S1573>/Dsr_InputSpeedProfile2'
             *  Product: '<S1648>/Product2'
             *  Product: '<S1648>/Product7'
             *  Product: '<S1663>/Prod'
             *  Sum: '<S1648>/Sum3'
             *  Sum: '<S1648>/Sum5'
             */
            rtb_Sum2_h5 = fmaxf((fabsf((rtb_IntegerDelay -
                                   VeESSR_n_InputSpeedProfile_DS) -
                                  (HeESSR_t_MedTEB_dT * rtb_Sum15)) *
                                 (rtb_Product4 * -2.0F)) - (rtb_Sum2_h5 *
                                 rtb_Sum2_h5), 0.0F);

            /* Switch: '<S1665>/Switch' incorporates:
             *  Sqrt: '<S1665>/Sqrt'
             */
            rtb_Sum2_h5 = sqrtf(rtb_Sum2_h5);

            /* Switch: '<S1661>/Switch1' incorporates:
             *  Abs: '<S1648>/Abs'
             *  DataStoreRead: '<S1573>/Dsr_InputAcceltnProf'
             *  Sum: '<S1648>/Sum7'
             *  Sum: '<S1648>/Sum8'
             */
            rtb_Switch1_lp = fabsf((VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15) +
                                   rtb_Gain_o) + (rtb_Sum2_h5 + rtb_Sum15);
        }

        /* End of Switch: '<S1661>/Switch1' */

        /* Product: '<S1630>/Product1' incorporates:
         *  Constant: '<S1619>/Calib'
         */
        rtb_Sum2_h5 = rtb_UnitDelay_b4 / HeESSR_t_MedTEB_dT;

        /* Switch: '<S1662>/Switch1' incorporates:
         *  Constant: '<S1659>/Calib'
         */
        if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
        {
            /* Switch: '<S1662>/Switch1' incorporates:
             *  Constant: '<S1660>/Calib'
             *  Gain: '<S1648>/Gain1'
             */
            rtb_Switch1_fz = -HeESSR_dn_NiDotLmt4JerkOvrdVal;
        }
        else
        {
            /* Abs: '<S1648>/Abs2' incorporates:
             *  DataStoreRead: '<S1573>/Dsr_InputAcceltnProf'
             *  Sum: '<S1648>/Sum11'
             */
            rtb_Abs2_h = ((VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15) -
                          rtb_UnitDelay_b4) + rtb_Gain_o;

            /* MinMax: '<S1648>/MinMax1' incorporates:
             *  Abs: '<S1648>/Abs3'
             *  Constant: '<S1619>/Calib'
             *  Constant: '<S1648>/Constant Value1'
             *  Constant: '<S1648>/Constant Value2'
             *  DataStoreRead: '<S1573>/Dsr_InputSpeedProfile2'
             *  Product: '<S1648>/Product5'
             *  Product: '<S1648>/Product8'
             *  Product: '<S1666>/Prod'
             *  Sum: '<S1648>/Sum10'
             *  Sum: '<S1648>/Sum9'
             */
            rtb_Abs2_h = fmaxf((fabsf((rtb_IntegerDelay -
                                  VeESSR_n_InputSpeedProfile_DS) -
                                 (HeESSR_t_MedTEB_dT * rtb_Sum15)) *
                                (rtb_Sum2_h5 * 2.0F)) - (rtb_Abs2_h * rtb_Abs2_h),
                               0.0F);

            /* Switch: '<S1664>/Switch' incorporates:
             *  Sqrt: '<S1664>/Sqrt'
             */
            rtb_Abs2_h = sqrtf(rtb_Abs2_h);

            /* Switch: '<S1662>/Switch1' incorporates:
             *  Abs: '<S1648>/Abs2'
             *  DataStoreRead: '<S1573>/Dsr_InputAcceltnProf'
             *  Sum: '<S1648>/Sum12'
             *  Sum: '<S1648>/Sum13'
             */
            rtb_Switch1_fz = (rtb_Sum15 - rtb_Abs2_h) - fabsf
                ((VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15) + rtb_UnitDelay_b4);
        }

        /* End of Switch: '<S1662>/Switch1' */

        /* Switch: '<S1630>/Switch1' incorporates:
         *  Constant: '<S1635>/Calib'
         *  Constant: '<S1636>/Calib'
         *  DataStoreRead: '<S1573>/Data Store Read'
         *  DataStoreRead: '<S1573>/Dsr_InputSpeedProfile1'
         *  Logic: '<S1630>/Logical1'
         *  Logic: '<S1630>/Logical6'
         *  Logic: '<S1630>/Logical8'
         */
        if (((HeESSR_b_NiLmtBypsLoopJerk) && (VeESSR_b_NiMaxActive_DS)) ||
                ((VeESSR_b_NiDotMaxActive_DS) && (HeESSR_b_NiDotLmtBypsLoopJerk)))
        {
            /* Switch: '<S1630>/Switch1' */
            rtb_UnitDelay_b4 = rtb_Switch1_lp;
        }
        else
        {
            /* Switch: '<S1630>/Switch1' incorporates:
             *  DataStoreRead: '<S1573>/Dsr_InputAcceltnProf'
             *  Sum: '<S1630>/Sum1'
             */
            rtb_UnitDelay_b4 += VeESSR_dn_InputAcceltnProf_DS;
        }

        /* End of Switch: '<S1630>/Switch1' */

        /* Outputs for Atomic SubSystem: '<S1630>/Limiter2' */
        /* Switch: '<S1643>/Switch1' incorporates:
         *  RelationalOperator: '<S1643>/Relational Operator'
         */
        if (rtb_Switch1_lp < rtb_UnitDelay_b4)
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = rtb_Switch1_lp;
        }
        else
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = rtb_UnitDelay_b4;
        }

        /* End of Switch: '<S1643>/Switch1' */

        /* Switch: '<S1643>/Switch' incorporates:
         *  RelationalOperator: '<S1643>/Relational Operator1'
         */
        if (rtb_Abs2_h > rtb_Switch1_fz)
        {
            /* Switch: '<S1643>/Switch' */
            rtb_UnitDelay_b4 = rtb_Abs2_h;
        }
        else
        {
            /* Switch: '<S1643>/Switch' */
            rtb_UnitDelay_b4 = rtb_Switch1_fz;
        }

        /* End of Switch: '<S1643>/Switch' */
        /* End of Outputs for SubSystem: '<S1630>/Limiter2' */

        /* Outputs for Atomic SubSystem: '<S1630>/Limiter4' */
        /* Switch: '<S1645>/Switch1' incorporates:
         *  DataStoreRead: '<S1573>/Dsr_NiProfGenNiDMax'
         *  RelationalOperator: '<S1645>/Relational Operator'
         */
        if (VeESSR_dn_StrtTypNiDotMax_DS < rtb_UnitDelay_b4)
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = VeESSR_dn_StrtTypNiDotMax_DS;
        }
        else
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = rtb_UnitDelay_b4;
        }

        /* End of Switch: '<S1645>/Switch1' */

        /* Switch: '<S1645>/Switch' incorporates:
         *  DataStoreRead: '<S1573>/Dsr_NiProfGenNiDMin'
         *  RelationalOperator: '<S1645>/Relational Operator1'
         */
        if (rtb_Abs2_h > VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S1645>/Switch' */
            rtb_Switch_hy = rtb_Abs2_h;
        }
        else
        {
            /* Switch: '<S1645>/Switch' */
            rtb_Switch_hy = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Switch: '<S1645>/Switch' */
        /* End of Outputs for SubSystem: '<S1630>/Limiter4' */

        /* Sum: '<S1634>/Sum6' incorporates:
         *  DataStoreRead: '<S1573>/Dsr_InputSpeedProfile2'
         */
        rtb_Sum6_ax = rtu_VeHSER_n_NiMax - VeESSR_n_InputSpeedProfile_DS;

        /* Abs: '<S1634>/Abs2' */
        rtb_Abs2_h = fabsf(rtb_Sum6_ax);

        /* Switch: '<S1634>/Switch' incorporates:
         *  Constant: '<S1634>/Constant Value7'
         *  RelationalOperator: '<S1634>/Comparison2'
         */
        if (rtb_Sum6_ax < 0.0F)
        {
            /* UnitDelay: '<S1573>/Unit Delay' incorporates:
             *  Abs: '<S1634>/Abs'
             */
            rtb_UnitDelay_b4 = fabsf(rtb_Sum2_h5);
        }
        else
        {
            /* UnitDelay: '<S1573>/Unit Delay' incorporates:
             *  Abs: '<S1634>/Abs1'
             *  Gain: '<S1634>/Gain'
             */
            rtb_UnitDelay_b4 = -fabsf(rtb_Product4);
        }

        /* End of Switch: '<S1634>/Switch' */

        /* Product: '<S1634>/Product4' incorporates:
         *  Constant: '<S1619>/Calib'
         */
        rtb_Product4_o = (rtb_UnitDelay_b4 * HeESSR_t_MedTEB_dT) *
            HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S1634>/Protected Division1' */
        /* Switch: '<S1657>/Switch1' incorporates:
         *  Constant: '<S1657>/Constant Value'
         *  Constant: '<S1657>/Constant Value1'
         *  Constant: '<S1657>/Constant Value2'
         *  Logic: '<S1657>/AND'
         *  RelationalOperator: '<S1657>/Greater Than or Equal '
         *  RelationalOperator: '<S1657>/Not Equal'
         *  RelationalOperator: '<S1657>/Not Equal1'
         *  Switch: '<S1657>/Switch2'
         */
        if ((rtb_Abs2_h != 0.0F) && (rtb_Product4_o != 0.0F))
        {
            /* Switch: '<S1657>/Switch1' incorporates:
             *  Product: '<S1657>/Division'
             */
            rtb_Abs2_h /= rtb_Product4_o;
        }
        else if (rtb_Abs2_h > 0.0F)
        {
            /* Switch: '<S1657>/Switch2' incorporates:
             *  Constant: '<S1657>/MAXFLOAT'
             *  Switch: '<S1657>/Switch1'
             */
            rtb_Abs2_h = 3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1657>/Switch1' incorporates:
             *  Constant: '<S1657>/Constant Value4'
             *  Switch: '<S1657>/Switch2'
             *  Switch: '<S1657>/Switch3'
             */
            rtb_Abs2_h = 0.0F;
        }

        /* End of Switch: '<S1657>/Switch1' */
        /* End of Outputs for SubSystem: '<S1634>/Protected Division1' */

        /* Sum: '<S1634>/Sum4' incorporates:
         *  Abs: '<S1634>/Abs3'
         *  Constant: '<S1634>/Constant Value3'
         *  Constant: '<S1634>/Constant Value5'
         *  Product: '<S1634>/Product3'
         */
        rtb_Abs2_h = (fabsf(rtb_Abs2_h) * 8.0F) + 1.0F;

        /* Switch: '<S1658>/Switch' */
        if (rtb_Abs2_h >= 0.0F)
        {
            /* Lookup_n-D: '<S1624>/Vector' incorporates:
             *  Sqrt: '<S1658>/Sqrt'
             */
            rtb_Abs2_h = sqrtf(rtb_Abs2_h);
        }
        else
        {
            /* Lookup_n-D: '<S1624>/Vector' incorporates:
             *  Constant: '<S1658>/Zero'
             */
            rtb_Abs2_h = 0.0F;
        }

        /* End of Switch: '<S1658>/Switch' */

        /* Lookup_n-D: '<S1624>/Vector' incorporates:
         *  Constant: '<S1634>/Constant Value'
         *  Constant: '<S1634>/Constant Value4'
         *  Constant: '<S1634>/Constant Value6'
         *  MinMax: '<S1634>/MinMax1'
         *  Product: '<S1634>/Product2'
         *  Rounding: '<S1634>/Rounding1'
         *  Sum: '<S1634>/Sum3'
         */
        rtb_Abs2_h = fmaxf(ceilf((rtb_Abs2_h - 1.0F) * 0.5F), 1.0F);

        /* Product: '<S1634>/Product' incorporates:
         *  Constant: '<S1619>/Calib'
         */
        rtb_Product4_o = rtb_Abs2_h * HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S1634>/Protected Division' */
        /* Switch: '<S1656>/Switch1' incorporates:
         *  Constant: '<S1656>/Constant Value'
         *  Constant: '<S1656>/Constant Value1'
         *  Constant: '<S1656>/Constant Value2'
         *  Constant: '<S1656>/Constant Value3'
         *  Logic: '<S1656>/AND'
         *  RelationalOperator: '<S1656>/Greater Than or Equal '
         *  RelationalOperator: '<S1656>/Greater Than or Equal 1'
         *  RelationalOperator: '<S1656>/Not Equal'
         *  RelationalOperator: '<S1656>/Not Equal1'
         *  Switch: '<S1656>/Switch2'
         *  Switch: '<S1656>/Switch3'
         */
        if ((rtb_Sum6_ax != 0.0F) && (rtb_Product4_o != 0.0F))
        {
            /* Switch: '<S1656>/Switch1' incorporates:
             *  Product: '<S1656>/Division'
             */
            rtb_Sum6_ax /= rtb_Product4_o;
        }
        else if (rtb_Sum6_ax > 0.0F)
        {
            /* Switch: '<S1656>/Switch2' incorporates:
             *  Constant: '<S1656>/MAXFLOAT'
             *  Switch: '<S1656>/Switch1'
             */
            rtb_Sum6_ax = 3.402823466E+38F;
        }
        else if (rtb_Sum6_ax < 0.0F)
        {
            /* Switch: '<S1656>/Switch3' incorporates:
             *  Constant: '<S1656>/MINFLOAT'
             *  Switch: '<S1656>/Switch1'
             *  Switch: '<S1656>/Switch2'
             */
            rtb_Sum6_ax = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1656>/Switch1' incorporates:
             *  Constant: '<S1656>/Constant Value4'
             *  Switch: '<S1656>/Switch2'
             *  Switch: '<S1656>/Switch3'
             */
            rtb_Sum6_ax = 0.0F;
        }

        /* End of Switch: '<S1656>/Switch1' */
        /* End of Outputs for SubSystem: '<S1634>/Protected Division' */

        /* Sum: '<S1634>/Sum' incorporates:
         *  Constant: '<S1619>/Calib'
         *  Constant: '<S1634>/Constant Value1'
         *  Constant: '<S1634>/Constant Value2'
         *  Product: '<S1634>/Product1'
         *  Sum: '<S1634>/Sum2'
         */
        rtb_UnitDelay_b4 = rtb_Sum6_ax - (((0.5F * rtb_UnitDelay_b4) *
            (rtb_Abs2_h - 1.0F)) * HeESSR_t_MedTEB_dT);

        /* Switch: '<S1630>/Switch4' incorporates:
         *  Constant: '<S1637>/Calib'
         */
        if (!HeESSR_b_NiLmtForAccelByps)
        {
            /* Switch: '<S1630>/Switch4' incorporates:
             *  MinMax: '<S1630>/MinMax1'
             */
            rtb_Switch_hy = fminf(rtb_UnitDelay_b4, rtb_Switch_hy);
        }

        /* End of Switch: '<S1630>/Switch4' */

        /* Outputs for Atomic SubSystem: '<S1630>/Limiter13' */
        /* RelationalOperator: '<S1642>/Relational Operator' */
        rtb_Equal_n = (rtu_VeHSER_dn_NiDotMax <= rtb_Switch_hy);

        /* Switch: '<S1642>/Switch1' */
        if (rtb_Equal_n)
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = rtu_VeHSER_dn_NiDotMax;
        }
        else
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = rtb_Switch_hy;
        }

        /* End of Switch: '<S1642>/Switch1' */

        /* Switch: '<S1642>/Switch' incorporates:
         *  RelationalOperator: '<S1642>/Relational Operator1'
         */
        if (rtb_Abs2_h <= rtu_VeHSER_dn_NiDotMin)
        {
            rtb_Abs2_h = rtu_VeHSER_dn_NiDotMin;
        }

        /* End of Switch: '<S1642>/Switch' */
        /* End of Outputs for SubSystem: '<S1630>/Limiter13' */

        /* Product: '<S1630>/Product9' incorporates:
         *  Constant: '<S1619>/Calib'
         */
        rtb_Switch_hy = rtb_Abs2_h * HeESSR_t_MedTEB_dT;

        /* Switch: '<S1630>/Switch2' incorporates:
         *  Constant: '<S1635>/Calib'
         *  DataStoreRead: '<S1573>/Dsr_InputSpeedProfile3'
         *  Logic: '<S1630>/Logical3'
         */
        if ((HeESSR_b_NiDotLmtBypsLoopJerk) && (VeESSR_b_NiDotMinActive_DS))
        {
            /* Switch: '<S1630>/Switch2' */
            rtb_Gain_o = rtb_Switch1_fz;
        }
        else
        {
            /* Switch: '<S1630>/Switch2' incorporates:
             *  DataStoreRead: '<S1573>/Dsr_InputAcceltnProf'
             *  Sum: '<S1630>/Sum16'
             */
            rtb_Gain_o += VeESSR_dn_InputAcceltnProf_DS;
        }

        /* End of Switch: '<S1630>/Switch2' */

        /* Outputs for Atomic SubSystem: '<S1630>/Limiter' */
        /* Switch: '<S1640>/Switch1' incorporates:
         *  RelationalOperator: '<S1640>/Relational Operator'
         */
        if (rtb_Switch1_lp < rtb_Gain_o)
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = rtb_Switch1_lp;
        }
        else
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = rtb_Gain_o;
        }

        /* End of Switch: '<S1640>/Switch1' */

        /* Switch: '<S1640>/Switch' incorporates:
         *  RelationalOperator: '<S1640>/Relational Operator1'
         */
        if (rtb_Abs2_h > rtb_Switch1_fz)
        {
            /* Switch: '<S1640>/Switch' */
            rtb_Gain_o = rtb_Abs2_h;
        }
        else
        {
            /* Switch: '<S1640>/Switch' */
            rtb_Gain_o = rtb_Switch1_fz;
        }

        /* End of Switch: '<S1640>/Switch' */
        /* End of Outputs for SubSystem: '<S1630>/Limiter' */

        /* Outputs for Atomic SubSystem: '<S1630>/Limiter3' */
        /* Switch: '<S1644>/Switch1' incorporates:
         *  DataStoreRead: '<S1573>/Dsr_NiProfGenNiDMax'
         *  RelationalOperator: '<S1644>/Relational Operator'
         */
        if (VeESSR_dn_StrtTypNiDotMax_DS < rtb_Gain_o)
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = VeESSR_dn_StrtTypNiDotMax_DS;
        }
        else
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = rtb_Gain_o;
        }

        /* End of Switch: '<S1644>/Switch1' */
        /* End of Outputs for SubSystem: '<S1630>/Limiter3' */

        /* Switch: '<S1630>/Switch5' incorporates:
         *  Constant: '<S1637>/Calib'
         *  DataStoreRead: '<S1573>/Dsr_NiProfGenNiDMin'
         *  RelationalOperator: '<S1644>/Relational Operator1'
         *  Switch: '<S1644>/Switch'
         */
        if (HeESSR_b_NiLmtForAccelByps)
        {
            /* Outputs for Atomic SubSystem: '<S1630>/Limiter3' */
            /* Switch: '<S1644>/Switch' incorporates:
             *  DataStoreRead: '<S1573>/Dsr_NiProfGenNiDMin'
             *  RelationalOperator: '<S1644>/Relational Operator1'
             */
            if (rtb_Abs2_h > VeESSR_dn_StrtTypNiDotMin_DS)
            {
                /* Switch: '<S1630>/Switch5' */
                rtb_Gain_o = rtb_Abs2_h;
            }
            else
            {
                /* Switch: '<S1630>/Switch5' */
                rtb_Gain_o = VeESSR_dn_StrtTypNiDotMin_DS;
            }

            /* End of Outputs for SubSystem: '<S1630>/Limiter3' */
        }
        else
        {
            /* Outputs for Atomic SubSystem: '<S1630>/Limiter3' */
            if (rtb_Abs2_h <= VeESSR_dn_StrtTypNiDotMin_DS)
            {
                /* Switch: '<S1644>/Switch' incorporates:
                 *  DataStoreRead: '<S1573>/Dsr_NiProfGenNiDMin'
                 */
                rtb_Abs2_h = VeESSR_dn_StrtTypNiDotMin_DS;
            }

            /* End of Outputs for SubSystem: '<S1630>/Limiter3' */

            /* Switch: '<S1630>/Switch5' incorporates:
             *  MinMax: '<S1630>/MinMax2'
             */
            rtb_Gain_o = fminf(rtb_UnitDelay_b4, rtb_Abs2_h);
        }

        /* End of Switch: '<S1630>/Switch5' */

        /* Outputs for Atomic SubSystem: '<S1630>/Limiter9' */
        /* Switch: '<S1647>/Switch1' incorporates:
         *  RelationalOperator: '<S1647>/Relational Operator'
         */
        if (rtu_VeHSER_dn_NiDotMax <= rtb_Gain_o)
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = rtu_VeHSER_dn_NiDotMax;
        }
        else
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = rtb_Gain_o;
        }

        /* End of Switch: '<S1647>/Switch1' */

        /* RelationalOperator: '<S1646>/Relational Operator1' incorporates:
         *  RelationalOperator: '<S1647>/Relational Operator1'
         */
        rtb_Merge_hn = (rtb_Abs2_h > rtu_VeHSER_dn_NiDotMin);

        /* Logic: '<S1647>/Logical2' */
        rtb_Logical2_bmg = !rtb_Merge_hn;

        /* Switch: '<S1647>/Switch' */
        if (!rtb_Merge_hn)
        {
            rtb_Abs2_h = rtu_VeHSER_dn_NiDotMin;
        }

        /* End of Switch: '<S1647>/Switch' */
        /* End of Outputs for SubSystem: '<S1630>/Limiter9' */

        /* Product: '<S1630>/Product10' incorporates:
         *  Constant: '<S1619>/Calib'
         */
        rtb_Gain_o = rtb_Abs2_h * HeESSR_t_MedTEB_dT;

        /* Sum: '<S1630>/Sum2' incorporates:
         *  DataStoreRead: '<S1573>/Dsr_InputSpeedProfile2'
         */
        rtb_Switch1_lp = rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS;

        /* Sum: '<S1633>/Sum6' incorporates:
         *  Constant: '<S1619>/Calib'
         *  DataStoreRead: '<S1573>/Dsr_InputSpeedProfile2'
         *  Product: '<S1633>/Product7'
         *  Sum: '<S1630>/Sum6'
         *  Switch: '<S1630>/Switch3'
         */
        rtb_IntegerDelay = (rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS) -
            (rtb_Sum15 * HeESSR_t_MedTEB_dT);

        /* Abs: '<S1633>/Abs2' incorporates:
         *  Sum: '<S1633>/Sum6'
         */
        rtb_UnitDelay_b4 = fabsf(rtb_IntegerDelay);

        /* Switch: '<S1633>/Switch' incorporates:
         *  Constant: '<S1633>/Constant Value7'
         *  RelationalOperator: '<S1633>/Comparison2'
         *  Sum: '<S1633>/Sum6'
         */
        if (rtb_IntegerDelay < 0.0F)
        {
            /* Lookup_n-D: '<S1624>/Vector' incorporates:
             *  Abs: '<S1633>/Abs'
             */
            rtb_Abs2_h = fabsf(rtb_Sum2_h5);
        }
        else
        {
            /* Lookup_n-D: '<S1624>/Vector' incorporates:
             *  Abs: '<S1633>/Abs1'
             *  Gain: '<S1633>/Gain'
             */
            rtb_Abs2_h = -fabsf(rtb_Product4);
        }

        /* End of Switch: '<S1633>/Switch' */

        /* Product: '<S1633>/Product4' incorporates:
         *  Constant: '<S1619>/Calib'
         */
        rtb_Product4 = (rtb_Abs2_h * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S1633>/Protected Division1' */
        /* Switch: '<S1653>/Switch1' incorporates:
         *  Constant: '<S1653>/Constant Value'
         *  Constant: '<S1653>/Constant Value1'
         *  Constant: '<S1653>/Constant Value2'
         *  Logic: '<S1653>/AND'
         *  RelationalOperator: '<S1653>/Greater Than or Equal '
         *  RelationalOperator: '<S1653>/Not Equal'
         *  RelationalOperator: '<S1653>/Not Equal1'
         *  Switch: '<S1653>/Switch2'
         */
        if ((rtb_UnitDelay_b4 != 0.0F) && (rtb_Product4 != 0.0F))
        {
            /* Switch: '<S1653>/Switch1' incorporates:
             *  Product: '<S1653>/Division'
             */
            rtb_Product4 = rtb_UnitDelay_b4 / rtb_Product4;
        }
        else if (rtb_UnitDelay_b4 > 0.0F)
        {
            /* Switch: '<S1653>/Switch2' incorporates:
             *  Constant: '<S1653>/MAXFLOAT'
             *  Switch: '<S1653>/Switch1'
             */
            rtb_Product4 = 3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1653>/Switch1' incorporates:
             *  Constant: '<S1653>/Constant Value4'
             *  Switch: '<S1653>/Switch2'
             *  Switch: '<S1653>/Switch3'
             */
            rtb_Product4 = 0.0F;
        }

        /* End of Switch: '<S1653>/Switch1' */
        /* End of Outputs for SubSystem: '<S1633>/Protected Division1' */

        /* Sum: '<S1633>/Sum4' incorporates:
         *  Abs: '<S1633>/Abs3'
         *  Constant: '<S1633>/Constant Value3'
         *  Constant: '<S1633>/Constant Value5'
         *  Product: '<S1633>/Product3'
         */
        rtb_Product4 = (fabsf(rtb_Product4) * 8.0F) + 1.0F;

        /* Switch: '<S1654>/Switch' incorporates:
         *  Constant: '<S1654>/Zero'
         *  Sqrt: '<S1654>/Sqrt'
         */
        if (rtb_Product4 >= 0.0F)
        {
            rtb_Product4 = sqrtf(rtb_Product4);
        }
        else
        {
            rtb_Product4 = 0.0F;
        }

        /* End of Switch: '<S1654>/Switch' */

        /* UnitDelay: '<S1573>/Unit Delay' incorporates:
         *  Constant: '<S1633>/Constant Value'
         *  Constant: '<S1633>/Constant Value4'
         *  Constant: '<S1633>/Constant Value6'
         *  MinMax: '<S1633>/MinMax1'
         *  Product: '<S1633>/Product2'
         *  Rounding: '<S1633>/Rounding1'
         *  Sum: '<S1633>/Sum3'
         */
        rtb_UnitDelay_b4 = fmaxf(ceilf((rtb_Product4 - 1.0F) * 0.5F), 1.0F);

        /* Product: '<S1633>/Product' incorporates:
         *  Constant: '<S1619>/Calib'
         */
        rtb_Product4 = rtb_UnitDelay_b4 * HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S1633>/Protected Division' */
        /* Switch: '<S1652>/Switch1' incorporates:
         *  Constant: '<S1652>/Constant Value'
         *  Constant: '<S1652>/Constant Value1'
         *  Constant: '<S1652>/Constant Value2'
         *  Constant: '<S1652>/Constant Value3'
         *  Logic: '<S1652>/AND'
         *  RelationalOperator: '<S1652>/Greater Than or Equal '
         *  RelationalOperator: '<S1652>/Greater Than or Equal 1'
         *  RelationalOperator: '<S1652>/Not Equal'
         *  RelationalOperator: '<S1652>/Not Equal1'
         *  Sum: '<S1633>/Sum6'
         *  Switch: '<S1652>/Switch2'
         *  Switch: '<S1652>/Switch3'
         */
        if ((rtb_IntegerDelay != 0.0F) && (rtb_Product4 != 0.0F))
        {
            /* Switch: '<S1652>/Switch1' incorporates:
             *  Product: '<S1652>/Division'
             */
            rtb_Product4 = rtb_IntegerDelay / rtb_Product4;
        }
        else if (rtb_IntegerDelay > 0.0F)
        {
            /* Switch: '<S1652>/Switch2' incorporates:
             *  Constant: '<S1652>/MAXFLOAT'
             *  Switch: '<S1652>/Switch1'
             */
            rtb_Product4 = 3.402823466E+38F;
        }
        else if (rtb_IntegerDelay < 0.0F)
        {
            /* Switch: '<S1652>/Switch3' incorporates:
             *  Constant: '<S1652>/MINFLOAT'
             *  Switch: '<S1652>/Switch1'
             *  Switch: '<S1652>/Switch2'
             */
            rtb_Product4 = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1652>/Switch1' incorporates:
             *  Constant: '<S1652>/Constant Value4'
             *  Switch: '<S1652>/Switch2'
             *  Switch: '<S1652>/Switch3'
             */
            rtb_Product4 = 0.0F;
        }

        /* End of Switch: '<S1652>/Switch1' */
        /* End of Outputs for SubSystem: '<S1633>/Protected Division' */

        /* Switch: '<S1630>/Switch3' incorporates:
         *  Constant: '<S1638>/Calib'
         */
        if (!HeESSR_b_TrnstnJerkByps)
        {
            /* Switch: '<S1630>/Switch8' incorporates:
             *  Constant: '<S1630>/Constant Value7'
             *  RelationalOperator: '<S1630>/Comparison'
             */
            if (rtb_IntegerDelay > 0.0F)
            {
                /* Switch: '<S1630>/Switch3' incorporates:
                 *  Constant: '<S1619>/Calib'
                 *  Constant: '<S1633>/Constant Value1'
                 *  Constant: '<S1633>/Constant Value2'
                 *  MinMax: '<S1630>/MinMax4'
                 *  Product: '<S1630>/Product5'
                 *  Product: '<S1633>/Product1'
                 *  Sum: '<S1633>/Sum'
                 *  Sum: '<S1633>/Sum2'
                 *  Switch: '<S1630>/Switch8'
                 */
                rtb_Switch1_lp = fminf(rtb_Switch1_lp, ((rtb_Product4 +
                    rtb_Sum15) - (((0.5F * rtb_Abs2_h) * (rtb_UnitDelay_b4 -
                    1.0F)) * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
            }
            else
            {
                /* Switch: '<S1630>/Switch3' incorporates:
                 *  Constant: '<S1619>/Calib'
                 *  Constant: '<S1633>/Constant Value1'
                 *  Constant: '<S1633>/Constant Value2'
                 *  MinMax: '<S1630>/MinMax5'
                 *  Product: '<S1630>/Product2'
                 *  Product: '<S1633>/Product1'
                 *  Sum: '<S1633>/Sum'
                 *  Sum: '<S1633>/Sum2'
                 *  Switch: '<S1630>/Switch8'
                 */
                rtb_Switch1_lp = fmaxf(rtb_Switch1_lp, ((rtb_Product4 +
                    rtb_Sum15) - (((0.5F * rtb_Abs2_h) * (rtb_UnitDelay_b4 -
                    1.0F)) * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
            }

            /* End of Switch: '<S1630>/Switch8' */
        }

        /* Outputs for Atomic SubSystem: '<S1630>/Limiter6' */
        /* RelationalOperator: '<S1646>/Relational Operator' */
        rtb_RelationalOperator_a2 = (rtb_Switch_hy <= rtb_Switch1_lp);

        /* Switch: '<S1646>/Switch1' */
        if (rtb_RelationalOperator_a2)
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = rtb_Switch_hy;
        }
        else
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = rtb_Switch1_lp;
        }

        /* End of Switch: '<S1646>/Switch1' */

        /* RelationalOperator: '<S1646>/Relational Operator1' */
        rtb_Merge_hn = (rtb_Abs2_h > rtb_Gain_o);

        /* Switch: '<S1646>/Switch' */
        if (rtb_Merge_hn)
        {
            rtb_Gain_o = rtb_Abs2_h;
        }

        /* End of Switch: '<S1646>/Switch' */
        /* End of Outputs for SubSystem: '<S1630>/Limiter6' */

        /* Sum: '<S1630>/Sum4' incorporates:
         *  DataStoreRead: '<S1573>/Dsr_InputSpeedProfile2'
         */
        rtb_IntegerDelay = rtb_Gain_o + VeESSR_n_InputSpeedProfile_DS;

        /* Outputs for Atomic SubSystem: '<S1630>/Limiter1' */
        /* RelationalOperator: '<S1641>/Relational Operator' incorporates:
         *  DataStoreWrite: '<S1573>/Dsw_InputSpeedProfile5'
         */
        VeESSR_b_NiMaxActive_DS = (rtu_VeHSER_n_NiMax <= rtb_IntegerDelay);

        /* Switch: '<S1641>/Switch1' incorporates:
         *  DataStoreWrite: '<S1573>/Dsw_InputSpeedProfile5'
         */
        if (VeESSR_b_NiMaxActive_DS)
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = rtu_VeHSER_n_NiMax;
        }
        else
        {
            /* Lookup_n-D: '<S1624>/Vector' */
            rtb_Abs2_h = rtb_IntegerDelay;
        }

        /* End of Switch: '<S1641>/Switch1' */

        /* Switch: '<S1641>/Switch' incorporates:
         *  Constant: '<S1630>/Constant Value4'
         *  RelationalOperator: '<S1641>/Relational Operator1'
         */
        if (rtb_Abs2_h > 0.0F)
        {
            /* Switch: '<S1641>/Switch' */
            rtb_IntegerDelay = rtb_Abs2_h;
        }
        else
        {
            /* Switch: '<S1641>/Switch' */
            rtb_IntegerDelay = 0.0F;
        }

        /* End of Switch: '<S1641>/Switch' */
        /* End of Outputs for SubSystem: '<S1630>/Limiter1' */

        /* Product: '<S1630>/Product3' incorporates:
         *  Constant: '<S1619>/Calib'
         *  DataStoreRead: '<S1573>/Dsr_InputSpeedProfile2'
         *  DataStoreWrite: '<S1573>/Dsw_InputAcceltnProf'
         *  Sum: '<S1630>/Sum'
         */
        VeESSR_dn_InputAcceltnProf_DS = (rtb_IntegerDelay -
            VeESSR_n_InputSpeedProfile_DS) / HeESSR_t_MedTEB_dT;

        /* DataStoreWrite: '<S1573>/Dsw_InputSpeedProfile' */
        VeESSR_n_InputSpeedProfile_DS = rtb_IntegerDelay;

        /* Logic: '<S1630>/Logical2' incorporates:
         *  DataStoreWrite: '<S1573>/Dsw_InputSpeedProfile1'
         */
        VeESSR_b_NiDotMaxActive_DS = (rtb_Equal_n && rtb_RelationalOperator_a2);

        /* DataStoreWrite: '<S1573>/Dsw_InputSpeedProfile2' */
        VeESSR_n_TargetSpeed_DS = rtb_Gain1_e1;

        /* DataStoreWrite: '<S1573>/Dsw_InputSpeedProfile3' */
        VeESSR_dn_TargetAcceltn_DS = rtb_Sum15;

        /* Outputs for Atomic SubSystem: '<S1630>/Limiter6' */
        /* Logic: '<S1630>/Logical' incorporates:
         *  DataStoreWrite: '<S1573>/Dsw_InputSpeedProfile4'
         *  Logic: '<S1646>/Logical2'
         */
        VeESSR_b_NiDotMinActive_DS = (rtb_Logical2_bmg && (!rtb_Merge_hn));

        /* End of Outputs for SubSystem: '<S1630>/Limiter6' */

        /* DataStoreWrite: '<S1573>/Dsw_Ni1stFlt_DS' */
        VeESSR_n_Ni1stFlt_DS = rtb_Summation_np;

        /* Sum: '<S1618>/Subtraction1' incorporates:
         *  Constant: '<S1620>/Calib'
         *  Lookup_n-D: '<S1624>/Vector'
         *  Product: '<S1573>/Multiplication'
         *  Product: '<S1618>/Multiplication'
         *  Sum: '<S1573>/Sum'
         *  Sum: '<S1618>/Subtraction'
         *  UnitDelay: '<S1573>/Unit Delay'
         */
        VeESSR_M_FastSpinInputTorq = (((rtb_SumSub_j * KeESSR_K_CKSEcmTorqFactor)
            - VeESSR_M_FastSpinInputTorq) * look1_iflf_binlcapw(rtb_SumSub_j -
            rtu_VeESSR_M_EngStrtTrqSnsd, ((const float32 *)
            &(KxESSR_K_TiEstCKSFastSpin[0])), ((const float32 *)
            &(KtESSR_K_TiEstCKSFastSpin[0])), 5U)) + VeESSR_M_FastSpinInputTorq;

        /* Switch: '<S1617>/Switch1' incorporates:
         *  Gain: '<S1626>/Gain'
         */
        rtb_SumSub_j = VeESSR_M_FastSpinInputTorq;

        /* Sum: '<S1630>/Sum17' incorporates:
         *  DataStoreWrite: '<S1573>/Dsw_InputAcceltnProf'
         */
        VeESSR_dn_InputJerkProfSpinupCKSFast = VeESSR_dn_InputAcceltnProf_DS -
            rtb_Gain_my;

        /* Update for UnitDelay: '<S1649>/Unit Delay' incorporates:
         *  Switch: '<S1649>/Switch3'
         */
        localDW->UnitDelay_DSTATE_c = rtb_Summation_eb;

        /* Update for Delay: '<S1630>/IntegerDelay' */
        localDW->icLoad_f = 0U;
        for (i = 0; i < 15; i++)
        {
            localDW->IntegerDelay_DSTATE_e[i] = localDW->IntegerDelay_DSTATE_e[i
                + 1];
        }

        localDW->IntegerDelay_DSTATE_e[15] = rtb_Gain1_e1;

        /* End of Update for Delay: '<S1630>/IntegerDelay' */
        /* End of Outputs for SubSystem: '<S1564>/FastSpin' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1564>/SlowSpin' incorporates:
         *  ActionPort: '<S1592>/Action Port'
         */
        /* Gain: '<S1678>/Gain' incorporates:
         *  Abs: '<S1678>/Abs1'
         *  DataStoreRead: '<S1592>/Dsr_NiProfGenDNiDLim1'
         */
        rtb_Gain_o = -fabsf(VeESSR_dn_StrtTypJerkMin_DS);

        /* Product: '<S1681>/Product4' incorporates:
         *  Constant: '<S1671>/Calib'
         */
        rtb_Product4 = rtb_Gain_o / HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S1678>/LowpassT Reset Enabled' */
        /* Sum: '<S1679>/Summation' incorporates:
         *  Constant: '<S1671>/Calib'
         *  Constant: '<S1674>/Calib'
         *  DataStoreRead: '<S1592>/Dsr_Ni1stFlt_DS'
         *  DataStoreRead: '<S1592>/Dsr_NiProfGenT2Gain'
         *  MinMax: '<S1679>/Maximum'
         *  Product: '<S1679>/Multiplication'
         *  Product: '<S1679>/Multiplication1'
         *  Sum: '<S1679>/Subtraction'
         */
        rtb_Summation_np = (((KeESSR_n_SlowSpinTgt - VeESSR_n_Ni1stFlt_DS) *
                             HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                             (VeESSR_k_StrtTypScndOrdLwPassT_DS,
                              HeESSR_t_MedTEB_dT))) + VeESSR_n_Ni1stFlt_DS;

        /* End of Outputs for SubSystem: '<S1678>/LowpassT Reset Enabled' */

        /* Outputs for Atomic SubSystem: '<S1678>/LowpassT Reset Enabled1' */
        /* Sum: '<S1680>/Summation' incorporates:
         *  Constant: '<S1671>/Calib'
         *  DataStoreRead: '<S1592>/Dsr_InputSpeedProfile1'
         *  DataStoreRead: '<S1592>/Dsr_NiProfGenT1Gain'
         *  MinMax: '<S1680>/Maximum'
         *  Product: '<S1680>/Multiplication'
         *  Product: '<S1680>/Multiplication1'
         *  Sum: '<S1680>/Subtraction'
         */
        rtb_Summation_eb = (((rtb_Summation_np - VeESSR_n_InputSpeedProfile_DS) *
                             HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                             (VeESSR_k_StrtTypFrstOrdLwPassT_DS,
                              HeESSR_t_MedTEB_dT))) +
            VeESSR_n_InputSpeedProfile_DS;

        /* End of Outputs for SubSystem: '<S1678>/LowpassT Reset Enabled1' */

        /* Switch: '<S1700>/Switch1' incorporates:
         *  UnitDelay: '<S1700>/Unit Delay'
         */
        if (rtb_Equal_n)
        {
            rtb_Gain1_e1 = rtb_Summation_eb;
        }
        else
        {
            rtb_Gain1_e1 = localDW->UnitDelay_DSTATE;
        }

        /* End of Switch: '<S1700>/Switch1' */

        /* Gain: '<S1681>/Gain1' incorporates:
         *  Sum: '<S1681>/Sum18'
         */
        rtb_Gain1_e1 = (rtb_Summation_eb + rtb_Gain1_e1) * 0.5F;

        /* Delay: '<S1681>/IntegerDelay' incorporates:
         *  Constant: '<S1690>/Calib'
         */
        if (rtb_Equal_n && (((uint32)localZCE->IntegerDelay_Reset_ZCE_bi) !=
                            POS_ZCSIG))
        {
            localDW->icLoad = 1U;
        }

        localZCE->IntegerDelay_Reset_ZCE_bi = rtb_Equal_n ? ((ZCSigState)1) :
            ((ZCSigState)0);
        if (((sint32)localDW->icLoad) != 0)
        {
            for (i = 0; i < 16; i++)
            {
                localDW->IntegerDelay_DSTATE[i] = rtb_Gain1_e1;
            }
        }

        if (((sint32)KeESSR_Cnt_DelayOptNi) <= 0)
        {
            /* Delay: '<S1681>/IntegerDelay' */
            rtb_IntegerDelay = rtb_Gain1_e1;
        }
        else
        {
            if (((sint32)KeESSR_Cnt_DelayOptNi) > 16)
            {
                tmp = 16U;
            }
            else
            {
                tmp = KeESSR_Cnt_DelayOptNi;
            }

            /* Delay: '<S1681>/IntegerDelay' */
            rtb_IntegerDelay = localDW->IntegerDelay_DSTATE[(uint8)(16U -
                ((uint32)tmp))];
        }

        /* End of Delay: '<S1681>/IntegerDelay' */

        /* Sum: '<S1681>/Sum15' incorporates:
         *  Abs: '<S1681>/Abs4'
         *  Constant: '<S1672>/Calib'
         *  DataStoreRead: '<S1592>/Dsr_InputSpeedProfile5'
         */
        rtb_Sum15 = fabsf(VeESSR_dn_TargetAcceltn_DS) +
            KeESSR_dn_NiTargetJerkLimit;

        /* Outputs for Atomic SubSystem: '<S1681>/GradientLimiter' */
        /* Sum: '<S1683>/Sum2' incorporates:
         *  Constant: '<S1671>/Calib'
         *  DataStoreRead: '<S1592>/Dsr_InputSpeedProfile4'
         *  Product: '<S1681>/Product6'
         *  Sum: '<S1681>/Sum14'
         *  UnitDelay: '<S1683>/Unit Delay'
         */
        rtb_Sum2_h5 = ((rtb_Gain1_e1 - VeESSR_n_TargetSpeed_DS) /
                       HeESSR_t_MedTEB_dT) - localDW->UnitDelay_DSTATE_h;

        /* Outputs for Atomic SubSystem: '<S1683>/Limiter' */
        /* Switch: '<S1701>/Switch1' incorporates:
         *  RelationalOperator: '<S1701>/Relational Operator'
         */
        if (rtb_Sum15 < rtb_Sum2_h5)
        {
            /* UnitDelay: '<S1592>/Unit Delay' */
            rtb_UnitDelay_b4 = rtb_Sum15;
        }
        else
        {
            /* UnitDelay: '<S1592>/Unit Delay' */
            rtb_UnitDelay_b4 = rtb_Sum2_h5;
        }

        /* End of Switch: '<S1701>/Switch1' */

        /* Switch: '<S1701>/Switch' incorporates:
         *  Gain: '<S1681>/Gain'
         *  RelationalOperator: '<S1701>/Relational Operator1'
         */
        if (rtb_UnitDelay_b4 <= (-rtb_Sum15))
        {
            rtb_UnitDelay_b4 = -rtb_Sum15;
        }

        /* End of Switch: '<S1701>/Switch' */
        /* End of Outputs for SubSystem: '<S1683>/Limiter' */

        /* Sum: '<S1683>/Sum3' incorporates:
         *  UnitDelay: '<S1683>/Unit Delay'
         */
        rtb_Gain_my = rtb_UnitDelay_b4 + localDW->UnitDelay_DSTATE_h;

        /* Update for UnitDelay: '<S1683>/Unit Delay' */
        localDW->UnitDelay_DSTATE_h = rtb_Gain_my;

        /* End of Outputs for SubSystem: '<S1681>/GradientLimiter' */

        /* Sum: '<S1682>/Subtraction1' incorporates:
         *  Constant: '<S1673>/Calib'
         *  DataStoreRead: '<S1592>/Dsr_InputSpeedProfile5'
         *  Product: '<S1682>/Multiplication'
         *  Sum: '<S1682>/Subtraction'
         */
        rtb_Sum15 = ((rtb_Gain_my - VeESSR_dn_TargetAcceltn_DS) *
                     KeESSR_k_NiDotTargetFilt) + VeESSR_dn_TargetAcceltn_DS;

        /* DataStoreRead: '<S1592>/Dsr_InputAcceltnProf' */
        rtb_Gain_my = VeESSR_dn_InputAcceltnProf_DS;

        /* Abs: '<S1678>/Abs' incorporates:
         *  DataStoreRead: '<S1592>/Dsr_NiProfGenDNiDLim'
         */
        rtb_UnitDelay_b4 = fabsf(VeESSR_dn_StrtTypJerkMax_DS);

        /* Switch: '<S1712>/Switch1' incorporates:
         *  Constant: '<S1710>/Calib'
         */
        if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
        {
            /* Switch: '<S1712>/Switch1' incorporates:
             *  Constant: '<S1711>/Calib'
             */
            rtb_Switch1_lp = HeESSR_dn_NiDotLmt4JerkOvrdVal;
        }
        else
        {
            /* Sum: '<S1699>/Sum6' incorporates:
             *  DataStoreRead: '<S1592>/Dsr_InputAcceltnProf'
             *  Sum: '<S1699>/Sum8'
             */
            rtb_Switch1_lp = VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15;

            /* Abs: '<S1699>/Abs' incorporates:
             *  Sum: '<S1699>/Sum6'
             */
            rtb_Sum2_h5 = (rtb_Switch1_lp - rtb_Gain_o) + rtb_UnitDelay_b4;

            /* MinMax: '<S1699>/MinMax2' incorporates:
             *  Abs: '<S1699>/Abs1'
             *  Constant: '<S1671>/Calib'
             *  Constant: '<S1699>/Constant Value'
             *  Constant: '<S1699>/Constant Value3'
             *  DataStoreRead: '<S1592>/Dsr_InputSpeedProfile1'
             *  Product: '<S1699>/Product2'
             *  Product: '<S1699>/Product7'
             *  Product: '<S1714>/Prod'
             *  Sum: '<S1699>/Sum3'
             *  Sum: '<S1699>/Sum5'
             */
            rtb_Sum2_h5 = fmaxf((fabsf((rtb_IntegerDelay -
                                   VeESSR_n_InputSpeedProfile_DS) -
                                  (HeESSR_t_MedTEB_dT * rtb_Sum15)) *
                                 (rtb_Product4 * -2.0F)) - (rtb_Sum2_h5 *
                                 rtb_Sum2_h5), 0.0F);

            /* Switch: '<S1716>/Switch' incorporates:
             *  Sqrt: '<S1716>/Sqrt'
             */
            rtb_Sum2_h5 = sqrtf(rtb_Sum2_h5);

            /* Switch: '<S1712>/Switch1' incorporates:
             *  Abs: '<S1699>/Abs'
             *  Sum: '<S1699>/Sum7'
             *  Sum: '<S1699>/Sum8'
             */
            rtb_Switch1_lp = fabsf(rtb_Switch1_lp + rtb_Gain_o) + (rtb_Sum2_h5 +
                rtb_Sum15);
        }

        /* End of Switch: '<S1712>/Switch1' */

        /* Product: '<S1681>/Product1' incorporates:
         *  Constant: '<S1671>/Calib'
         */
        rtb_Sum2_h5 = rtb_UnitDelay_b4 / HeESSR_t_MedTEB_dT;

        /* Switch: '<S1713>/Switch1' incorporates:
         *  Constant: '<S1710>/Calib'
         */
        if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
        {
            /* Switch: '<S1713>/Switch1' incorporates:
             *  Constant: '<S1711>/Calib'
             *  Gain: '<S1699>/Gain1'
             */
            rtb_Switch1_fz = -HeESSR_dn_NiDotLmt4JerkOvrdVal;
        }
        else
        {
            /* Sum: '<S1699>/Sum11' incorporates:
             *  DataStoreRead: '<S1592>/Dsr_InputAcceltnProf'
             *  Sum: '<S1699>/Sum13'
             */
            rtb_Switch_hy = VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15;

            /* Abs: '<S1699>/Abs2' incorporates:
             *  Sum: '<S1699>/Sum11'
             */
            rtb_Abs2_h = (rtb_Switch_hy - rtb_UnitDelay_b4) + rtb_Gain_o;

            /* MinMax: '<S1699>/MinMax1' incorporates:
             *  Abs: '<S1699>/Abs3'
             *  Constant: '<S1671>/Calib'
             *  Constant: '<S1699>/Constant Value1'
             *  Constant: '<S1699>/Constant Value2'
             *  DataStoreRead: '<S1592>/Dsr_InputSpeedProfile1'
             *  Product: '<S1699>/Product5'
             *  Product: '<S1699>/Product8'
             *  Product: '<S1717>/Prod'
             *  Sum: '<S1699>/Sum10'
             *  Sum: '<S1699>/Sum9'
             */
            rtb_Abs2_h = fmaxf((fabsf((rtb_IntegerDelay -
                                  VeESSR_n_InputSpeedProfile_DS) -
                                 (HeESSR_t_MedTEB_dT * rtb_Sum15)) *
                                (rtb_Sum2_h5 * 2.0F)) - (rtb_Abs2_h * rtb_Abs2_h),
                               0.0F);

            /* Switch: '<S1715>/Switch' incorporates:
             *  Sqrt: '<S1715>/Sqrt'
             */
            rtb_Abs2_h = sqrtf(rtb_Abs2_h);

            /* Switch: '<S1713>/Switch1' incorporates:
             *  Abs: '<S1699>/Abs2'
             *  Sum: '<S1699>/Sum12'
             *  Sum: '<S1699>/Sum13'
             */
            rtb_Switch1_fz = (rtb_Sum15 - rtb_Abs2_h) - fabsf(rtb_Switch_hy +
                rtb_UnitDelay_b4);
        }

        /* End of Switch: '<S1713>/Switch1' */

        /* Switch: '<S1681>/Switch1' incorporates:
         *  Constant: '<S1686>/Calib'
         *  Constant: '<S1687>/Calib'
         *  DataStoreRead: '<S1592>/Data Store Read'
         *  DataStoreRead: '<S1592>/Dsr_InputSpeedProfile2'
         *  Logic: '<S1681>/Logical1'
         *  Logic: '<S1681>/Logical6'
         *  Logic: '<S1681>/Logical8'
         */
        if (((HeESSR_b_NiLmtBypsLoopJerk) && (VeESSR_b_NiMaxActive_DS)) ||
                ((VeESSR_b_NiDotMaxActive_DS) && (HeESSR_b_NiDotLmtBypsLoopJerk)))
        {
            /* Switch: '<S1681>/Switch1' */
            rtb_UnitDelay_b4 = rtb_Switch1_lp;
        }
        else
        {
            /* Switch: '<S1681>/Switch1' incorporates:
             *  DataStoreRead: '<S1592>/Dsr_InputAcceltnProf'
             *  Sum: '<S1681>/Sum1'
             */
            rtb_UnitDelay_b4 += VeESSR_dn_InputAcceltnProf_DS;
        }

        /* End of Switch: '<S1681>/Switch1' */

        /* Outputs for Atomic SubSystem: '<S1681>/Limiter2' */
        /* Switch: '<S1694>/Switch1' incorporates:
         *  RelationalOperator: '<S1694>/Relational Operator'
         */
        if (rtb_Switch1_lp < rtb_UnitDelay_b4)
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = rtb_Switch1_lp;
        }
        else
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = rtb_UnitDelay_b4;
        }

        /* End of Switch: '<S1694>/Switch1' */

        /* Switch: '<S1694>/Switch' incorporates:
         *  RelationalOperator: '<S1694>/Relational Operator1'
         */
        if (rtb_Abs2_h > rtb_Switch1_fz)
        {
            /* Switch: '<S1694>/Switch' */
            rtb_UnitDelay_b4 = rtb_Abs2_h;
        }
        else
        {
            /* Switch: '<S1694>/Switch' */
            rtb_UnitDelay_b4 = rtb_Switch1_fz;
        }

        /* End of Switch: '<S1694>/Switch' */
        /* End of Outputs for SubSystem: '<S1681>/Limiter2' */

        /* Outputs for Atomic SubSystem: '<S1681>/Limiter4' */
        /* Switch: '<S1696>/Switch1' incorporates:
         *  DataStoreRead: '<S1592>/Dsr_NiProfGenNiDMax'
         *  RelationalOperator: '<S1696>/Relational Operator'
         */
        if (VeESSR_dn_StrtTypNiDotMax_DS < rtb_UnitDelay_b4)
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = VeESSR_dn_StrtTypNiDotMax_DS;
        }
        else
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = rtb_UnitDelay_b4;
        }

        /* End of Switch: '<S1696>/Switch1' */

        /* Switch: '<S1696>/Switch' incorporates:
         *  DataStoreRead: '<S1592>/Dsr_NiProfGenNiDMin'
         *  RelationalOperator: '<S1696>/Relational Operator1'
         */
        if (rtb_Abs2_h > VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S1696>/Switch' */
            rtb_Switch_hy = rtb_Abs2_h;
        }
        else
        {
            /* Switch: '<S1696>/Switch' */
            rtb_Switch_hy = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Switch: '<S1696>/Switch' */
        /* End of Outputs for SubSystem: '<S1681>/Limiter4' */

        /* Sum: '<S1685>/Sum6' incorporates:
         *  DataStoreRead: '<S1592>/Dsr_InputSpeedProfile1'
         */
        rtb_Sum6_ax = rtu_VeHSER_n_NiMax - VeESSR_n_InputSpeedProfile_DS;

        /* Abs: '<S1685>/Abs2' */
        rtb_Abs2_h = fabsf(rtb_Sum6_ax);

        /* Switch: '<S1685>/Switch' incorporates:
         *  Constant: '<S1685>/Constant Value7'
         *  RelationalOperator: '<S1685>/Comparison2'
         */
        if (rtb_Sum6_ax < 0.0F)
        {
            /* UnitDelay: '<S1592>/Unit Delay' incorporates:
             *  Abs: '<S1685>/Abs'
             */
            rtb_UnitDelay_b4 = fabsf(rtb_Sum2_h5);
        }
        else
        {
            /* UnitDelay: '<S1592>/Unit Delay' incorporates:
             *  Abs: '<S1685>/Abs1'
             *  Gain: '<S1685>/Gain'
             */
            rtb_UnitDelay_b4 = -fabsf(rtb_Product4);
        }

        /* End of Switch: '<S1685>/Switch' */

        /* Product: '<S1685>/Product4' incorporates:
         *  Constant: '<S1671>/Calib'
         */
        rtb_Product4_o = (rtb_UnitDelay_b4 * HeESSR_t_MedTEB_dT) *
            HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S1685>/Protected Division1' */
        /* Switch: '<S1708>/Switch1' incorporates:
         *  Constant: '<S1708>/Constant Value'
         *  Constant: '<S1708>/Constant Value1'
         *  Constant: '<S1708>/Constant Value2'
         *  Logic: '<S1708>/AND'
         *  RelationalOperator: '<S1708>/Greater Than or Equal '
         *  RelationalOperator: '<S1708>/Not Equal'
         *  RelationalOperator: '<S1708>/Not Equal1'
         *  Switch: '<S1708>/Switch2'
         */
        if ((rtb_Abs2_h != 0.0F) && (rtb_Product4_o != 0.0F))
        {
            /* Switch: '<S1708>/Switch1' incorporates:
             *  Product: '<S1708>/Division'
             */
            rtb_Abs2_h /= rtb_Product4_o;
        }
        else if (rtb_Abs2_h > 0.0F)
        {
            /* Switch: '<S1708>/Switch2' incorporates:
             *  Constant: '<S1708>/MAXFLOAT'
             *  Switch: '<S1708>/Switch1'
             */
            rtb_Abs2_h = 3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1708>/Switch1' incorporates:
             *  Constant: '<S1708>/Constant Value4'
             *  Switch: '<S1708>/Switch2'
             *  Switch: '<S1708>/Switch3'
             */
            rtb_Abs2_h = 0.0F;
        }

        /* End of Switch: '<S1708>/Switch1' */
        /* End of Outputs for SubSystem: '<S1685>/Protected Division1' */

        /* Sum: '<S1685>/Sum4' incorporates:
         *  Abs: '<S1685>/Abs3'
         *  Constant: '<S1685>/Constant Value3'
         *  Constant: '<S1685>/Constant Value5'
         *  Product: '<S1685>/Product3'
         */
        rtb_Abs2_h = (fabsf(rtb_Abs2_h) * 8.0F) + 1.0F;

        /* Switch: '<S1709>/Switch' */
        if (rtb_Abs2_h >= 0.0F)
        {
            /* Lookup_n-D: '<S1675>/Vector' incorporates:
             *  Sqrt: '<S1709>/Sqrt'
             */
            rtb_Abs2_h = sqrtf(rtb_Abs2_h);
        }
        else
        {
            /* Lookup_n-D: '<S1675>/Vector' incorporates:
             *  Constant: '<S1709>/Zero'
             */
            rtb_Abs2_h = 0.0F;
        }

        /* End of Switch: '<S1709>/Switch' */

        /* Lookup_n-D: '<S1675>/Vector' incorporates:
         *  Constant: '<S1685>/Constant Value'
         *  Constant: '<S1685>/Constant Value4'
         *  Constant: '<S1685>/Constant Value6'
         *  MinMax: '<S1685>/MinMax1'
         *  Product: '<S1685>/Product2'
         *  Rounding: '<S1685>/Rounding1'
         *  Sum: '<S1685>/Sum3'
         */
        rtb_Abs2_h = fmaxf(ceilf((rtb_Abs2_h - 1.0F) * 0.5F), 1.0F);

        /* Product: '<S1685>/Product' incorporates:
         *  Constant: '<S1671>/Calib'
         */
        rtb_Product4_o = rtb_Abs2_h * HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S1685>/Protected Division' */
        /* Switch: '<S1707>/Switch1' incorporates:
         *  Constant: '<S1707>/Constant Value'
         *  Constant: '<S1707>/Constant Value1'
         *  Constant: '<S1707>/Constant Value2'
         *  Constant: '<S1707>/Constant Value3'
         *  Logic: '<S1707>/AND'
         *  RelationalOperator: '<S1707>/Greater Than or Equal '
         *  RelationalOperator: '<S1707>/Greater Than or Equal 1'
         *  RelationalOperator: '<S1707>/Not Equal'
         *  RelationalOperator: '<S1707>/Not Equal1'
         *  Switch: '<S1707>/Switch2'
         *  Switch: '<S1707>/Switch3'
         */
        if ((rtb_Sum6_ax != 0.0F) && (rtb_Product4_o != 0.0F))
        {
            /* Switch: '<S1707>/Switch1' incorporates:
             *  Product: '<S1707>/Division'
             */
            rtb_Sum6_ax /= rtb_Product4_o;
        }
        else if (rtb_Sum6_ax > 0.0F)
        {
            /* Switch: '<S1707>/Switch2' incorporates:
             *  Constant: '<S1707>/MAXFLOAT'
             *  Switch: '<S1707>/Switch1'
             */
            rtb_Sum6_ax = 3.402823466E+38F;
        }
        else if (rtb_Sum6_ax < 0.0F)
        {
            /* Switch: '<S1707>/Switch3' incorporates:
             *  Constant: '<S1707>/MINFLOAT'
             *  Switch: '<S1707>/Switch1'
             *  Switch: '<S1707>/Switch2'
             */
            rtb_Sum6_ax = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1707>/Switch1' incorporates:
             *  Constant: '<S1707>/Constant Value4'
             *  Switch: '<S1707>/Switch2'
             *  Switch: '<S1707>/Switch3'
             */
            rtb_Sum6_ax = 0.0F;
        }

        /* End of Switch: '<S1707>/Switch1' */
        /* End of Outputs for SubSystem: '<S1685>/Protected Division' */

        /* Sum: '<S1685>/Sum' incorporates:
         *  Constant: '<S1671>/Calib'
         *  Constant: '<S1685>/Constant Value1'
         *  Constant: '<S1685>/Constant Value2'
         *  Product: '<S1685>/Product1'
         *  Sum: '<S1685>/Sum2'
         */
        rtb_UnitDelay_b4 = rtb_Sum6_ax - (((0.5F * rtb_UnitDelay_b4) *
            (rtb_Abs2_h - 1.0F)) * HeESSR_t_MedTEB_dT);

        /* Switch: '<S1681>/Switch4' incorporates:
         *  Constant: '<S1688>/Calib'
         */
        if (!HeESSR_b_NiLmtForAccelByps)
        {
            /* Switch: '<S1681>/Switch4' incorporates:
             *  MinMax: '<S1681>/MinMax1'
             */
            rtb_Switch_hy = fminf(rtb_UnitDelay_b4, rtb_Switch_hy);
        }

        /* End of Switch: '<S1681>/Switch4' */

        /* Outputs for Atomic SubSystem: '<S1681>/Limiter13' */
        /* RelationalOperator: '<S1693>/Relational Operator' */
        rtb_Equal_n = (rtu_VeHSER_dn_NiDotMax <= rtb_Switch_hy);

        /* Switch: '<S1693>/Switch1' */
        if (rtb_Equal_n)
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = rtu_VeHSER_dn_NiDotMax;
        }
        else
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = rtb_Switch_hy;
        }

        /* End of Switch: '<S1693>/Switch1' */

        /* Switch: '<S1693>/Switch' incorporates:
         *  RelationalOperator: '<S1693>/Relational Operator1'
         */
        if (rtb_Abs2_h <= rtu_VeHSER_dn_NiDotMin)
        {
            rtb_Abs2_h = rtu_VeHSER_dn_NiDotMin;
        }

        /* End of Switch: '<S1693>/Switch' */
        /* End of Outputs for SubSystem: '<S1681>/Limiter13' */

        /* Product: '<S1681>/Product9' incorporates:
         *  Constant: '<S1671>/Calib'
         */
        rtb_Switch_hy = rtb_Abs2_h * HeESSR_t_MedTEB_dT;

        /* Switch: '<S1681>/Switch2' incorporates:
         *  Constant: '<S1686>/Calib'
         *  DataStoreRead: '<S1592>/Dsr_InputSpeedProfile3'
         *  Logic: '<S1681>/Logical3'
         */
        if ((HeESSR_b_NiDotLmtBypsLoopJerk) && (VeESSR_b_NiDotMinActive_DS))
        {
            /* Switch: '<S1681>/Switch2' */
            rtb_Gain_o = rtb_Switch1_fz;
        }
        else
        {
            /* Switch: '<S1681>/Switch2' incorporates:
             *  DataStoreRead: '<S1592>/Dsr_InputAcceltnProf'
             *  Sum: '<S1681>/Sum16'
             */
            rtb_Gain_o += VeESSR_dn_InputAcceltnProf_DS;
        }

        /* End of Switch: '<S1681>/Switch2' */

        /* Outputs for Atomic SubSystem: '<S1681>/Limiter' */
        /* Switch: '<S1691>/Switch1' incorporates:
         *  RelationalOperator: '<S1691>/Relational Operator'
         */
        if (rtb_Switch1_lp < rtb_Gain_o)
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = rtb_Switch1_lp;
        }
        else
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = rtb_Gain_o;
        }

        /* End of Switch: '<S1691>/Switch1' */

        /* Switch: '<S1691>/Switch' incorporates:
         *  RelationalOperator: '<S1691>/Relational Operator1'
         */
        if (rtb_Abs2_h > rtb_Switch1_fz)
        {
            /* Switch: '<S1691>/Switch' */
            rtb_Gain_o = rtb_Abs2_h;
        }
        else
        {
            /* Switch: '<S1691>/Switch' */
            rtb_Gain_o = rtb_Switch1_fz;
        }

        /* End of Switch: '<S1691>/Switch' */
        /* End of Outputs for SubSystem: '<S1681>/Limiter' */

        /* Outputs for Atomic SubSystem: '<S1681>/Limiter3' */
        /* Switch: '<S1695>/Switch1' incorporates:
         *  DataStoreRead: '<S1592>/Dsr_NiProfGenNiDMax'
         *  RelationalOperator: '<S1695>/Relational Operator'
         */
        if (VeESSR_dn_StrtTypNiDotMax_DS < rtb_Gain_o)
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = VeESSR_dn_StrtTypNiDotMax_DS;
        }
        else
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = rtb_Gain_o;
        }

        /* End of Switch: '<S1695>/Switch1' */
        /* End of Outputs for SubSystem: '<S1681>/Limiter3' */

        /* Switch: '<S1681>/Switch5' incorporates:
         *  Constant: '<S1688>/Calib'
         *  DataStoreRead: '<S1592>/Dsr_NiProfGenNiDMin'
         *  RelationalOperator: '<S1695>/Relational Operator1'
         *  Switch: '<S1695>/Switch'
         */
        if (HeESSR_b_NiLmtForAccelByps)
        {
            /* Outputs for Atomic SubSystem: '<S1681>/Limiter3' */
            /* Switch: '<S1695>/Switch' incorporates:
             *  DataStoreRead: '<S1592>/Dsr_NiProfGenNiDMin'
             *  RelationalOperator: '<S1695>/Relational Operator1'
             */
            if (rtb_Abs2_h > VeESSR_dn_StrtTypNiDotMin_DS)
            {
                /* Switch: '<S1681>/Switch5' */
                rtb_Gain_o = rtb_Abs2_h;
            }
            else
            {
                /* Switch: '<S1681>/Switch5' */
                rtb_Gain_o = VeESSR_dn_StrtTypNiDotMin_DS;
            }

            /* End of Outputs for SubSystem: '<S1681>/Limiter3' */
        }
        else
        {
            /* Outputs for Atomic SubSystem: '<S1681>/Limiter3' */
            if (rtb_Abs2_h <= VeESSR_dn_StrtTypNiDotMin_DS)
            {
                /* Switch: '<S1695>/Switch' incorporates:
                 *  DataStoreRead: '<S1592>/Dsr_NiProfGenNiDMin'
                 */
                rtb_Abs2_h = VeESSR_dn_StrtTypNiDotMin_DS;
            }

            /* End of Outputs for SubSystem: '<S1681>/Limiter3' */

            /* Switch: '<S1681>/Switch5' incorporates:
             *  MinMax: '<S1681>/MinMax2'
             */
            rtb_Gain_o = fminf(rtb_UnitDelay_b4, rtb_Abs2_h);
        }

        /* End of Switch: '<S1681>/Switch5' */

        /* Outputs for Atomic SubSystem: '<S1681>/Limiter9' */
        /* Switch: '<S1698>/Switch1' incorporates:
         *  RelationalOperator: '<S1698>/Relational Operator'
         */
        if (rtu_VeHSER_dn_NiDotMax <= rtb_Gain_o)
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = rtu_VeHSER_dn_NiDotMax;
        }
        else
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = rtb_Gain_o;
        }

        /* End of Switch: '<S1698>/Switch1' */

        /* RelationalOperator: '<S1697>/Relational Operator1' incorporates:
         *  RelationalOperator: '<S1698>/Relational Operator1'
         */
        rtb_Merge_hn = (rtb_Abs2_h > rtu_VeHSER_dn_NiDotMin);

        /* Logic: '<S1698>/Logical2' */
        rtb_Logical2_bmg = !rtb_Merge_hn;

        /* Switch: '<S1698>/Switch' */
        if (!rtb_Merge_hn)
        {
            rtb_Abs2_h = rtu_VeHSER_dn_NiDotMin;
        }

        /* End of Switch: '<S1698>/Switch' */
        /* End of Outputs for SubSystem: '<S1681>/Limiter9' */

        /* Product: '<S1681>/Product10' incorporates:
         *  Constant: '<S1671>/Calib'
         */
        rtb_Gain_o = rtb_Abs2_h * HeESSR_t_MedTEB_dT;

        /* Sum: '<S1681>/Sum2' incorporates:
         *  DataStoreRead: '<S1592>/Dsr_InputSpeedProfile1'
         */
        rtb_Switch1_lp = rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS;

        /* Sum: '<S1684>/Sum6' incorporates:
         *  Constant: '<S1671>/Calib'
         *  DataStoreRead: '<S1592>/Dsr_InputSpeedProfile1'
         *  Product: '<S1684>/Product7'
         *  Sum: '<S1681>/Sum6'
         *  Switch: '<S1681>/Switch3'
         */
        rtb_IntegerDelay = (rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS) -
            (rtb_Sum15 * HeESSR_t_MedTEB_dT);

        /* Abs: '<S1684>/Abs2' incorporates:
         *  Sum: '<S1684>/Sum6'
         */
        rtb_UnitDelay_b4 = fabsf(rtb_IntegerDelay);

        /* Switch: '<S1684>/Switch' incorporates:
         *  Constant: '<S1684>/Constant Value7'
         *  RelationalOperator: '<S1684>/Comparison2'
         *  Sum: '<S1684>/Sum6'
         */
        if (rtb_IntegerDelay < 0.0F)
        {
            /* Lookup_n-D: '<S1675>/Vector' incorporates:
             *  Abs: '<S1684>/Abs'
             */
            rtb_Abs2_h = fabsf(rtb_Sum2_h5);
        }
        else
        {
            /* Lookup_n-D: '<S1675>/Vector' incorporates:
             *  Abs: '<S1684>/Abs1'
             *  Gain: '<S1684>/Gain'
             */
            rtb_Abs2_h = -fabsf(rtb_Product4);
        }

        /* End of Switch: '<S1684>/Switch' */

        /* Product: '<S1684>/Product4' incorporates:
         *  Constant: '<S1671>/Calib'
         */
        rtb_Product4 = (rtb_Abs2_h * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S1684>/Protected Division1' */
        /* Switch: '<S1704>/Switch1' incorporates:
         *  Constant: '<S1704>/Constant Value'
         *  Constant: '<S1704>/Constant Value1'
         *  Constant: '<S1704>/Constant Value2'
         *  Logic: '<S1704>/AND'
         *  RelationalOperator: '<S1704>/Greater Than or Equal '
         *  RelationalOperator: '<S1704>/Not Equal'
         *  RelationalOperator: '<S1704>/Not Equal1'
         *  Switch: '<S1704>/Switch2'
         */
        if ((rtb_UnitDelay_b4 != 0.0F) && (rtb_Product4 != 0.0F))
        {
            /* Switch: '<S1704>/Switch1' incorporates:
             *  Product: '<S1704>/Division'
             */
            rtb_Product4 = rtb_UnitDelay_b4 / rtb_Product4;
        }
        else if (rtb_UnitDelay_b4 > 0.0F)
        {
            /* Switch: '<S1704>/Switch2' incorporates:
             *  Constant: '<S1704>/MAXFLOAT'
             *  Switch: '<S1704>/Switch1'
             */
            rtb_Product4 = 3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1704>/Switch1' incorporates:
             *  Constant: '<S1704>/Constant Value4'
             *  Switch: '<S1704>/Switch2'
             *  Switch: '<S1704>/Switch3'
             */
            rtb_Product4 = 0.0F;
        }

        /* End of Switch: '<S1704>/Switch1' */
        /* End of Outputs for SubSystem: '<S1684>/Protected Division1' */

        /* Sum: '<S1684>/Sum4' incorporates:
         *  Abs: '<S1684>/Abs3'
         *  Constant: '<S1684>/Constant Value3'
         *  Constant: '<S1684>/Constant Value5'
         *  Product: '<S1684>/Product3'
         */
        rtb_Product4 = (fabsf(rtb_Product4) * 8.0F) + 1.0F;

        /* Switch: '<S1705>/Switch' incorporates:
         *  Constant: '<S1705>/Zero'
         *  Sqrt: '<S1705>/Sqrt'
         */
        if (rtb_Product4 >= 0.0F)
        {
            rtb_Product4 = sqrtf(rtb_Product4);
        }
        else
        {
            rtb_Product4 = 0.0F;
        }

        /* End of Switch: '<S1705>/Switch' */

        /* UnitDelay: '<S1592>/Unit Delay' incorporates:
         *  Constant: '<S1684>/Constant Value'
         *  Constant: '<S1684>/Constant Value4'
         *  Constant: '<S1684>/Constant Value6'
         *  MinMax: '<S1684>/MinMax1'
         *  Product: '<S1684>/Product2'
         *  Rounding: '<S1684>/Rounding1'
         *  Sum: '<S1684>/Sum3'
         */
        rtb_UnitDelay_b4 = fmaxf(ceilf((rtb_Product4 - 1.0F) * 0.5F), 1.0F);

        /* Product: '<S1684>/Product' incorporates:
         *  Constant: '<S1671>/Calib'
         */
        rtb_Product4 = rtb_UnitDelay_b4 * HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S1684>/Protected Division' */
        /* Switch: '<S1703>/Switch1' incorporates:
         *  Constant: '<S1703>/Constant Value'
         *  Constant: '<S1703>/Constant Value1'
         *  Constant: '<S1703>/Constant Value2'
         *  Constant: '<S1703>/Constant Value3'
         *  Logic: '<S1703>/AND'
         *  RelationalOperator: '<S1703>/Greater Than or Equal '
         *  RelationalOperator: '<S1703>/Greater Than or Equal 1'
         *  RelationalOperator: '<S1703>/Not Equal'
         *  RelationalOperator: '<S1703>/Not Equal1'
         *  Sum: '<S1684>/Sum6'
         *  Switch: '<S1703>/Switch2'
         *  Switch: '<S1703>/Switch3'
         */
        if ((rtb_IntegerDelay != 0.0F) && (rtb_Product4 != 0.0F))
        {
            /* Switch: '<S1703>/Switch1' incorporates:
             *  Product: '<S1703>/Division'
             */
            rtb_Product4 = rtb_IntegerDelay / rtb_Product4;
        }
        else if (rtb_IntegerDelay > 0.0F)
        {
            /* Switch: '<S1703>/Switch2' incorporates:
             *  Constant: '<S1703>/MAXFLOAT'
             *  Switch: '<S1703>/Switch1'
             */
            rtb_Product4 = 3.402823466E+38F;
        }
        else if (rtb_IntegerDelay < 0.0F)
        {
            /* Switch: '<S1703>/Switch3' incorporates:
             *  Constant: '<S1703>/MINFLOAT'
             *  Switch: '<S1703>/Switch1'
             *  Switch: '<S1703>/Switch2'
             */
            rtb_Product4 = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1703>/Switch1' incorporates:
             *  Constant: '<S1703>/Constant Value4'
             *  Switch: '<S1703>/Switch2'
             *  Switch: '<S1703>/Switch3'
             */
            rtb_Product4 = 0.0F;
        }

        /* End of Switch: '<S1703>/Switch1' */
        /* End of Outputs for SubSystem: '<S1684>/Protected Division' */

        /* Switch: '<S1681>/Switch3' incorporates:
         *  Constant: '<S1689>/Calib'
         */
        if (!HeESSR_b_TrnstnJerkByps)
        {
            /* Switch: '<S1681>/Switch8' incorporates:
             *  Constant: '<S1681>/Constant Value7'
             *  RelationalOperator: '<S1681>/Comparison'
             */
            if (rtb_IntegerDelay > 0.0F)
            {
                /* Switch: '<S1681>/Switch3' incorporates:
                 *  Constant: '<S1671>/Calib'
                 *  Constant: '<S1684>/Constant Value1'
                 *  Constant: '<S1684>/Constant Value2'
                 *  MinMax: '<S1681>/MinMax4'
                 *  Product: '<S1681>/Product5'
                 *  Product: '<S1684>/Product1'
                 *  Sum: '<S1684>/Sum'
                 *  Sum: '<S1684>/Sum2'
                 *  Switch: '<S1681>/Switch8'
                 */
                rtb_Switch1_lp = fminf(rtb_Switch1_lp, ((rtb_Product4 +
                    rtb_Sum15) - (((0.5F * rtb_Abs2_h) * (rtb_UnitDelay_b4 -
                    1.0F)) * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
            }
            else
            {
                /* Switch: '<S1681>/Switch3' incorporates:
                 *  Constant: '<S1671>/Calib'
                 *  Constant: '<S1684>/Constant Value1'
                 *  Constant: '<S1684>/Constant Value2'
                 *  MinMax: '<S1681>/MinMax5'
                 *  Product: '<S1681>/Product2'
                 *  Product: '<S1684>/Product1'
                 *  Sum: '<S1684>/Sum'
                 *  Sum: '<S1684>/Sum2'
                 *  Switch: '<S1681>/Switch8'
                 */
                rtb_Switch1_lp = fmaxf(rtb_Switch1_lp, ((rtb_Product4 +
                    rtb_Sum15) - (((0.5F * rtb_Abs2_h) * (rtb_UnitDelay_b4 -
                    1.0F)) * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
            }

            /* End of Switch: '<S1681>/Switch8' */
        }

        /* Outputs for Atomic SubSystem: '<S1681>/Limiter6' */
        /* RelationalOperator: '<S1697>/Relational Operator' */
        rtb_RelationalOperator_a2 = (rtb_Switch_hy <= rtb_Switch1_lp);

        /* Switch: '<S1697>/Switch1' */
        if (rtb_RelationalOperator_a2)
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = rtb_Switch_hy;
        }
        else
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = rtb_Switch1_lp;
        }

        /* End of Switch: '<S1697>/Switch1' */

        /* RelationalOperator: '<S1697>/Relational Operator1' */
        rtb_Merge_hn = (rtb_Abs2_h > rtb_Gain_o);

        /* Switch: '<S1697>/Switch' */
        if (rtb_Merge_hn)
        {
            rtb_Gain_o = rtb_Abs2_h;
        }

        /* End of Switch: '<S1697>/Switch' */
        /* End of Outputs for SubSystem: '<S1681>/Limiter6' */

        /* Sum: '<S1681>/Sum4' incorporates:
         *  DataStoreRead: '<S1592>/Dsr_InputSpeedProfile1'
         */
        rtb_IntegerDelay = rtb_Gain_o + VeESSR_n_InputSpeedProfile_DS;

        /* Outputs for Atomic SubSystem: '<S1681>/Limiter1' */
        /* RelationalOperator: '<S1692>/Relational Operator' incorporates:
         *  DataStoreWrite: '<S1592>/Dsw_InputSpeedProfile5'
         */
        VeESSR_b_NiMaxActive_DS = (rtu_VeHSER_n_NiMax <= rtb_IntegerDelay);

        /* Switch: '<S1692>/Switch1' incorporates:
         *  DataStoreWrite: '<S1592>/Dsw_InputSpeedProfile5'
         */
        if (VeESSR_b_NiMaxActive_DS)
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = rtu_VeHSER_n_NiMax;
        }
        else
        {
            /* Lookup_n-D: '<S1675>/Vector' */
            rtb_Abs2_h = rtb_IntegerDelay;
        }

        /* End of Switch: '<S1692>/Switch1' */

        /* Switch: '<S1692>/Switch' incorporates:
         *  Constant: '<S1681>/Constant Value4'
         *  RelationalOperator: '<S1692>/Relational Operator1'
         */
        if (rtb_Abs2_h > 0.0F)
        {
            /* Switch: '<S1692>/Switch' */
            rtb_IntegerDelay = rtb_Abs2_h;
        }
        else
        {
            /* Switch: '<S1692>/Switch' */
            rtb_IntegerDelay = 0.0F;
        }

        /* End of Switch: '<S1692>/Switch' */
        /* End of Outputs for SubSystem: '<S1681>/Limiter1' */

        /* Product: '<S1681>/Product3' incorporates:
         *  Constant: '<S1671>/Calib'
         *  DataStoreRead: '<S1592>/Dsr_InputSpeedProfile1'
         *  DataStoreWrite: '<S1592>/Dsw_InputAcceltnProf'
         *  Sum: '<S1681>/Sum'
         */
        VeESSR_dn_InputAcceltnProf_DS = (rtb_IntegerDelay -
            VeESSR_n_InputSpeedProfile_DS) / HeESSR_t_MedTEB_dT;

        /* DataStoreWrite: '<S1592>/Dsw_InputSpeedProfile' */
        VeESSR_n_InputSpeedProfile_DS = rtb_IntegerDelay;

        /* Logic: '<S1681>/Logical2' incorporates:
         *  DataStoreWrite: '<S1592>/Dsw_InputSpeedProfile1'
         */
        VeESSR_b_NiDotMaxActive_DS = (rtb_Equal_n && rtb_RelationalOperator_a2);

        /* DataStoreWrite: '<S1592>/Dsw_InputSpeedProfile2' */
        VeESSR_n_TargetSpeed_DS = rtb_Gain1_e1;

        /* DataStoreWrite: '<S1592>/Dsw_InputSpeedProfile3' */
        VeESSR_dn_TargetAcceltn_DS = rtb_Sum15;

        /* Outputs for Atomic SubSystem: '<S1681>/Limiter6' */
        /* Logic: '<S1681>/Logical' incorporates:
         *  DataStoreWrite: '<S1592>/Dsw_InputSpeedProfile4'
         *  Logic: '<S1697>/Logical2'
         */
        VeESSR_b_NiDotMinActive_DS = (rtb_Logical2_bmg && (!rtb_Merge_hn));

        /* End of Outputs for SubSystem: '<S1681>/Limiter6' */

        /* DataStoreWrite: '<S1592>/Dsw_Ni1stFlt_DS' */
        VeESSR_n_Ni1stFlt_DS = rtb_Summation_np;

        /* Sum: '<S1670>/Subtraction1' incorporates:
         *  Lookup_n-D: '<S1675>/Vector'
         *  Product: '<S1670>/Multiplication'
         *  Sum: '<S1592>/Sum'
         *  Sum: '<S1592>/Sum1'
         *  Sum: '<S1670>/Subtraction'
         *  UnitDelay: '<S1592>/Unit Delay'
         */
        VeESSR_M_SlowSpinInputTorq = (((rtb_SumSub_j -
            rtu_VeESSR_M_AddtlDragTorq) - VeESSR_M_SlowSpinInputTorq) *
            look1_iflf_binlcapw(rtb_SumSub_j - rtu_VeESSR_M_EngStrtTrqSnsd, ((
            const float32 *)&(KxESSR_K_TiEstCKSSlowSpin[0])), ((const float32 *)
            &(KtESSR_K_TiEstCKSSlowSpin[0])), 5U)) + VeESSR_M_SlowSpinInputTorq;

        /* Switch: '<S1617>/Switch1' incorporates:
         *  Gain: '<S1677>/Gain'
         */
        rtb_SumSub_j = VeESSR_M_SlowSpinInputTorq;

        /* Sum: '<S1681>/Sum17' incorporates:
         *  DataStoreWrite: '<S1592>/Dsw_InputAcceltnProf'
         */
        VeESSR_dn_InputJerkProfSpinUpCKSSlow = VeESSR_dn_InputAcceltnProf_DS -
            rtb_Gain_my;

        /* Update for UnitDelay: '<S1700>/Unit Delay' incorporates:
         *  Switch: '<S1700>/Switch3'
         */
        localDW->UnitDelay_DSTATE = rtb_Summation_eb;

        /* Update for Delay: '<S1681>/IntegerDelay' */
        localDW->icLoad = 0U;
        for (i = 0; i < 15; i++)
        {
            localDW->IntegerDelay_DSTATE[i] = localDW->IntegerDelay_DSTATE[i + 1];
        }

        localDW->IntegerDelay_DSTATE[15] = rtb_Gain1_e1;

        /* End of Update for Delay: '<S1681>/IntegerDelay' */
        /* End of Outputs for SubSystem: '<S1564>/SlowSpin' */
    }

    /* End of If: '<S1564>/If' */

    /* Gain: '<S1568>/Gain' incorporates:
     *  MinMax: '<S1564>/MinMax'
     *  Sum: '<S1564>/Summation5'
     */
    rtb_Summation_eb = (fminf(rtu_VeESMR_P_BatSTMaxLim,
                         rtu_VeESMR_P_BatEstdVoltMaxLim) -
                        rtu_VeABCR_P_HV_AccPwr) * 1000.0F;

    /* Gain: '<S1602>/Gain' incorporates:
     *  DataStoreRead: '<S1564>/Dsr_InputSpeedProfile2'
     */
    rtb_Gain1_e1 = 0.104719758F * VeESSR_n_InputSpeedProfile_DS;

    /* Outputs for Atomic SubSystem: '<S1568>/Protected Division' */
    /* Switch: '<S1601>/Switch1' incorporates:
     *  Constant: '<S1601>/Constant Value'
     *  Constant: '<S1601>/Constant Value1'
     *  Constant: '<S1601>/Constant Value2'
     *  Constant: '<S1601>/Constant Value3'
     *  Logic: '<S1601>/AND'
     *  RelationalOperator: '<S1601>/Greater Than or Equal '
     *  RelationalOperator: '<S1601>/Greater Than or Equal 1'
     *  RelationalOperator: '<S1601>/Not Equal'
     *  RelationalOperator: '<S1601>/Not Equal1'
     *  Switch: '<S1601>/Switch2'
     *  Switch: '<S1601>/Switch3'
     */
    if ((rtb_Summation_eb != 0.0F) && (rtb_Gain1_e1 != 0.0F))
    {
        /* Switch: '<S1601>/Switch1' incorporates:
         *  Product: '<S1601>/Division'
         */
        rtb_Summation_eb /= rtb_Gain1_e1;
    }
    else if (rtb_Summation_eb > 0.0F)
    {
        /* Switch: '<S1601>/Switch2' incorporates:
         *  Constant: '<S1601>/MAXFLOAT'
         *  Switch: '<S1601>/Switch1'
         */
        rtb_Summation_eb = 3.402823466E+38F;
    }
    else if (rtb_Summation_eb < 0.0F)
    {
        /* Switch: '<S1601>/Switch3' incorporates:
         *  Constant: '<S1601>/MINFLOAT'
         *  Switch: '<S1601>/Switch1'
         *  Switch: '<S1601>/Switch2'
         */
        rtb_Summation_eb = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1601>/Switch1' incorporates:
         *  Constant: '<S1601>/Constant Value4'
         *  Switch: '<S1601>/Switch2'
         *  Switch: '<S1601>/Switch3'
         */
        rtb_Summation_eb = 0.0F;
    }

    /* End of Switch: '<S1601>/Switch1' */
    /* End of Outputs for SubSystem: '<S1568>/Protected Division' */

    /* Product: '<S1568>/Product' incorporates:
     *  Constant: '<S1598>/Calib'
     */
    VeESSR_M_CKSTiEstLim = rtb_Summation_eb * KeESSR_scl_CKSTiEstLim;

    /* MinMax: '<S1568>/MinMax' incorporates:
     *  Constant: '<S1595>/Calib'
     */
    rtb_Gain1_e1 = fminf(KeESSR_M_CKSSpdCtlMaxTi, VeESSR_M_CKSTiEstLim);

    /* Gain: '<S1568>/Negation' */
    rtb_Summation_eb = -rtb_Gain1_e1;

    /* Sum: '<S1568>/Summation5' incorporates:
     *  DataStoreRead: '<S1564>/Dsr_InputSpeedProfile2'
     */
    VeESSR_n_CKSSpdError = VeESSR_n_InputSpeedProfile_DS -
        rtu_VeESSR_n_TransInSpdFlt;

    /* Outputs for Atomic SubSystem: '<S1568>/DeadBand' */
    /* Switch: '<S1593>/Switch1' incorporates:
     *  Constant: '<S1593>/Constant Value'
     *  Constant: '<S1596>/Calib'
     *  Constant: '<S1597>/Calib'
     *  RelationalOperator: '<S1593>/Greater  Than'
     *  RelationalOperator: '<S1593>/Greater  Than1'
     *  Sum: '<S1593>/Subtraction'
     *  Switch: '<S1593>/Switch2'
     */
    if (VeESSR_n_CKSSpdError >= KeESSR_n_CKSSpdCtlPosDdBnd)
    {
        rtb_Gain_o = VeESSR_n_CKSSpdError - KeESSR_n_CKSSpdCtlPosDdBnd;
    }
    else if (VeESSR_n_CKSSpdError <= KeESSR_n_CKSSpdCtlNegDdBnd)
    {
        /* Switch: '<S1593>/Switch2' incorporates:
         *  Constant: '<S1596>/Calib'
         *  Sum: '<S1593>/Subtraction1'
         */
        rtb_Gain_o = VeESSR_n_CKSSpdError - KeESSR_n_CKSSpdCtlNegDdBnd;
    }
    else
    {
        rtb_Gain_o = 0.0F;
    }

    /* End of Switch: '<S1593>/Switch1' */
    /* End of Outputs for SubSystem: '<S1568>/DeadBand' */

    /* Product: '<S1568>/Multiplication' incorporates:
     *  Constant: '<S1594>/Calib'
     */
    rtb_Summation_np = rtb_Gain_o * KeESSR_K_CKSSpdCtlPgain;

    /* Outputs for Atomic SubSystem: '<S1568>/Limiter' */
    /* Switch: '<S1599>/Switch1' incorporates:
     *  RelationalOperator: '<S1599>/Relational Operator'
     */
    if (rtb_Gain1_e1 >= rtb_Summation_np)
    {
        /* Switch: '<S1599>/Switch1' */
        rtb_Gain1_e1 = rtb_Summation_np;
    }

    /* End of Switch: '<S1599>/Switch1' */

    /* Switch: '<S1599>/Switch' incorporates:
     *  RelationalOperator: '<S1599>/Relational Operator1'
     */
    if (rtb_Gain1_e1 > rtb_Summation_eb)
    {
        /* Switch: '<S1599>/Switch' */
        VeESSR_M_CKSSpdCtlTi = rtb_Gain1_e1;
    }
    else
    {
        /* Switch: '<S1599>/Switch' */
        VeESSR_M_CKSSpdCtlTi = rtb_Summation_eb;
    }

    /* End of Switch: '<S1599>/Switch' */
    /* End of Outputs for SubSystem: '<S1568>/Limiter' */

    /* Sum: '<S1564>/Summation4' incorporates:
     *  DataStoreWrite: '<S1564>/Dsw_InputTorqEst'
     */
    VeESSR_M_EngTorqEst_DS = rtb_SumSub_j + VeESSR_M_CKSSpdCtlTi;

    /* DataStoreWrite: '<S1564>/Dsw_STMTmr' incorporates:
     *  Constant: '<S1574>/Calib'
     *  DataStoreRead: '<S1564>/Dsr_STMTmr'
     *  Sum: '<S1564>/Summation'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Switch: '<S1576>/Switch1' incorporates:
     *  Constant: '<S1569>/Constant'
     *  DataStoreWrite: '<S1564>/Dsw_STMTrigger'
     *  Switch: '<S1576>/Switch2'
     */
    if (rtb_GreaterThan3_e)
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngSpdTgtAch;
    }
    else
    {
        if (rtb_GreaterThan1_ix)
        {
            /* Switch: '<S1576>/Switch1' incorporates:
             *  Constant: '<S1570>/Constant'
             *  DataStoreWrite: '<S1564>/Dsw_STMTrigger'
             *  Switch: '<S1576>/Switch2'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;
        }
    }

    /* End of Switch: '<S1576>/Switch1' */

    /* Abs: '<S1572>/Abs' incorporates:
     *  Constant: '<S1574>/Calib'
     *  Constant: '<S1582>/Calib'
     *  Product: '<S1572>/Multiplication'
     */
    rtb_SumSub_j = fabsf(KeESSR_dscl_RampUpRtCKS * HeESSR_t_MedTEB_dT);

    /* Gain: '<S1572>/Gain' */
    rtb_Summation_eb = -rtb_SumSub_j;

    /* Sum: '<S1572>/Sum' incorporates:
     *  Constant: '<S1587>/Calib'
     *  DataStoreRead: '<S1564>/Dsr_SpdCtlGainMod1'
     */
    rtb_Gain1_e1 = KeESSR_scl_RampUpCKS - VeESSR_scl_SpdCtlGainMod_DS;

    /* Outputs for Atomic SubSystem: '<S1572>/Limiter1' */
    /* Switch: '<S1616>/Switch1' incorporates:
     *  RelationalOperator: '<S1616>/Relational Operator'
     */
    if (rtb_SumSub_j >= rtb_Gain1_e1)
    {
        /* Switch: '<S1617>/Switch1' */
        rtb_SumSub_j = rtb_Gain1_e1;
    }

    /* End of Switch: '<S1616>/Switch1' */

    /* Switch: '<S1616>/Switch' incorporates:
     *  RelationalOperator: '<S1616>/Relational Operator1'
     */
    if (rtb_SumSub_j > rtb_Summation_eb)
    {
        rtb_Summation_eb = rtb_SumSub_j;
    }

    /* End of Switch: '<S1616>/Switch' */
    /* End of Outputs for SubSystem: '<S1572>/Limiter1' */

    /* Sum: '<S1572>/Sum1' incorporates:
     *  DataStoreRead: '<S1564>/Dsr_SpdCtlGainMod1'
     */
    rtb_SumSub_j = rtb_Summation_eb + VeESSR_scl_SpdCtlGainMod_DS;

    /* Outputs for Atomic SubSystem: '<S1572>/Limiter2' */
    /* Switch: '<S1617>/Switch1' incorporates:
     *  Constant: '<S1564>/Constant Value7'
     *  RelationalOperator: '<S1617>/Relational Operator'
     */
    if (2.0F < rtb_SumSub_j)
    {
        /* Switch: '<S1617>/Switch1' */
        rtb_SumSub_j = 2.0F;
    }

    /* End of Switch: '<S1617>/Switch1' */

    /* Switch: '<S1617>/Switch' incorporates:
     *  Constant: '<S1564>/Constant Value6'
     *  DataStoreWrite: '<S1564>/Dsw_SpdCtlGainMod1'
     *  RelationalOperator: '<S1617>/Relational Operator1'
     */
    if (rtb_SumSub_j > 0.0F)
    {
        VeESSR_scl_SpdCtlGainMod_DS = rtb_SumSub_j;
    }
    else
    {
        VeESSR_scl_SpdCtlGainMod_DS = 0.0F;
    }

    /* End of Switch: '<S1617>/Switch' */
    /* End of Outputs for SubSystem: '<S1572>/Limiter2' */

    /* If: '<S1564>/If1' */
    if (rtb_LogicalOperator1_ny)
    {
        /* Outputs for IfAction SubSystem: '<S1564>/If_KeyCrank_P1C65' incorporates:
         *  ActionPort: '<S1579>/Action Port'
         */
        /* DataStoreWrite: '<S1564>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_KeyCrank_P1C65((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S1564>/If_KeyCrank_P1C65' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1564>/If_KeyCrank_NoFault' incorporates:
         *  ActionPort: '<S1578>/Action Port'
         */
        /* DataStoreWrite: '<S1564>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_KeyCrank_NoFault((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S1564>/If_KeyCrank_NoFault' */
    }

    /* End of If: '<S1564>/If1' */

    /* Switch: '<S1564>/Switch4' incorporates:
     *  Constant: '<S1564>/Constant Value4'
     *  DataStoreRead: '<S1564>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S1564>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S1564>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S1564>/Logical21'
     *  RelationalOperator: '<S1564>/Comparison'
     *  S-Function (sfix_bitop): '<S1564>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S1567>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator1_ny && ((VeESSR_g_StrtStpFailPhaseSelect_DS & 64U) >
         0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 64U;
    }

    /* End of Switch: '<S1564>/Switch4' */

    /* Update for UnitDelay: '<S1614>/Unit Delay' */
    localDW->UnitDelay_DSTATE_oj = rtb_Switch1_oq;
}

#endif

/*
 * Output and update for action system:
 *    '<S1855>/ESSC_PBatBoostReset'
 *    '<S2076>/ESSC_PBatBoostReset'
 *    '<S573>/ESSC_PBatBoostReset'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_PBatBoostReset(void)
{
    /* Switch: '<S1931>/Switch1' incorporates:
     *  Constant: '<S1865>/Constant Value'
     *  Constant: '<S1930>/Calib'
     *  DataStoreRead: '<S1865>/Dsr_AStrtPBatBoostReq1'
     *  DataStoreRead: '<S1865>/Dsr_PBatBoostTm'
     *  DataStoreWrite: '<S1865>/Dsw_PBatBoostTm'
     *  Sum: '<S1865>/Summation2'
     */
    if (VeESSR_b_AStrtPBatBoostReq_DS)
    {
        VeESSR_t_PBatBoostTm_DS = HeESSR_t_MedTEB_dT + VeESSR_t_PBatBoostTm_DS;
    }
    else
    {
        VeESSR_t_PBatBoostTm_DS = 0.0F;
    }

    /* End of Switch: '<S1931>/Switch1' */

    /* Switch: '<S1932>/Switch1' incorporates:
     *  Constant: '<S1933>/Calib'
     *  DataStoreWrite: '<S1865>/Dsw_AStrtPBatBoostReq'
     *  DataStoreWrite: '<S1865>/Dsw_PBatBoostTm'
     *  RelationalOperator: '<S1865>/Equal2'
     */
    VeESSR_b_AStrtPBatBoostReq_DS = ((VeESSR_t_PBatBoostTm_DS <=
        KeESSR_t_AStrtPBatBoostDelay) && (VeESSR_b_AStrtPBatBoostReq_DS));
}

#endif

/*
 * Output and update for action system:
 *    '<S1864>/ESSC_CombstDelay'
 *    '<S579>/ESSC_CombstDelay'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_CombstDelay(P2VAR(boolean,
    AUTOMATIC, ESSR_VAR_INIT) rty_OutputParameter)
{
    float32 rtb_Sum_ba;

    /* Sum: '<S1921>/Sum' incorporates:
     *  Constant: '<S1926>/Calib'
     *  Constant: '<S1927>/Calib'
     *  DataStoreRead: '<S1921>/Dsr_STMTmr'
     *  DataStoreRead: '<S1921>/Dsr_STMTmr1'
     *  Product: '<S1921>/Product'
     */
    rtb_Sum_ba = ((KeESSR_k_CombstDelay * VeESSR_n_InputSpeedProfile_DS) *
                  HeESSR_t_MedTEB_dT) + VeESSR_phi_CombstDelay_DS;

    /* DataStoreWrite: '<S1921>/Dsw_InputAcceltnProf' */
    VeESSR_phi_CombstDelay_DS = rtb_Sum_ba;

    /* RelationalOperator: '<S1921>/Comparison' incorporates:
     *  Constant: '<S1928>/Calib'
     */
    *rty_OutputParameter = (rtb_Sum_ba > KeESSR_phi_CombstDelay);
}

#endif

/*
 * Output and update for action system:
 *    '<S1855>/If_StartEng_P1C64'
 *    '<S2076>/If_StartEng_P1C64'
 *    '<S2230>/If_StartEng_P1C64'
 *    '<S2297>/If_StartEng_P1C64'
 *    '<S573>/If_StartEng_P1C64'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_If_StartEng_P1C64(P2VAR
    (TeESSR_e_StrtStpFailDTC, AUTOMATIC, ESSR_VAR_INIT) rty_DTC)
{
    /* SignalConversion generated from: '<S1875>/DTC' incorporates:
     *  Constant: '<S1980>/Constant'
     */
    *rty_DTC = CeESSR_e_P1C64;
}

#endif

/*
 * Output and update for action system:
 *    '<S2044>/Subsystem'
 *    '<S2303>/Subsystem'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Subsystem(VAR(float32, AUTOMATIC)
    rtu_TiMin, VAR(float32, AUTOMATIC) rtu_y, VAR(float32, AUTOMATIC) rtu_TqAct,
    P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Out1)
{
    float32 rtb_Switch_gjp;

    /* Switch: '<S2050>/Switch' incorporates:
     *  RelationalOperator: '<S2050>/Relational Operator'
     */
    if (rtu_y < rtu_TiMin)
    {
        /* Switch: '<S2050>/Switch' */
        rtb_Switch_gjp = rtu_TiMin;
    }
    else
    {
        /* Switch: '<S2050>/Switch' */
        rtb_Switch_gjp = rtu_y;
    }

    /* End of Switch: '<S2050>/Switch' */

    /* Switch: '<S2050>/Switch1' incorporates:
     *  RelationalOperator: '<S2050>/Relational Operator1'
     */
    if (rtu_TqAct < rtb_Switch_gjp)
    {
        *rty_Out1 = rtu_TqAct;
    }
    else
    {
        *rty_Out1 = rtb_Switch_gjp;
    }

    /* End of Switch: '<S2050>/Switch1' */
}

#endif

/*
 * System reset for action system:
 *    '<S2044>/Subsystem1'
 *    '<S2303>/Subsystem1'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Subsystem1_Reset(P2VAR
    (DW_Subsystem1_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW)
{
    /* SystemReset for Atomic SubSystem: '<S2051>/Signal Latch Off' */
    /* InitializeConditions for UnitDelay: '<S2052>/Unit Delay' */
    localDW->UnitDelay_DSTATE = false;

    /* End of SystemReset for SubSystem: '<S2051>/Signal Latch Off' */
}

#endif

/*
 * Output and update for action system:
 *    '<S2044>/Subsystem1'
 *    '<S2303>/Subsystem1'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Subsystem1(VAR(float32, AUTOMATIC)
    rtu_TiMin, VAR(float32, AUTOMATIC) rtu_y, VAR(float32, AUTOMATIC) rtu_TqAct,
    VAR(boolean, AUTOMATIC) rtu_CmbCmd, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT)
    rty_Out1, P2VAR(DW_Subsystem1_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW)
{
    boolean rtb_OR2_l;

    /* Outputs for Atomic SubSystem: '<S2051>/Signal Latch Off' */
    /* Logic: '<S2052>/OR2' incorporates:
     *  Logic: '<S2051>/Logical Operator'
     *  Logic: '<S2051>/Logical Operator1'
     *  Logic: '<S2052>/Logical1'
     *  RelationalOperator: '<S2051>/Relational Operator3'
     *  UnitDelay: '<S2052>/Unit Delay'
     */
    rtb_OR2_l = (((rtu_TqAct < rtu_TiMin) && (!rtu_CmbCmd)) &&
                 (!localDW->UnitDelay_DSTATE));

    /* Update for UnitDelay: '<S2052>/Unit Delay' incorporates:
     *  Logic: '<S2052>/Logical2'
     */
    localDW->UnitDelay_DSTATE = !rtb_OR2_l;

    /* End of Outputs for SubSystem: '<S2051>/Signal Latch Off' */

    /* Switch: '<S2051>/Switch3' */
    if (rtb_OR2_l)
    {
        *rty_Out1 = rtu_TiMin;
    }
    else
    {
        *rty_Out1 = rtu_y;
    }

    /* End of Switch: '<S2051>/Switch3' */
}

#endif

/* System initialize for function-call system: '<S569>/ESSC_StartEngDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_StartEngDur_Init(P2VAR
    (DW_ESSC_StartEngDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW)
{
    /* InitializeConditions for Delay: '<S2006>/IntegerDelay' */
    localDW->icLoad = 1U;

    /* SystemInitialize for Atomic SubSystem: '<S1887>/Digital Lowpass Reset Enabled1' */
    /* Start for If: '<S2044>/If' */
    localDW->If_ActiveSubsystem = -1;

    /* End of SystemInitialize for SubSystem: '<S1887>/Digital Lowpass Reset Enabled1' */

    /* SystemInitialize for Atomic SubSystem: '<S1867>/EngineTorqueCommands' */
#if Rte_SysCon_Variant_ESSR_BlueNexus

    /* SystemInitialize for Atomic SubSystem: '<S1937>/BlueNexus' */
    /* SystemInitialize for Atomic SubSystem: '<S1946>/Lowpass Second Order Enabled4' */
    /* InitializeConditions for Delay: '<S1951>/Delay' */
    localDW->icLoad_k = 1U;

    /* InitializeConditions for Delay: '<S1951>/Delay1' */
    localDW->icLoad_n = 1U;

    /* End of SystemInitialize for SubSystem: '<S1946>/Lowpass Second Order Enabled4' */
    /* End of SystemInitialize for SubSystem: '<S1937>/BlueNexus' */
#elif Rte_SysCon_Variant_ESSR_LQIR

    /* SystemInitialize for Atomic SubSystem: '<S1937>/LQIR' */
    /* SystemInitialize for Atomic SubSystem: '<S1948>/Lowpass Second Order Enabled4' */
    /* InitializeConditions for Delay: '<S1967>/Delay' */
    localDW->icLoad_d = 1U;

    /* InitializeConditions for Delay: '<S1967>/Delay1' */
    localDW->icLoad_m = 1U;

    /* End of SystemInitialize for SubSystem: '<S1948>/Lowpass Second Order Enabled4' */
    /* End of SystemInitialize for SubSystem: '<S1937>/LQIR' */
#else

    /* SystemInitialize for Atomic SubSystem: '<S1937>/Default' */
    /* SystemInitialize for Atomic SubSystem: '<S1947>/Lowpass Second Order Enabled4' */
    /* InitializeConditions for Delay: '<S1959>/Delay' */
    localDW->icLoad_g = 1U;

    /* InitializeConditions for Delay: '<S1959>/Delay1' */
    localDW->icLoad_mp = 1U;

    /* End of SystemInitialize for SubSystem: '<S1947>/Lowpass Second Order Enabled4' */
    /* End of SystemInitialize for SubSystem: '<S1937>/Default' */
#endif

    /* End of SystemInitialize for SubSystem: '<S1867>/EngineTorqueCommands' */
}

#endif

/* Output and update for function-call system: '<S569>/ESSC_StartEngDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_StartEngDur(VAR(float32,
    AUTOMATIC) rtu_VeESSR_n_OptInputSpd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngStrtTorqSnsd, VAR(float32, AUTOMATIC)
    rtu_VeCSVR_n_PrimNoSgndFltrd, VAR(boolean, AUTOMATIC)
    rtu_VeENGR_b_EngCombustionCmnd, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngTrqActual, VAR(boolean, AUTOMATIC) rtu_VeRTMR_b_InPlantMode,
    VAR(float32, AUTOMATIC) rtu_VeESSR_M_OptEngTrqReqPred, VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_OptEngTrqReqImmed, VAR(float32, AUTOMATIC)
    rtu_VeETQR_r_MaxSparkAuthority, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngineLosses, VAR(boolean, AUTOMATIC)
    rtu_VeSTRR_b_BackupStrtEngOn, VAR(TeENGR_e_ETRQ_Mode, AUTOMATIC)
    rtu_VeENGR_e_ETRQ_Mode, VAR(float32, AUTOMATIC) rtu_VeESSR_n_TransInSpdFlt,
    VAR(float32, AUTOMATIC) rtu_VeOHSR_n_IdleSpdBlended, VAR(float32, AUTOMATIC)
    rtu_EngCltTmp, VAR(float32, AUTOMATIC) rtu_VeHSER_n_NiMax, VAR(float32,
    AUTOMATIC) rtu_VeHSER_dn_NiDotMax, VAR(float32, AUTOMATIC)
    rtu_VeHSER_dn_NiDotMin, VAR(boolean, AUTOMATIC) rtu_VeSTRR_b_BumpStrtEngOn,
    VAR(boolean, AUTOMATIC) rtu_ErlyExitLmp, VAR(boolean, AUTOMATIC)
    rtu_LwrThresLmp, VAR(float32, AUTOMATIC) rtu_HTDR_TiMin, VAR(boolean,
    AUTOMATIC) rtu_PosSlipDtcdLtch4STRR, VAR(boolean, AUTOMATIC)
    rtu_VeBCPR_b_PosSlipDetected, VAR(float32, AUTOMATIC) rtu_VeTISR_n_NiFromMtr,
    VAR(float32, AUTOMATIC) rtu_VeETQR_M_EngCapacityMinRunI, VAR(boolean,
    AUTOMATIC) rtu_PNLimActv, VAR(float32, AUTOMATIC) rtu_PNLimTrq, VAR(float32,
    AUTOMATIC) rtu_TactTiMin, VAR(float32, AUTOMATIC) rtu_ImmedCal, VAR(float32,
    AUTOMATIC) rtu_AirflowTq, P2VAR(DW_ESSC_StartEngDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(ZCE_ESSC_StartEngDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localZCE, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn)
{
    float32 rtb_Maximum1;
    float32 rtb_Maximum2_a;
    float32 rtb_Product1_lj;
    float32 rtb_Product4;
    float32 rtb_Sum6_ky;
    float32 rtb_Switch1_bbr;
    float32 rtb_Switch1_mo;
    float32 rtb_Switch1_n5;
    float32 rtb_Switch_cp2;
    float32 rtb_VariantMergeForOutportNiDot;
    float32 rtb_VariantMergeForOutportNiPro;
    sint8 rtAction;
    sint8 rtPrevAction;
    boolean rtb_Equal2_o;
    boolean rtb_GreaterThan1_cc;
    boolean rtb_Logical15;
    boolean rtb_Logical5_b;
    boolean rtb_LogicalOperator3_m;
    boolean rtb_LogicalOperator4_n;
    boolean rtb_OR1_pe;
    boolean rtb_OR1_pw;
    boolean rtb_RelationalOperator_guj;
    boolean rtb_Switch1_gw;

#if Rte_SysCon_Variant_ESSR_BlueNexus || Rte_SysCon_Variant_ESSR_LQIR

    boolean rtb_UnitDelay1;

#endif

    sint32 i;
    float32 rtb_MinMax1_ow;
    float32 rtb_MinMax_bd;
    float32 rtb_MinMax_hj;
    float32 rtb_Multiplication1_gld;
    float32 rtb_Sum2_jm;
    float32 rtb_Summation_ep;
    float32 rtb_yyk1_p;
    uint8 tmp;

    /* Logic: '<S1861>/Logical Operator23' incorporates:
     *  Constant: '<S1890>/Calib'
     *  DataStoreRead: '<S1861>/Data Store Read1'
     */
    VeESSR_b_ActvBeltSlpCtrlCndnsSetStrtEng = (((VeESSR_b_BackUpStartEng_DS) &&
        rtu_PosSlipDtcdLtch4STRR) && (KeESSR_b_EnblActvBeltSlpCtrl));

    /* RelationalOperator: '<S1855>/Equal2' incorporates:
     *  Constant: '<S1869>/Calib'
     *  DataStoreRead: '<S1855>/Dsr_STMTmr'
     */
    rtb_Equal2_o = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

    /* Logic: '<S1861>/Logical Operator28' incorporates:
     *  Logic: '<S1861>/Logical Operator3'
     */
    rtb_RelationalOperator_guj = !VeESSR_b_ActvBeltSlpCtrlCndnsSetStrtEng;

    /* Outputs for Atomic SubSystem: '<S1861>/Stop Watch Reset Enabled' */
    /* Switch: '<S1896>/Switch1' incorporates:
     *  Logic: '<S1861>/Logical Operator28'
     *  Logic: '<S1861>/Logical Operator31'
     *  Switch: '<S1896>/Switch2'
     */
    if (rtb_RelationalOperator_guj || rtb_Equal2_o)
    {
        /* Switch: '<S1896>/Switch1' incorporates:
         *  Constant: '<S1896>/Constant Value2'
         */
        VeESSR_t_ActvBeltSlpCtrlAchvStrtEng = 0.0F;
    }
    else
    {
        if (VeESSR_b_ActvBeltSlpCtrlCndnsSetStrtEng)
        {
            /* Switch: '<S1896>/Switch1' incorporates:
             *  Constant: '<S1889>/Calib'
             *  Sum: '<S1896>/Subtraction'
             *  Switch: '<S1896>/Switch2'
             *  UnitDelay: '<S1896>/Unit Delay'
             */
            VeESSR_t_ActvBeltSlpCtrlAchvStrtEng = HeESSR_t_MedTEB_dT +
                VeESSR_t_ActvBeltSlpCtrlAchvStrtEng;
        }
    }

    /* End of Switch: '<S1896>/Switch1' */
    /* End of Outputs for SubSystem: '<S1861>/Stop Watch Reset Enabled' */

    /* RelationalOperator: '<S1861>/Greater  Than13' incorporates:
     *  Constant: '<S1894>/Calib'
     *  Constant: '<S1895>/Calib'
     *  MinMax: '<S1861>/MinMax'
     */
    VeESSR_b_ActvBeltSlpCtrlTmrStrtEng = (VeESSR_t_ActvBeltSlpCtrlAchvStrtEng >=
        fminf(KeESSR_t_ActvBeltSlpCtrlAchvdTmr, KeESSR_t_MaxStTmStartEng));

    /* Logic: '<S1861>/Logical Operator24' incorporates:
     *  Constant: '<S1891>/Calib'
     *  Logic: '<S1861>/Logical Operator26'
     *  Logic: '<S1861>/Logical Operator29'
     *  RelationalOperator: '<S1861>/Greater  Than14'
     */
    VeESSR_b_ActvBeltSlpCtrlAchvdStrtEng =
        ((VeESSR_b_ActvBeltSlpCtrlCndnsSetStrtEng) &&
         (((VeESSR_b_ActvBeltSlpCtrlTmrStrtEng) ||
           (!rtu_VeBCPR_b_PosSlipDetected)) || (rtu_VeTISR_n_NiFromMtr <=
           KeESSR_n_ActvBeltSlpCtrlMtrASpd)));

    /* Outputs for Atomic SubSystem: '<S1861>/Accumulator Reset Limited' */
    /* Switch: '<S1888>/Switch1' */
    if (rtb_Equal2_o)
    {
        /* Switch: '<S1888>/Switch1' incorporates:
         *  Constant: '<S1861>/Constant Value1'
         */
        rtb_Summation_ep = 0.0F;
    }
    else
    {
        /* Sum: '<S1888>/Summation' incorporates:
         *  Constant: '<S1889>/Calib'
         *  Constant: '<S1893>/Calib'
         *  Product: '<S1861>/Product'
         *  Sum: '<S1861>/Sum1'
         *  UnitDelay: '<S1888>/Unit Delay'
         */
        rtb_Summation_ep = ((KeESSR_n_EngStrtCoastDwnThres -
                             rtu_VeESSR_n_TransInSpdFlt) * HeESSR_t_MedTEB_dT) +
            localDW->UnitDelay_DSTATE_jv;

        /* Outputs for Atomic SubSystem: '<S1888>/Limiter' */
        /* Switch: '<S1897>/Switch1' incorporates:
         *  Constant: '<S1892>/Calib'
         *  RelationalOperator: '<S1897>/Relational Operator'
         */
        if (KeESSR_n_EngStrCoastDwnIntgrlVal < rtb_Summation_ep)
        {
            /* Switch: '<S1897>/Switch1' */
            rtb_Summation_ep = KeESSR_n_EngStrCoastDwnIntgrlVal;
        }

        /* End of Switch: '<S1897>/Switch1' */

        /* Switch: '<S1897>/Switch' incorporates:
         *  Constant: '<S1861>/Constant Value1'
         *  RelationalOperator: '<S1897>/Relational Operator1'
         */
        if (rtb_Summation_ep <= 0.0F)
        {
            /* Switch: '<S1888>/Switch1' */
            rtb_Summation_ep = 0.0F;
        }

        /* End of Switch: '<S1897>/Switch' */
        /* End of Outputs for SubSystem: '<S1888>/Limiter' */
    }

    /* End of Switch: '<S1888>/Switch1' */

    /* Update for UnitDelay: '<S1888>/Unit Delay' */
    localDW->UnitDelay_DSTATE_jv = rtb_Summation_ep;

    /* End of Outputs for SubSystem: '<S1861>/Accumulator Reset Limited' */

    /* RelationalOperator: '<S1861>/Comparison4' incorporates:
     *  Constant: '<S1892>/Calib'
     */
    VeESSR_b_StrtEngCoastDwnSpd = (rtb_Summation_ep ==
        KeESSR_n_EngStrCoastDwnIntgrlVal);

    /* Logic: '<S1861>/Logical Operator1' incorporates:
     *  Logic: '<S1861>/Logical Operator2'
     */
    VeESSR_b_StrEngBeltSlipCstDwn = ((rtb_RelationalOperator_guj ||
        (VeESSR_b_ActvBeltSlpCtrlAchvdStrtEng)) && (VeESSR_b_StrtEngCoastDwnSpd));

    /* Logic: '<S1863>/Logical Operator4' incorporates:
     *  Logic: '<S1855>/Logical13'
     */
    rtb_LogicalOperator4_n = (rtu_ErlyExitLmp || rtu_LwrThresLmp);

    /* Logic: '<S1855>/Logical15' */
    rtb_Logical15 = ((VeESSR_b_StrEngBeltSlipCstDwn) || rtb_LogicalOperator4_n);

    /* RelationalOperator: '<S1855>/Greater  Than1' incorporates:
     *  Constant: '<S1884>/Calib'
     *  DataStoreRead: '<S1855>/Dsr_STMTmr1'
     */
    rtb_GreaterThan1_cc = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmStartEng);

    /* Logic: '<S1855>/Logical5' incorporates:
     *  Constant: '<S1878>/Calib'
     *  Constant: '<S1879>/Calib'
     *  DataStoreRead: '<S1855>/Data Store Read1'
     *  Logic: '<S1855>/Logical2'
     *  Logic: '<S1855>/Logical3'
     *  Logic: '<S1855>/Logical8'
     */
    rtb_Logical5_b = (((!KeESSR_b_DsblEVStrtFailed_InPlant) ||
                       (!rtu_VeRTMR_b_InPlantMode)) &&
                      (((KeESSR_b_AllowEV_StrtFailed) ||
                        rtu_VeSTRR_b_BackupStrtEngOn) ||
                       (VeESSR_b_AStrtReattmptAllowed_DS)));

    /* Logic: '<S1863>/Logical Operator3' incorporates:
     *  Logic: '<S1855>/Logical1'
     *  Logic: '<S1855>/Logical11'
     *  Logic: '<S1855>/Logical12'
     */
    rtb_LogicalOperator3_m = ((rtb_Logical15 && rtb_GreaterThan1_cc) ||
        (rtb_GreaterThan1_cc && rtb_Logical5_b));

    /* Logic: '<S1855>/Logical16' incorporates:
     *  DataStoreWrite: '<S1855>/Dsw_AStrtFailed'
     */
    VeESSR_b_AStrtFailed_DS = ((VeESSR_b_StrEngBeltSlipCstDwn) ||
        rtb_LogicalOperator3_m);

    /* Switch: '<S1870>/Switch1' incorporates:
     *  Constant: '<S1855>/Constant Value3'
     *  DataStoreRead: '<S1855>/Dsr_STMTmr3'
     *  DataStoreWrite: '<S1855>/Dsw_AStrtFailed1'
     *  Logic: '<S1855>/Logical14'
     *  Logic: '<S1855>/Logical6'
     *  Sum: '<S1855>/Sum3'
     */
    if (rtb_LogicalOperator3_m && (!rtu_ErlyExitLmp))
    {
        VeESSR_Cnt_AStrtFailAttmptCntr_DS = (uint8)(((uint32)
            VeESSR_Cnt_AStrtFailAttmptCntr_DS) + 1U);
    }

    /* End of Switch: '<S1870>/Switch1' */

    /* RelationalOperator: '<S1855>/Greater  Than2' incorporates:
     *  Constant: '<S1877>/Calib'
     *  DataStoreWrite: '<S1855>/Dsw_AStrtFailed1'
     *  DataStoreWrite: '<S1855>/Dsw_AStrtFailed2'
     */
    VeESSR_b_AStrtReattmptAllowed_DS = (VeESSR_Cnt_AStrtFailAttmptCntr_DS <=
        KeESSR_Cnt_AStrtFailMaxAttmpts);

    /* Logic: '<S1855>/Logical10' incorporates:
     *  DataStoreWrite: '<S1855>/Dsw_AStrtFailed3'
     */
    VeESSR_b_BackUpStartEng_DS = ((rtb_LogicalOperator4_n ||
        rtu_VeSTRR_b_BumpStrtEngOn) || rtu_VeSTRR_b_BackupStrtEngOn);

    /* Switch: '<S1872>/Switch1' incorporates:
     *  Constant: '<S1880>/Calib'
     */
    rtb_Switch1_gw = ((KeESSR_b_EngCombCmd_Dsbl) ||
                      rtu_VeENGR_b_EngCombustionCmnd);

    /* Switch: '<S1855>/Switch1' incorporates:
     *  Constant: '<S1868>/Constant'
     *  DataStoreWrite: '<S1855>/Dsw_EngStrtType2'
     */
    if (rtb_Switch1_gw)
    {
        VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Startng;
    }

    /* End of Switch: '<S1855>/Switch1' */

    /* Switch: '<S1871>/Switch1' incorporates:
     *  Constant: '<S1881>/Calib'
     *  Constant: '<S1882>/Calib'
     *  Constant: '<S1885>/Calib'
     *  DataStoreRead: '<S1855>/Dsr_STMTmr'
     *  DataStoreWrite: '<S1855>/Dsw_InhibitShiftToMode'
     *  RelationalOperator: '<S1855>/Greater  Than'
     */
    if (VeESSR_t_STMTmr_DS < KeESSR_t_ShftInhbtStrtEngTm)
    {
        VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtStrtEngStrt;
    }
    else
    {
        VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtStrtEngEnd;
    }

    /* End of Switch: '<S1871>/Switch1' */

    /* DataStoreWrite: '<S1855>/Dsw_STMTmr' incorporates:
     *  Constant: '<S1869>/Calib'
     *  DataStoreRead: '<S1855>/Dsr_STMTmr'
     *  Sum: '<S1855>/Summation1'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Switch: '<S1863>/Switch' incorporates:
     *  Constant: '<S1907>/Calib'
     *  Constant: '<S1908>/Calib'
     *  DataStoreRead: '<S1863>/Dsr_STMTmr3'
     */
    if (VeESSR_b_EngReStrtAttmpt_DS)
    {
        rtb_Maximum2_a = KeESSR_M_MinEngReStrtTorqSnsd;
    }
    else
    {
        rtb_Maximum2_a = KeESSR_M_MinEngStrtTorqSnsd;
    }

    /* End of Switch: '<S1863>/Switch' */

    /* Logic: '<S1863>/Logical Operator3' incorporates:
     *  Abs: '<S1863>/Abs'
     *  Constant: '<S1906>/Calib'
     *  Logic: '<S1863>/Logical3'
     *  RelationalOperator: '<S1863>/Greater  Than1'
     *  RelationalOperator: '<S1863>/Relational Operator'
     *  Sum: '<S1863>/Add'
     */
    rtb_LogicalOperator3_m = ((fabsf(rtu_VeESSR_M_EngStrtTorqSnsd -
        rtu_VeETQR_M_EngTrqActual) < KeESSR_M_MaxEngTorqError) ||
        (rtu_VeESSR_M_EngStrtTorqSnsd > rtb_Maximum2_a));

    /* Outputs for Atomic SubSystem: '<S1863>/Signal Latch On With Reset' */
    /* Logic: '<S1913>/OR1' incorporates:
     *  Logic: '<S1863>/Logical4'
     *  Logic: '<S1913>/NOT'
     *  Logic: '<S1913>/OR'
     *  UnitDelay: '<S1913>/Unit Delay'
     */
    rtb_OR1_pe = ((rtb_LogicalOperator3_m && rtb_Switch1_gw) || ((!rtb_Equal2_o)
                   && (localDW->UnitDelay_DSTATE_mi)));

    /* Update for UnitDelay: '<S1913>/Unit Delay' */
    localDW->UnitDelay_DSTATE_mi = rtb_OR1_pe;

    /* End of Outputs for SubSystem: '<S1863>/Signal Latch On With Reset' */

    /* MinMax: '<S1855>/Maximum2' */
    rtb_Summation_ep = fmaxf(rtu_PNLimTrq, rtu_TactTiMin);

    /* Switch: '<S1867>/Switch7' incorporates:
     *  Constant: '<S1938>/Calib'
     */
    if (HeESSR_b_RampMinStartTorq)
    {
        /* Switch: '<S1867>/Switch7' incorporates:
         *  DataStoreRead: '<S1867>/Dsr_STMTmr9'
         *  Lookup_n-D: '<S1943>/Vector'
         */
        VeESSR_M_MinStartDetectTorq = look1_iflf_binlcapw(VeESSR_t_STMTmr_DS, ((
            const float32 *)&(KxESSR_M_MinStartDetectTorq[0])), ((const float32 *)
            &(KtESSR_M_MinStartDetectTorq[0])), 6U);
    }
    else
    {
        /* Switch: '<S1867>/Switch7' incorporates:
         *  Constant: '<S1942>/Calib'
         */
        VeESSR_M_MinStartDetectTorq = KeESSR_M_MinStartDetectTorq;
    }

    /* End of Switch: '<S1867>/Switch7' */

    /* Switch: '<S1867>/Switch6' incorporates:
     *  DataStoreRead: '<S1867>/Dsr_STMTmr8'
     */
    if (VeESSR_b_EngReStrtAttmpt_DS)
    {
        /* MinMax: '<S2009>/MinMax1' incorporates:
         *  Constant: '<S1941>/Calib'
         */
        rtb_MinMax_hj = KeESSR_M_MinReStartDetectTorq;
    }
    else
    {
        /* MinMax: '<S2009>/MinMax1' */
        rtb_MinMax_hj = VeESSR_M_MinStartDetectTorq;
    }

    /* End of Switch: '<S1867>/Switch6' */

    /* MinMax: '<S1867>/Maximum1' */
    rtb_Maximum1 = fmaxf(rtu_VeESSR_M_OptEngTrqReqPred, rtb_MinMax_hj);

    /* RelationalOperator: '<S1944>/Relational Operator' incorporates:
     *  DataStoreRead: '<S1867>/Data Store Read'
     */
    rtb_RelationalOperator_guj = (rtb_Maximum1 > VeESSR_M_EngTrqReqPrdtd_DS);

    /* MinMax: '<S1867>/Maximum2' */
    rtb_Maximum2_a = fmaxf(rtb_MinMax_hj, rtu_VeESSR_M_OptEngTrqReqImmed);

    /* Switch: '<S1944>/Switch1' incorporates:
     *  Switch: '<S1944>/Switch'
     */
    if (rtb_RelationalOperator_guj)
    {
        /* Switch: '<S1944>/Switch1' incorporates:
         *  Constant: '<S1944>/Constant Value1'
         */
        VeESSR_M_EngTrqReqPrdtdMin = -999.0F;

        /* Switch: '<S1944>/Switch' incorporates:
         *  MinMax: '<S1944>/MinMax'
         *  Product: '<S1944>/Product'
         *  Sum: '<S1944>/Summation3'
         *  Sum: '<S1944>/Summation4'
         */
        VeESSR_M_EngTrqReqPrdtdMax = fminf(((rtb_Maximum2_a +
            rtu_VeETQR_M_EngineLosses) * rtu_VeETQR_r_MaxSparkAuthority) -
            rtu_VeETQR_M_EngineLosses, rtb_Maximum1);
    }
    else
    {
        /* Switch: '<S1944>/Switch1' */
        VeESSR_M_EngTrqReqPrdtdMin = rtb_Maximum1;

        /* Switch: '<S1944>/Switch' incorporates:
         *  Constant: '<S1944>/Constant Value'
         */
        VeESSR_M_EngTrqReqPrdtdMax = 999.0F;
    }

    /* End of Switch: '<S1944>/Switch1' */

    /* If: '<S1864>/If1' */
    if (rtb_Switch1_gw)
    {
        /* Outputs for IfAction SubSystem: '<S1864>/ESSC_CombstDelay' incorporates:
         *  ActionPort: '<S1921>/Action Port'
         */
        ESSR_ac_ESSC_CombstDelay(&rtb_LogicalOperator4_n);

        /* End of Outputs for SubSystem: '<S1864>/ESSC_CombstDelay' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1864>/ESSC_CombstNoDelay' incorporates:
         *  ActionPort: '<S1922>/Action Port'
         */
        ESSR_ac_ESSC_CmbstnNoDelay(&rtb_LogicalOperator4_n);

        /* End of Outputs for SubSystem: '<S1864>/ESSC_CombstNoDelay' */
    }

    /* End of If: '<S1864>/If1' */

    /* Outputs for Atomic SubSystem: '<S1864>/Signal Latch On With Reset' */
    /* Logic: '<S1925>/OR1' incorporates:
     *  Constant: '<S1923>/Calib'
     *  DataStoreRead: '<S1864>/Dsr_STMTmr'
     *  Logic: '<S1864>/Logical3'
     *  Logic: '<S1925>/NOT'
     *  Logic: '<S1925>/OR'
     *  RelationalOperator: '<S1864>/Equal1'
     *  UnitDelay: '<S1925>/Unit Delay'
     */
    rtb_OR1_pw = ((rtb_LogicalOperator4_n || (VeESSR_t_STMTmr_DS >
                    KeESSR_t_FuelTmDelayHold)) || ((!rtb_Equal2_o) &&
                   (localDW->UnitDelay_DSTATE_fj)));

    /* Update for UnitDelay: '<S1925>/Unit Delay' */
    localDW->UnitDelay_DSTATE_fj = rtb_OR1_pw;

    /* End of Outputs for SubSystem: '<S1864>/Signal Latch On With Reset' */

    /* Logic: '<S1864>/Logical4' */
    rtb_LogicalOperator4_n = !rtb_OR1_pw;

    /* Switch: '<S1940>/Switch2' */
    if (rtb_LogicalOperator4_n)
    {
        /* MinMax: '<S1940>/MinMax' */
        rtb_MinMax_hj = fmaxf(rtu_VeETQR_M_EngCapacityMinRunI, rtu_ImmedCal);

        /* Switch: '<S1940>/Switch1' incorporates:
         *  RelationalOperator: '<S1940>/Relational Operator'
         */
        if (rtb_Maximum2_a <= rtb_MinMax_hj)
        {
            /* MinMax: '<S2009>/MinMax1' incorporates:
             *  MinMax: '<S1940>/MinMax1'
             *  Switch: '<S1940>/Switch1'
             */
            rtb_MinMax_hj = fminf(rtu_VeETQR_M_EngCapacityMinRunI, rtu_ImmedCal);
        }

        /* End of Switch: '<S1940>/Switch1' */
    }
    else
    {
        /* MinMax: '<S2009>/MinMax1' incorporates:
         *  DataStoreRead: '<S1867>/Data Store Read1'
         */
        rtb_MinMax_hj = VeESSR_M_EngTrqReqImmed_DS;
    }

    /* End of Switch: '<S1940>/Switch2' */

    /* Sum: '<S1867>/Sum2' */
    rtb_Sum2_jm = rtb_Maximum2_a - rtb_MinMax_hj;

    /* Outputs for Atomic SubSystem: '<S1867>/EngineTorqueCommands' */
#if Rte_SysCon_Variant_ESSR_BlueNexus

    /* Outputs for Atomic SubSystem: '<S1937>/BlueNexus' */
    /* UnitDelay: '<S1946>/Unit Delay1' incorporates:
     *  RelationalOperator: '<S1946>/Relational Operator1'
     */
    rtb_UnitDelay1 = (rtb_Maximum1 >= rtb_Summation_ep);

    /* Outputs for Atomic SubSystem: '<S1946>/Signal Latch On With Reset' */
    /* Logic: '<S1952>/OR1' incorporates:
     *  Logic: '<S1946>/Logical Operator'
     *  Logic: '<S1946>/Logical Operator1'
     *  Logic: '<S1952>/OR'
     *  RelationalOperator: '<S1946>/Relational Operator'
     *  UnitDelay: '<S1946>/Unit Delay'
     *  UnitDelay: '<S1952>/Unit Delay'
     */
    rtb_UnitDelay1 = (((rtb_Summation_ep == localDW->UnitDelay_DSTATE_g) &&
                       rtb_UnitDelay1) || (rtb_UnitDelay1 &&
                       (localDW->UnitDelay_DSTATE_jh)));

    /* Update for UnitDelay: '<S1952>/Unit Delay' */
    localDW->UnitDelay_DSTATE_jh = rtb_UnitDelay1;

    /* End of Outputs for SubSystem: '<S1946>/Signal Latch On With Reset' */

    /* Outputs for Atomic SubSystem: '<S1946>/Lowpass Second Order Enabled3' */
    /* MinMax: '<S1950>/MinMax' incorporates:
     *  Constant: '<S1950>/Constant3'
     */
    rtb_MinMax_bd = fmaxf(rtb_Sum2_jm, 0.0F);

    /* MinMax: '<S1950>/MinMax1' incorporates:
     *  Constant: '<S1950>/Constant1'
     */
    rtb_MinMax1_ow = fminf(rtb_Sum2_jm, 0.0F);

    /* UnitDelay: '<S1950>/yyk1' */
    rtb_yyk1_p = VeESSR_M_EngTrqReqImmedFltrOP;

    /* Switch: '<S1950>/Switch3' incorporates:
     *  Logic: '<S1946>/Logical Operator3'
     *  Logic: '<S1946>/Logical Operator4'
     *  RelationalOperator: '<S1946>/Relational Operator2'
     *  Switch: '<S1950>/Switch1'
     *  UnitDelay: '<S1946>/Unit Delay1'
     */
    if (rtb_LogicalOperator4_n || (rtu_PNLimActv != localDW->UnitDelay1_DSTATE))
    {
        /* Switch: '<S1950>/Switch3' */
        rtb_MinMax_hj = rtb_Sum2_jm;

        /* Switch: '<S1950>/Switch1' */
        rtb_Multiplication1_gld = rtb_Sum2_jm;
    }
    else
    {
        /* Switch: '<S1950>/Switch3' incorporates:
         *  UnitDelay: '<S1950>/yyk1'
         */
        rtb_MinMax_hj = VeESSR_M_EngTrqReqImmedFltrOP;

        /* Product: '<S1950>/Multiplication1' incorporates:
         *  Constant: '<S1939>/Calib'
         *  DataStoreRead: '<S1946>/Dsr_StrtTypInitImmedTorq1'
         *  MinMax: '<S1950>/Maximum'
         */
        rtb_Multiplication1_gld = (1.0F / fmaxf
            (VeESSR_k_StrtTypEngTorqReqFltT_DS, HeESSR_t_MedTEB_dT)) *
            HeESSR_t_MedTEB_dT;

        /* Switch: '<S1950>/Switch1' incorporates:
         *  Constant: '<S1946>/Constant Value'
         *  DataStoreRead: '<S1946>/Dsr_StrtTypInitImmedTorq7'
         *  Gain: '<S1950>/Gain'
         *  Gain: '<S1950>/Gain1'
         *  Math: '<S1950>/Square'
         *  Product: '<S1950>/Multiplication2'
         *  Product: '<S1950>/Multiplication3'
         *  Sum: '<S1950>/Subtraction'
         *  Sum: '<S1950>/Subtraction1'
         *  Sum: '<S1950>/Summation'
         *  UnitDelay: '<S1950>/yyk1'
         *  UnitDelay: '<S1950>/yyk2'
         */
        rtb_Multiplication1_gld = (((((localDW->yyk2_DSTATE_p -
            VeESSR_M_EngTrqReqImmedFltrOP) * (2.0F *
            VeESSR_k_StrtTypEngTorqReqImmedFltD_DS)) * rtb_Multiplication1_gld)
            + ((rtb_Multiplication1_gld * rtb_Multiplication1_gld) * (0.0F -
            localDW->yyk2_DSTATE_p))) - localDW->yyk2_DSTATE_p) + (2.0F *
            VeESSR_M_EngTrqReqImmedFltrOP);
    }

    /* End of Switch: '<S1950>/Switch3' */

    /* Outputs for Atomic SubSystem: '<S1950>/Limiter3' */
    /* Switch: '<S1953>/Switch1' incorporates:
     *  RelationalOperator: '<S1953>/Relational Operator'
     */
    if (rtb_MinMax_bd >= rtb_Multiplication1_gld)
    {
        /* Switch: '<S1955>/Switch1' */
        rtb_MinMax_bd = rtb_Multiplication1_gld;
    }

    /* End of Switch: '<S1953>/Switch1' */

    /* Switch: '<S1953>/Switch' incorporates:
     *  RelationalOperator: '<S1953>/Relational Operator1'
     */
    if (rtb_MinMax_bd > rtb_MinMax1_ow)
    {
        /* Switch: '<S1953>/Switch' */
        VeESSR_M_EngTrqReqImmedFltrOP = rtb_MinMax_bd;
    }
    else
    {
        /* Switch: '<S1953>/Switch' */
        VeESSR_M_EngTrqReqImmedFltrOP = rtb_MinMax1_ow;
    }

    /* End of Switch: '<S1953>/Switch' */
    /* End of Outputs for SubSystem: '<S1950>/Limiter3' */

    /* Switch: '<S1950>/Switch6' incorporates:
     *  RelationalOperator: '<S1950>/Comparison5'
     */
    if (VeESSR_M_EngTrqReqImmedFltrOP != rtb_Multiplication1_gld)
    {
        /* Update for UnitDelay: '<S1950>/yyk2' incorporates:
         *  Product: '<S1950>/Multiplication4'
         *  Product: '<S1950>/Multiplication5'
         *  Switch: '<S1950>/Switch6'
         */
        localDW->yyk2_DSTATE_p = (localDW->yyk2_DSTATE_p / rtb_yyk1_p) *
            VeESSR_M_EngTrqReqImmedFltrOP;
    }
    else
    {
        /* Update for UnitDelay: '<S1950>/yyk2' incorporates:
         *  Switch: '<S1950>/Switch6'
         */
        localDW->yyk2_DSTATE_p = rtb_MinMax_hj;
    }

    /* End of Switch: '<S1950>/Switch6' */
    /* End of Outputs for SubSystem: '<S1946>/Lowpass Second Order Enabled3' */

    /* Switch: '<S1946>/Switch2' incorporates:
     *  Logic: '<S1946>/Logical Operator2'
     */
    if (rtb_UnitDelay1 && rtu_PNLimActv)
    {
        /* Switch: '<S1946>/Switch2' */
        rtb_yyk1_p = rtb_Summation_ep;
    }
    else
    {
        /* Switch: '<S1946>/Switch2' */
        rtb_yyk1_p = VeESSR_M_EngTrqReqPrdtdMin;
    }

    /* End of Switch: '<S1946>/Switch2' */

    /* Switch: '<S1946>/Switch' */
    if (rtu_PNLimActv)
    {
        /* Switch: '<S1946>/Switch' */
        rtb_MinMax_hj = rtb_Summation_ep;
    }
    else
    {
        /* Switch: '<S1946>/Switch' */
        rtb_MinMax_hj = VeESSR_M_EngTrqReqPrdtdMax;
    }

    /* End of Switch: '<S1946>/Switch' */

    /* Outputs for Atomic SubSystem: '<S1946>/Lowpass Second Order Enabled4' */
    /* Delay: '<S1951>/Delay' incorporates:
     *  UnitDelay: '<S1951>/Unit Delay'
     */
    if ((((sint32)((((uint32)localZCE->Delay_Reset_ZCE_j) == POS_ZCSIG) ? 1 : 0))
         != ((sint32)(rtb_RelationalOperator_guj ? 1 : 0))) && (((uint32)
            localZCE->Delay_Reset_ZCE_j) != UNINITIALIZED_ZCSIG))
    {
        localDW->icLoad_k = 1U;
    }

    localZCE->Delay_Reset_ZCE_j = rtb_RelationalOperator_guj ? ((ZCSigState)1) :
        ((ZCSigState)0);
    if (((sint32)localDW->icLoad_k) != 0)
    {
        localDW->Delay_DSTATE_p = localDW->UnitDelay_DSTATE_ow;
    }

    /* Delay: '<S1951>/Delay1' incorporates:
     *  UnitDelay: '<S1951>/Unit Delay'
     */
    if ((((sint32)((((uint32)localZCE->Delay1_Reset_ZCE_n) == POS_ZCSIG) ? 1 : 0))
         != ((sint32)(rtb_RelationalOperator_guj ? 1 : 0))) && (((uint32)
            localZCE->Delay1_Reset_ZCE_n) != UNINITIALIZED_ZCSIG))
    {
        localDW->icLoad_n = 1U;
    }

    localZCE->Delay1_Reset_ZCE_n = rtb_RelationalOperator_guj ? ((ZCSigState)1) :
        ((ZCSigState)0);
    if (((sint32)localDW->icLoad_n) != 0)
    {
        localDW->Delay1_DSTATE_f = localDW->UnitDelay_DSTATE_ow;
    }

    /* Outputs for Atomic SubSystem: '<S1951>/Limiter4' */
    /* Switch: '<S1956>/Switch1' incorporates:
     *  Delay: '<S1951>/Delay'
     *  RelationalOperator: '<S1956>/Relational Operator'
     */
    if (rtb_MinMax_hj < localDW->Delay_DSTATE_p)
    {
        /* Switch: '<S1955>/Switch1' */
        rtb_MinMax_bd = rtb_MinMax_hj;
    }
    else
    {
        /* Switch: '<S1955>/Switch1' */
        rtb_MinMax_bd = localDW->Delay_DSTATE_p;
    }

    /* End of Switch: '<S1956>/Switch1' */
    /* End of Outputs for SubSystem: '<S1951>/Limiter4' */

    /* Switch: '<S1951>/Switch3' incorporates:
     *  RelationalOperator: '<S1956>/Relational Operator1'
     *  Switch: '<S1951>/Switch1'
     *  Switch: '<S1956>/Switch'
     */
    if (rtb_Equal2_o)
    {
        /* Switch: '<S1951>/Switch3' incorporates:
         *  DataStoreRead: '<S1867>/Data Store Read'
         */
        rtb_MinMax1_ow = VeESSR_M_EngTrqReqPrdtd_DS;

        /* Switch: '<S1951>/Switch1' incorporates:
         *  DataStoreRead: '<S1867>/Data Store Read'
         */
        rtb_MinMax_bd = VeESSR_M_EngTrqReqPrdtd_DS;
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S1951>/Limiter4' */
        if (rtb_MinMax_bd > rtb_yyk1_p)
        {
            /* Switch: '<S1956>/Switch' incorporates:
             *  Switch: '<S1951>/Switch3'
             */
            rtb_MinMax1_ow = rtb_MinMax_bd;
        }
        else
        {
            /* Switch: '<S1951>/Switch3' incorporates:
             *  Switch: '<S1956>/Switch'
             */
            rtb_MinMax1_ow = rtb_yyk1_p;
        }

        /* End of Outputs for SubSystem: '<S1951>/Limiter4' */

        /* Outputs for Atomic SubSystem: '<S1951>/Limiter1' */
        /* Switch: '<S1954>/Switch1' incorporates:
         *  Delay: '<S1951>/Delay1'
         *  RelationalOperator: '<S1954>/Relational Operator'
         */
        if (rtb_MinMax_hj < localDW->Delay1_DSTATE_f)
        {
            /* Product: '<S1951>/Multiplication1' */
            rtb_MinMax_bd = rtb_MinMax_hj;
        }
        else
        {
            /* Product: '<S1951>/Multiplication1' */
            rtb_MinMax_bd = localDW->Delay1_DSTATE_f;
        }

        /* End of Switch: '<S1954>/Switch1' */

        /* Switch: '<S1954>/Switch' incorporates:
         *  RelationalOperator: '<S1954>/Relational Operator1'
         */
        if (rtb_MinMax_bd > rtb_yyk1_p)
        {
            /* Switch: '<S1954>/Switch' */
            rtb_Multiplication1_gld = rtb_MinMax_bd;
        }
        else
        {
            /* Switch: '<S1954>/Switch' */
            rtb_Multiplication1_gld = rtb_yyk1_p;
        }

        /* End of Switch: '<S1954>/Switch' */
        /* End of Outputs for SubSystem: '<S1951>/Limiter1' */

        /* Product: '<S1951>/Multiplication1' incorporates:
         *  Constant: '<S1939>/Calib'
         *  Constant: '<S1949>/Calib'
         *  DataStoreRead: '<S1946>/Dsr_StrtTypInitImmedTorq1'
         *  MinMax: '<S1951>/Maximum'
         *  Product: '<S1946>/Product2'
         */
        rtb_MinMax_bd = (1.0F / fmaxf(KeESSR_K_StartEngTiPredCoefMult *
                          VeESSR_k_StrtTypEngTorqReqFltT_DS, HeESSR_t_MedTEB_dT))
            * HeESSR_t_MedTEB_dT;

        /* Switch: '<S1951>/Switch1' incorporates:
         *  DataStoreRead: '<S1946>/Dsr_StrtTypInitImmedTorq7'
         *  Gain: '<S1951>/Gain'
         *  Gain: '<S1951>/Gain1'
         *  Math: '<S1951>/Square'
         *  Product: '<S1951>/Multiplication2'
         *  Product: '<S1951>/Multiplication3'
         *  Sum: '<S1951>/Subtraction'
         *  Sum: '<S1951>/Subtraction1'
         *  Sum: '<S1951>/Summation'
         */
        rtb_MinMax_bd = (((((rtb_Multiplication1_gld - rtb_MinMax1_ow) * (2.0F *
                             VeESSR_k_StrtTypEngTorqReqImmedFltD_DS)) *
                           rtb_MinMax_bd) + ((rtb_MinMax_bd * rtb_MinMax_bd) *
                           (rtb_Maximum1 - rtb_Multiplication1_gld))) -
                         rtb_Multiplication1_gld) + (2.0F * rtb_MinMax1_ow);
    }

    /* End of Switch: '<S1951>/Switch3' */

    /* Outputs for Atomic SubSystem: '<S1951>/Limiter3' */
    /* Switch: '<S1955>/Switch1' incorporates:
     *  RelationalOperator: '<S1955>/Relational Operator'
     */
    if (rtb_MinMax_hj < rtb_MinMax_bd)
    {
        /* Switch: '<S1955>/Switch1' */
        rtb_MinMax_bd = rtb_MinMax_hj;
    }

    /* End of Switch: '<S1955>/Switch1' */

    /* Switch: '<S1955>/Switch' incorporates:
     *  RelationalOperator: '<S1955>/Relational Operator1'
     */
    if (rtb_MinMax_bd <= rtb_yyk1_p)
    {
        /* VariantMerge generated from: '<S1937>/EngTrqReqPred' */
        rtb_MinMax_bd = rtb_yyk1_p;
    }

    /* End of Switch: '<S1955>/Switch' */
    /* End of Outputs for SubSystem: '<S1951>/Limiter3' */

    /* Update for UnitDelay: '<S1951>/Unit Delay' */
    localDW->UnitDelay_DSTATE_ow = rtb_MinMax_bd;

    /* Update for Delay: '<S1951>/Delay' */
    localDW->icLoad_k = 0U;
    localDW->Delay_DSTATE_p = rtb_MinMax_bd;

    /* Update for Delay: '<S1951>/Delay1' */
    localDW->icLoad_n = 0U;
    localDW->Delay1_DSTATE_f = rtb_MinMax1_ow;

    /* End of Outputs for SubSystem: '<S1946>/Lowpass Second Order Enabled4' */

    /* Switch: '<S1946>/Switch1' */
    if (rtu_PNLimActv)
    {
        /* VariantMerge generated from: '<S1937>/EngTrqReqImmed' incorporates:
         *  MinMax: '<S1946>/Maximum5'
         *  Sum: '<S1946>/Sum1'
         */
        rtb_MinMax1_ow = fminf(rtb_Summation_ep, rtb_Maximum2_a -
                               VeESSR_M_EngTrqReqImmedFltrOP);
    }
    else
    {
        /* VariantMerge generated from: '<S1937>/EngTrqReqImmed' incorporates:
         *  Sum: '<S1946>/Sum1'
         */
        rtb_MinMax1_ow = rtb_Maximum2_a - VeESSR_M_EngTrqReqImmedFltrOP;
    }

    /* End of Switch: '<S1946>/Switch1' */

    /* Update for UnitDelay: '<S1946>/Unit Delay' */
    localDW->UnitDelay_DSTATE_g = rtb_MinMax_bd;

    /* Update for UnitDelay: '<S1946>/Unit Delay1' */
    localDW->UnitDelay1_DSTATE = rtu_PNLimActv;

    /* End of Outputs for SubSystem: '<S1937>/BlueNexus' */
#elif Rte_SysCon_Variant_ESSR_LQIR

    /* Outputs for Atomic SubSystem: '<S1937>/LQIR' */
    /* Outputs for Atomic SubSystem: '<S1948>/Lowpass Second Order Enabled4' */
    /* Delay: '<S1967>/Delay' incorporates:
     *  UnitDelay: '<S1967>/Unit Delay'
     */
    if ((((sint32)((((uint32)localZCE->Delay_Reset_ZCE) == POS_ZCSIG) ? 1 : 0))
            != ((sint32)(rtb_RelationalOperator_guj ? 1 : 0))) && (((uint32)
            localZCE->Delay_Reset_ZCE) != UNINITIALIZED_ZCSIG))
    {
        localDW->icLoad_d = 1U;
    }

    localZCE->Delay_Reset_ZCE = rtb_RelationalOperator_guj ? ((ZCSigState)1) :
        ((ZCSigState)0);
    if (((sint32)localDW->icLoad_d) != 0)
    {
        localDW->Delay_DSTATE = localDW->UnitDelay_DSTATE_o;
    }

    /* Delay: '<S1967>/Delay1' incorporates:
     *  UnitDelay: '<S1967>/Unit Delay'
     */
    if ((((sint32)((((uint32)localZCE->Delay1_Reset_ZCE) == POS_ZCSIG) ? 1 : 0))
         != ((sint32)(rtb_RelationalOperator_guj ? 1 : 0))) && (((uint32)
            localZCE->Delay1_Reset_ZCE) != UNINITIALIZED_ZCSIG))
    {
        localDW->icLoad_m = 1U;
    }

    localZCE->Delay1_Reset_ZCE = rtb_RelationalOperator_guj ? ((ZCSigState)1) :
        ((ZCSigState)0);
    if (((sint32)localDW->icLoad_m) != 0)
    {
        localDW->Delay1_DSTATE = localDW->UnitDelay_DSTATE_o;
    }

    /* Outputs for Atomic SubSystem: '<S1967>/Limiter4' */
    /* Switch: '<S1971>/Switch1' incorporates:
     *  Delay: '<S1967>/Delay'
     *  RelationalOperator: '<S1971>/Relational Operator'
     */
    if (VeESSR_M_EngTrqReqPrdtdMax < localDW->Delay_DSTATE)
    {
        /* Switch: '<S1970>/Switch1' */
        rtb_MinMax1_ow = VeESSR_M_EngTrqReqPrdtdMax;
    }
    else
    {
        /* Switch: '<S1970>/Switch1' */
        rtb_MinMax1_ow = localDW->Delay_DSTATE;
    }

    /* End of Switch: '<S1971>/Switch1' */
    /* End of Outputs for SubSystem: '<S1967>/Limiter4' */

    /* Switch: '<S1967>/Switch3' incorporates:
     *  RelationalOperator: '<S1971>/Relational Operator1'
     *  Switch: '<S1967>/Switch1'
     *  Switch: '<S1971>/Switch'
     */
    if (rtb_Equal2_o)
    {
        /* Switch: '<S1967>/Switch3' incorporates:
         *  DataStoreRead: '<S1867>/Data Store Read'
         */
        rtb_MinMax_bd = VeESSR_M_EngTrqReqPrdtd_DS;

        /* Switch: '<S1967>/Switch1' incorporates:
         *  DataStoreRead: '<S1867>/Data Store Read'
         */
        rtb_MinMax1_ow = VeESSR_M_EngTrqReqPrdtd_DS;
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S1967>/Limiter4' */
        if (rtb_MinMax1_ow > VeESSR_M_EngTrqReqPrdtdMin)
        {
            /* Switch: '<S1971>/Switch' incorporates:
             *  Switch: '<S1967>/Switch3'
             */
            rtb_MinMax_bd = rtb_MinMax1_ow;
        }
        else
        {
            /* Switch: '<S1967>/Switch3' incorporates:
             *  Switch: '<S1971>/Switch'
             */
            rtb_MinMax_bd = VeESSR_M_EngTrqReqPrdtdMin;
        }

        /* End of Outputs for SubSystem: '<S1967>/Limiter4' */

        /* Outputs for Atomic SubSystem: '<S1967>/Limiter1' */
        /* Switch: '<S1969>/Switch1' incorporates:
         *  Delay: '<S1967>/Delay1'
         *  RelationalOperator: '<S1969>/Relational Operator'
         */
        if (VeESSR_M_EngTrqReqPrdtdMax < localDW->Delay1_DSTATE)
        {
            /* Product: '<S1967>/Multiplication1' */
            rtb_MinMax1_ow = VeESSR_M_EngTrqReqPrdtdMax;
        }
        else
        {
            /* Product: '<S1967>/Multiplication1' */
            rtb_MinMax1_ow = localDW->Delay1_DSTATE;
        }

        /* End of Switch: '<S1969>/Switch1' */

        /* Switch: '<S1969>/Switch' incorporates:
         *  RelationalOperator: '<S1969>/Relational Operator1'
         */
        if (rtb_MinMax1_ow > VeESSR_M_EngTrqReqPrdtdMin)
        {
            /* Switch: '<S1969>/Switch' */
            rtb_yyk1_p = rtb_MinMax1_ow;
        }
        else
        {
            /* Switch: '<S1969>/Switch' */
            rtb_yyk1_p = VeESSR_M_EngTrqReqPrdtdMin;
        }

        /* End of Switch: '<S1969>/Switch' */
        /* End of Outputs for SubSystem: '<S1967>/Limiter1' */

        /* Product: '<S1967>/Multiplication1' incorporates:
         *  Constant: '<S1939>/Calib'
         *  Constant: '<S1966>/Calib'
         *  MinMax: '<S1967>/Maximum'
         */
        rtb_MinMax1_ow = (1.0F / fmaxf(KeESSR_k_LQRStartEngTiFltT,
                           HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT;

        /* Switch: '<S1967>/Switch1' incorporates:
         *  Constant: '<S1965>/Calib'
         *  Gain: '<S1967>/Gain'
         *  Gain: '<S1967>/Gain1'
         *  Math: '<S1967>/Square'
         *  Product: '<S1967>/Multiplication2'
         *  Product: '<S1967>/Multiplication3'
         *  Sum: '<S1967>/Subtraction'
         *  Sum: '<S1967>/Subtraction1'
         *  Sum: '<S1967>/Summation'
         */
        rtb_MinMax1_ow = (((((rtb_yyk1_p - rtb_MinMax_bd) * (2.0F *
                              KeESSR_k_LQRStartEngTiFltD)) * rtb_MinMax1_ow) +
                           ((rtb_MinMax1_ow * rtb_MinMax1_ow) * (rtb_Maximum1 -
                             rtb_yyk1_p))) - rtb_yyk1_p) + (2.0F * rtb_MinMax_bd);
    }

    /* End of Switch: '<S1967>/Switch3' */

    /* Outputs for Atomic SubSystem: '<S1967>/Limiter3' */
    /* Switch: '<S1970>/Switch1' incorporates:
     *  RelationalOperator: '<S1970>/Relational Operator'
     */
    if (VeESSR_M_EngTrqReqPrdtdMax < rtb_MinMax1_ow)
    {
        /* Switch: '<S1970>/Switch1' */
        rtb_MinMax1_ow = VeESSR_M_EngTrqReqPrdtdMax;
    }

    /* End of Switch: '<S1970>/Switch1' */

    /* Switch: '<S1970>/Switch' incorporates:
     *  RelationalOperator: '<S1970>/Relational Operator1'
     */
    if (rtb_MinMax1_ow > VeESSR_M_EngTrqReqPrdtdMin)
    {
        /* Switch: '<S1970>/Switch' */
        rtb_yyk1_p = rtb_MinMax1_ow;
    }
    else
    {
        /* Switch: '<S1970>/Switch' */
        rtb_yyk1_p = VeESSR_M_EngTrqReqPrdtdMin;
    }

    /* End of Switch: '<S1970>/Switch' */
    /* End of Outputs for SubSystem: '<S1967>/Limiter3' */

    /* Update for UnitDelay: '<S1967>/Unit Delay' */
    localDW->UnitDelay_DSTATE_o = rtb_yyk1_p;

    /* Update for Delay: '<S1967>/Delay' */
    localDW->icLoad_d = 0U;
    localDW->Delay_DSTATE = rtb_yyk1_p;

    /* Update for Delay: '<S1967>/Delay1' */
    localDW->icLoad_m = 0U;
    localDW->Delay1_DSTATE = rtb_MinMax_bd;

    /* End of Outputs for SubSystem: '<S1948>/Lowpass Second Order Enabled4' */

    /* Outputs for Atomic SubSystem: '<S1948>/Signal Latch On With Reset' */
    /* Logic: '<S1968>/OR1' incorporates:
     *  Constant: '<S1964>/Constant'
     *  Logic: '<S1968>/NOT'
     *  Logic: '<S1968>/OR'
     *  RelationalOperator: '<S1948>/Relational Operator'
     *  UnitDelay: '<S1968>/Unit Delay'
     */
    rtb_UnitDelay1 = ((((uint32)rtu_VeENGR_e_ETRQ_Mode) == CeENGR_e_Idle) ||
                      ((!rtb_Equal2_o) && (localDW->UnitDelay_DSTATE_p)));

    /* Update for UnitDelay: '<S1968>/Unit Delay' */
    localDW->UnitDelay_DSTATE_p = rtb_UnitDelay1;

    /* End of Outputs for SubSystem: '<S1948>/Signal Latch On With Reset' */

    /* Switch: '<S1948>/Switch1' incorporates:
     *  Switch: '<S1948>/Switch14'
     */
    if (rtb_UnitDelay1)
    {
        /* VariantMerge generated from: '<S1937>/EngTrqReqImmed' */
        rtb_MinMax1_ow = rtb_Maximum2_a;

        /* VariantMerge generated from: '<S1937>/EngTrqReqPred' */
        rtb_MinMax_bd = rtb_yyk1_p;
    }
    else
    {
        /* VariantMerge generated from: '<S1937>/EngTrqReqImmed' */
        rtb_MinMax1_ow = rtu_ImmedCal;

        /* VariantMerge generated from: '<S1937>/EngTrqReqPred' incorporates:
         *  DataStoreRead: '<S1867>/Data Store Read'
         */
        rtb_MinMax_bd = VeESSR_M_EngTrqReqPrdtd_DS;
    }

    /* End of Switch: '<S1948>/Switch1' */
    /* End of Outputs for SubSystem: '<S1937>/LQIR' */
#else

    /* Outputs for Atomic SubSystem: '<S1937>/Default' */
    /* Outputs for Atomic SubSystem: '<S1947>/Lowpass Second Order Enabled3' */
    /* MinMax: '<S1958>/MinMax' incorporates:
     *  Constant: '<S1958>/Constant3'
     */
    rtb_MinMax_hj = fmaxf(rtb_Sum2_jm, 0.0F);

    /* MinMax: '<S1958>/MinMax1' incorporates:
     *  Constant: '<S1958>/Constant1'
     */
    rtb_MinMax_bd = fminf(rtb_Sum2_jm, 0.0F);

    /* UnitDelay: '<S1958>/yyk1' */
    rtb_MinMax1_ow = VeESSR_M_EngTrqReqImmedFltrOP;

    /* Switch: '<S1958>/Switch3' incorporates:
     *  Switch: '<S1958>/Switch1'
     */
    if (rtb_LogicalOperator4_n)
    {
        /* Switch: '<S1958>/Switch3' */
        rtb_yyk1_p = rtb_Sum2_jm;
    }
    else
    {
        /* Switch: '<S1958>/Switch3' incorporates:
         *  UnitDelay: '<S1958>/yyk1'
         */
        rtb_yyk1_p = VeESSR_M_EngTrqReqImmedFltrOP;

        /* Product: '<S1958>/Multiplication1' incorporates:
         *  Constant: '<S1939>/Calib'
         *  DataStoreRead: '<S1947>/Dsr_StrtTypInitImmedTorq2'
         *  MinMax: '<S1958>/Maximum'
         */
        rtb_Sum2_jm = (1.0F / fmaxf(VeESSR_k_StrtTypEngTorqReqFltT_DS,
                        HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT;

        /* Switch: '<S1958>/Switch1' incorporates:
         *  Constant: '<S1947>/Constant Value'
         *  DataStoreRead: '<S1947>/Dsr_StrtTypInitImmedTorq7'
         *  Gain: '<S1958>/Gain'
         *  Gain: '<S1958>/Gain1'
         *  Math: '<S1958>/Square'
         *  Product: '<S1958>/Multiplication2'
         *  Product: '<S1958>/Multiplication3'
         *  Sum: '<S1958>/Subtraction'
         *  Sum: '<S1958>/Subtraction1'
         *  Sum: '<S1958>/Summation'
         *  UnitDelay: '<S1958>/yyk1'
         *  UnitDelay: '<S1958>/yyk2'
         */
        rtb_Sum2_jm = (((((localDW->yyk2_DSTATE - VeESSR_M_EngTrqReqImmedFltrOP)
                          * (2.0F * VeESSR_k_StrtTypEngTorqReqImmedFltD_DS)) *
                         rtb_Sum2_jm) + ((rtb_Sum2_jm * rtb_Sum2_jm) * (0.0F -
                          localDW->yyk2_DSTATE))) - localDW->yyk2_DSTATE) +
            (2.0F * VeESSR_M_EngTrqReqImmedFltrOP);
    }

    /* End of Switch: '<S1958>/Switch3' */

    /* Outputs for Atomic SubSystem: '<S1958>/Limiter3' */
    /* Switch: '<S1960>/Switch1' incorporates:
     *  RelationalOperator: '<S1960>/Relational Operator'
     */
    if (rtb_MinMax_hj >= rtb_Sum2_jm)
    {
        /* Switch: '<S1962>/Switch1' */
        rtb_MinMax_hj = rtb_Sum2_jm;
    }

    /* End of Switch: '<S1960>/Switch1' */

    /* Switch: '<S1960>/Switch' incorporates:
     *  RelationalOperator: '<S1960>/Relational Operator1'
     */
    if (rtb_MinMax_hj > rtb_MinMax_bd)
    {
        /* Switch: '<S1960>/Switch' */
        VeESSR_M_EngTrqReqImmedFltrOP = rtb_MinMax_hj;
    }
    else
    {
        /* Switch: '<S1960>/Switch' */
        VeESSR_M_EngTrqReqImmedFltrOP = rtb_MinMax_bd;
    }

    /* End of Switch: '<S1960>/Switch' */
    /* End of Outputs for SubSystem: '<S1958>/Limiter3' */

    /* Switch: '<S1958>/Switch6' incorporates:
     *  RelationalOperator: '<S1958>/Comparison5'
     */
    if (VeESSR_M_EngTrqReqImmedFltrOP != rtb_Sum2_jm)
    {
        /* Update for UnitDelay: '<S1958>/yyk2' incorporates:
         *  Product: '<S1958>/Multiplication4'
         *  Product: '<S1958>/Multiplication5'
         *  Switch: '<S1958>/Switch6'
         */
        localDW->yyk2_DSTATE = (localDW->yyk2_DSTATE / rtb_MinMax1_ow) *
            VeESSR_M_EngTrqReqImmedFltrOP;
    }
    else
    {
        /* Update for UnitDelay: '<S1958>/yyk2' incorporates:
         *  Switch: '<S1958>/Switch6'
         */
        localDW->yyk2_DSTATE = rtb_yyk1_p;
    }

    /* End of Switch: '<S1958>/Switch6' */
    /* End of Outputs for SubSystem: '<S1947>/Lowpass Second Order Enabled3' */

    /* Outputs for Atomic SubSystem: '<S1947>/Lowpass Second Order Enabled4' */
    /* Delay: '<S1959>/Delay' incorporates:
     *  UnitDelay: '<S1959>/Unit Delay'
     */
    if ((((sint32)((((uint32)localZCE->Delay_Reset_ZCE_k) == POS_ZCSIG) ? 1 : 0))
         != ((sint32)(rtb_RelationalOperator_guj ? 1 : 0))) && (((uint32)
            localZCE->Delay_Reset_ZCE_k) != UNINITIALIZED_ZCSIG))
    {
        localDW->icLoad_g = 1U;
    }

    localZCE->Delay_Reset_ZCE_k = rtb_RelationalOperator_guj ? ((ZCSigState)1) :
        ((ZCSigState)0);
    if (((sint32)localDW->icLoad_g) != 0)
    {
        localDW->Delay_DSTATE_i = localDW->UnitDelay_DSTATE_j;
    }

    /* Delay: '<S1959>/Delay1' incorporates:
     *  UnitDelay: '<S1959>/Unit Delay'
     */
    if ((((sint32)((((uint32)localZCE->Delay1_Reset_ZCE_c) == POS_ZCSIG) ? 1 : 0))
         != ((sint32)(rtb_RelationalOperator_guj ? 1 : 0))) && (((uint32)
            localZCE->Delay1_Reset_ZCE_c) != UNINITIALIZED_ZCSIG))
    {
        localDW->icLoad_mp = 1U;
    }

    localZCE->Delay1_Reset_ZCE_c = rtb_RelationalOperator_guj ? ((ZCSigState)1) :
        ((ZCSigState)0);
    if (((sint32)localDW->icLoad_mp) != 0)
    {
        localDW->Delay1_DSTATE_a = localDW->UnitDelay_DSTATE_j;
    }

    /* Outputs for Atomic SubSystem: '<S1959>/Limiter4' */
    /* Switch: '<S1963>/Switch1' incorporates:
     *  Delay: '<S1959>/Delay'
     *  RelationalOperator: '<S1963>/Relational Operator'
     */
    if (VeESSR_M_EngTrqReqPrdtdMax < localDW->Delay_DSTATE_i)
    {
        /* Switch: '<S1962>/Switch1' */
        rtb_MinMax_hj = VeESSR_M_EngTrqReqPrdtdMax;
    }
    else
    {
        /* Switch: '<S1962>/Switch1' */
        rtb_MinMax_hj = localDW->Delay_DSTATE_i;
    }

    /* End of Switch: '<S1963>/Switch1' */
    /* End of Outputs for SubSystem: '<S1959>/Limiter4' */

    /* Switch: '<S1959>/Switch3' incorporates:
     *  RelationalOperator: '<S1963>/Relational Operator1'
     *  Switch: '<S1959>/Switch1'
     *  Switch: '<S1963>/Switch'
     */
    if (rtb_Equal2_o)
    {
        /* Switch: '<S1959>/Switch3' incorporates:
         *  DataStoreRead: '<S1867>/Data Store Read'
         */
        rtb_Sum2_jm = VeESSR_M_EngTrqReqPrdtd_DS;

        /* Switch: '<S1959>/Switch1' incorporates:
         *  DataStoreRead: '<S1867>/Data Store Read'
         */
        rtb_Maximum1 = VeESSR_M_EngTrqReqPrdtd_DS;
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S1959>/Limiter4' */
        if (rtb_MinMax_hj > VeESSR_M_EngTrqReqPrdtdMin)
        {
            /* Switch: '<S1963>/Switch' incorporates:
             *  Switch: '<S1959>/Switch3'
             */
            rtb_Sum2_jm = rtb_MinMax_hj;
        }
        else
        {
            /* Switch: '<S1959>/Switch3' incorporates:
             *  Switch: '<S1963>/Switch'
             */
            rtb_Sum2_jm = VeESSR_M_EngTrqReqPrdtdMin;
        }

        /* End of Outputs for SubSystem: '<S1959>/Limiter4' */

        /* Outputs for Atomic SubSystem: '<S1959>/Limiter1' */
        /* Switch: '<S1961>/Switch1' incorporates:
         *  Delay: '<S1959>/Delay1'
         *  RelationalOperator: '<S1961>/Relational Operator'
         */
        if (VeESSR_M_EngTrqReqPrdtdMax < localDW->Delay1_DSTATE_a)
        {
            /* Product: '<S1959>/Multiplication1' */
            rtb_MinMax_bd = VeESSR_M_EngTrqReqPrdtdMax;
        }
        else
        {
            /* Product: '<S1959>/Multiplication1' */
            rtb_MinMax_bd = localDW->Delay1_DSTATE_a;
        }

        /* End of Switch: '<S1961>/Switch1' */

        /* Switch: '<S1961>/Switch' incorporates:
         *  RelationalOperator: '<S1961>/Relational Operator1'
         */
        if (rtb_MinMax_bd > VeESSR_M_EngTrqReqPrdtdMin)
        {
            /* Switch: '<S1961>/Switch' */
            rtb_MinMax1_ow = rtb_MinMax_bd;
        }
        else
        {
            /* Switch: '<S1961>/Switch' */
            rtb_MinMax1_ow = VeESSR_M_EngTrqReqPrdtdMin;
        }

        /* End of Switch: '<S1961>/Switch' */
        /* End of Outputs for SubSystem: '<S1959>/Limiter1' */

        /* Product: '<S1959>/Multiplication1' incorporates:
         *  Constant: '<S1939>/Calib'
         *  Constant: '<S1957>/Calib'
         *  DataStoreRead: '<S1947>/Dsr_StrtTypInitImmedTorq2'
         *  MinMax: '<S1959>/Maximum'
         *  Product: '<S1947>/Product2'
         */
        rtb_MinMax_bd = (1.0F / fmaxf(KeESSR_K_StartEngTiPredCoefMult *
                          VeESSR_k_StrtTypEngTorqReqFltT_DS, HeESSR_t_MedTEB_dT))
            * HeESSR_t_MedTEB_dT;

        /* Switch: '<S1959>/Switch1' incorporates:
         *  DataStoreRead: '<S1947>/Dsr_StrtTypInitImmedTorq7'
         *  Gain: '<S1959>/Gain'
         *  Gain: '<S1959>/Gain1'
         *  Math: '<S1959>/Square'
         *  Product: '<S1959>/Multiplication2'
         *  Product: '<S1959>/Multiplication3'
         *  Sum: '<S1959>/Subtraction'
         *  Sum: '<S1959>/Subtraction1'
         *  Sum: '<S1959>/Summation'
         */
        rtb_Maximum1 = (((((rtb_MinMax1_ow - rtb_Sum2_jm) * (2.0F *
                            VeESSR_k_StrtTypEngTorqReqImmedFltD_DS)) *
                          rtb_MinMax_bd) + ((rtb_MinMax_bd * rtb_MinMax_bd) *
                          (rtb_Maximum1 - rtb_MinMax1_ow))) - rtb_MinMax1_ow) +
            (2.0F * rtb_Sum2_jm);
    }

    /* End of Switch: '<S1959>/Switch3' */

    /* Outputs for Atomic SubSystem: '<S1959>/Limiter3' */
    /* Switch: '<S1962>/Switch1' incorporates:
     *  RelationalOperator: '<S1962>/Relational Operator'
     */
    if (VeESSR_M_EngTrqReqPrdtdMax < rtb_Maximum1)
    {
        /* Switch: '<S1962>/Switch1' */
        rtb_MinMax_hj = VeESSR_M_EngTrqReqPrdtdMax;
    }
    else
    {
        /* Switch: '<S1962>/Switch1' */
        rtb_MinMax_hj = rtb_Maximum1;
    }

    /* End of Switch: '<S1962>/Switch1' */

    /* Switch: '<S1962>/Switch' incorporates:
     *  RelationalOperator: '<S1962>/Relational Operator1'
     */
    if (rtb_MinMax_hj > VeESSR_M_EngTrqReqPrdtdMin)
    {
        /* VariantMerge generated from: '<S1937>/EngTrqReqPred' */
        rtb_MinMax_bd = rtb_MinMax_hj;
    }
    else
    {
        /* VariantMerge generated from: '<S1937>/EngTrqReqPred' */
        rtb_MinMax_bd = VeESSR_M_EngTrqReqPrdtdMin;
    }

    /* End of Switch: '<S1962>/Switch' */
    /* End of Outputs for SubSystem: '<S1959>/Limiter3' */

    /* Update for UnitDelay: '<S1959>/Unit Delay' */
    localDW->UnitDelay_DSTATE_j = rtb_MinMax_bd;

    /* Update for Delay: '<S1959>/Delay' */
    localDW->icLoad_g = 0U;
    localDW->Delay_DSTATE_i = rtb_MinMax_bd;

    /* Update for Delay: '<S1959>/Delay1' */
    localDW->icLoad_mp = 0U;
    localDW->Delay1_DSTATE_a = rtb_Sum2_jm;

    /* End of Outputs for SubSystem: '<S1947>/Lowpass Second Order Enabled4' */

    /* VariantMerge generated from: '<S1937>/EngTrqReqImmed' incorporates:
     *  Sum: '<S1947>/Sum1'
     */
    rtb_MinMax1_ow = rtb_Maximum2_a - VeESSR_M_EngTrqReqImmedFltrOP;

    /* End of Outputs for SubSystem: '<S1937>/Default' */
#endif

    /* End of Outputs for SubSystem: '<S1867>/EngineTorqueCommands' */

    /* Switch: '<S1855>/Switch5' */
    if (rtu_PNLimActv)
    {
        /* MinMax: '<S2009>/MinMax1' incorporates:
         *  DataStoreRead: '<S1855>/Data Store Read11'
         *  Sum: '<S1855>/Sum4'
         */
        rtb_MinMax_hj = rtb_Summation_ep - VeESSR_M_EngTrqReqImmed_DS;
    }
    else
    {
        /* MinMax: '<S2009>/MinMax1' incorporates:
         *  Sum: '<S1867>/Sum3'
         */
        rtb_MinMax_hj = rtb_Maximum2_a - rtb_MinMax1_ow;
    }

    /* End of Switch: '<S1855>/Switch5' */

    /* Sum: '<S1981>/Sum1' incorporates:
     *  Constant: '<S1992>/Calib'
     */
    rtb_Summation_ep = rtu_VeOHSR_n_IdleSpdBlended - KeESSR_n_DeltaIdleSpd;

    /* Logic: '<S1876>/Logical4' incorporates:
     *  Constant: '<S1987>/Calib'
     *  DataStoreRead: '<S1876>/Dsr_STMTmr2'
     *  RelationalOperator: '<S1876>/Comparison2'
     */
    VeESSR_b_RampNiBfrChk = ((VeESSR_t_STMTmr_DS < KeESSR_t_CombChkDlyTm) ||
        rtb_Switch1_gw);

    /* Switch: '<S1876>/Switch3' incorporates:
     *  Constant: '<S1983>/Calib'
     *  Switch: '<S1876>/Switch4'
     */
    if (VeESSR_b_RampNiBfrChk)
    {
        /* Switch: '<S1981>/Switch' incorporates:
         *  Constant: '<S1991>/Calib'
         */
        if (HeESSR_b_NiTrgtIdleSpdStrtEng)
        {
            rtb_Maximum2_a = rtb_Summation_ep;
        }
        else
        {
            rtb_Maximum2_a = rtu_VeESSR_n_OptInputSpd;
        }

        /* End of Switch: '<S1981>/Switch' */

        /* Switch: '<S1876>/Switch3' incorporates:
         *  DataStoreRead: '<S1981>/Dsr_MinEngStrtSpd'
         *  MinMax: '<S1981>/Maximum'
         */
        VeESSR_n_NiAfterCombustion = fmaxf(rtb_Maximum2_a,
            VeESSR_n_MinEngStrtSpd_DS);
    }
    else if (KeESSR_b_NoEngComb_SpdSrc)
    {
        /* Switch: '<S1876>/Switch4' incorporates:
         *  Constant: '<S1986>/Calib'
         *  Switch: '<S1876>/Switch3'
         */
        VeESSR_n_NiAfterCombustion = KeESSR_n_NoEngComb_SpdTgt;
    }
    else
    {
        /* Switch: '<S1876>/Switch3' incorporates:
         *  DataStoreRead: '<S1876>/Data Store Read'
         *  Switch: '<S1876>/Switch4'
         */
        VeESSR_n_NiAfterCombustion = VeESSR_n_InputSpeedProfile_DS;
    }

    /* End of Switch: '<S1876>/Switch3' */

    /* Logic: '<S1863>/Logical Operator4' incorporates:
     *  Constant: '<S1905>/Calib'
     *  Logic: '<S1863>/Logical12'
     */
    rtb_LogicalOperator4_n = !HeESSR_b_DtrmnEngRunExtra;

    /* Logic: '<S1863>/Logical16' incorporates:
     *  Logic: '<S1863>/Logical Operator2'
     */
    rtb_RelationalOperator_guj = !rtb_Switch1_gw;

    /* Outputs for Atomic SubSystem: '<S1902>/Accumulator Reset Limited' */
    /* Switch: '<S1914>/Switch1' incorporates:
     *  Constant: '<S1915>/Calib'
     *  Logic: '<S1863>/Logical1'
     *  Logic: '<S1863>/Logical16'
     *  Logic: '<S1863>/Logical2'
     *  Switch: '<S1902>/Switch'
     */
    if (rtb_Equal2_o || (rtb_RelationalOperator_guj && (!rtb_LogicalOperator4_n)))
    {
        /* Switch: '<S1914>/Switch1' incorporates:
         *  Constant: '<S1902>/Constant Value1'
         */
        rtb_Maximum2_a = 0.0F;
    }
    else
    {
        if (HeESSR_b_48VEngStrtExitSpd)
        {
            /* Switch: '<S1902>/Switch' */
            rtb_Maximum2_a = VeESSR_n_NiAfterCombustion;
        }
        else
        {
            /* Switch: '<S1902>/Switch' incorporates:
             *  Constant: '<S1918>/Calib'
             */
            rtb_Maximum2_a = KeESSR_n_EngStrtExitSpd;
        }

        /* Sum: '<S1914>/Summation' incorporates:
         *  Constant: '<S1916>/Calib'
         *  Constant: '<S1919>/Calib'
         *  Product: '<S1902>/Product'
         *  Sum: '<S1902>/Sum1'
         *  UnitDelay: '<S1914>/Unit Delay'
         */
        rtb_Maximum2_a = (((rtu_VeESSR_n_TransInSpdFlt -
                            KeESSR_n_EngStrtExitSpdDelta) - rtb_Maximum2_a) *
                          HeESSR_t_MedTEB_dT) + localDW->UnitDelay_DSTATE_f;

        /* Outputs for Atomic SubSystem: '<S1914>/Limiter' */
        /* Switch: '<S1920>/Switch1' incorporates:
         *  Constant: '<S1917>/Calib'
         *  RelationalOperator: '<S1920>/Relational Operator'
         */
        if (KeESSR_n_EngStrtExitIntgrlVal < rtb_Maximum2_a)
        {
            /* Switch: '<S1920>/Switch1' */
            rtb_Maximum2_a = KeESSR_n_EngStrtExitIntgrlVal;
        }

        /* End of Switch: '<S1920>/Switch1' */

        /* Switch: '<S1920>/Switch' incorporates:
         *  Constant: '<S1902>/Constant Value1'
         *  RelationalOperator: '<S1920>/Relational Operator1'
         */
        if (rtb_Maximum2_a <= 0.0F)
        {
            /* Switch: '<S1914>/Switch1' */
            rtb_Maximum2_a = 0.0F;
        }

        /* End of Switch: '<S1920>/Switch' */
        /* End of Outputs for SubSystem: '<S1914>/Limiter' */
    }

    /* End of Switch: '<S1914>/Switch1' */

    /* Update for UnitDelay: '<S1914>/Unit Delay' */
    localDW->UnitDelay_DSTATE_f = rtb_Maximum2_a;

    /* End of Outputs for SubSystem: '<S1902>/Accumulator Reset Limited' */

    /* RelationalOperator: '<S1902>/Comparison4' incorporates:
     *  Constant: '<S1917>/Calib'
     */
    VeESSR_b_SpdChk_StrtEng = (rtb_Maximum2_a == KeESSR_n_EngStrtExitIntgrlVal);

    /* Logic: '<S1863>/Logical13' incorporates:
     *  Constant: '<S1903>/Constant'
     *  Constant: '<S1904>/Constant'
     *  RelationalOperator: '<S1863>/Comparison5'
     *  RelationalOperator: '<S1863>/Comparison6'
     */
    VeESSR_b_ETRQStrtEng = ((((uint32)rtu_VeENGR_e_ETRQ_Mode) ==
        CeENGR_e_DriverControl) || (((uint32)rtu_VeENGR_e_ETRQ_Mode) ==
        CeENGR_e_Idle));

    /* Switch: '<S1873>/Switch1' incorporates:
     *  Constant: '<S1862>/Constant'
     *  Constant: '<S1909>/Calib'
     *  Constant: '<S1910>/Calib'
     *  Constant: '<S1911>/Calib'
     *  DataStoreRead: '<S1863>/Dsr_STMTmr2'
     *  DataStoreWrite: '<S1855>/Dsw_STMTrigger'
     *  Logic: '<S1855>/Logical9'
     *  Logic: '<S1863>/AND'
     *  Logic: '<S1863>/Logical11'
     *  Logic: '<S1863>/Logical6'
     *  Logic: '<S1863>/Logical7'
     *  RelationalOperator: '<S1863>/Greater  Than2'
     *  RelationalOperator: '<S1863>/Greater  Than4'
     *  RelationalOperator: '<S1863>/Relational Operator1'
     *  Switch: '<S1873>/Switch2'
     */
    if (((rtb_OR1_pe && ((VeESSR_t_STMTmr_DS > KeESSR_t_HoldStartStateTime) ||
                         ((VeESSR_t_STMTmr_DS > KeESSR_t_HoldStartStateTimeMin) &&
                          (rtb_MinMax_hj < KeESSR_M_StrtEngTqExitDelta)))) &&
            (VeESSR_b_SpdChk_StrtEng)) && (rtb_LogicalOperator4_n ||
            (VeESSR_b_ETRQStrtEng)))
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngRun;
    }
    else
    {
        if (rtb_GreaterThan1_cc || (VeESSR_b_StrEngBeltSlipCstDwn))
        {
            /* Switch: '<S1855>/Switch' incorporates:
             *  Switch: '<S1855>/Switch2'
             *  Switch: '<S1873>/Switch2'
             */
            if (rtb_Logical15)
            {
                /* Switch: '<S1873>/Switch1' incorporates:
                 *  Constant: '<S1859>/Constant'
                 *  DataStoreWrite: '<S1855>/Dsw_STMTrigger'
                 *  Switch: '<S1855>/Switch'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;
            }
            else if (rtb_Logical5_b)
            {
                /* Switch: '<S1855>/Switch2' incorporates:
                 *  Constant: '<S1860>/Constant'
                 *  DataStoreWrite: '<S1855>/Dsw_STMTrigger'
                 *  Switch: '<S1855>/Switch'
                 *  Switch: '<S1873>/Switch1'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_StopReq;
            }
            else
            {
                /* Switch: '<S1873>/Switch1' incorporates:
                 *  Constant: '<S1858>/Constant'
                 *  DataStoreWrite: '<S1855>/Dsw_STMTrigger'
                 *  Switch: '<S1855>/Switch'
                 *  Switch: '<S1855>/Switch2'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;
            }

            /* End of Switch: '<S1855>/Switch' */
        }
    }

    /* End of Switch: '<S1873>/Switch1' */

    /* Abs: '<S1866>/Abs' incorporates:
     *  Constant: '<S1869>/Calib'
     *  Constant: '<S1883>/Calib'
     *  Product: '<S1866>/Multiplication'
     */
    rtb_Maximum1 = fabsf(KeESSR_dscl_RampUpRate * HeESSR_t_MedTEB_dT);

    /* Outputs for Atomic SubSystem: '<S1866>/Limiter1' */
    /* Switch: '<S1935>/Switch1' incorporates:
     *  Constant: '<S1855>/Constant Value8'
     *  DataStoreRead: '<S1855>/Dsr_SpdCtlGainMod1'
     *  RelationalOperator: '<S1935>/Relational Operator'
     *  Sum: '<S1866>/Sum'
     */
    if (rtb_Maximum1 < (1.0F - VeESSR_scl_SpdCtlGainMod_DS))
    {
        /* MinMax: '<S2009>/MinMax1' */
        rtb_MinMax_hj = rtb_Maximum1;
    }
    else
    {
        /* MinMax: '<S2009>/MinMax1' */
        rtb_MinMax_hj = 1.0F - VeESSR_scl_SpdCtlGainMod_DS;
    }

    /* End of Switch: '<S1935>/Switch1' */

    /* Switch: '<S1935>/Switch' incorporates:
     *  Gain: '<S1866>/Gain'
     *  RelationalOperator: '<S1935>/Relational Operator1'
     */
    if (rtb_MinMax_hj <= (-rtb_Maximum1))
    {
        rtb_MinMax_hj = -rtb_Maximum1;
    }

    /* End of Switch: '<S1935>/Switch' */
    /* End of Outputs for SubSystem: '<S1866>/Limiter1' */

    /* Sum: '<S1866>/Sum1' incorporates:
     *  DataStoreRead: '<S1855>/Dsr_SpdCtlGainMod1'
     */
    rtb_Maximum2_a = rtb_MinMax_hj + VeESSR_scl_SpdCtlGainMod_DS;

    /* Outputs for Atomic SubSystem: '<S1866>/Limiter2' */
    /* Switch: '<S1936>/Switch1' incorporates:
     *  Constant: '<S1855>/Constant Value7'
     *  RelationalOperator: '<S1936>/Relational Operator'
     */
    if (2.0F < rtb_Maximum2_a)
    {
        /* MinMax: '<S2009>/MinMax1' */
        rtb_MinMax_hj = 2.0F;
    }
    else
    {
        /* MinMax: '<S2009>/MinMax1' */
        rtb_MinMax_hj = rtb_Maximum2_a;
    }

    /* End of Switch: '<S1936>/Switch1' */

    /* Switch: '<S1936>/Switch' incorporates:
     *  Constant: '<S1855>/Constant Value4'
     *  DataStoreWrite: '<S1855>/Dsw_SpdCtlGainMod1'
     *  RelationalOperator: '<S1936>/Relational Operator1'
     */
    if (rtb_MinMax_hj > 0.0F)
    {
        VeESSR_scl_SpdCtlGainMod_DS = rtb_MinMax_hj;
    }
    else
    {
        VeESSR_scl_SpdCtlGainMod_DS = 0.0F;
    }

    /* End of Switch: '<S1936>/Switch' */
    /* End of Outputs for SubSystem: '<S1866>/Limiter2' */

    /* Logic: '<S1863>/Logical Operator3' incorporates:
     *  Logic: '<S1863>/Logical Operator1'
     *  Logic: '<S1863>/Logical14'
     *  Logic: '<S1863>/Logical15'
     */
    rtb_LogicalOperator3_m = (((!rtb_LogicalOperator3_m) ||
        (!VeESSR_b_SpdChk_StrtEng)) && rtb_GreaterThan1_cc);

    /* Logic: '<S1863>/Logical Operator4' */
    rtb_LogicalOperator4_n = (rtb_RelationalOperator_guj && rtb_GreaterThan1_cc);

    /* Logic: '<S1863>/Logical Operator5' incorporates:
     *  Logic: '<S1863>/Logical17'
     */
    rtb_Logical15 = (rtb_GreaterThan1_cc && (!VeESSR_b_ETRQStrtEng));

    /* Logic: '<S1863>/Logical5' */
    rtb_GreaterThan1_cc = ((rtb_LogicalOperator3_m || rtb_LogicalOperator4_n) ||
                           rtb_Logical15);

    /* If: '<S1855>/If' incorporates:
     *  DataStoreRead: '<S1855>/Data Store Read4'
     *  Logic: '<S1855>/Logical17'
     *  Logic: '<S1855>/Logical7'
     */
    if ((!VeESSR_b_AStrtReattmptAllowed_DS) && rtb_GreaterThan1_cc)
    {
        /* Outputs for IfAction SubSystem: '<S1855>/If_StartEng_P1C64' incorporates:
         *  ActionPort: '<S1875>/Action Port'
         */
        /* DataStoreWrite: '<S1855>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_StartEng_P1C64((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S1855>/If_StartEng_P1C64' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1855>/If_StartEng_NoFault' incorporates:
         *  ActionPort: '<S1874>/Action Port'
         */
        /* DataStoreWrite: '<S1855>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_KeyCrank_NoFault((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S1855>/If_StartEng_NoFault' */
    }

    /* End of If: '<S1855>/If' */

    /* SignalConversion generated from: '<S1887>/Variant Source' */
#if !Rte_SysCon_Variant_ESSR_12vBSG

    /* Switch: '<S2017>/Switch1' incorporates:
     *  Constant: '<S1887>/Constant Value'
     */
    rtb_Switch1_n5 = 0.0F;

#endif

    /* Switch: '<S1887>/Switch9' incorporates:
     *  Constant: '<S2046>/Calib'
     *  DataStoreRead: '<S1887>/Data Store Read8'
     *  MinMax: '<S2045>/MinMax1'
     *  Product: '<S2045>/Multiplication'
     *  SignalConversion generated from: '<S1887>/Variant Source'
     *  Sum: '<S2045>/Summation5'
     */
#if Rte_SysCon_Variant_ESSR_12vBSG

    /* Outputs for Atomic SubSystem: '<S2045>/Limiter' */
    /* Outputs for Atomic SubSystem: '<S2045>/DeadBand' */
    /* Outputs for Atomic SubSystem: '<S1887>/Digital Lowpass Reset Enabled' */
    /* Switch: '<S2043>/Switch1' incorporates:
     *  Constant: '<S2046>/Calib'
     *  Switch: '<S2043>/Switch2'
     */
    if (rtb_Equal2_o)
    {
        /* Switch: '<S2043>/Switch1' incorporates:
         *  DataStoreRead: '<S1887>/Data Store Read8'
         */
        rtb_Switch1_n5 = VeESSR_n_InputSpeedProfile_DS;
    }
    else if (HeESSR_b_EnblLQRConfig)
    {
        /* Switch: '<S2043>/Switch2' incorporates:
         *  Constant: '<S1887>/Constant'
         *  Product: '<S2043>/Multiplication'
         *  Sum: '<S2043>/Subtraction'
         *  Sum: '<S2043>/Summation'
         *  Switch: '<S2043>/Switch1'
         *  UnitDelay: '<S2043>/Unit Delay'
         */
        rtb_Switch1_n5 = ((rtb_Summation_ep - localDW->UnitDelay_DSTATE_d) *
                          0.2F) + localDW->UnitDelay_DSTATE_d;
    }
    else
    {
        /* Switch: '<S2043>/Switch1' incorporates:
         *  Switch: '<S2043>/Switch2'
         *  UnitDelay: '<S2043>/Unit Delay'
         */
        rtb_Switch1_n5 = localDW->UnitDelay_DSTATE_d;
    }

    /* End of Switch: '<S2043>/Switch1' */

    /* Update for UnitDelay: '<S2043>/Unit Delay' */
    localDW->UnitDelay_DSTATE_d = rtb_Switch1_n5;
    if (!HeESSR_b_EnblLQRConfig)
    {
        rtb_Switch1_n5 = VeESSR_n_InputSpeedProfile_DS;
    }

    /* Sum: '<S2045>/Summation5' incorporates:
     *  Constant: '<S2046>/Calib'
     *  DataStoreRead: '<S1887>/Data Store Read8'
     */
    VeESSR_n_EngStrtSpdError = fmaxf(rtb_Switch1_n5, rtu_VeESSR_n_TransInSpdFlt)
        - rtu_VeESSR_n_TransInSpdFlt;

    /* Switch: '<S2053>/Switch1' incorporates:
     *  Constant: '<S2053>/Constant Value'
     *  Constant: '<S2057>/Calib'
     *  Constant: '<S2058>/Calib'
     *  RelationalOperator: '<S2053>/Greater  Than'
     *  RelationalOperator: '<S2053>/Greater  Than1'
     *  Sum: '<S2053>/Subtraction'
     *  Switch: '<S2053>/Switch2'
     */
    if (VeESSR_n_EngStrtSpdError >= KeESSR_n_EngStrtSpdCtlPosDdBnd)
    {
        rtb_Maximum2_a = VeESSR_n_EngStrtSpdError -
            KeESSR_n_EngStrtSpdCtlPosDdBnd;
    }
    else if (VeESSR_n_EngStrtSpdError <= KeESSR_n_EngStrtSpdCtlNegDdBnd)
    {
        /* Switch: '<S2053>/Switch2' incorporates:
         *  Constant: '<S2057>/Calib'
         *  Sum: '<S2053>/Subtraction1'
         */
        rtb_Maximum2_a = VeESSR_n_EngStrtSpdError -
            KeESSR_n_EngStrtSpdCtlNegDdBnd;
    }
    else
    {
        rtb_Maximum2_a = 0.0F;
    }

    /* End of Switch: '<S2053>/Switch1' */

    /* Product: '<S2045>/Multiplication' incorporates:
     *  Constant: '<S2054>/Calib'
     */
    rtb_Switch1_n5 = rtb_Maximum2_a * KeESSR_K_EngStrtSpdCtlPgain;

    /* Switch: '<S2059>/Switch1' incorporates:
     *  Constant: '<S2055>/Calib'
     *  RelationalOperator: '<S2059>/Relational Operator'
     */
    if (KeESSR_M_EngStrtSpdCtlMaxTi < rtb_Switch1_n5)
    {
        /* MinMax: '<S2009>/MinMax1' */
        rtb_MinMax_hj = KeESSR_M_EngStrtSpdCtlMaxTi;
    }
    else
    {
        /* MinMax: '<S2009>/MinMax1' */
        rtb_MinMax_hj = rtb_Switch1_n5;
    }

    /* End of Switch: '<S2059>/Switch1' */

    /* Switch: '<S2059>/Switch' incorporates:
     *  Constant: '<S2056>/Calib'
     *  RelationalOperator: '<S2059>/Relational Operator1'
     */
    if (rtb_MinMax_hj > KeESSR_M_EngStrtSpdCtlMinTi)
    {
        /* Switch: '<S2059>/Switch' */
        VeESSR_M_StrtEngPSpdCtl = rtb_MinMax_hj;
    }
    else
    {
        /* Switch: '<S2059>/Switch' */
        VeESSR_M_StrtEngPSpdCtl = KeESSR_M_EngStrtSpdCtlMinTi;
    }

    /* End of Switch: '<S2059>/Switch' */

    /* Switch: '<S2017>/Switch1' */
    rtb_Switch1_n5 = VeESSR_M_StrtEngPSpdCtl;

    /* End of Outputs for SubSystem: '<S1887>/Digital Lowpass Reset Enabled' */
    /* End of Outputs for SubSystem: '<S2045>/DeadBand' */
    /* End of Outputs for SubSystem: '<S2045>/Limiter' */
#endif

    /* End of Switch: '<S1887>/Switch9' */

    /* Outputs for Atomic SubSystem: '<S1887>/Digital Lowpass Reset Enabled1' */
    /* Outputs for Atomic SubSystem: '<S2044>/Signal Latch On With Reset' */
    /* Logic: '<S2049>/OR1' incorporates:
     *  Logic: '<S2044>/Logical Operator'
     *  Logic: '<S2049>/NOT'
     *  Logic: '<S2049>/OR'
     *  RelationalOperator: '<S2044>/Relational Operator'
     *  UnitDelay: '<S2049>/Unit Delay'
     */
    rtb_Logical5_b = ((rtb_Equal2_o && (rtu_VeESSR_M_EngTrqAct_Lmtd >
                        rtu_HTDR_TiMin)) || ((!rtb_Equal2_o) &&
                       (localDW->UnitDelay_DSTATE_h)));

    /* Update for UnitDelay: '<S2049>/Unit Delay' */
    localDW->UnitDelay_DSTATE_h = rtb_Logical5_b;

    /* End of Outputs for SubSystem: '<S2044>/Signal Latch On With Reset' */

    /* Switch: '<S2044>/Switch1' */
    if (rtb_Equal2_o)
    {
        /* Switch: '<S2044>/Switch1' incorporates:
         *  DataStoreRead: '<S1887>/Data Store Read3'
         */
        rtb_Summation_ep = VeESSR_M_TiEstP1fOpLp;
    }
    else
    {
        /* Switch: '<S2044>/Switch1' incorporates:
         *  Lookup_n-D: '<S2048>/Vector'
         *  Product: '<S2044>/Multiplication'
         *  Sum: '<S2044>/Subtraction'
         *  Sum: '<S2044>/Summation'
         *  UnitDelay: '<S2044>/Unit Delay'
         */
        rtb_Summation_ep = ((rtu_VeESSR_M_EngTrqAct_Lmtd -
                             VeESSR_M_StrEngISpdCtl) * look1_iflf_binlcapw
                            (rtu_EngCltTmp, ((const float32 *)
                              &(KxESSR_k_TiEstBlndStrtEng[0])), ((const float32 *)
                              &(KtESSR_k_TiEstBlndStrtEng[0])), 8U)) +
            VeESSR_M_StrEngISpdCtl;
    }

    /* End of Switch: '<S2044>/Switch1' */

    /* If: '<S2044>/If' */
    rtPrevAction = localDW->If_ActiveSubsystem;
    rtAction = (sint8)((!rtb_Logical5_b) ? 1 : 0);
    localDW->If_ActiveSubsystem = rtAction;
    if (rtAction == 0)
    {
        /* Outputs for IfAction SubSystem: '<S2044>/Subsystem' incorporates:
         *  ActionPort: '<S2050>/Action Port'
         */
        ESSR_ac_Subsystem(rtu_HTDR_TiMin, rtb_Summation_ep,
                          rtu_VeESSR_M_EngTrqAct_Lmtd, &rtb_MinMax_hj);

        /* End of Outputs for SubSystem: '<S2044>/Subsystem' */
    }
    else
    {
        if (rtAction != rtPrevAction)
        {
            /* SystemReset for IfAction SubSystem: '<S2044>/Subsystem1' incorporates:
             *  ActionPort: '<S2051>/Action Port'
             */
            /* SystemReset for If: '<S2044>/If' */
            ESSR_ac_Subsystem1_Reset(&localDW->Subsystem1);

            /* End of SystemReset for SubSystem: '<S2044>/Subsystem1' */
        }

        /* Outputs for IfAction SubSystem: '<S2044>/Subsystem1' incorporates:
         *  ActionPort: '<S2051>/Action Port'
         */
        ESSR_ac_Subsystem1(rtu_HTDR_TiMin, rtb_Summation_ep,
                           rtu_VeESSR_M_EngTrqAct_Lmtd, rtb_Switch1_gw,
                           &rtb_MinMax_hj, &localDW->Subsystem1);

        /* End of Outputs for SubSystem: '<S2044>/Subsystem1' */
    }

    /* End of If: '<S2044>/If' */

    /* Switch: '<S2044>/Switch' incorporates:
     *  Constant: '<S2047>/Calib'
     */
    if (KeESSR_b_EnblTiEstFltLim)
    {
        /* Switch: '<S2044>/Switch' */
        VeESSR_M_StrEngISpdCtl = rtb_MinMax_hj;
    }
    else
    {
        /* Switch: '<S2044>/Switch' */
        VeESSR_M_StrEngISpdCtl = rtb_Summation_ep;
    }

    /* End of Switch: '<S2044>/Switch' */
    /* End of Outputs for SubSystem: '<S1887>/Digital Lowpass Reset Enabled1' */

    /* Switch: '<S2017>/Switch1' incorporates:
     *  Sum: '<S1887>/Summation5'
     */
    rtb_Switch1_n5 += VeESSR_M_StrEngISpdCtl;

    /* MinMax: '<S1887>/MinMax' incorporates:
     *  DataStoreWrite: '<S1887>/Dsw_InputTorqEst1'
     */
    VeESSR_M_EngTorqEst_DS = fmaxf(rtb_Switch1_n5, rtu_HTDR_TiMin);

    /* Switch: '<S1863>/Switch4' incorporates:
     *  S-Function (sfix_bitop): '<S1898>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator3_m)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 256U;
    }

    /* End of Switch: '<S1863>/Switch4' */

    /* Switch: '<S1863>/Switch2' incorporates:
     *  S-Function (sfix_bitop): '<S1899>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator4_n)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 512U;
    }

    /* End of Switch: '<S1863>/Switch2' */

    /* Switch: '<S1863>/Switch3' incorporates:
     *  S-Function (sfix_bitop): '<S1901>/FixPt Bitwise Operator1'
     */
    if (rtb_Logical15)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 536870912U;
    }

    /* End of Switch: '<S1863>/Switch3' */

    /* Logic: '<S1863>/Logical' incorporates:
     *  DataStoreWrite: '<S1863>/Dsw_SE_EngFuelOn'
     */
    VeESSR_b_SE_EngFuelOn_DS = (rtb_OR1_pe && (VeESSR_b_SpdChk_StrtEng));

    /* Switch: '<S1863>/Switch1' incorporates:
     *  Constant: '<S1863>/Constant Value'
     *  DataStoreRead: '<S1863>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S1863>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S1863>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S1863>/Logical21'
     *  RelationalOperator: '<S1863>/Comparison'
     *  S-Function (sfix_bitop): '<S1863>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S1900>/FixPt Bitwise Operator1'
     */
    if (rtb_GreaterThan1_cc && ((VeESSR_g_StrtStpFailPhaseSelect_DS & 1024U) >
                                0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 1024U;
    }

    /* End of Switch: '<S1863>/Switch1' */

    /* DataStoreWrite: '<S1867>/Dsw_EngTrqReqImmed' */
    VeESSR_M_EngTrqReqImmed_DS = rtb_MinMax1_ow;

    /* DataStoreWrite: '<S1867>/Dsw_EngTrqReqPrdtd' */
    VeESSR_M_EngTrqReqPrdtd_DS = rtb_MinMax_bd;

    /* Switch: '<S1945>/Switch1' incorporates:
     *  Constant: '<S1973>/Constant'
     *  RelationalOperator: '<S1945>/Relational Operator'
     */
    if (((uint32)rtu_VeENGR_e_ETRQ_Mode) == CeENGR_e_Idle)
    {
        /* Switch: '<S1945>/Switch2' incorporates:
         *  Constant: '<S1978>/Calib'
         */
        if (KeESSR_b_EnblPotForRespType)
        {
            rtb_Maximum2_a = rtu_AirflowTq;
        }
        else
        {
            rtb_Maximum2_a = rtu_VeESSR_M_OptEngTrqReqPred;
        }

        /* End of Switch: '<S1945>/Switch2' */

        /* Switch: '<S1945>/Switch1' incorporates:
         *  Sum: '<S1945>/Subtract'
         */
        rtb_Switch1_n5 = rtb_Maximum2_a - rtu_VeESSR_M_OptEngTrqReqImmed;
    }
    else
    {
        /* Switch: '<S1945>/Switch1' incorporates:
         *  Constant: '<S1945>/Constant'
         */
        rtb_Switch1_n5 = 0.0F;
    }

    /* End of Switch: '<S1945>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S1945>/Hysteresis' */
    /* Switch: '<S1975>/Switch1' incorporates:
     *  Constant: '<S1977>/Calib'
     *  RelationalOperator: '<S1975>/Greater  Than'
     */
    if (rtb_Switch1_n5 > KeESSR_M_RespTypeRSP)
    {
        /* Switch: '<S1975>/Switch1' incorporates:
         *  Constant: '<S1975>/Constant Value'
         */
        rtb_LogicalOperator3_m = true;
    }
    else
    {
        /* Switch: '<S1975>/Switch1' incorporates:
         *  Constant: '<S1976>/Calib'
         *  RelationalOperator: '<S1975>/Greater  Than1'
         *  UnitDelay: '<S1975>/Unit Delay'
         */
        rtb_LogicalOperator3_m = ((rtb_Switch1_n5 >= KeESSR_M_RespTypeLSP) &&
            (localDW->UnitDelay_DSTATE_m));
    }

    /* End of Switch: '<S1975>/Switch1' */

    /* Update for UnitDelay: '<S1975>/Unit Delay' */
    localDW->UnitDelay_DSTATE_m = rtb_LogicalOperator3_m;

    /* End of Outputs for SubSystem: '<S1945>/Hysteresis' */

    /* Switch: '<S1945>/Switch3' incorporates:
     *  Constant: '<S1972>/Constant'
     *  Constant: '<S1974>/Constant'
     *  DataStoreWrite: '<S1867>/Dsw_NiProfGenDNiDLim14'
     */
    if (rtb_LogicalOperator3_m)
    {
        VeESSR_e_StrtStpTypEngTorqRespType_DS = CePTAR_e_PleasibilityLimited;
    }
    else
    {
        VeESSR_e_StrtStpTypEngTorqRespType_DS = CePTAR_e_Inactive;
    }

    /* End of Switch: '<S1945>/Switch3' */

    /* Sum: '<S1988>/Sum' incorporates:
     *  Constant: '<S1994>/Calib'
     *  DataStoreRead: '<S1988>/Dsr_InputAcceltnProf'
     *  DataStoreRead: '<S1988>/Dsr_InputSpeedProfile1'
     *  Product: '<S1988>/Product'
     */
    VeESSR_n_InputSpdLead_StartEng = (VeESSR_dn_InputAcceltnProf_DS *
        KeESSR_t_NiDotLimNiProfLead) + VeESSR_n_InputSpeedProfile_DS;

    /* Sum: '<S1988>/Sum1' incorporates:
     *  Constant: '<S1988>/Constant Value2'
     *  DataStoreRead: '<S1988>/Dsr_InputTorqEst'
     *  Lookup_n-D: '<S1995>/Vector'
     *  Product: '<S1988>/Product1'
     */
    rtb_Switch1_n5 = ((VeESSR_M_EngTorqEst_DS * 0.0001F) *
                      VeESSR_n_InputSpdLead_StartEng) + look1_iflf_binlcapw
        (rtu_VeCSVR_n_PrimNoSgndFltrd, ((const float32 *)
          &(KxESSR_P_NiDotLimPowerLim[0])), ((const float32 *)
          &(KtESSR_P_NiDotLimPowerLim[0])), 2U);

    /* Product: '<S1988>/Product2' incorporates:
     *  Constant: '<S1993>/Calib'
     */
    rtb_Summation_ep = VeESSR_n_InputSpdLead_StartEng *
        KeESSR_K_NiDotLimEffInertia;

    /* Outputs for Atomic SubSystem: '<S1988>/Protected Division' */
    /* Switch: '<S1998>/Switch1' incorporates:
     *  Constant: '<S1998>/Constant Value'
     *  Constant: '<S1998>/Constant Value1'
     *  Constant: '<S1998>/Constant Value2'
     *  Constant: '<S1998>/Constant Value3'
     *  Logic: '<S1998>/AND'
     *  RelationalOperator: '<S1998>/Greater Than or Equal '
     *  RelationalOperator: '<S1998>/Greater Than or Equal 1'
     *  RelationalOperator: '<S1998>/Not Equal'
     *  RelationalOperator: '<S1998>/Not Equal1'
     *  Switch: '<S1998>/Switch2'
     *  Switch: '<S1998>/Switch3'
     */
    if ((rtb_Switch1_n5 != 0.0F) && (rtb_Summation_ep != 0.0F))
    {
        /* Switch: '<S1998>/Switch1' incorporates:
         *  Product: '<S1998>/Division'
         */
        rtb_Switch1_n5 /= rtb_Summation_ep;
    }
    else if (rtb_Switch1_n5 > 0.0F)
    {
        /* Switch: '<S1998>/Switch2' incorporates:
         *  Constant: '<S1998>/MAXFLOAT'
         *  Switch: '<S1998>/Switch1'
         */
        rtb_Switch1_n5 = 3.402823466E+38F;
    }
    else if (rtb_Switch1_n5 < 0.0F)
    {
        /* Switch: '<S1998>/Switch3' incorporates:
         *  Constant: '<S1998>/MINFLOAT'
         *  Switch: '<S1998>/Switch1'
         *  Switch: '<S1998>/Switch2'
         */
        rtb_Switch1_n5 = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1998>/Switch1' incorporates:
         *  Constant: '<S1998>/Constant Value4'
         *  Switch: '<S1998>/Switch2'
         *  Switch: '<S1998>/Switch3'
         */
        rtb_Switch1_n5 = 0.0F;
    }

    /* End of Switch: '<S1998>/Switch1' */
    /* End of Outputs for SubSystem: '<S1988>/Protected Division' */

    /* Outputs for Atomic SubSystem: '<S1988>/Limiter1' */
    /* Switch: '<S1996>/Switch1' incorporates:
     *  DataStoreRead: '<S1876>/Dsr_NiProfGenNiDMax1'
     *  RelationalOperator: '<S1996>/Relational Operator'
     */
    if (VeESSR_dn_StrtTypNiDotMax_EngStrt_DS < rtb_Switch1_n5)
    {
        /* Switch: '<S2017>/Switch1' */
        rtb_Switch1_n5 = VeESSR_dn_StrtTypNiDotMax_EngStrt_DS;
    }

    /* End of Switch: '<S1996>/Switch1' */

    /* Switch: '<S1996>/Switch' incorporates:
     *  Constant: '<S1988>/Constant Value1'
     *  RelationalOperator: '<S1996>/Relational Operator1'
     */
    if (rtb_Switch1_n5 > 300.0F)
    {
        /* Switch: '<S1996>/Switch' */
        VeESSR_dn_NiDotMax_StartEng = rtb_Switch1_n5;
    }
    else
    {
        /* Switch: '<S1996>/Switch' */
        VeESSR_dn_NiDotMax_StartEng = 300.0F;
    }

    /* End of Switch: '<S1996>/Switch' */
    /* End of Outputs for SubSystem: '<S1988>/Limiter1' */

    /* Gain: '<S1990>/Gain' incorporates:
     *  Abs: '<S1990>/Abs1'
     *  DataStoreRead: '<S1876>/Dsr_NiProfGenDNiDLim2'
     */
    rtb_Multiplication1_gld = -fabsf(VeESSR_dn_StrtTypJerkMinStartEng_DS);

    /* Product: '<S2006>/Product4' incorporates:
     *  Constant: '<S1982>/Calib'
     */
    rtb_yyk1_p = rtb_Multiplication1_gld / HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1990>/LowpassT Reset Enabled' */
    /* Sum: '<S2004>/Summation' incorporates:
     *  Constant: '<S1982>/Calib'
     *  DataStoreRead: '<S1876>/Dsr_Ni1stFlt_DS'
     *  DataStoreRead: '<S1876>/Dsr_NiProfGenT2Gain'
     *  MinMax: '<S2004>/Maximum'
     *  Product: '<S2004>/Multiplication'
     *  Product: '<S2004>/Multiplication1'
     *  Sum: '<S2004>/Subtraction'
     */
    rtb_Summation_ep = (((VeESSR_n_NiAfterCombustion - VeESSR_n_Ni1stFlt_DS) *
                         HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                         (VeESSR_k_StrtTypScndOrdLwPassT_DS, HeESSR_t_MedTEB_dT)))
        + VeESSR_n_Ni1stFlt_DS;

    /* End of Outputs for SubSystem: '<S1990>/LowpassT Reset Enabled' */

    /* Outputs for Atomic SubSystem: '<S1990>/LowpassT Reset Enabled1' */
    /* Sum: '<S2005>/Summation' incorporates:
     *  Constant: '<S1982>/Calib'
     *  DataStoreRead: '<S1876>/Data Store Read9'
     *  DataStoreRead: '<S1876>/Dsr_NiProfGenT1Gain'
     *  MinMax: '<S2005>/Maximum'
     *  Product: '<S2005>/Multiplication'
     *  Product: '<S2005>/Multiplication1'
     *  Sum: '<S2005>/Subtraction'
     */
    rtb_Maximum2_a = (((rtb_Summation_ep - VeESSR_n_InputSpeedProfile_DS) *
                       HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                       (VeESSR_k_StrtTypFrstOrdLwPassT_DS, HeESSR_t_MedTEB_dT)))
        + VeESSR_n_InputSpeedProfile_DS;

    /* End of Outputs for SubSystem: '<S1990>/LowpassT Reset Enabled1' */

    /* Switch: '<S2025>/Switch1' incorporates:
     *  UnitDelay: '<S2025>/Unit Delay'
     */
    if (rtb_Equal2_o)
    {
        rtb_MinMax_hj = rtb_Maximum2_a;
    }
    else
    {
        rtb_MinMax_hj = localDW->UnitDelay_DSTATE;
    }

    /* End of Switch: '<S2025>/Switch1' */

    /* Gain: '<S2006>/Gain1' incorporates:
     *  Sum: '<S2006>/Sum18'
     */
    rtb_Maximum1 = (rtb_Maximum2_a + rtb_MinMax_hj) * 0.5F;

    /* Delay: '<S2006>/IntegerDelay' incorporates:
     *  Constant: '<S2015>/Calib'
     */
    if (rtb_Equal2_o && (((uint32)localZCE->IntegerDelay_Reset_ZCE_jb) !=
                         POS_ZCSIG))
    {
        localDW->icLoad = 1U;
    }

    localZCE->IntegerDelay_Reset_ZCE_jb = rtb_Equal2_o ? ((ZCSigState)1) :
        ((ZCSigState)0);
    if (((sint32)localDW->icLoad) != 0)
    {
        for (i = 0; i < 16; i++)
        {
            localDW->IntegerDelay_DSTATE[i] = rtb_Maximum1;
        }
    }

    if (((sint32)KeESSR_Cnt_DelayOptNi) <= 0)
    {
        /* Delay: '<S2006>/IntegerDelay' */
        rtb_Sum2_jm = rtb_Maximum1;
    }
    else
    {
        if (((sint32)KeESSR_Cnt_DelayOptNi) > 16)
        {
            tmp = 16U;
        }
        else
        {
            tmp = KeESSR_Cnt_DelayOptNi;
        }

        /* Delay: '<S2006>/IntegerDelay' */
        rtb_Sum2_jm = localDW->IntegerDelay_DSTATE[(uint8)(16U - ((uint32)tmp))];
    }

    /* End of Delay: '<S2006>/IntegerDelay' */

    /* Sum: '<S2006>/Sum15' incorporates:
     *  Abs: '<S2006>/Abs4'
     *  Constant: '<S1984>/Calib'
     *  DataStoreRead: '<S1876>/Dsr_InputSpeedProfile5'
     */
    rtb_MinMax_bd = fabsf(VeESSR_dn_TargetAcceltn_DS) +
        KeESSR_dn_NiTargetJerkLimit;

    /* Outputs for Atomic SubSystem: '<S2006>/GradientLimiter' */
    /* Sum: '<S2008>/Sum2' incorporates:
     *  Constant: '<S1982>/Calib'
     *  DataStoreRead: '<S1876>/Dsr_InputSpeedProfile4'
     *  Product: '<S2006>/Product6'
     *  Sum: '<S2006>/Sum14'
     *  UnitDelay: '<S2008>/Unit Delay'
     */
    rtb_MinMax1_ow = ((rtb_Maximum1 - VeESSR_n_TargetSpeed_DS) /
                      HeESSR_t_MedTEB_dT) - localDW->UnitDelay_DSTATE_dr;

    /* Outputs for Atomic SubSystem: '<S2008>/Limiter' */
    /* Switch: '<S2026>/Switch1' incorporates:
     *  RelationalOperator: '<S2026>/Relational Operator'
     */
    if (rtb_MinMax_bd < rtb_MinMax1_ow)
    {
        /* MinMax: '<S2009>/MinMax1' */
        rtb_MinMax_hj = rtb_MinMax_bd;
    }
    else
    {
        /* MinMax: '<S2009>/MinMax1' */
        rtb_MinMax_hj = rtb_MinMax1_ow;
    }

    /* End of Switch: '<S2026>/Switch1' */

    /* Switch: '<S2026>/Switch' incorporates:
     *  Gain: '<S2006>/Gain'
     *  RelationalOperator: '<S2026>/Relational Operator1'
     */
    if (rtb_MinMax_hj <= (-rtb_MinMax_bd))
    {
        rtb_MinMax_hj = -rtb_MinMax_bd;
    }

    /* End of Switch: '<S2026>/Switch' */
    /* End of Outputs for SubSystem: '<S2008>/Limiter' */

    /* Sum: '<S2008>/Sum3' incorporates:
     *  UnitDelay: '<S2008>/Unit Delay'
     */
    rtb_Switch1_n5 = rtb_MinMax_hj + localDW->UnitDelay_DSTATE_dr;

    /* Update for UnitDelay: '<S2008>/Unit Delay' */
    localDW->UnitDelay_DSTATE_dr = rtb_Switch1_n5;

    /* End of Outputs for SubSystem: '<S2006>/GradientLimiter' */

    /* Sum: '<S2007>/Subtraction1' incorporates:
     *  Constant: '<S1985>/Calib'
     *  DataStoreRead: '<S1876>/Dsr_InputSpeedProfile5'
     *  Product: '<S2007>/Multiplication'
     *  Sum: '<S2007>/Subtraction'
     */
    rtb_MinMax_bd = ((rtb_Switch1_n5 - VeESSR_dn_TargetAcceltn_DS) *
                     KeESSR_k_NiDotTargetFilt) + VeESSR_dn_TargetAcceltn_DS;

    /* DataStoreRead: '<S1876>/Dsr_InputAcceltnProf' */
    rtb_MinMax1_ow = VeESSR_dn_InputAcceltnProf_DS;

    /* Abs: '<S1990>/Abs' incorporates:
     *  DataStoreRead: '<S1876>/Dsr_NiProfGenDNiDLim1'
     */
    rtb_Switch1_n5 = fabsf(VeESSR_dn_StrtTypJerkMaxStartEng_DS);

    /* Switch: '<S2037>/Switch1' incorporates:
     *  Constant: '<S2035>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S2037>/Switch1' incorporates:
         *  Constant: '<S2036>/Calib'
         */
        rtb_Switch1_bbr = HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S2024>/Sum6' incorporates:
         *  DataStoreRead: '<S1876>/Dsr_InputAcceltnProf'
         *  Sum: '<S2024>/Sum8'
         */
        rtb_Switch_cp2 = VeESSR_dn_InputAcceltnProf_DS - rtb_MinMax_bd;

        /* Abs: '<S2024>/Abs' incorporates:
         *  Sum: '<S2024>/Sum6'
         */
        rtb_MinMax_hj = (rtb_Switch_cp2 - rtb_Multiplication1_gld) +
            rtb_Switch1_n5;

        /* MinMax: '<S2024>/MinMax2' incorporates:
         *  Abs: '<S2024>/Abs1'
         *  Constant: '<S1982>/Calib'
         *  Constant: '<S2024>/Constant Value'
         *  Constant: '<S2024>/Constant Value3'
         *  DataStoreRead: '<S1876>/Data Store Read9'
         *  Product: '<S2024>/Product2'
         *  Product: '<S2024>/Product7'
         *  Product: '<S2039>/Prod'
         *  Sum: '<S2024>/Sum3'
         *  Sum: '<S2024>/Sum5'
         */
        rtb_MinMax_hj = fmaxf((fabsf((rtb_Sum2_jm -
            VeESSR_n_InputSpeedProfile_DS) - (HeESSR_t_MedTEB_dT * rtb_MinMax_bd))
                               * (rtb_yyk1_p * -2.0F)) - (rtb_MinMax_hj *
                               rtb_MinMax_hj), 0.0F);

        /* Switch: '<S2041>/Switch' incorporates:
         *  Sqrt: '<S2041>/Sqrt'
         */
        rtb_MinMax_hj = sqrtf(rtb_MinMax_hj);

        /* Switch: '<S2037>/Switch1' incorporates:
         *  Abs: '<S2024>/Abs'
         *  Sum: '<S2024>/Sum7'
         *  Sum: '<S2024>/Sum8'
         */
        rtb_Switch1_bbr = fabsf(rtb_Switch_cp2 + rtb_Multiplication1_gld) +
            (rtb_MinMax_hj + rtb_MinMax_bd);
    }

    /* End of Switch: '<S2037>/Switch1' */

    /* Product: '<S2006>/Product1' incorporates:
     *  Constant: '<S1982>/Calib'
     */
    rtb_Product1_lj = rtb_Switch1_n5 / HeESSR_t_MedTEB_dT;

    /* Switch: '<S2038>/Switch1' incorporates:
     *  Constant: '<S2035>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S2038>/Switch1' incorporates:
         *  Constant: '<S2036>/Calib'
         *  Gain: '<S2024>/Gain1'
         */
        rtb_Switch1_mo = -HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S2024>/Sum11' incorporates:
         *  DataStoreRead: '<S1876>/Dsr_InputAcceltnProf'
         *  Sum: '<S2024>/Sum13'
         */
        rtb_Switch_cp2 = VeESSR_dn_InputAcceltnProf_DS - rtb_MinMax_bd;

        /* Abs: '<S2024>/Abs2' incorporates:
         *  Sum: '<S2024>/Sum11'
         */
        rtb_MinMax_hj = (rtb_Switch_cp2 - rtb_Switch1_n5) +
            rtb_Multiplication1_gld;

        /* MinMax: '<S2024>/MinMax1' incorporates:
         *  Abs: '<S2024>/Abs3'
         *  Constant: '<S1982>/Calib'
         *  Constant: '<S2024>/Constant Value1'
         *  Constant: '<S2024>/Constant Value2'
         *  DataStoreRead: '<S1876>/Data Store Read9'
         *  Product: '<S2024>/Product5'
         *  Product: '<S2024>/Product8'
         *  Product: '<S2042>/Prod'
         *  Sum: '<S2024>/Sum10'
         *  Sum: '<S2024>/Sum9'
         */
        rtb_MinMax_hj = fmaxf((fabsf((rtb_Sum2_jm -
            VeESSR_n_InputSpeedProfile_DS) - (HeESSR_t_MedTEB_dT * rtb_MinMax_bd))
                               * (rtb_Product1_lj * 2.0F)) - (rtb_MinMax_hj *
                               rtb_MinMax_hj), 0.0F);

        /* Switch: '<S2040>/Switch' incorporates:
         *  Sqrt: '<S2040>/Sqrt'
         */
        rtb_MinMax_hj = sqrtf(rtb_MinMax_hj);

        /* Switch: '<S2038>/Switch1' incorporates:
         *  Abs: '<S2024>/Abs2'
         *  Sum: '<S2024>/Sum12'
         *  Sum: '<S2024>/Sum13'
         */
        rtb_Switch1_mo = (rtb_MinMax_bd - rtb_MinMax_hj) - fabsf(rtb_Switch_cp2
            + rtb_Switch1_n5);
    }

    /* End of Switch: '<S2038>/Switch1' */

    /* Switch: '<S2006>/Switch1' incorporates:
     *  Constant: '<S2011>/Calib'
     *  Constant: '<S2012>/Calib'
     *  DataStoreRead: '<S1876>/Data Store Read2'
     *  DataStoreRead: '<S1876>/Dsr_InputSpeedProfile2'
     *  Logic: '<S2006>/Logical1'
     *  Logic: '<S2006>/Logical6'
     *  Logic: '<S2006>/Logical8'
     */
    if (((HeESSR_b_NiLmtBypsLoopJerk) && (VeESSR_b_NiMaxActive_DS)) ||
            ((VeESSR_b_NiDotMaxActive_DS) && (HeESSR_b_NiDotLmtBypsLoopJerk)))
    {
        /* Switch: '<S2006>/Switch1' */
        rtb_Switch1_n5 = rtb_Switch1_bbr;
    }
    else
    {
        /* Switch: '<S2006>/Switch1' incorporates:
         *  DataStoreRead: '<S1876>/Dsr_InputAcceltnProf'
         *  Sum: '<S2006>/Sum1'
         */
        rtb_Switch1_n5 += VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S2006>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S2006>/Limiter2' */
    /* Switch: '<S2019>/Switch1' incorporates:
     *  RelationalOperator: '<S2019>/Relational Operator'
     */
    if (rtb_Switch1_bbr < rtb_Switch1_n5)
    {
        /* Switch: '<S2017>/Switch1' */
        rtb_Switch1_n5 = rtb_Switch1_bbr;
    }

    /* End of Switch: '<S2019>/Switch1' */

    /* Switch: '<S2019>/Switch' incorporates:
     *  RelationalOperator: '<S2019>/Relational Operator1'
     */
    if (rtb_Switch1_n5 <= rtb_Switch1_mo)
    {
        /* Switch: '<S2019>/Switch' */
        rtb_Switch1_n5 = rtb_Switch1_mo;
    }

    /* End of Switch: '<S2019>/Switch' */
    /* End of Outputs for SubSystem: '<S2006>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S2006>/Limiter4' */
    /* Switch: '<S2021>/Switch1' incorporates:
     *  RelationalOperator: '<S2021>/Relational Operator'
     */
    if (VeESSR_dn_NiDotMax_StartEng < rtb_Switch1_n5)
    {
        /* Switch: '<S2017>/Switch1' */
        rtb_Switch1_n5 = VeESSR_dn_NiDotMax_StartEng;
    }

    /* End of Switch: '<S2021>/Switch1' */

    /* Switch: '<S2021>/Switch' incorporates:
     *  DataStoreRead: '<S1876>/Dsr_NiProfGenNiDMin'
     *  RelationalOperator: '<S2021>/Relational Operator1'
     */
    if (rtb_Switch1_n5 > VeESSR_dn_StrtTypNiDotMin_DS)
    {
        /* Switch: '<S2021>/Switch' */
        rtb_Switch_cp2 = rtb_Switch1_n5;
    }
    else
    {
        /* Switch: '<S2021>/Switch' */
        rtb_Switch_cp2 = VeESSR_dn_StrtTypNiDotMin_DS;
    }

    /* End of Switch: '<S2021>/Switch' */
    /* End of Outputs for SubSystem: '<S2006>/Limiter4' */

    /* Sum: '<S2010>/Sum6' incorporates:
     *  DataStoreRead: '<S1876>/Data Store Read9'
     */
    rtb_Sum6_ky = rtu_VeHSER_n_NiMax - VeESSR_n_InputSpeedProfile_DS;

    /* Abs: '<S2010>/Abs2' */
    rtb_MinMax_hj = fabsf(rtb_Sum6_ky);

    /* Switch: '<S2010>/Switch' incorporates:
     *  Constant: '<S2010>/Constant Value7'
     *  RelationalOperator: '<S2010>/Comparison2'
     */
    if (rtb_Sum6_ky < 0.0F)
    {
        /* Switch: '<S2017>/Switch1' incorporates:
         *  Abs: '<S2010>/Abs'
         */
        rtb_Switch1_n5 = fabsf(rtb_Product1_lj);
    }
    else
    {
        /* Switch: '<S2017>/Switch1' incorporates:
         *  Abs: '<S2010>/Abs1'
         *  Gain: '<S2010>/Gain'
         */
        rtb_Switch1_n5 = -fabsf(rtb_yyk1_p);
    }

    /* End of Switch: '<S2010>/Switch' */

    /* Product: '<S2010>/Product4' incorporates:
     *  Constant: '<S1982>/Calib'
     */
    rtb_Product4 = (rtb_Switch1_n5 * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2010>/Protected Division1' */
    /* Switch: '<S2033>/Switch1' incorporates:
     *  Constant: '<S2033>/Constant Value'
     *  Constant: '<S2033>/Constant Value1'
     *  Constant: '<S2033>/Constant Value2'
     *  Logic: '<S2033>/AND'
     *  RelationalOperator: '<S2033>/Greater Than or Equal '
     *  RelationalOperator: '<S2033>/Not Equal'
     *  RelationalOperator: '<S2033>/Not Equal1'
     *  Switch: '<S2033>/Switch2'
     */
    if ((rtb_MinMax_hj != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S2033>/Switch1' incorporates:
         *  Product: '<S2033>/Division'
         */
        rtb_MinMax_hj /= rtb_Product4;
    }
    else if (rtb_MinMax_hj > 0.0F)
    {
        /* Switch: '<S2033>/Switch2' incorporates:
         *  Constant: '<S2033>/MAXFLOAT'
         *  Switch: '<S2033>/Switch1'
         */
        rtb_MinMax_hj = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2033>/Switch1' incorporates:
         *  Constant: '<S2033>/Constant Value4'
         *  Switch: '<S2033>/Switch2'
         *  Switch: '<S2033>/Switch3'
         */
        rtb_MinMax_hj = 0.0F;
    }

    /* End of Switch: '<S2033>/Switch1' */
    /* End of Outputs for SubSystem: '<S2010>/Protected Division1' */

    /* Sum: '<S2010>/Sum4' incorporates:
     *  Abs: '<S2010>/Abs3'
     *  Constant: '<S2010>/Constant Value3'
     *  Constant: '<S2010>/Constant Value5'
     *  Product: '<S2010>/Product3'
     */
    rtb_MinMax_hj = (fabsf(rtb_MinMax_hj) * 8.0F) + 1.0F;

    /* Switch: '<S2034>/Switch' */
    if (rtb_MinMax_hj >= 0.0F)
    {
        /* MinMax: '<S2009>/MinMax1' incorporates:
         *  Sqrt: '<S2034>/Sqrt'
         */
        rtb_MinMax_hj = sqrtf(rtb_MinMax_hj);
    }
    else
    {
        /* MinMax: '<S2009>/MinMax1' incorporates:
         *  Constant: '<S2034>/Zero'
         */
        rtb_MinMax_hj = 0.0F;
    }

    /* End of Switch: '<S2034>/Switch' */

    /* MinMax: '<S2009>/MinMax1' incorporates:
     *  Constant: '<S2010>/Constant Value'
     *  Constant: '<S2010>/Constant Value4'
     *  Constant: '<S2010>/Constant Value6'
     *  MinMax: '<S2010>/MinMax1'
     *  Product: '<S2010>/Product2'
     *  Rounding: '<S2010>/Rounding1'
     *  Sum: '<S2010>/Sum3'
     */
    rtb_MinMax_hj = fmaxf(ceilf((rtb_MinMax_hj - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S2010>/Product' incorporates:
     *  Constant: '<S1982>/Calib'
     */
    rtb_Product4 = rtb_MinMax_hj * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2010>/Protected Division' */
    /* Switch: '<S2032>/Switch1' incorporates:
     *  Constant: '<S2032>/Constant Value'
     *  Constant: '<S2032>/Constant Value1'
     *  Constant: '<S2032>/Constant Value2'
     *  Constant: '<S2032>/Constant Value3'
     *  Logic: '<S2032>/AND'
     *  RelationalOperator: '<S2032>/Greater Than or Equal '
     *  RelationalOperator: '<S2032>/Greater Than or Equal 1'
     *  RelationalOperator: '<S2032>/Not Equal'
     *  RelationalOperator: '<S2032>/Not Equal1'
     *  Switch: '<S2032>/Switch2'
     *  Switch: '<S2032>/Switch3'
     */
    if ((rtb_Sum6_ky != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S2032>/Switch1' incorporates:
         *  Product: '<S2032>/Division'
         */
        rtb_Sum6_ky /= rtb_Product4;
    }
    else if (rtb_Sum6_ky > 0.0F)
    {
        /* Switch: '<S2032>/Switch2' incorporates:
         *  Constant: '<S2032>/MAXFLOAT'
         *  Switch: '<S2032>/Switch1'
         */
        rtb_Sum6_ky = 3.402823466E+38F;
    }
    else if (rtb_Sum6_ky < 0.0F)
    {
        /* Switch: '<S2032>/Switch3' incorporates:
         *  Constant: '<S2032>/MINFLOAT'
         *  Switch: '<S2032>/Switch1'
         *  Switch: '<S2032>/Switch2'
         */
        rtb_Sum6_ky = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2032>/Switch1' incorporates:
         *  Constant: '<S2032>/Constant Value4'
         *  Switch: '<S2032>/Switch2'
         *  Switch: '<S2032>/Switch3'
         */
        rtb_Sum6_ky = 0.0F;
    }

    /* End of Switch: '<S2032>/Switch1' */
    /* End of Outputs for SubSystem: '<S2010>/Protected Division' */

    /* Sum: '<S2010>/Sum' incorporates:
     *  Constant: '<S1982>/Calib'
     *  Constant: '<S2010>/Constant Value1'
     *  Constant: '<S2010>/Constant Value2'
     *  Product: '<S2010>/Product1'
     *  Sum: '<S2010>/Sum2'
     */
    rtb_MinMax_hj = rtb_Sum6_ky - (((0.5F * rtb_Switch1_n5) * (rtb_MinMax_hj -
        1.0F)) * HeESSR_t_MedTEB_dT);

    /* Switch: '<S2006>/Switch4' incorporates:
     *  Constant: '<S2013>/Calib'
     */
    if (!HeESSR_b_NiLmtForAccelByps)
    {
        /* Switch: '<S2006>/Switch4' incorporates:
         *  MinMax: '<S2006>/MinMax1'
         */
        rtb_Switch_cp2 = fminf(rtb_MinMax_hj, rtb_Switch_cp2);
    }

    /* End of Switch: '<S2006>/Switch4' */

    /* Outputs for Atomic SubSystem: '<S2006>/Limiter13' */
    /* RelationalOperator: '<S2018>/Relational Operator' */
    rtb_LogicalOperator3_m = (rtu_VeHSER_dn_NiDotMax <= rtb_Switch_cp2);

    /* Switch: '<S2018>/Switch1' */
    if (rtb_LogicalOperator3_m)
    {
        /* Switch: '<S2017>/Switch1' */
        rtb_Switch1_n5 = rtu_VeHSER_dn_NiDotMax;
    }
    else
    {
        /* Switch: '<S2017>/Switch1' */
        rtb_Switch1_n5 = rtb_Switch_cp2;
    }

    /* End of Switch: '<S2018>/Switch1' */

    /* Switch: '<S2018>/Switch' incorporates:
     *  RelationalOperator: '<S2018>/Relational Operator1'
     */
    if (rtb_Switch1_n5 <= rtu_VeHSER_dn_NiDotMin)
    {
        rtb_Switch1_n5 = rtu_VeHSER_dn_NiDotMin;
    }

    /* End of Switch: '<S2018>/Switch' */
    /* End of Outputs for SubSystem: '<S2006>/Limiter13' */

    /* Product: '<S2006>/Product9' incorporates:
     *  Constant: '<S1982>/Calib'
     */
    rtb_Switch_cp2 = rtb_Switch1_n5 * HeESSR_t_MedTEB_dT;

    /* Switch: '<S2006>/Switch2' incorporates:
     *  Constant: '<S2011>/Calib'
     *  DataStoreRead: '<S1876>/Dsr_InputSpeedProfile3'
     *  Logic: '<S2006>/Logical3'
     */
    if ((HeESSR_b_NiDotLmtBypsLoopJerk) && (VeESSR_b_NiDotMinActive_DS))
    {
        /* Switch: '<S2006>/Switch2' */
        rtb_Switch1_n5 = rtb_Switch1_mo;
    }
    else
    {
        /* Switch: '<S2006>/Switch2' incorporates:
         *  DataStoreRead: '<S1876>/Dsr_InputAcceltnProf'
         *  Sum: '<S2006>/Sum16'
         */
        rtb_Switch1_n5 = VeESSR_dn_InputAcceltnProf_DS + rtb_Multiplication1_gld;
    }

    /* End of Switch: '<S2006>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S2006>/Limiter' */
    /* Switch: '<S2016>/Switch1' incorporates:
     *  RelationalOperator: '<S2016>/Relational Operator'
     */
    if (rtb_Switch1_bbr < rtb_Switch1_n5)
    {
        /* Switch: '<S2017>/Switch1' */
        rtb_Switch1_n5 = rtb_Switch1_bbr;
    }

    /* End of Switch: '<S2016>/Switch1' */

    /* Switch: '<S2016>/Switch' incorporates:
     *  RelationalOperator: '<S2016>/Relational Operator1'
     */
    if (rtb_Switch1_n5 <= rtb_Switch1_mo)
    {
        /* Switch: '<S2016>/Switch' */
        rtb_Switch1_n5 = rtb_Switch1_mo;
    }

    /* End of Switch: '<S2016>/Switch' */
    /* End of Outputs for SubSystem: '<S2006>/Limiter' */

    /* Outputs for Atomic SubSystem: '<S2006>/Limiter3' */
    /* Switch: '<S2020>/Switch1' incorporates:
     *  RelationalOperator: '<S2020>/Relational Operator'
     */
    if (VeESSR_dn_NiDotMax_StartEng < rtb_Switch1_n5)
    {
        /* Switch: '<S2017>/Switch1' */
        rtb_Switch1_n5 = VeESSR_dn_NiDotMax_StartEng;
    }

    /* End of Switch: '<S2020>/Switch1' */
    /* End of Outputs for SubSystem: '<S2006>/Limiter3' */

    /* Switch: '<S2006>/Switch5' incorporates:
     *  Constant: '<S2013>/Calib'
     *  DataStoreRead: '<S1876>/Dsr_NiProfGenNiDMin'
     *  RelationalOperator: '<S2020>/Relational Operator1'
     *  Switch: '<S2020>/Switch'
     */
    if (HeESSR_b_NiLmtForAccelByps)
    {
        /* Outputs for Atomic SubSystem: '<S2006>/Limiter3' */
        /* Switch: '<S2020>/Switch' incorporates:
         *  DataStoreRead: '<S1876>/Dsr_NiProfGenNiDMin'
         *  RelationalOperator: '<S2020>/Relational Operator1'
         */
        if (rtb_Switch1_n5 <= VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S2006>/Switch5' */
            rtb_Switch1_n5 = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Outputs for SubSystem: '<S2006>/Limiter3' */
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S2006>/Limiter3' */
        if (rtb_Switch1_n5 <= VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S2020>/Switch' incorporates:
             *  DataStoreRead: '<S1876>/Dsr_NiProfGenNiDMin'
             */
            rtb_Switch1_n5 = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Outputs for SubSystem: '<S2006>/Limiter3' */

        /* Switch: '<S2006>/Switch5' incorporates:
         *  MinMax: '<S2006>/MinMax2'
         */
        rtb_Switch1_n5 = fminf(rtb_MinMax_hj, rtb_Switch1_n5);
    }

    /* End of Switch: '<S2006>/Switch5' */

    /* Outputs for Atomic SubSystem: '<S2006>/Limiter9' */
    /* Switch: '<S2023>/Switch1' incorporates:
     *  RelationalOperator: '<S2023>/Relational Operator'
     */
    if (rtu_VeHSER_dn_NiDotMax <= rtb_Switch1_n5)
    {
        /* Switch: '<S2017>/Switch1' */
        rtb_Switch1_n5 = rtu_VeHSER_dn_NiDotMax;
    }

    /* End of Switch: '<S2023>/Switch1' */

    /* RelationalOperator: '<S2022>/Relational Operator1' incorporates:
     *  RelationalOperator: '<S2023>/Relational Operator1'
     */
    rtb_Switch1_gw = (rtb_Switch1_n5 > rtu_VeHSER_dn_NiDotMin);

    /* Logic: '<S2023>/Logical2' */
    rtb_OR1_pe = !rtb_Switch1_gw;

    /* Switch: '<S2023>/Switch' */
    if (!rtb_Switch1_gw)
    {
        rtb_Switch1_n5 = rtu_VeHSER_dn_NiDotMin;
    }

    /* End of Switch: '<S2023>/Switch' */
    /* End of Outputs for SubSystem: '<S2006>/Limiter9' */

    /* Product: '<S2006>/Product10' incorporates:
     *  Constant: '<S1982>/Calib'
     */
    rtb_Multiplication1_gld = rtb_Switch1_n5 * HeESSR_t_MedTEB_dT;

    /* Sum: '<S2006>/Sum2' incorporates:
     *  DataStoreRead: '<S1876>/Data Store Read9'
     */
    rtb_Switch1_bbr = rtb_Sum2_jm - VeESSR_n_InputSpeedProfile_DS;

    /* Sum: '<S2009>/Sum6' incorporates:
     *  Constant: '<S1982>/Calib'
     *  DataStoreRead: '<S1876>/Data Store Read9'
     *  Product: '<S2009>/Product7'
     *  Sum: '<S2006>/Sum6'
     *  Switch: '<S2006>/Switch3'
     */
    rtb_Sum2_jm = (rtb_Sum2_jm - VeESSR_n_InputSpeedProfile_DS) - (rtb_MinMax_bd
        * HeESSR_t_MedTEB_dT);

    /* Abs: '<S2009>/Abs2' incorporates:
     *  Sum: '<S2009>/Sum6'
     */
    rtb_MinMax_hj = fabsf(rtb_Sum2_jm);

    /* Switch: '<S2009>/Switch' incorporates:
     *  Constant: '<S2009>/Constant Value7'
     *  RelationalOperator: '<S2009>/Comparison2'
     *  Sum: '<S2009>/Sum6'
     */
    if (rtb_Sum2_jm < 0.0F)
    {
        /* Switch: '<S2017>/Switch1' incorporates:
         *  Abs: '<S2009>/Abs'
         */
        rtb_Switch1_n5 = fabsf(rtb_Product1_lj);
    }
    else
    {
        /* Switch: '<S2017>/Switch1' incorporates:
         *  Abs: '<S2009>/Abs1'
         *  Gain: '<S2009>/Gain'
         */
        rtb_Switch1_n5 = -fabsf(rtb_yyk1_p);
    }

    /* End of Switch: '<S2009>/Switch' */

    /* Product: '<S2009>/Product4' incorporates:
     *  Constant: '<S1982>/Calib'
     */
    rtb_yyk1_p = (rtb_Switch1_n5 * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2009>/Protected Division1' */
    /* Switch: '<S2029>/Switch1' incorporates:
     *  Constant: '<S2029>/Constant Value'
     *  Constant: '<S2029>/Constant Value1'
     *  Constant: '<S2029>/Constant Value2'
     *  Logic: '<S2029>/AND'
     *  RelationalOperator: '<S2029>/Greater Than or Equal '
     *  RelationalOperator: '<S2029>/Not Equal'
     *  RelationalOperator: '<S2029>/Not Equal1'
     *  Switch: '<S2029>/Switch2'
     */
    if ((rtb_MinMax_hj != 0.0F) && (rtb_yyk1_p != 0.0F))
    {
        /* Switch: '<S2029>/Switch1' incorporates:
         *  Product: '<S2029>/Division'
         */
        rtb_yyk1_p = rtb_MinMax_hj / rtb_yyk1_p;
    }
    else if (rtb_MinMax_hj > 0.0F)
    {
        /* Switch: '<S2029>/Switch2' incorporates:
         *  Constant: '<S2029>/MAXFLOAT'
         *  Switch: '<S2029>/Switch1'
         */
        rtb_yyk1_p = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2029>/Switch1' incorporates:
         *  Constant: '<S2029>/Constant Value4'
         *  Switch: '<S2029>/Switch2'
         *  Switch: '<S2029>/Switch3'
         */
        rtb_yyk1_p = 0.0F;
    }

    /* End of Switch: '<S2029>/Switch1' */
    /* End of Outputs for SubSystem: '<S2009>/Protected Division1' */

    /* Sum: '<S2009>/Sum4' incorporates:
     *  Abs: '<S2009>/Abs3'
     *  Constant: '<S2009>/Constant Value3'
     *  Constant: '<S2009>/Constant Value5'
     *  Product: '<S2009>/Product3'
     */
    rtb_yyk1_p = (fabsf(rtb_yyk1_p) * 8.0F) + 1.0F;

    /* Switch: '<S2030>/Switch' incorporates:
     *  Constant: '<S2030>/Zero'
     *  Sqrt: '<S2030>/Sqrt'
     */
    if (rtb_yyk1_p >= 0.0F)
    {
        rtb_yyk1_p = sqrtf(rtb_yyk1_p);
    }
    else
    {
        rtb_yyk1_p = 0.0F;
    }

    /* End of Switch: '<S2030>/Switch' */

    /* MinMax: '<S2009>/MinMax1' incorporates:
     *  Constant: '<S2009>/Constant Value'
     *  Constant: '<S2009>/Constant Value4'
     *  Constant: '<S2009>/Constant Value6'
     *  Product: '<S2009>/Product2'
     *  Rounding: '<S2009>/Rounding1'
     *  Sum: '<S2009>/Sum3'
     */
    rtb_MinMax_hj = fmaxf(ceilf((rtb_yyk1_p - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S2009>/Product' incorporates:
     *  Constant: '<S1982>/Calib'
     */
    rtb_yyk1_p = rtb_MinMax_hj * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2009>/Protected Division' */
    /* Switch: '<S2028>/Switch1' incorporates:
     *  Constant: '<S2028>/Constant Value'
     *  Constant: '<S2028>/Constant Value1'
     *  Constant: '<S2028>/Constant Value2'
     *  Constant: '<S2028>/Constant Value3'
     *  Logic: '<S2028>/AND'
     *  RelationalOperator: '<S2028>/Greater Than or Equal '
     *  RelationalOperator: '<S2028>/Greater Than or Equal 1'
     *  RelationalOperator: '<S2028>/Not Equal'
     *  RelationalOperator: '<S2028>/Not Equal1'
     *  Sum: '<S2009>/Sum6'
     *  Switch: '<S2028>/Switch2'
     *  Switch: '<S2028>/Switch3'
     */
    if ((rtb_Sum2_jm != 0.0F) && (rtb_yyk1_p != 0.0F))
    {
        /* Switch: '<S2028>/Switch1' incorporates:
         *  Product: '<S2028>/Division'
         */
        rtb_yyk1_p = rtb_Sum2_jm / rtb_yyk1_p;
    }
    else if (rtb_Sum2_jm > 0.0F)
    {
        /* Switch: '<S2028>/Switch2' incorporates:
         *  Constant: '<S2028>/MAXFLOAT'
         *  Switch: '<S2028>/Switch1'
         */
        rtb_yyk1_p = 3.402823466E+38F;
    }
    else if (rtb_Sum2_jm < 0.0F)
    {
        /* Switch: '<S2028>/Switch3' incorporates:
         *  Constant: '<S2028>/MINFLOAT'
         *  Switch: '<S2028>/Switch1'
         *  Switch: '<S2028>/Switch2'
         */
        rtb_yyk1_p = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2028>/Switch1' incorporates:
         *  Constant: '<S2028>/Constant Value4'
         *  Switch: '<S2028>/Switch2'
         *  Switch: '<S2028>/Switch3'
         */
        rtb_yyk1_p = 0.0F;
    }

    /* End of Switch: '<S2028>/Switch1' */
    /* End of Outputs for SubSystem: '<S2009>/Protected Division' */

    /* Switch: '<S2006>/Switch3' incorporates:
     *  Constant: '<S2014>/Calib'
     */
    if (!HeESSR_b_TrnstnJerkByps)
    {
        /* Switch: '<S2006>/Switch8' incorporates:
         *  Constant: '<S2006>/Constant Value7'
         *  RelationalOperator: '<S2006>/Comparison'
         */
        if (rtb_Sum2_jm > 0.0F)
        {
            /* Switch: '<S2006>/Switch3' incorporates:
             *  Constant: '<S1982>/Calib'
             *  Constant: '<S2009>/Constant Value1'
             *  Constant: '<S2009>/Constant Value2'
             *  MinMax: '<S2006>/MinMax4'
             *  Product: '<S2006>/Product5'
             *  Product: '<S2009>/Product1'
             *  Sum: '<S2009>/Sum'
             *  Sum: '<S2009>/Sum2'
             *  Switch: '<S2006>/Switch8'
             */
            rtb_Switch1_bbr = fminf(rtb_Switch1_bbr, ((rtb_yyk1_p +
                rtb_MinMax_bd) - (((0.5F * rtb_Switch1_n5) * (rtb_MinMax_hj -
                1.0F)) * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }
        else
        {
            /* Switch: '<S2006>/Switch3' incorporates:
             *  Constant: '<S1982>/Calib'
             *  Constant: '<S2009>/Constant Value1'
             *  Constant: '<S2009>/Constant Value2'
             *  MinMax: '<S2006>/MinMax5'
             *  Product: '<S2006>/Product2'
             *  Product: '<S2009>/Product1'
             *  Sum: '<S2009>/Sum'
             *  Sum: '<S2009>/Sum2'
             *  Switch: '<S2006>/Switch8'
             */
            rtb_Switch1_bbr = fmaxf(rtb_Switch1_bbr, ((rtb_yyk1_p +
                rtb_MinMax_bd) - (((0.5F * rtb_Switch1_n5) * (rtb_MinMax_hj -
                1.0F)) * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }

        /* End of Switch: '<S2006>/Switch8' */
    }

    /* Outputs for Atomic SubSystem: '<S2006>/Limiter6' */
    /* RelationalOperator: '<S2022>/Relational Operator' */
    rtb_Logical15 = (rtb_Switch_cp2 <= rtb_Switch1_bbr);

    /* Switch: '<S2022>/Switch1' */
    if (rtb_Logical15)
    {
        /* Switch: '<S2017>/Switch1' */
        rtb_Switch1_n5 = rtb_Switch_cp2;
    }
    else
    {
        /* Switch: '<S2017>/Switch1' */
        rtb_Switch1_n5 = rtb_Switch1_bbr;
    }

    /* End of Switch: '<S2022>/Switch1' */

    /* RelationalOperator: '<S2022>/Relational Operator1' */
    rtb_Switch1_gw = (rtb_Switch1_n5 > rtb_Multiplication1_gld);

    /* Switch: '<S2022>/Switch' */
    if (rtb_Switch1_gw)
    {
        rtb_Multiplication1_gld = rtb_Switch1_n5;
    }

    /* End of Switch: '<S2022>/Switch' */
    /* End of Outputs for SubSystem: '<S2006>/Limiter6' */

    /* Sum: '<S2006>/Sum4' incorporates:
     *  DataStoreRead: '<S1876>/Data Store Read9'
     */
    rtb_Switch1_n5 = rtb_Multiplication1_gld + VeESSR_n_InputSpeedProfile_DS;

    /* Outputs for Atomic SubSystem: '<S2006>/Limiter1' */
    /* RelationalOperator: '<S2017>/Relational Operator' incorporates:
     *  DataStoreWrite: '<S1876>/Dsw_InputSpeedProfile5'
     */
    VeESSR_b_NiMaxActive_DS = (rtu_VeHSER_n_NiMax <= rtb_Switch1_n5);

    /* Switch: '<S2017>/Switch1' incorporates:
     *  DataStoreWrite: '<S1876>/Dsw_InputSpeedProfile5'
     */
    if (VeESSR_b_NiMaxActive_DS)
    {
        /* Switch: '<S2017>/Switch1' */
        rtb_Switch1_n5 = rtu_VeHSER_n_NiMax;
    }

    /* End of Switch: '<S2017>/Switch1' */

    /* Switch: '<S2017>/Switch' incorporates:
     *  Constant: '<S2006>/Constant Value4'
     *  RelationalOperator: '<S2017>/Relational Operator1'
     */
    if (rtb_Switch1_n5 <= 0.0F)
    {
        /* Switch: '<S2017>/Switch' */
        rtb_Switch1_n5 = 0.0F;
    }

    /* End of Switch: '<S2017>/Switch' */
    /* End of Outputs for SubSystem: '<S2006>/Limiter1' */

    /* Product: '<S2006>/Product3' incorporates:
     *  Constant: '<S1982>/Calib'
     *  DataStoreRead: '<S1876>/Data Store Read9'
     *  Sum: '<S2006>/Sum'
     */
    rtb_Sum2_jm = (rtb_Switch1_n5 - VeESSR_n_InputSpeedProfile_DS) /
        HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1876>/ProfArb' */
#if Rte_SysCon_Variant_ESSR_LQIR

    /* Outputs for Atomic SubSystem: '<S1989>/LQIR' */
    /* Outputs for Atomic SubSystem: '<S2000>/Signal Latch On With Reset' */
    /* Logic: '<S2003>/OR1' incorporates:
     *  Constant: '<S2001>/Constant'
     *  Logic: '<S2003>/NOT'
     *  Logic: '<S2003>/OR'
     *  RelationalOperator: '<S2000>/Relational Operator'
     *  UnitDelay: '<S2003>/Unit Delay'
     */
    rtb_Equal2_o = ((((uint32)rtu_VeENGR_e_ETRQ_Mode) == CeENGR_e_Idle) ||
                    ((!rtb_Equal2_o) && (localDW->UnitDelay_DSTATE_k)));

    /* Update for UnitDelay: '<S2003>/Unit Delay' */
    localDW->UnitDelay_DSTATE_k = rtb_Equal2_o;

    /* End of Outputs for SubSystem: '<S2000>/Signal Latch On With Reset' */

    /* Switch: '<S2000>/Switch1' incorporates:
     *  Switch: '<S2000>/Switch14'
     */
    if (rtb_Equal2_o)
    {
        /* VariantMerge generated from: '<S1989>/NiDotProf' */
        rtb_VariantMergeForOutportNiDot = rtb_Sum2_jm;

        /* VariantMerge generated from: '<S1989>/NiProf' */
        rtb_VariantMergeForOutportNiPro = rtb_Switch1_n5;
    }
    else
    {
        /* VariantMerge generated from: '<S1989>/NiDotProf' incorporates:
         *  Constant: '<S2000>/Constant'
         */
        rtb_VariantMergeForOutportNiDot = 0.0F;

        /* VariantMerge generated from: '<S1989>/NiProf' incorporates:
         *  Constant: '<S2002>/Calib'
         *  Sum: '<S2000>/Add'
         */
        rtb_VariantMergeForOutportNiPro = rtu_VeESSR_n_TransInSpdFlt +
            KeESSR_n_ActNiDeltaLQIR;
    }

    /* End of Switch: '<S2000>/Switch1' */
    /* End of Outputs for SubSystem: '<S1989>/LQIR' */
#else

    /* Outputs for Atomic SubSystem: '<S1989>/Default' */
    /* VariantMerge generated from: '<S1989>/NiProf' incorporates:
     *  Inport: '<S1999>/ShapeNi'
     */
    rtb_VariantMergeForOutportNiPro = rtb_Switch1_n5;

    /* VariantMerge generated from: '<S1989>/NiDotProf' incorporates:
     *  Inport: '<S1999>/ShapeNiD'
     */
    rtb_VariantMergeForOutportNiDot = rtb_Sum2_jm;

    /* End of Outputs for SubSystem: '<S1989>/Default' */
#endif

    /* End of Outputs for SubSystem: '<S1876>/ProfArb' */

    /* DataStoreWrite: '<S1876>/Dsw_InputAcceltnProf' */
    VeESSR_dn_InputAcceltnProf_DS = rtb_VariantMergeForOutportNiDot;

    /* DataStoreWrite: '<S1876>/Dsw_InputSpeedProfile' */
    VeESSR_n_InputSpeedProfile_DS = rtb_VariantMergeForOutportNiPro;

    /* Logic: '<S2006>/Logical2' incorporates:
     *  DataStoreWrite: '<S1876>/Dsw_InputSpeedProfile1'
     */
    VeESSR_b_NiDotMaxActive_DS = (rtb_LogicalOperator3_m && rtb_Logical15);

    /* DataStoreWrite: '<S1876>/Dsw_InputSpeedProfile2' */
    VeESSR_n_TargetSpeed_DS = rtb_Maximum1;

    /* DataStoreWrite: '<S1876>/Dsw_InputSpeedProfile3' */
    VeESSR_dn_TargetAcceltn_DS = rtb_MinMax_bd;

    /* Outputs for Atomic SubSystem: '<S2006>/Limiter6' */
    /* Logic: '<S2006>/Logical' incorporates:
     *  DataStoreWrite: '<S1876>/Dsw_InputSpeedProfile4'
     *  Logic: '<S2022>/Logical2'
     */
    VeESSR_b_NiDotMinActive_DS = (rtb_OR1_pe && (!rtb_Switch1_gw));

    /* End of Outputs for SubSystem: '<S2006>/Limiter6' */

    /* DataStoreWrite: '<S1876>/Dsw_Ni1stFlt_DS' */
    VeESSR_n_Ni1stFlt_DS = rtb_Summation_ep;

    /* Sum: '<S2006>/Sum17' */
    VeESSR_dn_InputJerkProfStartEng = rtb_Sum2_jm - rtb_MinMax1_ow;

    /* If: '<S1864>/If' */
    if (rtb_OR1_pw)
    {
        /* Outputs for IfAction SubSystem: '<S1855>/ESSC_PBatBoostReset' incorporates:
         *  ActionPort: '<S1865>/Action Port'
         */
        ESSR_ac_ESSC_PBatBoostReset();

        /* End of Outputs for SubSystem: '<S1855>/ESSC_PBatBoostReset' */
    }

    /* End of If: '<S1864>/If' */

    /* Update for UnitDelay: '<S2025>/Unit Delay' incorporates:
     *  Switch: '<S2025>/Switch3'
     */
    localDW->UnitDelay_DSTATE = rtb_Maximum2_a;

    /* Update for Delay: '<S2006>/IntegerDelay' */
    localDW->icLoad = 0U;
    for (i = 0; i < 15; i++)
    {
        localDW->IntegerDelay_DSTATE[i] = localDW->IntegerDelay_DSTATE[i + 1];
    }

    localDW->IntegerDelay_DSTATE[15] = rtb_Maximum1;

    /* End of Update for Delay: '<S2006>/IntegerDelay' */
}

#endif

/* Output and update for function-call system: '<S554>/ESSC_AchEngIdleEnt' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_AchEngIdleEnt(void)
{
    /* Switch: '<S733>/Switch1' incorporates:
     *  Constant: '<S731>/Constant'
     *  DataStoreRead: '<S669>/Dsr_EngStrtType'
     *  DataStoreRead: '<S669>/Dsr_InputSpeedProfile1'
     *  DataStoreWrite: '<S669>/Dsw_Ni1stFlt'
     *  RelationalOperator: '<S669>/Comparison4'
     */
    if (((uint32)VeESSR_e_EngStrtProfType_DS) == CeESSR_e_LowPwrAlgo)
    {
        VeESSR_n_Ni1stFlt_DS = VeESSR_n_InputSpeedProfile_DS;
    }

    /* End of Switch: '<S733>/Switch1' */

    /* DataStoreWrite: '<S669>/Dsw_EngStartStopSt' incorporates:
     *  Constant: '<S729>/Constant'
     */
    VeESSR_e_EngStartStopSt_DS = CeESSR_e_AchEngIdleSt;

    /* DataStoreWrite: '<S669>/Data Store Write1' incorporates:
     *  Constant: '<S669>/Constant Value2'
     */
    VeESSR_M_EngStrtTorq_DS = 0.0F;

    /* DataStoreWrite: '<S669>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
     *  Constant: '<S734>/Calib'
     */
    VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

    /* DataStoreWrite: '<S669>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
     *  Constant: '<S735>/Calib'
     */
    VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

    /* DataStoreWrite: '<S669>/Dsw_EngStrtStpMd2' incorporates:
     *  Constant: '<S737>/Calib'
     */
    VeESSR_e_EngStrtStpMd_DS = KeESSR_e_MdInAchEngIdleSt;

    /* DataStoreWrite: '<S669>/Dsw_EngStrtType1' incorporates:
     *  Constant: '<S732>/Constant'
     */
    VeESSR_e_TCM_StartStopType_DS = CeESSR_e_NoAction;

    /* DataStoreWrite: '<S669>/Dsw_InhibitShiftToMode' incorporates:
     *  Constant: '<S736>/Calib'
     */
    VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtAchIdleSt;

    /* DataStoreWrite: '<S669>/Dsw_InputSpeedProfile1' incorporates:
     *  Constant: '<S739>/Calib'
     */
    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

    /* DataStoreWrite: '<S669>/Dsw_StrtStpFailDTC' incorporates:
     *  Constant: '<S730>/Constant'
     */
    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

    /* DataStoreWrite: '<S669>/Dsw_TransFldPmpSel' incorporates:
     *  Constant: '<S738>/Calib'
     */
    VeESSR_e_TransFldPmpSel_DS = KeESSR_e_TransFldPmpSelAchEngIdleSt;
}

#endif

/* System initialize for function-call system: '<S554>/ESSC_AchEngIdleDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_AchEngIdleDur_Init(P2VAR
    (DW_ESSC_AchEngIdleDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW)
{
    /* InitializeConditions for Delay: '<S692>/IntegerDelay' */
    localDW->icLoad = 1U;
}

#endif

/* Output and update for function-call system: '<S554>/ESSC_AchEngIdleDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_AchEngIdleDur(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_OptEngTrqReq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_OptInputSpd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeENGR_T_EngCoolantTemp, VAR(float32, AUTOMATIC) rtu_VeHSER_n_NiMax, VAR
    (float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMax, VAR(float32, AUTOMATIC)
    rtu_VeHSER_dn_NiDotMin, P2VAR(DW_ESSC_AchEngIdleDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(ZCE_ESSC_AchEngIdleDur_ESSR_a_T, AUTOMATIC,
    ESSR_VAR_INIT) localZCE)
{
    sint32 i;
    float32 rtb_Abs_kj;
    float32 rtb_Gain1_p;
    float32 rtb_Gain_d2;
    float32 rtb_Gain_px;
    float32 rtb_IntegerDelay;
    float32 rtb_MinMax1_h;
    float32 rtb_Product4;
    float32 rtb_Product4_g;
    float32 rtb_Sum15;
    float32 rtb_Sum2_af;
    float32 rtb_Sum6_o1;
    float32 rtb_Summation_em;
    float32 rtb_Summation_i;
    float32 rtb_Switch1_ca;
    float32 rtb_Switch1_g25;
    float32 rtb_Switch_mq;
    uint8 tmp;
    boolean rtb_Logical2_ko;
    boolean rtb_RelationalOperator1_dki;
    boolean rtb_RelationalOperator_acd;
    boolean rtb_RelationalOperator_nx;

    /* MinMax: '<S695>/MinMax1' incorporates:
     *  Constant: '<S679>/Calib'
     *  MinMax: '<S668>/Maximum1'
     */
    rtb_MinMax1_h = fmaxf(rtu_VeESSR_M_OptEngTrqReq, KeESSR_M_MinStartDetectTorq);

    /* DataStoreWrite: '<S668>/Dsw_EngTrqReqImmed' incorporates:
     *  Constant: '<S678>/Calib'
     *  DataStoreRead: '<S668>/Dsr_EngTrqReqPrdtd1'
     *  Product: '<S673>/Multiplication'
     *  Sum: '<S673>/Subtraction'
     *  Sum: '<S673>/Subtraction1'
     */
    VeESSR_M_EngTrqReqImmed_DS = ((rtb_MinMax1_h - VeESSR_M_EngTrqReqImmed_DS) *
        KeESSR_K_AchIdleEngCmdFlt) + VeESSR_M_EngTrqReqImmed_DS;

    /* DataStoreWrite: '<S668>/Dsw_EngTrqReqPrdtd1' incorporates:
     *  Constant: '<S678>/Calib'
     *  DataStoreRead: '<S668>/Dsr_EngTrqReqPrdtd3'
     *  Product: '<S672>/Multiplication'
     *  Sum: '<S672>/Subtraction'
     *  Sum: '<S672>/Subtraction1'
     */
    VeESSR_M_EngTrqReqPrdtd_DS = ((rtb_MinMax1_h - VeESSR_M_EngTrqReqPrdtd_DS) *
        KeESSR_K_AchIdleEngCmdFlt) + VeESSR_M_EngTrqReqPrdtd_DS;

    /* Gain: '<S687>/Gain' incorporates:
     *  Abs: '<S687>/Abs1'
     *  DataStoreRead: '<S668>/Dsr_NiProfGenDNiDLim1'
     */
    rtb_Gain_px = -fabsf(VeESSR_dn_StrtTypJerkMin_DS);

    /* Product: '<S692>/Product4' incorporates:
     *  Constant: '<S676>/Calib'
     */
    rtb_Product4 = rtb_Gain_px / HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S687>/LowpassT Reset Enabled' */
    /* Sum: '<S690>/Summation' incorporates:
     *  Constant: '<S676>/Calib'
     *  DataStoreRead: '<S668>/Dsr_MinEngStrtSpd'
     *  DataStoreRead: '<S668>/Dsr_Ni1stFlt_DS'
     *  DataStoreRead: '<S668>/Dsr_NiProfGenT2Gain'
     *  MinMax: '<S668>/Maximum3'
     *  MinMax: '<S690>/Maximum'
     *  Product: '<S690>/Multiplication'
     *  Product: '<S690>/Multiplication1'
     *  Sum: '<S690>/Subtraction'
     */
    rtb_Summation_em = (((fmaxf(rtu_VeESSR_n_OptInputSpd,
                           VeESSR_n_MinEngStrtSpd_DS) - VeESSR_n_Ni1stFlt_DS) *
                         HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                         (VeESSR_k_StrtTypScndOrdLwPassT_DS, HeESSR_t_MedTEB_dT)))
        + VeESSR_n_Ni1stFlt_DS;

    /* End of Outputs for SubSystem: '<S687>/LowpassT Reset Enabled' */

    /* Outputs for Atomic SubSystem: '<S687>/LowpassT Reset Enabled1' */
    /* Sum: '<S691>/Summation' incorporates:
     *  Constant: '<S676>/Calib'
     *  DataStoreRead: '<S668>/Dsr_InputSpeedProfile3'
     *  DataStoreRead: '<S668>/Dsr_NiProfGenT1Gain'
     *  MinMax: '<S691>/Maximum'
     *  Product: '<S691>/Multiplication'
     *  Product: '<S691>/Multiplication1'
     *  Sum: '<S691>/Subtraction'
     */
    rtb_Summation_i = (((rtb_Summation_em - VeESSR_n_InputSpeedProfile_DS) *
                        HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                        (VeESSR_k_StrtTypFrstOrdLwPassT_DS, HeESSR_t_MedTEB_dT)))
        + VeESSR_n_InputSpeedProfile_DS;

    /* End of Outputs for SubSystem: '<S687>/LowpassT Reset Enabled1' */

    /* RelationalOperator: '<S668>/Relational Operator' incorporates:
     *  Constant: '<S676>/Calib'
     *  DataStoreRead: '<S668>/Dsr_STMTmr'
     */
    rtb_RelationalOperator_acd = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

    /* Switch: '<S711>/Switch1' incorporates:
     *  UnitDelay: '<S711>/Unit Delay'
     */
    if (rtb_RelationalOperator_acd)
    {
        rtb_Gain1_p = rtb_Summation_i;
    }
    else
    {
        rtb_Gain1_p = localDW->UnitDelay_DSTATE;
    }

    /* End of Switch: '<S711>/Switch1' */

    /* Gain: '<S692>/Gain1' incorporates:
     *  Sum: '<S692>/Sum18'
     */
    rtb_Gain1_p = (rtb_Summation_i + rtb_Gain1_p) * 0.5F;

    /* Delay: '<S692>/IntegerDelay' incorporates:
     *  Constant: '<S701>/Calib'
     */
    if (rtb_RelationalOperator_acd && (((uint32)
            localZCE->IntegerDelay_Reset_ZCE_b) != POS_ZCSIG))
    {
        localDW->icLoad = 1U;
    }

    localZCE->IntegerDelay_Reset_ZCE_b = rtb_RelationalOperator_acd ?
        ((ZCSigState)1) : ((ZCSigState)0);
    if (((sint32)localDW->icLoad) != 0)
    {
        for (i = 0; i < 16; i++)
        {
            localDW->IntegerDelay_DSTATE[i] = rtb_Gain1_p;
        }
    }

    if (((sint32)KeESSR_Cnt_DelayOptNi) <= 0)
    {
        /* Delay: '<S692>/IntegerDelay' */
        rtb_IntegerDelay = rtb_Gain1_p;
    }
    else
    {
        if (((sint32)KeESSR_Cnt_DelayOptNi) > 16)
        {
            tmp = 16U;
        }
        else
        {
            tmp = KeESSR_Cnt_DelayOptNi;
        }

        /* Delay: '<S692>/IntegerDelay' */
        rtb_IntegerDelay = localDW->IntegerDelay_DSTATE[(uint8)(16U - ((uint32)
            tmp))];
    }

    /* End of Delay: '<S692>/IntegerDelay' */

    /* Sum: '<S692>/Sum15' incorporates:
     *  Abs: '<S692>/Abs4'
     *  Constant: '<S680>/Calib'
     *  DataStoreRead: '<S668>/Dsr_InputSpeedProfile5'
     */
    rtb_Sum15 = fabsf(VeESSR_dn_TargetAcceltn_DS) + KeESSR_dn_NiTargetJerkLimit;

    /* Outputs for Atomic SubSystem: '<S692>/GradientLimiter' */
    /* Sum: '<S694>/Sum2' incorporates:
     *  Constant: '<S676>/Calib'
     *  DataStoreRead: '<S668>/Dsr_InputSpeedProfile4'
     *  Product: '<S692>/Product6'
     *  Sum: '<S692>/Sum14'
     *  UnitDelay: '<S694>/Unit Delay'
     */
    rtb_Sum2_af = ((rtb_Gain1_p - VeESSR_n_TargetSpeed_DS) / HeESSR_t_MedTEB_dT)
        - localDW->UnitDelay_DSTATE_b;

    /* Outputs for Atomic SubSystem: '<S694>/Limiter' */
    /* Switch: '<S712>/Switch1' incorporates:
     *  RelationalOperator: '<S712>/Relational Operator'
     */
    if (rtb_Sum15 < rtb_Sum2_af)
    {
        /* MinMax: '<S695>/MinMax1' */
        rtb_MinMax1_h = rtb_Sum15;
    }
    else
    {
        /* MinMax: '<S695>/MinMax1' */
        rtb_MinMax1_h = rtb_Sum2_af;
    }

    /* End of Switch: '<S712>/Switch1' */

    /* Switch: '<S712>/Switch' incorporates:
     *  Gain: '<S692>/Gain'
     *  RelationalOperator: '<S712>/Relational Operator1'
     */
    if (rtb_MinMax1_h <= (-rtb_Sum15))
    {
        rtb_MinMax1_h = -rtb_Sum15;
    }

    /* End of Switch: '<S712>/Switch' */
    /* End of Outputs for SubSystem: '<S694>/Limiter' */

    /* Sum: '<S694>/Sum3' incorporates:
     *  UnitDelay: '<S694>/Unit Delay'
     */
    rtb_Gain_d2 = rtb_MinMax1_h + localDW->UnitDelay_DSTATE_b;

    /* Update for UnitDelay: '<S694>/Unit Delay' */
    localDW->UnitDelay_DSTATE_b = rtb_Gain_d2;

    /* End of Outputs for SubSystem: '<S692>/GradientLimiter' */

    /* Sum: '<S693>/Subtraction1' incorporates:
     *  Constant: '<S682>/Calib'
     *  DataStoreRead: '<S668>/Dsr_InputSpeedProfile5'
     *  Product: '<S693>/Multiplication'
     *  Sum: '<S693>/Subtraction'
     */
    rtb_Sum15 = ((rtb_Gain_d2 - VeESSR_dn_TargetAcceltn_DS) *
                 KeESSR_k_NiDotTargetFilt) + VeESSR_dn_TargetAcceltn_DS;

    /* DataStoreRead: '<S668>/Dsr_InputAcceltnProf' */
    rtb_Gain_d2 = VeESSR_dn_InputAcceltnProf_DS;

    /* Abs: '<S687>/Abs' incorporates:
     *  DataStoreRead: '<S668>/Dsr_NiProfGenDNiDLim'
     */
    rtb_Abs_kj = fabsf(VeESSR_dn_StrtTypJerkMax_DS);

    /* Switch: '<S723>/Switch1' incorporates:
     *  Constant: '<S721>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S723>/Switch1' incorporates:
         *  Constant: '<S722>/Calib'
         */
        rtb_Switch1_ca = HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S710>/Sum6' incorporates:
         *  DataStoreRead: '<S668>/Dsr_InputAcceltnProf'
         *  Sum: '<S710>/Sum8'
         */
        rtb_MinMax1_h = VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15;

        /* Abs: '<S710>/Abs' incorporates:
         *  Sum: '<S710>/Sum6'
         */
        rtb_Sum2_af = (rtb_MinMax1_h - rtb_Gain_px) + rtb_Abs_kj;

        /* MinMax: '<S710>/MinMax2' incorporates:
         *  Abs: '<S710>/Abs1'
         *  Constant: '<S676>/Calib'
         *  Constant: '<S710>/Constant Value'
         *  Constant: '<S710>/Constant Value3'
         *  DataStoreRead: '<S668>/Dsr_InputSpeedProfile3'
         *  Product: '<S710>/Product2'
         *  Product: '<S710>/Product7'
         *  Product: '<S725>/Prod'
         *  Sum: '<S710>/Sum3'
         *  Sum: '<S710>/Sum5'
         */
        rtb_Sum2_af = fmaxf((fabsf((rtb_IntegerDelay -
                               VeESSR_n_InputSpeedProfile_DS) -
                              (HeESSR_t_MedTEB_dT * rtb_Sum15)) * (rtb_Product4 *
                              -2.0F)) - (rtb_Sum2_af * rtb_Sum2_af), 0.0F);

        /* Switch: '<S727>/Switch' incorporates:
         *  Sqrt: '<S727>/Sqrt'
         */
        rtb_Sum2_af = sqrtf(rtb_Sum2_af);

        /* Switch: '<S723>/Switch1' incorporates:
         *  Abs: '<S710>/Abs'
         *  Sum: '<S710>/Sum7'
         *  Sum: '<S710>/Sum8'
         */
        rtb_Switch1_ca = fabsf(rtb_MinMax1_h + rtb_Gain_px) + (rtb_Sum2_af +
            rtb_Sum15);
    }

    /* End of Switch: '<S723>/Switch1' */

    /* Product: '<S692>/Product1' incorporates:
     *  Constant: '<S676>/Calib'
     */
    rtb_Sum2_af = rtb_Abs_kj / HeESSR_t_MedTEB_dT;

    /* Switch: '<S724>/Switch1' incorporates:
     *  Constant: '<S721>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S724>/Switch1' incorporates:
         *  Constant: '<S722>/Calib'
         *  Gain: '<S710>/Gain1'
         */
        rtb_Switch1_g25 = -HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S710>/Sum11' incorporates:
         *  DataStoreRead: '<S668>/Dsr_InputAcceltnProf'
         *  Sum: '<S710>/Sum13'
         */
        rtb_Switch_mq = VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15;

        /* Abs: '<S710>/Abs2' incorporates:
         *  Sum: '<S710>/Sum11'
         */
        rtb_MinMax1_h = (rtb_Switch_mq - rtb_Abs_kj) + rtb_Gain_px;

        /* MinMax: '<S710>/MinMax1' incorporates:
         *  Abs: '<S710>/Abs3'
         *  Constant: '<S676>/Calib'
         *  Constant: '<S710>/Constant Value1'
         *  Constant: '<S710>/Constant Value2'
         *  DataStoreRead: '<S668>/Dsr_InputSpeedProfile3'
         *  Product: '<S710>/Product5'
         *  Product: '<S710>/Product8'
         *  Product: '<S728>/Prod'
         *  Sum: '<S710>/Sum10'
         *  Sum: '<S710>/Sum9'
         */
        rtb_MinMax1_h = fmaxf((fabsf((rtb_IntegerDelay -
            VeESSR_n_InputSpeedProfile_DS) - (HeESSR_t_MedTEB_dT * rtb_Sum15)) *
                               (rtb_Sum2_af * 2.0F)) - (rtb_MinMax1_h *
                               rtb_MinMax1_h), 0.0F);

        /* Switch: '<S726>/Switch' incorporates:
         *  Sqrt: '<S726>/Sqrt'
         */
        rtb_MinMax1_h = sqrtf(rtb_MinMax1_h);

        /* Switch: '<S724>/Switch1' incorporates:
         *  Abs: '<S710>/Abs2'
         *  Sum: '<S710>/Sum12'
         *  Sum: '<S710>/Sum13'
         */
        rtb_Switch1_g25 = (rtb_Sum15 - rtb_MinMax1_h) - fabsf(rtb_Switch_mq +
            rtb_Abs_kj);
    }

    /* End of Switch: '<S724>/Switch1' */

    /* Switch: '<S692>/Switch1' incorporates:
     *  Constant: '<S697>/Calib'
     *  Constant: '<S698>/Calib'
     *  DataStoreRead: '<S668>/Data Store Read'
     *  DataStoreRead: '<S668>/Dsr_InputSpeedProfile1'
     *  Logic: '<S692>/Logical1'
     *  Logic: '<S692>/Logical6'
     *  Logic: '<S692>/Logical8'
     */
    if (((HeESSR_b_NiLmtBypsLoopJerk) && (VeESSR_b_NiMaxActive_DS)) ||
            ((VeESSR_b_NiDotMaxActive_DS) && (HeESSR_b_NiDotLmtBypsLoopJerk)))
    {
        /* Switch: '<S692>/Switch1' */
        rtb_Abs_kj = rtb_Switch1_ca;
    }
    else
    {
        /* Switch: '<S692>/Switch1' incorporates:
         *  DataStoreRead: '<S668>/Dsr_InputAcceltnProf'
         *  Sum: '<S692>/Sum1'
         */
        rtb_Abs_kj += VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S692>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S692>/Limiter2' */
    /* Switch: '<S705>/Switch1' incorporates:
     *  RelationalOperator: '<S705>/Relational Operator'
     */
    if (rtb_Switch1_ca < rtb_Abs_kj)
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = rtb_Switch1_ca;
    }

    /* End of Switch: '<S705>/Switch1' */

    /* Switch: '<S705>/Switch' incorporates:
     *  RelationalOperator: '<S705>/Relational Operator1'
     */
    if (rtb_Abs_kj <= rtb_Switch1_g25)
    {
        /* Switch: '<S705>/Switch' */
        rtb_Abs_kj = rtb_Switch1_g25;
    }

    /* End of Switch: '<S705>/Switch' */
    /* End of Outputs for SubSystem: '<S692>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S692>/Limiter4' */
    /* Switch: '<S707>/Switch1' incorporates:
     *  DataStoreRead: '<S668>/Dsr_NiProfGenNiDMax'
     *  RelationalOperator: '<S707>/Relational Operator'
     */
    if (VeESSR_dn_StrtTypNiDotMax_DS < rtb_Abs_kj)
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = VeESSR_dn_StrtTypNiDotMax_DS;
    }

    /* End of Switch: '<S707>/Switch1' */

    /* Switch: '<S707>/Switch' incorporates:
     *  DataStoreRead: '<S668>/Dsr_NiProfGenNiDMin'
     *  RelationalOperator: '<S707>/Relational Operator1'
     */
    if (rtb_Abs_kj > VeESSR_dn_StrtTypNiDotMin_DS)
    {
        /* Switch: '<S707>/Switch' */
        rtb_Switch_mq = rtb_Abs_kj;
    }
    else
    {
        /* Switch: '<S707>/Switch' */
        rtb_Switch_mq = VeESSR_dn_StrtTypNiDotMin_DS;
    }

    /* End of Switch: '<S707>/Switch' */
    /* End of Outputs for SubSystem: '<S692>/Limiter4' */

    /* Sum: '<S696>/Sum6' incorporates:
     *  DataStoreRead: '<S668>/Dsr_InputSpeedProfile3'
     */
    rtb_Sum6_o1 = rtu_VeHSER_n_NiMax - VeESSR_n_InputSpeedProfile_DS;

    /* Abs: '<S696>/Abs2' */
    rtb_Abs_kj = fabsf(rtb_Sum6_o1);

    /* Switch: '<S696>/Switch' incorporates:
     *  Constant: '<S696>/Constant Value7'
     *  RelationalOperator: '<S696>/Comparison2'
     */
    if (rtb_Sum6_o1 < 0.0F)
    {
        /* MinMax: '<S695>/MinMax1' incorporates:
         *  Abs: '<S696>/Abs'
         */
        rtb_MinMax1_h = fabsf(rtb_Sum2_af);
    }
    else
    {
        /* MinMax: '<S695>/MinMax1' incorporates:
         *  Abs: '<S696>/Abs1'
         *  Gain: '<S696>/Gain'
         */
        rtb_MinMax1_h = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S696>/Switch' */

    /* Product: '<S696>/Product4' incorporates:
     *  Constant: '<S676>/Calib'
     */
    rtb_Product4_g = (rtb_MinMax1_h * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S696>/Protected Division1' */
    /* Switch: '<S719>/Switch1' incorporates:
     *  Constant: '<S719>/Constant Value'
     *  Constant: '<S719>/Constant Value1'
     *  Constant: '<S719>/Constant Value2'
     *  Logic: '<S719>/AND'
     *  RelationalOperator: '<S719>/Greater Than or Equal '
     *  RelationalOperator: '<S719>/Not Equal'
     *  RelationalOperator: '<S719>/Not Equal1'
     *  Switch: '<S719>/Switch2'
     */
    if ((rtb_Abs_kj != 0.0F) && (rtb_Product4_g != 0.0F))
    {
        /* Switch: '<S719>/Switch1' incorporates:
         *  Product: '<S719>/Division'
         */
        rtb_Abs_kj /= rtb_Product4_g;
    }
    else if (rtb_Abs_kj > 0.0F)
    {
        /* Switch: '<S719>/Switch2' incorporates:
         *  Constant: '<S719>/MAXFLOAT'
         *  Switch: '<S719>/Switch1'
         */
        rtb_Abs_kj = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S719>/Switch1' incorporates:
         *  Constant: '<S719>/Constant Value4'
         *  Switch: '<S719>/Switch2'
         *  Switch: '<S719>/Switch3'
         */
        rtb_Abs_kj = 0.0F;
    }

    /* End of Switch: '<S719>/Switch1' */
    /* End of Outputs for SubSystem: '<S696>/Protected Division1' */

    /* Sum: '<S696>/Sum4' incorporates:
     *  Abs: '<S696>/Abs3'
     *  Constant: '<S696>/Constant Value3'
     *  Constant: '<S696>/Constant Value5'
     *  Product: '<S696>/Product3'
     */
    rtb_Abs_kj = (fabsf(rtb_Abs_kj) * 8.0F) + 1.0F;

    /* Switch: '<S720>/Switch' */
    if (rtb_Abs_kj >= 0.0F)
    {
        /* Lookup_n-D: '<S685>/Vector' incorporates:
         *  Sqrt: '<S720>/Sqrt'
         */
        rtb_Abs_kj = sqrtf(rtb_Abs_kj);
    }
    else
    {
        /* Lookup_n-D: '<S685>/Vector' incorporates:
         *  Constant: '<S720>/Zero'
         */
        rtb_Abs_kj = 0.0F;
    }

    /* End of Switch: '<S720>/Switch' */

    /* Lookup_n-D: '<S685>/Vector' incorporates:
     *  Constant: '<S696>/Constant Value'
     *  Constant: '<S696>/Constant Value4'
     *  Constant: '<S696>/Constant Value6'
     *  MinMax: '<S696>/MinMax1'
     *  Product: '<S696>/Product2'
     *  Rounding: '<S696>/Rounding1'
     *  Sum: '<S696>/Sum3'
     */
    rtb_Abs_kj = fmaxf(ceilf((rtb_Abs_kj - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S696>/Product' incorporates:
     *  Constant: '<S676>/Calib'
     */
    rtb_Product4_g = rtb_Abs_kj * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S696>/Protected Division' */
    /* Switch: '<S718>/Switch1' incorporates:
     *  Constant: '<S718>/Constant Value'
     *  Constant: '<S718>/Constant Value1'
     *  Constant: '<S718>/Constant Value2'
     *  Constant: '<S718>/Constant Value3'
     *  Logic: '<S718>/AND'
     *  RelationalOperator: '<S718>/Greater Than or Equal '
     *  RelationalOperator: '<S718>/Greater Than or Equal 1'
     *  RelationalOperator: '<S718>/Not Equal'
     *  RelationalOperator: '<S718>/Not Equal1'
     *  Switch: '<S718>/Switch2'
     *  Switch: '<S718>/Switch3'
     */
    if ((rtb_Sum6_o1 != 0.0F) && (rtb_Product4_g != 0.0F))
    {
        /* Switch: '<S718>/Switch1' incorporates:
         *  Product: '<S718>/Division'
         */
        rtb_Sum6_o1 /= rtb_Product4_g;
    }
    else if (rtb_Sum6_o1 > 0.0F)
    {
        /* Switch: '<S718>/Switch2' incorporates:
         *  Constant: '<S718>/MAXFLOAT'
         *  Switch: '<S718>/Switch1'
         */
        rtb_Sum6_o1 = 3.402823466E+38F;
    }
    else if (rtb_Sum6_o1 < 0.0F)
    {
        /* Switch: '<S718>/Switch3' incorporates:
         *  Constant: '<S718>/MINFLOAT'
         *  Switch: '<S718>/Switch1'
         *  Switch: '<S718>/Switch2'
         */
        rtb_Sum6_o1 = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S718>/Switch1' incorporates:
         *  Constant: '<S718>/Constant Value4'
         *  Switch: '<S718>/Switch2'
         *  Switch: '<S718>/Switch3'
         */
        rtb_Sum6_o1 = 0.0F;
    }

    /* End of Switch: '<S718>/Switch1' */
    /* End of Outputs for SubSystem: '<S696>/Protected Division' */

    /* Sum: '<S696>/Sum' incorporates:
     *  Constant: '<S676>/Calib'
     *  Constant: '<S696>/Constant Value1'
     *  Constant: '<S696>/Constant Value2'
     *  Product: '<S696>/Product1'
     *  Sum: '<S696>/Sum2'
     */
    rtb_MinMax1_h = rtb_Sum6_o1 - (((0.5F * rtb_MinMax1_h) * (rtb_Abs_kj - 1.0F))
        * HeESSR_t_MedTEB_dT);

    /* Switch: '<S692>/Switch4' incorporates:
     *  Constant: '<S699>/Calib'
     */
    if (!HeESSR_b_NiLmtForAccelByps)
    {
        /* Switch: '<S692>/Switch4' incorporates:
         *  MinMax: '<S692>/MinMax1'
         */
        rtb_Switch_mq = fminf(rtb_MinMax1_h, rtb_Switch_mq);
    }

    /* End of Switch: '<S692>/Switch4' */

    /* Outputs for Atomic SubSystem: '<S692>/Limiter13' */
    /* RelationalOperator: '<S704>/Relational Operator' */
    rtb_RelationalOperator_acd = (rtu_VeHSER_dn_NiDotMax <= rtb_Switch_mq);

    /* Switch: '<S704>/Switch1' */
    if (rtb_RelationalOperator_acd)
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = rtu_VeHSER_dn_NiDotMax;
    }
    else
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = rtb_Switch_mq;
    }

    /* End of Switch: '<S704>/Switch1' */

    /* Switch: '<S704>/Switch' incorporates:
     *  RelationalOperator: '<S704>/Relational Operator1'
     */
    if (rtb_Abs_kj <= rtu_VeHSER_dn_NiDotMin)
    {
        rtb_Abs_kj = rtu_VeHSER_dn_NiDotMin;
    }

    /* End of Switch: '<S704>/Switch' */
    /* End of Outputs for SubSystem: '<S692>/Limiter13' */

    /* Product: '<S692>/Product9' incorporates:
     *  Constant: '<S676>/Calib'
     */
    rtb_Switch_mq = rtb_Abs_kj * HeESSR_t_MedTEB_dT;

    /* Switch: '<S692>/Switch2' incorporates:
     *  Constant: '<S697>/Calib'
     *  DataStoreRead: '<S668>/Dsr_InputSpeedProfile2'
     *  Logic: '<S692>/Logical3'
     */
    if ((HeESSR_b_NiDotLmtBypsLoopJerk) && (VeESSR_b_NiDotMinActive_DS))
    {
        /* Switch: '<S692>/Switch2' */
        rtb_Gain_px = rtb_Switch1_g25;
    }
    else
    {
        /* Switch: '<S692>/Switch2' incorporates:
         *  DataStoreRead: '<S668>/Dsr_InputAcceltnProf'
         *  Sum: '<S692>/Sum16'
         */
        rtb_Gain_px += VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S692>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S692>/Limiter' */
    /* Switch: '<S702>/Switch1' incorporates:
     *  RelationalOperator: '<S702>/Relational Operator'
     */
    if (rtb_Switch1_ca < rtb_Gain_px)
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = rtb_Switch1_ca;
    }
    else
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = rtb_Gain_px;
    }

    /* End of Switch: '<S702>/Switch1' */

    /* Switch: '<S702>/Switch' incorporates:
     *  RelationalOperator: '<S702>/Relational Operator1'
     */
    if (rtb_Abs_kj > rtb_Switch1_g25)
    {
        /* Switch: '<S702>/Switch' */
        rtb_Gain_px = rtb_Abs_kj;
    }
    else
    {
        /* Switch: '<S702>/Switch' */
        rtb_Gain_px = rtb_Switch1_g25;
    }

    /* End of Switch: '<S702>/Switch' */
    /* End of Outputs for SubSystem: '<S692>/Limiter' */

    /* Outputs for Atomic SubSystem: '<S692>/Limiter3' */
    /* Switch: '<S706>/Switch1' incorporates:
     *  DataStoreRead: '<S668>/Dsr_NiProfGenNiDMax'
     *  RelationalOperator: '<S706>/Relational Operator'
     */
    if (VeESSR_dn_StrtTypNiDotMax_DS < rtb_Gain_px)
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = VeESSR_dn_StrtTypNiDotMax_DS;
    }
    else
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = rtb_Gain_px;
    }

    /* End of Switch: '<S706>/Switch1' */
    /* End of Outputs for SubSystem: '<S692>/Limiter3' */

    /* Switch: '<S692>/Switch5' incorporates:
     *  Constant: '<S699>/Calib'
     *  DataStoreRead: '<S668>/Dsr_NiProfGenNiDMin'
     *  RelationalOperator: '<S706>/Relational Operator1'
     *  Switch: '<S706>/Switch'
     */
    if (HeESSR_b_NiLmtForAccelByps)
    {
        /* Outputs for Atomic SubSystem: '<S692>/Limiter3' */
        /* Switch: '<S706>/Switch' incorporates:
         *  DataStoreRead: '<S668>/Dsr_NiProfGenNiDMin'
         *  RelationalOperator: '<S706>/Relational Operator1'
         */
        if (rtb_Abs_kj > VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S692>/Switch5' */
            rtb_Gain_px = rtb_Abs_kj;
        }
        else
        {
            /* Switch: '<S692>/Switch5' */
            rtb_Gain_px = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Outputs for SubSystem: '<S692>/Limiter3' */
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S692>/Limiter3' */
        if (rtb_Abs_kj <= VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S706>/Switch' incorporates:
             *  DataStoreRead: '<S668>/Dsr_NiProfGenNiDMin'
             */
            rtb_Abs_kj = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Outputs for SubSystem: '<S692>/Limiter3' */

        /* Switch: '<S692>/Switch5' incorporates:
         *  MinMax: '<S692>/MinMax2'
         */
        rtb_Gain_px = fminf(rtb_MinMax1_h, rtb_Abs_kj);
    }

    /* End of Switch: '<S692>/Switch5' */

    /* Outputs for Atomic SubSystem: '<S692>/Limiter9' */
    /* Switch: '<S709>/Switch1' incorporates:
     *  RelationalOperator: '<S709>/Relational Operator'
     */
    if (rtu_VeHSER_dn_NiDotMax <= rtb_Gain_px)
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = rtu_VeHSER_dn_NiDotMax;
    }
    else
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = rtb_Gain_px;
    }

    /* End of Switch: '<S709>/Switch1' */

    /* RelationalOperator: '<S708>/Relational Operator1' incorporates:
     *  RelationalOperator: '<S709>/Relational Operator1'
     */
    rtb_RelationalOperator1_dki = (rtb_Abs_kj > rtu_VeHSER_dn_NiDotMin);

    /* Logic: '<S709>/Logical2' */
    rtb_Logical2_ko = !rtb_RelationalOperator1_dki;

    /* Switch: '<S709>/Switch' */
    if (!rtb_RelationalOperator1_dki)
    {
        rtb_Abs_kj = rtu_VeHSER_dn_NiDotMin;
    }

    /* End of Switch: '<S709>/Switch' */
    /* End of Outputs for SubSystem: '<S692>/Limiter9' */

    /* Product: '<S692>/Product10' incorporates:
     *  Constant: '<S676>/Calib'
     */
    rtb_Gain_px = rtb_Abs_kj * HeESSR_t_MedTEB_dT;

    /* Sum: '<S692>/Sum2' incorporates:
     *  DataStoreRead: '<S668>/Dsr_InputSpeedProfile3'
     */
    rtb_Switch1_ca = rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS;

    /* Sum: '<S695>/Sum6' incorporates:
     *  Constant: '<S676>/Calib'
     *  DataStoreRead: '<S668>/Dsr_InputSpeedProfile3'
     *  Product: '<S695>/Product7'
     *  Sum: '<S692>/Sum6'
     *  Switch: '<S692>/Switch3'
     */
    rtb_IntegerDelay = (rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS) -
        (rtb_Sum15 * HeESSR_t_MedTEB_dT);

    /* Abs: '<S695>/Abs2' incorporates:
     *  Sum: '<S695>/Sum6'
     */
    rtb_MinMax1_h = fabsf(rtb_IntegerDelay);

    /* Switch: '<S695>/Switch' incorporates:
     *  Constant: '<S695>/Constant Value7'
     *  RelationalOperator: '<S695>/Comparison2'
     *  Sum: '<S695>/Sum6'
     */
    if (rtb_IntegerDelay < 0.0F)
    {
        /* Lookup_n-D: '<S685>/Vector' incorporates:
         *  Abs: '<S695>/Abs'
         */
        rtb_Abs_kj = fabsf(rtb_Sum2_af);
    }
    else
    {
        /* Lookup_n-D: '<S685>/Vector' incorporates:
         *  Abs: '<S695>/Abs1'
         *  Gain: '<S695>/Gain'
         */
        rtb_Abs_kj = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S695>/Switch' */

    /* Product: '<S695>/Product4' incorporates:
     *  Constant: '<S676>/Calib'
     */
    rtb_Product4 = (rtb_Abs_kj * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S695>/Protected Division1' */
    /* Switch: '<S715>/Switch1' incorporates:
     *  Constant: '<S715>/Constant Value'
     *  Constant: '<S715>/Constant Value1'
     *  Constant: '<S715>/Constant Value2'
     *  Logic: '<S715>/AND'
     *  RelationalOperator: '<S715>/Greater Than or Equal '
     *  RelationalOperator: '<S715>/Not Equal'
     *  RelationalOperator: '<S715>/Not Equal1'
     *  Switch: '<S715>/Switch2'
     */
    if ((rtb_MinMax1_h != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S715>/Switch1' incorporates:
         *  Product: '<S715>/Division'
         */
        rtb_Product4 = rtb_MinMax1_h / rtb_Product4;
    }
    else if (rtb_MinMax1_h > 0.0F)
    {
        /* Switch: '<S715>/Switch2' incorporates:
         *  Constant: '<S715>/MAXFLOAT'
         *  Switch: '<S715>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S715>/Switch1' incorporates:
         *  Constant: '<S715>/Constant Value4'
         *  Switch: '<S715>/Switch2'
         *  Switch: '<S715>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S715>/Switch1' */
    /* End of Outputs for SubSystem: '<S695>/Protected Division1' */

    /* Sum: '<S695>/Sum4' incorporates:
     *  Abs: '<S695>/Abs3'
     *  Constant: '<S695>/Constant Value3'
     *  Constant: '<S695>/Constant Value5'
     *  Product: '<S695>/Product3'
     */
    rtb_Product4 = (fabsf(rtb_Product4) * 8.0F) + 1.0F;

    /* Switch: '<S716>/Switch' incorporates:
     *  Constant: '<S716>/Zero'
     *  Sqrt: '<S716>/Sqrt'
     */
    if (rtb_Product4 >= 0.0F)
    {
        rtb_Product4 = sqrtf(rtb_Product4);
    }
    else
    {
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S716>/Switch' */

    /* MinMax: '<S695>/MinMax1' incorporates:
     *  Constant: '<S695>/Constant Value'
     *  Constant: '<S695>/Constant Value4'
     *  Constant: '<S695>/Constant Value6'
     *  Product: '<S695>/Product2'
     *  Rounding: '<S695>/Rounding1'
     *  Sum: '<S695>/Sum3'
     */
    rtb_MinMax1_h = fmaxf(ceilf((rtb_Product4 - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S695>/Product' incorporates:
     *  Constant: '<S676>/Calib'
     */
    rtb_Product4 = rtb_MinMax1_h * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S695>/Protected Division' */
    /* Switch: '<S714>/Switch1' incorporates:
     *  Constant: '<S714>/Constant Value'
     *  Constant: '<S714>/Constant Value1'
     *  Constant: '<S714>/Constant Value2'
     *  Constant: '<S714>/Constant Value3'
     *  Logic: '<S714>/AND'
     *  RelationalOperator: '<S714>/Greater Than or Equal '
     *  RelationalOperator: '<S714>/Greater Than or Equal 1'
     *  RelationalOperator: '<S714>/Not Equal'
     *  RelationalOperator: '<S714>/Not Equal1'
     *  Sum: '<S695>/Sum6'
     *  Switch: '<S714>/Switch2'
     *  Switch: '<S714>/Switch3'
     */
    if ((rtb_IntegerDelay != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S714>/Switch1' incorporates:
         *  Product: '<S714>/Division'
         */
        rtb_Product4 = rtb_IntegerDelay / rtb_Product4;
    }
    else if (rtb_IntegerDelay > 0.0F)
    {
        /* Switch: '<S714>/Switch2' incorporates:
         *  Constant: '<S714>/MAXFLOAT'
         *  Switch: '<S714>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else if (rtb_IntegerDelay < 0.0F)
    {
        /* Switch: '<S714>/Switch3' incorporates:
         *  Constant: '<S714>/MINFLOAT'
         *  Switch: '<S714>/Switch1'
         *  Switch: '<S714>/Switch2'
         */
        rtb_Product4 = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S714>/Switch1' incorporates:
         *  Constant: '<S714>/Constant Value4'
         *  Switch: '<S714>/Switch2'
         *  Switch: '<S714>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S714>/Switch1' */
    /* End of Outputs for SubSystem: '<S695>/Protected Division' */

    /* Switch: '<S692>/Switch3' incorporates:
     *  Constant: '<S700>/Calib'
     */
    if (!HeESSR_b_TrnstnJerkByps)
    {
        /* Switch: '<S692>/Switch8' incorporates:
         *  Constant: '<S692>/Constant Value7'
         *  RelationalOperator: '<S692>/Comparison'
         */
        if (rtb_IntegerDelay > 0.0F)
        {
            /* Switch: '<S692>/Switch3' incorporates:
             *  Constant: '<S676>/Calib'
             *  Constant: '<S695>/Constant Value1'
             *  Constant: '<S695>/Constant Value2'
             *  MinMax: '<S692>/MinMax4'
             *  Product: '<S692>/Product5'
             *  Product: '<S695>/Product1'
             *  Sum: '<S695>/Sum'
             *  Sum: '<S695>/Sum2'
             *  Switch: '<S692>/Switch8'
             */
            rtb_Switch1_ca = fminf(rtb_Switch1_ca, ((rtb_Product4 + rtb_Sum15) -
                                    (((0.5F * rtb_Abs_kj) * (rtb_MinMax1_h -
                1.0F)) * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }
        else
        {
            /* Switch: '<S692>/Switch3' incorporates:
             *  Constant: '<S676>/Calib'
             *  Constant: '<S695>/Constant Value1'
             *  Constant: '<S695>/Constant Value2'
             *  MinMax: '<S692>/MinMax5'
             *  Product: '<S692>/Product2'
             *  Product: '<S695>/Product1'
             *  Sum: '<S695>/Sum'
             *  Sum: '<S695>/Sum2'
             *  Switch: '<S692>/Switch8'
             */
            rtb_Switch1_ca = fmaxf(rtb_Switch1_ca, ((rtb_Product4 + rtb_Sum15) -
                                    (((0.5F * rtb_Abs_kj) * (rtb_MinMax1_h -
                1.0F)) * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }

        /* End of Switch: '<S692>/Switch8' */
    }

    /* Outputs for Atomic SubSystem: '<S692>/Limiter6' */
    /* RelationalOperator: '<S708>/Relational Operator' */
    rtb_RelationalOperator_nx = (rtb_Switch_mq <= rtb_Switch1_ca);

    /* Switch: '<S708>/Switch1' */
    if (rtb_RelationalOperator_nx)
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = rtb_Switch_mq;
    }
    else
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = rtb_Switch1_ca;
    }

    /* End of Switch: '<S708>/Switch1' */

    /* RelationalOperator: '<S708>/Relational Operator1' */
    rtb_RelationalOperator1_dki = (rtb_Abs_kj > rtb_Gain_px);

    /* Switch: '<S708>/Switch' */
    if (rtb_RelationalOperator1_dki)
    {
        rtb_Gain_px = rtb_Abs_kj;
    }

    /* End of Switch: '<S708>/Switch' */
    /* End of Outputs for SubSystem: '<S692>/Limiter6' */

    /* Sum: '<S692>/Sum4' incorporates:
     *  DataStoreRead: '<S668>/Dsr_InputSpeedProfile3'
     */
    rtb_IntegerDelay = rtb_Gain_px + VeESSR_n_InputSpeedProfile_DS;

    /* Outputs for Atomic SubSystem: '<S692>/Limiter1' */
    /* RelationalOperator: '<S703>/Relational Operator' incorporates:
     *  DataStoreWrite: '<S668>/Dsw_InputSpeedProfile5'
     */
    VeESSR_b_NiMaxActive_DS = (rtu_VeHSER_n_NiMax <= rtb_IntegerDelay);

    /* Switch: '<S703>/Switch1' incorporates:
     *  DataStoreWrite: '<S668>/Dsw_InputSpeedProfile5'
     */
    if (VeESSR_b_NiMaxActive_DS)
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = rtu_VeHSER_n_NiMax;
    }
    else
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = rtb_IntegerDelay;
    }

    /* End of Switch: '<S703>/Switch1' */

    /* Switch: '<S703>/Switch' incorporates:
     *  Constant: '<S692>/Constant Value4'
     *  RelationalOperator: '<S703>/Relational Operator1'
     */
    if (rtb_Abs_kj > 0.0F)
    {
        /* Switch: '<S703>/Switch' */
        rtb_IntegerDelay = rtb_Abs_kj;
    }
    else
    {
        /* Switch: '<S703>/Switch' */
        rtb_IntegerDelay = 0.0F;
    }

    /* End of Switch: '<S703>/Switch' */
    /* End of Outputs for SubSystem: '<S692>/Limiter1' */

    /* Product: '<S692>/Product3' incorporates:
     *  Constant: '<S676>/Calib'
     *  DataStoreRead: '<S668>/Dsr_InputSpeedProfile3'
     *  DataStoreWrite: '<S668>/Dsw_InputAcceltnProf'
     *  Sum: '<S692>/Sum'
     */
    VeESSR_dn_InputAcceltnProf_DS = (rtb_IntegerDelay -
        VeESSR_n_InputSpeedProfile_DS) / HeESSR_t_MedTEB_dT;

    /* DataStoreWrite: '<S668>/Dsw_InputSpeedProfile' */
    VeESSR_n_InputSpeedProfile_DS = rtb_IntegerDelay;

    /* Logic: '<S692>/Logical2' incorporates:
     *  DataStoreWrite: '<S668>/Dsw_InputSpeedProfile1'
     */
    VeESSR_b_NiDotMaxActive_DS = (rtb_RelationalOperator_acd &&
        rtb_RelationalOperator_nx);

    /* DataStoreWrite: '<S668>/Dsw_InputSpeedProfile2' */
    VeESSR_n_TargetSpeed_DS = rtb_Gain1_p;

    /* DataStoreWrite: '<S668>/Dsw_InputSpeedProfile3' */
    VeESSR_dn_TargetAcceltn_DS = rtb_Sum15;

    /* Outputs for Atomic SubSystem: '<S692>/Limiter6' */
    /* Logic: '<S692>/Logical' incorporates:
     *  DataStoreWrite: '<S668>/Dsw_InputSpeedProfile4'
     *  Logic: '<S708>/Logical2'
     */
    VeESSR_b_NiDotMinActive_DS = (rtb_Logical2_ko &&
        (!rtb_RelationalOperator1_dki));

    /* End of Outputs for SubSystem: '<S692>/Limiter6' */

    /* DataStoreWrite: '<S668>/Dsw_Ni1stFlt_DS' */
    VeESSR_n_Ni1stFlt_DS = rtb_Summation_em;

    /* DataStoreWrite: '<S668>/Dsw_STMTmr' incorporates:
     *  Constant: '<S676>/Calib'
     *  DataStoreRead: '<S668>/Dsr_STMTmr'
     *  Sum: '<S668>/Summation1'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Abs: '<S675>/Abs' incorporates:
     *  Constant: '<S676>/Calib'
     *  Constant: '<S681>/Calib'
     *  Product: '<S675>/Multiplication'
     */
    rtb_IntegerDelay = fabsf(KeESSR_dscl_RampUpRtAchIdle * HeESSR_t_MedTEB_dT);

    /* Sum: '<S675>/Sum' incorporates:
     *  Constant: '<S683>/Calib'
     *  DataStoreRead: '<S668>/Dsr_SpdCtlGainMod1'
     */
    rtb_Sum15 = KeESSR_scl_RampUpAchIdle - VeESSR_scl_SpdCtlGainMod_DS;

    /* Outputs for Atomic SubSystem: '<S675>/Limiter1' */
    /* Switch: '<S688>/Switch1' incorporates:
     *  RelationalOperator: '<S688>/Relational Operator'
     */
    if (rtb_IntegerDelay < rtb_Sum15)
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = rtb_IntegerDelay;
    }
    else
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = rtb_Sum15;
    }

    /* End of Switch: '<S688>/Switch1' */

    /* Switch: '<S688>/Switch' incorporates:
     *  Gain: '<S675>/Gain'
     *  RelationalOperator: '<S688>/Relational Operator1'
     */
    if (rtb_Abs_kj <= (-rtb_IntegerDelay))
    {
        rtb_Abs_kj = -rtb_IntegerDelay;
    }

    /* End of Switch: '<S688>/Switch' */
    /* End of Outputs for SubSystem: '<S675>/Limiter1' */

    /* Sum: '<S675>/Sum1' incorporates:
     *  DataStoreRead: '<S668>/Dsr_SpdCtlGainMod1'
     */
    rtb_Summation_em = rtb_Abs_kj + VeESSR_scl_SpdCtlGainMod_DS;

    /* Outputs for Atomic SubSystem: '<S675>/Limiter2' */
    /* Switch: '<S689>/Switch1' incorporates:
     *  Constant: '<S668>/Constant Value7'
     *  RelationalOperator: '<S689>/Relational Operator'
     */
    if (2.0F < rtb_Summation_em)
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = 2.0F;
    }
    else
    {
        /* Lookup_n-D: '<S685>/Vector' */
        rtb_Abs_kj = rtb_Summation_em;
    }

    /* End of Switch: '<S689>/Switch1' */

    /* Switch: '<S689>/Switch' incorporates:
     *  Constant: '<S668>/Constant Value6'
     *  DataStoreWrite: '<S668>/Dsw_SpdCtlGainMod1'
     *  RelationalOperator: '<S689>/Relational Operator1'
     */
    if (rtb_Abs_kj > 0.0F)
    {
        VeESSR_scl_SpdCtlGainMod_DS = rtb_Abs_kj;
    }
    else
    {
        VeESSR_scl_SpdCtlGainMod_DS = 0.0F;
    }

    /* End of Switch: '<S689>/Switch' */
    /* End of Outputs for SubSystem: '<S675>/Limiter2' */

    /* Sum: '<S668>/Sum2' incorporates:
     *  DataStoreRead: '<S668>/Dsr_InputTorqEst'
     *  Sum: '<S671>/Subtraction'
     */
    rtb_Gain_px = rtu_VeESSR_M_EngTrqAct_Lmtd - VeESSR_M_EngTorqEst_DS;

    /* DataStoreWrite: '<S668>/Dsw_InputTorqEst' incorporates:
     *  DataStoreRead: '<S668>/Dsr_InputTorqEst'
     *  Lookup_n-D: '<S684>/Vector'
     *  Product: '<S671>/Multiplication'
     *  Sum: '<S668>/Sum2'
     *  Sum: '<S671>/Subtraction1'
     */
    VeESSR_M_EngTorqEst_DS = (look1_iflf_binlcapw(rtb_Gain_px, ((const float32 *)
        &(KxESSR_K_TiEstBlndAchIdle[0])), ((const float32 *)
        &(KtESSR_K_TiEstBlndAchIdle[0])), 6U) * rtb_Gain_px) +
        VeESSR_M_EngTorqEst_DS;

    /* Switch: '<S677>/Switch1' incorporates:
     *  Constant: '<S674>/Constant'
     *  DataStoreRead: '<S668>/Dsr_STMTmr2'
     *  DataStoreWrite: '<S668>/Dsw_STMTrigger1'
     *  Lookup_n-D: '<S685>/Vector'
     *  RelationalOperator: '<S668>/Greater  Than2'
     */
    if (VeESSR_t_STMTmr_DS > look1_iflf_binlcapw(rtu_VeENGR_T_EngCoolantTemp, ((
            const float32 *)&(KxESSR_t_AchIdleTime[0])), ((const float32 *)
            &(KtESSR_t_AchIdleTime[0])), 2U))
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngRun;
    }

    /* End of Switch: '<S677>/Switch1' */

    /* Sum: '<S692>/Sum17' incorporates:
     *  DataStoreWrite: '<S668>/Dsw_InputAcceltnProf'
     */
    VeESSR_dn_InputJerkProfAchIdle = VeESSR_dn_InputAcceltnProf_DS - rtb_Gain_d2;

    /* Update for UnitDelay: '<S711>/Unit Delay' incorporates:
     *  Switch: '<S711>/Switch3'
     */
    localDW->UnitDelay_DSTATE = rtb_Summation_i;

    /* Update for Delay: '<S692>/IntegerDelay' */
    localDW->icLoad = 0U;
    for (i = 0; i < 15; i++)
    {
        localDW->IntegerDelay_DSTATE[i] = localDW->IntegerDelay_DSTATE[i + 1];
    }

    localDW->IntegerDelay_DSTATE[15] = rtb_Gain1_p;

    /* End of Update for Delay: '<S692>/IntegerDelay' */
}

#endif

/* Output and update for function-call system: '<S562>/SpnUp_12v_Du' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpnUp_12v_Du(VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_TransInSpdFlt, VAR(boolean, AUTOMATIC) rtu_PSAActv, VAR(float32,
    AUTOMATIC) rtu_HTDR_TiMin, VAR(float32, AUTOMATIC) rtu_EngTrqAct, P2VAR
    (DW_SpnUp_12v_Du_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR(uint32,
    AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_g_StrtStpFailRsn)
{
    float32 rtb_Summation_m1;
    float32 rtb_Switch1_oo5;
    boolean rtb_Equal2_k5;
    boolean rtb_GreaterThan1_la;
    boolean rtb_LogicalOperator1_i;

    /* RelationalOperator: '<S1241>/Equal2' incorporates:
     *  Constant: '<S1250>/Calib'
     *  DataStoreRead: '<S1241>/Dsr_STMTmr'
     */
    rtb_Equal2_k5 = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

    /* Outputs for Atomic SubSystem: '<S1248>/Accumulator Reset Limited' */
    /* Switch: '<S1263>/Switch1' */
    if (rtb_Equal2_k5)
    {
        /* Switch: '<S1263>/Switch1' incorporates:
         *  Constant: '<S1248>/Constant Value1'
         */
        rtb_Summation_m1 = 0.0F;
    }
    else
    {
        /* Sum: '<S1263>/Summation' incorporates:
         *  Constant: '<S1257>/Calib'
         *  Constant: '<S1264>/Calib'
         *  Constant: '<S1266>/Calib'
         *  Product: '<S1248>/Product'
         *  Sum: '<S1248>/Sum1'
         *  UnitDelay: '<S1263>/Unit Delay'
         */
        rtb_Summation_m1 = (((rtu_VeESSR_n_TransInSpdFlt -
                              KeESSR_n_Strt2RunExitSpdDelta) -
                             KeESSR_n_Start2RunTgt) * HeESSR_t_MedTEB_dT) +
            localDW->UnitDelay_DSTATE_e;

        /* Outputs for Atomic SubSystem: '<S1263>/Limiter' */
        /* Switch: '<S1267>/Switch1' incorporates:
         *  Constant: '<S1265>/Calib'
         *  RelationalOperator: '<S1267>/Relational Operator'
         */
        if (KeESSR_n_Strt2RunExitIntgrlVal < rtb_Summation_m1)
        {
            /* Switch: '<S1267>/Switch1' */
            rtb_Summation_m1 = KeESSR_n_Strt2RunExitIntgrlVal;
        }

        /* End of Switch: '<S1267>/Switch1' */

        /* Switch: '<S1267>/Switch' incorporates:
         *  Constant: '<S1248>/Constant Value1'
         *  RelationalOperator: '<S1267>/Relational Operator1'
         */
        if (rtb_Summation_m1 <= 0.0F)
        {
            /* Switch: '<S1263>/Switch1' */
            rtb_Summation_m1 = 0.0F;
        }

        /* End of Switch: '<S1267>/Switch' */
        /* End of Outputs for SubSystem: '<S1263>/Limiter' */
    }

    /* End of Switch: '<S1263>/Switch1' */

    /* Update for UnitDelay: '<S1263>/Unit Delay' */
    localDW->UnitDelay_DSTATE_e = rtb_Summation_m1;

    /* End of Outputs for SubSystem: '<S1248>/Accumulator Reset Limited' */

    /* RelationalOperator: '<S1248>/Comparison4' incorporates:
     *  Constant: '<S1265>/Calib'
     */
    VeESSR_b_Strt2RunSpdChk = (rtb_Summation_m1 ==
        KeESSR_n_Strt2RunExitIntgrlVal);

    /* SignalConversion generated from: '<S1241>/Variant Source' */
#if Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* Switch: '<S1282>/Switch1' incorporates:
     *  Constant: '<S1258>/Calib'
     */
    rtb_Switch1_oo5 = KeESSR_t_MaxStTmSpinUp_12vStrt;

#else

    /* Switch: '<S1282>/Switch1' incorporates:
     *  Constant: '<S1241>/Constant'
     */
    rtb_Switch1_oo5 = 100.0F;

#endif

    /* End of SignalConversion generated from: '<S1241>/Variant Source' */

    /* RelationalOperator: '<S1241>/Greater  Than1' incorporates:
     *  DataStoreRead: '<S1241>/Dsr_STMTmr1'
     */
    rtb_GreaterThan1_la = (VeESSR_t_STMTmr_DS > rtb_Switch1_oo5);

    /* Logic: '<S1241>/Logical Operator1' incorporates:
     *  Logic: '<S1241>/Logical Operator'
     */
    rtb_LogicalOperator1_i = ((!VeESSR_b_Strt2RunSpdChk) && rtb_GreaterThan1_la);

    /* Switch: '<S1241>/Switch' incorporates:
     *  S-Function (sfix_bitop): '<S1243>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator1_i)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 8388608U;
    }

    /* End of Switch: '<S1241>/Switch' */

    /* Switch: '<S1241>/Switch1' incorporates:
     *  Constant: '<S1249>/Calib'
     *  DataStoreWrite: '<S1241>/Dsw_InputSpeedProfile'
     */
    if (HeESSR_b_12vBSGLowPwr)
    {
        /* Switch: '<S1241>/Switch3' */
        if (rtb_Equal2_k5)
        {
            /* Switch: '<S1241>/Switch3' */
            rtb_Switch1_oo5 = rtu_VeESSR_n_TransInSpdFlt;
        }
        else
        {
            /* Sum: '<S1241>/Sum3' incorporates:
             *  Constant: '<S1256>/Calib'
             *  Constant: '<S1257>/Calib'
             *  DataStoreRead: '<S1241>/Dsr_InputSpeedProfile6'
             *  Sum: '<S1241>/Sum1'
             */
            rtb_Switch1_oo5 = (KeESSR_n_Start2RunTgt -
                               KeESSR_n_NiTrgtOffst12VStrt) -
                VeESSR_n_InputSpeedProfile_DS;

            /* Outputs for Atomic SubSystem: '<S1241>/Limiter' */
            /* Switch: '<S1259>/Switch1' incorporates:
             *  Constant: '<S1255>/Calib'
             *  RelationalOperator: '<S1259>/Relational Operator'
             */
            if (KeESSR_dn_12VPtgtLU < rtb_Switch1_oo5)
            {
                /* Switch: '<S1259>/Switch1' */
                rtb_Switch1_oo5 = KeESSR_dn_12VPtgtLU;
            }

            /* End of Switch: '<S1259>/Switch1' */

            /* Switch: '<S1259>/Switch' incorporates:
             *  Constant: '<S1254>/Calib'
             *  RelationalOperator: '<S1259>/Relational Operator1'
             */
            if (rtb_Switch1_oo5 <= KeESSR_dn_12VPtgtLD)
            {
                rtb_Switch1_oo5 = KeESSR_dn_12VPtgtLD;
            }

            /* End of Switch: '<S1259>/Switch' */
            /* End of Outputs for SubSystem: '<S1241>/Limiter' */

            /* Switch: '<S1241>/Switch3' incorporates:
             *  DataStoreRead: '<S1241>/Dsr_InputSpeedProfile6'
             *  Sum: '<S1241>/Sum4'
             */
            rtb_Switch1_oo5 += VeESSR_n_InputSpeedProfile_DS;
        }

        /* End of Switch: '<S1241>/Switch3' */
        VeESSR_n_InputSpeedProfile_DS = rtb_Switch1_oo5;
    }
    else
    {
        VeESSR_n_InputSpeedProfile_DS = rtu_VeESSR_n_TransInSpdFlt;
    }

    /* End of Switch: '<S1241>/Switch1' */

    /* Sum: '<S1262>/Summation5' incorporates:
     *  DataStoreRead: '<S1262>/Dsr_InputSpeedProfile6'
     */
    VeESSR_n_SpinUp12VSpdError = VeESSR_n_InputSpeedProfile_DS -
        rtu_VeESSR_n_TransInSpdFlt;

    /* Product: '<S1262>/proportional_term' incorporates:
     *  Constant: '<S1280>/Calib'
     */
    VeESSR_M_SpinUp12VPSpdCtl = VeESSR_n_SpinUp12VSpdError *
        KeESSR_K_SpinUp12VSpdCtlPgain;

    /* Switch: '<S1262>/Switch' */
    if (rtb_Equal2_k5)
    {
        /* Switch: '<S1262>/Switch' incorporates:
         *  DataStoreRead: '<S1262>/Dsr_InputSpeedProfile7'
         */
        VeESSR_M_SpinUp12VISpdCtl = VeESSR_M_EngTorqEst_DS;
    }
    else
    {
        /* Switch: '<S1262>/Switch' incorporates:
         *  Constant: '<S1278>/Calib'
         *  Constant: '<S1279>/Calib'
         *  Constant: '<S1281>/Calib'
         *  Product: '<S1262>/Multiplication1'
         *  Product: '<S1262>/Product'
         *  Sum: '<S1262>/Sum//Sub'
         *  Sum: '<S1262>/Sum//Sub2'
         *  Sum: '<S1262>/Sum//Sub3'
         *  UnitDelay: '<S1262>/Unit Delay'
         *  UnitDelay: '<S1262>/Unit Delay1'
         *  UnitDelay: '<S1262>/Unit Delay2'
         */
        VeESSR_M_SpinUp12VISpdCtl = (((VeESSR_n_SpinUp12VSpdError -
            ((VeESSR_M_SpinUp12VSpdCtlPre - VeESSR_M_SpinUp12VSpdCtlPost) *
             KeESSR_K_SpinUp12VWindupIgain)) * KeESSR_K_SpinUp12VSpdCtlIgain) *
            HeESSR_t_MedTEB_dT) + VeESSR_M_SpinUp12VISpdCtl;
    }

    /* End of Switch: '<S1262>/Switch' */

    /* Sum: '<S1262>/Sum//Sub1' */
    VeESSR_M_SpinUp12VSpdCtlPre = VeESSR_M_SpinUp12VPSpdCtl +
        VeESSR_M_SpinUp12VISpdCtl;

    /* Outputs for Atomic SubSystem: '<S1262>/Limiter' */
    /* Switch: '<S1282>/Switch1' incorporates:
     *  RelationalOperator: '<S1282>/Relational Operator'
     */
    if (rtu_EngTrqAct < VeESSR_M_SpinUp12VSpdCtlPre)
    {
        /* Switch: '<S1282>/Switch1' */
        rtb_Switch1_oo5 = rtu_EngTrqAct;
    }
    else
    {
        /* Switch: '<S1282>/Switch1' */
        rtb_Switch1_oo5 = VeESSR_M_SpinUp12VSpdCtlPre;
    }

    /* End of Switch: '<S1282>/Switch1' */

    /* Switch: '<S1282>/Switch' incorporates:
     *  RelationalOperator: '<S1282>/Relational Operator1'
     */
    if (rtb_Switch1_oo5 > rtu_HTDR_TiMin)
    {
        /* Switch: '<S1282>/Switch' */
        VeESSR_M_SpinUp12VSpdCtlPost = rtb_Switch1_oo5;
    }
    else
    {
        /* Switch: '<S1282>/Switch' */
        VeESSR_M_SpinUp12VSpdCtlPost = rtu_HTDR_TiMin;
    }

    /* End of Switch: '<S1282>/Switch' */
    /* End of Outputs for SubSystem: '<S1262>/Limiter' */

    /* Switch: '<S1241>/Switch2' incorporates:
     *  Constant: '<S1241>/Constant Value4'
     *  Constant: '<S1249>/Calib'
     *  DataStoreWrite: '<S1241>/Dsw_InputTorqEst'
     */
    if (HeESSR_b_12vBSGLowPwr)
    {
        VeESSR_M_EngTorqEst_DS = VeESSR_M_SpinUp12VSpdCtlPost;
    }
    else
    {
        VeESSR_M_EngTorqEst_DS = 0.0F;
    }

    /* End of Switch: '<S1241>/Switch2' */

    /* DataStoreWrite: '<S1241>/Dsw_STMTmr' incorporates:
     *  Constant: '<S1250>/Calib'
     *  DataStoreRead: '<S1241>/Dsr_STMTmr'
     *  Sum: '<S1241>/Summation'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Switch: '<S1251>/Switch1' incorporates:
     *  Constant: '<S1245>/Constant'
     *  DataStoreWrite: '<S1241>/Dsw_STMTrigger'
     *  Switch: '<S1251>/Switch2'
     */
    if (VeESSR_b_Strt2RunSpdChk)
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngSpdTgtAch;
    }
    else
    {
        if (rtb_GreaterThan1_la)
        {
            /* Switch: '<S1241>/Switch6' incorporates:
             *  Switch: '<S1251>/Switch2'
             */
            if (rtu_PSAActv)
            {
                /* Switch: '<S1251>/Switch1' incorporates:
                 *  Constant: '<S1247>/Constant'
                 *  DataStoreWrite: '<S1241>/Dsw_STMTrigger'
                 *  Switch: '<S1251>/Switch2'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;
            }
            else
            {
                /* Switch: '<S1251>/Switch1' incorporates:
                 *  Constant: '<S1246>/Constant'
                 *  DataStoreWrite: '<S1241>/Dsw_STMTrigger'
                 *  Switch: '<S1251>/Switch2'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;
            }

            /* End of Switch: '<S1241>/Switch6' */
        }
    }

    /* End of Switch: '<S1251>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S1241>/SpeedCheck_CD_Exit' */
#if Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* Outputs for Atomic SubSystem: '<S1261>/SpeedCheck_CD_Exit' */
    /* Product: '<S1271>/Product1' incorporates:
     *  Constant: '<S1274>/Calib'
     *  Constant: '<S1276>/Calib'
     *  Sum: '<S1271>/Summation6'
     */
    VeESSR_n_P1f12VStrtCDAccmIn = (KeESSR_n_12vLPSCDSpd -
        rtu_VeESSR_n_TransInSpdFlt) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1271>/Accumulator Reset Limited' */
    /* Switch: '<S1273>/Switch1' */
    if (rtb_Equal2_k5)
    {
        /* Switch: '<S1273>/Switch1' incorporates:
         *  Constant: '<S1271>/Constant Value7'
         */
        VeESSR_n_P1f12VStrtFailCDAccm = 0.0F;
    }
    else
    {
        /* Sum: '<S1273>/Summation' incorporates:
         *  UnitDelay: '<S1273>/Unit Delay'
         */
        rtb_Switch1_oo5 = VeESSR_n_P1f12VStrtCDAccmIn +
            VeESSR_n_P1f12VStrtFailCDAccm;

        /* Outputs for Atomic SubSystem: '<S1273>/Limiter' */
        /* Switch: '<S1277>/Switch1' incorporates:
         *  Constant: '<S1275>/Calib'
         *  RelationalOperator: '<S1277>/Relational Operator'
         */
        if (KeESSR_n_12vLPSCDDeltaSpd < rtb_Switch1_oo5)
        {
            /* Switch: '<S1277>/Switch1' */
            rtb_Switch1_oo5 = KeESSR_n_12vLPSCDDeltaSpd;
        }

        /* End of Switch: '<S1277>/Switch1' */

        /* Switch: '<S1277>/Switch' incorporates:
         *  Constant: '<S1271>/Constant Value7'
         *  RelationalOperator: '<S1277>/Relational Operator1'
         */
        if (rtb_Switch1_oo5 > 0.0F)
        {
            /* Switch: '<S1273>/Switch1' */
            VeESSR_n_P1f12VStrtFailCDAccm = rtb_Switch1_oo5;
        }
        else
        {
            /* Switch: '<S1273>/Switch1' */
            VeESSR_n_P1f12VStrtFailCDAccm = 0.0F;
        }

        /* End of Switch: '<S1277>/Switch' */
        /* End of Outputs for SubSystem: '<S1273>/Limiter' */
    }

    /* End of Switch: '<S1273>/Switch1' */
    /* End of Outputs for SubSystem: '<S1271>/Accumulator Reset Limited' */

    /* VariantMerge generated from: '<S1261>/VeESSR_b_P1f12VCDExitCnfrmd' incorporates:
     *  Constant: '<S1275>/Calib'
     *  RelationalOperator: '<S1271>/Comparison4'
     */
    VeESSR_b_P1f12VStrtFailCoastDownDtct = (VeESSR_n_P1f12VStrtFailCDAccm >=
        KeESSR_n_12vLPSCDDeltaSpd);

    /* End of Outputs for SubSystem: '<S1261>/SpeedCheck_CD_Exit' */
    /* End of Outputs for SubSystem: '<S1241>/SpeedCheck_CD_Exit' */
#else

    /* Outputs for Atomic SubSystem: '<S1261>/Subsystem' */
    /* VariantMerge generated from: '<S1261>/VeESSR_b_P1f12VCDExitCnfrmd' incorporates:
     *  Constant: '<S1272>/Constant'
     */
    VeESSR_b_P1f12VStrtFailCoastDownDtct = false;

    /* End of Outputs for SubSystem: '<S1261>/Subsystem' */
#endif

    /* If: '<S1241>/If1' */
    if (rtb_LogicalOperator1_i)
    {
        /* Outputs for IfAction SubSystem: '<S1241>/If_KeyCrank_P1C65' incorporates:
         *  ActionPort: '<S1253>/Action Port'
         */
        /* Switch: '<S1253>/Switch' */
        if (VeESSR_b_P1f12VStrtFailCoastDownDtct)
        {
            /* DataStoreWrite: '<S1241>/Dsw_StrtStpFailDTC' incorporates:
             *  Constant: '<S1269>/Constant'
             *  Merge: '<S1241>/Merge'
             */
            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;
        }
        else
        {
            /* DataStoreWrite: '<S1241>/Dsw_StrtStpFailDTC' incorporates:
             *  Constant: '<S1270>/Constant'
             *  Merge: '<S1241>/Merge'
             */
            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C64;
        }

        /* End of Switch: '<S1253>/Switch' */
        /* End of Outputs for SubSystem: '<S1241>/If_KeyCrank_P1C65' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1241>/If_KeyCrank_NoFault' incorporates:
         *  ActionPort: '<S1252>/Action Port'
         */
        /* DataStoreWrite: '<S1241>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_KeyCrank_NoFault((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S1241>/If_KeyCrank_NoFault' */
    }

    /* End of If: '<S1241>/If1' */

    /* Switch: '<S1241>/Switch4' incorporates:
     *  Constant: '<S1241>/Constant Value'
     *  DataStoreRead: '<S1241>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S1241>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S1241>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S1241>/Logical21'
     *  RelationalOperator: '<S1241>/Comparison'
     *  S-Function (sfix_bitop): '<S1241>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S1244>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator1_i && ((VeESSR_g_StrtStpFailPhaseSelect_DS & 128U) >
         0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 128U;
    }

    /* End of Switch: '<S1241>/Switch4' */

    /* DataStoreWrite: '<S1241>/Dsw_InputAcceltnProf' incorporates:
     *  Constant: '<S1241>/Constant Value1'
     */
    VeESSR_dn_InputAcceltnProf_DS = 0.0F;
}

#endif

/* Output and update for function-call system: '<S555>/AchIdle_12vStrt_En' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_AchIdle_12vStrt_En(VAR(boolean,
    AUTOMATIC) rtu_VeSTRR_b_FirstStartActv, VAR(TeHPMR_e_PropSysMode, AUTOMATIC)
    rtu_VeHPMR_e_PropSysMode)
{
    boolean rtb_Comparison4_hs;

    /* Switch: '<S825>/Switch1' incorporates:
     *  Constant: '<S814>/Constant'
     *  Constant: '<S823>/Calib'
     *  Constant: '<S830>/Calib'
     *  Constant: '<S831>/Calib'
     *  Logic: '<S742>/Logical'
     *  Logic: '<S742>/Logical1'
     *  Logic: '<S742>/Logical2'
     *  Logic: '<S742>/Logical3'
     *  RelationalOperator: '<S742>/Comparison1'
     */
    if ((HeESSR_b_12vBSGLowPwr) || ((!KeESSR_b_ForceNiClsdLoopIdleCtrl_12vStrt) &&
         ((rtu_VeSTRR_b_FirstStartActv || (((uint32)rtu_VeHPMR_e_PropSysMode) ==
            CeHPMR_e_Conventional)) || (KeESSR_b_ForceETRQIdleCtrl_12vStrt))))
    {
        /* Switch: '<S825>/Switch1' incorporates:
         *  Constant: '<S812>/Constant'
         */
        VeESSR_e_IdleCtrlrSelect_12vStrt = CeESSR_e_ETRQ_Ctrl;
    }
    else
    {
        /* Switch: '<S825>/Switch1' incorporates:
         *  Constant: '<S817>/Constant'
         */
        VeESSR_e_IdleCtrlrSelect_12vStrt = CeESSR_e_ICSR_Ctrl;
    }

    /* End of Switch: '<S825>/Switch1' */

    /* RelationalOperator: '<S742>/Comparison4' incorporates:
     *  Constant: '<S818>/Constant'
     *  Switch: '<S825>/Switch1'
     */
    rtb_Comparison4_hs = (((uint32)VeESSR_e_IdleCtrlrSelect_12vStrt) ==
                          CeESSR_e_ETRQ_Ctrl);

    /* Switch: '<S826>/Switch1' incorporates:
     *  DataStoreWrite: '<S742>/Dsw_Dsbl_ICSRFor12vStart'
     */
    VeESSR_b_DsblNiClsdLoopCntrl_DS = rtb_Comparison4_hs;

    /* Switch: '<S742>/Switch2' incorporates:
     *  Constant: '<S819>/Constant'
     *  Constant: '<S823>/Calib'
     *  DataStoreWrite: '<S742>/Dsw_EngStrtType1'
     */
    if (HeESSR_b_12vBSGLowPwr)
    {
        /* Switch: '<S742>/Switch3' incorporates:
         *  Constant: '<S813>/Constant'
         *  Constant: '<S820>/Constant'
         *  Constant: '<S821>/Constant'
         *  DataStoreRead: '<S742>/Dsr_EngStrtType3'
         *  DataStoreWrite: '<S742>/Dsw_EngStrtType1'
         *  RelationalOperator: '<S742>/Comparison9'
         *  Switch: '<S742>/Switch2'
         */
        if (CeESSR_e_EMLwPwrStrtAlgo == ((uint32)VeESSR_e_EngStrtProfType_DS))
        {
            VeESSR_e_TCM_StartStopType_DS = CeESSR_e_EMStrt;
        }
        else
        {
            VeESSR_e_TCM_StartStopType_DS = CeESSR_e_NormalStart;
        }

        /* End of Switch: '<S742>/Switch3' */
    }
    else
    {
        VeESSR_e_TCM_StartStopType_DS = CeESSR_e_NoAction;
    }

    /* End of Switch: '<S742>/Switch2' */

    /* Switch: '<S827>/Switch1' incorporates:
     *  Constant: '<S815>/Constant'
     *  Constant: '<S816>/Constant'
     *  DataStoreWrite: '<S742>/Dsw_TRAREngCntrlMode_DS'
     */
    if (rtb_Comparison4_hs)
    {
        VeESSR_e_EngCntrlMode_DS = CeTRAR_e_SpeedMode;
    }
    else
    {
        VeESSR_e_EngCntrlMode_DS = CeTRAR_e_TorqueMode;
    }

    /* End of Switch: '<S827>/Switch1' */

    /* DataStoreWrite: '<S742>/Dsw_EngStartStopSt' incorporates:
     *  Constant: '<S810>/Constant'
     */
    VeESSR_e_EngStartStopSt_DS = CeESSR_e_AchEngIdle12vStrtSt;

    /* Switch: '<S742>/Switch1' incorporates:
     *  Constant: '<S742>/Constant Value7'
     *  Constant: '<S824>/Calib'
     *  DataStoreWrite: '<S742>/Data Store Write1'
     */
    if (!HeESSR_b_EngStrtTorq)
    {
        VeESSR_M_EngStrtTorq_DS = 0.0F;
    }

    /* End of Switch: '<S742>/Switch1' */

    /* DataStoreWrite: '<S742>/Dsw_Ni1stFlt' incorporates:
     *  DataStoreRead: '<S742>/Dsr_InputSpeedProfile1'
     */
    VeESSR_n_Ni1stFlt_DS = VeESSR_n_InputSpeedProfile_DS;

    /* DataStoreWrite: '<S742>/Dsw_AEMDMtrBGain' incorporates:
     *  Constant: '<S836>/Calib'
     */
    VeESSR_scl_AEMDMtrBGain_DS = KeESSR_scl_AEMDMtrBGain_AchIdle12VStrtSt;

    /* DataStoreWrite: '<S742>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
     *  Constant: '<S828>/Calib'
     */
    VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

    /* DataStoreWrite: '<S742>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
     *  Constant: '<S829>/Calib'
     */
    VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

    /* DataStoreWrite: '<S742>/Dsw_EngStrtStpMd2' incorporates:
     *  Constant: '<S833>/Calib'
     */
    VeESSR_e_EngStrtStpMd_DS = KeESSR_e_MdInAchEngIdle12vStrtSt;

    /* DataStoreWrite: '<S742>/Dsw_EngStrtType2' incorporates:
     *  Constant: '<S822>/Constant'
     */
    VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Startng;

    /* DataStoreWrite: '<S742>/Dsw_InhibitShiftToMode' incorporates:
     *  Constant: '<S832>/Calib'
     */
    VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtAchIdle12vStrtSt;

    /* DataStoreWrite: '<S742>/Dsw_InputSpeedProfile1' incorporates:
     *  Constant: '<S835>/Calib'
     */
    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

    /* DataStoreWrite: '<S742>/Dsw_StrtStpFailDTC' incorporates:
     *  Constant: '<S811>/Constant'
     */
    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

    /* DataStoreWrite: '<S742>/Dsw_TransFldPmpSel' incorporates:
     *  Constant: '<S834>/Calib'
     */
    VeESSR_e_TransFldPmpSel_DS = KeESSR_e_TransFldPmpSelAchEngIdle12vStrtSt;
}

#endif

/* System initialize for function-call system: '<S555>/AchIdle_12vStrt_Du' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_AchIdle_12vStrt_Du_Init(P2VAR
    (DW_AchIdle_12vStrt_Du_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW)
{
    /* SystemInitialize for IfAction SubSystem: '<S741>/ICSR_Ctrl' */
    /* InitializeConditions for Delay: '<S773>/IntegerDelay' */
    localDW->icLoad = 1U;

    /* End of SystemInitialize for SubSystem: '<S741>/ICSR_Ctrl' */
}

#endif

/* Output and update for function-call system: '<S555>/AchIdle_12vStrt_Du' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_AchIdle_12vStrt_Du(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_OptEngTrqReq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_OptInputSpd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeENGR_T_EngCoolantTemp, VAR(TeESSR_e_IdleCtrlrSelect, AUTOMATIC)
    rtu_VeESSR_e_IdleCtrlrSelect, VAR(float32, AUTOMATIC) rtu_VeHSER_n_NiMax,
    VAR(float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMax, VAR(float32, AUTOMATIC)
    rtu_VeHSER_dn_NiDotMin, P2VAR(DW_AchIdle_12vStrt_Du_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(ZCE_AchIdle_12vStrt_Du_ESSR_a_T, AUTOMATIC,
    ESSR_VAR_INIT) localZCE)
{
    sint32 i;
    float32 rtb_Gain1_gb;
    float32 rtb_Gain_inb;
    float32 rtb_Gain_nf;
    float32 rtb_IntegerDelay;
    float32 rtb_MinMax1_jq;
    float32 rtb_Product4;
    float32 rtb_Product4_of;
    float32 rtb_Sum15;
    float32 rtb_Sum2_pk;
    float32 rtb_Sum6_lr;
    float32 rtb_Summation_knd;
    float32 rtb_Summation_lr;
    float32 rtb_Switch1_iw;
    float32 rtb_Switch1_mdg;
    float32 rtb_Switch_iy;
    uint8 tmp;
    boolean rtb_Logical2_ir;
    boolean rtb_RelationalOperator1_mu;
    boolean rtb_RelationalOperator_d0d;
    boolean rtb_RelationalOperator_f0;

    /* RelationalOperator: '<S741>/Relational Operator' incorporates:
     *  Constant: '<S750>/Calib'
     *  DataStoreRead: '<S741>/Dsr_STMTmr'
     */
    rtb_RelationalOperator_d0d = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

    /* If: '<S741>/If' incorporates:
     *  Constant: '<S749>/Constant'
     *  RelationalOperator: '<S741>/Comparison4'
     */
    if (((uint32)rtu_VeESSR_e_IdleCtrlrSelect) == CeESSR_e_ETRQ_Ctrl)
    {
        /* Outputs for IfAction SubSystem: '<S741>/ETRQ_Ctrl' incorporates:
         *  ActionPort: '<S748>/Action Port'
         */
        /* Lookup_n-D: '<S754>/Vector' incorporates:
         *  DataStoreRead: '<S748>/Dsr_SpdCtlGainMod1'
         */
        rtb_IntegerDelay = VeESSR_scl_SpdCtlGainMod_DS;

        /* Merge: '<S741>/Merge2' incorporates:
         *  Inport: '<S748>/OptNi'
         */
        rtb_Product4 = rtu_VeESSR_n_OptInputSpd;

        /* Merge: '<S741>/Merge1' incorporates:
         *  Constant: '<S748>/Constant Value3'
         *  SignalConversion generated from: '<S748>/InputAcceltnProf'
         */
        rtb_Gain_inb = 0.0F;

        /* Merge: '<S741>/Merge3' incorporates:
         *  DataStoreRead: '<S748>/Dsr_Ni1stFlt_DS'
         */
        rtb_Summation_knd = VeESSR_n_Ni1stFlt_DS;

        /* Merge: '<S741>/Merge4' incorporates:
         *  Constant: '<S756>/Calib'
         *  SignalConversion generated from: '<S748>/K_Filt_EngTrqReqPrdtdImmed'
         */
        rtb_Gain_nf = KeESSR_K_AchIdle12vStrtETRQEngCmdFlt;

        /* Merge: '<S741>/Merge5' incorporates:
         *  Constant: '<S757>/Calib'
         *  SignalConversion generated from: '<S748>/K_Filt_EngTorqEst'
         */
        rtb_Sum15 = KeESSR_K_TiEstBlndAchIdle12vStrt;

        /* End of Outputs for SubSystem: '<S741>/ETRQ_Ctrl' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S741>/ICSR_Ctrl' incorporates:
         *  ActionPort: '<S751>/Action Port'
         */
        /* Gain: '<S768>/Gain' incorporates:
         *  Abs: '<S768>/Abs1'
         *  DataStoreRead: '<S751>/Dsr_NiProfGenDNiDLim1'
         */
        rtb_Gain_nf = -fabsf(VeESSR_dn_StrtTypJerkMin_DS);

        /* Product: '<S773>/Product4' incorporates:
         *  Constant: '<S759>/Calib'
         */
        rtb_Product4 = rtb_Gain_nf / HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S768>/LowpassT Reset Enabled' */
        /* Sum: '<S771>/Summation' incorporates:
         *  Constant: '<S759>/Calib'
         *  DataStoreRead: '<S751>/Dsr_MinEngStrtSpd'
         *  DataStoreRead: '<S751>/Dsr_Ni1stFlt_DS'
         *  DataStoreRead: '<S751>/Dsr_NiProfGenT2Gain'
         *  MinMax: '<S751>/Maximum3'
         *  MinMax: '<S771>/Maximum'
         *  Product: '<S771>/Multiplication'
         *  Product: '<S771>/Multiplication1'
         *  Sum: '<S771>/Subtraction'
         */
        rtb_Summation_knd = (((fmaxf(rtu_VeESSR_n_OptInputSpd,
                                VeESSR_n_MinEngStrtSpd_DS) -
                               VeESSR_n_Ni1stFlt_DS) * HeESSR_t_MedTEB_dT) *
                             (1.0F / fmaxf(VeESSR_k_StrtTypScndOrdLwPassT_DS,
                               HeESSR_t_MedTEB_dT))) + VeESSR_n_Ni1stFlt_DS;

        /* End of Outputs for SubSystem: '<S768>/LowpassT Reset Enabled' */

        /* Outputs for Atomic SubSystem: '<S768>/LowpassT Reset Enabled1' */
        /* Sum: '<S772>/Summation' incorporates:
         *  Constant: '<S759>/Calib'
         *  DataStoreRead: '<S751>/Dsr_InputSpeedProfile3'
         *  DataStoreRead: '<S751>/Dsr_NiProfGenT1Gain'
         *  MinMax: '<S772>/Maximum'
         *  Product: '<S772>/Multiplication'
         *  Product: '<S772>/Multiplication1'
         *  Sum: '<S772>/Subtraction'
         */
        rtb_Summation_lr = (((rtb_Summation_knd - VeESSR_n_InputSpeedProfile_DS)
                             * HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                             (VeESSR_k_StrtTypFrstOrdLwPassT_DS,
                              HeESSR_t_MedTEB_dT))) +
            VeESSR_n_InputSpeedProfile_DS;

        /* End of Outputs for SubSystem: '<S768>/LowpassT Reset Enabled1' */

        /* Switch: '<S792>/Switch1' incorporates:
         *  UnitDelay: '<S792>/Unit Delay'
         */
        if (rtb_RelationalOperator_d0d)
        {
            rtb_Gain1_gb = rtb_Summation_lr;
        }
        else
        {
            rtb_Gain1_gb = localDW->UnitDelay_DSTATE;
        }

        /* End of Switch: '<S792>/Switch1' */

        /* Gain: '<S773>/Gain1' incorporates:
         *  Sum: '<S773>/Sum18'
         */
        rtb_Gain1_gb = (rtb_Summation_lr + rtb_Gain1_gb) * 0.5F;

        /* Delay: '<S773>/IntegerDelay' incorporates:
         *  Constant: '<S782>/Calib'
         */
        if (rtb_RelationalOperator_d0d && (((uint32)
                localZCE->IntegerDelay_Reset_ZCE_c) != POS_ZCSIG))
        {
            localDW->icLoad = 1U;
        }

        localZCE->IntegerDelay_Reset_ZCE_c = rtb_RelationalOperator_d0d ?
            ((ZCSigState)1) : ((ZCSigState)0);
        if (((sint32)localDW->icLoad) != 0)
        {
            for (i = 0; i < 16; i++)
            {
                localDW->IntegerDelay_DSTATE[i] = rtb_Gain1_gb;
            }
        }

        if (((sint32)KeESSR_Cnt_DelayOptNi) <= 0)
        {
            /* Delay: '<S773>/IntegerDelay' */
            rtb_IntegerDelay = rtb_Gain1_gb;
        }
        else
        {
            if (((sint32)KeESSR_Cnt_DelayOptNi) > 16)
            {
                tmp = 16U;
            }
            else
            {
                tmp = KeESSR_Cnt_DelayOptNi;
            }

            /* Delay: '<S773>/IntegerDelay' */
            rtb_IntegerDelay = localDW->IntegerDelay_DSTATE[(uint8)(16U -
                ((uint32)tmp))];
        }

        /* End of Delay: '<S773>/IntegerDelay' */

        /* Sum: '<S773>/Sum15' incorporates:
         *  Abs: '<S773>/Abs4'
         *  Constant: '<S761>/Calib'
         *  DataStoreRead: '<S751>/Dsr_InputSpeedProfile5'
         */
        rtb_Sum15 = fabsf(VeESSR_dn_TargetAcceltn_DS) +
            KeESSR_dn_NiTargetJerkLimit;

        /* Outputs for Atomic SubSystem: '<S773>/GradientLimiter' */
        /* Sum: '<S775>/Sum2' incorporates:
         *  Constant: '<S759>/Calib'
         *  DataStoreRead: '<S751>/Dsr_InputSpeedProfile4'
         *  Product: '<S773>/Product6'
         *  Sum: '<S773>/Sum14'
         *  UnitDelay: '<S775>/Unit Delay'
         */
        rtb_Sum2_pk = ((rtb_Gain1_gb - VeESSR_n_TargetSpeed_DS) /
                       HeESSR_t_MedTEB_dT) - localDW->UnitDelay_DSTATE_d;

        /* Outputs for Atomic SubSystem: '<S775>/Limiter' */
        /* Switch: '<S793>/Switch1' incorporates:
         *  RelationalOperator: '<S793>/Relational Operator'
         */
        if (rtb_Sum15 < rtb_Sum2_pk)
        {
            /* MinMax: '<S776>/MinMax1' */
            rtb_MinMax1_jq = rtb_Sum15;
        }
        else
        {
            /* MinMax: '<S776>/MinMax1' */
            rtb_MinMax1_jq = rtb_Sum2_pk;
        }

        /* End of Switch: '<S793>/Switch1' */

        /* Switch: '<S793>/Switch' incorporates:
         *  Gain: '<S773>/Gain'
         *  RelationalOperator: '<S793>/Relational Operator1'
         */
        if (rtb_MinMax1_jq <= (-rtb_Sum15))
        {
            rtb_MinMax1_jq = -rtb_Sum15;
        }

        /* End of Switch: '<S793>/Switch' */
        /* End of Outputs for SubSystem: '<S775>/Limiter' */

        /* Sum: '<S775>/Sum3' incorporates:
         *  UnitDelay: '<S775>/Unit Delay'
         */
        rtb_Gain_inb = rtb_MinMax1_jq + localDW->UnitDelay_DSTATE_d;

        /* Update for UnitDelay: '<S775>/Unit Delay' */
        localDW->UnitDelay_DSTATE_d = rtb_Gain_inb;

        /* End of Outputs for SubSystem: '<S773>/GradientLimiter' */

        /* Sum: '<S774>/Subtraction1' incorporates:
         *  Constant: '<S763>/Calib'
         *  DataStoreRead: '<S751>/Dsr_InputSpeedProfile5'
         *  Product: '<S774>/Multiplication'
         *  Sum: '<S774>/Subtraction'
         */
        rtb_Gain_inb = ((rtb_Gain_inb - VeESSR_dn_TargetAcceltn_DS) *
                        KeESSR_k_NiDotTargetFilt) + VeESSR_dn_TargetAcceltn_DS;

        /* Abs: '<S768>/Abs' incorporates:
         *  DataStoreRead: '<S751>/Dsr_NiProfGenDNiDLim'
         */
        rtb_Sum2_pk = fabsf(VeESSR_dn_StrtTypJerkMax_DS);

        /* Switch: '<S804>/Switch1' incorporates:
         *  Constant: '<S802>/Calib'
         */
        if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
        {
            /* Switch: '<S804>/Switch1' incorporates:
             *  Constant: '<S803>/Calib'
             */
            rtb_Switch1_mdg = HeESSR_dn_NiDotLmt4JerkOvrdVal;
        }
        else
        {
            /* Sum: '<S791>/Sum6' incorporates:
             *  DataStoreRead: '<S751>/Dsr_InputAcceltnProf'
             *  Sum: '<S791>/Sum8'
             */
            rtb_MinMax1_jq = VeESSR_dn_InputAcceltnProf_DS - rtb_Gain_inb;

            /* Abs: '<S791>/Abs' incorporates:
             *  Sum: '<S791>/Sum6'
             */
            rtb_Sum15 = (rtb_MinMax1_jq - rtb_Gain_nf) + rtb_Sum2_pk;

            /* MinMax: '<S791>/MinMax2' incorporates:
             *  Abs: '<S791>/Abs1'
             *  Constant: '<S759>/Calib'
             *  Constant: '<S791>/Constant Value'
             *  Constant: '<S791>/Constant Value3'
             *  DataStoreRead: '<S751>/Dsr_InputSpeedProfile3'
             *  Product: '<S791>/Product2'
             *  Product: '<S791>/Product7'
             *  Product: '<S806>/Prod'
             *  Sum: '<S791>/Sum3'
             *  Sum: '<S791>/Sum5'
             */
            rtb_Sum15 = fmaxf((fabsf((rtb_IntegerDelay -
                                 VeESSR_n_InputSpeedProfile_DS) -
                                (HeESSR_t_MedTEB_dT * rtb_Gain_inb)) *
                               (rtb_Product4 * -2.0F)) - (rtb_Sum15 * rtb_Sum15),
                              0.0F);

            /* Switch: '<S808>/Switch' incorporates:
             *  Sqrt: '<S808>/Sqrt'
             */
            rtb_Sum15 = sqrtf(rtb_Sum15);

            /* Switch: '<S804>/Switch1' incorporates:
             *  Abs: '<S791>/Abs'
             *  Sum: '<S791>/Sum7'
             *  Sum: '<S791>/Sum8'
             */
            rtb_Switch1_mdg = fabsf(rtb_MinMax1_jq + rtb_Gain_nf) + (rtb_Sum15 +
                rtb_Gain_inb);
        }

        /* End of Switch: '<S804>/Switch1' */

        /* Product: '<S773>/Product1' incorporates:
         *  Constant: '<S759>/Calib'
         */
        rtb_Sum15 = rtb_Sum2_pk / HeESSR_t_MedTEB_dT;

        /* Switch: '<S805>/Switch1' incorporates:
         *  Constant: '<S802>/Calib'
         */
        if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
        {
            /* Switch: '<S805>/Switch1' incorporates:
             *  Constant: '<S803>/Calib'
             *  Gain: '<S791>/Gain1'
             */
            rtb_Switch1_iw = -HeESSR_dn_NiDotLmt4JerkOvrdVal;
        }
        else
        {
            /* Sum: '<S791>/Sum11' incorporates:
             *  DataStoreRead: '<S751>/Dsr_InputAcceltnProf'
             *  Sum: '<S791>/Sum13'
             */
            rtb_Switch_iy = VeESSR_dn_InputAcceltnProf_DS - rtb_Gain_inb;

            /* Abs: '<S791>/Abs2' incorporates:
             *  Sum: '<S791>/Sum11'
             */
            rtb_MinMax1_jq = (rtb_Switch_iy - rtb_Sum2_pk) + rtb_Gain_nf;

            /* MinMax: '<S791>/MinMax1' incorporates:
             *  Abs: '<S791>/Abs3'
             *  Constant: '<S759>/Calib'
             *  Constant: '<S791>/Constant Value1'
             *  Constant: '<S791>/Constant Value2'
             *  DataStoreRead: '<S751>/Dsr_InputSpeedProfile3'
             *  Product: '<S791>/Product5'
             *  Product: '<S791>/Product8'
             *  Product: '<S809>/Prod'
             *  Sum: '<S791>/Sum10'
             *  Sum: '<S791>/Sum9'
             */
            rtb_MinMax1_jq = fmaxf((fabsf((rtb_IntegerDelay -
                VeESSR_n_InputSpeedProfile_DS) - (HeESSR_t_MedTEB_dT *
                rtb_Gain_inb)) * (rtb_Sum15 * 2.0F)) - (rtb_MinMax1_jq *
                                    rtb_MinMax1_jq), 0.0F);

            /* Switch: '<S807>/Switch' incorporates:
             *  Sqrt: '<S807>/Sqrt'
             */
            rtb_MinMax1_jq = sqrtf(rtb_MinMax1_jq);

            /* Switch: '<S805>/Switch1' incorporates:
             *  Abs: '<S791>/Abs2'
             *  Sum: '<S791>/Sum12'
             *  Sum: '<S791>/Sum13'
             */
            rtb_Switch1_iw = (rtb_Gain_inb - rtb_MinMax1_jq) - fabsf
                (rtb_Switch_iy + rtb_Sum2_pk);
        }

        /* End of Switch: '<S805>/Switch1' */

        /* Switch: '<S773>/Switch1' incorporates:
         *  Constant: '<S778>/Calib'
         *  Constant: '<S779>/Calib'
         *  DataStoreRead: '<S751>/Data Store Read'
         *  DataStoreRead: '<S751>/Dsr_InputSpeedProfile1'
         *  Logic: '<S773>/Logical1'
         *  Logic: '<S773>/Logical6'
         *  Logic: '<S773>/Logical8'
         */
        if (((HeESSR_b_NiLmtBypsLoopJerk) && (VeESSR_b_NiMaxActive_DS)) ||
                ((VeESSR_b_NiDotMaxActive_DS) && (HeESSR_b_NiDotLmtBypsLoopJerk)))
        {
            /* Switch: '<S773>/Switch1' */
            rtb_Sum2_pk = rtb_Switch1_mdg;
        }
        else
        {
            /* Switch: '<S773>/Switch1' incorporates:
             *  DataStoreRead: '<S751>/Dsr_InputAcceltnProf'
             *  Sum: '<S773>/Sum1'
             */
            rtb_Sum2_pk += VeESSR_dn_InputAcceltnProf_DS;
        }

        /* End of Switch: '<S773>/Switch1' */

        /* Outputs for Atomic SubSystem: '<S773>/Limiter2' */
        /* Switch: '<S786>/Switch1' incorporates:
         *  RelationalOperator: '<S786>/Relational Operator'
         */
        if (rtb_Switch1_mdg < rtb_Sum2_pk)
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = rtb_Switch1_mdg;
        }

        /* End of Switch: '<S786>/Switch1' */

        /* Switch: '<S786>/Switch' incorporates:
         *  RelationalOperator: '<S786>/Relational Operator1'
         */
        if (rtb_Sum2_pk <= rtb_Switch1_iw)
        {
            /* Switch: '<S786>/Switch' */
            rtb_Sum2_pk = rtb_Switch1_iw;
        }

        /* End of Switch: '<S786>/Switch' */
        /* End of Outputs for SubSystem: '<S773>/Limiter2' */

        /* Outputs for Atomic SubSystem: '<S773>/Limiter4' */
        /* Switch: '<S788>/Switch1' incorporates:
         *  DataStoreRead: '<S751>/Dsr_NiProfGenNiDMax'
         *  RelationalOperator: '<S788>/Relational Operator'
         */
        if (VeESSR_dn_StrtTypNiDotMax_DS < rtb_Sum2_pk)
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = VeESSR_dn_StrtTypNiDotMax_DS;
        }

        /* End of Switch: '<S788>/Switch1' */

        /* Switch: '<S788>/Switch' incorporates:
         *  DataStoreRead: '<S751>/Dsr_NiProfGenNiDMin'
         *  RelationalOperator: '<S788>/Relational Operator1'
         */
        if (rtb_Sum2_pk > VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S788>/Switch' */
            rtb_Switch_iy = rtb_Sum2_pk;
        }
        else
        {
            /* Switch: '<S788>/Switch' */
            rtb_Switch_iy = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Switch: '<S788>/Switch' */
        /* End of Outputs for SubSystem: '<S773>/Limiter4' */

        /* Sum: '<S777>/Sum6' incorporates:
         *  DataStoreRead: '<S751>/Dsr_InputSpeedProfile3'
         */
        rtb_Sum6_lr = rtu_VeHSER_n_NiMax - VeESSR_n_InputSpeedProfile_DS;

        /* Abs: '<S777>/Abs2' */
        rtb_Sum2_pk = fabsf(rtb_Sum6_lr);

        /* Switch: '<S777>/Switch' incorporates:
         *  Constant: '<S777>/Constant Value7'
         *  RelationalOperator: '<S777>/Comparison2'
         */
        if (rtb_Sum6_lr < 0.0F)
        {
            /* MinMax: '<S776>/MinMax1' incorporates:
             *  Abs: '<S777>/Abs'
             */
            rtb_MinMax1_jq = fabsf(rtb_Sum15);
        }
        else
        {
            /* MinMax: '<S776>/MinMax1' incorporates:
             *  Abs: '<S777>/Abs1'
             *  Gain: '<S777>/Gain'
             */
            rtb_MinMax1_jq = -fabsf(rtb_Product4);
        }

        /* End of Switch: '<S777>/Switch' */

        /* Product: '<S777>/Product4' incorporates:
         *  Constant: '<S759>/Calib'
         */
        rtb_Product4_of = (rtb_MinMax1_jq * HeESSR_t_MedTEB_dT) *
            HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S777>/Protected Division1' */
        /* Switch: '<S800>/Switch1' incorporates:
         *  Constant: '<S800>/Constant Value'
         *  Constant: '<S800>/Constant Value1'
         *  Constant: '<S800>/Constant Value2'
         *  Logic: '<S800>/AND'
         *  RelationalOperator: '<S800>/Greater Than or Equal '
         *  RelationalOperator: '<S800>/Not Equal'
         *  RelationalOperator: '<S800>/Not Equal1'
         *  Switch: '<S800>/Switch2'
         */
        if ((rtb_Sum2_pk != 0.0F) && (rtb_Product4_of != 0.0F))
        {
            /* Switch: '<S800>/Switch1' incorporates:
             *  Product: '<S800>/Division'
             */
            rtb_Sum2_pk /= rtb_Product4_of;
        }
        else if (rtb_Sum2_pk > 0.0F)
        {
            /* Switch: '<S800>/Switch2' incorporates:
             *  Constant: '<S800>/MAXFLOAT'
             *  Switch: '<S800>/Switch1'
             */
            rtb_Sum2_pk = 3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S800>/Switch1' incorporates:
             *  Constant: '<S800>/Constant Value4'
             *  Switch: '<S800>/Switch2'
             *  Switch: '<S800>/Switch3'
             */
            rtb_Sum2_pk = 0.0F;
        }

        /* End of Switch: '<S800>/Switch1' */
        /* End of Outputs for SubSystem: '<S777>/Protected Division1' */

        /* Sum: '<S777>/Sum4' incorporates:
         *  Abs: '<S777>/Abs3'
         *  Constant: '<S777>/Constant Value3'
         *  Constant: '<S777>/Constant Value5'
         *  Product: '<S777>/Product3'
         */
        rtb_Sum2_pk = (fabsf(rtb_Sum2_pk) * 8.0F) + 1.0F;

        /* Switch: '<S801>/Switch' */
        if (rtb_Sum2_pk >= 0.0F)
        {
            /* Sum: '<S751>/Sum2' incorporates:
             *  Sqrt: '<S801>/Sqrt'
             */
            rtb_Sum2_pk = sqrtf(rtb_Sum2_pk);
        }
        else
        {
            /* Sum: '<S751>/Sum2' incorporates:
             *  Constant: '<S801>/Zero'
             */
            rtb_Sum2_pk = 0.0F;
        }

        /* End of Switch: '<S801>/Switch' */

        /* Sum: '<S751>/Sum2' incorporates:
         *  Constant: '<S777>/Constant Value'
         *  Constant: '<S777>/Constant Value4'
         *  Constant: '<S777>/Constant Value6'
         *  MinMax: '<S777>/MinMax1'
         *  Product: '<S777>/Product2'
         *  Rounding: '<S777>/Rounding1'
         *  Sum: '<S777>/Sum3'
         */
        rtb_Sum2_pk = fmaxf(ceilf((rtb_Sum2_pk - 1.0F) * 0.5F), 1.0F);

        /* Product: '<S777>/Product' incorporates:
         *  Constant: '<S759>/Calib'
         */
        rtb_Product4_of = rtb_Sum2_pk * HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S777>/Protected Division' */
        /* Switch: '<S799>/Switch1' incorporates:
         *  Constant: '<S799>/Constant Value'
         *  Constant: '<S799>/Constant Value1'
         *  Constant: '<S799>/Constant Value2'
         *  Constant: '<S799>/Constant Value3'
         *  Logic: '<S799>/AND'
         *  RelationalOperator: '<S799>/Greater Than or Equal '
         *  RelationalOperator: '<S799>/Greater Than or Equal 1'
         *  RelationalOperator: '<S799>/Not Equal'
         *  RelationalOperator: '<S799>/Not Equal1'
         *  Switch: '<S799>/Switch2'
         *  Switch: '<S799>/Switch3'
         */
        if ((rtb_Sum6_lr != 0.0F) && (rtb_Product4_of != 0.0F))
        {
            /* Switch: '<S799>/Switch1' incorporates:
             *  Product: '<S799>/Division'
             */
            rtb_Sum6_lr /= rtb_Product4_of;
        }
        else if (rtb_Sum6_lr > 0.0F)
        {
            /* Switch: '<S799>/Switch2' incorporates:
             *  Constant: '<S799>/MAXFLOAT'
             *  Switch: '<S799>/Switch1'
             */
            rtb_Sum6_lr = 3.402823466E+38F;
        }
        else if (rtb_Sum6_lr < 0.0F)
        {
            /* Switch: '<S799>/Switch3' incorporates:
             *  Constant: '<S799>/MINFLOAT'
             *  Switch: '<S799>/Switch1'
             *  Switch: '<S799>/Switch2'
             */
            rtb_Sum6_lr = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S799>/Switch1' incorporates:
             *  Constant: '<S799>/Constant Value4'
             *  Switch: '<S799>/Switch2'
             *  Switch: '<S799>/Switch3'
             */
            rtb_Sum6_lr = 0.0F;
        }

        /* End of Switch: '<S799>/Switch1' */
        /* End of Outputs for SubSystem: '<S777>/Protected Division' */

        /* Sum: '<S777>/Sum' incorporates:
         *  Constant: '<S759>/Calib'
         *  Constant: '<S777>/Constant Value1'
         *  Constant: '<S777>/Constant Value2'
         *  Product: '<S777>/Product1'
         *  Sum: '<S777>/Sum2'
         */
        rtb_MinMax1_jq = rtb_Sum6_lr - (((0.5F * rtb_MinMax1_jq) * (rtb_Sum2_pk
            - 1.0F)) * HeESSR_t_MedTEB_dT);

        /* Switch: '<S773>/Switch4' incorporates:
         *  Constant: '<S780>/Calib'
         */
        if (!HeESSR_b_NiLmtForAccelByps)
        {
            /* Switch: '<S773>/Switch4' incorporates:
             *  MinMax: '<S773>/MinMax1'
             */
            rtb_Switch_iy = fminf(rtb_MinMax1_jq, rtb_Switch_iy);
        }

        /* End of Switch: '<S773>/Switch4' */

        /* Outputs for Atomic SubSystem: '<S773>/Limiter13' */
        /* RelationalOperator: '<S785>/Relational Operator' */
        rtb_RelationalOperator_d0d = (rtu_VeHSER_dn_NiDotMax <= rtb_Switch_iy);

        /* Switch: '<S785>/Switch1' */
        if (rtb_RelationalOperator_d0d)
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = rtu_VeHSER_dn_NiDotMax;
        }
        else
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = rtb_Switch_iy;
        }

        /* End of Switch: '<S785>/Switch1' */

        /* Switch: '<S785>/Switch' incorporates:
         *  RelationalOperator: '<S785>/Relational Operator1'
         */
        if (rtb_Sum2_pk <= rtu_VeHSER_dn_NiDotMin)
        {
            rtb_Sum2_pk = rtu_VeHSER_dn_NiDotMin;
        }

        /* End of Switch: '<S785>/Switch' */
        /* End of Outputs for SubSystem: '<S773>/Limiter13' */

        /* Product: '<S773>/Product9' incorporates:
         *  Constant: '<S759>/Calib'
         */
        rtb_Switch_iy = rtb_Sum2_pk * HeESSR_t_MedTEB_dT;

        /* Switch: '<S773>/Switch2' incorporates:
         *  Constant: '<S778>/Calib'
         *  DataStoreRead: '<S751>/Dsr_InputSpeedProfile2'
         *  Logic: '<S773>/Logical3'
         */
        if ((HeESSR_b_NiDotLmtBypsLoopJerk) && (VeESSR_b_NiDotMinActive_DS))
        {
            /* Switch: '<S773>/Switch2' */
            rtb_Gain_nf = rtb_Switch1_iw;
        }
        else
        {
            /* Switch: '<S773>/Switch2' incorporates:
             *  DataStoreRead: '<S751>/Dsr_InputAcceltnProf'
             *  Sum: '<S773>/Sum16'
             */
            rtb_Gain_nf += VeESSR_dn_InputAcceltnProf_DS;
        }

        /* End of Switch: '<S773>/Switch2' */

        /* Outputs for Atomic SubSystem: '<S773>/Limiter' */
        /* Switch: '<S783>/Switch1' incorporates:
         *  RelationalOperator: '<S783>/Relational Operator'
         */
        if (rtb_Switch1_mdg < rtb_Gain_nf)
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = rtb_Switch1_mdg;
        }
        else
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = rtb_Gain_nf;
        }

        /* End of Switch: '<S783>/Switch1' */

        /* Switch: '<S783>/Switch' incorporates:
         *  RelationalOperator: '<S783>/Relational Operator1'
         */
        if (rtb_Sum2_pk > rtb_Switch1_iw)
        {
            /* Switch: '<S783>/Switch' */
            rtb_Gain_nf = rtb_Sum2_pk;
        }
        else
        {
            /* Switch: '<S783>/Switch' */
            rtb_Gain_nf = rtb_Switch1_iw;
        }

        /* End of Switch: '<S783>/Switch' */
        /* End of Outputs for SubSystem: '<S773>/Limiter' */

        /* Outputs for Atomic SubSystem: '<S773>/Limiter3' */
        /* Switch: '<S787>/Switch1' incorporates:
         *  DataStoreRead: '<S751>/Dsr_NiProfGenNiDMax'
         *  RelationalOperator: '<S787>/Relational Operator'
         */
        if (VeESSR_dn_StrtTypNiDotMax_DS < rtb_Gain_nf)
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = VeESSR_dn_StrtTypNiDotMax_DS;
        }
        else
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = rtb_Gain_nf;
        }

        /* End of Switch: '<S787>/Switch1' */
        /* End of Outputs for SubSystem: '<S773>/Limiter3' */

        /* Switch: '<S773>/Switch5' incorporates:
         *  Constant: '<S780>/Calib'
         *  DataStoreRead: '<S751>/Dsr_NiProfGenNiDMin'
         *  RelationalOperator: '<S787>/Relational Operator1'
         *  Switch: '<S787>/Switch'
         */
        if (HeESSR_b_NiLmtForAccelByps)
        {
            /* Outputs for Atomic SubSystem: '<S773>/Limiter3' */
            /* Switch: '<S787>/Switch' incorporates:
             *  DataStoreRead: '<S751>/Dsr_NiProfGenNiDMin'
             *  RelationalOperator: '<S787>/Relational Operator1'
             */
            if (rtb_Sum2_pk > VeESSR_dn_StrtTypNiDotMin_DS)
            {
                /* Switch: '<S773>/Switch5' */
                rtb_Gain_nf = rtb_Sum2_pk;
            }
            else
            {
                /* Switch: '<S773>/Switch5' */
                rtb_Gain_nf = VeESSR_dn_StrtTypNiDotMin_DS;
            }

            /* End of Outputs for SubSystem: '<S773>/Limiter3' */
        }
        else
        {
            /* Outputs for Atomic SubSystem: '<S773>/Limiter3' */
            if (rtb_Sum2_pk <= VeESSR_dn_StrtTypNiDotMin_DS)
            {
                /* Switch: '<S787>/Switch' incorporates:
                 *  DataStoreRead: '<S751>/Dsr_NiProfGenNiDMin'
                 */
                rtb_Sum2_pk = VeESSR_dn_StrtTypNiDotMin_DS;
            }

            /* End of Outputs for SubSystem: '<S773>/Limiter3' */

            /* Switch: '<S773>/Switch5' incorporates:
             *  MinMax: '<S773>/MinMax2'
             */
            rtb_Gain_nf = fminf(rtb_MinMax1_jq, rtb_Sum2_pk);
        }

        /* End of Switch: '<S773>/Switch5' */

        /* Outputs for Atomic SubSystem: '<S773>/Limiter9' */
        /* Switch: '<S790>/Switch1' incorporates:
         *  RelationalOperator: '<S790>/Relational Operator'
         */
        if (rtu_VeHSER_dn_NiDotMax <= rtb_Gain_nf)
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = rtu_VeHSER_dn_NiDotMax;
        }
        else
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = rtb_Gain_nf;
        }

        /* End of Switch: '<S790>/Switch1' */

        /* RelationalOperator: '<S789>/Relational Operator1' incorporates:
         *  RelationalOperator: '<S790>/Relational Operator1'
         */
        rtb_RelationalOperator1_mu = (rtb_Sum2_pk > rtu_VeHSER_dn_NiDotMin);

        /* Logic: '<S790>/Logical2' */
        rtb_Logical2_ir = !rtb_RelationalOperator1_mu;

        /* Switch: '<S790>/Switch' */
        if (!rtb_RelationalOperator1_mu)
        {
            rtb_Sum2_pk = rtu_VeHSER_dn_NiDotMin;
        }

        /* End of Switch: '<S790>/Switch' */
        /* End of Outputs for SubSystem: '<S773>/Limiter9' */

        /* Product: '<S773>/Product10' incorporates:
         *  Constant: '<S759>/Calib'
         */
        rtb_Gain_nf = rtb_Sum2_pk * HeESSR_t_MedTEB_dT;

        /* Sum: '<S773>/Sum2' incorporates:
         *  DataStoreRead: '<S751>/Dsr_InputSpeedProfile3'
         */
        rtb_Switch1_mdg = rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS;

        /* Sum: '<S776>/Sum6' incorporates:
         *  Constant: '<S759>/Calib'
         *  DataStoreRead: '<S751>/Dsr_InputSpeedProfile3'
         *  Product: '<S776>/Product7'
         *  Sum: '<S773>/Sum6'
         *  Switch: '<S773>/Switch3'
         */
        rtb_IntegerDelay = (rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS) -
            (rtb_Gain_inb * HeESSR_t_MedTEB_dT);

        /* Abs: '<S776>/Abs2' incorporates:
         *  Sum: '<S776>/Sum6'
         */
        rtb_MinMax1_jq = fabsf(rtb_IntegerDelay);

        /* Switch: '<S776>/Switch' incorporates:
         *  Constant: '<S776>/Constant Value7'
         *  RelationalOperator: '<S776>/Comparison2'
         *  Sum: '<S776>/Sum6'
         */
        if (rtb_IntegerDelay < 0.0F)
        {
            /* Sum: '<S751>/Sum2' incorporates:
             *  Abs: '<S776>/Abs'
             */
            rtb_Sum2_pk = fabsf(rtb_Sum15);
        }
        else
        {
            /* Sum: '<S751>/Sum2' incorporates:
             *  Abs: '<S776>/Abs1'
             *  Gain: '<S776>/Gain'
             */
            rtb_Sum2_pk = -fabsf(rtb_Product4);
        }

        /* End of Switch: '<S776>/Switch' */

        /* Product: '<S776>/Product4' incorporates:
         *  Constant: '<S759>/Calib'
         */
        rtb_Product4 = (rtb_Sum2_pk * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S776>/Protected Division1' */
        /* Switch: '<S796>/Switch1' incorporates:
         *  Constant: '<S796>/Constant Value'
         *  Constant: '<S796>/Constant Value1'
         *  Constant: '<S796>/Constant Value2'
         *  Logic: '<S796>/AND'
         *  RelationalOperator: '<S796>/Greater Than or Equal '
         *  RelationalOperator: '<S796>/Not Equal'
         *  RelationalOperator: '<S796>/Not Equal1'
         *  Switch: '<S796>/Switch2'
         */
        if ((rtb_MinMax1_jq != 0.0F) && (rtb_Product4 != 0.0F))
        {
            /* Switch: '<S796>/Switch1' incorporates:
             *  Product: '<S796>/Division'
             */
            rtb_Product4 = rtb_MinMax1_jq / rtb_Product4;
        }
        else if (rtb_MinMax1_jq > 0.0F)
        {
            /* Switch: '<S796>/Switch2' incorporates:
             *  Constant: '<S796>/MAXFLOAT'
             *  Switch: '<S796>/Switch1'
             */
            rtb_Product4 = 3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S796>/Switch1' incorporates:
             *  Constant: '<S796>/Constant Value4'
             *  Switch: '<S796>/Switch2'
             *  Switch: '<S796>/Switch3'
             */
            rtb_Product4 = 0.0F;
        }

        /* End of Switch: '<S796>/Switch1' */
        /* End of Outputs for SubSystem: '<S776>/Protected Division1' */

        /* Sum: '<S776>/Sum4' incorporates:
         *  Abs: '<S776>/Abs3'
         *  Constant: '<S776>/Constant Value3'
         *  Constant: '<S776>/Constant Value5'
         *  Product: '<S776>/Product3'
         */
        rtb_Product4 = (fabsf(rtb_Product4) * 8.0F) + 1.0F;

        /* Switch: '<S797>/Switch' incorporates:
         *  Constant: '<S797>/Zero'
         *  Sqrt: '<S797>/Sqrt'
         */
        if (rtb_Product4 >= 0.0F)
        {
            rtb_Product4 = sqrtf(rtb_Product4);
        }
        else
        {
            rtb_Product4 = 0.0F;
        }

        /* End of Switch: '<S797>/Switch' */

        /* MinMax: '<S776>/MinMax1' incorporates:
         *  Constant: '<S776>/Constant Value'
         *  Constant: '<S776>/Constant Value4'
         *  Constant: '<S776>/Constant Value6'
         *  Product: '<S776>/Product2'
         *  Rounding: '<S776>/Rounding1'
         *  Sum: '<S776>/Sum3'
         */
        rtb_MinMax1_jq = fmaxf(ceilf((rtb_Product4 - 1.0F) * 0.5F), 1.0F);

        /* Product: '<S776>/Product' incorporates:
         *  Constant: '<S759>/Calib'
         */
        rtb_Product4 = rtb_MinMax1_jq * HeESSR_t_MedTEB_dT;

        /* Outputs for Atomic SubSystem: '<S776>/Protected Division' */
        /* Switch: '<S795>/Switch1' incorporates:
         *  Constant: '<S795>/Constant Value'
         *  Constant: '<S795>/Constant Value1'
         *  Constant: '<S795>/Constant Value2'
         *  Constant: '<S795>/Constant Value3'
         *  Logic: '<S795>/AND'
         *  RelationalOperator: '<S795>/Greater Than or Equal '
         *  RelationalOperator: '<S795>/Greater Than or Equal 1'
         *  RelationalOperator: '<S795>/Not Equal'
         *  RelationalOperator: '<S795>/Not Equal1'
         *  Sum: '<S776>/Sum6'
         *  Switch: '<S795>/Switch2'
         *  Switch: '<S795>/Switch3'
         */
        if ((rtb_IntegerDelay != 0.0F) && (rtb_Product4 != 0.0F))
        {
            /* Switch: '<S795>/Switch1' incorporates:
             *  Product: '<S795>/Division'
             */
            rtb_Product4 = rtb_IntegerDelay / rtb_Product4;
        }
        else if (rtb_IntegerDelay > 0.0F)
        {
            /* Switch: '<S795>/Switch2' incorporates:
             *  Constant: '<S795>/MAXFLOAT'
             *  Switch: '<S795>/Switch1'
             */
            rtb_Product4 = 3.402823466E+38F;
        }
        else if (rtb_IntegerDelay < 0.0F)
        {
            /* Switch: '<S795>/Switch3' incorporates:
             *  Constant: '<S795>/MINFLOAT'
             *  Switch: '<S795>/Switch1'
             *  Switch: '<S795>/Switch2'
             */
            rtb_Product4 = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S795>/Switch1' incorporates:
             *  Constant: '<S795>/Constant Value4'
             *  Switch: '<S795>/Switch2'
             *  Switch: '<S795>/Switch3'
             */
            rtb_Product4 = 0.0F;
        }

        /* End of Switch: '<S795>/Switch1' */
        /* End of Outputs for SubSystem: '<S776>/Protected Division' */

        /* Switch: '<S773>/Switch3' incorporates:
         *  Constant: '<S781>/Calib'
         */
        if (!HeESSR_b_TrnstnJerkByps)
        {
            /* Switch: '<S773>/Switch8' incorporates:
             *  Constant: '<S773>/Constant Value7'
             *  RelationalOperator: '<S773>/Comparison'
             */
            if (rtb_IntegerDelay > 0.0F)
            {
                /* Switch: '<S773>/Switch3' incorporates:
                 *  Constant: '<S759>/Calib'
                 *  Constant: '<S776>/Constant Value1'
                 *  Constant: '<S776>/Constant Value2'
                 *  MinMax: '<S773>/MinMax4'
                 *  Product: '<S773>/Product5'
                 *  Product: '<S776>/Product1'
                 *  Sum: '<S776>/Sum'
                 *  Sum: '<S776>/Sum2'
                 *  Switch: '<S773>/Switch8'
                 */
                rtb_Switch1_mdg = fminf(rtb_Switch1_mdg, ((rtb_Product4 +
                    rtb_Gain_inb) - (((0.5F * rtb_Sum2_pk) * (rtb_MinMax1_jq -
                    1.0F)) * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
            }
            else
            {
                /* Switch: '<S773>/Switch3' incorporates:
                 *  Constant: '<S759>/Calib'
                 *  Constant: '<S776>/Constant Value1'
                 *  Constant: '<S776>/Constant Value2'
                 *  MinMax: '<S773>/MinMax5'
                 *  Product: '<S773>/Product2'
                 *  Product: '<S776>/Product1'
                 *  Sum: '<S776>/Sum'
                 *  Sum: '<S776>/Sum2'
                 *  Switch: '<S773>/Switch8'
                 */
                rtb_Switch1_mdg = fmaxf(rtb_Switch1_mdg, ((rtb_Product4 +
                    rtb_Gain_inb) - (((0.5F * rtb_Sum2_pk) * (rtb_MinMax1_jq -
                    1.0F)) * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
            }

            /* End of Switch: '<S773>/Switch8' */
        }

        /* Outputs for Atomic SubSystem: '<S773>/Limiter6' */
        /* RelationalOperator: '<S789>/Relational Operator' */
        rtb_RelationalOperator_f0 = (rtb_Switch_iy <= rtb_Switch1_mdg);

        /* Switch: '<S789>/Switch1' */
        if (rtb_RelationalOperator_f0)
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = rtb_Switch_iy;
        }
        else
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = rtb_Switch1_mdg;
        }

        /* End of Switch: '<S789>/Switch1' */

        /* RelationalOperator: '<S789>/Relational Operator1' */
        rtb_RelationalOperator1_mu = (rtb_Sum2_pk > rtb_Gain_nf);

        /* End of Outputs for SubSystem: '<S773>/Limiter6' */

        /* Logic: '<S773>/Logical2' incorporates:
         *  DataStoreWrite: '<S751>/Dsw_InputSpeedProfile1'
         */
        VeESSR_b_NiDotMaxActive_DS = (rtb_RelationalOperator_d0d &&
            rtb_RelationalOperator_f0);

        /* DataStoreWrite: '<S751>/Dsw_InputSpeedProfile2' */
        VeESSR_n_TargetSpeed_DS = rtb_Gain1_gb;

        /* DataStoreWrite: '<S751>/Dsw_InputSpeedProfile3' */
        VeESSR_dn_TargetAcceltn_DS = rtb_Gain_inb;

        /* Outputs for Atomic SubSystem: '<S773>/Limiter6' */
        /* Logic: '<S773>/Logical' incorporates:
         *  DataStoreWrite: '<S751>/Dsw_InputSpeedProfile4'
         *  Logic: '<S789>/Logical2'
         */
        VeESSR_b_NiDotMinActive_DS = (rtb_Logical2_ir &&
            (!rtb_RelationalOperator1_mu));

        /* Switch: '<S789>/Switch' */
        if (rtb_RelationalOperator1_mu)
        {
            rtb_Gain_nf = rtb_Sum2_pk;
        }

        /* End of Switch: '<S789>/Switch' */
        /* End of Outputs for SubSystem: '<S773>/Limiter6' */

        /* Sum: '<S773>/Sum4' incorporates:
         *  DataStoreRead: '<S751>/Dsr_InputSpeedProfile3'
         */
        rtb_IntegerDelay = rtb_Gain_nf + VeESSR_n_InputSpeedProfile_DS;

        /* Outputs for Atomic SubSystem: '<S773>/Limiter1' */
        /* RelationalOperator: '<S784>/Relational Operator' incorporates:
         *  DataStoreWrite: '<S751>/Dsw_InputSpeedProfile5'
         */
        VeESSR_b_NiMaxActive_DS = (rtu_VeHSER_n_NiMax <= rtb_IntegerDelay);

        /* Switch: '<S784>/Switch1' incorporates:
         *  DataStoreWrite: '<S751>/Dsw_InputSpeedProfile5'
         */
        if (VeESSR_b_NiMaxActive_DS)
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = rtu_VeHSER_n_NiMax;
        }
        else
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = rtb_IntegerDelay;
        }

        /* End of Switch: '<S784>/Switch1' */

        /* Switch: '<S784>/Switch' incorporates:
         *  Constant: '<S773>/Constant Value4'
         *  RelationalOperator: '<S784>/Relational Operator1'
         */
        if (rtb_Sum2_pk > 0.0F)
        {
            /* Switch: '<S784>/Switch' */
            rtb_Product4 = rtb_Sum2_pk;
        }
        else
        {
            /* Switch: '<S784>/Switch' */
            rtb_Product4 = 0.0F;
        }

        /* End of Switch: '<S784>/Switch' */
        /* End of Outputs for SubSystem: '<S773>/Limiter1' */

        /* Abs: '<S758>/Abs' incorporates:
         *  Constant: '<S750>/Calib'
         *  Constant: '<S762>/Calib'
         *  Product: '<S758>/Multiplication'
         */
        rtb_Gain_inb = fabsf(KeESSR_dscl_RampUpRate * HeESSR_t_MedTEB_dT);

        /* Outputs for Atomic SubSystem: '<S758>/Limiter1' */
        /* Switch: '<S769>/Switch1' incorporates:
         *  Constant: '<S751>/Constant Value2'
         *  DataStoreRead: '<S751>/Dsr_SpdCtlGainMod1'
         *  RelationalOperator: '<S769>/Relational Operator'
         *  Sum: '<S758>/Sum'
         */
        if (rtb_Gain_inb < (1.0F - VeESSR_scl_SpdCtlGainMod_DS))
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = rtb_Gain_inb;
        }
        else
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = 1.0F - VeESSR_scl_SpdCtlGainMod_DS;
        }

        /* End of Switch: '<S769>/Switch1' */

        /* Switch: '<S769>/Switch' incorporates:
         *  Gain: '<S758>/Gain'
         *  RelationalOperator: '<S769>/Relational Operator1'
         */
        if (rtb_Sum2_pk <= (-rtb_Gain_inb))
        {
            rtb_Sum2_pk = -rtb_Gain_inb;
        }

        /* End of Switch: '<S769>/Switch' */
        /* End of Outputs for SubSystem: '<S758>/Limiter1' */

        /* Sum: '<S758>/Sum1' incorporates:
         *  DataStoreRead: '<S751>/Dsr_SpdCtlGainMod1'
         */
        rtb_IntegerDelay = rtb_Sum2_pk + VeESSR_scl_SpdCtlGainMod_DS;

        /* Outputs for Atomic SubSystem: '<S758>/Limiter2' */
        /* Switch: '<S770>/Switch1' incorporates:
         *  Constant: '<S751>/Constant Value7'
         *  RelationalOperator: '<S770>/Relational Operator'
         */
        if (2.0F < rtb_IntegerDelay)
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = 2.0F;
        }
        else
        {
            /* Sum: '<S751>/Sum2' */
            rtb_Sum2_pk = rtb_IntegerDelay;
        }

        /* End of Switch: '<S770>/Switch1' */

        /* Switch: '<S770>/Switch' incorporates:
         *  Constant: '<S751>/Constant Value6'
         *  RelationalOperator: '<S770>/Relational Operator1'
         */
        if (rtb_Sum2_pk > 0.0F)
        {
            /* Lookup_n-D: '<S754>/Vector' */
            rtb_IntegerDelay = rtb_Sum2_pk;
        }
        else
        {
            /* Lookup_n-D: '<S754>/Vector' */
            rtb_IntegerDelay = 0.0F;
        }

        /* End of Switch: '<S770>/Switch' */
        /* End of Outputs for SubSystem: '<S758>/Limiter2' */

        /* Sum: '<S751>/Sum2' incorporates:
         *  Constant: '<S759>/Calib'
         *  DataStoreRead: '<S751>/Dsr_InputSpeedProfile3'
         *  Product: '<S773>/Product3'
         *  Sum: '<S773>/Sum'
         */
        rtb_Sum2_pk = (rtb_Product4 - VeESSR_n_InputSpeedProfile_DS) /
            HeESSR_t_MedTEB_dT;

        /* Merge: '<S741>/Merge1' incorporates:
         *  Gain: '<S765>/Gain'
         */
        rtb_Gain_inb = rtb_Sum2_pk;

        /* Sum: '<S773>/Sum17' incorporates:
         *  DataStoreRead: '<S751>/Dsr_InputAcceltnProf'
         */
        VeESSR_dn_InputJerkProfAchIdle12V = rtb_Sum2_pk -
            VeESSR_dn_InputAcceltnProf_DS;

        /* Merge: '<S741>/Merge4' incorporates:
         *  Constant: '<S760>/Calib'
         *  SignalConversion generated from: '<S751>/K_Filt_EngTrqReqPrdtdImmed'
         */
        rtb_Gain_nf = KeESSR_K_AchIdle12vStrtNiClsdLoopEngCmdFlt;

        /* Merge: '<S741>/Merge5' incorporates:
         *  DataStoreRead: '<S741>/Dsr_InputTorqEst'
         *  Lookup_n-D: '<S764>/Vector'
         *  Sum: '<S751>/Sum2'
         */
        rtb_Sum15 = look1_iflf_binlcapw(rtu_VeESSR_M_EngTrqAct_Lmtd -
            VeESSR_M_EngTorqEst_DS, ((const float32 *)
            &(KxESSR_K_TiEstBlndAchIdle12vStrt[0])), ((const float32 *)
            &(KtESSR_K_TiEstBlndAchIdle12vStrt[0])), 6U);

        /* Update for UnitDelay: '<S792>/Unit Delay' incorporates:
         *  Switch: '<S792>/Switch3'
         */
        localDW->UnitDelay_DSTATE = rtb_Summation_lr;

        /* Update for Delay: '<S773>/IntegerDelay' */
        localDW->icLoad = 0U;
        for (i = 0; i < 15; i++)
        {
            localDW->IntegerDelay_DSTATE[i] = localDW->IntegerDelay_DSTATE[i + 1];
        }

        localDW->IntegerDelay_DSTATE[15] = rtb_Gain1_gb;

        /* End of Update for Delay: '<S773>/IntegerDelay' */
        /* End of Outputs for SubSystem: '<S741>/ICSR_Ctrl' */
    }

    /* End of If: '<S741>/If' */

    /* MinMax: '<S741>/Maximum1' incorporates:
     *  Constant: '<S753>/Calib'
     */
    rtb_Summation_lr = fmaxf(rtu_VeESSR_M_OptEngTrqReq,
        KeESSR_M_MinStartDetectTorq);

    /* DataStoreWrite: '<S741>/Dsw_EngTrqReqImmed' incorporates:
     *  DataStoreRead: '<S741>/Dsr_EngTrqReqPrdtd1'
     *  Product: '<S746>/Multiplication'
     *  Sum: '<S746>/Subtraction'
     *  Sum: '<S746>/Subtraction1'
     */
    VeESSR_M_EngTrqReqImmed_DS = ((rtb_Summation_lr - VeESSR_M_EngTrqReqImmed_DS)
        * rtb_Gain_nf) + VeESSR_M_EngTrqReqImmed_DS;

    /* DataStoreWrite: '<S741>/Dsw_EngTrqReqPrdtd1' incorporates:
     *  DataStoreRead: '<S741>/Dsr_EngTrqReqPrdtd3'
     *  Product: '<S745>/Multiplication'
     *  Sum: '<S745>/Subtraction'
     *  Sum: '<S745>/Subtraction1'
     */
    VeESSR_M_EngTrqReqPrdtd_DS = ((rtb_Summation_lr - VeESSR_M_EngTrqReqPrdtd_DS)
        * rtb_Gain_nf) + VeESSR_M_EngTrqReqPrdtd_DS;

    /* DataStoreWrite: '<S741>/Dsw_InputAcceltnProf' */
    VeESSR_dn_InputAcceltnProf_DS = rtb_Gain_inb;

    /* DataStoreWrite: '<S741>/Dsw_InputSpeedProfile' */
    VeESSR_n_InputSpeedProfile_DS = rtb_Product4;

    /* DataStoreWrite: '<S741>/Dsw_InputTorqEst' incorporates:
     *  DataStoreRead: '<S741>/Dsr_InputTorqEst'
     *  Product: '<S744>/Multiplication'
     *  Sum: '<S744>/Subtraction'
     *  Sum: '<S744>/Subtraction1'
     */
    VeESSR_M_EngTorqEst_DS = ((rtu_VeESSR_M_EngTrqAct_Lmtd -
        VeESSR_M_EngTorqEst_DS) * rtb_Sum15) + VeESSR_M_EngTorqEst_DS;

    /* DataStoreWrite: '<S741>/Dsw_Ni1stFlt_DS' */
    VeESSR_n_Ni1stFlt_DS = rtb_Summation_knd;

    /* DataStoreWrite: '<S741>/Dsw_STMTmr' incorporates:
     *  Constant: '<S750>/Calib'
     *  DataStoreRead: '<S741>/Dsr_STMTmr'
     *  Sum: '<S741>/Summation1'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* DataStoreWrite: '<S741>/Dsw_SpdCtlGainMod1' */
    VeESSR_scl_SpdCtlGainMod_DS = rtb_IntegerDelay;

    /* Switch: '<S752>/Switch1' incorporates:
     *  Constant: '<S747>/Constant'
     *  DataStoreRead: '<S741>/Dsr_STMTmr2'
     *  DataStoreWrite: '<S741>/Dsw_STMTrigger1'
     *  Lookup_n-D: '<S754>/Vector'
     *  RelationalOperator: '<S741>/Greater  Than2'
     */
    if (VeESSR_t_STMTmr_DS > look1_iflf_binlcapw(rtu_VeENGR_T_EngCoolantTemp, ((
            const float32 *)&(KxESSR_t_AchIdleTime[0])), ((const float32 *)
            &(KtESSR_t_AchIdleTime[0])), 2U))
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngRun;
    }

    /* End of Switch: '<S752>/Switch1' */
}

#endif

/* System initialize for function-call system: '<S570>/StartEngPFS_Dur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_StartEngPFS_Dur_Init(P2VAR
    (DW_StartEngPFS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW)
{
    /* InitializeConditions for Delay: '<S2149>/IntegerDelay' */
    localDW->icLoad = 1U;
}

#endif

/* Output and update for function-call system: '<S570>/StartEngPFS_Dur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_StartEngPFS_Dur(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_OptEngTrqReq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_OptInputSpd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngStrtTorqSnsd, VAR(boolean, AUTOMATIC)
    rtu_VeENGR_b_EngCombustionCmnd, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngTrqActual, VAR(boolean, AUTOMATIC) rtu_VeRTMR_b_InPlantMode,
    VAR(float32, AUTOMATIC) rtu_BatModTmp, VAR(boolean, AUTOMATIC)
    rtu_VeSTRR_b_BackupStrtEngOn, VAR(TeENGR_e_ETRQ_Mode, AUTOMATIC)
    rtu_VeENGR_e_ETRQ_Mode, VAR(float32, AUTOMATIC) rtu_VeESSR_n_TransInSpdFlt,
    VAR(float32, AUTOMATIC) rtu_VeOHSR_n_IdleSpdBlended, VAR(float32, AUTOMATIC)
    rtu_VeHSER_n_NiMax, VAR(float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMax, VAR
    (float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMin, VAR(float32, AUTOMATIC)
    rtu_HTDR_TiMin, VAR(boolean, AUTOMATIC) rtu_PNLimActv, VAR(float32,
    AUTOMATIC) rtu_PNLimTrq, VAR(float32, AUTOMATIC) rtu_TactTiMin, P2VAR
    (DW_StartEngPFS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR
    (ZCE_StartEngPFS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localZCE, P2VAR
    (uint32, AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_g_StrtStpFailRsn)
{
    sint32 i;
    float32 rtb_Abs_do;
    float32 rtb_Abs_om;
    float32 rtb_Dsr_STMTmr_nr;
    float32 rtb_Gain_oh;
    float32 rtb_MinMax1_h;
    float32 rtb_Product4;
    float32 rtb_Product4_h;
    float32 rtb_Sum6_l5;
    float32 rtb_Sum_ix;
    float32 rtb_Summation_e1;
    float32 rtb_Switch1_d2;
    float32 rtb_Switch1_lps;
    float32 rtb_Switch1_nzn;
    float32 rtb_Switch3_fu;
    float32 rtb_Switch4_pe;
    float32 rtb_Switch_aes;
    float32 rtb_Vector_cq;
    uint8 tmp;
    boolean rtb_Equal2_k;
    boolean rtb_GreaterThan1_fm;
    boolean rtb_Logical4_c3;
    boolean rtb_Logical5_gk;
    boolean rtb_Logical5_je;
    boolean rtb_LogicalOperator3_n;
    boolean rtb_LogicalOperator4_b;
    boolean rtb_RelationalOperator1_cd;

    /* RelationalOperator: '<S2076>/Greater  Than1' incorporates:
     *  Constant: '<S2099>/Calib'
     *  DataStoreRead: '<S2076>/Dsr_STMTmr1'
     */
    rtb_GreaterThan1_fm = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmStartEngPFS);

    /* Logic: '<S2076>/Logical5' incorporates:
     *  Constant: '<S2094>/Calib'
     *  Constant: '<S2095>/Calib'
     *  DataStoreRead: '<S2076>/Data Store Read1'
     *  Logic: '<S2076>/Logical2'
     *  Logic: '<S2076>/Logical3'
     *  Logic: '<S2076>/Logical8'
     */
    rtb_Logical5_je = (((!KeESSR_b_DsblEVStrtFailed_InPlant) ||
                        (!rtu_VeRTMR_b_InPlantMode)) &&
                       (((KeESSR_b_AllowEV_StrtFailed) ||
                         rtu_VeSTRR_b_BackupStrtEngOn) ||
                        (VeESSR_b_AStrtReattmptAllowed_DS)));

    /* Logic: '<S2076>/Logical1' incorporates:
     *  DataStoreWrite: '<S2076>/Dsw_AStrtFailed'
     */
    VeESSR_b_AStrtFailed_DS = (rtb_GreaterThan1_fm && rtb_Logical5_je);

    /* Switch: '<S2087>/Switch1' incorporates:
     *  Constant: '<S2076>/Constant Value3'
     *  DataStoreRead: '<S2076>/Dsr_STMTmr3'
     *  DataStoreWrite: '<S2076>/Dsw_AStrtFailed'
     *  DataStoreWrite: '<S2076>/Dsw_AStrtFailed1'
     *  Sum: '<S2076>/Sum3'
     */
    if (VeESSR_b_AStrtFailed_DS)
    {
        VeESSR_Cnt_AStrtFailAttmptCntr_DS = (uint8)(((uint32)
            VeESSR_Cnt_AStrtFailAttmptCntr_DS) + 1U);
    }

    /* End of Switch: '<S2087>/Switch1' */

    /* RelationalOperator: '<S2076>/Greater  Than3' incorporates:
     *  Constant: '<S2093>/Calib'
     *  DataStoreWrite: '<S2076>/Dsw_AStrtFailed1'
     *  DataStoreWrite: '<S2076>/Dsw_AStrtFailed3'
     */
    VeESSR_b_AStrtReattmptAllowed_DS = (VeESSR_Cnt_AStrtFailAttmptCntr_DS <=
        KeESSR_Cnt_AStrtFailMaxAttmpts);

    /* Switch: '<S2076>/Switch2' incorporates:
     *  Constant: '<S2085>/Constant'
     *  DataStoreWrite: '<S2076>/Dsw_EngStrtType2'
     */
    if (rtu_VeENGR_b_EngCombustionCmnd)
    {
        VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Startng;
    }

    /* End of Switch: '<S2076>/Switch2' */

    /* DataStoreRead: '<S2076>/Dsr_STMTmr' */
    rtb_Dsr_STMTmr_nr = VeESSR_t_STMTmr_DS;

    /* Switch: '<S2088>/Switch1' incorporates:
     *  Constant: '<S2096>/Calib'
     *  Constant: '<S2097>/Calib'
     *  Constant: '<S2100>/Calib'
     *  DataStoreRead: '<S2076>/Dsr_STMTmr'
     *  DataStoreWrite: '<S2076>/Dsw_InhibitShiftToMode'
     *  RelationalOperator: '<S2076>/Greater  Than'
     */
    if (VeESSR_t_STMTmr_DS < KeESSR_t_ShftInhbtStrtEngPFSTm)
    {
        VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtStrtEngPFSStrt;
    }
    else
    {
        VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtStrtEngPFSEnd;
    }

    /* End of Switch: '<S2088>/Switch1' */

    /* Sum: '<S2076>/Summation1' incorporates:
     *  Constant: '<S2086>/Calib'
     *  DataStoreRead: '<S2076>/Dsr_STMTmr'
     *  DataStoreWrite: '<S2076>/Dsw_STMTmr'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Logic: '<S2081>/Logical Operator4' incorporates:
     *  Abs: '<S2081>/Abs'
     *  Constant: '<S2112>/Calib'
     *  Constant: '<S2113>/Calib'
     *  Logic: '<S2081>/Logical3'
     *  RelationalOperator: '<S2081>/Greater  Than1'
     *  RelationalOperator: '<S2081>/Relational Operator'
     *  Sum: '<S2081>/Add'
     */
    rtb_LogicalOperator4_b = ((fabsf(rtu_VeESSR_M_EngStrtTorqSnsd -
        rtu_VeETQR_M_EngTrqActual) < KeESSR_M_MaxEngTorqError) ||
        (rtu_VeESSR_M_EngStrtTorqSnsd > KeESSR_M_MinEngStrtTorqSnsd));

    /* RelationalOperator: '<S2076>/Equal2' incorporates:
     *  Constant: '<S2086>/Calib'
     */
    rtb_Equal2_k = (HeESSR_t_MedTEB_dT > rtb_Dsr_STMTmr_nr);

    /* Outputs for Atomic SubSystem: '<S2082>/Signal Latch On With Reset' */
    /* Outputs for Atomic SubSystem: '<S2081>/Signal Latch On With Reset' */
    /* Logic: '<S2118>/NOT' incorporates:
     *  Logic: '<S2130>/NOT'
     */
    rtb_Logical4_c3 = !rtb_Equal2_k;

    /* End of Outputs for SubSystem: '<S2082>/Signal Latch On With Reset' */

    /* Logic: '<S2118>/OR1' incorporates:
     *  Logic: '<S2081>/Logical4'
     *  Logic: '<S2118>/NOT'
     *  Logic: '<S2118>/OR'
     *  UnitDelay: '<S2118>/Unit Delay'
     */
    rtb_RelationalOperator1_cd = ((rtb_LogicalOperator4_b &&
        rtu_VeENGR_b_EngCombustionCmnd) || (rtb_Logical4_c3 &&
        (localDW->UnitDelay_DSTATE_m)));

    /* Update for UnitDelay: '<S2118>/Unit Delay' */
    localDW->UnitDelay_DSTATE_m = rtb_RelationalOperator1_cd;

    /* End of Outputs for SubSystem: '<S2081>/Signal Latch On With Reset' */

    /* Sum: '<S2092>/Sum4' incorporates:
     *  Constant: '<S2144>/Calib'
     */
    rtb_Dsr_STMTmr_nr = rtu_VeOHSR_n_IdleSpdBlended - KeESSR_n_DeltaIdleSpd;

    /* Switch: '<S2092>/Switch1' incorporates:
     *  Constant: '<S2141>/Calib'
     */
    if (HeESSR_b_NiTrgtIdleSpdStrtEng)
    {
        /* Switch: '<S2092>/Switch1' */
        VeESSR_n_NiTargetStrtEng_PFS = rtb_Dsr_STMTmr_nr;
    }
    else
    {
        /* Switch: '<S2092>/Switch1' */
        VeESSR_n_NiTargetStrtEng_PFS = rtu_VeESSR_n_OptInputSpd;
    }

    /* End of Switch: '<S2092>/Switch1' */

    /* Logic: '<S2081>/Logical Operator3' incorporates:
     *  Constant: '<S2111>/Calib'
     *  Logic: '<S2081>/Logical16'
     */
    rtb_LogicalOperator3_n = !HeESSR_b_DtrmnEngRunExtraPFS;

    /* Logic: '<S2081>/Logical17' incorporates:
     *  Logic: '<S2081>/Logical Operator2'
     */
    rtb_Logical5_gk = !rtu_VeENGR_b_EngCombustionCmnd;

    /* Outputs for Atomic SubSystem: '<S2108>/Accumulator Reset Limited' */
    /* Switch: '<S2119>/Switch1' incorporates:
     *  Constant: '<S2120>/Calib'
     *  Logic: '<S2081>/Logical1'
     *  Logic: '<S2081>/Logical17'
     *  Logic: '<S2081>/Logical2'
     *  Switch: '<S2108>/Switch'
     */
    if (rtb_Equal2_k || (rtb_Logical5_gk && (!rtb_LogicalOperator3_n)))
    {
        /* Switch: '<S2119>/Switch1' incorporates:
         *  Constant: '<S2108>/Constant Value1'
         */
        rtb_Summation_e1 = 0.0F;
    }
    else
    {
        if (HeESSR_b_48VEngStrtExitSpd)
        {
            /* Switch: '<S2108>/Switch' */
            rtb_Abs_do = VeESSR_n_NiTargetStrtEng_PFS;
        }
        else
        {
            /* Switch: '<S2108>/Switch' incorporates:
             *  Constant: '<S2123>/Calib'
             */
            rtb_Abs_do = KeESSR_n_EngStrtExitSpd;
        }

        /* Sum: '<S2119>/Summation' incorporates:
         *  Constant: '<S2121>/Calib'
         *  Constant: '<S2124>/Calib'
         *  Product: '<S2108>/Product'
         *  Sum: '<S2108>/Sum1'
         *  UnitDelay: '<S2119>/Unit Delay'
         */
        rtb_Summation_e1 = (((rtu_VeESSR_n_TransInSpdFlt -
                              KeESSR_n_EngStrtExitSpdDelta) - rtb_Abs_do) *
                            HeESSR_t_MedTEB_dT) + localDW->UnitDelay_DSTATE_f;

        /* Outputs for Atomic SubSystem: '<S2119>/Limiter' */
        /* Switch: '<S2125>/Switch1' incorporates:
         *  Constant: '<S2122>/Calib'
         *  RelationalOperator: '<S2125>/Relational Operator'
         */
        if (KeESSR_n_EngStrtExitIntgrlVal < rtb_Summation_e1)
        {
            /* Switch: '<S2125>/Switch1' */
            rtb_Summation_e1 = KeESSR_n_EngStrtExitIntgrlVal;
        }

        /* End of Switch: '<S2125>/Switch1' */

        /* Switch: '<S2125>/Switch' incorporates:
         *  Constant: '<S2108>/Constant Value1'
         *  RelationalOperator: '<S2125>/Relational Operator1'
         */
        if (rtb_Summation_e1 <= 0.0F)
        {
            /* Switch: '<S2119>/Switch1' */
            rtb_Summation_e1 = 0.0F;
        }

        /* End of Switch: '<S2125>/Switch' */
        /* End of Outputs for SubSystem: '<S2119>/Limiter' */
    }

    /* End of Switch: '<S2119>/Switch1' */

    /* Update for UnitDelay: '<S2119>/Unit Delay' */
    localDW->UnitDelay_DSTATE_f = rtb_Summation_e1;

    /* End of Outputs for SubSystem: '<S2108>/Accumulator Reset Limited' */

    /* RelationalOperator: '<S2108>/Comparison4' incorporates:
     *  Constant: '<S2122>/Calib'
     */
    VeESSR_b_SpdChk_StrtEngPFS = (rtb_Summation_e1 ==
        KeESSR_n_EngStrtExitIntgrlVal);

    /* Logic: '<S2081>/Logical13' incorporates:
     *  Constant: '<S2109>/Constant'
     *  Constant: '<S2110>/Constant'
     *  RelationalOperator: '<S2081>/Comparison5'
     *  RelationalOperator: '<S2081>/Comparison6'
     */
    VeESSR_b_ETRQStrtEngPFS = ((((uint32)rtu_VeENGR_e_ETRQ_Mode) ==
        CeENGR_e_DriverControl) || (((uint32)rtu_VeENGR_e_ETRQ_Mode) ==
        CeENGR_e_Idle));

    /* Sum: '<S2076>/Sum1' incorporates:
     *  DataStoreRead: '<S2076>/Dsr_EngTrqReqPrdtd1'
     *  DataStoreRead: '<S2076>/Dsr_StrtTypInitImmedTorq1'
     *  Sum: '<S2103>/Sum1'
     */
    rtb_Vector_cq = VeESSR_M_EngTrqReqPrdtd_DS - VeESSR_M_EngTrqReqImmed_DS;

    /* Switch: '<S2089>/Switch1' incorporates:
     *  Constant: '<S2080>/Constant'
     *  Constant: '<S2114>/Calib'
     *  Constant: '<S2115>/Calib'
     *  Constant: '<S2116>/Calib'
     *  DataStoreRead: '<S2081>/Dsr_STMTmr2'
     *  DataStoreWrite: '<S2076>/Dsw_STMTrigger'
     *  Logic: '<S2081>/AND'
     *  Logic: '<S2081>/Logical11'
     *  Logic: '<S2081>/Logical6'
     *  Logic: '<S2081>/Logical7'
     *  RelationalOperator: '<S2081>/Greater  Than2'
     *  RelationalOperator: '<S2081>/Greater  Than4'
     *  RelationalOperator: '<S2081>/Relational Operator1'
     *  Sum: '<S2076>/Sum1'
     *  Switch: '<S2089>/Switch2'
     */
    if (((rtb_RelationalOperator1_cd && ((VeESSR_t_STMTmr_DS >
            KeESSR_t_HoldStartStateTime) || ((VeESSR_t_STMTmr_DS >
             KeESSR_t_HoldStartStateTimeMin) && (rtb_Vector_cq <
             KeESSR_M_StrtEngTqExitDelta)))) && (VeESSR_b_SpdChk_StrtEngPFS)) &&
        (rtb_LogicalOperator3_n || (VeESSR_b_ETRQStrtEngPFS)))
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngRun;
    }
    else
    {
        if (rtb_GreaterThan1_fm)
        {
            /* Switch: '<S2076>/Switch' incorporates:
             *  Switch: '<S2089>/Switch2'
             */
            if (rtb_Logical5_je)
            {
                /* Switch: '<S2089>/Switch1' incorporates:
                 *  Constant: '<S2079>/Constant'
                 *  DataStoreWrite: '<S2076>/Dsw_STMTrigger'
                 *  Switch: '<S2089>/Switch2'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_StopReq;
            }
            else
            {
                /* Switch: '<S2089>/Switch1' incorporates:
                 *  Constant: '<S2078>/Constant'
                 *  DataStoreWrite: '<S2076>/Dsw_STMTrigger'
                 *  Switch: '<S2089>/Switch2'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;
            }

            /* End of Switch: '<S2076>/Switch' */
        }
    }

    /* End of Switch: '<S2089>/Switch1' */

    /* Abs: '<S2084>/Abs' incorporates:
     *  Constant: '<S2086>/Calib'
     *  Constant: '<S2098>/Calib'
     *  Product: '<S2084>/Multiplication'
     */
    rtb_Abs_do = fabsf(KeESSR_dscl_RampUpRate * HeESSR_t_MedTEB_dT);

    /* Outputs for Atomic SubSystem: '<S2084>/Limiter1' */
    /* Switch: '<S2137>/Switch1' incorporates:
     *  Constant: '<S2076>/Constant Value8'
     *  DataStoreRead: '<S2076>/Dsr_SpdCtlGainMod1'
     *  RelationalOperator: '<S2137>/Relational Operator'
     *  Sum: '<S2084>/Sum'
     */
    if (rtb_Abs_do < (1.0F - VeESSR_scl_SpdCtlGainMod_DS))
    {
        /* MinMax: '<S2152>/MinMax1' */
        rtb_MinMax1_h = rtb_Abs_do;
    }
    else
    {
        /* MinMax: '<S2152>/MinMax1' */
        rtb_MinMax1_h = 1.0F - VeESSR_scl_SpdCtlGainMod_DS;
    }

    /* End of Switch: '<S2137>/Switch1' */

    /* Switch: '<S2137>/Switch' incorporates:
     *  Gain: '<S2084>/Gain'
     *  RelationalOperator: '<S2137>/Relational Operator1'
     */
    if (rtb_MinMax1_h <= (-rtb_Abs_do))
    {
        rtb_MinMax1_h = -rtb_Abs_do;
    }

    /* End of Switch: '<S2137>/Switch' */
    /* End of Outputs for SubSystem: '<S2084>/Limiter1' */

    /* Sum: '<S2084>/Sum1' incorporates:
     *  DataStoreRead: '<S2076>/Dsr_SpdCtlGainMod1'
     */
    rtb_Summation_e1 = rtb_MinMax1_h + VeESSR_scl_SpdCtlGainMod_DS;

    /* Outputs for Atomic SubSystem: '<S2084>/Limiter2' */
    /* Switch: '<S2138>/Switch1' incorporates:
     *  Constant: '<S2076>/Constant Value7'
     *  RelationalOperator: '<S2138>/Relational Operator'
     */
    if (2.0F < rtb_Summation_e1)
    {
        /* MinMax: '<S2152>/MinMax1' */
        rtb_MinMax1_h = 2.0F;
    }
    else
    {
        /* MinMax: '<S2152>/MinMax1' */
        rtb_MinMax1_h = rtb_Summation_e1;
    }

    /* End of Switch: '<S2138>/Switch1' */

    /* Switch: '<S2138>/Switch' incorporates:
     *  Constant: '<S2076>/Constant Value4'
     *  DataStoreWrite: '<S2076>/Dsw_SpdCtlGainMod1'
     *  RelationalOperator: '<S2138>/Relational Operator1'
     */
    if (rtb_MinMax1_h > 0.0F)
    {
        VeESSR_scl_SpdCtlGainMod_DS = rtb_MinMax1_h;
    }
    else
    {
        VeESSR_scl_SpdCtlGainMod_DS = 0.0F;
    }

    /* End of Switch: '<S2138>/Switch' */
    /* End of Outputs for SubSystem: '<S2084>/Limiter2' */

    /* Logic: '<S2081>/Logical Operator3' incorporates:
     *  Logic: '<S2081>/Logical Operator1'
     *  Logic: '<S2081>/Logical14'
     *  Logic: '<S2081>/Logical15'
     */
    rtb_LogicalOperator3_n = (((!VeESSR_b_SpdChk_StrtEngPFS) ||
        (!rtb_LogicalOperator4_b)) && rtb_GreaterThan1_fm);

    /* Logic: '<S2081>/Logical Operator4' */
    rtb_LogicalOperator4_b = (rtb_Logical5_gk && rtb_GreaterThan1_fm);

    /* Logic: '<S2081>/Logical Operator5' incorporates:
     *  Logic: '<S2081>/Logical12'
     */
    rtb_Logical5_je = (rtb_GreaterThan1_fm && (!VeESSR_b_ETRQStrtEngPFS));

    /* Logic: '<S2081>/Logical5' */
    rtb_Logical5_gk = ((rtb_LogicalOperator3_n || rtb_LogicalOperator4_b) ||
                       rtb_Logical5_je);

    /* If: '<S2076>/If' incorporates:
     *  DataStoreRead: '<S2076>/Data Store Read2'
     *  Logic: '<S2076>/Logical4'
     *  Logic: '<S2076>/Logical7'
     */
    if ((!VeESSR_b_AStrtReattmptAllowed_DS) && rtb_Logical5_gk)
    {
        /* Outputs for IfAction SubSystem: '<S2076>/If_StartEng_P1C64' incorporates:
         *  ActionPort: '<S2091>/Action Port'
         */
        /* DataStoreWrite: '<S2076>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_StartEng_P1C64((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S2076>/If_StartEng_P1C64' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2076>/If_StartEng_NoFault' incorporates:
         *  ActionPort: '<S2090>/Action Port'
         */
        /* DataStoreWrite: '<S2076>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_KeyCrank_NoFault((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S2076>/If_StartEng_NoFault' */
    }

    /* End of If: '<S2076>/If' */

    /* SignalConversion generated from: '<S2102>/Variant Source' incorporates:
     *  MinMax: '<S2188>/MinMax1'
     *  Product: '<S2188>/Multiplication'
     *  Sum: '<S2188>/Summation5'
     *  Switch: '<S2102>/Switch9'
     */
#if !Rte_SysCon_Variant_ESSR_12vBSG

    /* Switch: '<S2160>/Switch1' incorporates:
     *  Constant: '<S2102>/Constant Value'
     */
    rtb_Switch1_nzn = 0.0F;

#else

    /* Outputs for Atomic SubSystem: '<S2188>/Limiter' */
    /* Outputs for Atomic SubSystem: '<S2188>/DeadBand' */
    /* Outputs for Atomic SubSystem: '<S2102>/Digital Lowpass Reset Enabled1' */
    /* Switch: '<S2187>/Switch1' incorporates:
     *  Constant: '<S2189>/Calib'
     *  Switch: '<S2187>/Switch2'
     */
    if (rtb_Equal2_k)
    {
        /* Switch: '<S2187>/Switch1' incorporates:
         *  DataStoreRead: '<S2102>/Data Store Read8'
         */
        rtb_Dsr_STMTmr_nr = VeESSR_n_InputSpeedProfile_DS;
    }
    else if (HeESSR_b_EnblLQRConfig)
    {
        /* Switch: '<S2187>/Switch2' incorporates:
         *  Constant: '<S2102>/Constant'
         *  Product: '<S2187>/Multiplication'
         *  Sum: '<S2187>/Subtraction'
         *  Sum: '<S2187>/Summation'
         *  Switch: '<S2187>/Switch1'
         *  UnitDelay: '<S2187>/Unit Delay'
         */
        rtb_Dsr_STMTmr_nr = ((rtb_Dsr_STMTmr_nr - localDW->UnitDelay_DSTATE_n) *
                             0.2F) + localDW->UnitDelay_DSTATE_n;
    }
    else
    {
        /* Switch: '<S2187>/Switch1' incorporates:
         *  Switch: '<S2187>/Switch2'
         *  UnitDelay: '<S2187>/Unit Delay'
         */
        rtb_Dsr_STMTmr_nr = localDW->UnitDelay_DSTATE_n;
    }

    /* End of Switch: '<S2187>/Switch1' */

    /* Update for UnitDelay: '<S2187>/Unit Delay' */
    localDW->UnitDelay_DSTATE_n = rtb_Dsr_STMTmr_nr;

    /* Switch: '<S2102>/Switch9' incorporates:
     *  Constant: '<S2189>/Calib'
     *  DataStoreRead: '<S2102>/Data Store Read8'
     */
    if (!HeESSR_b_EnblLQRConfig)
    {
        rtb_Dsr_STMTmr_nr = VeESSR_n_InputSpeedProfile_DS;
    }

    /* Sum: '<S2188>/Summation5' incorporates:
     *  MinMax: '<S2188>/MinMax1'
     */
    VeESSR_n_EngStrtPFSSpdError = fmaxf(rtb_Dsr_STMTmr_nr,
        rtu_VeESSR_n_TransInSpdFlt) - rtu_VeESSR_n_TransInSpdFlt;

    /* Switch: '<S2191>/Switch1' incorporates:
     *  Constant: '<S2188>/Constant Value'
     *  Constant: '<S2191>/Constant Value'
     *  Constant: '<S2194>/Calib'
     *  RelationalOperator: '<S2191>/Greater  Than'
     *  RelationalOperator: '<S2191>/Greater  Than1'
     *  Sum: '<S2191>/Subtraction'
     *  Switch: '<S2191>/Switch2'
     */
    if (VeESSR_n_EngStrtPFSSpdError >= KeESSR_n_EngStrtPFSSpdCtlPosDdBnd)
    {
        rtb_Abs_do = VeESSR_n_EngStrtPFSSpdError -
            KeESSR_n_EngStrtPFSSpdCtlPosDdBnd;
    }
    else if (VeESSR_n_EngStrtPFSSpdError <= 0.0F)
    {
        /* Switch: '<S2191>/Switch2' incorporates:
         *  Sum: '<S2191>/Subtraction1'
         */
        rtb_Abs_do = VeESSR_n_EngStrtPFSSpdError;
    }
    else
    {
        rtb_Abs_do = 0.0F;
    }

    /* End of Switch: '<S2191>/Switch1' */

    /* Product: '<S2188>/Multiplication' incorporates:
     *  Constant: '<S2192>/Calib'
     */
    rtb_Dsr_STMTmr_nr = rtb_Abs_do * KeESSR_K_EngStrtPFSSpdCtlPgain;

    /* Switch: '<S2195>/Switch1' incorporates:
     *  Constant: '<S2188>/Constant Value1'
     *  RelationalOperator: '<S2195>/Relational Operator'
     */
    if (0.0F < rtb_Dsr_STMTmr_nr)
    {
        /* MinMax: '<S2152>/MinMax1' */
        rtb_MinMax1_h = 0.0F;
    }
    else
    {
        /* MinMax: '<S2152>/MinMax1' */
        rtb_MinMax1_h = rtb_Dsr_STMTmr_nr;
    }

    /* End of Switch: '<S2195>/Switch1' */

    /* Switch: '<S2195>/Switch' incorporates:
     *  Constant: '<S2193>/Calib'
     *  RelationalOperator: '<S2195>/Relational Operator1'
     */
    if (rtb_MinMax1_h > KeESSR_M_EngStrtPFSSpdCtlMinTi)
    {
        /* Switch: '<S2195>/Switch' */
        VeESSR_M_StrtEngPFSPSpdCtl = rtb_MinMax1_h;
    }
    else
    {
        /* Switch: '<S2195>/Switch' */
        VeESSR_M_StrtEngPFSPSpdCtl = KeESSR_M_EngStrtPFSSpdCtlMinTi;
    }

    /* End of Switch: '<S2195>/Switch' */

    /* Switch: '<S2160>/Switch1' */
    rtb_Switch1_nzn = VeESSR_M_StrtEngPFSPSpdCtl;

    /* End of Outputs for SubSystem: '<S2102>/Digital Lowpass Reset Enabled1' */
    /* End of Outputs for SubSystem: '<S2188>/DeadBand' */
    /* End of Outputs for SubSystem: '<S2188>/Limiter' */
#endif

    /* Sum: '<S2186>/Subtraction1' incorporates:
     *  Constant: '<S2190>/Calib'
     *  DataStoreRead: '<S2102>/Dsr_InputTorqEst1'
     *  Product: '<S2186>/Multiplication'
     *  Sum: '<S2186>/Subtraction'
     */
    VeESSR_M_StrtEngPFSISpdCtl = ((rtu_VeESSR_M_EngTrqAct_Lmtd -
        VeESSR_M_EngTorqEst_DS) * KeESSR_K_TiEstBlndStrtEngPFS) +
        VeESSR_M_EngTorqEst_DS;

    /* Switch: '<S2160>/Switch1' incorporates:
     *  Sum: '<S2102>/Sum'
     */
    rtb_Switch1_nzn += VeESSR_M_StrtEngPFSISpdCtl;

    /* MinMax: '<S2102>/MinMax' incorporates:
     *  DataStoreWrite: '<S2102>/Dsw_InputTorqEst'
     */
    VeESSR_M_EngTorqEst_DS = fmaxf(rtu_HTDR_TiMin, rtb_Switch1_nzn);

    /* Switch: '<S2103>/Switch3' incorporates:
     *  Constant: '<S2197>/Calib'
     */
    if (HeESSR_b_RampMinStartTorq)
    {
        /* Switch: '<S2103>/Switch3' incorporates:
         *  DataStoreRead: '<S2103>/Dsr_STMTmr2'
         *  Lookup_n-D: '<S2199>/Vector'
         */
        VeESSR_M_MinStartDetectTorqPFS = look1_iflf_binlcapw(VeESSR_t_STMTmr_DS,
            ((const float32 *)&(KxESSR_M_MinStartDetectTorq[0])), ((const
            float32 *)&(KtESSR_M_MinStartDetectTorq[0])), 6U);
    }
    else
    {
        /* Switch: '<S2103>/Switch3' incorporates:
         *  Constant: '<S2198>/Calib'
         */
        VeESSR_M_MinStartDetectTorqPFS = KeESSR_M_MinStartDetectTorq;
    }

    /* End of Switch: '<S2103>/Switch3' */

    /* MinMax: '<S2103>/Maximum1' */
    rtb_Dsr_STMTmr_nr = fmaxf(rtu_VeESSR_M_OptEngTrqReq,
        VeESSR_M_MinStartDetectTorqPFS);

    /* If: '<S2082>/If1' */
    if (rtu_VeENGR_b_EngCombustionCmnd)
    {
        /* Outputs for IfAction SubSystem: '<S2082>/ESSC_CombstDelay' incorporates:
         *  ActionPort: '<S2126>/Action Port'
         */
        /* RelationalOperator: '<S2165>/Relational Operator1' incorporates:
         *  Constant: '<S2126>/TRUE Constant'
         *  SignalConversion generated from: '<S2126>/OutputParameter'
         */
        rtb_RelationalOperator1_cd = true;

        /* End of Outputs for SubSystem: '<S2082>/ESSC_CombstDelay' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2082>/ESSC_CombstNoDelay' incorporates:
         *  ActionPort: '<S2127>/Action Port'
         */
        ESSR_ac_ESSC_CmbstnNoDelay(&rtb_RelationalOperator1_cd);

        /* End of Outputs for SubSystem: '<S2082>/ESSC_CombstNoDelay' */
    }

    /* End of If: '<S2082>/If1' */

    /* Outputs for Atomic SubSystem: '<S2082>/Signal Latch On With Reset' */
    /* Logic: '<S2130>/OR1' incorporates:
     *  Constant: '<S2128>/Calib'
     *  DataStoreRead: '<S2082>/Dsr_STMTmr'
     *  Logic: '<S2082>/Logical3'
     *  Logic: '<S2130>/OR'
     *  RelationalOperator: '<S2082>/Equal1'
     *  UnitDelay: '<S2130>/Unit Delay'
     */
    rtb_GreaterThan1_fm = ((rtb_RelationalOperator1_cd || (VeESSR_t_STMTmr_DS >
        KeESSR_t_FuelTmDelayHold)) || (rtb_Logical4_c3 &&
                            (localDW->UnitDelay_DSTATE_e)));

    /* Update for UnitDelay: '<S2130>/Unit Delay' */
    localDW->UnitDelay_DSTATE_e = rtb_GreaterThan1_fm;

    /* End of Outputs for SubSystem: '<S2082>/Signal Latch On With Reset' */

    /* Logic: '<S2082>/Logical4' */
    rtb_Logical4_c3 = !rtb_GreaterThan1_fm;

    /* Outputs for Atomic SubSystem: '<S2103>/EngineTorqueCommands_PFS' */
    /* Outputs for Atomic SubSystem: '<S2196>/BlueNexus' */
    /* MinMax: '<S2200>/MinMax4' incorporates:
     *  MinMax: '<S2201>/Maximum4'
     *  Switch: '<S2201>/Switch1'
     */
    rtb_Abs_do = fmaxf(rtu_PNLimTrq, rtu_TactTiMin);

    /* End of Outputs for SubSystem: '<S2196>/BlueNexus' */
    /* End of Outputs for SubSystem: '<S2103>/EngineTorqueCommands_PFS' */

    /* RelationalOperator: '<S2165>/Relational Operator1' incorporates:
     *  MinMax: '<S2200>/MinMax4'
     *  RelationalOperator: '<S2200>/Relational Operator1'
     */
    rtb_RelationalOperator1_cd = (rtb_Dsr_STMTmr_nr >= rtb_Abs_do);

    /* Outputs for Atomic SubSystem: '<S2200>/Signal Latch On With Reset' */
    /* Logic: '<S2214>/OR1' incorporates:
     *  DataStoreRead: '<S2103>/Data Store Read6'
     *  Logic: '<S2200>/Logical Operator'
     *  Logic: '<S2200>/Logical Operator1'
     *  Logic: '<S2214>/OR'
     *  MinMax: '<S2200>/MinMax4'
     *  RelationalOperator: '<S2200>/Relational Operator'
     *  UnitDelay: '<S2214>/Unit Delay'
     */
    rtb_RelationalOperator1_cd = (((rtb_Abs_do == VeESSR_M_EngTrqReqPrdtd_DS) &&
        rtb_RelationalOperator1_cd) || (rtb_RelationalOperator1_cd &&
        (localDW->UnitDelay_DSTATE_fz)));

    /* Update for UnitDelay: '<S2214>/Unit Delay' */
    localDW->UnitDelay_DSTATE_fz = rtb_RelationalOperator1_cd;

    /* End of Outputs for SubSystem: '<S2200>/Signal Latch On With Reset' */

    /* Switch: '<S2200>/Switch2' incorporates:
     *  Logic: '<S2200>/Logical Operator2'
     */
    if (rtb_RelationalOperator1_cd && rtu_PNLimActv)
    {
        /* Switch: '<S2200>/Switch2' incorporates:
         *  MinMax: '<S2200>/MinMax4'
         */
        VeESSR_M_EngTrqReqPrdtdMinPFS = rtb_Abs_do;
    }
    else
    {
        /* Switch: '<S2200>/Switch2' incorporates:
         *  Constant: '<S2200>/Constant Value1'
         */
        VeESSR_M_EngTrqReqPrdtdMinPFS = -999.0F;
    }

    /* End of Switch: '<S2200>/Switch2' */

    /* Switch: '<S2200>/Switch' */
    if (rtu_PNLimActv)
    {
        /* Switch: '<S2200>/Switch' incorporates:
         *  MinMax: '<S2200>/MinMax4'
         */
        VeESSR_M_EngTrqReqPrdtdMaxPFS = rtb_Abs_do;
    }
    else
    {
        /* Switch: '<S2200>/Switch' incorporates:
         *  Constant: '<S2200>/Constant Value'
         */
        VeESSR_M_EngTrqReqPrdtdMaxPFS = 999.0F;
    }

    /* End of Switch: '<S2200>/Switch' */

    /* Outputs for Atomic SubSystem: '<S2103>/EngineTorqueCommands_PFS' */
#if Rte_SysCon_Variant_ESSR_BlueNexus

    /* Outputs for Atomic SubSystem: '<S2196>/BlueNexus' */
    /* Outputs for Atomic SubSystem: '<S2201>/Lowpass Second Order Enabled' */
    /* Switch: '<S2204>/Switch3' incorporates:
     *  Logic: '<S2201>/Logical Operator1'
     *  Logic: '<S2201>/Logical Operator2'
     *  RelationalOperator: '<S2201>/Relational Operator2'
     *  Switch: '<S2204>/Switch1'
     *  UnitDelay: '<S2201>/Unit Delay'
     */
    if (rtb_Logical4_c3 || (rtu_PNLimActv != localDW->UnitDelay_DSTATE_h))
    {
        /* Switch: '<S2204>/Switch3' */
        rtb_Switch3_fu = rtb_Vector_cq;

        /* Switch: '<S2204>/Switch1' */
        VeESSR_M_EngTrqReqImmedFltrPFS = rtb_Vector_cq;
    }
    else
    {
        /* Switch: '<S2204>/Switch3' incorporates:
         *  UnitDelay: '<S2204>/x2'
         */
        rtb_Switch3_fu = VeESSR_M_EngTrqReqImmedFltrPFS;

        /* Product: '<S2204>/Multiplication1' incorporates:
         *  Constant: '<S2086>/Calib'
         *  DataStoreRead: '<S2201>/Dsr_StrtTypInitImmedTorq2'
         *  MinMax: '<S2204>/Maximum'
         */
        rtb_Sum_ix = (1.0F / fmaxf(VeESSR_k_StrtTypEngTorqReqFltT_DS,
                       HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT;

        /* Switch: '<S2204>/Switch1' incorporates:
         *  Constant: '<S2201>/Constant Value'
         *  DataStoreRead: '<S2201>/Dsr_StrtTypInitImmedTorq3'
         *  Gain: '<S2204>/Gain'
         *  Gain: '<S2204>/Gain1'
         *  Math: '<S2204>/Square'
         *  Product: '<S2204>/Multiplication2'
         *  Product: '<S2204>/Multiplication3'
         *  Sum: '<S2204>/Subtraction'
         *  Sum: '<S2204>/Subtraction1'
         *  Sum: '<S2204>/Summation'
         *  UnitDelay: '<S2204>/temp'
         *  UnitDelay: '<S2204>/x2'
         */
        VeESSR_M_EngTrqReqImmedFltrPFS = (((((localDW->temp_DSTATE_fy -
            VeESSR_M_EngTrqReqImmedFltrPFS) * (2.0F *
            VeESSR_k_StrtTypEngTorqReqImmedFltD_DS)) * rtb_Sum_ix) +
            ((rtb_Sum_ix * rtb_Sum_ix) * (0.0F - localDW->temp_DSTATE_fy))) -
            localDW->temp_DSTATE_fy) + (2.0F * VeESSR_M_EngTrqReqImmedFltrPFS);
    }

    /* End of Switch: '<S2204>/Switch3' */

    /* Update for UnitDelay: '<S2204>/temp' */
    localDW->temp_DSTATE_fy = rtb_Switch3_fu;

    /* End of Outputs for SubSystem: '<S2201>/Lowpass Second Order Enabled' */

    /* Outputs for Atomic SubSystem: '<S2201>/Lowpass Second Order Enabled3' */
    /* Switch: '<S2205>/Switch3' incorporates:
     *  Switch: '<S2205>/Switch1'
     */
    if (rtb_Logical4_c3)
    {
        /* Switch: '<S2205>/Switch3' incorporates:
         *  DataStoreRead: '<S2103>/Dsr_EngTrqReqPrdtd3'
         */
        rtb_Switch3_fu = VeESSR_M_EngTrqReqPrdtd_DS;

        /* Switch: '<S2205>/Switch1' incorporates:
         *  DataStoreRead: '<S2103>/Dsr_EngTrqReqPrdtd3'
         */
        rtb_Switch4_pe = VeESSR_M_EngTrqReqPrdtd_DS;
    }
    else
    {
        /* Switch: '<S2205>/Switch3' incorporates:
         *  UnitDelay: '<S2205>/x2'
         */
        rtb_Switch3_fu = localDW->x2_DSTATE_l;

        /* Product: '<S2205>/Multiplication1' incorporates:
         *  Constant: '<S2086>/Calib'
         *  DataStoreRead: '<S2201>/Dsr_StrtTypInitImmedTorq4'
         *  Gain: '<S2201>/Gain'
         *  MinMax: '<S2205>/Maximum'
         */
        rtb_Switch4_pe = (1.0F / fmaxf(1.2F * VeESSR_k_StrtTypEngTorqReqFltT_DS,
                           HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT;

        /* Switch: '<S2205>/Switch1' incorporates:
         *  DataStoreRead: '<S2201>/Dsr_StrtTypInitImmedTorq7'
         *  Gain: '<S2205>/Gain'
         *  Gain: '<S2205>/Gain1'
         *  Math: '<S2205>/Square'
         *  Product: '<S2205>/Multiplication2'
         *  Product: '<S2205>/Multiplication3'
         *  Sum: '<S2205>/Subtraction'
         *  Sum: '<S2205>/Subtraction1'
         *  Sum: '<S2205>/Summation'
         *  UnitDelay: '<S2205>/temp'
         *  UnitDelay: '<S2205>/x2'
         */
        rtb_Switch4_pe = (((((localDW->temp_DSTATE_f - localDW->x2_DSTATE_l) *
                             (2.0F * VeESSR_k_StrtTypEngTorqReqImmedFltD_DS)) *
                            rtb_Switch4_pe) + ((rtb_Switch4_pe * rtb_Switch4_pe)
                            * (rtb_Dsr_STMTmr_nr - localDW->temp_DSTATE_f))) -
                          localDW->temp_DSTATE_f) + (2.0F * localDW->x2_DSTATE_l);
    }

    /* End of Switch: '<S2205>/Switch3' */

    /* Outputs for Atomic SubSystem: '<S2205>/Limiter3' */
    /* Switch: '<S2206>/Switch1' incorporates:
     *  RelationalOperator: '<S2206>/Relational Operator'
     */
    if (VeESSR_M_EngTrqReqPrdtdMaxPFS < rtb_Switch4_pe)
    {
        /* Switch: '<S2206>/Switch1' */
        rtb_Switch4_pe = VeESSR_M_EngTrqReqPrdtdMaxPFS;
    }

    /* End of Switch: '<S2206>/Switch1' */

    /* Switch: '<S2206>/Switch' incorporates:
     *  RelationalOperator: '<S2206>/Relational Operator1'
     */
    if (rtb_Switch4_pe <= VeESSR_M_EngTrqReqPrdtdMinPFS)
    {
        /* VariantMerge generated from: '<S2196>/EngTrqReqPred' */
        rtb_Switch4_pe = VeESSR_M_EngTrqReqPrdtdMinPFS;
    }

    /* End of Switch: '<S2206>/Switch' */
    /* End of Outputs for SubSystem: '<S2205>/Limiter3' */

    /* Update for UnitDelay: '<S2205>/x2' */
    localDW->x2_DSTATE_l = rtb_Switch4_pe;

    /* Update for UnitDelay: '<S2205>/temp' */
    localDW->temp_DSTATE_f = rtb_Switch3_fu;

    /* End of Outputs for SubSystem: '<S2201>/Lowpass Second Order Enabled3' */

    /* Switch: '<S2201>/Switch1' */
    if (rtu_PNLimActv)
    {
        /* VariantMerge generated from: '<S2196>/EngTrqReqImmed' incorporates:
         *  MinMax: '<S2201>/Maximum5'
         *  Sum: '<S2201>/Sum1'
         */
        rtb_Switch3_fu = fminf(rtb_Abs_do, rtb_Switch4_pe -
                               VeESSR_M_EngTrqReqImmedFltrPFS);
    }
    else
    {
        /* VariantMerge generated from: '<S2196>/EngTrqReqImmed' incorporates:
         *  Sum: '<S2201>/Sum1'
         */
        rtb_Switch3_fu = rtb_Switch4_pe - VeESSR_M_EngTrqReqImmedFltrPFS;
    }

    /* Update for UnitDelay: '<S2201>/Unit Delay' */
    localDW->UnitDelay_DSTATE_h = rtu_PNLimActv;

    /* End of Outputs for SubSystem: '<S2196>/BlueNexus' */
#elif Rte_SysCon_Variant_ESSR_LQIR

    /* Outputs for Atomic SubSystem: '<S2196>/LQIR' */
    /* VariantMerge generated from: '<S2196>/EngTrqReqImmed' incorporates:
     *  Inport: '<S2203>/PredTarget'
     */
    rtb_Switch3_fu = rtb_Dsr_STMTmr_nr;

    /* Outputs for Atomic SubSystem: '<S2203>/Lowpass Second Order Enabled3' */
    /* Switch: '<S2212>/Switch3' incorporates:
     *  Switch: '<S2212>/Switch1'
     */
    if (rtb_Logical4_c3)
    {
        /* Switch: '<S2212>/Switch3' incorporates:
         *  DataStoreRead: '<S2103>/Dsr_EngTrqReqPrdtd3'
         */
        rtb_Abs_do = VeESSR_M_EngTrqReqPrdtd_DS;

        /* Switch: '<S2212>/Switch1' incorporates:
         *  DataStoreRead: '<S2103>/Dsr_EngTrqReqPrdtd3'
         */
        rtb_Switch4_pe = VeESSR_M_EngTrqReqPrdtd_DS;
    }
    else
    {
        /* Switch: '<S2212>/Switch3' incorporates:
         *  UnitDelay: '<S2212>/x2'
         */
        rtb_Abs_do = localDW->x2_DSTATE;

        /* Product: '<S2212>/Multiplication1' incorporates:
         *  Constant: '<S2086>/Calib'
         *  Constant: '<S2211>/Calib'
         *  MinMax: '<S2212>/Maximum'
         */
        rtb_Switch4_pe = (1.0F / fmaxf(KeESSR_k_LQRStartEngTiFltT,
                           HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT;

        /* Switch: '<S2212>/Switch1' incorporates:
         *  Constant: '<S2210>/Calib'
         *  Gain: '<S2212>/Gain'
         *  Gain: '<S2212>/Gain1'
         *  Inport: '<S2203>/PredTarget'
         *  Math: '<S2212>/Square'
         *  Product: '<S2212>/Multiplication2'
         *  Product: '<S2212>/Multiplication3'
         *  Sum: '<S2212>/Subtraction'
         *  Sum: '<S2212>/Subtraction1'
         *  Sum: '<S2212>/Summation'
         *  UnitDelay: '<S2212>/temp'
         *  UnitDelay: '<S2212>/x2'
         */
        rtb_Switch4_pe = (((((localDW->temp_DSTATE - localDW->x2_DSTATE) * (2.0F
                              * KeESSR_k_LQRStartEngTiFltD)) * rtb_Switch4_pe) +
                           ((rtb_Switch4_pe * rtb_Switch4_pe) *
                            (rtb_Dsr_STMTmr_nr - localDW->temp_DSTATE))) -
                          localDW->temp_DSTATE) + (2.0F * localDW->x2_DSTATE);
    }

    /* End of Switch: '<S2212>/Switch3' */

    /* Outputs for Atomic SubSystem: '<S2212>/Limiter3' */
    /* Switch: '<S2213>/Switch1' incorporates:
     *  RelationalOperator: '<S2213>/Relational Operator'
     */
    if (VeESSR_M_EngTrqReqPrdtdMaxPFS < rtb_Switch4_pe)
    {
        /* Switch: '<S2213>/Switch1' */
        rtb_Switch4_pe = VeESSR_M_EngTrqReqPrdtdMaxPFS;
    }

    /* End of Switch: '<S2213>/Switch1' */

    /* Switch: '<S2213>/Switch' incorporates:
     *  RelationalOperator: '<S2213>/Relational Operator1'
     */
    if (rtb_Switch4_pe <= VeESSR_M_EngTrqReqPrdtdMinPFS)
    {
        /* VariantMerge generated from: '<S2196>/EngTrqReqPred' */
        rtb_Switch4_pe = VeESSR_M_EngTrqReqPrdtdMinPFS;
    }

    /* End of Switch: '<S2213>/Switch' */
    /* End of Outputs for SubSystem: '<S2212>/Limiter3' */

    /* Update for UnitDelay: '<S2212>/x2' */
    localDW->x2_DSTATE = rtb_Switch4_pe;

    /* Update for UnitDelay: '<S2212>/temp' */
    localDW->temp_DSTATE = rtb_Abs_do;

    /* End of Outputs for SubSystem: '<S2203>/Lowpass Second Order Enabled3' */
    /* End of Outputs for SubSystem: '<S2196>/LQIR' */
#else

    /* Outputs for Atomic SubSystem: '<S2196>/Default' */
    /* Outputs for Atomic SubSystem: '<S2202>/Lowpass Second Order Enabled' */
    /* Switch: '<S2207>/Switch3' incorporates:
     *  Switch: '<S2207>/Switch1'
     */
    if (rtb_Logical4_c3)
    {
        /* Switch: '<S2207>/Switch3' */
        rtb_Switch3_fu = rtb_Vector_cq;

        /* Switch: '<S2207>/Switch1' */
        VeESSR_M_EngTrqReqImmedFltrPFS = rtb_Vector_cq;
    }
    else
    {
        /* Switch: '<S2207>/Switch3' incorporates:
         *  UnitDelay: '<S2207>/x2'
         */
        rtb_Switch3_fu = VeESSR_M_EngTrqReqImmedFltrPFS;

        /* Product: '<S2207>/Multiplication1' incorporates:
         *  Constant: '<S2086>/Calib'
         *  DataStoreRead: '<S2202>/Dsr_StrtTypInitImmedTorq2'
         *  MinMax: '<S2207>/Maximum'
         */
        rtb_Summation_e1 = (1.0F / fmaxf(VeESSR_k_StrtTypEngTorqReqFltT_DS,
                             HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT;

        /* Switch: '<S2207>/Switch1' incorporates:
         *  Constant: '<S2202>/Constant Value'
         *  DataStoreRead: '<S2202>/Dsr_StrtTypInitImmedTorq3'
         *  Gain: '<S2207>/Gain'
         *  Gain: '<S2207>/Gain1'
         *  Math: '<S2207>/Square'
         *  Product: '<S2207>/Multiplication2'
         *  Product: '<S2207>/Multiplication3'
         *  Sum: '<S2207>/Subtraction'
         *  Sum: '<S2207>/Subtraction1'
         *  Sum: '<S2207>/Summation'
         *  UnitDelay: '<S2207>/temp'
         *  UnitDelay: '<S2207>/x2'
         */
        VeESSR_M_EngTrqReqImmedFltrPFS = (((((localDW->temp_DSTATE_m -
            VeESSR_M_EngTrqReqImmedFltrPFS) * (2.0F *
            VeESSR_k_StrtTypEngTorqReqImmedFltD_DS)) * rtb_Summation_e1) +
            ((rtb_Summation_e1 * rtb_Summation_e1) * (0.0F -
            localDW->temp_DSTATE_m))) - localDW->temp_DSTATE_m) + (2.0F *
            VeESSR_M_EngTrqReqImmedFltrPFS);
    }

    /* End of Switch: '<S2207>/Switch3' */

    /* Update for UnitDelay: '<S2207>/temp' */
    localDW->temp_DSTATE_m = rtb_Switch3_fu;

    /* End of Outputs for SubSystem: '<S2202>/Lowpass Second Order Enabled' */

    /* Outputs for Atomic SubSystem: '<S2202>/Lowpass Second Order Enabled3' */
    /* Switch: '<S2208>/Switch3' incorporates:
     *  Switch: '<S2208>/Switch1'
     */
    if (rtb_Logical4_c3)
    {
        /* Switch: '<S2208>/Switch3' incorporates:
         *  DataStoreRead: '<S2103>/Dsr_EngTrqReqPrdtd3'
         */
        rtb_Switch3_fu = VeESSR_M_EngTrqReqPrdtd_DS;

        /* Switch: '<S2208>/Switch1' incorporates:
         *  DataStoreRead: '<S2103>/Dsr_EngTrqReqPrdtd3'
         */
        rtb_Switch4_pe = VeESSR_M_EngTrqReqPrdtd_DS;
    }
    else
    {
        /* Switch: '<S2208>/Switch3' incorporates:
         *  UnitDelay: '<S2208>/x2'
         */
        rtb_Switch3_fu = localDW->x2_DSTATE_a;

        /* Product: '<S2208>/Multiplication1' incorporates:
         *  Constant: '<S2086>/Calib'
         *  DataStoreRead: '<S2202>/Dsr_StrtTypInitImmedTorq4'
         *  Gain: '<S2202>/Gain'
         *  MinMax: '<S2208>/Maximum'
         */
        rtb_Switch4_pe = (1.0F / fmaxf(1.2F * VeESSR_k_StrtTypEngTorqReqFltT_DS,
                           HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT;

        /* Switch: '<S2208>/Switch1' incorporates:
         *  DataStoreRead: '<S2202>/Dsr_StrtTypInitImmedTorq7'
         *  Gain: '<S2208>/Gain'
         *  Gain: '<S2208>/Gain1'
         *  Math: '<S2208>/Square'
         *  Product: '<S2208>/Multiplication2'
         *  Product: '<S2208>/Multiplication3'
         *  Sum: '<S2208>/Subtraction'
         *  Sum: '<S2208>/Subtraction1'
         *  Sum: '<S2208>/Summation'
         *  UnitDelay: '<S2208>/temp'
         *  UnitDelay: '<S2208>/x2'
         */
        rtb_Switch4_pe = (((((localDW->temp_DSTATE_j - localDW->x2_DSTATE_a) *
                             (2.0F * VeESSR_k_StrtTypEngTorqReqImmedFltD_DS)) *
                            rtb_Switch4_pe) + ((rtb_Switch4_pe * rtb_Switch4_pe)
                            * (rtb_Dsr_STMTmr_nr - localDW->temp_DSTATE_j))) -
                          localDW->temp_DSTATE_j) + (2.0F * localDW->x2_DSTATE_a);
    }

    /* End of Switch: '<S2208>/Switch3' */

    /* Outputs for Atomic SubSystem: '<S2208>/Limiter3' */
    /* Switch: '<S2209>/Switch1' incorporates:
     *  RelationalOperator: '<S2209>/Relational Operator'
     */
    if (VeESSR_M_EngTrqReqPrdtdMinPFS < rtb_Switch4_pe)
    {
        /* Switch: '<S2209>/Switch1' */
        rtb_Switch4_pe = VeESSR_M_EngTrqReqPrdtdMinPFS;
    }

    /* End of Switch: '<S2209>/Switch1' */

    /* Switch: '<S2209>/Switch' incorporates:
     *  RelationalOperator: '<S2209>/Relational Operator1'
     */
    if (rtb_Switch4_pe <= VeESSR_M_EngTrqReqPrdtdMaxPFS)
    {
        /* VariantMerge generated from: '<S2196>/EngTrqReqPred' */
        rtb_Switch4_pe = VeESSR_M_EngTrqReqPrdtdMaxPFS;
    }

    /* End of Switch: '<S2209>/Switch' */
    /* End of Outputs for SubSystem: '<S2208>/Limiter3' */

    /* Update for UnitDelay: '<S2208>/x2' */
    localDW->x2_DSTATE_a = rtb_Switch4_pe;

    /* Update for UnitDelay: '<S2208>/temp' */
    localDW->temp_DSTATE_j = rtb_Switch3_fu;

    /* End of Outputs for SubSystem: '<S2202>/Lowpass Second Order Enabled3' */

    /* VariantMerge generated from: '<S2196>/EngTrqReqImmed' incorporates:
     *  Sum: '<S2202>/Sum1'
     */
    rtb_Switch3_fu = rtb_Switch4_pe - VeESSR_M_EngTrqReqImmedFltrPFS;

    /* End of Outputs for SubSystem: '<S2196>/Default' */
#endif

    /* End of Outputs for SubSystem: '<S2103>/EngineTorqueCommands_PFS' */

    /* DataStoreWrite: '<S2103>/Data Store Write' */
    VeESSR_M_EngTrqReqPrdtd_DS = rtb_Switch4_pe;

    /* DataStoreWrite: '<S2103>/Data Store Write1' */
    VeESSR_M_EngTrqReqImmed_DS = rtb_Switch3_fu;

    /* Switch: '<S2081>/Switch4' incorporates:
     *  S-Function (sfix_bitop): '<S2104>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator3_n)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 256U;
    }

    /* End of Switch: '<S2081>/Switch4' */

    /* Switch: '<S2081>/Switch2' incorporates:
     *  S-Function (sfix_bitop): '<S2105>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator4_b)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 512U;
    }

    /* End of Switch: '<S2081>/Switch2' */

    /* Switch: '<S2081>/Switch3' incorporates:
     *  S-Function (sfix_bitop): '<S2107>/FixPt Bitwise Operator1'
     */
    if (rtb_Logical5_je)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 536870912U;
    }

    /* End of Switch: '<S2081>/Switch3' */

    /* Switch: '<S2081>/Switch1' incorporates:
     *  Constant: '<S2081>/Constant Value'
     *  DataStoreRead: '<S2081>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S2081>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S2081>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S2081>/Logical21'
     *  RelationalOperator: '<S2081>/Comparison'
     *  S-Function (sfix_bitop): '<S2081>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S2106>/FixPt Bitwise Operator1'
     */
    if (rtb_Logical5_gk && ((VeESSR_g_StrtStpFailPhaseSelect_DS & 2048U) > 0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 2048U;
    }

    /* End of Switch: '<S2081>/Switch1' */

    /* Lookup_n-D: '<S2145>/Vector' */
    rtb_Vector_cq = look1_iflf_binlcapw(rtu_BatModTmp, ((const float32 *)
        &(KxESSRR_dn_NiRtLim[0])), ((const float32 *)&(KtESSRR_dn_NiRtLim[0])),
        3U);

    /* Gain: '<S2146>/Gain' incorporates:
     *  Abs: '<S2146>/Abs1'
     *  DataStoreRead: '<S2092>/Dsr_NiProfGenDNiDLim2'
     */
    rtb_Gain_oh = -fabsf(VeESSR_dn_StrtTypJerkMinStartEng_DS);

    /* Product: '<S2149>/Product4' incorporates:
     *  Constant: '<S2086>/Calib'
     */
    rtb_Product4 = rtb_Gain_oh / HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2146>/LowpassT Reset Enabled' */
    /* Sum: '<S2147>/Summation' incorporates:
     *  Constant: '<S2086>/Calib'
     *  DataStoreRead: '<S2092>/Dsr_Ni1stFlt_DS'
     *  DataStoreRead: '<S2092>/Dsr_NiProfGenT2Gain'
     *  MinMax: '<S2147>/Maximum'
     *  Product: '<S2147>/Multiplication'
     *  Product: '<S2147>/Multiplication1'
     *  Sum: '<S2147>/Subtraction'
     */
    rtb_Switch3_fu = (((VeESSR_n_NiTargetStrtEng_PFS - VeESSR_n_Ni1stFlt_DS) *
                       HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                       (VeESSR_k_StrtTypScndOrdLwPassT_DS, HeESSR_t_MedTEB_dT)))
        + VeESSR_n_Ni1stFlt_DS;

    /* End of Outputs for SubSystem: '<S2146>/LowpassT Reset Enabled' */

    /* Outputs for Atomic SubSystem: '<S2146>/LowpassT Reset Enabled1' */
    /* Sum: '<S2148>/Summation' incorporates:
     *  Constant: '<S2086>/Calib'
     *  DataStoreRead: '<S2092>/Dsr_InputSpeedProfile1'
     *  DataStoreRead: '<S2092>/Dsr_NiProfGenT1Gain'
     *  MinMax: '<S2148>/Maximum'
     *  Product: '<S2148>/Multiplication'
     *  Product: '<S2148>/Multiplication1'
     *  Sum: '<S2148>/Subtraction'
     */
    rtb_Switch4_pe = (((rtb_Switch3_fu - VeESSR_n_InputSpeedProfile_DS) *
                       HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                       (VeESSR_k_StrtTypFrstOrdLwPassT_DS, HeESSR_t_MedTEB_dT)))
        + VeESSR_n_InputSpeedProfile_DS;

    /* End of Outputs for SubSystem: '<S2146>/LowpassT Reset Enabled1' */

    /* Switch: '<S2168>/Switch1' incorporates:
     *  UnitDelay: '<S2168>/Unit Delay'
     */
    if (rtb_Equal2_k)
    {
        rtb_Dsr_STMTmr_nr = rtb_Switch4_pe;
    }
    else
    {
        rtb_Dsr_STMTmr_nr = localDW->UnitDelay_DSTATE;
    }

    /* End of Switch: '<S2168>/Switch1' */

    /* Gain: '<S2149>/Gain1' incorporates:
     *  Sum: '<S2149>/Sum18'
     */
    rtb_Dsr_STMTmr_nr = (rtb_Switch4_pe + rtb_Dsr_STMTmr_nr) * 0.5F;

    /* Delay: '<S2149>/IntegerDelay' incorporates:
     *  Constant: '<S2158>/Calib'
     */
    if (rtb_Equal2_k && (((uint32)localZCE->IntegerDelay_Reset_ZCE_jf) !=
                         POS_ZCSIG))
    {
        localDW->icLoad = 1U;
    }

    localZCE->IntegerDelay_Reset_ZCE_jf = rtb_Equal2_k ? ((ZCSigState)1) :
        ((ZCSigState)0);
    if (((sint32)localDW->icLoad) != 0)
    {
        for (i = 0; i < 16; i++)
        {
            localDW->IntegerDelay_DSTATE[i] = rtb_Dsr_STMTmr_nr;
        }
    }

    if (((sint32)KeESSR_Cnt_DelayOptNi) <= 0)
    {
        /* Delay: '<S2149>/IntegerDelay' */
        rtb_Summation_e1 = rtb_Dsr_STMTmr_nr;
    }
    else
    {
        if (((sint32)KeESSR_Cnt_DelayOptNi) > 16)
        {
            tmp = 16U;
        }
        else
        {
            tmp = KeESSR_Cnt_DelayOptNi;
        }

        /* Delay: '<S2149>/IntegerDelay' */
        rtb_Summation_e1 = localDW->IntegerDelay_DSTATE[(uint8)(16U - ((uint32)
            tmp))];
    }

    /* End of Delay: '<S2149>/IntegerDelay' */

    /* Sum: '<S2149>/Sum15' incorporates:
     *  Abs: '<S2149>/Abs4'
     *  Constant: '<S2142>/Calib'
     *  DataStoreRead: '<S2092>/Dsr_InputSpeedProfile5'
     */
    rtb_Sum_ix = fabsf(VeESSR_dn_TargetAcceltn_DS) + KeESSR_dn_NiTargetJerkLimit;

    /* Outputs for Atomic SubSystem: '<S2149>/GradientLimiter' */
    /* Sum: '<S2151>/Sum2' incorporates:
     *  Constant: '<S2086>/Calib'
     *  DataStoreRead: '<S2092>/Dsr_InputSpeedProfile4'
     *  Product: '<S2149>/Product6'
     *  Sum: '<S2149>/Sum14'
     *  UnitDelay: '<S2151>/Unit Delay'
     */
    rtb_Switch1_nzn = ((rtb_Dsr_STMTmr_nr - VeESSR_n_TargetSpeed_DS) /
                       HeESSR_t_MedTEB_dT) - localDW->UnitDelay_DSTATE_g;

    /* Outputs for Atomic SubSystem: '<S2151>/Limiter' */
    /* Switch: '<S2169>/Switch1' incorporates:
     *  RelationalOperator: '<S2169>/Relational Operator'
     */
    if (rtb_Sum_ix < rtb_Switch1_nzn)
    {
        /* MinMax: '<S2152>/MinMax1' */
        rtb_MinMax1_h = rtb_Sum_ix;
    }
    else
    {
        /* MinMax: '<S2152>/MinMax1' */
        rtb_MinMax1_h = rtb_Switch1_nzn;
    }

    /* End of Switch: '<S2169>/Switch1' */

    /* Switch: '<S2169>/Switch' incorporates:
     *  Gain: '<S2149>/Gain'
     *  RelationalOperator: '<S2169>/Relational Operator1'
     */
    if (rtb_MinMax1_h <= (-rtb_Sum_ix))
    {
        rtb_MinMax1_h = -rtb_Sum_ix;
    }

    /* End of Switch: '<S2169>/Switch' */
    /* End of Outputs for SubSystem: '<S2151>/Limiter' */

    /* Sum: '<S2151>/Sum3' incorporates:
     *  UnitDelay: '<S2151>/Unit Delay'
     */
    rtb_Abs_do = rtb_MinMax1_h + localDW->UnitDelay_DSTATE_g;

    /* Update for UnitDelay: '<S2151>/Unit Delay' */
    localDW->UnitDelay_DSTATE_g = rtb_Abs_do;

    /* End of Outputs for SubSystem: '<S2149>/GradientLimiter' */

    /* Sum: '<S2150>/Subtraction1' incorporates:
     *  Constant: '<S2143>/Calib'
     *  DataStoreRead: '<S2092>/Dsr_InputSpeedProfile5'
     *  Product: '<S2150>/Multiplication'
     *  Sum: '<S2150>/Subtraction'
     */
    rtb_Abs_do = ((rtb_Abs_do - VeESSR_dn_TargetAcceltn_DS) *
                  KeESSR_k_NiDotTargetFilt) + VeESSR_dn_TargetAcceltn_DS;

    /* DataStoreRead: '<S2092>/Dsr_InputAcceltnProf' */
    rtb_Sum_ix = VeESSR_dn_InputAcceltnProf_DS;

    /* Abs: '<S2146>/Abs' incorporates:
     *  DataStoreRead: '<S2092>/Dsr_NiProfGenDNiDLim1'
     */
    rtb_Switch1_nzn = fabsf(VeESSR_dn_StrtTypJerkMaxStartEng_DS);

    /* Switch: '<S2180>/Switch1' incorporates:
     *  Constant: '<S2178>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S2180>/Switch1' incorporates:
         *  Constant: '<S2179>/Calib'
         */
        rtb_Switch1_d2 = HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S2167>/Sum6' incorporates:
         *  DataStoreRead: '<S2092>/Dsr_InputAcceltnProf'
         *  Sum: '<S2167>/Sum8'
         */
        rtb_MinMax1_h = VeESSR_dn_InputAcceltnProf_DS - rtb_Abs_do;

        /* Abs: '<S2167>/Abs' incorporates:
         *  Sum: '<S2167>/Sum6'
         */
        rtb_Abs_om = (rtb_MinMax1_h - rtb_Gain_oh) + rtb_Switch1_nzn;

        /* MinMax: '<S2167>/MinMax2' incorporates:
         *  Abs: '<S2167>/Abs1'
         *  Constant: '<S2086>/Calib'
         *  Constant: '<S2167>/Constant Value'
         *  Constant: '<S2167>/Constant Value3'
         *  DataStoreRead: '<S2092>/Dsr_InputSpeedProfile1'
         *  Product: '<S2167>/Product2'
         *  Product: '<S2167>/Product7'
         *  Product: '<S2182>/Prod'
         *  Sum: '<S2167>/Sum3'
         *  Sum: '<S2167>/Sum5'
         */
        rtb_Abs_om = fmaxf((fabsf((rtb_Summation_e1 -
                              VeESSR_n_InputSpeedProfile_DS) -
                             (HeESSR_t_MedTEB_dT * rtb_Abs_do)) * (rtb_Product4 *
                             -2.0F)) - (rtb_Abs_om * rtb_Abs_om), 0.0F);

        /* Switch: '<S2184>/Switch' incorporates:
         *  Sqrt: '<S2184>/Sqrt'
         */
        rtb_Abs_om = sqrtf(rtb_Abs_om);

        /* Switch: '<S2180>/Switch1' incorporates:
         *  Abs: '<S2167>/Abs'
         *  Sum: '<S2167>/Sum7'
         *  Sum: '<S2167>/Sum8'
         */
        rtb_Switch1_d2 = fabsf(rtb_MinMax1_h + rtb_Gain_oh) + (rtb_Abs_om +
            rtb_Abs_do);
    }

    /* End of Switch: '<S2180>/Switch1' */

    /* Product: '<S2149>/Product1' incorporates:
     *  Constant: '<S2086>/Calib'
     */
    rtb_Abs_om = rtb_Switch1_nzn / HeESSR_t_MedTEB_dT;

    /* Switch: '<S2181>/Switch1' incorporates:
     *  Constant: '<S2178>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S2181>/Switch1' incorporates:
         *  Constant: '<S2179>/Calib'
         *  Gain: '<S2167>/Gain1'
         */
        rtb_Switch1_lps = -HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S2167>/Sum11' incorporates:
         *  DataStoreRead: '<S2092>/Dsr_InputAcceltnProf'
         *  Sum: '<S2167>/Sum13'
         */
        rtb_Switch_aes = VeESSR_dn_InputAcceltnProf_DS - rtb_Abs_do;

        /* Abs: '<S2167>/Abs2' incorporates:
         *  Sum: '<S2167>/Sum11'
         */
        rtb_MinMax1_h = (rtb_Switch_aes - rtb_Switch1_nzn) + rtb_Gain_oh;

        /* MinMax: '<S2167>/MinMax1' incorporates:
         *  Abs: '<S2167>/Abs3'
         *  Constant: '<S2086>/Calib'
         *  Constant: '<S2167>/Constant Value1'
         *  Constant: '<S2167>/Constant Value2'
         *  DataStoreRead: '<S2092>/Dsr_InputSpeedProfile1'
         *  Product: '<S2167>/Product5'
         *  Product: '<S2167>/Product8'
         *  Product: '<S2185>/Prod'
         *  Sum: '<S2167>/Sum10'
         *  Sum: '<S2167>/Sum9'
         */
        rtb_MinMax1_h = fmaxf((fabsf((rtb_Summation_e1 -
            VeESSR_n_InputSpeedProfile_DS) - (HeESSR_t_MedTEB_dT * rtb_Abs_do)) *
                               (rtb_Abs_om * 2.0F)) - (rtb_MinMax1_h *
                               rtb_MinMax1_h), 0.0F);

        /* Switch: '<S2183>/Switch' incorporates:
         *  Sqrt: '<S2183>/Sqrt'
         */
        rtb_MinMax1_h = sqrtf(rtb_MinMax1_h);

        /* Switch: '<S2181>/Switch1' incorporates:
         *  Abs: '<S2167>/Abs2'
         *  Sum: '<S2167>/Sum12'
         *  Sum: '<S2167>/Sum13'
         */
        rtb_Switch1_lps = (rtb_Abs_do - rtb_MinMax1_h) - fabsf(rtb_Switch_aes +
            rtb_Switch1_nzn);
    }

    /* End of Switch: '<S2181>/Switch1' */

    /* Switch: '<S2149>/Switch1' incorporates:
     *  Constant: '<S2154>/Calib'
     *  Constant: '<S2155>/Calib'
     *  DataStoreRead: '<S2092>/Data Store Read'
     *  DataStoreRead: '<S2092>/Dsr_InputSpeedProfile2'
     *  Logic: '<S2149>/Logical1'
     *  Logic: '<S2149>/Logical6'
     *  Logic: '<S2149>/Logical8'
     */
    if (((HeESSR_b_NiLmtBypsLoopJerk) && (VeESSR_b_NiMaxActive_DS)) ||
            ((VeESSR_b_NiDotMaxActive_DS) && (HeESSR_b_NiDotLmtBypsLoopJerk)))
    {
        /* Switch: '<S2149>/Switch1' */
        rtb_Switch1_nzn = rtb_Switch1_d2;
    }
    else
    {
        /* Switch: '<S2149>/Switch1' incorporates:
         *  DataStoreRead: '<S2092>/Dsr_InputAcceltnProf'
         *  Sum: '<S2149>/Sum1'
         */
        rtb_Switch1_nzn += VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S2149>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S2149>/Limiter2' */
    /* Switch: '<S2162>/Switch1' incorporates:
     *  RelationalOperator: '<S2162>/Relational Operator'
     */
    if (rtb_Switch1_d2 < rtb_Switch1_nzn)
    {
        /* Switch: '<S2160>/Switch1' */
        rtb_Switch1_nzn = rtb_Switch1_d2;
    }

    /* End of Switch: '<S2162>/Switch1' */

    /* Switch: '<S2162>/Switch' incorporates:
     *  RelationalOperator: '<S2162>/Relational Operator1'
     */
    if (rtb_Switch1_nzn <= rtb_Switch1_lps)
    {
        /* Switch: '<S2162>/Switch' */
        rtb_Switch1_nzn = rtb_Switch1_lps;
    }

    /* End of Switch: '<S2162>/Switch' */
    /* End of Outputs for SubSystem: '<S2149>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S2149>/Limiter4' */
    /* Switch: '<S2164>/Switch1' incorporates:
     *  RelationalOperator: '<S2164>/Relational Operator'
     */
    if (rtb_Vector_cq < rtb_Switch1_nzn)
    {
        /* Switch: '<S2160>/Switch1' */
        rtb_Switch1_nzn = rtb_Vector_cq;
    }

    /* End of Switch: '<S2164>/Switch1' */

    /* Switch: '<S2164>/Switch' incorporates:
     *  DataStoreRead: '<S2092>/Dsr_NiProfGenNiDMin'
     *  RelationalOperator: '<S2164>/Relational Operator1'
     */
    if (rtb_Switch1_nzn > VeESSR_dn_StrtTypNiDotMin_DS)
    {
        /* Switch: '<S2164>/Switch' */
        rtb_Switch_aes = rtb_Switch1_nzn;
    }
    else
    {
        /* Switch: '<S2164>/Switch' */
        rtb_Switch_aes = VeESSR_dn_StrtTypNiDotMin_DS;
    }

    /* End of Switch: '<S2164>/Switch' */
    /* End of Outputs for SubSystem: '<S2149>/Limiter4' */

    /* Sum: '<S2153>/Sum6' incorporates:
     *  DataStoreRead: '<S2092>/Dsr_InputSpeedProfile1'
     */
    rtb_Sum6_l5 = rtu_VeHSER_n_NiMax - VeESSR_n_InputSpeedProfile_DS;

    /* Abs: '<S2153>/Abs2' */
    rtb_MinMax1_h = fabsf(rtb_Sum6_l5);

    /* Switch: '<S2153>/Switch' incorporates:
     *  Constant: '<S2153>/Constant Value7'
     *  RelationalOperator: '<S2153>/Comparison2'
     */
    if (rtb_Sum6_l5 < 0.0F)
    {
        /* Switch: '<S2160>/Switch1' incorporates:
         *  Abs: '<S2153>/Abs'
         */
        rtb_Switch1_nzn = fabsf(rtb_Abs_om);
    }
    else
    {
        /* Switch: '<S2160>/Switch1' incorporates:
         *  Abs: '<S2153>/Abs1'
         *  Gain: '<S2153>/Gain'
         */
        rtb_Switch1_nzn = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S2153>/Switch' */

    /* Product: '<S2153>/Product4' incorporates:
     *  Constant: '<S2086>/Calib'
     */
    rtb_Product4_h = (rtb_Switch1_nzn * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2153>/Protected Division1' */
    /* Switch: '<S2176>/Switch1' incorporates:
     *  Constant: '<S2176>/Constant Value'
     *  Constant: '<S2176>/Constant Value1'
     *  Constant: '<S2176>/Constant Value2'
     *  Logic: '<S2176>/AND'
     *  RelationalOperator: '<S2176>/Greater Than or Equal '
     *  RelationalOperator: '<S2176>/Not Equal'
     *  RelationalOperator: '<S2176>/Not Equal1'
     *  Switch: '<S2176>/Switch2'
     */
    if ((rtb_MinMax1_h != 0.0F) && (rtb_Product4_h != 0.0F))
    {
        /* Switch: '<S2176>/Switch1' incorporates:
         *  Product: '<S2176>/Division'
         */
        rtb_MinMax1_h /= rtb_Product4_h;
    }
    else if (rtb_MinMax1_h > 0.0F)
    {
        /* Switch: '<S2176>/Switch2' incorporates:
         *  Constant: '<S2176>/MAXFLOAT'
         *  Switch: '<S2176>/Switch1'
         */
        rtb_MinMax1_h = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2176>/Switch1' incorporates:
         *  Constant: '<S2176>/Constant Value4'
         *  Switch: '<S2176>/Switch2'
         *  Switch: '<S2176>/Switch3'
         */
        rtb_MinMax1_h = 0.0F;
    }

    /* End of Switch: '<S2176>/Switch1' */
    /* End of Outputs for SubSystem: '<S2153>/Protected Division1' */

    /* Sum: '<S2153>/Sum4' incorporates:
     *  Abs: '<S2153>/Abs3'
     *  Constant: '<S2153>/Constant Value3'
     *  Constant: '<S2153>/Constant Value5'
     *  Product: '<S2153>/Product3'
     */
    rtb_MinMax1_h = (fabsf(rtb_MinMax1_h) * 8.0F) + 1.0F;

    /* Switch: '<S2177>/Switch' */
    if (rtb_MinMax1_h >= 0.0F)
    {
        /* MinMax: '<S2152>/MinMax1' incorporates:
         *  Sqrt: '<S2177>/Sqrt'
         */
        rtb_MinMax1_h = sqrtf(rtb_MinMax1_h);
    }
    else
    {
        /* MinMax: '<S2152>/MinMax1' incorporates:
         *  Constant: '<S2177>/Zero'
         */
        rtb_MinMax1_h = 0.0F;
    }

    /* End of Switch: '<S2177>/Switch' */

    /* MinMax: '<S2152>/MinMax1' incorporates:
     *  Constant: '<S2153>/Constant Value'
     *  Constant: '<S2153>/Constant Value4'
     *  Constant: '<S2153>/Constant Value6'
     *  MinMax: '<S2153>/MinMax1'
     *  Product: '<S2153>/Product2'
     *  Rounding: '<S2153>/Rounding1'
     *  Sum: '<S2153>/Sum3'
     */
    rtb_MinMax1_h = fmaxf(ceilf((rtb_MinMax1_h - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S2153>/Product' incorporates:
     *  Constant: '<S2086>/Calib'
     */
    rtb_Product4_h = rtb_MinMax1_h * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2153>/Protected Division' */
    /* Switch: '<S2175>/Switch1' incorporates:
     *  Constant: '<S2175>/Constant Value'
     *  Constant: '<S2175>/Constant Value1'
     *  Constant: '<S2175>/Constant Value2'
     *  Constant: '<S2175>/Constant Value3'
     *  Logic: '<S2175>/AND'
     *  RelationalOperator: '<S2175>/Greater Than or Equal '
     *  RelationalOperator: '<S2175>/Greater Than or Equal 1'
     *  RelationalOperator: '<S2175>/Not Equal'
     *  RelationalOperator: '<S2175>/Not Equal1'
     *  Switch: '<S2175>/Switch2'
     *  Switch: '<S2175>/Switch3'
     */
    if ((rtb_Sum6_l5 != 0.0F) && (rtb_Product4_h != 0.0F))
    {
        /* Switch: '<S2175>/Switch1' incorporates:
         *  Product: '<S2175>/Division'
         */
        rtb_Sum6_l5 /= rtb_Product4_h;
    }
    else if (rtb_Sum6_l5 > 0.0F)
    {
        /* Switch: '<S2175>/Switch2' incorporates:
         *  Constant: '<S2175>/MAXFLOAT'
         *  Switch: '<S2175>/Switch1'
         */
        rtb_Sum6_l5 = 3.402823466E+38F;
    }
    else if (rtb_Sum6_l5 < 0.0F)
    {
        /* Switch: '<S2175>/Switch3' incorporates:
         *  Constant: '<S2175>/MINFLOAT'
         *  Switch: '<S2175>/Switch1'
         *  Switch: '<S2175>/Switch2'
         */
        rtb_Sum6_l5 = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2175>/Switch1' incorporates:
         *  Constant: '<S2175>/Constant Value4'
         *  Switch: '<S2175>/Switch2'
         *  Switch: '<S2175>/Switch3'
         */
        rtb_Sum6_l5 = 0.0F;
    }

    /* End of Switch: '<S2175>/Switch1' */
    /* End of Outputs for SubSystem: '<S2153>/Protected Division' */

    /* Sum: '<S2153>/Sum' incorporates:
     *  Constant: '<S2086>/Calib'
     *  Constant: '<S2153>/Constant Value1'
     *  Constant: '<S2153>/Constant Value2'
     *  Product: '<S2153>/Product1'
     *  Sum: '<S2153>/Sum2'
     */
    rtb_MinMax1_h = rtb_Sum6_l5 - (((0.5F * rtb_Switch1_nzn) * (rtb_MinMax1_h -
        1.0F)) * HeESSR_t_MedTEB_dT);

    /* Switch: '<S2149>/Switch4' incorporates:
     *  Constant: '<S2156>/Calib'
     */
    if (!HeESSR_b_NiLmtForAccelByps)
    {
        /* Switch: '<S2149>/Switch4' incorporates:
         *  MinMax: '<S2149>/MinMax1'
         */
        rtb_Switch_aes = fminf(rtb_MinMax1_h, rtb_Switch_aes);
    }

    /* End of Switch: '<S2149>/Switch4' */

    /* Outputs for Atomic SubSystem: '<S2149>/Limiter13' */
    /* RelationalOperator: '<S2161>/Relational Operator' */
    rtb_LogicalOperator4_b = (rtu_VeHSER_dn_NiDotMax <= rtb_Switch_aes);

    /* Switch: '<S2161>/Switch1' */
    if (rtb_LogicalOperator4_b)
    {
        /* Switch: '<S2160>/Switch1' */
        rtb_Switch1_nzn = rtu_VeHSER_dn_NiDotMax;
    }
    else
    {
        /* Switch: '<S2160>/Switch1' */
        rtb_Switch1_nzn = rtb_Switch_aes;
    }

    /* End of Switch: '<S2161>/Switch1' */

    /* Switch: '<S2161>/Switch' incorporates:
     *  RelationalOperator: '<S2161>/Relational Operator1'
     */
    if (rtb_Switch1_nzn <= rtu_VeHSER_dn_NiDotMin)
    {
        rtb_Switch1_nzn = rtu_VeHSER_dn_NiDotMin;
    }

    /* End of Switch: '<S2161>/Switch' */
    /* End of Outputs for SubSystem: '<S2149>/Limiter13' */

    /* Product: '<S2149>/Product9' incorporates:
     *  Constant: '<S2086>/Calib'
     */
    rtb_Switch_aes = rtb_Switch1_nzn * HeESSR_t_MedTEB_dT;

    /* Switch: '<S2149>/Switch2' incorporates:
     *  Constant: '<S2154>/Calib'
     *  DataStoreRead: '<S2092>/Dsr_InputSpeedProfile3'
     *  Logic: '<S2149>/Logical3'
     */
    if ((HeESSR_b_NiDotLmtBypsLoopJerk) && (VeESSR_b_NiDotMinActive_DS))
    {
        /* Switch: '<S2149>/Switch2' */
        rtb_Switch1_nzn = rtb_Switch1_lps;
    }
    else
    {
        /* Switch: '<S2149>/Switch2' incorporates:
         *  DataStoreRead: '<S2092>/Dsr_InputAcceltnProf'
         *  Sum: '<S2149>/Sum16'
         */
        rtb_Switch1_nzn = VeESSR_dn_InputAcceltnProf_DS + rtb_Gain_oh;
    }

    /* End of Switch: '<S2149>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S2149>/Limiter' */
    /* Switch: '<S2159>/Switch1' incorporates:
     *  RelationalOperator: '<S2159>/Relational Operator'
     */
    if (rtb_Switch1_d2 < rtb_Switch1_nzn)
    {
        /* Switch: '<S2160>/Switch1' */
        rtb_Switch1_nzn = rtb_Switch1_d2;
    }

    /* End of Switch: '<S2159>/Switch1' */

    /* Switch: '<S2159>/Switch' incorporates:
     *  RelationalOperator: '<S2159>/Relational Operator1'
     */
    if (rtb_Switch1_nzn <= rtb_Switch1_lps)
    {
        /* Switch: '<S2159>/Switch' */
        rtb_Switch1_nzn = rtb_Switch1_lps;
    }

    /* End of Switch: '<S2159>/Switch' */
    /* End of Outputs for SubSystem: '<S2149>/Limiter' */

    /* Outputs for Atomic SubSystem: '<S2149>/Limiter3' */
    /* Switch: '<S2163>/Switch1' incorporates:
     *  RelationalOperator: '<S2163>/Relational Operator'
     */
    if (rtb_Vector_cq < rtb_Switch1_nzn)
    {
        /* Switch: '<S2160>/Switch1' */
        rtb_Switch1_nzn = rtb_Vector_cq;
    }

    /* End of Switch: '<S2163>/Switch1' */
    /* End of Outputs for SubSystem: '<S2149>/Limiter3' */

    /* Switch: '<S2149>/Switch5' incorporates:
     *  Constant: '<S2156>/Calib'
     *  DataStoreRead: '<S2092>/Dsr_NiProfGenNiDMin'
     *  RelationalOperator: '<S2163>/Relational Operator1'
     *  Switch: '<S2163>/Switch'
     */
    if (HeESSR_b_NiLmtForAccelByps)
    {
        /* Outputs for Atomic SubSystem: '<S2149>/Limiter3' */
        /* Switch: '<S2163>/Switch' incorporates:
         *  DataStoreRead: '<S2092>/Dsr_NiProfGenNiDMin'
         *  RelationalOperator: '<S2163>/Relational Operator1'
         */
        if (rtb_Switch1_nzn <= VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S2149>/Switch5' */
            rtb_Switch1_nzn = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Outputs for SubSystem: '<S2149>/Limiter3' */
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S2149>/Limiter3' */
        if (rtb_Switch1_nzn <= VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S2163>/Switch' incorporates:
             *  DataStoreRead: '<S2092>/Dsr_NiProfGenNiDMin'
             */
            rtb_Switch1_nzn = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Outputs for SubSystem: '<S2149>/Limiter3' */

        /* Switch: '<S2149>/Switch5' incorporates:
         *  MinMax: '<S2149>/MinMax2'
         */
        rtb_Switch1_nzn = fminf(rtb_MinMax1_h, rtb_Switch1_nzn);
    }

    /* End of Switch: '<S2149>/Switch5' */

    /* Outputs for Atomic SubSystem: '<S2149>/Limiter9' */
    /* Switch: '<S2166>/Switch1' incorporates:
     *  RelationalOperator: '<S2166>/Relational Operator'
     */
    if (rtu_VeHSER_dn_NiDotMax <= rtb_Switch1_nzn)
    {
        /* Switch: '<S2160>/Switch1' */
        rtb_Switch1_nzn = rtu_VeHSER_dn_NiDotMax;
    }

    /* End of Switch: '<S2166>/Switch1' */

    /* RelationalOperator: '<S2165>/Relational Operator1' incorporates:
     *  RelationalOperator: '<S2166>/Relational Operator1'
     */
    rtb_RelationalOperator1_cd = (rtb_Switch1_nzn > rtu_VeHSER_dn_NiDotMin);

    /* Logic: '<S2166>/Logical2' */
    rtb_Equal2_k = !rtb_RelationalOperator1_cd;

    /* Switch: '<S2166>/Switch' */
    if (!rtb_RelationalOperator1_cd)
    {
        rtb_Switch1_nzn = rtu_VeHSER_dn_NiDotMin;
    }

    /* End of Switch: '<S2166>/Switch' */
    /* End of Outputs for SubSystem: '<S2149>/Limiter9' */

    /* Product: '<S2149>/Product10' incorporates:
     *  Constant: '<S2086>/Calib'
     */
    rtb_Vector_cq = rtb_Switch1_nzn * HeESSR_t_MedTEB_dT;

    /* Sum: '<S2149>/Sum2' incorporates:
     *  DataStoreRead: '<S2092>/Dsr_InputSpeedProfile1'
     */
    rtb_Gain_oh = rtb_Summation_e1 - VeESSR_n_InputSpeedProfile_DS;

    /* Sum: '<S2152>/Sum6' incorporates:
     *  Constant: '<S2086>/Calib'
     *  DataStoreRead: '<S2092>/Dsr_InputSpeedProfile1'
     *  Product: '<S2152>/Product7'
     *  Sum: '<S2149>/Sum6'
     *  Switch: '<S2149>/Switch3'
     */
    rtb_Summation_e1 = (rtb_Summation_e1 - VeESSR_n_InputSpeedProfile_DS) -
        (rtb_Abs_do * HeESSR_t_MedTEB_dT);

    /* Abs: '<S2152>/Abs2' incorporates:
     *  Sum: '<S2152>/Sum6'
     */
    rtb_MinMax1_h = fabsf(rtb_Summation_e1);

    /* Switch: '<S2152>/Switch' incorporates:
     *  Constant: '<S2152>/Constant Value7'
     *  RelationalOperator: '<S2152>/Comparison2'
     *  Sum: '<S2152>/Sum6'
     */
    if (rtb_Summation_e1 < 0.0F)
    {
        /* Switch: '<S2160>/Switch1' incorporates:
         *  Abs: '<S2152>/Abs'
         */
        rtb_Switch1_nzn = fabsf(rtb_Abs_om);
    }
    else
    {
        /* Switch: '<S2160>/Switch1' incorporates:
         *  Abs: '<S2152>/Abs1'
         *  Gain: '<S2152>/Gain'
         */
        rtb_Switch1_nzn = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S2152>/Switch' */

    /* Product: '<S2152>/Product4' incorporates:
     *  Constant: '<S2086>/Calib'
     */
    rtb_Product4 = (rtb_Switch1_nzn * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2152>/Protected Division1' */
    /* Switch: '<S2172>/Switch1' incorporates:
     *  Constant: '<S2172>/Constant Value'
     *  Constant: '<S2172>/Constant Value1'
     *  Constant: '<S2172>/Constant Value2'
     *  Logic: '<S2172>/AND'
     *  RelationalOperator: '<S2172>/Greater Than or Equal '
     *  RelationalOperator: '<S2172>/Not Equal'
     *  RelationalOperator: '<S2172>/Not Equal1'
     *  Switch: '<S2172>/Switch2'
     */
    if ((rtb_MinMax1_h != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S2172>/Switch1' incorporates:
         *  Product: '<S2172>/Division'
         */
        rtb_Product4 = rtb_MinMax1_h / rtb_Product4;
    }
    else if (rtb_MinMax1_h > 0.0F)
    {
        /* Switch: '<S2172>/Switch2' incorporates:
         *  Constant: '<S2172>/MAXFLOAT'
         *  Switch: '<S2172>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2172>/Switch1' incorporates:
         *  Constant: '<S2172>/Constant Value4'
         *  Switch: '<S2172>/Switch2'
         *  Switch: '<S2172>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S2172>/Switch1' */
    /* End of Outputs for SubSystem: '<S2152>/Protected Division1' */

    /* Sum: '<S2152>/Sum4' incorporates:
     *  Abs: '<S2152>/Abs3'
     *  Constant: '<S2152>/Constant Value3'
     *  Constant: '<S2152>/Constant Value5'
     *  Product: '<S2152>/Product3'
     */
    rtb_Product4 = (fabsf(rtb_Product4) * 8.0F) + 1.0F;

    /* Switch: '<S2173>/Switch' incorporates:
     *  Constant: '<S2173>/Zero'
     *  Sqrt: '<S2173>/Sqrt'
     */
    if (rtb_Product4 >= 0.0F)
    {
        rtb_Product4 = sqrtf(rtb_Product4);
    }
    else
    {
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S2173>/Switch' */

    /* MinMax: '<S2152>/MinMax1' incorporates:
     *  Constant: '<S2152>/Constant Value'
     *  Constant: '<S2152>/Constant Value4'
     *  Constant: '<S2152>/Constant Value6'
     *  Product: '<S2152>/Product2'
     *  Rounding: '<S2152>/Rounding1'
     *  Sum: '<S2152>/Sum3'
     */
    rtb_MinMax1_h = fmaxf(ceilf((rtb_Product4 - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S2152>/Product' incorporates:
     *  Constant: '<S2086>/Calib'
     */
    rtb_Product4 = rtb_MinMax1_h * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2152>/Protected Division' */
    /* Switch: '<S2171>/Switch1' incorporates:
     *  Constant: '<S2171>/Constant Value'
     *  Constant: '<S2171>/Constant Value1'
     *  Constant: '<S2171>/Constant Value2'
     *  Constant: '<S2171>/Constant Value3'
     *  Logic: '<S2171>/AND'
     *  RelationalOperator: '<S2171>/Greater Than or Equal '
     *  RelationalOperator: '<S2171>/Greater Than or Equal 1'
     *  RelationalOperator: '<S2171>/Not Equal'
     *  RelationalOperator: '<S2171>/Not Equal1'
     *  Sum: '<S2152>/Sum6'
     *  Switch: '<S2171>/Switch2'
     *  Switch: '<S2171>/Switch3'
     */
    if ((rtb_Summation_e1 != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S2171>/Switch1' incorporates:
         *  Product: '<S2171>/Division'
         */
        rtb_Product4 = rtb_Summation_e1 / rtb_Product4;
    }
    else if (rtb_Summation_e1 > 0.0F)
    {
        /* Switch: '<S2171>/Switch2' incorporates:
         *  Constant: '<S2171>/MAXFLOAT'
         *  Switch: '<S2171>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else if (rtb_Summation_e1 < 0.0F)
    {
        /* Switch: '<S2171>/Switch3' incorporates:
         *  Constant: '<S2171>/MINFLOAT'
         *  Switch: '<S2171>/Switch1'
         *  Switch: '<S2171>/Switch2'
         */
        rtb_Product4 = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2171>/Switch1' incorporates:
         *  Constant: '<S2171>/Constant Value4'
         *  Switch: '<S2171>/Switch2'
         *  Switch: '<S2171>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S2171>/Switch1' */
    /* End of Outputs for SubSystem: '<S2152>/Protected Division' */

    /* Switch: '<S2149>/Switch3' incorporates:
     *  Constant: '<S2157>/Calib'
     */
    if (!HeESSR_b_TrnstnJerkByps)
    {
        /* Switch: '<S2149>/Switch8' incorporates:
         *  Constant: '<S2149>/Constant Value7'
         *  RelationalOperator: '<S2149>/Comparison'
         */
        if (rtb_Summation_e1 > 0.0F)
        {
            /* Switch: '<S2149>/Switch3' incorporates:
             *  Constant: '<S2086>/Calib'
             *  Constant: '<S2152>/Constant Value1'
             *  Constant: '<S2152>/Constant Value2'
             *  MinMax: '<S2149>/MinMax4'
             *  Product: '<S2149>/Product5'
             *  Product: '<S2152>/Product1'
             *  Sum: '<S2152>/Sum'
             *  Sum: '<S2152>/Sum2'
             *  Switch: '<S2149>/Switch8'
             */
            rtb_Gain_oh = fminf(rtb_Gain_oh, ((rtb_Product4 + rtb_Abs_do) -
                                 (((0.5F * rtb_Switch1_nzn) * (rtb_MinMax1_h -
                                    1.0F)) * HeESSR_t_MedTEB_dT)) *
                                HeESSR_t_MedTEB_dT);
        }
        else
        {
            /* Switch: '<S2149>/Switch3' incorporates:
             *  Constant: '<S2086>/Calib'
             *  Constant: '<S2152>/Constant Value1'
             *  Constant: '<S2152>/Constant Value2'
             *  MinMax: '<S2149>/MinMax5'
             *  Product: '<S2149>/Product2'
             *  Product: '<S2152>/Product1'
             *  Sum: '<S2152>/Sum'
             *  Sum: '<S2152>/Sum2'
             *  Switch: '<S2149>/Switch8'
             */
            rtb_Gain_oh = fmaxf(rtb_Gain_oh, ((rtb_Product4 + rtb_Abs_do) -
                                 (((0.5F * rtb_Switch1_nzn) * (rtb_MinMax1_h -
                                    1.0F)) * HeESSR_t_MedTEB_dT)) *
                                HeESSR_t_MedTEB_dT);
        }

        /* End of Switch: '<S2149>/Switch8' */
    }

    /* Outputs for Atomic SubSystem: '<S2149>/Limiter6' */
    /* RelationalOperator: '<S2165>/Relational Operator' */
    rtb_LogicalOperator3_n = (rtb_Switch_aes <= rtb_Gain_oh);

    /* Switch: '<S2165>/Switch1' */
    if (rtb_LogicalOperator3_n)
    {
        /* Switch: '<S2160>/Switch1' */
        rtb_Switch1_nzn = rtb_Switch_aes;
    }
    else
    {
        /* Switch: '<S2160>/Switch1' */
        rtb_Switch1_nzn = rtb_Gain_oh;
    }

    /* End of Switch: '<S2165>/Switch1' */

    /* RelationalOperator: '<S2165>/Relational Operator1' */
    rtb_RelationalOperator1_cd = (rtb_Switch1_nzn > rtb_Vector_cq);

    /* Switch: '<S2165>/Switch' */
    if (rtb_RelationalOperator1_cd)
    {
        rtb_Vector_cq = rtb_Switch1_nzn;
    }

    /* End of Switch: '<S2165>/Switch' */
    /* End of Outputs for SubSystem: '<S2149>/Limiter6' */

    /* Sum: '<S2149>/Sum4' incorporates:
     *  DataStoreRead: '<S2092>/Dsr_InputSpeedProfile1'
     */
    rtb_Summation_e1 = rtb_Vector_cq + VeESSR_n_InputSpeedProfile_DS;

    /* Outputs for Atomic SubSystem: '<S2149>/Limiter1' */
    /* RelationalOperator: '<S2160>/Relational Operator' incorporates:
     *  DataStoreWrite: '<S2092>/Dsw_InputSpeedProfile5'
     */
    VeESSR_b_NiMaxActive_DS = (rtu_VeHSER_n_NiMax <= rtb_Summation_e1);

    /* Switch: '<S2160>/Switch1' incorporates:
     *  DataStoreWrite: '<S2092>/Dsw_InputSpeedProfile5'
     */
    if (VeESSR_b_NiMaxActive_DS)
    {
        /* Switch: '<S2160>/Switch1' */
        rtb_Switch1_nzn = rtu_VeHSER_n_NiMax;
    }
    else
    {
        /* Switch: '<S2160>/Switch1' */
        rtb_Switch1_nzn = rtb_Summation_e1;
    }

    /* End of Switch: '<S2160>/Switch1' */

    /* Switch: '<S2160>/Switch' incorporates:
     *  Constant: '<S2149>/Constant Value4'
     *  RelationalOperator: '<S2160>/Relational Operator1'
     */
    if (rtb_Switch1_nzn > 0.0F)
    {
        /* Switch: '<S2160>/Switch' */
        rtb_Summation_e1 = rtb_Switch1_nzn;
    }
    else
    {
        /* Switch: '<S2160>/Switch' */
        rtb_Summation_e1 = 0.0F;
    }

    /* End of Switch: '<S2160>/Switch' */
    /* End of Outputs for SubSystem: '<S2149>/Limiter1' */

    /* Product: '<S2149>/Product3' incorporates:
     *  Constant: '<S2086>/Calib'
     *  DataStoreRead: '<S2092>/Dsr_InputSpeedProfile1'
     *  DataStoreWrite: '<S2092>/Dsw_InputAcceltnProf'
     *  Sum: '<S2149>/Sum'
     */
    VeESSR_dn_InputAcceltnProf_DS = (rtb_Summation_e1 -
        VeESSR_n_InputSpeedProfile_DS) / HeESSR_t_MedTEB_dT;

    /* DataStoreWrite: '<S2092>/Dsw_InputSpeedProfile' */
    VeESSR_n_InputSpeedProfile_DS = rtb_Summation_e1;

    /* Logic: '<S2149>/Logical2' incorporates:
     *  DataStoreWrite: '<S2092>/Dsw_InputSpeedProfile1'
     */
    VeESSR_b_NiDotMaxActive_DS = (rtb_LogicalOperator4_b &&
        rtb_LogicalOperator3_n);

    /* DataStoreWrite: '<S2092>/Dsw_InputSpeedProfile2' */
    VeESSR_n_TargetSpeed_DS = rtb_Dsr_STMTmr_nr;

    /* DataStoreWrite: '<S2092>/Dsw_InputSpeedProfile3' */
    VeESSR_dn_TargetAcceltn_DS = rtb_Abs_do;

    /* Outputs for Atomic SubSystem: '<S2149>/Limiter6' */
    /* Logic: '<S2149>/Logical' incorporates:
     *  DataStoreWrite: '<S2092>/Dsw_InputSpeedProfile4'
     *  Logic: '<S2165>/Logical2'
     */
    VeESSR_b_NiDotMinActive_DS = (rtb_Equal2_k && (!rtb_RelationalOperator1_cd));

    /* End of Outputs for SubSystem: '<S2149>/Limiter6' */

    /* DataStoreWrite: '<S2092>/Dsw_Ni1stFlt_DS' */
    VeESSR_n_Ni1stFlt_DS = rtb_Switch3_fu;

    /* Sum: '<S2149>/Sum17' incorporates:
     *  DataStoreWrite: '<S2092>/Dsw_InputAcceltnProf'
     */
    VeESSR_dn_InputJerkProfStartEngPFS = VeESSR_dn_InputAcceltnProf_DS -
        rtb_Sum_ix;

    /* If: '<S2082>/If' */
    if (rtb_GreaterThan1_fm)
    {
        /* Outputs for IfAction SubSystem: '<S2076>/ESSC_PBatBoostReset' incorporates:
         *  ActionPort: '<S2083>/Action Port'
         */
        ESSR_ac_ESSC_PBatBoostReset();

        /* End of Outputs for SubSystem: '<S2076>/ESSC_PBatBoostReset' */
    }

    /* End of If: '<S2082>/If' */

    /* Update for UnitDelay: '<S2168>/Unit Delay' incorporates:
     *  Switch: '<S2168>/Switch3'
     */
    localDW->UnitDelay_DSTATE = rtb_Switch4_pe;

    /* Update for Delay: '<S2149>/IntegerDelay' */
    localDW->icLoad = 0U;
    for (i = 0; i < 15; i++)
    {
        localDW->IntegerDelay_DSTATE[i] = localDW->IntegerDelay_DSTATE[i + 1];
    }

    localDW->IntegerDelay_DSTATE[15] = rtb_Dsr_STMTmr_nr;

    /* End of Update for Delay: '<S2149>/IntegerDelay' */
}

#endif

/* Output and update for function-call system: '<S563>/SpnUpFreEng_Bmp_Du' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpnUpFreEng_Bmp_Du(VAR(float32,
    AUTOMATIC) rtu_VeESSR_n_TransInSpdFlt, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeEPCR_M_EngPulseTorqEst, VAR(float32, AUTOMATIC)
    rtu_VeENGR_T_EngCoolantTemp, VAR(float32, AUTOMATIC)
    rtu_VeOHSR_n_InputSpeedDsrdM2, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_OptInputSpd, VAR(float32, AUTOMATIC)
    rtu_VeESMR_P_BatEstdVoltMaxLim, VAR(float32, AUTOMATIC)
    rtu_VeTISR_n_TransMinInputSpd, VAR(TeHSER_e_RngEqnSel, AUTOMATIC)
    rtu_VeHSER_e_RngEqnSel, VAR(float32, AUTOMATIC) rtu_VeESSR_dn_DtrmnNidot,
    VAR(uint16, AUTOMATIC) rtu_VeTINR_d_TCMFailures, VAR(boolean, AUTOMATIC)
    rtu_PSA_Actv, VAR(boolean, AUTOMATIC) rtu_EngCombustionCmnd, VAR(float32,
    AUTOMATIC) rtu_VeHTDR_M_MtrB_TorqCmnd, VAR(float32, AUTOMATIC)
    rtu_VeATRR_M_OutputTorqReqImmed, P2VAR(DW_SpnUpFreEng_Bmp_Du_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn)
{
    float32 rtb_Sum2_ob;
    float32 rtb_Summation_fa;
    boolean rtb_LeESSR_b_SpnUpBmpStrtFailEn;
    boolean rtb_LogicalOperator2_ei;

    /* S-Function (sfix_bitop): '<S1332>/Bitwise Logical Operator6' incorporates:
     *  Constant: '<S1351>/Calib'
     */
    VeESSR_d_TCMFailuresMasked = (uint16)(rtu_VeTINR_d_TCMFailures &
        KeESSR_d_TCMFailures_MaskVal);

    /* Logic: '<S1332>/Logical6' incorporates:
     *  Constant: '<S1332>/Constant Value1'
     *  Constant: '<S1332>/Constant Value4'
     *  Constant: '<S1332>/Constant Value5'
     *  RelationalOperator: '<S1332>/Comparison'
     *  RelationalOperator: '<S1332>/Comparison1'
     *  RelationalOperator: '<S1332>/Comparison3'
     */
    VeESSR_b_SpnUpBmpStrtFailTCM = (((128 == ((sint32)VeESSR_d_TCMFailuresMasked))
        || (((sint32)VeESSR_d_TCMFailuresMasked) == 32)) || (((sint32)
        VeESSR_d_TCMFailuresMasked) == 64));

    /* Logic: '<S1299>/Logical Operator9' incorporates:
     *  Constant: '<S1325>/Calib'
     *  DataStoreRead: '<S1299>/Dsr_STMTmr1'
     *  RelationalOperator: '<S1299>/Greater  Than1'
     */
    VeESSR_b_SpnUpBmpStrtFailRaw = ((VeESSR_b_SpnUpBmpStrtFailTCM) ||
        (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmSpinUp_BumpStrt));

    /* Logic: '<S1299>/Logical Operator15' incorporates:
     *  Constant: '<S1319>/Calib'
     */
    VeESSR_b_SpnUpBmpStrtFailPend = ((KeESSR_b_SpnUpBmpStrtFailEV_Enbl) &&
        (VeESSR_b_SpnUpBmpStrtFailRaw));

    /* Logic: '<S1299>/Logical Operator5' incorporates:
     *  DataStoreWrite: '<S1299>/TCMOpenDiscCltch'
     */
    VeESSR_b_TCMOpenDisconnctCltch_DS = (rtu_PSA_Actv &&
        (VeESSR_b_SpnUpBmpStrtFailPend));

    /* Outputs for Atomic SubSystem: '<S1299>/Accumulator Reset Enabled Limited1' */
    /* Switch: '<S1302>/Switch2' incorporates:
     *  DataStoreWrite: '<S1299>/TCMOpenDiscCltch'
     *  Logic: '<S1299>/Logical Operator21'
     *  Switch: '<S1302>/Switch1'
     */
    if (!VeESSR_b_TCMOpenDisconnctCltch_DS)
    {
        /* Switch: '<S1302>/Switch1' incorporates:
         *  Constant: '<S1299>/Constant Value7'
         */
        VeESSR_n_SpnUpBmpStrtFailCDAccm = 0.0F;
    }
    else
    {
        /* Sum: '<S1302>/Summation' incorporates:
         *  Constant: '<S1322>/Calib'
         *  Sum: '<S1299>/Summation6'
         *  UnitDelay: '<S1302>/Unit Delay'
         */
        rtb_Summation_fa = (KeESSR_n_SpnUpBmpStrtCoastDwnSpd -
                            rtu_VeESSR_n_TransInSpdFlt) +
            VeESSR_n_SpnUpBmpStrtFailCDAccm;

        /* Outputs for Atomic SubSystem: '<S1302>/Limiter' */
        /* Switch: '<S1334>/Switch1' incorporates:
         *  Constant: '<S1321>/Calib'
         *  RelationalOperator: '<S1334>/Relational Operator'
         */
        if (KeESSR_n_SpnUpBmpStrtCDDeltaSpd < rtb_Summation_fa)
        {
            /* Switch: '<S1334>/Switch1' */
            rtb_Summation_fa = KeESSR_n_SpnUpBmpStrtCDDeltaSpd;
        }

        /* End of Switch: '<S1334>/Switch1' */

        /* Switch: '<S1334>/Switch' incorporates:
         *  Constant: '<S1299>/Constant Value7'
         *  RelationalOperator: '<S1334>/Relational Operator1'
         */
        if (rtb_Summation_fa > 0.0F)
        {
            /* Switch: '<S1302>/Switch1' incorporates:
             *  Switch: '<S1302>/Switch2'
             */
            VeESSR_n_SpnUpBmpStrtFailCDAccm = rtb_Summation_fa;
        }
        else
        {
            /* Switch: '<S1302>/Switch1' incorporates:
             *  Switch: '<S1302>/Switch2'
             */
            VeESSR_n_SpnUpBmpStrtFailCDAccm = 0.0F;
        }

        /* End of Switch: '<S1334>/Switch' */
        /* End of Outputs for SubSystem: '<S1302>/Limiter' */
    }

    /* End of Switch: '<S1302>/Switch2' */
    /* End of Outputs for SubSystem: '<S1299>/Accumulator Reset Enabled Limited1' */

    /* RelationalOperator: '<S1299>/Comparison4' incorporates:
     *  Constant: '<S1321>/Calib'
     */
    VeESSR_b_SpnUpBmpStrtFailCoastDownDtct = (VeESSR_n_SpnUpBmpStrtFailCDAccm >=
        KeESSR_n_SpnUpBmpStrtCDDeltaSpd);

    /* Sum: '<S1299>/Summation5' incorporates:
     *  Constant: '<S1324>/Calib'
     *  Sum: '<S1299>/Summation3'
     */
    VeESSR_n_SpnUpBmpStrtEngRunAccmIn = rtu_VeESSR_n_TransInSpdFlt -
        (rtu_VeESSR_n_OptInputSpd - KeESSR_n_SpnUpBmpStrtOptNiDeltaSpd);

    /* Outputs for Atomic SubSystem: '<S1299>/Accumulator Reset Enabled Limited' */
    /* Switch: '<S1301>/Switch2' incorporates:
     *  DataStoreWrite: '<S1299>/TCMOpenDiscCltch'
     *  Logic: '<S1299>/Logical Operator10'
     *  Switch: '<S1301>/Switch1'
     */
    if (!VeESSR_b_TCMOpenDisconnctCltch_DS)
    {
        /* Switch: '<S1301>/Switch1' incorporates:
         *  Constant: '<S1299>/Constant Value6'
         */
        VeESSR_n_SpnUpBmpStrtFailEngRunAccm = 0.0F;
    }
    else
    {
        /* Sum: '<S1301>/Summation' incorporates:
         *  UnitDelay: '<S1301>/Unit Delay'
         */
        rtb_Summation_fa = VeESSR_n_SpnUpBmpStrtEngRunAccmIn +
            VeESSR_n_SpnUpBmpStrtFailEngRunAccm;

        /* Outputs for Atomic SubSystem: '<S1301>/Limiter' */
        /* Switch: '<S1333>/Switch1' incorporates:
         *  Constant: '<S1323>/Calib'
         *  RelationalOperator: '<S1333>/Relational Operator'
         */
        if (KeESSR_n_SpnUpBmpStrtEngRunDeltaSpd < rtb_Summation_fa)
        {
            /* Switch: '<S1333>/Switch1' */
            rtb_Summation_fa = KeESSR_n_SpnUpBmpStrtEngRunDeltaSpd;
        }

        /* End of Switch: '<S1333>/Switch1' */

        /* Switch: '<S1333>/Switch' incorporates:
         *  Constant: '<S1299>/Constant Value6'
         *  RelationalOperator: '<S1333>/Relational Operator1'
         */
        if (rtb_Summation_fa > 0.0F)
        {
            /* Switch: '<S1301>/Switch1' incorporates:
             *  Switch: '<S1301>/Switch2'
             */
            VeESSR_n_SpnUpBmpStrtFailEngRunAccm = rtb_Summation_fa;
        }
        else
        {
            /* Switch: '<S1301>/Switch1' incorporates:
             *  Switch: '<S1301>/Switch2'
             */
            VeESSR_n_SpnUpBmpStrtFailEngRunAccm = 0.0F;
        }

        /* End of Switch: '<S1333>/Switch' */
        /* End of Outputs for SubSystem: '<S1301>/Limiter' */
    }

    /* End of Switch: '<S1301>/Switch2' */
    /* End of Outputs for SubSystem: '<S1299>/Accumulator Reset Enabled Limited' */

    /* RelationalOperator: '<S1299>/Comparison1' incorporates:
     *  Constant: '<S1323>/Calib'
     */
    VeESSR_b_SpnUpBmpStrtFailEngRunAccmTrg =
        (VeESSR_n_SpnUpBmpStrtFailEngRunAccm >=
         KeESSR_n_SpnUpBmpStrtEngRunDeltaSpd);

    /* Logic: '<S1299>/AND2' */
    rtb_LeESSR_b_SpnUpBmpStrtFailEn = ((VeESSR_b_SpnUpBmpStrtFailEngRunAccmTrg) &&
        rtu_EngCombustionCmnd);

    /* Outputs for Atomic SubSystem: '<S1299>/Stop Watch Reset Enabled' */
    /* Switch: '<S1331>/Switch1' incorporates:
     *  Constant: '<S1313>/Calib'
     *  DataStoreRead: '<S1299>/Dsr_STMTmr3'
     *  DataStoreWrite: '<S1299>/TCMOpenDiscCltch'
     *  Logic: '<S1299>/Logical Operator28'
     *  Logic: '<S1299>/Logical Operator31'
     *  RelationalOperator: '<S1299>/Greater  Than12'
     *  Switch: '<S1331>/Switch2'
     */
    if ((!VeESSR_b_TCMOpenDisconnctCltch_DS) || (VeESSR_t_STMTmr_DS <
            HeESSR_t_MedTEB_dT))
    {
        /* Switch: '<S1331>/Switch1' incorporates:
         *  Constant: '<S1331>/Constant Value2'
         */
        VeESSR_t_SpnUpBmpStrtFailTmr = 0.0F;
    }
    else
    {
        if (VeESSR_b_TCMOpenDisconnctCltch_DS)
        {
            /* Switch: '<S1331>/Switch1' incorporates:
             *  Sum: '<S1331>/Subtraction'
             *  Switch: '<S1331>/Switch2'
             *  UnitDelay: '<S1331>/Unit Delay'
             */
            VeESSR_t_SpnUpBmpStrtFailTmr = HeESSR_t_MedTEB_dT +
                VeESSR_t_SpnUpBmpStrtFailTmr;
        }
    }

    /* End of Switch: '<S1331>/Switch1' */
    /* End of Outputs for SubSystem: '<S1299>/Stop Watch Reset Enabled' */

    /* Logic: '<S1299>/Logical Operator6' incorporates:
     *  Constant: '<S1326>/Calib'
     *  DataStoreWrite: '<S1299>/TCMOpenDiscCltch'
     *  RelationalOperator: '<S1299>/Greater  Than13'
     */
    VeESSR_b_SpnUpBmpStrtFailFinTmrExpd = ((VeESSR_b_TCMOpenDisconnctCltch_DS) &&
        (VeESSR_t_SpnUpBmpStrtFailTmr >= KeESSR_t_SpnUpBmpStrtFailTmr));

    /* Logic: '<S1299>/Logical Operator4' incorporates:
     *  Constant: '<S1319>/Calib'
     *  Logic: '<S1299>/Logical Operator11'
     *  Logic: '<S1299>/Logical Operator14'
     *  Logic: '<S1299>/Logical Operator17'
     *  Logic: '<S1299>/Logical Operator18'
     *  Logic: '<S1299>/Logical Operator20'
     *  Logic: '<S1299>/Logical Operator8'
     */
    VeESSR_b_SpnUpBmpStrtFailCnfrmd = (((((VeESSR_b_SpnUpBmpStrtFailRaw) &&
        (!KeESSR_b_SpnUpBmpStrtFailEV_Enbl)) || ((VeESSR_b_SpnUpBmpStrtFailPend)
        && (!rtu_PSA_Actv))) || (VeESSR_b_SpnUpBmpStrtFailCoastDownDtct)) || (((
        !VeESSR_b_SpnUpBmpStrtFailCoastDownDtct) &&
        (!rtb_LeESSR_b_SpnUpBmpStrtFailEn)) &&
        (VeESSR_b_SpnUpBmpStrtFailFinTmrExpd)));

    /* Logic: '<S1299>/Logical Operator13' incorporates:
     *  Constant: '<S1319>/Calib'
     *  DataStoreWrite: '<S1299>/BmpStrtFailed'
     */
    VeESSR_b_BumpStrtFailed_DS = ((KeESSR_b_SpnUpBmpStrtFailEV_Enbl) &&
        (VeESSR_b_SpnUpBmpStrtFailCnfrmd));

    /* Switch: '<S1299>/Switch' incorporates:
     *  S-Function (sfix_bitop): '<S1303>/FixPt Bitwise Operator1'
     */
    if (VeESSR_b_SpnUpBmpStrtFailCnfrmd)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 67108864U;
    }

    /* End of Switch: '<S1299>/Switch' */

    /* Outputs for Atomic SubSystem: '<S1309>/Protected Division' */
    /* Switch: '<S1342>/Switch1' incorporates:
     *  Constant: '<S1336>/Calib'
     *  Constant: '<S1342>/Constant Value'
     *  Constant: '<S1342>/Constant Value1'
     *  Constant: '<S1342>/Constant Value2'
     *  Constant: '<S1342>/Constant Value3'
     *  DataStoreRead: '<S1309>/Dsr_STMTmr2'
     *  Logic: '<S1342>/AND'
     *  RelationalOperator: '<S1342>/Greater Than or Equal '
     *  RelationalOperator: '<S1342>/Greater Than or Equal 1'
     *  RelationalOperator: '<S1342>/Not Equal'
     *  RelationalOperator: '<S1342>/Not Equal1'
     *  Switch: '<S1342>/Switch2'
     *  Switch: '<S1342>/Switch3'
     */
    if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT != 0.0F))
    {
        /* Switch: '<S1342>/Switch1' incorporates:
         *  Product: '<S1342>/Division'
         */
        rtb_Summation_fa = VeESSR_t_STMTmr_DS / HeESSR_t_MedTEB_dT;
    }
    else if (VeESSR_t_STMTmr_DS > 0.0F)
    {
        /* Switch: '<S1342>/Switch2' incorporates:
         *  Constant: '<S1342>/MAXFLOAT'
         *  Switch: '<S1342>/Switch1'
         */
        rtb_Summation_fa = 3.402823466E+38F;
    }
    else if (VeESSR_t_STMTmr_DS < 0.0F)
    {
        /* Switch: '<S1342>/Switch3' incorporates:
         *  Constant: '<S1342>/MINFLOAT'
         *  Switch: '<S1342>/Switch1'
         *  Switch: '<S1342>/Switch2'
         */
        rtb_Summation_fa = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1342>/Switch1' incorporates:
         *  Constant: '<S1342>/Constant Value4'
         *  Switch: '<S1342>/Switch2'
         *  Switch: '<S1342>/Switch3'
         */
        rtb_Summation_fa = 0.0F;
    }

    /* End of Switch: '<S1342>/Switch1' */
    /* End of Outputs for SubSystem: '<S1309>/Protected Division' */

    /* Sum: '<S1309>/Summation2' incorporates:
     *  Constant: '<S1309>/Constant Value'
     *  Gain: '<S1309>/Gain'
     *  Lookup_n-D: '<S1339>/Vector'
     *  Lookup_n-D: '<S1341>/Vector'
     *  MinMax: '<S1309>/MinMax'
     *  Product: '<S1309>/Product1'
     *  Switch: '<S1342>/Switch1'
     */
    VeESSR_M_SpinUpEngFricEngStrtTorq = (fmaxf(-rtu_VeESSR_M_EngTrqAct_Lmtd,
        0.0F) * look1_iflf_binlcapw(rtb_Summation_fa, ((const float32 *)
        &(KxESSR_K_SpinUpEngStrtTorqGain[0])), ((const float32 *)
        &(KtESSR_K_SpinUpEngStrtTorqGain[0])), 4U)) + look1_iflf_binlcapw
        (rtb_Summation_fa, ((const float32 *)&(KxESSR_M_SpinUpEngStrtTorqOffset
           [0])), ((const float32 *)&(KtESSR_M_SpinUpEngStrtTorqOffset[0])), 4U);

    /* Abs: '<S1309>/Abs' */
    VeESSR_M_SpinUpEngPulseEngStrtTorq = fabsf(rtu_VeEPCR_M_EngPulseTorqEst);

    /* Lookup_n-D: '<S1340>/Vector' */
    VeESSR_M_SpinUpECTEngStrtTorq = look1_iflf_binlcapw
        (rtu_VeENGR_T_EngCoolantTemp, ((const float32 *)
          &(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((const float32 *)
          &(KtESSR_M_ECTAddtlEngStrtTorq[0])), 6U);

    /* Sum: '<S1309>/Summation1' */
    VeESSR_M_SpinUpEngStrtTorqRaw = (VeESSR_M_SpinUpEngFricEngStrtTorq +
        VeESSR_M_SpinUpEngPulseEngStrtTorq) + VeESSR_M_SpinUpECTEngStrtTorq;

    /* Outputs for Atomic SubSystem: '<S1309>/GradientLimiter' */
    /* Sum: '<S1335>/Sum2' incorporates:
     *  UnitDelay: '<S1335>/Unit Delay'
     */
    rtb_Sum2_ob = VeESSR_M_SpinUpEngStrtTorqRaw - VeESSR_M_SpinUpEngStrtTorqLmtd;

    /* Outputs for Atomic SubSystem: '<S1335>/Limiter' */
    /* Switch: '<S1343>/Switch1' incorporates:
     *  Constant: '<S1338>/Calib'
     *  RelationalOperator: '<S1343>/Relational Operator'
     */
    if (KeESSR_dM_SpinUpEngStrtTorqLU < rtb_Sum2_ob)
    {
        /* Lookup_n-D: '<S1327>/Vector' */
        rtb_Sum2_ob = KeESSR_dM_SpinUpEngStrtTorqLU;
    }

    /* End of Switch: '<S1343>/Switch1' */

    /* Switch: '<S1343>/Switch' incorporates:
     *  Constant: '<S1337>/Calib'
     *  RelationalOperator: '<S1343>/Relational Operator1'
     */
    if (rtb_Sum2_ob <= KeESSR_dM_SpinUpEngStrtTorqLD)
    {
        rtb_Sum2_ob = KeESSR_dM_SpinUpEngStrtTorqLD;
    }

    /* End of Switch: '<S1343>/Switch' */
    /* End of Outputs for SubSystem: '<S1335>/Limiter' */

    /* Sum: '<S1335>/Sum3' incorporates:
     *  UnitDelay: '<S1335>/Unit Delay'
     */
    VeESSR_M_SpinUpEngStrtTorqLmtd = rtb_Sum2_ob +
        VeESSR_M_SpinUpEngStrtTorqLmtd;

    /* End of Outputs for SubSystem: '<S1309>/GradientLimiter' */

    /* DataStoreWrite: '<S1299>/Data Store Write2' */
    VeESSR_M_EngStrtTorq_DS = VeESSR_M_SpinUpEngStrtTorqLmtd;

    /* Outputs for Atomic SubSystem: '<S1299>/Protected Division' */
    /* Switch: '<S1330>/Switch1' incorporates:
     *  Constant: '<S1313>/Calib'
     *  Constant: '<S1330>/Constant Value'
     *  Constant: '<S1330>/Constant Value1'
     *  Constant: '<S1330>/Constant Value2'
     *  Constant: '<S1330>/Constant Value3'
     *  DataStoreRead: '<S1299>/Dsr_STMTmr2'
     *  Logic: '<S1330>/AND'
     *  RelationalOperator: '<S1330>/Greater Than or Equal '
     *  RelationalOperator: '<S1330>/Greater Than or Equal 1'
     *  RelationalOperator: '<S1330>/Not Equal'
     *  RelationalOperator: '<S1330>/Not Equal1'
     *  Switch: '<S1330>/Switch2'
     *  Switch: '<S1330>/Switch3'
     */
    if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT != 0.0F))
    {
        /* Switch: '<S1330>/Switch1' incorporates:
         *  Product: '<S1330>/Division'
         */
        rtb_Summation_fa = VeESSR_t_STMTmr_DS / HeESSR_t_MedTEB_dT;
    }
    else if (VeESSR_t_STMTmr_DS > 0.0F)
    {
        /* Switch: '<S1330>/Switch2' incorporates:
         *  Constant: '<S1330>/MAXFLOAT'
         *  Switch: '<S1330>/Switch1'
         */
        rtb_Summation_fa = 3.402823466E+38F;
    }
    else if (VeESSR_t_STMTmr_DS < 0.0F)
    {
        /* Switch: '<S1330>/Switch3' incorporates:
         *  Constant: '<S1330>/MINFLOAT'
         *  Switch: '<S1330>/Switch1'
         *  Switch: '<S1330>/Switch2'
         */
        rtb_Summation_fa = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1330>/Switch1' incorporates:
         *  Constant: '<S1330>/Constant Value4'
         *  Switch: '<S1330>/Switch2'
         *  Switch: '<S1330>/Switch3'
         */
        rtb_Summation_fa = 0.0F;
    }

    /* End of Switch: '<S1330>/Switch1' */
    /* End of Outputs for SubSystem: '<S1299>/Protected Division' */

    /* Sum: '<S1299>/Summation2' incorporates:
     *  DataStoreWrite: '<S1299>/Dsw_EngTrqReqImmed'
     *  Lookup_n-D: '<S1327>/Vector'
     *  Lookup_n-D: '<S1328>/Vector'
     *  Sum: '<S1299>/Summation1'
     *  Switch: '<S1330>/Switch1'
     */
    VeESSR_M_EngTrqReqImmed_DS = look2_iflf_binlcapw(rtu_VeENGR_T_EngCoolantTemp,
        rtu_VeESSR_n_OptInputSpd - rtu_VeESSR_n_TransInSpdFlt, ((const float32 *)
        &(KxESSR_M_EngTrqReqBumpStrtErrBsd[0])), ((const float32 *)
        &(KyESSR_M_EngTrqReqBumpStrtErrBsd[0])), ((const float32 *)
        &(KtESSR_M_EngTrqReqBumpStrtErrBsd[0])),
        ESSR_ac_ConstP.Vector_maxIndex_a, 3U) + look2_iflf_binlcapw
        (rtu_VeESSR_n_TransInSpdFlt, rtb_Summation_fa, ((const float32 *)
          &(KxESSR_M_EngTrqReqBumpStrtTmrBsd[0])), ((const float32 *)
          &(KyESSR_M_EngTrqReqBumpStrtTmrBsd[0])), ((const float32 *)
          &(KtESSR_M_EngTrqReqBumpStrtTmrBsd[0])),
         ESSR_ac_ConstP.Vector_maxIndex_n, 4U);

    /* DataStoreWrite: '<S1299>/Dsw_EngTrqReqPrdtd1' incorporates:
     *  DataStoreWrite: '<S1299>/Dsw_EngTrqReqImmed'
     */
    VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_EngTrqReqImmed_DS;

    /* Switch: '<S1299>/Switch2' incorporates:
     *  Constant: '<S1320>/Calib'
     *  DataStoreWrite: '<S1299>/Dsw_InputSpeedProfile'
     */
    if (KeESSR_b_TgtM2SpdSpinupBumpStrt)
    {
        VeESSR_n_InputSpeedProfile_DS = rtu_VeOHSR_n_InputSpeedDsrdM2;
    }
    else
    {
        VeESSR_n_InputSpeedProfile_DS = rtu_VeESSR_n_TransInSpdFlt;
    }

    /* End of Switch: '<S1299>/Switch2' */

    /* Gain: '<S1310>/Gain' */
    rtb_Summation_fa = 1000.0F * rtu_VeESMR_P_BatEstdVoltMaxLim;

    /* Outputs for Atomic SubSystem: '<S1310>/Protected Division' */
    /* Switch: '<S1347>/Switch1' incorporates:
     *  Constant: '<S1347>/Constant Value'
     *  Constant: '<S1347>/Constant Value1'
     *  Constant: '<S1347>/Constant Value2'
     *  Constant: '<S1347>/Constant Value3'
     *  DataStoreRead: '<S1310>/Dsr_STMTmr3'
     *  Logic: '<S1347>/AND'
     *  RelationalOperator: '<S1347>/Greater Than or Equal '
     *  RelationalOperator: '<S1347>/Greater Than or Equal 1'
     *  RelationalOperator: '<S1347>/Not Equal'
     *  RelationalOperator: '<S1347>/Not Equal1'
     *  Switch: '<S1347>/Switch2'
     *  Switch: '<S1347>/Switch3'
     */
    if ((rtb_Summation_fa != 0.0F) && (VeESSR_M_EngStrtTorq_DS != 0.0F))
    {
        /* Switch: '<S1347>/Switch1' incorporates:
         *  Product: '<S1347>/Division'
         */
        rtb_Summation_fa /= VeESSR_M_EngStrtTorq_DS;
    }
    else if (rtb_Summation_fa > 0.0F)
    {
        /* Switch: '<S1347>/Switch2' incorporates:
         *  Constant: '<S1347>/MAXFLOAT'
         *  Switch: '<S1347>/Switch1'
         */
        rtb_Summation_fa = 3.402823466E+38F;
    }
    else if (rtb_Summation_fa < 0.0F)
    {
        /* Switch: '<S1347>/Switch3' incorporates:
         *  Constant: '<S1347>/MINFLOAT'
         *  Switch: '<S1347>/Switch1'
         *  Switch: '<S1347>/Switch2'
         */
        rtb_Summation_fa = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1347>/Switch1' incorporates:
         *  Constant: '<S1347>/Constant Value4'
         *  Switch: '<S1347>/Switch2'
         *  Switch: '<S1347>/Switch3'
         */
        rtb_Summation_fa = 0.0F;
    }

    /* End of Switch: '<S1347>/Switch1' */
    /* End of Outputs for SubSystem: '<S1310>/Protected Division' */

    /* Gain: '<S1348>/Gain' */
    VeESSR_n_NbTgtBattPwr = 94.2477798F * rtb_Summation_fa;

    /* MinMax: '<S1310>/MinMax' */
    rtb_Sum2_ob = fminf(VeESSR_n_NbTgtBattPwr, rtu_VeTISR_n_TransMinInputSpd);

    /* MinMax: '<S1310>/MinMax1' incorporates:
     *  Constant: '<S1344>/Calib'
     *  Constant: '<S1345>/Calib'
     *  Sum: '<S1310>/Summation3'
     */
    rtb_Summation_fa = fmaxf(KeESSR_n_MinNbTgt, rtu_VeESSR_n_TransInSpdFlt +
        KeESSR_n_NbTgtOffset);

    /* Outputs for Atomic SubSystem: '<S1310>/Limiter' */
    /* Switch: '<S1346>/Switch1' incorporates:
     *  RelationalOperator: '<S1346>/Relational Operator'
     */
    if (rtu_VeOHSR_n_InputSpeedDsrdM2 < rtb_Summation_fa)
    {
        /* Switch: '<S1346>/Switch1' */
        rtb_Summation_fa = rtu_VeOHSR_n_InputSpeedDsrdM2;
    }

    /* End of Switch: '<S1346>/Switch1' */

    /* Switch: '<S1346>/Switch' incorporates:
     *  DataStoreWrite: '<S1299>/Dsw_InputSpeedProfile1'
     *  RelationalOperator: '<S1346>/Relational Operator1'
     */
    if (rtb_Summation_fa > rtb_Sum2_ob)
    {
        VeESSR_n_NbTgt_DS = rtb_Summation_fa;
    }
    else
    {
        VeESSR_n_NbTgt_DS = rtb_Sum2_ob;
    }

    /* End of Switch: '<S1346>/Switch' */
    /* End of Outputs for SubSystem: '<S1310>/Limiter' */

    /* Logic: '<S1299>/Logical Operator2' incorporates:
     *  Constant: '<S1311>/Constant'
     *  Constant: '<S1312>/Constant'
     *  RelationalOperator: '<S1299>/Greater  Than2'
     *  RelationalOperator: '<S1299>/Greater  Than3'
     */
    rtb_LogicalOperator2_ei = ((CeHSER_e_UseM2Eqn == ((uint32)
        rtu_VeHSER_e_RngEqnSel)) || (((uint32)rtu_VeHSER_e_RngEqnSel) ==
        CeHSER_e_UseG2Eqn));

    /* Switch: '<S1299>/Switch1' incorporates:
     *  Constant: '<S1299>/Constant Value'
     *  DataStoreRead: '<S1299>/Data Store Read1'
     *  DataStoreWrite: '<S1299>/Dsw_InputTorqEst'
     *  Sum: '<S1299>/Sum1'
     */
    if (rtb_LogicalOperator2_ei)
    {
        /* Switch: '<S1299>/Switch3' incorporates:
         *  Constant: '<S1299>/Constant Value8'
         *  Constant: '<S1318>/Calib'
         */
        if (KeESSR_b_EnblTo4TiEstBmpStrt)
        {
            rtb_Summation_fa = rtu_VeATRR_M_OutputTorqReqImmed;
        }
        else
        {
            rtb_Summation_fa = 0.0F;
        }

        /* End of Switch: '<S1299>/Switch3' */
        VeESSR_M_EngTorqEst_DS = rtb_Summation_fa - VeESSR_M_MtrBTorqCmndPrev_DS;
    }
    else
    {
        VeESSR_M_EngTorqEst_DS = 0.0F;
    }

    /* End of Switch: '<S1299>/Switch1' */

    /* DataStoreWrite: '<S1299>/Dsw_STMTmr' incorporates:
     *  Constant: '<S1313>/Calib'
     *  DataStoreRead: '<S1299>/Dsr_STMTmr'
     *  Sum: '<S1299>/Summation'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Switch: '<S1315>/Switch1' incorporates:
     *  Switch: '<S1315>/Switch2'
     */
    if (rtb_LeESSR_b_SpnUpBmpStrtFailEn)
    {
        /* Switch: '<S1315>/Switch1' incorporates:
         *  Constant: '<S1308>/Constant'
         */
        VeESSR_e_SpnUpBmpStrtFailArbTrg = CeESSR_e_EngSpdTgtAch;
    }
    else if (VeESSR_b_SpnUpBmpStrtFailCoastDownDtct)
    {
        /* Switch: '<S1315>/Switch2' incorporates:
         *  Constant: '<S1306>/Constant'
         *  Switch: '<S1315>/Switch1'
         */
        VeESSR_e_SpnUpBmpStrtFailArbTrg = CeESSR_e_CoastDown;
    }
    else
    {
        /* Switch: '<S1315>/Switch1' incorporates:
         *  Constant: '<S1307>/Constant'
         *  Switch: '<S1315>/Switch2'
         */
        VeESSR_e_SpnUpBmpStrtFailArbTrg = CeESSR_e_EngFail;
    }

    /* End of Switch: '<S1315>/Switch1' */

    /* Switch: '<S1314>/Switch1' incorporates:
     *  Constant: '<S1305>/Constant'
     *  DataStoreWrite: '<S1299>/Dsw_STMTrigger'
     *  Logic: '<S1299>/Logical Operator12'
     *  Logic: '<S1299>/Logical Operator19'
     *  Logic: '<S1299>/Logical Operator3'
     *  Switch: '<S1314>/Switch2'
     */
    if ((!VeESSR_b_SpnUpBmpStrtFailPend) && rtb_LogicalOperator2_ei)
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngSpdTgtAch;
    }
    else
    {
        if ((VeESSR_b_SpnUpBmpStrtFailCnfrmd) || rtb_LeESSR_b_SpnUpBmpStrtFailEn)
        {
            /* Switch: '<S1314>/Switch1' incorporates:
             *  DataStoreWrite: '<S1299>/Dsw_STMTrigger'
             *  Switch: '<S1314>/Switch2'
             *  Switch: '<S1315>/Switch1'
             */
            VeESSR_e_STMTrigger_DS = VeESSR_e_SpnUpBmpStrtFailArbTrg;
        }
    }

    /* End of Switch: '<S1314>/Switch1' */

    /* If: '<S1299>/If1' */
    if (VeESSR_b_SpnUpBmpStrtFailCnfrmd)
    {
        /* Outputs for IfAction SubSystem: '<S1299>/If_KeyCrank_P1C65' incorporates:
         *  ActionPort: '<S1317>/Action Port'
         */
        /* DataStoreWrite: '<S1299>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_KeyCrank_P1C65((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S1299>/If_KeyCrank_P1C65' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1299>/If_KeyCrank_NoFault' incorporates:
         *  ActionPort: '<S1316>/Action Port'
         */
        /* DataStoreWrite: '<S1299>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_KeyCrank_NoFault((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S1299>/If_KeyCrank_NoFault' */
    }

    /* End of If: '<S1299>/If1' */

    /* Switch: '<S1299>/Switch4' incorporates:
     *  Constant: '<S1299>/Constant Value1'
     *  DataStoreRead: '<S1299>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S1299>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S1299>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S1299>/Logical21'
     *  RelationalOperator: '<S1299>/Comparison'
     *  S-Function (sfix_bitop): '<S1299>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S1304>/FixPt Bitwise Operator1'
     */
    if ((VeESSR_b_SpnUpBmpStrtFailCnfrmd) &&
            ((VeESSR_g_StrtStpFailPhaseSelect_DS & 512U) > 0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 512U;
    }

    /* End of Switch: '<S1299>/Switch4' */

    /* DataStoreWrite: '<S1299>/Dsw_InputAcceltnProf1' */
    VeESSR_dn_InputAcceltnProf_DS = rtu_VeESSR_dn_DtrmnNidot;

    /* UnitDelay: '<S1299>/Unit Delay' incorporates:
     *  DataStoreWrite: '<S1299>/Dsw_InputSpeedProfile2'
     */
    VeESSR_M_MtrBTorqCmndPrev_DS = localDW->UnitDelay_DSTATE;

    /* Update for UnitDelay: '<S1299>/Unit Delay' */
    localDW->UnitDelay_DSTATE = rtu_VeHTDR_M_MtrB_TorqCmnd;
}

#endif

/* Output and update for function-call system: '<S556>/AchIdle_BmpStrt_Du' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_AchIdle_BmpStrt_Du(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_OptEngTrqReq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeENGR_T_EngCoolantTemp, VAR(float32, AUTOMATIC)
    rtu_VeMTQR_M_MtrA_MaxTorq, VAR(float32, AUTOMATIC) rtu_VeMTQR_M_MtrA_MinTorq,
    VAR(float32, AUTOMATIC) rtu_VeOHSR_n_InputSpeedDsrdM2, VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_OptEngTrqReqPred, VAR(float32, AUTOMATIC)
    rtu_VeESMR_P_BatEstdVoltMaxLim, VAR(float32, AUTOMATIC)
    rtu_VeTISR_n_TransMinInputSpd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_TransInSpdFlt, VAR(float32, AUTOMATIC) rtu_VeMSPR_n_MtrB_Spd,
    VAR(float32, AUTOMATIC) rtu_VeETQR_M_EngCapacityMinOff, VAR
    (TeTRGR_e_TransRangeState, AUTOMATIC) rtu_VeTRGR_e_VldtdTransRngSt, VAR
    (float32, AUTOMATIC) rtu_VeATRR_M_OutputTorqReqImmed, VAR(float32, AUTOMATIC)
    rtu_VeOITR_M_InputTorqMaxTact, P2VAR(B_AchIdle_BmpStrt_Du_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localB, P2VAR(DW_AchIdle_BmpStrt_Du_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localDW)
{
    float32 rtb_Abs_cc;
    float32 rtb_Gain_d;
    float32 rtb_Multiplication_jm;
    float32 rtb_Sum3_he_tmp;
    float32 rtb_Sum3_hz;
    float32 rtb_Switch1_a0h;
    float32 rtb_Switch1_fk;
    float32 rtb_Switch1_lpi;
    float32 rtb_Switch2_h2;
    float32 rtb_Vector_bo;
    uint16 rtb_Switch1_om;
    boolean rtb_Equal2_l5;
    boolean rtb_Switch1_ks;
    boolean rtb_Switch1_nt;

    /* DataStoreWrite: '<S838>/Dsw_EngTrqReqImmed' incorporates:
     *  Constant: '<S857>/Calib'
     *  Constant: '<S862>/Calib'
     *  DataStoreRead: '<S838>/Dsr_EngTrqReqPrdtd1'
     *  MinMax: '<S838>/Maximum1'
     *  Product: '<S843>/Multiplication'
     *  Sum: '<S843>/Subtraction'
     *  Sum: '<S843>/Subtraction1'
     */
    VeESSR_M_EngTrqReqImmed_DS = ((fmaxf(rtu_VeESSR_M_OptEngTrqReq,
        KeESSR_M_MinStartDetectTorq) - VeESSR_M_EngTrqReqImmed_DS) *
        KeESSR_K_AchIdleBumpStrtETRQEngCmdFlt) + VeESSR_M_EngTrqReqImmed_DS;

    /* DataStoreWrite: '<S838>/Dsw_EngTrqReqPrdtd1' incorporates:
     *  Constant: '<S857>/Calib'
     *  Constant: '<S862>/Calib'
     *  DataStoreRead: '<S838>/Dsr_EngTrqReqPrdtd3'
     *  MinMax: '<S838>/Maximum2'
     *  Product: '<S842>/Multiplication'
     *  Sum: '<S842>/Subtraction'
     *  Sum: '<S842>/Subtraction1'
     */
    VeESSR_M_EngTrqReqPrdtd_DS = ((fmaxf(rtu_VeESSR_M_OptEngTrqReqPred,
        KeESSR_M_MinStartDetectTorq) - VeESSR_M_EngTrqReqPrdtd_DS) *
        KeESSR_K_AchIdleBumpStrtETRQEngCmdFlt) + VeESSR_M_EngTrqReqPrdtd_DS;

    /* Gain: '<S870>/Gain' */
    rtb_Gain_d = 1000.0F * rtu_VeESMR_P_BatEstdVoltMaxLim;

    /* Outputs for Atomic SubSystem: '<S870>/Protected Division' */
    /* Switch: '<S896>/Switch1' incorporates:
     *  Constant: '<S896>/Constant Value'
     *  Constant: '<S896>/Constant Value1'
     *  Constant: '<S896>/Constant Value2'
     *  Constant: '<S896>/Constant Value3'
     *  DataStoreRead: '<S870>/Dsr_STMTmr3'
     *  Logic: '<S896>/AND'
     *  RelationalOperator: '<S896>/Greater Than or Equal '
     *  RelationalOperator: '<S896>/Greater Than or Equal 1'
     *  RelationalOperator: '<S896>/Not Equal'
     *  RelationalOperator: '<S896>/Not Equal1'
     *  Switch: '<S896>/Switch2'
     *  Switch: '<S896>/Switch3'
     */
    if ((rtb_Gain_d != 0.0F) && (VeESSR_M_EngStrtTorq_DS != 0.0F))
    {
        /* Switch: '<S896>/Switch1' incorporates:
         *  Product: '<S896>/Division'
         */
        rtb_Gain_d /= VeESSR_M_EngStrtTorq_DS;
    }
    else if (rtb_Gain_d > 0.0F)
    {
        /* Switch: '<S896>/Switch2' incorporates:
         *  Constant: '<S896>/MAXFLOAT'
         *  Switch: '<S896>/Switch1'
         */
        rtb_Gain_d = 3.402823466E+38F;
    }
    else if (rtb_Gain_d < 0.0F)
    {
        /* Switch: '<S896>/Switch3' incorporates:
         *  Constant: '<S896>/MINFLOAT'
         *  Switch: '<S896>/Switch1'
         *  Switch: '<S896>/Switch2'
         */
        rtb_Gain_d = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S896>/Switch1' incorporates:
         *  Constant: '<S896>/Constant Value4'
         *  Switch: '<S896>/Switch2'
         *  Switch: '<S896>/Switch3'
         */
        rtb_Gain_d = 0.0F;
    }

    /* End of Switch: '<S896>/Switch1' */
    /* End of Outputs for SubSystem: '<S870>/Protected Division' */

    /* Gain: '<S899>/Gain' */
    VeESSR_n_NbTgtBattPwrAchIdle = 94.2477798F * rtb_Gain_d;

    /* MinMax: '<S870>/MinMax1' incorporates:
     *  Constant: '<S893>/Calib'
     *  MinMax: '<S870>/MinMax'
     */
    VeESSR_n_EngMinTgtAchIdle = fmaxf(KeESSR_n_MinNbTgt, fminf
        (VeESSR_n_NbTgtBattPwrAchIdle, rtu_VeTISR_n_TransMinInputSpd));

    /* Sum: '<S838>/Sum2' incorporates:
     *  Sum: '<S870>/Sum1'
     */
    rtb_Abs_cc = rtu_VeESSR_n_TransInSpdFlt - VeESSR_n_EngMinTgtAchIdle;

    /* Sum: '<S838>/Sum3' incorporates:
     *  Sum: '<S845>/Sum2'
     */
    rtb_Sum3_he_tmp = rtu_VeOHSR_n_InputSpeedDsrdM2 - VeESSR_n_EngMinTgtAchIdle;

    /* Outputs for Atomic SubSystem: '<S838>/Protected Division' */
    /* Switch: '<S871>/Switch1' incorporates:
     *  Constant: '<S871>/Constant Value'
     *  Constant: '<S871>/Constant Value1'
     *  Constant: '<S871>/Constant Value2'
     *  Constant: '<S871>/Constant Value3'
     *  Logic: '<S871>/AND'
     *  RelationalOperator: '<S871>/Greater Than or Equal '
     *  RelationalOperator: '<S871>/Greater Than or Equal 1'
     *  RelationalOperator: '<S871>/Not Equal'
     *  RelationalOperator: '<S871>/Not Equal1'
     *  Sum: '<S838>/Sum2'
     *  Sum: '<S838>/Sum3'
     *  Switch: '<S871>/Switch2'
     *  Switch: '<S871>/Switch3'
     */
    if ((rtb_Abs_cc != 0.0F) && (rtb_Sum3_he_tmp != 0.0F))
    {
        /* Switch: '<S871>/Switch1' incorporates:
         *  Product: '<S871>/Division'
         */
        rtb_Gain_d = rtb_Abs_cc / rtb_Sum3_he_tmp;
    }
    else if (rtb_Abs_cc > 0.0F)
    {
        /* Switch: '<S871>/Switch2' incorporates:
         *  Constant: '<S871>/MAXFLOAT'
         *  Switch: '<S871>/Switch1'
         */
        rtb_Gain_d = 3.402823466E+38F;
    }
    else if (rtb_Abs_cc < 0.0F)
    {
        /* Switch: '<S871>/Switch3' incorporates:
         *  Constant: '<S871>/MINFLOAT'
         *  Switch: '<S871>/Switch1'
         *  Switch: '<S871>/Switch2'
         */
        rtb_Gain_d = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S871>/Switch1' incorporates:
         *  Constant: '<S871>/Constant Value4'
         *  Switch: '<S871>/Switch2'
         *  Switch: '<S871>/Switch3'
         */
        rtb_Gain_d = 0.0F;
    }

    /* End of Switch: '<S871>/Switch1' */
    /* End of Outputs for SubSystem: '<S838>/Protected Division' */

    /* Outputs for Atomic SubSystem: '<S838>/Limiter' */
    /* Switch: '<S868>/Switch1' incorporates:
     *  Constant: '<S838>/Constant Value1'
     *  RelationalOperator: '<S868>/Relational Operator'
     */
    if (1.0F < rtb_Gain_d)
    {
        /* Lookup_n-D: '<S867>/Vector' */
        rtb_Vector_bo = 1.0F;
    }
    else
    {
        /* Lookup_n-D: '<S867>/Vector' */
        rtb_Vector_bo = rtb_Gain_d;
    }

    /* End of Switch: '<S868>/Switch1' */

    /* Switch: '<S868>/Switch' incorporates:
     *  Constant: '<S838>/Constant Value'
     *  RelationalOperator: '<S868>/Relational Operator1'
     */
    if (rtb_Vector_bo > 0.0F)
    {
        /* Switch: '<S868>/Switch' */
        VeESSR_K_BlendRatio = rtb_Vector_bo;
    }
    else
    {
        /* Switch: '<S868>/Switch' */
        VeESSR_K_BlendRatio = 0.0F;
    }

    /* End of Switch: '<S868>/Switch' */
    /* End of Outputs for SubSystem: '<S838>/Limiter' */

    /* Outputs for Atomic SubSystem: '<S849>/Hysteresis' */
    /* Switch: '<S886>/Switch1' incorporates:
     *  Constant: '<S888>/Calib'
     *  RelationalOperator: '<S886>/Greater  Than'
     */
    if (VeESSR_K_BlendRatio > KeESSR_K_MtrAEnblBlendThres)
    {
        /* Switch: '<S886>/Switch1' incorporates:
         *  Constant: '<S886>/Constant Value'
         */
        rtb_Switch1_nt = true;
    }
    else
    {
        /* Switch: '<S886>/Switch1' incorporates:
         *  Constant: '<S887>/Calib'
         *  RelationalOperator: '<S886>/Greater  Than1'
         *  Sum: '<S849>/Sum1'
         *  UnitDelay: '<S886>/Unit Delay'
         */
        rtb_Switch1_nt = ((VeESSR_K_BlendRatio >= (KeESSR_K_MtrAEnblBlendThres -
                            KeESSR_K_MtrAEnblBlendHys)) &&
                          (localDW->UnitDelay_DSTATE_f));
    }

    /* End of Switch: '<S886>/Switch1' */

    /* Update for UnitDelay: '<S886>/Unit Delay' */
    localDW->UnitDelay_DSTATE_f = rtb_Switch1_nt;

    /* End of Outputs for SubSystem: '<S849>/Hysteresis' */

    /* RelationalOperator: '<S838>/Equal2' incorporates:
     *  Constant: '<S852>/Calib'
     *  DataStoreRead: '<S838>/Dsr_STMTmr'
     */
    rtb_Equal2_l5 = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

    /* Logic: '<S849>/Logical1' incorporates:
     *  Logic: '<S849>/Logical2'
     */
    VeESSR_b_MtrAZeroTrq = ((!rtb_Switch1_nt) || rtb_Equal2_l5);

    /* Outputs for Atomic SubSystem: '<S875>/EdgeFalling' */
    /* Outputs for Atomic SubSystem: '<S874>/EdgeFalling' */
    /* Logic: '<S903>/OR1' incorporates:
     *  Logic: '<S912>/OR1'
     */
    rtb_Switch1_ks = !VeESSR_b_MtrAZeroTrq;

    /* End of Outputs for SubSystem: '<S875>/EdgeFalling' */

    /* Logic: '<S903>/AND' incorporates:
     *  Logic: '<S903>/OR1'
     *  UnitDelay: '<S903>/Unit Delay'
     */
    rtb_Switch1_nt = (rtb_Switch1_ks && (localDW->UnitDelay_DSTATE_n));

    /* Update for UnitDelay: '<S903>/Unit Delay' */
    localDW->UnitDelay_DSTATE_n = VeESSR_b_MtrAZeroTrq;

    /* End of Outputs for SubSystem: '<S874>/EdgeFalling' */

    /* Outputs for Atomic SubSystem: '<S874>/Counter Reset  Enabled ' */
    /* Switch: '<S906>/Switch1' incorporates:
     *  Switch: '<S902>/Switch1'
     */
    if (rtb_Switch1_nt)
    {
        /* Switch: '<S906>/Switch1' incorporates:
         *  UnitDelay: '<S874>/Unit Delay24'
         */
        rtb_Gain_d = localDW->UnitDelay24_DSTATE;

        /* Switch: '<S902>/Switch1' incorporates:
         *  Constant: '<S902>/Constant Value2'
         */
        rtb_Switch1_om = 0U;
    }
    else
    {
        /* Switch: '<S906>/Switch1' incorporates:
         *  UnitDelay: '<S874>/Unit Delay23'
         */
        rtb_Gain_d = localDW->UnitDelay23_DSTATE;

        /* Switch: '<S902>/Switch2' incorporates:
         *  UnitDelay: '<S874>/Unit Delay3'
         */
        if (localDW->UnitDelay3_DSTATE)
        {
            /* Switch: '<S902>/Switch1' incorporates:
             *  Constant: '<S902>/Constant Value1'
             *  Sum: '<S902>/Subtraction'
             *  Switch: '<S902>/Switch2'
             *  UnitDelay: '<S902>/Unit Delay'
             */
            rtb_Switch1_om = (uint16)(((uint32)localDW->UnitDelay_DSTATE_pn) +
                1U);
        }
        else
        {
            /* Switch: '<S902>/Switch1' incorporates:
             *  Switch: '<S902>/Switch2'
             *  UnitDelay: '<S902>/Unit Delay'
             */
            rtb_Switch1_om = localDW->UnitDelay_DSTATE_pn;
        }

        /* End of Switch: '<S902>/Switch2' */
    }

    /* End of Switch: '<S906>/Switch1' */

    /* Update for UnitDelay: '<S902>/Unit Delay' */
    localDW->UnitDelay_DSTATE_pn = rtb_Switch1_om;

    /* End of Outputs for SubSystem: '<S874>/Counter Reset  Enabled ' */

    /* Product: '<S874>/Multiplication' incorporates:
     *  Constant: '<S904>/Calib'
     */
    rtb_Sum3_hz = ((float32)rtb_Switch1_om) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S874>/Protected Division' */
    /* Switch: '<S910>/Switch1' incorporates:
     *  Constant: '<S908>/Calib'
     *  Constant: '<S910>/Constant Value'
     *  Constant: '<S910>/Constant Value1'
     *  Constant: '<S910>/Constant Value2'
     *  Constant: '<S910>/Constant Value3'
     *  Logic: '<S910>/AND'
     *  RelationalOperator: '<S910>/Greater Than or Equal '
     *  RelationalOperator: '<S910>/Greater Than or Equal 1'
     *  RelationalOperator: '<S910>/Not Equal'
     *  RelationalOperator: '<S910>/Not Equal1'
     *  Switch: '<S910>/Switch2'
     *  Switch: '<S910>/Switch3'
     */
    if ((rtb_Sum3_hz != 0.0F) && (KeESSR_t_TrqLmtRampTm != 0.0F))
    {
        /* Switch: '<S910>/Switch1' incorporates:
         *  Product: '<S910>/Division'
         */
        rtb_Switch1_lpi = rtb_Sum3_hz / KeESSR_t_TrqLmtRampTm;
    }
    else if (rtb_Sum3_hz > 0.0F)
    {
        /* Switch: '<S910>/Switch2' incorporates:
         *  Constant: '<S910>/MAXFLOAT'
         *  Switch: '<S910>/Switch1'
         */
        rtb_Switch1_lpi = 3.402823466E+38F;
    }
    else if (rtb_Sum3_hz < 0.0F)
    {
        /* Switch: '<S910>/Switch3' incorporates:
         *  Constant: '<S910>/MINFLOAT'
         *  Switch: '<S910>/Switch1'
         *  Switch: '<S910>/Switch2'
         */
        rtb_Switch1_lpi = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S910>/Switch1' incorporates:
         *  Constant: '<S910>/Constant Value4'
         *  Switch: '<S910>/Switch2'
         *  Switch: '<S910>/Switch3'
         */
        rtb_Switch1_lpi = 0.0F;
    }

    /* End of Switch: '<S910>/Switch1' */
    /* End of Outputs for SubSystem: '<S874>/Protected Division' */

    /* Outputs for Atomic SubSystem: '<S874>/Limiter2' */
    /* Switch: '<S909>/Switch1' incorporates:
     *  Constant: '<S874>/KeHTDR_t_dT2'
     *  RelationalOperator: '<S909>/Relational Operator'
     */
    if (1.0F < rtb_Switch1_lpi)
    {
        /* Lookup_n-D: '<S867>/Vector' */
        rtb_Vector_bo = 1.0F;
    }
    else
    {
        /* Lookup_n-D: '<S867>/Vector' */
        rtb_Vector_bo = rtb_Switch1_lpi;
    }

    /* End of Switch: '<S909>/Switch1' */

    /* Switch: '<S909>/Switch' incorporates:
     *  Constant: '<S874>/KeHTDR_t_dT1'
     *  RelationalOperator: '<S909>/Relational Operator1'
     */
    if (rtb_Vector_bo > 0.0F)
    {
        /* Switch: '<S909>/Switch' */
        rtb_Switch1_lpi = rtb_Vector_bo;
    }
    else
    {
        /* Switch: '<S909>/Switch' */
        rtb_Switch1_lpi = 0.0F;
    }

    /* End of Switch: '<S909>/Switch' */
    /* End of Outputs for SubSystem: '<S874>/Limiter2' */

    /* Switch: '<S874>/Switch2' incorporates:
     *  Constant: '<S874>/Constant Value'
     */
    if (VeESSR_b_MtrAZeroTrq)
    {
        rtb_Vector_bo = 0.0F;
    }
    else
    {
        rtb_Vector_bo = rtu_VeMTQR_M_MtrA_MaxTorq;
    }

    /* End of Switch: '<S874>/Switch2' */

    /* Sum: '<S874>/Summation1' incorporates:
     *  Constant: '<S874>/KeHTDR_t_dT2'
     *  Product: '<S874>/Multiplication13'
     *  Product: '<S874>/Multiplication19'
     *  Sum: '<S874>/Subtraction2'
     */
    rtb_Switch1_lpi = ((1.0F - rtb_Switch1_lpi) * rtb_Gain_d) + (rtb_Switch1_lpi
        * rtb_Vector_bo);

    /* Switch: '<S905>/Switch1' incorporates:
     *  Abs: '<S874>/Abs'
     *  Abs: '<S874>/Abs1'
     *  Constant: '<S907>/Calib'
     *  DataStoreWrite: '<S838>/Dsw_DsblNiClsdLoopCntrl1'
     *  RelationalOperator: '<S874>/Comparison1'
     *  UnitDelay: '<S874>/Unit Delay1'
     */
    if (fabsf(localDW->UnitDelay1_DSTATE) >= fabsf(rtu_VeMTQR_M_MtrA_MaxTorq))
    {
        VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;
    }
    else
    {
        VeESSR_M_MtrA_MaxTorq_DS = rtb_Switch1_lpi;
    }

    /* End of Switch: '<S905>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S875>/EdgeFalling' */
    /* Logic: '<S912>/AND' incorporates:
     *  UnitDelay: '<S912>/Unit Delay'
     */
    rtb_Switch1_nt = (rtb_Switch1_ks && (localDW->UnitDelay_DSTATE_e));

    /* Update for UnitDelay: '<S912>/Unit Delay' */
    localDW->UnitDelay_DSTATE_e = VeESSR_b_MtrAZeroTrq;

    /* End of Outputs for SubSystem: '<S875>/EdgeFalling' */

    /* Outputs for Atomic SubSystem: '<S875>/Counter Reset  Enabled ' */
    /* Switch: '<S915>/Switch1' incorporates:
     *  Switch: '<S911>/Switch1'
     */
    if (rtb_Switch1_nt)
    {
        /* Switch: '<S915>/Switch1' incorporates:
         *  UnitDelay: '<S875>/Unit Delay24'
         */
        rtb_Switch1_fk = localDW->UnitDelay24_DSTATE_i;

        /* Switch: '<S911>/Switch1' incorporates:
         *  Constant: '<S911>/Constant Value2'
         */
        rtb_Switch1_om = 0U;
    }
    else
    {
        /* Switch: '<S915>/Switch1' incorporates:
         *  UnitDelay: '<S875>/Unit Delay23'
         */
        rtb_Switch1_fk = localDW->UnitDelay23_DSTATE_d;

        /* Switch: '<S911>/Switch2' incorporates:
         *  UnitDelay: '<S875>/Unit Delay3'
         */
        if (localDW->UnitDelay3_DSTATE_o)
        {
            /* Switch: '<S911>/Switch1' incorporates:
             *  Constant: '<S911>/Constant Value1'
             *  Sum: '<S911>/Subtraction'
             *  Switch: '<S911>/Switch2'
             *  UnitDelay: '<S911>/Unit Delay'
             */
            rtb_Switch1_om = (uint16)(((uint32)localDW->UnitDelay_DSTATE_p) + 1U);
        }
        else
        {
            /* Switch: '<S911>/Switch1' incorporates:
             *  Switch: '<S911>/Switch2'
             *  UnitDelay: '<S911>/Unit Delay'
             */
            rtb_Switch1_om = localDW->UnitDelay_DSTATE_p;
        }

        /* End of Switch: '<S911>/Switch2' */
    }

    /* End of Switch: '<S915>/Switch1' */

    /* Update for UnitDelay: '<S911>/Unit Delay' */
    localDW->UnitDelay_DSTATE_p = rtb_Switch1_om;

    /* End of Outputs for SubSystem: '<S875>/Counter Reset  Enabled ' */

    /* Product: '<S875>/Multiplication' incorporates:
     *  Constant: '<S913>/Calib'
     */
    rtb_Multiplication_jm = ((float32)rtb_Switch1_om) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S875>/Protected Division' */
    /* Switch: '<S919>/Switch1' incorporates:
     *  Constant: '<S917>/Calib'
     *  Constant: '<S919>/Constant Value'
     *  Constant: '<S919>/Constant Value1'
     *  Constant: '<S919>/Constant Value2'
     *  Constant: '<S919>/Constant Value3'
     *  Logic: '<S919>/AND'
     *  RelationalOperator: '<S919>/Greater Than or Equal '
     *  RelationalOperator: '<S919>/Greater Than or Equal 1'
     *  RelationalOperator: '<S919>/Not Equal'
     *  RelationalOperator: '<S919>/Not Equal1'
     *  Switch: '<S919>/Switch2'
     *  Switch: '<S919>/Switch3'
     */
    if ((rtb_Multiplication_jm != 0.0F) && (KeESSR_t_TrqLmtRampTm != 0.0F))
    {
        /* Switch: '<S919>/Switch1' incorporates:
         *  Product: '<S919>/Division'
         */
        rtb_Switch1_a0h = rtb_Multiplication_jm / KeESSR_t_TrqLmtRampTm;
    }
    else if (rtb_Multiplication_jm > 0.0F)
    {
        /* Switch: '<S919>/Switch2' incorporates:
         *  Constant: '<S919>/MAXFLOAT'
         *  Switch: '<S919>/Switch1'
         */
        rtb_Switch1_a0h = 3.402823466E+38F;
    }
    else if (rtb_Multiplication_jm < 0.0F)
    {
        /* Switch: '<S919>/Switch3' incorporates:
         *  Constant: '<S919>/MINFLOAT'
         *  Switch: '<S919>/Switch1'
         *  Switch: '<S919>/Switch2'
         */
        rtb_Switch1_a0h = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S919>/Switch1' incorporates:
         *  Constant: '<S919>/Constant Value4'
         *  Switch: '<S919>/Switch2'
         *  Switch: '<S919>/Switch3'
         */
        rtb_Switch1_a0h = 0.0F;
    }

    /* End of Switch: '<S919>/Switch1' */
    /* End of Outputs for SubSystem: '<S875>/Protected Division' */

    /* Outputs for Atomic SubSystem: '<S875>/Limiter2' */
    /* Switch: '<S918>/Switch1' incorporates:
     *  Constant: '<S875>/KeHTDR_t_dT2'
     *  RelationalOperator: '<S918>/Relational Operator'
     */
    if (1.0F < rtb_Switch1_a0h)
    {
        /* Lookup_n-D: '<S867>/Vector' */
        rtb_Vector_bo = 1.0F;
    }
    else
    {
        /* Lookup_n-D: '<S867>/Vector' */
        rtb_Vector_bo = rtb_Switch1_a0h;
    }

    /* End of Switch: '<S918>/Switch1' */

    /* Switch: '<S918>/Switch' incorporates:
     *  Constant: '<S875>/KeHTDR_t_dT1'
     *  RelationalOperator: '<S918>/Relational Operator1'
     */
    if (rtb_Vector_bo > 0.0F)
    {
        /* Switch: '<S918>/Switch' */
        rtb_Switch1_a0h = rtb_Vector_bo;
    }
    else
    {
        /* Switch: '<S918>/Switch' */
        rtb_Switch1_a0h = 0.0F;
    }

    /* End of Switch: '<S918>/Switch' */
    /* End of Outputs for SubSystem: '<S875>/Limiter2' */

    /* Switch: '<S875>/Switch2' incorporates:
     *  Constant: '<S875>/Constant Value'
     */
    if (VeESSR_b_MtrAZeroTrq)
    {
        rtb_Vector_bo = 0.0F;
    }
    else
    {
        rtb_Vector_bo = rtu_VeMTQR_M_MtrA_MinTorq;
    }

    /* End of Switch: '<S875>/Switch2' */

    /* Sum: '<S875>/Summation1' incorporates:
     *  Constant: '<S875>/KeHTDR_t_dT2'
     *  Product: '<S875>/Multiplication13'
     *  Product: '<S875>/Multiplication19'
     *  Sum: '<S875>/Subtraction2'
     */
    rtb_Switch1_a0h = ((1.0F - rtb_Switch1_a0h) * rtb_Switch1_fk) +
        (rtb_Switch1_a0h * rtb_Vector_bo);

    /* Switch: '<S914>/Switch1' incorporates:
     *  Abs: '<S875>/Abs'
     *  Abs: '<S875>/Abs1'
     *  Constant: '<S916>/Calib'
     *  DataStoreWrite: '<S838>/Dsw_DsblNiClsdLoopCntrl2'
     *  RelationalOperator: '<S875>/Comparison1'
     *  UnitDelay: '<S875>/Unit Delay1'
     */
    if (fabsf(localDW->UnitDelay1_DSTATE_h) >= fabsf(rtu_VeMTQR_M_MtrA_MinTorq))
    {
        VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;
    }
    else
    {
        VeESSR_M_MtrA_MinTorq_DS = rtb_Switch1_a0h;
    }

    /* End of Switch: '<S914>/Switch1' */

    /* DataStoreWrite: '<S838>/Dsw_InputSpeedProfile' */
    VeESSR_n_InputSpeedProfile_DS = rtu_VeOHSR_n_InputSpeedDsrdM2;

    /* DataStoreWrite: '<S838>/Dsw_InputSpeedProfile1' */
    VeESSR_n_NbTgt_DS = rtu_VeOHSR_n_InputSpeedDsrdM2;

    /* Outputs for Atomic SubSystem: '<S838>/Hysteresis1' */
    /* Switch: '<S855>/Switch1' incorporates:
     *  Constant: '<S859>/Calib'
     *  RelationalOperator: '<S855>/Greater  Than'
     */
    if (VeESSR_K_BlendRatio > KeESSR_K_EngTrqBlendThresh)
    {
        /* Switch: '<S855>/Switch1' incorporates:
         *  Constant: '<S855>/Constant Value'
         */
        rtb_Switch1_nt = true;
    }
    else
    {
        /* Switch: '<S855>/Switch1' incorporates:
         *  Constant: '<S858>/Calib'
         *  RelationalOperator: '<S855>/Greater  Than1'
         *  Sum: '<S838>/Sum5'
         *  UnitDelay: '<S855>/Unit Delay'
         */
        rtb_Switch1_nt = ((VeESSR_K_BlendRatio >= (KeESSR_K_EngTrqBlendThresh -
                            KeESSR_K_EngTrqBlendHys)) &&
                          (localDW->UnitDelay_DSTATE_n2));
    }

    /* End of Switch: '<S855>/Switch1' */

    /* Update for UnitDelay: '<S855>/Unit Delay' */
    localDW->UnitDelay_DSTATE_n2 = rtb_Switch1_nt;

    /* End of Outputs for SubSystem: '<S838>/Hysteresis1' */

    /* Outputs for Atomic SubSystem: '<S838>/Hysteresis' */
    /* Switch: '<S854>/Switch1' incorporates:
     *  Constant: '<S861>/Calib'
     *  RelationalOperator: '<S854>/Greater  Than'
     */
    if (VeESSR_K_BlendRatio > KeESSR_K_ToBlendThresh)
    {
        /* Switch: '<S854>/Switch1' incorporates:
         *  Constant: '<S854>/Constant Value'
         */
        rtb_Switch1_ks = true;
    }
    else
    {
        /* Switch: '<S854>/Switch1' incorporates:
         *  Constant: '<S860>/Calib'
         *  RelationalOperator: '<S854>/Greater  Than1'
         *  Sum: '<S838>/Sum4'
         *  UnitDelay: '<S854>/Unit Delay'
         */
        rtb_Switch1_ks = ((VeESSR_K_BlendRatio >= (KeESSR_K_ToBlendThresh -
                            KeESSR_K_ToBlendHys)) &&
                          (localDW->UnitDelay_DSTATE_a));
    }

    /* End of Switch: '<S854>/Switch1' */

    /* Update for UnitDelay: '<S854>/Unit Delay' */
    localDW->UnitDelay_DSTATE_a = rtb_Switch1_ks;

    /* End of Outputs for SubSystem: '<S838>/Hysteresis' */

    /* Switch: '<S838>/Switch2' incorporates:
     *  Constant: '<S863>/Calib'
     */
    if (KeESSR_b_LmtEngTrqAct)
    {
        /* Switch: '<S838>/Switch2' incorporates:
         *  MinMax: '<S838>/MinMax'
         */
        rtb_Switch2_h2 = fminf(rtu_VeOITR_M_InputTorqMaxTact,
                               rtu_VeESSR_M_EngTrqAct_Lmtd);
    }
    else
    {
        /* Switch: '<S838>/Switch2' */
        rtb_Switch2_h2 = rtu_VeESSR_M_EngTrqAct_Lmtd;
    }

    /* End of Switch: '<S838>/Switch2' */

    /* If: '<S838>/If' */
    if (rtb_Switch1_nt)
    {
        /* Outputs for IfAction SubSystem: '<S838>/TiEst_Blendto_EngTrqAct' incorporates:
         *  ActionPort: '<S872>/Action Port'
         */
        /* Merge: '<S838>/Merge' incorporates:
         *  Inport: '<S872>/In1'
         */
        localB->Merge = rtb_Switch2_h2;

        /* Lookup_n-D: '<S867>/Vector' incorporates:
         *  Lookup_n-D: '<S900>/Vector'
         *  Switch: '<S868>/Switch'
         */
        rtb_Vector_bo = look1_iflf_binlcapw(VeESSR_K_BlendRatio, ((const float32
            *)&(KxESSR_K_BlendTitoEngTrq[0])), ((const float32 *)
            &(KtESSR_K_BlendTitoEngTrq[0])), 6U);

        /* End of Outputs for SubSystem: '<S838>/TiEst_Blendto_EngTrqAct' */
    }
    else if (rtb_Switch1_ks)
    {
        /* Outputs for IfAction SubSystem: '<S838>/TiEst_Blendto_TotransIntake' incorporates:
         *  ActionPort: '<S873>/Action Port'
         */
        /* Merge: '<S838>/Merge' incorporates:
         *  Inport: '<S873>/In1'
         */
        localB->Merge = rtu_VeATRR_M_OutputTorqReqImmed;

        /* Lookup_n-D: '<S867>/Vector' incorporates:
         *  Constant: '<S901>/Calib'
         *  SignalConversion generated from: '<S873>/Out2'
         */
        rtb_Vector_bo = KeESSR_K_BlendTitoTo;

        /* End of Outputs for SubSystem: '<S838>/TiEst_Blendto_TotransIntake' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S838>/Hold' incorporates:
         *  ActionPort: '<S853>/Action Port'
         */
        /* Lookup_n-D: '<S867>/Vector' incorporates:
         *  Constant: '<S853>/Constant Value'
         *  SignalConversion generated from: '<S853>/Out2'
         */
        rtb_Vector_bo = 0.0F;

        /* End of Outputs for SubSystem: '<S838>/Hold' */
    }

    /* End of If: '<S838>/If' */

    /* Switch: '<S838>/Switch' incorporates:
     *  Constant: '<S850>/Constant'
     *  Constant: '<S851>/Constant'
     *  Logic: '<S838>/Logical1'
     *  RelationalOperator: '<S838>/Comparison1'
     *  RelationalOperator: '<S838>/Comparison4'
     *  Switch: '<S838>/Switch1'
     */
    if ((CeTRGR_e_TransRangePark == ((uint32)rtu_VeTRGR_e_VldtdTransRngSt)) ||
            (((uint32)rtu_VeTRGR_e_VldtdTransRngSt) ==
             CeTRGR_e_TransRangeNeutral))
    {
        /* Switch: '<S838>/Switch' */
        VeESSR_K_TiEstBlndCoeff = rtb_Vector_bo;

        /* Switch: '<S838>/Switch1' */
        VeESSR_M_TrgtEngTrqEst = localB->Merge;
    }
    else
    {
        /* Switch: '<S838>/Switch' incorporates:
         *  Lookup_n-D: '<S866>/Vector'
         *  Switch: '<S868>/Switch'
         */
        VeESSR_K_TiEstBlndCoeff = look1_iflf_binlcapw(VeESSR_K_BlendRatio, ((
            const float32 *)&(KxESSR_K_TiEstBlndAchIdleBumpStrt[0])), ((const
            float32 *)&(KtESSR_K_TiEstBlndAchIdleBumpStrt[0])), 6U);

        /* Switch: '<S838>/Switch1' */
        VeESSR_M_TrgtEngTrqEst = rtb_Switch2_h2;
    }

    /* End of Switch: '<S838>/Switch' */

    /* Outputs for Atomic SubSystem: '<S838>/Digital Lowpass Reset Enabled' */
    /* Switch: '<S848>/Switch1' incorporates:
     *  Constant: '<S870>/Constant Value'
     *  Switch: '<S898>/Switch1'
     *  UnitDelay: '<S898>/Unit Delay'
     */
    if (rtb_Equal2_l5)
    {
        /* Switch: '<S848>/Switch1' incorporates:
         *  DataStoreRead: '<S838>/Dsr_InputTorqEst'
         */
        VeESSR_M_EngTorqEstOpnLoop = VeESSR_M_EngTorqEst_DS;
        rtb_Switch2_h2 = 0.0F;
    }
    else
    {
        /* Switch: '<S848>/Switch1' incorporates:
         *  Product: '<S848>/Multiplication'
         *  Sum: '<S848>/Subtraction'
         *  Sum: '<S848>/Summation'
         *  UnitDelay: '<S848>/Unit Delay'
         */
        VeESSR_M_EngTorqEstOpnLoop = ((VeESSR_M_TrgtEngTrqEst -
            VeESSR_M_EngTorqEstOpnLoop) * VeESSR_K_TiEstBlndCoeff) +
            VeESSR_M_EngTorqEstOpnLoop;
        rtb_Switch2_h2 = localDW->UnitDelay_DSTATE;
    }

    /* End of Switch: '<S848>/Switch1' */
    /* End of Outputs for SubSystem: '<S838>/Digital Lowpass Reset Enabled' */

    /* Lookup_n-D: '<S865>/Vector' incorporates:
     *  Sum: '<S838>/Summation2'
     */
    VeESSR_K_AchIdleBumpSpdCtlPgain = look1_iflf_binlcapw(rtu_VeMSPR_n_MtrB_Spd
        - VeESSR_n_EngMinTgtAchIdle, ((const float32 *)
        &(KxESSR_K_AchIdleBumpSpdCtlPgain[0])), ((const float32 *)
        &(KtESSR_K_AchIdleBumpSpdCtlPgain[0])), 4U);

    /* Lookup_n-D: '<S867>/Vector' incorporates:
     *  Lookup_n-D: '<S894>/Vector'
     */
    rtb_Vector_bo = look1_iflf_binlcapw(rtb_Abs_cc, ((const float32 *)
        &(KxESSR_K_DeltaGainMult[0])), ((const float32 *)
        &(KtESSR_K_DeltaGainMult[0])), 4U);

    /* MinMax: '<S870>/MinMax2' */
    rtb_Switch2_h2 = fmaxf(rtb_Switch2_h2, rtb_Vector_bo);

    /* Switch: '<S870>/Switch' incorporates:
     *  Constant: '<S889>/Calib'
     */
    if (KeESSR_b_ByBassGainLtch)
    {
        /* Switch: '<S870>/Switch' */
        VeESSR_K_DeltaGainMult = rtb_Vector_bo;
    }
    else
    {
        /* Switch: '<S870>/Switch' */
        VeESSR_K_DeltaGainMult = rtb_Switch2_h2;
    }

    /* End of Switch: '<S870>/Switch' */

    /* Switch: '<S870>/Switch1' */
    if (rtb_Equal2_l5)
    {
        /* Switch: '<S870>/Switch1' */
        VeESSR_n_EngMinTgtPCtrl = rtu_VeESSR_n_TransInSpdFlt;
    }
    else
    {
        /* Abs: '<S870>/Abs' */
        rtb_Abs_cc = fabsf(rtu_VeETQR_M_EngCapacityMinOff);

        /* Outputs for Atomic SubSystem: '<S870>/Protected Division1' */
        /* Switch: '<S897>/Switch1' incorporates:
         *  Constant: '<S897>/Constant Value'
         *  Constant: '<S897>/Constant Value1'
         *  Constant: '<S897>/Constant Value2'
         *  Logic: '<S897>/AND'
         *  RelationalOperator: '<S897>/Greater Than or Equal '
         *  RelationalOperator: '<S897>/Not Equal'
         *  RelationalOperator: '<S897>/Not Equal1'
         *  Switch: '<S897>/Switch2'
         */
        if ((rtb_Abs_cc != 0.0F) && (VeESSR_K_AchIdleBumpSpdCtlPgain != 0.0F))
        {
            /* Switch: '<S897>/Switch1' incorporates:
             *  Product: '<S897>/Division'
             */
            rtb_Abs_cc /= VeESSR_K_AchIdleBumpSpdCtlPgain;
        }
        else if (rtb_Abs_cc > 0.0F)
        {
            /* Switch: '<S897>/Switch2' incorporates:
             *  Constant: '<S897>/MAXFLOAT'
             *  Switch: '<S897>/Switch1'
             */
            rtb_Abs_cc = 3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S897>/Switch1' incorporates:
             *  Constant: '<S897>/Constant Value4'
             *  Switch: '<S897>/Switch2'
             *  Switch: '<S897>/Switch3'
             */
            rtb_Abs_cc = 0.0F;
        }

        /* End of Switch: '<S897>/Switch1' */
        /* End of Outputs for SubSystem: '<S870>/Protected Division1' */

        /* Sum: '<S870>/Sum3' incorporates:
         *  Constant: '<S892>/Calib'
         *  MinMax: '<S870>/MinMax3'
         *  Product: '<S870>/Product'
         *  Sum: '<S870>/Sum2'
         *  UnitDelay: '<S870>/Unit Delay'
         */
        rtb_Abs_cc = (fminf(KeESSR_n_MaxOffstEngMinTgt, rtb_Abs_cc *
                            VeESSR_K_DeltaGainMult) + VeESSR_n_EngMinTgtAchIdle)
            - VeESSR_n_EngMinTgtPCtrl;

        /* Outputs for Atomic SubSystem: '<S870>/Limiter' */
        /* Switch: '<S895>/Switch1' incorporates:
         *  Constant: '<S891>/Calib'
         *  RelationalOperator: '<S895>/Relational Operator'
         */
        if (KeESSR_dn_PtgtLU < rtb_Abs_cc)
        {
            /* Switch: '<S895>/Switch1' */
            rtb_Abs_cc = KeESSR_dn_PtgtLU;
        }

        /* End of Switch: '<S895>/Switch1' */

        /* Switch: '<S895>/Switch' incorporates:
         *  Constant: '<S890>/Calib'
         *  RelationalOperator: '<S895>/Relational Operator1'
         */
        if (rtb_Abs_cc <= KeESSR_dn_PtgtLD)
        {
            rtb_Abs_cc = KeESSR_dn_PtgtLD;
        }

        /* End of Switch: '<S895>/Switch' */
        /* End of Outputs for SubSystem: '<S870>/Limiter' */

        /* Switch: '<S870>/Switch1' incorporates:
         *  Sum: '<S870>/Sum4'
         *  UnitDelay: '<S870>/Unit Delay'
         */
        VeESSR_n_EngMinTgtPCtrl = rtb_Abs_cc + VeESSR_n_EngMinTgtPCtrl;
    }

    /* End of Switch: '<S870>/Switch1' */

    /* Sum: '<S841>/Summation5' */
    VeESSR_n_AchIdleBumpSpdError = rtu_VeESSR_n_TransInSpdFlt -
        VeESSR_n_EngMinTgtPCtrl;

    /* Outputs for Atomic SubSystem: '<S841>/DeadBand' */
    /* Switch: '<S876>/Switch1' incorporates:
     *  Constant: '<S876>/Constant Value'
     *  Constant: '<S878>/Calib'
     *  Constant: '<S879>/Calib'
     *  RelationalOperator: '<S876>/Greater  Than'
     *  RelationalOperator: '<S876>/Greater  Than1'
     *  Sum: '<S876>/Subtraction'
     *  Switch: '<S876>/Switch2'
     */
    if (VeESSR_n_AchIdleBumpSpdError >= KeESSR_n_AchIdleBumpSpdCtlPosDdBnd)
    {
        rtb_Vector_bo = VeESSR_n_AchIdleBumpSpdError -
            KeESSR_n_AchIdleBumpSpdCtlPosDdBnd;
    }
    else if (VeESSR_n_AchIdleBumpSpdError <= KeESSR_n_AchIdleBumpSpdCtlNegDdBnd)
    {
        /* Switch: '<S876>/Switch2' incorporates:
         *  Constant: '<S878>/Calib'
         *  Sum: '<S876>/Subtraction1'
         */
        rtb_Vector_bo = VeESSR_n_AchIdleBumpSpdError -
            KeESSR_n_AchIdleBumpSpdCtlNegDdBnd;
    }
    else
    {
        rtb_Vector_bo = 0.0F;
    }

    /* End of Switch: '<S876>/Switch1' */
    /* End of Outputs for SubSystem: '<S841>/DeadBand' */

    /* Product: '<S841>/Multiplication' */
    rtb_Vector_bo *= VeESSR_K_AchIdleBumpSpdCtlPgain;

    /* Outputs for Atomic SubSystem: '<S841>/Limiter' */
    /* Switch: '<S880>/Switch1' incorporates:
     *  Constant: '<S841>/Constant Value'
     *  RelationalOperator: '<S880>/Relational Operator'
     */
    if (0.0F < rtb_Vector_bo)
    {
        /* Lookup_n-D: '<S867>/Vector' */
        rtb_Vector_bo = 0.0F;
    }

    /* End of Switch: '<S880>/Switch1' */

    /* Switch: '<S880>/Switch' incorporates:
     *  Constant: '<S877>/Calib'
     *  RelationalOperator: '<S880>/Relational Operator1'
     */
    if (rtb_Vector_bo > KeESSR_M_AchIdleBumpSpdCtlMinTi)
    {
        /* Switch: '<S880>/Switch' */
        VeESSR_M_AchIdleBumpPSpdCtl = rtb_Vector_bo;
    }
    else
    {
        /* Switch: '<S880>/Switch' */
        VeESSR_M_AchIdleBumpPSpdCtl = KeESSR_M_AchIdleBumpSpdCtlMinTi;
    }

    /* End of Switch: '<S880>/Switch' */
    /* End of Outputs for SubSystem: '<S841>/Limiter' */

    /* Sum: '<S838>/Sum' incorporates:
     *  DataStoreWrite: '<S838>/Dsw_InputTorqEst'
     */
    VeESSR_M_EngTorqEst_DS = VeESSR_M_EngTorqEstOpnLoop +
        VeESSR_M_AchIdleBumpPSpdCtl;

    /* DataStoreWrite: '<S838>/Dsw_STMTmr' incorporates:
     *  Constant: '<S852>/Calib'
     *  DataStoreRead: '<S838>/Dsr_STMTmr'
     *  Sum: '<S838>/Summation1'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Sum: '<S845>/Sum3' incorporates:
     *  Constant: '<S845>/Constant Value'
     *  Constant: '<S884>/Calib'
     *  MinMax: '<S845>/MinMax'
     *  Product: '<S845>/Product1'
     */
    VeESSR_n_BumpStrtTrgtRunSpd = fminf(rtb_Sum3_he_tmp * 0.5F,
        KeESSR_n_MaxDeltaAchIdleSpdThres) + VeESSR_n_EngMinTgtAchIdle;

    /* Outputs for Atomic SubSystem: '<S845>/Accumulator Reset Limited' */
    /* Switch: '<S881>/Switch1' */
    if (rtb_Equal2_l5)
    {
        /* Switch: '<S881>/Switch1' incorporates:
         *  Constant: '<S845>/Constant Value1'
         */
        VeESSR_n_BumpStrtExitIntgrlVal = 0.0F;
    }
    else
    {
        /* Sum: '<S881>/Summation' incorporates:
         *  Constant: '<S882>/Calib'
         *  Product: '<S845>/Product'
         *  Sum: '<S845>/Sum1'
         *  UnitDelay: '<S881>/Unit Delay'
         */
        rtb_Vector_bo = ((rtu_VeESSR_n_TransInSpdFlt -
                          VeESSR_n_BumpStrtTrgtRunSpd) * HeESSR_t_MedTEB_dT) +
            VeESSR_n_BumpStrtExitIntgrlVal;

        /* Outputs for Atomic SubSystem: '<S881>/Limiter' */
        /* Switch: '<S885>/Switch1' incorporates:
         *  Constant: '<S883>/Calib'
         *  RelationalOperator: '<S885>/Relational Operator'
         */
        if (KeESSR_n_BumpStrtStateExitIntgrlVal < rtb_Vector_bo)
        {
            /* Switch: '<S885>/Switch1' */
            rtb_Vector_bo = KeESSR_n_BumpStrtStateExitIntgrlVal;
        }

        /* End of Switch: '<S885>/Switch1' */

        /* Switch: '<S885>/Switch' incorporates:
         *  Constant: '<S845>/Constant Value1'
         *  RelationalOperator: '<S885>/Relational Operator1'
         */
        if (rtb_Vector_bo > 0.0F)
        {
            /* Switch: '<S881>/Switch1' */
            VeESSR_n_BumpStrtExitIntgrlVal = rtb_Vector_bo;
        }
        else
        {
            /* Switch: '<S881>/Switch1' */
            VeESSR_n_BumpStrtExitIntgrlVal = 0.0F;
        }

        /* End of Switch: '<S885>/Switch' */
        /* End of Outputs for SubSystem: '<S881>/Limiter' */
    }

    /* End of Switch: '<S881>/Switch1' */
    /* End of Outputs for SubSystem: '<S845>/Accumulator Reset Limited' */

    /* RelationalOperator: '<S845>/Comparison4' incorporates:
     *  Constant: '<S883>/Calib'
     */
    VeESSR_b_BumpStrtSpdChk = (VeESSR_n_BumpStrtExitIntgrlVal ==
        KeESSR_n_BumpStrtStateExitIntgrlVal);

    /* RelationalOperator: '<S838>/Greater  Than1' incorporates:
     *  Constant: '<S864>/Calib'
     *  DataStoreRead: '<S838>/Dsr_STMTmr1'
     */
    rtb_Switch1_nt = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmAchIdle_BumpStrt);

    /* Switch: '<S856>/Switch1' incorporates:
     *  Constant: '<S847>/Constant'
     *  DataStoreRead: '<S838>/Dsr_STMTmr2'
     *  DataStoreWrite: '<S838>/Dsw_STMTrigger1'
     *  Logic: '<S838>/Logical'
     *  Lookup_n-D: '<S867>/Vector'
     *  RelationalOperator: '<S838>/Greater  Than2'
     *  Switch: '<S856>/Switch2'
     */
    if ((VeESSR_b_BumpStrtSpdChk) && (VeESSR_t_STMTmr_DS > look1_iflf_binlcapw
            (rtu_VeENGR_T_EngCoolantTemp, ((const float32 *)
            &(KxESSR_t_AchIdleTime[0])), ((const float32 *)
            &(KtESSR_t_AchIdleTime[0])), 2U)))
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngRun;
    }
    else
    {
        if (rtb_Switch1_nt)
        {
            /* Switch: '<S856>/Switch1' incorporates:
             *  Constant: '<S846>/Constant'
             *  DataStoreWrite: '<S838>/Dsw_STMTrigger1'
             *  Switch: '<S856>/Switch2'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;
        }
    }

    /* End of Switch: '<S856>/Switch1' */

    /* Switch: '<S838>/Switch4' incorporates:
     *  Constant: '<S838>/Constant Value2'
     *  DataStoreRead: '<S838>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S838>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S838>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S838>/Logical21'
     *  RelationalOperator: '<S838>/Comparison'
     *  S-Function (sfix_bitop): '<S838>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S844>/FixPt Bitwise Operator1'
     */
    if (rtb_Switch1_nt && ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16384U) > 0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 16384U;
    }

    /* End of Switch: '<S838>/Switch4' */

    /* DataStoreWrite: '<S838>/Dsw_InputAcceltnProf' incorporates:
     *  Constant: '<S838>/Constant Value3'
     */
    VeESSR_dn_InputAcceltnProf_DS = 0.0F;

    /* Update for UnitDelay: '<S874>/Unit Delay1' incorporates:
     *  DataStoreWrite: '<S838>/Dsw_DsblNiClsdLoopCntrl1'
     */
    localDW->UnitDelay1_DSTATE = VeESSR_M_MtrA_MaxTorq_DS;

    /* Update for UnitDelay: '<S874>/Unit Delay24' */
    localDW->UnitDelay24_DSTATE = rtb_Switch1_lpi;

    /* Update for UnitDelay: '<S874>/Unit Delay23' */
    localDW->UnitDelay23_DSTATE = rtb_Gain_d;

    /* Update for UnitDelay: '<S874>/Unit Delay3' incorporates:
     *  Constant: '<S908>/Calib'
     *  RelationalOperator: '<S874>/Less  Than'
     */
    localDW->UnitDelay3_DSTATE = (rtb_Sum3_hz < KeESSR_t_TrqLmtRampTm);

    /* Update for UnitDelay: '<S875>/Unit Delay1' incorporates:
     *  DataStoreWrite: '<S838>/Dsw_DsblNiClsdLoopCntrl2'
     */
    localDW->UnitDelay1_DSTATE_h = VeESSR_M_MtrA_MinTorq_DS;

    /* Update for UnitDelay: '<S875>/Unit Delay24' */
    localDW->UnitDelay24_DSTATE_i = rtb_Switch1_a0h;

    /* Update for UnitDelay: '<S875>/Unit Delay23' */
    localDW->UnitDelay23_DSTATE_d = rtb_Switch1_fk;

    /* Update for UnitDelay: '<S875>/Unit Delay3' incorporates:
     *  Constant: '<S917>/Calib'
     *  RelationalOperator: '<S875>/Less  Than'
     */
    localDW->UnitDelay3_DSTATE_o = (rtb_Multiplication_jm <
        KeESSR_t_TrqLmtRampTm);

    /* Switch: '<S898>/Switch3' */
    if (rtb_Equal2_l5)
    {
        /* Update for UnitDelay: '<S898>/Unit Delay' incorporates:
         *  Constant: '<S870>/Constant Value'
         */
        localDW->UnitDelay_DSTATE = 0.0F;
    }
    else
    {
        /* Update for UnitDelay: '<S898>/Unit Delay' */
        localDW->UnitDelay_DSTATE = rtb_Switch2_h2;
    }

    /* End of Switch: '<S898>/Switch3' */
}

#endif

/* Output and update for function-call system: '<S567>/SpinUp_CS_Dur' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpinUp_CS_Dur(VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_AddtlDragTorq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_TransInSpdFlt, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngCapacityMinRunI, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngTrqActual, VAR(float32, AUTOMATIC)
    rtu_VeETQR_r_MaxSparkAuthority, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngineLosses, VAR(float32, AUTOMATIC)
    rtu_VeENGR_p_EngManfldAbsPrs, VAR(boolean, AUTOMATIC) rtu_ClthLwrThresLmp,
    VAR(boolean, AUTOMATIC) rtu_ClthErlyExitLmp, P2VAR
    (DW_SpinUp_CS_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR(uint32,
    AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_g_StrtStpFailRsn)
{
    float32 rtb_Switch1_ly;
    boolean rtb_GreaterThan3_ee;
    boolean rtb_GreaterThan_hw;
    boolean rtb_LeESSR_b_SpnUpCS_CoastDownT;
    boolean rtb_LogicalOperator21;
    boolean rtb_LogicalOperator3_do;
    boolean rtb_OR2_j;
    boolean rtb_OR_jb;

    /* Outputs for Atomic SubSystem: '<S1731>/Digital Lowpass Reset Enabled' */
    /* Switch: '<S1735>/Switch1' incorporates:
     *  Constant: '<S1736>/Calib'
     *  DataStoreRead: '<S1731>/Dsr_STMTmr'
     *  RelationalOperator: '<S1731>/Equal2'
     */
    if (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS)
    {
        /* Switch: '<S1735>/Switch1' incorporates:
         *  DataStoreRead: '<S1731>/Dsr_InputSpeedProfile7'
         */
        rtb_Switch1_ly = VeESSR_M_EngTorqEst_DS;
    }
    else
    {
        /* Switch: '<S1735>/Switch1' incorporates:
         *  Constant: '<S1738>/Calib'
         *  Product: '<S1735>/Multiplication'
         *  Sum: '<S1731>/Sum1'
         *  Sum: '<S1735>/Subtraction'
         *  Sum: '<S1735>/Summation'
         *  UnitDelay: '<S1735>/Unit Delay'
         */
        rtb_Switch1_ly = (((rtu_VeESSR_M_EngTrqAct_Lmtd -
                            rtu_VeESSR_M_AddtlDragTorq) -
                           localDW->UnitDelay_DSTATE) * KeESSR_K_TiEstBlndSFS) +
            localDW->UnitDelay_DSTATE;
    }

    /* End of Switch: '<S1735>/Switch1' */

    /* Update for UnitDelay: '<S1735>/Unit Delay' */
    localDW->UnitDelay_DSTATE = rtb_Switch1_ly;

    /* End of Outputs for SubSystem: '<S1731>/Digital Lowpass Reset Enabled' */

    /* DataStoreWrite: '<S1731>/Dsw_InputTorqEst' */
    VeESSR_M_EngTorqEst_DS = rtb_Switch1_ly;

    /* DataStoreWrite: '<S1731>/Dsw_STMTmr' incorporates:
     *  Constant: '<S1736>/Calib'
     *  DataStoreRead: '<S1731>/Dsr_STMTmr'
     *  Sum: '<S1731>/Summation1'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* DataStoreWrite: '<S1731>/Dsw_InputSpeedProfile' */
    VeESSR_n_InputSpeedProfile_DS = rtu_VeESSR_n_TransInSpdFlt;

    /* Outputs for Atomic SubSystem: '<S1731>/ChkSpinUpEng_CS' */
    /* Switch: '<S1734>/Switch1' incorporates:
     *  Constant: '<S1751>/Calib'
     *  DataStoreRead: '<S1734>/Dsr_AStrtSpinUpExtSpd'
     */
    if (rtu_ClthLwrThresLmp)
    {
        rtb_Switch1_ly = KeESSR_n_LmpHmCSSpinUpExtSpd;
    }
    else
    {
        rtb_Switch1_ly = VeESSR_n_StrtTypAStrtSpinUpExtSpd_DS;
    }

    /* End of Switch: '<S1734>/Switch1' */

    /* RelationalOperator: '<S1734>/Greater  Than' */
    rtb_GreaterThan_hw = (rtu_VeESSR_n_TransInSpdFlt > rtb_Switch1_ly);

    /* RelationalOperator: '<S1734>/Greater  Than3' incorporates:
     *  Constant: '<S1753>/Calib'
     *  DataStoreRead: '<S1734>/Dsr_STMTmr1'
     */
    rtb_GreaterThan3_ee = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmSpinUp_CS);

    /* Logic: '<S1734>/Logical Operator21' incorporates:
     *  Logic: '<S1734>/Logical Operator5'
     */
    rtb_LogicalOperator21 = !rtu_ClthLwrThresLmp;

    /* Logic: '<S1734>/Logical Operator3' incorporates:
     *  Logic: '<S1734>/Logical Operator'
     */
    rtb_LogicalOperator3_do = (((!rtb_GreaterThan_hw) && rtb_GreaterThan3_ee) &&
        rtb_LogicalOperator21);

    /* Switch: '<S1734>/Switch' */
    if (rtb_LogicalOperator3_do)
    {
        /* DataStoreWrite: '<S1734>/Data Store Write' incorporates:
         *  S-Function (sfix_bitop): '<S1739>/FixPt Bitwise Operator1'
         *  Switch: '<S1734>/Switch'
         */
        *rtd_NeESSR_g_StrtStpFailRsn |= 32U;
    }

    /* End of Switch: '<S1734>/Switch' */

    /* Logic: '<S1734>/OR' incorporates:
     *  DataStoreRead: '<S1734>/Dsr_InputSpeedProfile2'
     *  DataStoreRead: '<S1734>/Dsr_STMTmr2'
     *  DataStoreRead: '<S1734>/Dsr_StrtTypMapTargetMaxTm'
     *  Logic: '<S1734>/Logical Operator6'
     *  RelationalOperator: '<S1734>/Greater  Than1'
     *  RelationalOperator: '<S1734>/Greater  Than2'
     */
    rtb_OR_jb = ((rtu_VeETQR_M_EngCapacityMinRunI <= VeESSR_M_EngTrqReqImmed_DS)
                 || ((VeESSR_t_STMTmr_DS > VeESSR_t_StrtTypAirflowTrqMaxTm_DS) ||
                     rtb_GreaterThan3_ee));

    /* Logic: '<S1734>/Logical Operator9' incorporates:
     *  Logic: '<S1734>/Logical Operator1'
     *  Logic: '<S1734>/Logical Operator4'
     */
    rtb_LeESSR_b_SpnUpCS_CoastDownT = (((!rtb_OR_jb) && rtb_GreaterThan3_ee) &&
        rtb_LogicalOperator21);

    /* Switch: '<S1734>/Switch2' */
    if (rtb_LeESSR_b_SpnUpCS_CoastDownT)
    {
        /* DataStoreWrite: '<S1734>/Data Store Write1' incorporates:
         *  S-Function (sfix_bitop): '<S1740>/FixPt Bitwise Operator1'
         *  Switch: '<S1734>/Switch2'
         */
        *rtd_NeESSR_g_StrtStpFailRsn |= 64U;
    }

    /* End of Switch: '<S1734>/Switch2' */

    /* Logic: '<S1734>/OR2' incorporates:
     *  DataStoreRead: '<S1734>/Dsr_STMTmr4'
     *  DataStoreRead: '<S1734>/Dsr_StrtTypAStrtSpinUpManPrs'
     *  DataStoreRead: '<S1734>/Dsr_StrtTypMapTargetMaxTm2'
     *  Logic: '<S1734>/Logical Operator16'
     *  RelationalOperator: '<S1734>/Greater  Than10'
     *  RelationalOperator: '<S1734>/Greater  Than9'
     */
    rtb_OR2_j = ((rtu_VeENGR_p_EngManfldAbsPrs <
                  VeESSR_p_StrtTypAStrtSpinUpManPrs_DS) || ((VeESSR_t_STMTmr_DS >
                   VeESSR_t_StrtTypManPrsMaxTm_DS) || rtb_GreaterThan3_ee));

    /* Logic: '<S1734>/Logical Operator21' incorporates:
     *  Logic: '<S1734>/Logical Operator19'
     */
    rtb_LogicalOperator21 = (((!rtb_OR2_j) && rtb_GreaterThan3_ee) &&
        rtb_LogicalOperator21);

    /* Switch: '<S1734>/Switch6' */
    if (rtb_LogicalOperator21)
    {
        /* DataStoreWrite: '<S1734>/Data Store Write7' incorporates:
         *  S-Function (sfix_bitop): '<S1741>/FixPt Bitwise Operator1'
         *  Switch: '<S1734>/Switch6'
         */
        *rtd_NeESSR_g_StrtStpFailRsn |= 33554432U;
    }

    /* End of Switch: '<S1734>/Switch6' */

    /* Logic: '<S1734>/Logical Operator9' */
    rtb_LeESSR_b_SpnUpCS_CoastDownT = (((rtb_LogicalOperator3_do ||
        rtb_LeESSR_b_SpnUpCS_CoastDownT) || rtb_LogicalOperator21) ||
        rtu_ClthErlyExitLmp);

    /* Switch: '<S1746>/Switch1' incorporates:
     *  Constant: '<S1734>/Constant Value1'
     *  Constant: '<S1734>/Constant Value3'
     *  DataStoreRead: '<S1734>/Dsr_STMTmr3'
     *  DataStoreRead: '<S1734>/Dsr_STMTmr6'
     *  DataStoreWrite: '<S1734>/Dsw_AStrtFailed1'
     *  Logic: '<S1734>/Logical1'
     *  Logic: '<S1734>/Logical2'
     *  RelationalOperator: '<S1734>/Greater  Than4'
     *  Sum: '<S1734>/Sum3'
     */
    if ((rtb_LeESSR_b_SpnUpCS_CoastDownT || rtu_ClthLwrThresLmp) && (((sint32)
            VeESSR_Cnt_CSSpinupAttmptCntr_DS) < 255))
    {
        VeESSR_Cnt_CSSpinupAttmptCntr_DS = (uint8)(((uint32)
            VeESSR_Cnt_CSSpinupAttmptCntr_DS) + 1U);
    }

    /* End of Switch: '<S1746>/Switch1' */

    /* Logic: '<S1734>/Logical Operator15' incorporates:
     *  Constant: '<S1750>/Calib'
     *  Constant: '<S1752>/Calib'
     *  DataStoreWrite: '<S1734>/Dsw_AStrtFailed3'
     *  RelationalOperator: '<S1734>/Greater  Than8'
     */
    VeESSR_b_BackUpStartEng_DS = (((KeESSR_b_EnblFtrEarlyExitSpinUp) &&
        rtu_ClthErlyExitLmp) && (rtu_VeESSR_n_TransInSpdFlt >
        KeESSR_n_MinSpdFuelOn));

    /* If: '<S1734>/If' incorporates:
     *  Constant: '<S1749>/Calib'
     *  DataStoreRead: '<S1734>/Dsr_STMTmr8'
     *  RelationalOperator: '<S1734>/Greater  Than5'
     */
    if (rtb_LogicalOperator3_do && (VeESSR_Cnt_CSSpinupAttmptCntr_DS >=
            KeESSR_Cnt_CSSpinupMaxAttmpts))
    {
        /* Outputs for IfAction SubSystem: '<S1734>/If_AutoStrt_P1C65' incorporates:
         *  ActionPort: '<S1748>/Action Port'
         */
        /* DataStoreWrite: '<S1734>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_AutoStrt_P1C65((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S1734>/If_AutoStrt_P1C65' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1734>/If_AutoStrt_NoFault' incorporates:
         *  ActionPort: '<S1747>/Action Port'
         */
        /* DataStoreWrite: '<S1734>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_AutoStrt_NoFault((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S1734>/If_AutoStrt_NoFault' */
    }

    /* End of If: '<S1734>/If' */

    /* Switch: '<S1737>/Switch1' incorporates:
     *  Constant: '<S1743>/Constant'
     *  DataStoreWrite: '<S1731>/Dsw_STMTrigger'
     *  DataStoreWrite: '<S1734>/Dsw_AStrtFailed3'
     *  Logic: '<S1734>/AND'
     *  Logic: '<S1734>/Logical Operator22'
     *  Switch: '<S1737>/Switch2'
     *  Switch: '<S1737>/Switch3'
     */
    if ((VeESSR_b_BackUpStartEng_DS) || ((rtb_GreaterThan_hw && rtb_OR_jb) &&
            rtb_OR2_j))
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngSpdTgtAch;
    }
    else if (rtb_LeESSR_b_SpnUpCS_CoastDownT)
    {
        /* Switch: '<S1737>/Switch1' incorporates:
         *  Constant: '<S1744>/Constant'
         *  DataStoreWrite: '<S1731>/Dsw_STMTrigger'
         *  Switch: '<S1737>/Switch2'
         */
        VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;
    }
    else
    {
        if (rtb_GreaterThan3_ee)
        {
            /* Switch: '<S1734>/Switch3' */
            if (rtu_ClthLwrThresLmp)
            {
                /* Switch: '<S1737>/Switch1' incorporates:
                 *  Constant: '<S1745>/Constant'
                 *  DataStoreWrite: '<S1731>/Dsw_STMTrigger'
                 *  Switch: '<S1737>/Switch2'
                 *  Switch: '<S1737>/Switch3'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;
            }
            else
            {
                /* Switch: '<S1737>/Switch1' incorporates:
                 *  Constant: '<S1742>/Constant'
                 *  DataStoreWrite: '<S1731>/Dsw_STMTrigger'
                 *  Switch: '<S1737>/Switch2'
                 *  Switch: '<S1737>/Switch3'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;
            }

            /* End of Switch: '<S1734>/Switch3' */
        }
    }

    /* End of Switch: '<S1737>/Switch1' */
    /* End of Outputs for SubSystem: '<S1731>/ChkSpinUpEng_CS' */

    /* Switch: '<S1731>/Switch4' incorporates:
     *  Constant: '<S1731>/Constant Value'
     *  DataStoreRead: '<S1731>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S1731>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S1731>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S1731>/Logical1'
     *  Logic: '<S1731>/Logical21'
     *  RelationalOperator: '<S1731>/Comparison'
     *  S-Function (sfix_bitop): '<S1731>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S1733>/FixPt Bitwise Operator1'
     */
    if ((rtb_LeESSR_b_SpnUpCS_CoastDownT || rtb_GreaterThan3_ee) &&
            ((VeESSR_g_StrtStpFailPhaseSelect_DS & 4194304U) > 0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 4194304U;
    }

    /* End of Switch: '<S1731>/Switch4' */

    /* MinMax: '<S1731>/MinMax' incorporates:
     *  DataStoreRead: '<S1731>/Dsr_InputSpeedProfile2'
     *  DataStoreRead: '<S1731>/Dsr_StrtTypInitImmedTorq'
     *  DataStoreWrite: '<S1731>/Dsw_EngTrqReqImmed'
     *  Sum: '<S1731>/Summation2'
     */
    VeESSR_M_EngTrqReqImmed_DS = fminf(VeESSR_M_StrtTypInitImmedTorq_DS,
        rtu_VeETQR_M_EngTrqActual + VeESSR_M_MinImmedExitTorqDelta_DS);

    /* MinMax: '<S1731>/MinMax1' incorporates:
     *  DataStoreRead: '<S1731>/Dsr_InputSpeedProfile3'
     *  DataStoreRead: '<S1731>/Dsr_StrtTypInitPredTorq'
     *  DataStoreWrite: '<S1731>/Dsw_EngTrqReqPrdtd1'
     *  Product: '<S1731>/Product'
     *  Sum: '<S1731>/Summation3'
     *  Sum: '<S1731>/Summation4'
     */
    VeESSR_M_EngTrqReqPrdtd_DS = fminf(VeESSR_M_StrtTypInitPredTorq_DS,
        ((VeESSR_M_EngTrqReqImmed_DS + rtu_VeETQR_M_EngineLosses) *
         rtu_VeETQR_r_MaxSparkAuthority) - rtu_VeETQR_M_EngineLosses);
}

#endif

/*
 * Output and update for action system:
 *    '<S2238>/ESSC_CombstDelay'
 *    '<S2306>/ESSC_CombstDelay'
 */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_CombstDelay_l(VAR(float32,
    AUTOMATIC) rtu_Ni, P2VAR(boolean, AUTOMATIC, ESSR_VAR_INIT)
    rty_OutputParameter)
{
    float32 rtb_Sum_mk;

    /* Sum: '<S2276>/Sum' incorporates:
     *  Constant: '<S2281>/Calib'
     *  Constant: '<S2282>/Calib'
     *  DataStoreRead: '<S2276>/Dsr_STMTmr1'
     *  Product: '<S2276>/Product'
     */
    rtb_Sum_mk = ((KeESSR_k_CombstDelay * rtu_Ni) * HeESSR_t_MedTEB_dT) +
        VeESSR_phi_CombstDelay_DS;

    /* DataStoreWrite: '<S2276>/Dsw_InputAcceltnProf' */
    VeESSR_phi_CombstDelay_DS = rtb_Sum_mk;

    /* RelationalOperator: '<S2276>/Comparison' incorporates:
     *  Constant: '<S2283>/Calib'
     */
    *rty_OutputParameter = (rtb_Sum_mk > KeESSR_phi_CombstDelay);
}

#endif

/* Output and update for function-call system: '<S571>/StartEngCS_Dur' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_StartEngCS_Dur(VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(boolean, AUTOMATIC)
    rtu_VeENGR_b_EngCombustionCmnd, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngTrqActual, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_OptEngTrqReqPred, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_OptEngTrqReqImmed, VAR(float32, AUTOMATIC)
    rtu_VeETQR_r_MaxSparkAuthority, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngineLosses, VAR(TeENGR_e_ETRQ_Mode, AUTOMATIC)
    rtu_VeENGR_e_ETRQ_Mode, VAR(float32, AUTOMATIC) rtu_VeESSR_n_TransInSpdFlt,
    VAR(float32, AUTOMATIC) rtu_EngCltTmp, VAR(float32, AUTOMATIC)
    rtu_HSER_Cltch1Trq, VAR(float32, AUTOMATIC) rtu_HSER_Cltch3Trq, VAR(boolean,
    AUTOMATIC) rtu_VeRTMR_b_InPlantMode, VAR(boolean, AUTOMATIC)
    rtu_ClthSpinupErlyExitLmp, P2VAR(DW_StartEngCS_Dur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn)
{
    float32 rtb_Multiplication1_iz;
    float32 rtb_Sum1_f2;
    float32 rtb_Sum2_e1o;
    float32 rtb_Switch3_fg;
    boolean rtb_Equal2_o;
    boolean rtb_GreaterThan1_li;
    boolean rtb_Logical8_kf;
    boolean rtb_LogicalOperator4_j;
    boolean rtb_LogicalOperator4_o;

    /* RelationalOperator: '<S2230>/Greater  Than1' incorporates:
     *  Constant: '<S2254>/Calib'
     *  DataStoreRead: '<S2230>/Dsr_STMTmr1'
     */
    rtb_GreaterThan1_li = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmStartEngCS);

    /* Logic: '<S2230>/Logical8' incorporates:
     *  Constant: '<S2250>/Calib'
     *  Constant: '<S2251>/Calib'
     *  DataStoreRead: '<S2230>/Data Store Read1'
     *  Logic: '<S2230>/Logical10'
     *  Logic: '<S2230>/Logical5'
     *  Logic: '<S2230>/Logical6'
     */
    rtb_Logical8_kf = (((!KeESSR_b_DsblEVStrtFailed_InPlant) ||
                        (!rtu_VeRTMR_b_InPlantMode)) &&
                       ((KeESSR_b_AllowEV_StrtFailed) ||
                        (VeESSR_b_AStrtReattmptAllowed_DS)));

    /* Logic: '<S2230>/Logical14' incorporates:
     *  DataStoreWrite: '<S2230>/Dsw_AStrtFailed3'
     *  Logic: '<S2230>/Logical12'
     *  Logic: '<S2230>/Logical13'
     */
    VeESSR_b_AStrtFailed_DS = ((rtu_ClthSpinupErlyExitLmp && rtb_GreaterThan1_li)
        || (rtb_GreaterThan1_li && rtb_Logical8_kf));

    /* Switch: '<S2241>/Switch1' incorporates:
     *  Constant: '<S2230>/Constant Value4'
     *  DataStoreRead: '<S2230>/Dsr_STMTmr3'
     *  DataStoreWrite: '<S2230>/Dsw_AStrtFailed1'
     *  DataStoreWrite: '<S2230>/Dsw_AStrtFailed3'
     *  Logic: '<S2230>/Logical3'
     *  Logic: '<S2230>/Logical9'
     *  Sum: '<S2230>/Sum3'
     */
    if ((VeESSR_b_AStrtFailed_DS) && (!rtu_ClthSpinupErlyExitLmp))
    {
        VeESSR_Cnt_AStrtFailAttmptCntr_DS = (uint8)(((uint32)
            VeESSR_Cnt_AStrtFailAttmptCntr_DS) + 1U);
    }

    /* End of Switch: '<S2241>/Switch1' */

    /* RelationalOperator: '<S2230>/Greater  Than3' incorporates:
     *  Constant: '<S2246>/Calib'
     *  DataStoreWrite: '<S2230>/Dsw_AStrtFailed1'
     *  DataStoreWrite: '<S2230>/Dsw_AStrtFailed4'
     */
    VeESSR_b_AStrtReattmptAllowed_DS = (VeESSR_Cnt_AStrtFailAttmptCntr_DS <=
        KeESSR_Cnt_AStrtFailMaxAttmpts);

    /* Logic: '<S2237>/Logical Operator4' incorporates:
     *  Constant: '<S2252>/Calib'
     *  Switch: '<S2242>/Switch1'
     */
    rtb_LogicalOperator4_o = ((KeESSR_b_EngCombCmd_Dsbl) ||
        rtu_VeENGR_b_EngCombustionCmnd);

    /* If: '<S2238>/If1' */
    if (rtb_LogicalOperator4_o)
    {
        /* Outputs for IfAction SubSystem: '<S2238>/ESSC_CombstDelay' incorporates:
         *  ActionPort: '<S2276>/Action Port'
         */
        ESSR_ac_ESSC_CombstDelay_l(rtu_VeESSR_n_TransInSpdFlt,
            &rtb_LogicalOperator4_o);

        /* End of Outputs for SubSystem: '<S2238>/ESSC_CombstDelay' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2238>/ESSC_CombstNoDelay' incorporates:
         *  ActionPort: '<S2277>/Action Port'
         */
        ESSR_ac_ESSC_CmbstnNoDelay(&rtb_LogicalOperator4_o);

        /* End of Outputs for SubSystem: '<S2238>/ESSC_CombstNoDelay' */
    }

    /* End of If: '<S2238>/If1' */

    /* RelationalOperator: '<S2230>/Equal2' incorporates:
     *  Constant: '<S2240>/Calib'
     *  DataStoreRead: '<S2230>/Dsr_STMTmr'
     */
    rtb_Equal2_o = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

    /* Outputs for Atomic SubSystem: '<S2238>/Signal Latch On With Reset' */
    /* Logic: '<S2280>/OR1' incorporates:
     *  Constant: '<S2278>/Calib'
     *  DataStoreRead: '<S2238>/Dsr_STMTmr'
     *  Logic: '<S2238>/Logical3'
     *  Logic: '<S2280>/NOT'
     *  Logic: '<S2280>/OR'
     *  RelationalOperator: '<S2238>/Equal1'
     *  UnitDelay: '<S2280>/Unit Delay'
     */
    rtb_LogicalOperator4_o = ((rtb_LogicalOperator4_o || (VeESSR_t_STMTmr_DS >
        KeESSR_t_FuelTmDelayHold)) || ((!rtb_Equal2_o) &&
        (localDW->UnitDelay_DSTATE_h)));

    /* Update for UnitDelay: '<S2280>/Unit Delay' */
    localDW->UnitDelay_DSTATE_h = rtb_LogicalOperator4_o;

    /* End of Outputs for SubSystem: '<S2238>/Signal Latch On With Reset' */

    /* Logic: '<S2238>/Logical4' */
    rtb_LogicalOperator4_o = !rtb_LogicalOperator4_o;

    /* Logic: '<S2230>/Logical4' incorporates:
     *  Logic: '<S2230>/Logical1'
     */
    rtb_LogicalOperator4_j = !rtb_LogicalOperator4_o;

    /* Switch: '<S2230>/Switch1' incorporates:
     *  Constant: '<S2239>/Constant'
     *  Constant: '<S2248>/Calib'
     *  DataStoreWrite: '<S2230>/Dsw_EngStrtType2'
     *  Logic: '<S2230>/Logical4'
     *  Logic: '<S2230>/Logical7'
     *  RelationalOperator: '<S2230>/Greater  Than2'
     */
    if ((rtu_VeETQR_M_EngTrqActual > KeESSR_M_StrtEngCSEngTrqThrsh) &&
            rtb_LogicalOperator4_j)
    {
        VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Startng;
    }

    /* End of Switch: '<S2230>/Switch1' */

    /* Sum: '<S2262>/Sum2' incorporates:
     *  Constant: '<S2249>/Calib'
     *  MinMax: '<S2230>/Maximum2'
     */
    rtb_Sum2_e1o = fmaxf(rtu_VeESSR_M_OptEngTrqReqImmed,
                         KeESSR_M_StrtEngCSMinStrtDtctTorq);

    /* Sum: '<S2230>/Sum1' incorporates:
     *  DataStoreRead: '<S2230>/Dsr_StrtTypInitImmedTorq1'
     */
    rtb_Sum1_f2 = rtb_Sum2_e1o - VeESSR_M_EngTrqReqImmed_DS;

    /* Outputs for Atomic SubSystem: '<S2230>/Lowpass Second Order Enabled1' */
    /* Switch: '<S2256>/Switch3' incorporates:
     *  Switch: '<S2256>/Switch1'
     */
    if (rtb_LogicalOperator4_o)
    {
        /* Switch: '<S2256>/Switch3' */
        rtb_Switch3_fg = rtb_Sum1_f2;

        /* Switch: '<S2256>/Switch1' */
        rtb_Multiplication1_iz = rtb_Sum1_f2;
    }
    else
    {
        /* Switch: '<S2256>/Switch3' incorporates:
         *  UnitDelay: '<S2256>/x2'
         */
        rtb_Switch3_fg = localDW->x2_DSTATE_j;

        /* Product: '<S2256>/Multiplication1' incorporates:
         *  Constant: '<S2240>/Calib'
         *  DataStoreRead: '<S2230>/Dsr_StrtTypInitImmedTorq3'
         *  MinMax: '<S2256>/Maximum'
         */
        rtb_Multiplication1_iz = (1.0F / fmaxf(VeESSR_k_StrtTypEngTorqReqFltT_DS,
            HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT;

        /* Switch: '<S2256>/Switch1' incorporates:
         *  Constant: '<S2230>/Constant Value2'
         *  DataStoreRead: '<S2230>/Dsr_StrtTypInitImmedTorq4'
         *  Gain: '<S2256>/Gain'
         *  Gain: '<S2256>/Gain1'
         *  Math: '<S2256>/Square'
         *  Product: '<S2256>/Multiplication2'
         *  Product: '<S2256>/Multiplication3'
         *  Sum: '<S2256>/Subtraction'
         *  Sum: '<S2256>/Subtraction1'
         *  Sum: '<S2256>/Summation'
         *  UnitDelay: '<S2256>/temp'
         *  UnitDelay: '<S2256>/x2'
         */
        rtb_Multiplication1_iz = (((((localDW->temp_DSTATE_g -
            localDW->x2_DSTATE_j) * (2.0F *
            VeESSR_k_StrtTypEngTorqReqImmedFltD_DS)) * rtb_Multiplication1_iz) +
            ((rtb_Multiplication1_iz * rtb_Multiplication1_iz) * (0.0F -
            localDW->temp_DSTATE_g))) - localDW->temp_DSTATE_g) + (2.0F *
            localDW->x2_DSTATE_j);
    }

    /* End of Switch: '<S2256>/Switch3' */

    /* Update for UnitDelay: '<S2256>/x2' */
    localDW->x2_DSTATE_j = rtb_Multiplication1_iz;

    /* Update for UnitDelay: '<S2256>/temp' */
    localDW->temp_DSTATE_g = rtb_Switch3_fg;

    /* End of Outputs for SubSystem: '<S2230>/Lowpass Second Order Enabled1' */

    /* Sum: '<S2230>/Sum2' incorporates:
     *  DataStoreWrite: '<S2230>/Dsw_EngTrqReqImmed'
     */
    VeESSR_M_EngTrqReqImmed_DS = rtb_Sum2_e1o - rtb_Multiplication1_iz;

    /* Sum: '<S2230>/Summation4' incorporates:
     *  Product: '<S2230>/Product'
     *  Sum: '<S2230>/Summation3'
     */
    rtb_Switch3_fg = ((rtb_Sum2_e1o + rtu_VeETQR_M_EngineLosses) *
                      rtu_VeETQR_r_MaxSparkAuthority) -
        rtu_VeETQR_M_EngineLosses;

    /* Outputs for Atomic SubSystem: '<S2230>/Lowpass Second Order Enabled3' */
    /* Switch: '<S2257>/Switch3' incorporates:
     *  Switch: '<S2257>/Switch1'
     */
    if (rtb_Equal2_o)
    {
        /* Switch: '<S2257>/Switch3' incorporates:
         *  DataStoreRead: '<S2230>/Dsr_StrtTypInitImmedTorq6'
         */
        rtb_Sum2_e1o = VeESSR_M_EngTrqReqPrdtd_DS;

        /* Switch: '<S2257>/Switch1' incorporates:
         *  DataStoreRead: '<S2230>/Dsr_StrtTypInitImmedTorq6'
         */
        rtb_Multiplication1_iz = VeESSR_M_EngTrqReqPrdtd_DS;
    }
    else
    {
        /* Switch: '<S2257>/Switch3' incorporates:
         *  UnitDelay: '<S2257>/x2'
         */
        rtb_Sum2_e1o = localDW->x2_DSTATE;

        /* Product: '<S2257>/Multiplication1' incorporates:
         *  Constant: '<S2240>/Calib'
         *  Constant: '<S2247>/Calib'
         *  DataStoreRead: '<S2230>/Dsr_StrtTypInitImmedTorq2'
         *  MinMax: '<S2257>/Maximum'
         *  Product: '<S2230>/Product1'
         */
        rtb_Multiplication1_iz = (1.0F / fmaxf(KeESSR_K_StrtEngCSTiPredCoefMult *
            VeESSR_k_StrtTypEngTorqReqFltT_DS, HeESSR_t_MedTEB_dT)) *
            HeESSR_t_MedTEB_dT;

        /* Switch: '<S2257>/Switch1' incorporates:
         *  Constant: '<S2249>/Calib'
         *  DataStoreRead: '<S2230>/Dsr_StrtTypInitImmedTorq5'
         *  Gain: '<S2257>/Gain'
         *  Gain: '<S2257>/Gain1'
         *  Math: '<S2257>/Square'
         *  MinMax: '<S2230>/Maximum1'
         *  Product: '<S2257>/Multiplication2'
         *  Product: '<S2257>/Multiplication3'
         *  Sum: '<S2257>/Subtraction'
         *  Sum: '<S2257>/Subtraction1'
         *  Sum: '<S2257>/Summation'
         *  UnitDelay: '<S2257>/temp'
         *  UnitDelay: '<S2257>/x2'
         */
        rtb_Multiplication1_iz = (((((localDW->temp_DSTATE - localDW->x2_DSTATE)
            * (2.0F * VeESSR_k_StrtTypEngTorqReqImmedFltD_DS)) *
            rtb_Multiplication1_iz) + ((rtb_Multiplication1_iz *
            rtb_Multiplication1_iz) * (fmaxf(rtu_VeESSR_M_OptEngTrqReqPred,
            KeESSR_M_StrtEngCSMinStrtDtctTorq) - localDW->temp_DSTATE))) -
            localDW->temp_DSTATE) + (2.0F * localDW->x2_DSTATE);
    }

    /* End of Switch: '<S2257>/Switch3' */

    /* Outputs for Atomic SubSystem: '<S2257>/Limiter3' */
    /* Switch: '<S2287>/Switch1' incorporates:
     *  RelationalOperator: '<S2287>/Relational Operator'
     */
    if (rtb_Switch3_fg >= rtb_Multiplication1_iz)
    {
        /* Lookup_n-D: '<S2274>/Vector' */
        rtb_Switch3_fg = rtb_Multiplication1_iz;
    }

    /* End of Switch: '<S2287>/Switch1' */

    /* Switch: '<S2287>/Switch' incorporates:
     *  DataStoreWrite: '<S2230>/Dsw_EngTrqReqImmed'
     *  DataStoreWrite: '<S2230>/Dsw_EngTrqReqPrdtd'
     *  RelationalOperator: '<S2287>/Relational Operator1'
     */
    if (rtb_Switch3_fg > VeESSR_M_EngTrqReqImmed_DS)
    {
        VeESSR_M_EngTrqReqPrdtd_DS = rtb_Switch3_fg;
    }
    else
    {
        VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_EngTrqReqImmed_DS;
    }

    /* End of Switch: '<S2287>/Switch' */
    /* End of Outputs for SubSystem: '<S2257>/Limiter3' */

    /* Update for UnitDelay: '<S2257>/x2' incorporates:
     *  DataStoreWrite: '<S2230>/Dsw_EngTrqReqPrdtd'
     */
    localDW->x2_DSTATE = VeESSR_M_EngTrqReqPrdtd_DS;

    /* Update for UnitDelay: '<S2257>/temp' */
    localDW->temp_DSTATE = rtb_Sum2_e1o;

    /* End of Outputs for SubSystem: '<S2230>/Lowpass Second Order Enabled3' */

    /* DataStoreWrite: '<S2230>/Dsw_InputSpeedProfile' */
    VeESSR_n_InputSpeedProfile_DS = rtu_VeESSR_n_TransInSpdFlt;

    /* Outputs for Atomic SubSystem: '<S2230>/Digital Lowpass Reset Enabled' */
    /* Switch: '<S2236>/Switch1' */
    if (rtb_Equal2_o)
    {
        /* Switch: '<S2236>/Switch1' incorporates:
         *  DataStoreRead: '<S2230>/Dsr_InputSpeedProfile7'
         */
        rtb_Sum2_e1o = VeESSR_M_EngTorqEst_DS;
    }
    else
    {
        /* Switch: '<S2236>/Switch1' incorporates:
         *  Lookup_n-D: '<S2255>/Vector'
         *  Product: '<S2236>/Multiplication'
         *  Sum: '<S2236>/Subtraction'
         *  Sum: '<S2236>/Summation'
         *  UnitDelay: '<S2236>/Unit Delay'
         */
        rtb_Sum2_e1o = ((rtu_VeESSR_M_EngTrqAct_Lmtd -
                         localDW->UnitDelay_DSTATE_l) * look1_iflf_binlcapw
                        (rtu_EngCltTmp, ((const float32 *)
                          &(KxESSR_k_TiEstBlndStrtEng[0])), ((const float32 *)
                          &(KtESSR_k_TiEstBlndStrtEng[0])), 8U)) +
            localDW->UnitDelay_DSTATE_l;
    }

    /* End of Switch: '<S2236>/Switch1' */

    /* Update for UnitDelay: '<S2236>/Unit Delay' */
    localDW->UnitDelay_DSTATE_l = rtb_Sum2_e1o;

    /* End of Outputs for SubSystem: '<S2230>/Digital Lowpass Reset Enabled' */

    /* DataStoreWrite: '<S2230>/Dsw_InputTorqEst1' */
    VeESSR_M_EngTorqEst_DS = rtb_Sum2_e1o;

    /* DataStoreWrite: '<S2230>/Dsw_STMTmr' incorporates:
     *  Constant: '<S2240>/Calib'
     *  DataStoreRead: '<S2230>/Dsr_STMTmr'
     *  Sum: '<S2230>/Summation1'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Sum: '<S2262>/Sum2' */
    rtb_Sum2_e1o = rtu_HSER_Cltch1Trq + rtu_HSER_Cltch3Trq;

    /* Product: '<S2262>/Product' incorporates:
     *  Constant: '<S2253>/Calib'
     *  Constant: '<S2269>/Calib'
     *  Constant: '<S2271>/Calib'
     *  Lookup_n-D: '<S2274>/Vector'
     *  Sum: '<S2262>/Sum1'
     *  Sum: '<S2262>/Sum2'
     */
    VeESSR_n_StrtEngCSErr = (((rtu_VeESSR_n_TransInSpdFlt -
        KeESSR_n_StrtEngCSExitSpdIngrl) - KeESSR_n_StrtEngCSSpdTgt) *
        HeESSR_t_MedTEB_dT) * look1_iflf_binlcapw(rtb_Sum2_e1o, ((const float32 *)
        &(KxESSR_k_StrtEngCSCltchTrqMult[0])), ((const float32 *)
        &(KtESSR_k_StrtEngCSCltchTrqMult[0])), 6U);

    /* Logic: '<S2237>/Logical2' incorporates:
     *  Logic: '<S2237>/Logical Operator2'
     */
    rtb_LogicalOperator4_o = !rtb_LogicalOperator4_j;

    /* Outputs for Atomic SubSystem: '<S2262>/Accumulator Reset Limited' */
    /* Switch: '<S2268>/Switch1' incorporates:
     *  Logic: '<S2237>/Logical1'
     *  Logic: '<S2237>/Logical2'
     */
    if (rtb_Equal2_o || rtb_LogicalOperator4_o)
    {
        /* Switch: '<S2268>/Switch1' incorporates:
         *  Constant: '<S2262>/Constant Value1'
         */
        rtb_Switch3_fg = 0.0F;
    }
    else
    {
        /* Sum: '<S2268>/Summation' incorporates:
         *  UnitDelay: '<S2268>/Unit Delay'
         */
        rtb_Switch3_fg = VeESSR_n_StrtEngCSErr + localDW->UnitDelay_DSTATE;

        /* Outputs for Atomic SubSystem: '<S2268>/Limiter' */
        /* Switch: '<S2275>/Switch1' incorporates:
         *  Constant: '<S2272>/Calib'
         *  RelationalOperator: '<S2275>/Relational Operator'
         */
        if (KeESSR_n_StrtEngCSMaxIntgrlVal < rtb_Switch3_fg)
        {
            /* Switch: '<S2275>/Switch1' */
            rtb_Switch3_fg = KeESSR_n_StrtEngCSMaxIntgrlVal;
        }

        /* End of Switch: '<S2275>/Switch1' */

        /* Switch: '<S2275>/Switch' incorporates:
         *  Constant: '<S2273>/Calib'
         *  RelationalOperator: '<S2275>/Relational Operator1'
         */
        if (rtb_Switch3_fg <= KeESSR_n_StrtEngCSMinIntgrlVal)
        {
            /* Switch: '<S2268>/Switch1' */
            rtb_Switch3_fg = KeESSR_n_StrtEngCSMinIntgrlVal;
        }

        /* End of Switch: '<S2275>/Switch' */
        /* End of Outputs for SubSystem: '<S2268>/Limiter' */
    }

    /* End of Switch: '<S2268>/Switch1' */

    /* Update for UnitDelay: '<S2268>/Unit Delay' */
    localDW->UnitDelay_DSTATE = rtb_Switch3_fg;

    /* End of Outputs for SubSystem: '<S2262>/Accumulator Reset Limited' */

    /* RelationalOperator: '<S2262>/Comparison4' incorporates:
     *  Constant: '<S2272>/Calib'
     */
    VeESSR_b_StrtEngCSSpdChk = (rtb_Switch3_fg == KeESSR_n_StrtEngCSMaxIntgrlVal);

    /* RelationalOperator: '<S2262>/Comparison1' incorporates:
     *  Constant: '<S2270>/Calib'
     */
    VeESSR_b_StrtEngCSCltchTrqChk = (rtb_Sum2_e1o >=
        KeESSR_M_StrtEngCSMaxNegCltchTrq);

    /* Logic: '<S2262>/Logical' */
    VeESSR_b_StrEngSpdChkCSFnl = ((VeESSR_b_StrtEngCSSpdChk) &&
        (VeESSR_b_StrtEngCSCltchTrqChk));

    /* Logic: '<S2237>/Logical Operator5' incorporates:
     *  Constant: '<S2263>/Constant'
     *  Constant: '<S2264>/Constant'
     *  Logic: '<S2237>/Logical13'
     *  RelationalOperator: '<S2237>/Comparison5'
     *  RelationalOperator: '<S2237>/Comparison6'
     */
    rtb_Equal2_o = ((((uint32)rtu_VeENGR_e_ETRQ_Mode) == CeENGR_e_DriverControl)
                    || (((uint32)rtu_VeENGR_e_ETRQ_Mode) == CeENGR_e_Idle));

    /* Logic: '<S2237>/AND' incorporates:
     *  Constant: '<S2265>/Calib'
     *  Constant: '<S2266>/Calib'
     *  Constant: '<S2267>/Calib'
     *  DataStoreRead: '<S2237>/Dsr_STMTmr2'
     *  Logic: '<S2237>/Logical6'
     *  Logic: '<S2237>/Logical7'
     *  Logic: '<S2237>/Logical9'
     *  RelationalOperator: '<S2237>/Greater  Than2'
     *  RelationalOperator: '<S2237>/Greater  Than4'
     *  RelationalOperator: '<S2237>/Relational Operator1'
     */
    VeESSR_b_StrtEngCSRunDtct = ((rtb_LogicalOperator4_j && ((VeESSR_t_STMTmr_DS
        > KeESSR_t_StrtEngCSHoldTm) || ((VeESSR_t_STMTmr_DS >
        KeESSR_t_StrtEngCSHoldTmMin) && (rtb_Sum1_f2 <
        KeESSR_M_StrtEngCSTqExitDelta)))) && ((VeESSR_b_StrEngSpdChkCSFnl) &&
        rtb_Equal2_o));

    /* Switch: '<S2243>/Switch1' incorporates:
     *  Constant: '<S2235>/Constant'
     *  DataStoreWrite: '<S2230>/Dsw_STMTrigger1'
     *  Switch: '<S2243>/Switch2'
     */
    if (VeESSR_b_StrtEngCSRunDtct)
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngRun;
    }
    else
    {
        if (rtb_GreaterThan1_li)
        {
            /* Switch: '<S2230>/Switch' incorporates:
             *  Switch: '<S2230>/Switch2'
             *  Switch: '<S2243>/Switch2'
             */
            if (rtu_ClthSpinupErlyExitLmp)
            {
                /* Switch: '<S2243>/Switch1' incorporates:
                 *  Constant: '<S2234>/Constant'
                 *  DataStoreWrite: '<S2230>/Dsw_STMTrigger1'
                 *  Switch: '<S2230>/Switch'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;
            }
            else if (rtb_Logical8_kf)
            {
                /* Switch: '<S2230>/Switch2' incorporates:
                 *  Constant: '<S2233>/Constant'
                 *  DataStoreWrite: '<S2230>/Dsw_STMTrigger1'
                 *  Switch: '<S2230>/Switch'
                 *  Switch: '<S2243>/Switch1'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_StopReq;
            }
            else
            {
                /* Switch: '<S2243>/Switch1' incorporates:
                 *  Constant: '<S2232>/Constant'
                 *  DataStoreWrite: '<S2230>/Dsw_STMTrigger1'
                 *  Switch: '<S2230>/Switch'
                 *  Switch: '<S2230>/Switch2'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;
            }

            /* End of Switch: '<S2230>/Switch' */
        }
    }

    /* End of Switch: '<S2243>/Switch1' */

    /* Logic: '<S2237>/Logical Operator3' incorporates:
     *  Logic: '<S2237>/Logical Operator1'
     */
    rtb_Logical8_kf = ((!VeESSR_b_StrEngSpdChkCSFnl) && rtb_GreaterThan1_li);

    /* Logic: '<S2237>/Logical Operator4' */
    rtb_LogicalOperator4_o = (rtb_LogicalOperator4_o && rtb_GreaterThan1_li);

    /* Logic: '<S2237>/Logical Operator5' incorporates:
     *  Logic: '<S2237>/Logical17'
     */
    rtb_Equal2_o = (rtb_GreaterThan1_li && (!rtb_Equal2_o));

    /* Logic: '<S2237>/Logical5' */
    rtb_GreaterThan1_li = ((rtb_Logical8_kf || rtb_LogicalOperator4_o) ||
                           rtb_Equal2_o);

    /* If: '<S2230>/If' incorporates:
     *  DataStoreRead: '<S2230>/Data Store Read'
     *  Logic: '<S2230>/Logical11'
     *  Logic: '<S2230>/Logical2'
     */
    if ((!VeESSR_b_AStrtReattmptAllowed_DS) && rtb_GreaterThan1_li)
    {
        /* Outputs for IfAction SubSystem: '<S2230>/If_StartEng_P1C64' incorporates:
         *  ActionPort: '<S2245>/Action Port'
         */
        /* DataStoreWrite: '<S2230>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_StartEng_P1C64((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S2230>/If_StartEng_P1C64' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2230>/If_StartEng_NoFault' incorporates:
         *  ActionPort: '<S2244>/Action Port'
         */
        /* DataStoreWrite: '<S2230>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_KeyCrank_NoFault((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S2230>/If_StartEng_NoFault' */
    }

    /* End of If: '<S2230>/If' */

    /* Switch: '<S2237>/Switch2' incorporates:
     *  S-Function (sfix_bitop): '<S2259>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator4_o)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 512U;
    }

    /* End of Switch: '<S2237>/Switch2' */

    /* Switch: '<S2237>/Switch3' incorporates:
     *  S-Function (sfix_bitop): '<S2261>/FixPt Bitwise Operator1'
     */
    if (rtb_Equal2_o)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 536870912U;
    }

    /* End of Switch: '<S2237>/Switch3' */

    /* Switch: '<S2237>/Switch4' incorporates:
     *  S-Function (sfix_bitop): '<S2258>/FixPt Bitwise Operator1'
     */
    if (rtb_Logical8_kf)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 256U;
    }

    /* End of Switch: '<S2237>/Switch4' */

    /* Switch: '<S2237>/Switch1' incorporates:
     *  Constant: '<S2237>/Constant Value'
     *  DataStoreRead: '<S2237>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S2237>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S2237>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S2237>/Logical21'
     *  RelationalOperator: '<S2237>/Comparison'
     *  S-Function (sfix_bitop): '<S2237>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S2260>/FixPt Bitwise Operator1'
     */
    if (rtb_GreaterThan1_li && ((VeESSR_g_StrtStpFailPhaseSelect_DS & 8388608U) >
         0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 8388608U;
    }

    /* End of Switch: '<S2237>/Switch1' */
}

#endif

/* System initialize for function-call system: '<S568>/ESSC_SpinUp_EM_Dur' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_SpinUp_EM_Dur_Init(P2VAR
    (DW_ESSC_SpinUp_EM_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW)
{
    /* InitializeConditions for Delay: '<S1809>/IntegerDelay' */
    localDW->icLoad = 1U;
}

#endif

/* Output and update for function-call system: '<S568>/ESSC_SpinUp_EM_Dur' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_SpinUp_EM_Dur(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_EngTrqAct_Lmtd, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_AddtlDragTorq, VAR(float32, AUTOMATIC)
    rtu_VeESSR_n_TransInSpdFlt, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngCapacityMinRunI, VAR(float32, AUTOMATIC) rtu_BatVoltModMin,
    VAR(float32, AUTOMATIC) rtu_VeETQR_M_EngTrqActual, VAR(float32, AUTOMATIC)
    rtu_VeETQR_r_MaxSparkAuthority, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngineLosses, VAR(float32, AUTOMATIC)
    rtu_VeENGR_p_EngManfldAbsPrs, VAR(boolean, AUTOMATIC)
    rtu_VeRTMR_b_InPlantMode, VAR(float32, AUTOMATIC) rtu_VeHSER_n_NiMax, VAR
    (float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMax, VAR(float32, AUTOMATIC)
    rtu_VeHSER_dn_NiDotMin, VAR(boolean, AUTOMATIC) rtu_EMErlyExitLmp, VAR
    (float32, AUTOMATIC) rtu_TiEStMin, P2VAR(DW_ESSC_SpinUp_EM_Dur_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR(ZCE_ESSC_SpinUp_EM_Dur_ESSR_a_T,
    AUTOMATIC, ESSR_VAR_INIT) localZCE, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn)
{
    sint32 i;
    float32 rtb_Abs2_g34;
    float32 rtb_Gain1_bn;
    float32 rtb_Gain_dgb;
    float32 rtb_Gain_ow;
    float32 rtb_IntegerDelay;
    float32 rtb_MinMax1_pk;
    float32 rtb_Product4;
    float32 rtb_Product4_i;
    float32 rtb_Sum15;
    float32 rtb_Sum2_ml;
    float32 rtb_Sum6_bz;
    float32 rtb_Summation_hp;
    float32 rtb_Switch1_dh;
    float32 rtb_Switch1_khn;
    float32 rtb_Switch_j34;
    float32 rtb_UnitDelay_k;
    uint8 tmp;
    boolean rtb_Equal2_o;
    boolean rtb_GreaterThan3_ja;
    boolean rtb_LeESSR_b_SpinUp_CoastDownTr;
    boolean rtb_LogicalOperator3_d;
    boolean rtb_LogicalOperator4_lh;
    boolean rtb_OR2_c;
    boolean rtb_OR_kx;
    boolean rtb_RelationalOperator1_bk;

    /* RelationalOperator: '<S1765>/Equal2' incorporates:
     *  Constant: '<S1771>/Calib'
     *  DataStoreRead: '<S1765>/Dsr_STMTmr'
     */
    rtb_Equal2_o = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

    /* Outputs for Atomic SubSystem: '<S1765>/Digital Lowpass Reset Enabled' */
    /* Switch: '<S1770>/Switch1' */
    if (rtb_Equal2_o)
    {
        /* Switch: '<S1770>/Switch1' incorporates:
         *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile7'
         */
        VeESSR_M_SpinUpEM_ISpdCtl = VeESSR_M_EngTorqEst_DS;
    }
    else
    {
        /* Switch: '<S1770>/Switch1' incorporates:
         *  Constant: '<S1774>/Calib'
         *  Product: '<S1770>/Multiplication'
         *  Sum: '<S1765>/Sum1'
         *  Sum: '<S1770>/Subtraction'
         *  Sum: '<S1770>/Summation'
         *  UnitDelay: '<S1770>/Unit Delay'
         */
        VeESSR_M_SpinUpEM_ISpdCtl = (((rtu_VeESSR_M_EngTrqAct_Lmtd -
            rtu_VeESSR_M_AddtlDragTorq) - VeESSR_M_SpinUpEM_ISpdCtl) *
            KeESSR_K_TiEstBlndEMspinup) + VeESSR_M_SpinUpEM_ISpdCtl;
    }

    /* End of Switch: '<S1770>/Switch1' */
    /* End of Outputs for SubSystem: '<S1765>/Digital Lowpass Reset Enabled' */

    /* DataStoreWrite: '<S1765>/Data Store Write' */
    VeESSR_M_TiEstEMOpnLp = VeESSR_M_SpinUpEM_ISpdCtl;

    /* Gain: '<S1778>/Gain' incorporates:
     *  Abs: '<S1778>/Abs1'
     *  DataStoreRead: '<S1765>/Dsr_NiProfGenDNiDLim1'
     */
    rtb_Gain_ow = -fabsf(VeESSR_dn_StrtTypJerkMin_DS);

    /* Product: '<S1809>/Product4' incorporates:
     *  Constant: '<S1771>/Calib'
     */
    rtb_Product4 = rtb_Gain_ow / HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1765>/ChkSpinUpEng_EM' */
    /* RelationalOperator: '<S1825>/Relational Operator1' incorporates:
     *  DataStoreRead: '<S1769>/Dsr_AStrtSpinUpExtSpd'
     *  RelationalOperator: '<S1769>/Greater  Than'
     */
    rtb_RelationalOperator1_bk = (rtu_VeESSR_n_TransInSpdFlt >
        VeESSR_n_StrtTypAStrtSpinUpExtSpd_DS);

    /* RelationalOperator: '<S1769>/Greater  Than3' incorporates:
     *  Constant: '<S1796>/Calib'
     *  DataStoreRead: '<S1769>/Dsr_STMTmr1'
     */
    rtb_GreaterThan3_ja = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmSpinUp_EM);

    /* Logic: '<S1769>/Logical Operator9' incorporates:
     *  Logic: '<S1769>/Logical Operator10'
     */
    rtb_LeESSR_b_SpinUp_CoastDownTr = !rtu_EMErlyExitLmp;

    /* Logic: '<S1769>/Logical Operator3' incorporates:
     *  Logic: '<S1769>/Logical Operator'
     */
    rtb_LogicalOperator3_d = (((!rtb_RelationalOperator1_bk) &&
        rtb_GreaterThan3_ja) && rtb_LeESSR_b_SpinUp_CoastDownTr);

    /* Switch: '<S1769>/Switch' */
    if (rtb_LogicalOperator3_d)
    {
        /* DataStoreWrite: '<S1769>/Data Store Write' incorporates:
         *  S-Function (sfix_bitop): '<S1780>/FixPt Bitwise Operator1'
         *  Switch: '<S1769>/Switch'
         */
        *rtd_NeESSR_g_StrtStpFailRsn |= 32U;
    }

    /* End of Switch: '<S1769>/Switch' */

    /* Logic: '<S1769>/OR' incorporates:
     *  Constant: '<S1791>/Calib'
     *  DataStoreRead: '<S1769>/Dsr_InputSpeedProfile2'
     *  DataStoreRead: '<S1769>/Dsr_STMTmr2'
     *  DataStoreRead: '<S1769>/Dsr_StrtTypMapTargetMaxTm'
     *  Logic: '<S1769>/Logical Operator6'
     *  RelationalOperator: '<S1769>/Greater  Than1'
     *  RelationalOperator: '<S1769>/Greater  Than2'
     *  RelationalOperator: '<S1769>/Greater  Than6'
     */
    rtb_OR_kx = (((rtu_VeETQR_M_EngCapacityMinRunI <= VeESSR_M_EngTrqReqImmed_DS)
                  || ((VeESSR_t_STMTmr_DS > VeESSR_t_StrtTypAirflowTrqMaxTm_DS) ||
                      rtb_GreaterThan3_ja)) || (rtu_BatVoltModMin <
                  KeESSR_U_BatVoltModMin_ExitSpin));

    /* Logic: '<S1769>/Logical Operator4' incorporates:
     *  Logic: '<S1769>/Logical Operator1'
     */
    rtb_LogicalOperator4_lh = (((!rtb_OR_kx) && rtb_GreaterThan3_ja) &&
        rtb_LeESSR_b_SpinUp_CoastDownTr);

    /* Switch: '<S1769>/Switch2' */
    if (rtb_LogicalOperator4_lh)
    {
        /* DataStoreWrite: '<S1769>/Data Store Write1' incorporates:
         *  S-Function (sfix_bitop): '<S1781>/FixPt Bitwise Operator1'
         *  Switch: '<S1769>/Switch2'
         */
        *rtd_NeESSR_g_StrtStpFailRsn |= 64U;
    }

    /* End of Switch: '<S1769>/Switch2' */

    /* Logic: '<S1769>/OR2' incorporates:
     *  DataStoreRead: '<S1769>/Dsr_STMTmr4'
     *  DataStoreRead: '<S1769>/Dsr_StrtTypAStrtSpinUpManPrs'
     *  DataStoreRead: '<S1769>/Dsr_StrtTypMapTargetMaxTm2'
     *  Logic: '<S1769>/Logical Operator16'
     *  RelationalOperator: '<S1769>/Greater  Than10'
     *  RelationalOperator: '<S1769>/Greater  Than9'
     */
    rtb_OR2_c = ((rtu_VeENGR_p_EngManfldAbsPrs <
                  VeESSR_p_StrtTypAStrtSpinUpManPrs_DS) || ((VeESSR_t_STMTmr_DS >
                   VeESSR_t_StrtTypManPrsMaxTm_DS) || rtb_GreaterThan3_ja));

    /* Logic: '<S1769>/Logical Operator9' incorporates:
     *  Logic: '<S1769>/Logical Operator19'
     *  Logic: '<S1769>/Logical Operator21'
     */
    rtb_LeESSR_b_SpinUp_CoastDownTr = ((rtb_LeESSR_b_SpinUp_CoastDownTr &&
        (!rtb_OR2_c)) && rtb_GreaterThan3_ja);

    /* Switch: '<S1769>/Switch6' */
    if (rtb_LeESSR_b_SpinUp_CoastDownTr)
    {
        /* DataStoreWrite: '<S1769>/Data Store Write2' incorporates:
         *  S-Function (sfix_bitop): '<S1782>/FixPt Bitwise Operator1'
         *  Switch: '<S1769>/Switch6'
         */
        *rtd_NeESSR_g_StrtStpFailRsn |= 33554432U;
    }

    /* End of Switch: '<S1769>/Switch6' */

    /* Logic: '<S1769>/Logical Operator9' */
    rtb_LeESSR_b_SpinUp_CoastDownTr = (((rtb_LeESSR_b_SpinUp_CoastDownTr ||
        rtb_LogicalOperator3_d) || rtb_LogicalOperator4_lh) || rtu_EMErlyExitLmp);

    /* Switch: '<S1787>/Switch1' incorporates:
     *  Constant: '<S1769>/Constant Value1'
     *  Constant: '<S1769>/Constant Value3'
     *  DataStoreRead: '<S1769>/Dsr_STMTmr3'
     *  DataStoreRead: '<S1769>/Dsr_STMTmr6'
     *  DataStoreWrite: '<S1769>/Dsw_AStrtFailed1'
     *  Logic: '<S1769>/Logical4'
     *  RelationalOperator: '<S1769>/Greater  Than4'
     *  Sum: '<S1769>/Sum3'
     */
    if (rtb_LeESSR_b_SpinUp_CoastDownTr && (((sint32)
            VeESSR_Cnt_EMSpinupAttmptCntr_DS) < 255))
    {
        VeESSR_Cnt_EMSpinupAttmptCntr_DS = (uint8)(((uint32)
            VeESSR_Cnt_EMSpinupAttmptCntr_DS) + 1U);
    }

    /* End of Switch: '<S1787>/Switch1' */

    /* If: '<S1769>/If' incorporates:
     *  Constant: '<S1790>/Calib'
     *  DataStoreRead: '<S1769>/Dsr_STMTmr8'
     *  RelationalOperator: '<S1769>/Greater  Than5'
     */
    if (rtb_LogicalOperator3_d && (VeESSR_Cnt_EMSpinupAttmptCntr_DS >=
            KeESSR_Cnt_EMSpinupMaxAttmpts))
    {
        /* Outputs for IfAction SubSystem: '<S1769>/If_AutoStrt_P1C65' incorporates:
         *  ActionPort: '<S1789>/Action Port'
         */
        /* DataStoreWrite: '<S1769>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_AutoStrt_P1C65((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S1769>/If_AutoStrt_P1C65' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1769>/If_AutoStrt_NoFault' incorporates:
         *  ActionPort: '<S1788>/Action Port'
         */
        /* DataStoreWrite: '<S1769>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_AutoStrt_NoFault((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S1769>/If_AutoStrt_NoFault' */
    }

    /* End of If: '<S1769>/If' */

    /* Logic: '<S1769>/AND' */
    rtb_LogicalOperator3_d = ((rtb_RelationalOperator1_bk && rtb_OR_kx) &&
        rtb_OR2_c);

    /* End of Outputs for SubSystem: '<S1765>/ChkSpinUpEng_EM' */

    /* Outputs for Atomic SubSystem: '<S1778>/LowpassT Reset Enabled' */
    /* Sum: '<S1807>/Summation' incorporates:
     *  Constant: '<S1771>/Calib'
     *  Constant: '<S1795>/Calib'
     *  DataStoreRead: '<S1765>/Dsr_Ni1stFlt_DS'
     *  DataStoreRead: '<S1765>/Dsr_NiProfGenT2Gain'
     *  MinMax: '<S1807>/Maximum'
     *  Product: '<S1807>/Multiplication'
     *  Product: '<S1807>/Multiplication1'
     *  Sum: '<S1807>/Subtraction'
     */
    rtb_UnitDelay_k = (((KeESSR_n_NiTargetEMStrt - VeESSR_n_Ni1stFlt_DS) *
                        HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                        (VeESSR_k_StrtTypScndOrdLwPassT_DS, HeESSR_t_MedTEB_dT)))
        + VeESSR_n_Ni1stFlt_DS;

    /* End of Outputs for SubSystem: '<S1778>/LowpassT Reset Enabled' */

    /* Outputs for Atomic SubSystem: '<S1778>/LowpassT Reset Enabled1' */
    /* Sum: '<S1808>/Summation' incorporates:
     *  Constant: '<S1771>/Calib'
     *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile1'
     *  DataStoreRead: '<S1765>/Dsr_NiProfGenT1Gain'
     *  MinMax: '<S1808>/Maximum'
     *  Product: '<S1808>/Multiplication'
     *  Product: '<S1808>/Multiplication1'
     *  Sum: '<S1808>/Subtraction'
     */
    rtb_Summation_hp = (((rtb_UnitDelay_k - VeESSR_n_InputSpeedProfile_DS) *
                         HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                         (VeESSR_k_StrtTypFrstOrdLwPassT_DS, HeESSR_t_MedTEB_dT)))
        + VeESSR_n_InputSpeedProfile_DS;

    /* End of Outputs for SubSystem: '<S1778>/LowpassT Reset Enabled1' */

    /* Switch: '<S1828>/Switch1' incorporates:
     *  UnitDelay: '<S1828>/Unit Delay'
     */
    if (rtb_Equal2_o)
    {
        rtb_Gain1_bn = rtb_Summation_hp;
    }
    else
    {
        rtb_Gain1_bn = localDW->UnitDelay_DSTATE;
    }

    /* End of Switch: '<S1828>/Switch1' */

    /* Gain: '<S1809>/Gain1' incorporates:
     *  Sum: '<S1809>/Sum18'
     */
    rtb_Gain1_bn = (rtb_Summation_hp + rtb_Gain1_bn) * 0.5F;

    /* Delay: '<S1809>/IntegerDelay' incorporates:
     *  Constant: '<S1818>/Calib'
     */
    if (rtb_Equal2_o && (((uint32)localZCE->IntegerDelay_Reset_ZCE_j) !=
                         POS_ZCSIG))
    {
        localDW->icLoad = 1U;
    }

    localZCE->IntegerDelay_Reset_ZCE_j = rtb_Equal2_o ? ((ZCSigState)1) :
        ((ZCSigState)0);
    if (((sint32)localDW->icLoad) != 0)
    {
        for (i = 0; i < 16; i++)
        {
            localDW->IntegerDelay_DSTATE[i] = rtb_Gain1_bn;
        }
    }

    if (((sint32)KeESSR_Cnt_DelayOptNi) <= 0)
    {
        /* Delay: '<S1809>/IntegerDelay' */
        rtb_IntegerDelay = rtb_Gain1_bn;
    }
    else
    {
        if (((sint32)KeESSR_Cnt_DelayOptNi) > 16)
        {
            tmp = 16U;
        }
        else
        {
            tmp = KeESSR_Cnt_DelayOptNi;
        }

        /* Delay: '<S1809>/IntegerDelay' */
        rtb_IntegerDelay = localDW->IntegerDelay_DSTATE[(uint8)(16U - ((uint32)
            tmp))];
    }

    /* End of Delay: '<S1809>/IntegerDelay' */

    /* Sum: '<S1809>/Sum15' incorporates:
     *  Abs: '<S1809>/Abs4'
     *  Constant: '<S1775>/Calib'
     *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile5'
     */
    rtb_Sum15 = fabsf(VeESSR_dn_TargetAcceltn_DS) + KeESSR_dn_NiTargetJerkLimit;

    /* Outputs for Atomic SubSystem: '<S1809>/GradientLimiter' */
    /* Sum: '<S1811>/Sum2' incorporates:
     *  Constant: '<S1771>/Calib'
     *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile4'
     *  Product: '<S1809>/Product6'
     *  Sum: '<S1809>/Sum14'
     *  UnitDelay: '<S1811>/Unit Delay'
     */
    rtb_Sum2_ml = ((rtb_Gain1_bn - VeESSR_n_TargetSpeed_DS) / HeESSR_t_MedTEB_dT)
        - localDW->UnitDelay_DSTATE_o;

    /* Outputs for Atomic SubSystem: '<S1811>/Limiter' */
    /* Switch: '<S1829>/Switch1' incorporates:
     *  RelationalOperator: '<S1829>/Relational Operator'
     */
    if (rtb_Sum15 < rtb_Sum2_ml)
    {
        /* MinMax: '<S1812>/MinMax1' */
        rtb_MinMax1_pk = rtb_Sum15;
    }
    else
    {
        /* MinMax: '<S1812>/MinMax1' */
        rtb_MinMax1_pk = rtb_Sum2_ml;
    }

    /* End of Switch: '<S1829>/Switch1' */

    /* Switch: '<S1829>/Switch' incorporates:
     *  Gain: '<S1809>/Gain'
     *  RelationalOperator: '<S1829>/Relational Operator1'
     */
    if (rtb_MinMax1_pk <= (-rtb_Sum15))
    {
        rtb_MinMax1_pk = -rtb_Sum15;
    }

    /* End of Switch: '<S1829>/Switch' */
    /* End of Outputs for SubSystem: '<S1811>/Limiter' */

    /* Sum: '<S1811>/Sum3' incorporates:
     *  UnitDelay: '<S1811>/Unit Delay'
     */
    rtb_Gain_dgb = rtb_MinMax1_pk + localDW->UnitDelay_DSTATE_o;

    /* Update for UnitDelay: '<S1811>/Unit Delay' */
    localDW->UnitDelay_DSTATE_o = rtb_Gain_dgb;

    /* End of Outputs for SubSystem: '<S1809>/GradientLimiter' */

    /* Sum: '<S1810>/Subtraction1' incorporates:
     *  Constant: '<S1776>/Calib'
     *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile5'
     *  Product: '<S1810>/Multiplication'
     *  Sum: '<S1810>/Subtraction'
     */
    rtb_Gain_dgb = ((rtb_Gain_dgb - VeESSR_dn_TargetAcceltn_DS) *
                    KeESSR_k_NiDotTargetFilt) + VeESSR_dn_TargetAcceltn_DS;

    /* DataStoreRead: '<S1765>/Dsr_InputAcceltnProf' */
    rtb_Sum15 = VeESSR_dn_InputAcceltnProf_DS;

    /* Switch: '<S1773>/Switch1' incorporates:
     *  Constant: '<S1802>/Constant'
     *  Constant: '<S1803>/Calib'
     *  DataStoreRead: '<S1773>/Data Store Read'
     *  Logic: '<S1773>/Logical Operator'
     *  RelationalOperator: '<S1773>/Comparison4'
     */
    if ((((uint32)VeESSR_e_EngStartStopStPrev_DS) == CeESSR_e_InitEngSpinSt) &&
            (HeESSR_b_EnblMaxJerkSpinUp))
    {
        /* Outputs for Atomic SubSystem: '<S1773>/Protected Division' */
        /* Switch: '<S1806>/Switch1' incorporates:
         *  Constant: '<S1805>/Calib'
         *  Constant: '<S1806>/Constant Value'
         *  Constant: '<S1806>/Constant Value1'
         *  Constant: '<S1806>/Constant Value2'
         *  Constant: '<S1806>/Constant Value3'
         *  DataStoreRead: '<S1773>/Dsr_NiProfGenNiDMax'
         *  Logic: '<S1806>/AND'
         *  RelationalOperator: '<S1806>/Greater Than or Equal '
         *  RelationalOperator: '<S1806>/Greater Than or Equal 1'
         *  RelationalOperator: '<S1806>/Not Equal'
         *  RelationalOperator: '<S1806>/Not Equal1'
         *  Switch: '<S1806>/Switch2'
         *  Switch: '<S1806>/Switch3'
         */
        if ((VeESSR_dn_StrtTypNiDotMax_DS != 0.0F) &&
                (KeESSR_dn_InitJerkMaxSpinup != 0.0F))
        {
            /* Switch: '<S1806>/Switch1' incorporates:
             *  Product: '<S1806>/Division'
             */
            rtb_Sum2_ml = VeESSR_dn_StrtTypNiDotMax_DS /
                KeESSR_dn_InitJerkMaxSpinup;
        }
        else if (VeESSR_dn_StrtTypNiDotMax_DS > 0.0F)
        {
            /* Switch: '<S1806>/Switch2' incorporates:
             *  Constant: '<S1806>/MAXFLOAT'
             *  Switch: '<S1806>/Switch1'
             */
            rtb_Sum2_ml = 3.402823466E+38F;
        }
        else if (VeESSR_dn_StrtTypNiDotMax_DS < 0.0F)
        {
            /* Switch: '<S1806>/Switch3' incorporates:
             *  Constant: '<S1806>/MINFLOAT'
             *  Switch: '<S1806>/Switch1'
             *  Switch: '<S1806>/Switch2'
             */
            rtb_Sum2_ml = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1806>/Switch1' incorporates:
             *  Constant: '<S1806>/Constant Value4'
             *  Switch: '<S1806>/Switch2'
             *  Switch: '<S1806>/Switch3'
             */
            rtb_Sum2_ml = 0.0F;
        }

        /* End of Switch: '<S1806>/Switch1' */
        /* End of Outputs for SubSystem: '<S1773>/Protected Division' */

        /* Switch: '<S1773>/Switch' incorporates:
         *  Constant: '<S1804>/Calib'
         *  DataStoreRead: '<S1773>/Dsr_STMTmr1'
         *  Product: '<S1773>/Product'
         *  RelationalOperator: '<S1773>/Greater  Than3'
         *  Rounding: '<S1773>/Rounding1'
         */
        if (VeESSR_t_STMTmr_DS > (ceilf(rtb_Sum2_ml) * HeESSR_t_MedTEB_dT))
        {
            /* Switch: '<S1773>/Switch1' incorporates:
             *  DataStoreRead: '<S1773>/Dsr_NiProfGenDNiDLim'
             *  Switch: '<S1773>/Switch'
             */
            VeESSR_dn_JerkMaxSpinupEM = VeESSR_dn_StrtTypJerkMax_DS;
        }
        else
        {
            /* Switch: '<S1773>/Switch1' incorporates:
             *  Constant: '<S1805>/Calib'
             *  Switch: '<S1773>/Switch'
             */
            VeESSR_dn_JerkMaxSpinupEM = KeESSR_dn_InitJerkMaxSpinup;
        }

        /* End of Switch: '<S1773>/Switch' */
    }
    else
    {
        /* Switch: '<S1773>/Switch1' incorporates:
         *  DataStoreRead: '<S1773>/Dsr_NiProfGenDNiDLim1'
         */
        VeESSR_dn_JerkMaxSpinupEM = VeESSR_dn_StrtTypJerkMax_DS;
    }

    /* End of Switch: '<S1773>/Switch1' */

    /* Abs: '<S1778>/Abs' */
    rtb_MinMax1_pk = fabsf(VeESSR_dn_JerkMaxSpinupEM);

    /* Switch: '<S1840>/Switch1' incorporates:
     *  Constant: '<S1838>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S1840>/Switch1' incorporates:
         *  Constant: '<S1839>/Calib'
         */
        rtb_Switch1_dh = HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S1827>/Sum6' incorporates:
         *  DataStoreRead: '<S1765>/Dsr_InputAcceltnProf'
         *  Sum: '<S1827>/Sum8'
         */
        rtb_Switch1_dh = VeESSR_dn_InputAcceltnProf_DS - rtb_Gain_dgb;

        /* Abs: '<S1827>/Abs' incorporates:
         *  Sum: '<S1827>/Sum6'
         */
        rtb_Sum2_ml = (rtb_Switch1_dh - rtb_Gain_ow) + rtb_MinMax1_pk;

        /* MinMax: '<S1827>/MinMax2' incorporates:
         *  Abs: '<S1827>/Abs1'
         *  Constant: '<S1771>/Calib'
         *  Constant: '<S1827>/Constant Value'
         *  Constant: '<S1827>/Constant Value3'
         *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile1'
         *  Product: '<S1827>/Product2'
         *  Product: '<S1827>/Product7'
         *  Product: '<S1842>/Prod'
         *  Sum: '<S1827>/Sum3'
         *  Sum: '<S1827>/Sum5'
         */
        rtb_Sum2_ml = fmaxf((fabsf((rtb_IntegerDelay -
                               VeESSR_n_InputSpeedProfile_DS) -
                              (HeESSR_t_MedTEB_dT * rtb_Gain_dgb)) *
                             (rtb_Product4 * -2.0F)) - (rtb_Sum2_ml *
                             rtb_Sum2_ml), 0.0F);

        /* Switch: '<S1844>/Switch' incorporates:
         *  Sqrt: '<S1844>/Sqrt'
         */
        rtb_Sum2_ml = sqrtf(rtb_Sum2_ml);

        /* Switch: '<S1840>/Switch1' incorporates:
         *  Abs: '<S1827>/Abs'
         *  Sum: '<S1827>/Sum7'
         *  Sum: '<S1827>/Sum8'
         */
        rtb_Switch1_dh = fabsf(rtb_Switch1_dh + rtb_Gain_ow) + (rtb_Sum2_ml +
            rtb_Gain_dgb);
    }

    /* End of Switch: '<S1840>/Switch1' */

    /* Product: '<S1809>/Product1' incorporates:
     *  Constant: '<S1771>/Calib'
     */
    rtb_Sum2_ml = rtb_MinMax1_pk / HeESSR_t_MedTEB_dT;

    /* Switch: '<S1841>/Switch1' incorporates:
     *  Constant: '<S1838>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S1841>/Switch1' incorporates:
         *  Constant: '<S1839>/Calib'
         *  Gain: '<S1827>/Gain1'
         */
        rtb_Switch1_khn = -HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S1827>/Sum11' incorporates:
         *  DataStoreRead: '<S1765>/Dsr_InputAcceltnProf'
         *  Sum: '<S1827>/Sum13'
         */
        rtb_Switch_j34 = VeESSR_dn_InputAcceltnProf_DS - rtb_Gain_dgb;

        /* Abs: '<S1827>/Abs2' incorporates:
         *  Sum: '<S1827>/Sum11'
         */
        rtb_Abs2_g34 = (rtb_Switch_j34 - rtb_MinMax1_pk) + rtb_Gain_ow;

        /* MinMax: '<S1827>/MinMax1' incorporates:
         *  Abs: '<S1827>/Abs3'
         *  Constant: '<S1771>/Calib'
         *  Constant: '<S1827>/Constant Value1'
         *  Constant: '<S1827>/Constant Value2'
         *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile1'
         *  Product: '<S1827>/Product5'
         *  Product: '<S1827>/Product8'
         *  Product: '<S1845>/Prod'
         *  Sum: '<S1827>/Sum10'
         *  Sum: '<S1827>/Sum9'
         */
        rtb_Abs2_g34 = fmaxf((fabsf((rtb_IntegerDelay -
                                VeESSR_n_InputSpeedProfile_DS) -
                               (HeESSR_t_MedTEB_dT * rtb_Gain_dgb)) *
                              (rtb_Sum2_ml * 2.0F)) - (rtb_Abs2_g34 *
                              rtb_Abs2_g34), 0.0F);

        /* Switch: '<S1843>/Switch' incorporates:
         *  Sqrt: '<S1843>/Sqrt'
         */
        rtb_Abs2_g34 = sqrtf(rtb_Abs2_g34);

        /* Switch: '<S1841>/Switch1' incorporates:
         *  Abs: '<S1827>/Abs2'
         *  Sum: '<S1827>/Sum12'
         *  Sum: '<S1827>/Sum13'
         */
        rtb_Switch1_khn = (rtb_Gain_dgb - rtb_Abs2_g34) - fabsf(rtb_Switch_j34 +
            rtb_MinMax1_pk);
    }

    /* End of Switch: '<S1841>/Switch1' */

    /* Switch: '<S1809>/Switch1' incorporates:
     *  Constant: '<S1814>/Calib'
     *  Constant: '<S1815>/Calib'
     *  DataStoreRead: '<S1765>/Data Store Read'
     *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile8'
     *  Logic: '<S1809>/Logical1'
     *  Logic: '<S1809>/Logical6'
     *  Logic: '<S1809>/Logical8'
     */
    if (((HeESSR_b_NiLmtBypsLoopJerk) && (VeESSR_b_NiMaxActive_DS)) ||
            ((VeESSR_b_NiDotMaxActive_DS) && (HeESSR_b_NiDotLmtBypsLoopJerk)))
    {
        /* Switch: '<S1809>/Switch1' */
        rtb_MinMax1_pk = rtb_Switch1_dh;
    }
    else
    {
        /* Switch: '<S1809>/Switch1' incorporates:
         *  DataStoreRead: '<S1765>/Dsr_InputAcceltnProf'
         *  Sum: '<S1809>/Sum1'
         */
        rtb_MinMax1_pk += VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S1809>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S1809>/Limiter2' */
    /* Switch: '<S1822>/Switch1' incorporates:
     *  RelationalOperator: '<S1822>/Relational Operator'
     */
    if (rtb_Switch1_dh < rtb_MinMax1_pk)
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = rtb_Switch1_dh;
    }
    else
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = rtb_MinMax1_pk;
    }

    /* End of Switch: '<S1822>/Switch1' */

    /* Switch: '<S1822>/Switch' incorporates:
     *  RelationalOperator: '<S1822>/Relational Operator1'
     */
    if (rtb_Abs2_g34 > rtb_Switch1_khn)
    {
        /* Switch: '<S1822>/Switch' */
        rtb_MinMax1_pk = rtb_Abs2_g34;
    }
    else
    {
        /* Switch: '<S1822>/Switch' */
        rtb_MinMax1_pk = rtb_Switch1_khn;
    }

    /* End of Switch: '<S1822>/Switch' */
    /* End of Outputs for SubSystem: '<S1809>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S1809>/Limiter4' */
    /* Switch: '<S1824>/Switch1' incorporates:
     *  DataStoreRead: '<S1765>/Dsr_NiProfGenNiDMax'
     *  RelationalOperator: '<S1824>/Relational Operator'
     */
    if (VeESSR_dn_StrtTypNiDotMax_DS < rtb_MinMax1_pk)
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = VeESSR_dn_StrtTypNiDotMax_DS;
    }
    else
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = rtb_MinMax1_pk;
    }

    /* End of Switch: '<S1824>/Switch1' */

    /* Switch: '<S1824>/Switch' incorporates:
     *  DataStoreRead: '<S1765>/Dsr_NiProfGenNiDMin'
     *  RelationalOperator: '<S1824>/Relational Operator1'
     */
    if (rtb_Abs2_g34 > VeESSR_dn_StrtTypNiDotMin_DS)
    {
        /* Switch: '<S1824>/Switch' */
        rtb_Switch_j34 = rtb_Abs2_g34;
    }
    else
    {
        /* Switch: '<S1824>/Switch' */
        rtb_Switch_j34 = VeESSR_dn_StrtTypNiDotMin_DS;
    }

    /* End of Switch: '<S1824>/Switch' */
    /* End of Outputs for SubSystem: '<S1809>/Limiter4' */

    /* Sum: '<S1813>/Sum6' incorporates:
     *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile1'
     */
    rtb_Sum6_bz = rtu_VeHSER_n_NiMax - VeESSR_n_InputSpeedProfile_DS;

    /* Abs: '<S1813>/Abs2' */
    rtb_Abs2_g34 = fabsf(rtb_Sum6_bz);

    /* Switch: '<S1813>/Switch' incorporates:
     *  Constant: '<S1813>/Constant Value7'
     *  RelationalOperator: '<S1813>/Comparison2'
     */
    if (rtb_Sum6_bz < 0.0F)
    {
        /* MinMax: '<S1812>/MinMax1' incorporates:
         *  Abs: '<S1813>/Abs'
         */
        rtb_MinMax1_pk = fabsf(rtb_Sum2_ml);
    }
    else
    {
        /* MinMax: '<S1812>/MinMax1' incorporates:
         *  Abs: '<S1813>/Abs1'
         *  Gain: '<S1813>/Gain'
         */
        rtb_MinMax1_pk = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S1813>/Switch' */

    /* Product: '<S1813>/Product4' incorporates:
     *  Constant: '<S1771>/Calib'
     */
    rtb_Product4_i = (rtb_MinMax1_pk * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1813>/Protected Division1' */
    /* Switch: '<S1836>/Switch1' incorporates:
     *  Constant: '<S1836>/Constant Value'
     *  Constant: '<S1836>/Constant Value1'
     *  Constant: '<S1836>/Constant Value2'
     *  Logic: '<S1836>/AND'
     *  RelationalOperator: '<S1836>/Greater Than or Equal '
     *  RelationalOperator: '<S1836>/Not Equal'
     *  RelationalOperator: '<S1836>/Not Equal1'
     *  Switch: '<S1836>/Switch2'
     */
    if ((rtb_Abs2_g34 != 0.0F) && (rtb_Product4_i != 0.0F))
    {
        /* Switch: '<S1836>/Switch1' incorporates:
         *  Product: '<S1836>/Division'
         */
        rtb_Abs2_g34 /= rtb_Product4_i;
    }
    else if (rtb_Abs2_g34 > 0.0F)
    {
        /* Switch: '<S1836>/Switch2' incorporates:
         *  Constant: '<S1836>/MAXFLOAT'
         *  Switch: '<S1836>/Switch1'
         */
        rtb_Abs2_g34 = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1836>/Switch1' incorporates:
         *  Constant: '<S1836>/Constant Value4'
         *  Switch: '<S1836>/Switch2'
         *  Switch: '<S1836>/Switch3'
         */
        rtb_Abs2_g34 = 0.0F;
    }

    /* End of Switch: '<S1836>/Switch1' */
    /* End of Outputs for SubSystem: '<S1813>/Protected Division1' */

    /* Sum: '<S1813>/Sum4' incorporates:
     *  Abs: '<S1813>/Abs3'
     *  Constant: '<S1813>/Constant Value3'
     *  Constant: '<S1813>/Constant Value5'
     *  Product: '<S1813>/Product3'
     */
    rtb_Abs2_g34 = (fabsf(rtb_Abs2_g34) * 8.0F) + 1.0F;

    /* Switch: '<S1837>/Switch' */
    if (rtb_Abs2_g34 >= 0.0F)
    {
        /* Sum: '<S1765>/Summation4' incorporates:
         *  Sqrt: '<S1837>/Sqrt'
         */
        rtb_Abs2_g34 = sqrtf(rtb_Abs2_g34);
    }
    else
    {
        /* Sum: '<S1765>/Summation4' incorporates:
         *  Constant: '<S1837>/Zero'
         */
        rtb_Abs2_g34 = 0.0F;
    }

    /* End of Switch: '<S1837>/Switch' */

    /* Sum: '<S1765>/Summation4' incorporates:
     *  Constant: '<S1813>/Constant Value'
     *  Constant: '<S1813>/Constant Value4'
     *  Constant: '<S1813>/Constant Value6'
     *  MinMax: '<S1813>/MinMax1'
     *  Product: '<S1813>/Product2'
     *  Rounding: '<S1813>/Rounding1'
     *  Sum: '<S1813>/Sum3'
     */
    rtb_Abs2_g34 = fmaxf(ceilf((rtb_Abs2_g34 - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S1813>/Product' incorporates:
     *  Constant: '<S1771>/Calib'
     */
    rtb_Product4_i = rtb_Abs2_g34 * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1813>/Protected Division' */
    /* Switch: '<S1835>/Switch1' incorporates:
     *  Constant: '<S1835>/Constant Value'
     *  Constant: '<S1835>/Constant Value1'
     *  Constant: '<S1835>/Constant Value2'
     *  Constant: '<S1835>/Constant Value3'
     *  Logic: '<S1835>/AND'
     *  RelationalOperator: '<S1835>/Greater Than or Equal '
     *  RelationalOperator: '<S1835>/Greater Than or Equal 1'
     *  RelationalOperator: '<S1835>/Not Equal'
     *  RelationalOperator: '<S1835>/Not Equal1'
     *  Switch: '<S1835>/Switch2'
     *  Switch: '<S1835>/Switch3'
     */
    if ((rtb_Sum6_bz != 0.0F) && (rtb_Product4_i != 0.0F))
    {
        /* Switch: '<S1835>/Switch1' incorporates:
         *  Product: '<S1835>/Division'
         */
        rtb_Sum6_bz /= rtb_Product4_i;
    }
    else if (rtb_Sum6_bz > 0.0F)
    {
        /* Switch: '<S1835>/Switch2' incorporates:
         *  Constant: '<S1835>/MAXFLOAT'
         *  Switch: '<S1835>/Switch1'
         */
        rtb_Sum6_bz = 3.402823466E+38F;
    }
    else if (rtb_Sum6_bz < 0.0F)
    {
        /* Switch: '<S1835>/Switch3' incorporates:
         *  Constant: '<S1835>/MINFLOAT'
         *  Switch: '<S1835>/Switch1'
         *  Switch: '<S1835>/Switch2'
         */
        rtb_Sum6_bz = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1835>/Switch1' incorporates:
         *  Constant: '<S1835>/Constant Value4'
         *  Switch: '<S1835>/Switch2'
         *  Switch: '<S1835>/Switch3'
         */
        rtb_Sum6_bz = 0.0F;
    }

    /* End of Switch: '<S1835>/Switch1' */
    /* End of Outputs for SubSystem: '<S1813>/Protected Division' */

    /* Sum: '<S1813>/Sum' incorporates:
     *  Constant: '<S1771>/Calib'
     *  Constant: '<S1813>/Constant Value1'
     *  Constant: '<S1813>/Constant Value2'
     *  Product: '<S1813>/Product1'
     *  Sum: '<S1813>/Sum2'
     */
    rtb_MinMax1_pk = rtb_Sum6_bz - (((0.5F * rtb_MinMax1_pk) * (rtb_Abs2_g34 -
        1.0F)) * HeESSR_t_MedTEB_dT);

    /* Switch: '<S1809>/Switch4' incorporates:
     *  Constant: '<S1816>/Calib'
     */
    if (!HeESSR_b_NiLmtForAccelByps)
    {
        /* Switch: '<S1809>/Switch4' incorporates:
         *  MinMax: '<S1809>/MinMax1'
         */
        rtb_Switch_j34 = fminf(rtb_MinMax1_pk, rtb_Switch_j34);
    }

    /* End of Switch: '<S1809>/Switch4' */

    /* Outputs for Atomic SubSystem: '<S1809>/Limiter13' */
    /* RelationalOperator: '<S1821>/Relational Operator' */
    rtb_Equal2_o = (rtu_VeHSER_dn_NiDotMax <= rtb_Switch_j34);

    /* Switch: '<S1821>/Switch1' */
    if (rtb_Equal2_o)
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = rtu_VeHSER_dn_NiDotMax;
    }
    else
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = rtb_Switch_j34;
    }

    /* End of Switch: '<S1821>/Switch1' */

    /* Switch: '<S1821>/Switch' incorporates:
     *  RelationalOperator: '<S1821>/Relational Operator1'
     */
    if (rtb_Abs2_g34 <= rtu_VeHSER_dn_NiDotMin)
    {
        rtb_Abs2_g34 = rtu_VeHSER_dn_NiDotMin;
    }

    /* End of Switch: '<S1821>/Switch' */
    /* End of Outputs for SubSystem: '<S1809>/Limiter13' */

    /* Product: '<S1809>/Product9' incorporates:
     *  Constant: '<S1771>/Calib'
     */
    rtb_Switch_j34 = rtb_Abs2_g34 * HeESSR_t_MedTEB_dT;

    /* Switch: '<S1809>/Switch2' incorporates:
     *  Constant: '<S1814>/Calib'
     *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile9'
     *  Logic: '<S1809>/Logical3'
     */
    if ((HeESSR_b_NiDotLmtBypsLoopJerk) && (VeESSR_b_NiDotMinActive_DS))
    {
        /* Switch: '<S1809>/Switch2' */
        rtb_Gain_ow = rtb_Switch1_khn;
    }
    else
    {
        /* Switch: '<S1809>/Switch2' incorporates:
         *  DataStoreRead: '<S1765>/Dsr_InputAcceltnProf'
         *  Sum: '<S1809>/Sum16'
         */
        rtb_Gain_ow += VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S1809>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S1809>/Limiter' */
    /* Switch: '<S1819>/Switch1' incorporates:
     *  RelationalOperator: '<S1819>/Relational Operator'
     */
    if (rtb_Switch1_dh < rtb_Gain_ow)
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = rtb_Switch1_dh;
    }
    else
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = rtb_Gain_ow;
    }

    /* End of Switch: '<S1819>/Switch1' */

    /* Switch: '<S1819>/Switch' incorporates:
     *  RelationalOperator: '<S1819>/Relational Operator1'
     */
    if (rtb_Abs2_g34 > rtb_Switch1_khn)
    {
        /* Switch: '<S1819>/Switch' */
        rtb_Gain_ow = rtb_Abs2_g34;
    }
    else
    {
        /* Switch: '<S1819>/Switch' */
        rtb_Gain_ow = rtb_Switch1_khn;
    }

    /* End of Switch: '<S1819>/Switch' */
    /* End of Outputs for SubSystem: '<S1809>/Limiter' */

    /* Outputs for Atomic SubSystem: '<S1809>/Limiter3' */
    /* Switch: '<S1823>/Switch1' incorporates:
     *  DataStoreRead: '<S1765>/Dsr_NiProfGenNiDMax'
     *  RelationalOperator: '<S1823>/Relational Operator'
     */
    if (VeESSR_dn_StrtTypNiDotMax_DS < rtb_Gain_ow)
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = VeESSR_dn_StrtTypNiDotMax_DS;
    }
    else
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = rtb_Gain_ow;
    }

    /* End of Switch: '<S1823>/Switch1' */
    /* End of Outputs for SubSystem: '<S1809>/Limiter3' */

    /* Switch: '<S1809>/Switch5' incorporates:
     *  Constant: '<S1816>/Calib'
     *  DataStoreRead: '<S1765>/Dsr_NiProfGenNiDMin'
     *  RelationalOperator: '<S1823>/Relational Operator1'
     *  Switch: '<S1823>/Switch'
     */
    if (HeESSR_b_NiLmtForAccelByps)
    {
        /* Outputs for Atomic SubSystem: '<S1809>/Limiter3' */
        /* Switch: '<S1823>/Switch' incorporates:
         *  DataStoreRead: '<S1765>/Dsr_NiProfGenNiDMin'
         *  RelationalOperator: '<S1823>/Relational Operator1'
         */
        if (rtb_Abs2_g34 > VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S1809>/Switch5' */
            rtb_Gain_ow = rtb_Abs2_g34;
        }
        else
        {
            /* Switch: '<S1809>/Switch5' */
            rtb_Gain_ow = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Outputs for SubSystem: '<S1809>/Limiter3' */
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S1809>/Limiter3' */
        if (rtb_Abs2_g34 <= VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S1823>/Switch' incorporates:
             *  DataStoreRead: '<S1765>/Dsr_NiProfGenNiDMin'
             */
            rtb_Abs2_g34 = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Outputs for SubSystem: '<S1809>/Limiter3' */

        /* Switch: '<S1809>/Switch5' incorporates:
         *  MinMax: '<S1809>/MinMax2'
         */
        rtb_Gain_ow = fminf(rtb_MinMax1_pk, rtb_Abs2_g34);
    }

    /* End of Switch: '<S1809>/Switch5' */

    /* Outputs for Atomic SubSystem: '<S1809>/Limiter9' */
    /* Switch: '<S1826>/Switch1' incorporates:
     *  RelationalOperator: '<S1826>/Relational Operator'
     */
    if (rtu_VeHSER_dn_NiDotMax <= rtb_Gain_ow)
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = rtu_VeHSER_dn_NiDotMax;
    }
    else
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = rtb_Gain_ow;
    }

    /* End of Switch: '<S1826>/Switch1' */

    /* RelationalOperator: '<S1825>/Relational Operator1' incorporates:
     *  RelationalOperator: '<S1826>/Relational Operator1'
     */
    rtb_RelationalOperator1_bk = (rtb_Abs2_g34 > rtu_VeHSER_dn_NiDotMin);

    /* Logic: '<S1826>/Logical2' */
    rtb_OR_kx = !rtb_RelationalOperator1_bk;

    /* Switch: '<S1826>/Switch' */
    if (!rtb_RelationalOperator1_bk)
    {
        rtb_Abs2_g34 = rtu_VeHSER_dn_NiDotMin;
    }

    /* End of Switch: '<S1826>/Switch' */
    /* End of Outputs for SubSystem: '<S1809>/Limiter9' */

    /* Product: '<S1809>/Product10' incorporates:
     *  Constant: '<S1771>/Calib'
     */
    rtb_Gain_ow = rtb_Abs2_g34 * HeESSR_t_MedTEB_dT;

    /* Sum: '<S1809>/Sum2' incorporates:
     *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile1'
     */
    rtb_Switch1_dh = rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS;

    /* Sum: '<S1812>/Sum6' incorporates:
     *  Constant: '<S1771>/Calib'
     *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile1'
     *  Product: '<S1812>/Product7'
     *  Sum: '<S1809>/Sum6'
     *  Switch: '<S1809>/Switch3'
     */
    rtb_IntegerDelay = (rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS) -
        (rtb_Gain_dgb * HeESSR_t_MedTEB_dT);

    /* Abs: '<S1812>/Abs2' incorporates:
     *  Sum: '<S1812>/Sum6'
     */
    rtb_MinMax1_pk = fabsf(rtb_IntegerDelay);

    /* Switch: '<S1812>/Switch' incorporates:
     *  Constant: '<S1812>/Constant Value7'
     *  RelationalOperator: '<S1812>/Comparison2'
     *  Sum: '<S1812>/Sum6'
     */
    if (rtb_IntegerDelay < 0.0F)
    {
        /* Sum: '<S1765>/Summation4' incorporates:
         *  Abs: '<S1812>/Abs'
         */
        rtb_Abs2_g34 = fabsf(rtb_Sum2_ml);
    }
    else
    {
        /* Sum: '<S1765>/Summation4' incorporates:
         *  Abs: '<S1812>/Abs1'
         *  Gain: '<S1812>/Gain'
         */
        rtb_Abs2_g34 = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S1812>/Switch' */

    /* Product: '<S1812>/Product4' incorporates:
     *  Constant: '<S1771>/Calib'
     */
    rtb_Product4 = (rtb_Abs2_g34 * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1812>/Protected Division1' */
    /* Switch: '<S1832>/Switch1' incorporates:
     *  Constant: '<S1832>/Constant Value'
     *  Constant: '<S1832>/Constant Value1'
     *  Constant: '<S1832>/Constant Value2'
     *  Logic: '<S1832>/AND'
     *  RelationalOperator: '<S1832>/Greater Than or Equal '
     *  RelationalOperator: '<S1832>/Not Equal'
     *  RelationalOperator: '<S1832>/Not Equal1'
     *  Switch: '<S1832>/Switch2'
     */
    if ((rtb_MinMax1_pk != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S1832>/Switch1' incorporates:
         *  Product: '<S1832>/Division'
         */
        rtb_Product4 = rtb_MinMax1_pk / rtb_Product4;
    }
    else if (rtb_MinMax1_pk > 0.0F)
    {
        /* Switch: '<S1832>/Switch2' incorporates:
         *  Constant: '<S1832>/MAXFLOAT'
         *  Switch: '<S1832>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1832>/Switch1' incorporates:
         *  Constant: '<S1832>/Constant Value4'
         *  Switch: '<S1832>/Switch2'
         *  Switch: '<S1832>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S1832>/Switch1' */
    /* End of Outputs for SubSystem: '<S1812>/Protected Division1' */

    /* Sum: '<S1812>/Sum4' incorporates:
     *  Abs: '<S1812>/Abs3'
     *  Constant: '<S1812>/Constant Value3'
     *  Constant: '<S1812>/Constant Value5'
     *  Product: '<S1812>/Product3'
     */
    rtb_Product4 = (fabsf(rtb_Product4) * 8.0F) + 1.0F;

    /* Switch: '<S1833>/Switch' incorporates:
     *  Constant: '<S1833>/Zero'
     *  Sqrt: '<S1833>/Sqrt'
     */
    if (rtb_Product4 >= 0.0F)
    {
        rtb_Product4 = sqrtf(rtb_Product4);
    }
    else
    {
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S1833>/Switch' */

    /* MinMax: '<S1812>/MinMax1' incorporates:
     *  Constant: '<S1812>/Constant Value'
     *  Constant: '<S1812>/Constant Value4'
     *  Constant: '<S1812>/Constant Value6'
     *  Product: '<S1812>/Product2'
     *  Rounding: '<S1812>/Rounding1'
     *  Sum: '<S1812>/Sum3'
     */
    rtb_MinMax1_pk = fmaxf(ceilf((rtb_Product4 - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S1812>/Product' incorporates:
     *  Constant: '<S1771>/Calib'
     */
    rtb_Product4 = rtb_MinMax1_pk * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1812>/Protected Division' */
    /* Switch: '<S1831>/Switch1' incorporates:
     *  Constant: '<S1831>/Constant Value'
     *  Constant: '<S1831>/Constant Value1'
     *  Constant: '<S1831>/Constant Value2'
     *  Constant: '<S1831>/Constant Value3'
     *  Logic: '<S1831>/AND'
     *  RelationalOperator: '<S1831>/Greater Than or Equal '
     *  RelationalOperator: '<S1831>/Greater Than or Equal 1'
     *  RelationalOperator: '<S1831>/Not Equal'
     *  RelationalOperator: '<S1831>/Not Equal1'
     *  Sum: '<S1812>/Sum6'
     *  Switch: '<S1831>/Switch2'
     *  Switch: '<S1831>/Switch3'
     */
    if ((rtb_IntegerDelay != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S1831>/Switch1' incorporates:
         *  Product: '<S1831>/Division'
         */
        rtb_Product4 = rtb_IntegerDelay / rtb_Product4;
    }
    else if (rtb_IntegerDelay > 0.0F)
    {
        /* Switch: '<S1831>/Switch2' incorporates:
         *  Constant: '<S1831>/MAXFLOAT'
         *  Switch: '<S1831>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else if (rtb_IntegerDelay < 0.0F)
    {
        /* Switch: '<S1831>/Switch3' incorporates:
         *  Constant: '<S1831>/MINFLOAT'
         *  Switch: '<S1831>/Switch1'
         *  Switch: '<S1831>/Switch2'
         */
        rtb_Product4 = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1831>/Switch1' incorporates:
         *  Constant: '<S1831>/Constant Value4'
         *  Switch: '<S1831>/Switch2'
         *  Switch: '<S1831>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S1831>/Switch1' */
    /* End of Outputs for SubSystem: '<S1812>/Protected Division' */

    /* Switch: '<S1809>/Switch3' incorporates:
     *  Constant: '<S1817>/Calib'
     */
    if (!HeESSR_b_TrnstnJerkByps)
    {
        /* Switch: '<S1809>/Switch8' incorporates:
         *  Constant: '<S1809>/Constant Value7'
         *  RelationalOperator: '<S1809>/Comparison'
         */
        if (rtb_IntegerDelay > 0.0F)
        {
            /* Switch: '<S1809>/Switch3' incorporates:
             *  Constant: '<S1771>/Calib'
             *  Constant: '<S1812>/Constant Value1'
             *  Constant: '<S1812>/Constant Value2'
             *  MinMax: '<S1809>/MinMax4'
             *  Product: '<S1809>/Product5'
             *  Product: '<S1812>/Product1'
             *  Sum: '<S1812>/Sum'
             *  Sum: '<S1812>/Sum2'
             *  Switch: '<S1809>/Switch8'
             */
            rtb_Switch1_dh = fminf(rtb_Switch1_dh, ((rtb_Product4 + rtb_Gain_dgb)
                                    - (((0.5F * rtb_Abs2_g34) * (rtb_MinMax1_pk
                - 1.0F)) * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }
        else
        {
            /* Switch: '<S1809>/Switch3' incorporates:
             *  Constant: '<S1771>/Calib'
             *  Constant: '<S1812>/Constant Value1'
             *  Constant: '<S1812>/Constant Value2'
             *  MinMax: '<S1809>/MinMax5'
             *  Product: '<S1809>/Product2'
             *  Product: '<S1812>/Product1'
             *  Sum: '<S1812>/Sum'
             *  Sum: '<S1812>/Sum2'
             *  Switch: '<S1809>/Switch8'
             */
            rtb_Switch1_dh = fmaxf(rtb_Switch1_dh, ((rtb_Product4 + rtb_Gain_dgb)
                                    - (((0.5F * rtb_Abs2_g34) * (rtb_MinMax1_pk
                - 1.0F)) * HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }

        /* End of Switch: '<S1809>/Switch8' */
    }

    /* Outputs for Atomic SubSystem: '<S1809>/Limiter6' */
    /* RelationalOperator: '<S1825>/Relational Operator' */
    rtb_LogicalOperator4_lh = (rtb_Switch_j34 <= rtb_Switch1_dh);

    /* Switch: '<S1825>/Switch1' */
    if (rtb_LogicalOperator4_lh)
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = rtb_Switch_j34;
    }
    else
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = rtb_Switch1_dh;
    }

    /* End of Switch: '<S1825>/Switch1' */

    /* RelationalOperator: '<S1825>/Relational Operator1' */
    rtb_RelationalOperator1_bk = (rtb_Abs2_g34 > rtb_Gain_ow);

    /* Switch: '<S1825>/Switch' */
    if (rtb_RelationalOperator1_bk)
    {
        rtb_Gain_ow = rtb_Abs2_g34;
    }

    /* End of Switch: '<S1825>/Switch' */
    /* End of Outputs for SubSystem: '<S1809>/Limiter6' */

    /* Sum: '<S1809>/Sum4' incorporates:
     *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile1'
     */
    rtb_IntegerDelay = rtb_Gain_ow + VeESSR_n_InputSpeedProfile_DS;

    /* Outputs for Atomic SubSystem: '<S1809>/Limiter1' */
    /* RelationalOperator: '<S1820>/Relational Operator' incorporates:
     *  DataStoreWrite: '<S1765>/Dsw_InputSpeedProfile5'
     */
    VeESSR_b_NiMaxActive_DS = (rtu_VeHSER_n_NiMax <= rtb_IntegerDelay);

    /* Switch: '<S1820>/Switch1' incorporates:
     *  DataStoreWrite: '<S1765>/Dsw_InputSpeedProfile5'
     */
    if (VeESSR_b_NiMaxActive_DS)
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = rtu_VeHSER_n_NiMax;
    }
    else
    {
        /* Sum: '<S1765>/Summation4' */
        rtb_Abs2_g34 = rtb_IntegerDelay;
    }

    /* End of Switch: '<S1820>/Switch1' */

    /* Switch: '<S1820>/Switch' incorporates:
     *  Constant: '<S1809>/Constant Value4'
     *  RelationalOperator: '<S1820>/Relational Operator1'
     */
    if (rtb_Abs2_g34 > 0.0F)
    {
        /* Switch: '<S1820>/Switch' */
        rtb_IntegerDelay = rtb_Abs2_g34;
    }
    else
    {
        /* Switch: '<S1820>/Switch' */
        rtb_IntegerDelay = 0.0F;
    }

    /* End of Switch: '<S1820>/Switch' */
    /* End of Outputs for SubSystem: '<S1809>/Limiter1' */

    /* Product: '<S1809>/Product3' incorporates:
     *  Constant: '<S1771>/Calib'
     *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile1'
     *  DataStoreWrite: '<S1765>/Dsw_InputAcceltnProf'
     *  Sum: '<S1809>/Sum'
     */
    VeESSR_dn_InputAcceltnProf_DS = (rtb_IntegerDelay -
        VeESSR_n_InputSpeedProfile_DS) / HeESSR_t_MedTEB_dT;

    /* DataStoreWrite: '<S1765>/Dsw_InputSpeedProfile' */
    VeESSR_n_InputSpeedProfile_DS = rtb_IntegerDelay;

    /* Logic: '<S1809>/Logical2' incorporates:
     *  DataStoreWrite: '<S1765>/Dsw_InputSpeedProfile1'
     */
    VeESSR_b_NiDotMaxActive_DS = (rtb_Equal2_o && rtb_LogicalOperator4_lh);

    /* DataStoreWrite: '<S1765>/Dsw_InputSpeedProfile2' */
    VeESSR_n_TargetSpeed_DS = rtb_Gain1_bn;

    /* DataStoreWrite: '<S1765>/Dsw_InputSpeedProfile3' */
    VeESSR_dn_TargetAcceltn_DS = rtb_Gain_dgb;

    /* Outputs for Atomic SubSystem: '<S1809>/Limiter6' */
    /* Logic: '<S1809>/Logical' incorporates:
     *  DataStoreWrite: '<S1765>/Dsw_InputSpeedProfile4'
     *  Logic: '<S1825>/Logical2'
     */
    VeESSR_b_NiDotMinActive_DS = (rtb_OR_kx && (!rtb_RelationalOperator1_bk));

    /* End of Outputs for SubSystem: '<S1809>/Limiter6' */

    /* Sum: '<S1779>/Summation5' incorporates:
     *  DataStoreRead: '<S1779>/Dsr_InputSpeedProfile6'
     */
    VeESSR_n_SpinUpEMSpdError = rtu_VeESSR_n_TransInSpdFlt -
        VeESSR_n_InputSpeedProfile_DS;

    /* MinMax: '<S1779>/MinMax' incorporates:
     *  Constant: '<S1779>/Constant Value'
     *  Constant: '<S1846>/Calib'
     *  Product: '<S1779>/Multiplication'
     */
    VeESSR_M_SpinUpEMPSpdCtl = fminf(0.0F, VeESSR_n_SpinUpEMSpdError *
        KeESSR_K_SpinUpEMSpdCtlPgain);

    /* MinMax: '<S1765>/MinMax2' incorporates:
     *  DataStoreWrite: '<S1765>/Dsw_InputTorqEst'
     *  Sum: '<S1765>/Summation5'
     */
    VeESSR_M_EngTorqEst_DS = fmaxf(rtu_TiEStMin, VeESSR_M_SpinUpEM_ISpdCtl +
        VeESSR_M_SpinUpEMPSpdCtl);

    /* DataStoreWrite: '<S1765>/Dsw_Ni1stFlt_DS' */
    VeESSR_n_Ni1stFlt_DS = rtb_UnitDelay_k;

    /* DataStoreWrite: '<S1765>/Dsw_STMTmr' incorporates:
     *  Constant: '<S1771>/Calib'
     *  DataStoreRead: '<S1765>/Dsr_STMTmr'
     *  Sum: '<S1765>/Summation1'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S1765>/ChkSpinUpEng_EM' */
    /* Switch: '<S1772>/Switch1' incorporates:
     *  Constant: '<S1784>/Constant'
     *  Constant: '<S1793>/Calib'
     *  Constant: '<S1794>/Calib'
     *  DataStoreWrite: '<S1765>/Dsw_STMTrigger'
     *  Logic: '<S1769>/Logical Operator13'
     *  Logic: '<S1769>/Logical Operator2'
     *  RelationalOperator: '<S1769>/Greater  Than8'
     *  Switch: '<S1772>/Switch2'
     *  Switch: '<S1772>/Switch3'
     */
    if ((((KeESSR_b_EnblFtrEarlyExitSpinUp) && rtu_EMErlyExitLmp) &&
            (rtu_VeESSR_n_TransInSpdFlt > KeESSR_n_MinSpdFuelOn)) ||
            rtb_LogicalOperator3_d)
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngSpdTgtAch;
    }
    else if (rtb_LeESSR_b_SpinUp_CoastDownTr)
    {
        /* Switch: '<S1772>/Switch1' incorporates:
         *  Constant: '<S1786>/Constant'
         *  DataStoreWrite: '<S1765>/Dsw_STMTrigger'
         *  Switch: '<S1772>/Switch2'
         */
        VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;
    }
    else
    {
        if (rtb_GreaterThan3_ja)
        {
            /* Switch: '<S1769>/Switch8' incorporates:
             *  Constant: '<S1792>/Calib'
             *  Logic: '<S1769>/Logical2'
             *  Logic: '<S1769>/Logical3'
             */
            if ((!KeESSR_b_DsblEVStrtFailed_InPlant) ||
                    (!rtu_VeRTMR_b_InPlantMode))
            {
                /* Switch: '<S1772>/Switch1' incorporates:
                 *  Constant: '<S1785>/Constant'
                 *  DataStoreWrite: '<S1765>/Dsw_STMTrigger'
                 *  Switch: '<S1772>/Switch2'
                 *  Switch: '<S1772>/Switch3'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;
            }
            else
            {
                /* Switch: '<S1772>/Switch1' incorporates:
                 *  Constant: '<S1783>/Constant'
                 *  DataStoreWrite: '<S1765>/Dsw_STMTrigger'
                 *  Switch: '<S1772>/Switch2'
                 *  Switch: '<S1772>/Switch3'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;
            }

            /* End of Switch: '<S1769>/Switch8' */
        }
    }

    /* End of Switch: '<S1772>/Switch1' */
    /* End of Outputs for SubSystem: '<S1765>/ChkSpinUpEng_EM' */

    /* Switch: '<S1765>/Switch4' incorporates:
     *  Constant: '<S1765>/Constant Value'
     *  DataStoreRead: '<S1765>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S1765>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S1765>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S1765>/Logical1'
     *  Logic: '<S1765>/Logical21'
     *  RelationalOperator: '<S1765>/Comparison'
     *  S-Function (sfix_bitop): '<S1765>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S1768>/FixPt Bitwise Operator1'
     */
    if ((rtb_LeESSR_b_SpinUp_CoastDownTr || rtb_GreaterThan3_ja) &&
            ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16777216U) > 0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 16777216U;
    }

    /* End of Switch: '<S1765>/Switch4' */

    /* MinMax: '<S1765>/MinMax' incorporates:
     *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile2'
     *  DataStoreRead: '<S1765>/Dsr_StrtTypInitImmedTorq'
     *  DataStoreWrite: '<S1765>/Dsw_EngTrqReqImmed'
     *  Sum: '<S1765>/Summation2'
     */
    VeESSR_M_EngTrqReqImmed_DS = fminf(VeESSR_M_StrtTypInitImmedTorq_DS,
        rtu_VeETQR_M_EngTrqActual + VeESSR_M_MinImmedExitTorqDelta_DS);

    /* MinMax: '<S1765>/MinMax1' incorporates:
     *  DataStoreRead: '<S1765>/Dsr_InputSpeedProfile3'
     *  DataStoreRead: '<S1765>/Dsr_StrtTypInitPredTorq'
     *  DataStoreWrite: '<S1765>/Dsw_EngTrqReqPrdtd1'
     *  Product: '<S1765>/Product'
     *  Sum: '<S1765>/Summation3'
     *  Sum: '<S1765>/Summation4'
     */
    VeESSR_M_EngTrqReqPrdtd_DS = fminf(VeESSR_M_StrtTypInitPredTorq_DS,
        ((VeESSR_M_EngTrqReqImmed_DS + rtu_VeETQR_M_EngineLosses) *
         rtu_VeETQR_r_MaxSparkAuthority) - rtu_VeETQR_M_EngineLosses);

    /* DataStoreWrite: '<S1765>/Dsw_SpdCtlGainMod1' incorporates:
     *  Constant: '<S1765>/Constant Value7'
     */
    VeESSR_scl_SpdCtlGainMod_DS = 1.0F;

    /* Sum: '<S1809>/Sum17' incorporates:
     *  DataStoreWrite: '<S1765>/Dsw_InputAcceltnProf'
     */
    VeESSR_dn_InputJerkProfSpinUpEMEng = VeESSR_dn_InputAcceltnProf_DS -
        rtb_Sum15;

    /* Update for UnitDelay: '<S1828>/Unit Delay' incorporates:
     *  Switch: '<S1828>/Switch3'
     */
    localDW->UnitDelay_DSTATE = rtb_Summation_hp;

    /* Update for Delay: '<S1809>/IntegerDelay' */
    localDW->icLoad = 0U;
    for (i = 0; i < 15; i++)
    {
        localDW->IntegerDelay_DSTATE[i] = localDW->IntegerDelay_DSTATE[i + 1];
    }

    localDW->IntegerDelay_DSTATE[15] = rtb_Gain1_bn;

    /* End of Update for Delay: '<S1809>/IntegerDelay' */
}

#endif

/* System initialize for function-call system: '<S572>/StartEng_EM_Dur' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_StartEng_EM_Dur_Init(P2VAR
    (DW_StartEng_EM_Dur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW)
{
    /* InitializeConditions for Delay: '<S2398>/IntegerDelay' */
    localDW->icLoad = 1U;

    /* SystemInitialize for Atomic SubSystem: '<S2297>/Digital Lowpass Reset Enabled1' */
    /* Start for If: '<S2303>/If' */
    localDW->If_ActiveSubsystem = -1;

    /* End of SystemInitialize for SubSystem: '<S2297>/Digital Lowpass Reset Enabled1' */
}

#endif

/* Output and update for function-call system: '<S572>/StartEng_EM_Dur' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_StartEng_EM_Dur(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_EngStrtTorqSnsd, VAR(boolean, AUTOMATIC)
    rtu_VeENGR_b_EngCombustionCmnd, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngTrqActual, VAR(boolean, AUTOMATIC) rtu_VeRTMR_b_InPlantMode,
    VAR(float32, AUTOMATIC) rtu_VeESSR_M_OptEngTrqReqPred, VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_OptEngTrqReqImmed, VAR(float32, AUTOMATIC)
    rtu_VeETQR_r_MaxSparkAuthority, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngineLosses, VAR(TeENGR_e_ETRQ_Mode, AUTOMATIC)
    rtu_VeENGR_e_ETRQ_Mode, VAR(float32, AUTOMATIC) rtu_VeESSR_n_TransInSpdFlt,
    VAR(float32, AUTOMATIC) rtu_VeOHSR_n_IdleSpdBlended, VAR(float32, AUTOMATIC)
    rtu_VeHSER_n_NiMax, VAR(float32, AUTOMATIC) rtu_VeMSPR_n_MtrB_Spd, VAR
    (float32, AUTOMATIC) rtu_VeETQR_M_EngCapacityMinOff, VAR(float32, AUTOMATIC)
    rtu_VeOITR_M_InputTorqMaxTact, VAR(float32, AUTOMATIC)
    rtu_VeHTDR_M_MtrB_TorqCmnd, VAR(float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMax,
    VAR(float32, AUTOMATIC) rtu_VeHSER_dn_NiDotMin, VAR(boolean, AUTOMATIC)
    rtu_EMErlyExitLmp, VAR(TeHSER_e_RngSt, AUTOMATIC) rtu_VeHSER_e_RngSt, VAR
    (float32, AUTOMATIC) rtu_TiEstMin, P2VAR(DW_StartEng_EM_Dur_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR(ZCE_StartEng_EM_Dur_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localZCE, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn)
{
    sint32 i;
    float32 rtb_Abs_kl;
    float32 rtb_Gain_dx;
    float32 rtb_IntegerDelay;
    float32 rtb_MinMax1_kd;
    float32 rtb_Multiplication1_bh;
    float32 rtb_Multiplication1_fy;
    float32 rtb_Product4;
    float32 rtb_Product4_o;
    float32 rtb_Sum15;
    float32 rtb_Sum2_is;
    float32 rtb_Sum5_fb;
    float32 rtb_Sum6_hu;
    float32 rtb_Sum6_k;
    float32 rtb_Switch1_adj;
    float32 rtb_Switch1_esq;
    float32 rtb_Switch5_a2;
    float32 rtb_Switch_bj;
    sint8 rtAction;
    sint8 rtPrevAction;
    uint8 tmp;
    boolean rtb_GreaterThan1_eg;
    boolean rtb_Logical2_c4;
    boolean rtb_Logical5_nn;
    boolean rtb_LogicalOperator3_c;
    boolean rtb_OR1_ep_tmp;
    boolean rtb_OR1_p;
    boolean rtb_RelationalOperator_is;
    boolean rtb_Switch1_mv;

    /* RelationalOperator: '<S2297>/Greater  Than1' incorporates:
     *  Constant: '<S2339>/Calib'
     *  DataStoreRead: '<S2297>/Dsr_STMTmr1'
     */
    rtb_GreaterThan1_eg = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmStartEngEM);

    /* Logic: '<S2297>/Logical5' incorporates:
     *  Constant: '<S2328>/Calib'
     *  Constant: '<S2329>/Calib'
     *  DataStoreRead: '<S2297>/Data Store Read1'
     *  Logic: '<S2297>/Logical2'
     *  Logic: '<S2297>/Logical3'
     *  Logic: '<S2297>/Logical8'
     */
    rtb_Logical5_nn = (((!KeESSR_b_DsblEVStrtFailed_InPlant) ||
                        (!rtu_VeRTMR_b_InPlantMode)) &&
                       ((KeESSR_b_AllowEV_StrtFailed) ||
                        (VeESSR_b_AStrtReattmptAllowed_DS)));

    /* Logic: '<S2297>/Logical14' incorporates:
     *  DataStoreWrite: '<S2297>/Dsw_AStrtFailed3'
     *  Logic: '<S2297>/Logical12'
     *  Logic: '<S2297>/Logical13'
     */
    VeESSR_b_AStrtFailed_DS = ((rtu_EMErlyExitLmp && rtb_GreaterThan1_eg) ||
        (rtb_GreaterThan1_eg && rtb_Logical5_nn));

    /* Switch: '<S2314>/Switch1' incorporates:
     *  Constant: '<S2297>/Constant Value3'
     *  DataStoreRead: '<S2297>/Dsr_STMTmr3'
     *  DataStoreWrite: '<S2297>/Dsw_AStrtFailed1'
     *  DataStoreWrite: '<S2297>/Dsw_AStrtFailed3'
     *  Logic: '<S2297>/Logical1'
     *  Logic: '<S2297>/Logical6'
     *  Sum: '<S2297>/Sum3'
     */
    if ((VeESSR_b_AStrtFailed_DS) && (!rtu_EMErlyExitLmp))
    {
        VeESSR_Cnt_AStrtFailAttmptCntr_DS = (uint8)(((uint32)
            VeESSR_Cnt_AStrtFailAttmptCntr_DS) + 1U);
    }

    /* End of Switch: '<S2314>/Switch1' */

    /* RelationalOperator: '<S2297>/Greater  Than2' incorporates:
     *  Constant: '<S2318>/Calib'
     *  DataStoreWrite: '<S2297>/Dsw_AStrtFailed1'
     *  DataStoreWrite: '<S2297>/Dsw_AStrtFailed2'
     */
    VeESSR_b_AStrtReattmptAllowed_DS = (VeESSR_Cnt_AStrtFailAttmptCntr_DS <=
        KeESSR_Cnt_AStrtFailMaxAttmpts);

    /* Outputs for Atomic SubSystem: '<S2297>/Hysteresis2' */
    /* Switch: '<S2313>/Switch1' incorporates:
     *  Constant: '<S2326>/Calib'
     *  RelationalOperator: '<S2313>/Greater  Than'
     */
    if (rtu_VeHTDR_M_MtrB_TorqCmnd > KeESSR_M_EMStrtMtrBThres)
    {
        /* Switch: '<S2313>/Switch1' incorporates:
         *  Constant: '<S2313>/Constant Value'
         */
        rtb_Switch1_mv = true;
    }
    else
    {
        /* Switch: '<S2313>/Switch1' incorporates:
         *  Constant: '<S2325>/Calib'
         *  RelationalOperator: '<S2313>/Greater  Than1'
         *  Sum: '<S2297>/Sum4'
         *  UnitDelay: '<S2313>/Unit Delay'
         */
        rtb_Switch1_mv = ((rtu_VeHTDR_M_MtrB_TorqCmnd >=
                           (KeESSR_M_EMStrtMtrBThres - KeESSR_M_EMStrtMtrBHys)) &&
                          (localDW->UnitDelay_DSTATE_h));
    }

    /* End of Switch: '<S2313>/Switch1' */

    /* Update for UnitDelay: '<S2313>/Unit Delay' */
    localDW->UnitDelay_DSTATE_h = rtb_Switch1_mv;

    /* End of Outputs for SubSystem: '<S2297>/Hysteresis2' */

    /* Switch: '<S2297>/Switch3' incorporates:
     *  Constant: '<S2331>/Calib'
     *  Constant: '<S2337>/Calib'
     *  DataStoreRead: '<S2297>/Dsr_STMTmr2'
     *  Logic: '<S2297>/Logical4'
     *  RelationalOperator: '<S2297>/Comparison2'
     *  Switch: '<S2297>/Switch4'
     */
    if ((VeESSR_t_STMTmr_DS < KeESSR_t_CombChkDlyTm) ||
            rtu_VeENGR_b_EngCombustionCmnd)
    {
        /* Switch: '<S2297>/Switch3' incorporates:
         *  Constant: '<S2335>/Calib'
         */
        VeESSR_n_NiAfterCombEM = KeESSR_n_NiTargetEMStrt;
    }
    else if (KeESSR_b_NoEngComb_SpdSrc)
    {
        /* Switch: '<S2297>/Switch4' incorporates:
         *  Constant: '<S2336>/Calib'
         *  Switch: '<S2297>/Switch3'
         */
        VeESSR_n_NiAfterCombEM = KeESSR_n_NoEngComb_SpdTgt;
    }
    else
    {
        /* Switch: '<S2297>/Switch3' incorporates:
         *  DataStoreRead: '<S2297>/Data Store Read'
         *  Switch: '<S2297>/Switch4'
         */
        VeESSR_n_NiAfterCombEM = VeESSR_n_InputSpeedProfile_DS;
    }

    /* End of Switch: '<S2297>/Switch3' */

    /* Sum: '<S2297>/Sum5' */
    rtb_Sum5_fb = rtu_VeESSR_n_TransInSpdFlt - VeESSR_n_NiAfterCombEM;

    /* Sum: '<S2297>/Sum6' */
    rtb_Sum6_k = rtu_VeOHSR_n_IdleSpdBlended - VeESSR_n_NiAfterCombEM;

    /* Outputs for Atomic SubSystem: '<S2297>/Protected Division' */
    /* Switch: '<S2347>/Switch1' incorporates:
     *  Constant: '<S2347>/Constant Value'
     *  Constant: '<S2347>/Constant Value1'
     *  Constant: '<S2347>/Constant Value2'
     *  Constant: '<S2347>/Constant Value3'
     *  Logic: '<S2347>/AND'
     *  RelationalOperator: '<S2347>/Greater Than or Equal '
     *  RelationalOperator: '<S2347>/Greater Than or Equal 1'
     *  RelationalOperator: '<S2347>/Not Equal'
     *  RelationalOperator: '<S2347>/Not Equal1'
     *  Switch: '<S2347>/Switch2'
     *  Switch: '<S2347>/Switch3'
     */
    if ((rtb_Sum5_fb != 0.0F) && (rtb_Sum6_k != 0.0F))
    {
        /* Switch: '<S2347>/Switch1' incorporates:
         *  Product: '<S2347>/Division'
         */
        rtb_Sum5_fb /= rtb_Sum6_k;
    }
    else if (rtb_Sum5_fb > 0.0F)
    {
        /* Switch: '<S2347>/Switch2' incorporates:
         *  Constant: '<S2347>/MAXFLOAT'
         *  Switch: '<S2347>/Switch1'
         */
        rtb_Sum5_fb = 3.402823466E+38F;
    }
    else if (rtb_Sum5_fb < 0.0F)
    {
        /* Switch: '<S2347>/Switch3' incorporates:
         *  Constant: '<S2347>/MINFLOAT'
         *  Switch: '<S2347>/Switch1'
         *  Switch: '<S2347>/Switch2'
         */
        rtb_Sum5_fb = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2347>/Switch1' incorporates:
         *  Constant: '<S2347>/Constant Value4'
         *  Switch: '<S2347>/Switch2'
         *  Switch: '<S2347>/Switch3'
         */
        rtb_Sum5_fb = 0.0F;
    }

    /* End of Switch: '<S2347>/Switch1' */
    /* End of Outputs for SubSystem: '<S2297>/Protected Division' */

    /* Outputs for Atomic SubSystem: '<S2297>/Limiter1' */
    /* Switch: '<S2342>/Switch1' incorporates:
     *  Constant: '<S2297>/Constant Value4'
     *  RelationalOperator: '<S2342>/Relational Operator'
     */
    if (1.0F < rtb_Sum5_fb)
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = 1.0F;
    }
    else
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtb_Sum5_fb;
    }

    /* End of Switch: '<S2342>/Switch1' */

    /* Switch: '<S2342>/Switch' incorporates:
     *  Constant: '<S2297>/Constant Value'
     *  RelationalOperator: '<S2342>/Relational Operator1'
     */
    if (rtb_Abs_kl > 0.0F)
    {
        /* Switch: '<S2342>/Switch' */
        VeESSR_K_EMStrtBlendRatio = rtb_Abs_kl;
    }
    else
    {
        /* Switch: '<S2342>/Switch' */
        VeESSR_K_EMStrtBlendRatio = 0.0F;
    }

    /* End of Switch: '<S2342>/Switch' */
    /* End of Outputs for SubSystem: '<S2297>/Limiter1' */

    /* Outputs for Atomic SubSystem: '<S2297>/Stop Watch Reset Enabled' */
    /* Switch: '<S2350>/Switch2' incorporates:
     *  Constant: '<S2319>/Calib'
     *  Logic: '<S2297>/Logical10'
     *  Logic: '<S2297>/Logical11'
     *  Logic: '<S2297>/Logical9'
     *  RelationalOperator: '<S2297>/Comparison1'
     *  Switch: '<S2350>/Switch1'
     */
    if (rtb_Switch1_mv || (VeESSR_K_EMStrtBlendRatio <=
                           KeESSR_K_EMBlendStartThresh))
    {
        /* Switch: '<S2350>/Switch1' incorporates:
         *  Constant: '<S2350>/Constant Value2'
         */
        rtb_Sum5_fb = 0.0F;
    }
    else
    {
        /* Switch: '<S2350>/Switch1' incorporates:
         *  Constant: '<S2309>/Calib'
         *  Sum: '<S2350>/Subtraction'
         *  Switch: '<S2350>/Switch2'
         *  UnitDelay: '<S2350>/Unit Delay'
         */
        rtb_Sum5_fb = HeESSR_t_MedTEB_dT + localDW->UnitDelay_DSTATE_k;
    }

    /* End of Switch: '<S2350>/Switch2' */

    /* Update for UnitDelay: '<S2350>/Unit Delay' */
    localDW->UnitDelay_DSTATE_k = rtb_Sum5_fb;

    /* End of Outputs for SubSystem: '<S2297>/Stop Watch Reset Enabled' */

    /* Switch: '<S2297>/Switch1' incorporates:
     *  Constant: '<S2307>/Constant'
     *  Constant: '<S2338>/Calib'
     *  DataStoreWrite: '<S2297>/Dsw_EngStrtType2'
     *  Logic: '<S2297>/Logical'
     *  RelationalOperator: '<S2297>/Comparison4'
     */
    if (rtu_VeENGR_b_EngCombustionCmnd && (rtb_Sum5_fb > KeESSR_t_EMStartTime))
    {
        VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Startng;
    }

    /* End of Switch: '<S2297>/Switch1' */

    /* MinMax: '<S2401>/MinMax1' incorporates:
     *  Constant: '<S2327>/Calib'
     *  MinMax: '<S2297>/Maximum2'
     */
    rtb_MinMax1_kd = fmaxf(rtu_VeESSR_M_OptEngTrqReqImmed,
                           KeESSR_M_MinStartDetectTorq);

    /* If: '<S2306>/If1' */
    if (rtu_VeENGR_b_EngCombustionCmnd)
    {
        /* Outputs for IfAction SubSystem: '<S2306>/ESSC_CombstDelay' incorporates:
         *  ActionPort: '<S2378>/Action Port'
         */
        ESSR_ac_ESSC_CombstDelay_l(rtu_VeESSR_n_TransInSpdFlt,
            &rtb_LogicalOperator3_c);

        /* End of Outputs for SubSystem: '<S2306>/ESSC_CombstDelay' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2306>/ESSC_CombstNoDelay' incorporates:
         *  ActionPort: '<S2379>/Action Port'
         */
        ESSR_ac_ESSC_CmbstnNoDelay(&rtb_LogicalOperator3_c);

        /* End of Outputs for SubSystem: '<S2306>/ESSC_CombstNoDelay' */
    }

    /* End of If: '<S2306>/If1' */

    /* RelationalOperator: '<S2297>/Equal2' incorporates:
     *  Constant: '<S2309>/Calib'
     *  DataStoreRead: '<S2297>/Dsr_STMTmr'
     */
    rtb_Switch1_mv = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

    /* Outputs for Atomic SubSystem: '<S2305>/Signal Latch On With Reset' */
    /* Outputs for Atomic SubSystem: '<S2297>/Digital Lowpass Reset Enabled1' */
    /* Outputs for Atomic SubSystem: '<S2303>/Signal Latch On With Reset' */
    /* Outputs for Atomic SubSystem: '<S2306>/Signal Latch On With Reset' */
    /* Logic: '<S2382>/NOT' incorporates:
     *  Logic: '<S2353>/NOT'
     *  Logic: '<S2372>/NOT'
     */
    rtb_OR1_ep_tmp = !rtb_Switch1_mv;

    /* End of Outputs for SubSystem: '<S2303>/Signal Latch On With Reset' */
    /* End of Outputs for SubSystem: '<S2297>/Digital Lowpass Reset Enabled1' */
    /* End of Outputs for SubSystem: '<S2305>/Signal Latch On With Reset' */

    /* Logic: '<S2382>/OR1' incorporates:
     *  Constant: '<S2380>/Calib'
     *  DataStoreRead: '<S2306>/Dsr_STMTmr'
     *  Logic: '<S2306>/Logical3'
     *  Logic: '<S2382>/NOT'
     *  Logic: '<S2382>/OR'
     *  RelationalOperator: '<S2306>/Equal1'
     *  UnitDelay: '<S2382>/Unit Delay'
     */
    rtb_OR1_p = ((rtb_LogicalOperator3_c || (VeESSR_t_STMTmr_DS >
                   KeESSR_t_FuelTmDelayHold)) || (rtb_OR1_ep_tmp &&
                  (localDW->UnitDelay_DSTATE_cx)));

    /* Update for UnitDelay: '<S2382>/Unit Delay' */
    localDW->UnitDelay_DSTATE_cx = rtb_OR1_p;

    /* End of Outputs for SubSystem: '<S2306>/Signal Latch On With Reset' */

    /* Logic: '<S2306>/Logical4' */
    rtb_OR1_p = !rtb_OR1_p;

    /* Sum: '<S2297>/Sum1' incorporates:
     *  DataStoreRead: '<S2297>/Dsr_StrtTypInitImmedTorq1'
     */
    rtb_Sum5_fb = rtb_MinMax1_kd - VeESSR_M_EngTrqReqImmed_DS;

    /* Outputs for Atomic SubSystem: '<S2297>/Lowpass Second Order Enabled1' */
    /* Switch: '<S2343>/Switch3' incorporates:
     *  Switch: '<S2343>/Switch1'
     */
    if (rtb_OR1_p)
    {
        /* Switch: '<S2343>/Switch3' */
        rtb_Sum6_k = rtb_Sum5_fb;

        /* Switch: '<S2343>/Switch1' */
        rtb_Multiplication1_bh = rtb_Sum5_fb;
    }
    else
    {
        /* Switch: '<S2343>/Switch3' incorporates:
         *  UnitDelay: '<S2343>/x2'
         */
        rtb_Sum6_k = localDW->x2_DSTATE_o;

        /* Product: '<S2343>/Multiplication1' incorporates:
         *  Constant: '<S2309>/Calib'
         *  DataStoreRead: '<S2297>/Dsr_StrtTypInitImmedTorq3'
         *  MinMax: '<S2343>/Maximum'
         */
        rtb_Multiplication1_bh = (1.0F / fmaxf(VeESSR_k_StrtTypEngTorqReqFltT_DS,
            HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT;

        /* Switch: '<S2343>/Switch1' incorporates:
         *  Constant: '<S2297>/Constant Value2'
         *  DataStoreRead: '<S2297>/Dsr_StrtTypInitImmedTorq5'
         *  Gain: '<S2343>/Gain'
         *  Gain: '<S2343>/Gain1'
         *  Math: '<S2343>/Square'
         *  Product: '<S2343>/Multiplication2'
         *  Product: '<S2343>/Multiplication3'
         *  Sum: '<S2343>/Subtraction'
         *  Sum: '<S2343>/Subtraction1'
         *  Sum: '<S2343>/Summation'
         *  UnitDelay: '<S2343>/temp'
         *  UnitDelay: '<S2343>/x2'
         */
        rtb_Multiplication1_bh = (((((localDW->temp_DSTATE_d -
            localDW->x2_DSTATE_o) * (2.0F *
            VeESSR_k_StrtTypEngTorqReqImmedFltD_DS)) * rtb_Multiplication1_bh) +
            ((rtb_Multiplication1_bh * rtb_Multiplication1_bh) * (0.0F -
            localDW->temp_DSTATE_d))) - localDW->temp_DSTATE_d) + (2.0F *
            localDW->x2_DSTATE_o);
    }

    /* End of Switch: '<S2343>/Switch3' */

    /* Update for UnitDelay: '<S2343>/x2' */
    localDW->x2_DSTATE_o = rtb_Multiplication1_bh;

    /* Update for UnitDelay: '<S2343>/temp' */
    localDW->temp_DSTATE_d = rtb_Sum6_k;

    /* End of Outputs for SubSystem: '<S2297>/Lowpass Second Order Enabled1' */

    /* Sum: '<S2297>/Sum2' incorporates:
     *  DataStoreWrite: '<S2297>/Dsw_EngTrqReqImmed'
     */
    VeESSR_M_EngTrqReqImmed_DS = rtb_MinMax1_kd - rtb_Multiplication1_bh;

    /* Sum: '<S2297>/Summation4' incorporates:
     *  Product: '<S2297>/Product'
     *  Sum: '<S2297>/Summation3'
     */
    rtb_Multiplication1_bh = ((rtb_MinMax1_kd + rtu_VeETQR_M_EngineLosses) *
        rtu_VeETQR_r_MaxSparkAuthority) - rtu_VeETQR_M_EngineLosses;

    /* Outputs for Atomic SubSystem: '<S2297>/Lowpass Second Order Enabled3' */
    /* Switch: '<S2344>/Switch3' incorporates:
     *  Switch: '<S2344>/Switch1'
     */
    if (rtb_Switch1_mv)
    {
        /* Switch: '<S2344>/Switch3' incorporates:
         *  DataStoreRead: '<S2297>/Dsr_StrtTypInitImmedTorq6'
         */
        rtb_Sum6_k = VeESSR_M_EngTrqReqPrdtd_DS;

        /* Switch: '<S2344>/Switch1' incorporates:
         *  DataStoreRead: '<S2297>/Dsr_StrtTypInitImmedTorq6'
         */
        rtb_Multiplication1_fy = VeESSR_M_EngTrqReqPrdtd_DS;
    }
    else
    {
        /* Switch: '<S2344>/Switch3' incorporates:
         *  UnitDelay: '<S2344>/x2'
         */
        rtb_Sum6_k = localDW->x2_DSTATE;

        /* Product: '<S2344>/Multiplication1' incorporates:
         *  Constant: '<S2309>/Calib'
         *  Constant: '<S2320>/Calib'
         *  DataStoreRead: '<S2297>/Dsr_StrtTypInitImmedTorq2'
         *  MinMax: '<S2344>/Maximum'
         *  Product: '<S2297>/Product1'
         */
        rtb_Multiplication1_fy = (1.0F / fmaxf(KeESSR_K_StartEngTiPredCoefMult *
            VeESSR_k_StrtTypEngTorqReqFltT_DS, HeESSR_t_MedTEB_dT)) *
            HeESSR_t_MedTEB_dT;

        /* Switch: '<S2297>/Switch5' incorporates:
         *  Constant: '<S2308>/Constant'
         *  Constant: '<S2333>/Calib'
         *  DataStoreRead: '<S2297>/Dsr_StrtTypInitImmedTorq4'
         *  RelationalOperator: '<S2297>/Comparison3'
         */
        if (((uint32)rtu_VeHSER_e_RngSt) == CeHSER_e_ShiftToNeutEngOn)
        {
            rtb_Gain_dx = KeESSR_k_EMStrtEngTqPredXNFlt;
        }
        else
        {
            rtb_Gain_dx = VeESSR_k_StrtTypEngTorqReqImmedFltD_DS;
        }

        /* End of Switch: '<S2297>/Switch5' */

        /* Switch: '<S2344>/Switch1' incorporates:
         *  Constant: '<S2327>/Calib'
         *  Gain: '<S2344>/Gain'
         *  Gain: '<S2344>/Gain1'
         *  Math: '<S2344>/Square'
         *  MinMax: '<S2297>/Maximum1'
         *  Product: '<S2344>/Multiplication2'
         *  Product: '<S2344>/Multiplication3'
         *  Sum: '<S2344>/Subtraction'
         *  Sum: '<S2344>/Subtraction1'
         *  Sum: '<S2344>/Summation'
         *  UnitDelay: '<S2344>/temp'
         *  UnitDelay: '<S2344>/x2'
         */
        rtb_Multiplication1_fy = (((((localDW->temp_DSTATE - localDW->x2_DSTATE)
            * (2.0F * rtb_Gain_dx)) * rtb_Multiplication1_fy) +
            ((rtb_Multiplication1_fy * rtb_Multiplication1_fy) * (fmaxf
            (rtu_VeESSR_M_OptEngTrqReqPred, KeESSR_M_MinStartDetectTorq) -
            localDW->temp_DSTATE))) - localDW->temp_DSTATE) + (2.0F *
            localDW->x2_DSTATE);
    }

    /* End of Switch: '<S2344>/Switch3' */

    /* Outputs for Atomic SubSystem: '<S2344>/Limiter3' */
    /* Switch: '<S2389>/Switch1' incorporates:
     *  RelationalOperator: '<S2389>/Relational Operator'
     */
    if (rtb_Multiplication1_bh < rtb_Multiplication1_fy)
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtb_Multiplication1_bh;
    }
    else
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtb_Multiplication1_fy;
    }

    /* End of Switch: '<S2389>/Switch1' */

    /* Switch: '<S2389>/Switch' incorporates:
     *  DataStoreWrite: '<S2297>/Dsw_EngTrqReqImmed'
     *  DataStoreWrite: '<S2297>/Dsw_EngTrqReqPrdtd'
     *  RelationalOperator: '<S2389>/Relational Operator1'
     */
    if (rtb_Abs_kl > VeESSR_M_EngTrqReqImmed_DS)
    {
        VeESSR_M_EngTrqReqPrdtd_DS = rtb_Abs_kl;
    }
    else
    {
        VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_EngTrqReqImmed_DS;
    }

    /* End of Switch: '<S2389>/Switch' */
    /* End of Outputs for SubSystem: '<S2344>/Limiter3' */

    /* Update for UnitDelay: '<S2344>/x2' incorporates:
     *  DataStoreWrite: '<S2297>/Dsw_EngTrqReqPrdtd'
     */
    localDW->x2_DSTATE = VeESSR_M_EngTrqReqPrdtd_DS;

    /* Update for UnitDelay: '<S2344>/temp' */
    localDW->temp_DSTATE = rtb_Sum6_k;

    /* End of Outputs for SubSystem: '<S2297>/Lowpass Second Order Enabled3' */

    /* Gain: '<S2349>/Gain' incorporates:
     *  Abs: '<S2349>/Abs1'
     *  DataStoreRead: '<S2297>/Dsr_NiProfGenDNiDLim2'
     */
    rtb_Gain_dx = -fabsf(VeESSR_dn_StrtTypJerkMinStartEng_DS);

    /* Product: '<S2398>/Product4' incorporates:
     *  Constant: '<S2309>/Calib'
     */
    rtb_Product4 = rtb_Gain_dx / HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2349>/LowpassT Reset Enabled' */
    /* Sum: '<S2396>/Summation' incorporates:
     *  Constant: '<S2309>/Calib'
     *  DataStoreRead: '<S2297>/Dsr_Ni1stFlt_DS'
     *  DataStoreRead: '<S2297>/Dsr_NiProfGenT2Gain'
     *  MinMax: '<S2396>/Maximum'
     *  Product: '<S2396>/Multiplication'
     *  Product: '<S2396>/Multiplication1'
     *  Sum: '<S2396>/Subtraction'
     */
    rtb_Multiplication1_fy = (((VeESSR_n_NiAfterCombEM - VeESSR_n_Ni1stFlt_DS) *
        HeESSR_t_MedTEB_dT) * (1.0F / fmaxf(VeESSR_k_StrtTypScndOrdLwPassT_DS,
        HeESSR_t_MedTEB_dT))) + VeESSR_n_Ni1stFlt_DS;

    /* End of Outputs for SubSystem: '<S2349>/LowpassT Reset Enabled' */

    /* Outputs for Atomic SubSystem: '<S2349>/LowpassT Reset Enabled1' */
    /* Sum: '<S2397>/Summation' incorporates:
     *  Constant: '<S2309>/Calib'
     *  DataStoreRead: '<S2297>/Dsr_InputSpeedProfile1'
     *  DataStoreRead: '<S2297>/Dsr_NiProfGenT1Gain'
     *  MinMax: '<S2397>/Maximum'
     *  Product: '<S2397>/Multiplication'
     *  Product: '<S2397>/Multiplication1'
     *  Sum: '<S2397>/Subtraction'
     */
    rtb_Sum6_k = (((rtb_Multiplication1_fy - VeESSR_n_InputSpeedProfile_DS) *
                   HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                   (VeESSR_k_StrtTypFrstOrdLwPassT_DS, HeESSR_t_MedTEB_dT))) +
        VeESSR_n_InputSpeedProfile_DS;

    /* End of Outputs for SubSystem: '<S2349>/LowpassT Reset Enabled1' */

    /* Switch: '<S2417>/Switch1' incorporates:
     *  UnitDelay: '<S2417>/Unit Delay'
     */
    if (rtb_Switch1_mv)
    {
        rtb_Multiplication1_bh = rtb_Sum6_k;
    }
    else
    {
        rtb_Multiplication1_bh = localDW->UnitDelay_DSTATE;
    }

    /* End of Switch: '<S2417>/Switch1' */

    /* Gain: '<S2398>/Gain1' incorporates:
     *  Sum: '<S2398>/Sum18'
     */
    rtb_Multiplication1_bh = (rtb_Sum6_k + rtb_Multiplication1_bh) * 0.5F;

    /* Delay: '<S2398>/IntegerDelay' incorporates:
     *  Constant: '<S2407>/Calib'
     */
    if (rtb_Switch1_mv && (((uint32)localZCE->IntegerDelay_Reset_ZCE_o) !=
                           POS_ZCSIG))
    {
        localDW->icLoad = 1U;
    }

    localZCE->IntegerDelay_Reset_ZCE_o = rtb_Switch1_mv ? ((ZCSigState)1) :
        ((ZCSigState)0);
    if (((sint32)localDW->icLoad) != 0)
    {
        for (i = 0; i < 16; i++)
        {
            localDW->IntegerDelay_DSTATE[i] = rtb_Multiplication1_bh;
        }
    }

    if (((sint32)KeESSR_Cnt_DelayOptNi) <= 0)
    {
        /* Delay: '<S2398>/IntegerDelay' */
        rtb_IntegerDelay = rtb_Multiplication1_bh;
    }
    else
    {
        if (((sint32)KeESSR_Cnt_DelayOptNi) > 16)
        {
            tmp = 16U;
        }
        else
        {
            tmp = KeESSR_Cnt_DelayOptNi;
        }

        /* Delay: '<S2398>/IntegerDelay' */
        rtb_IntegerDelay = localDW->IntegerDelay_DSTATE[(uint8)(16U - ((uint32)
            tmp))];
    }

    /* End of Delay: '<S2398>/IntegerDelay' */

    /* Sum: '<S2398>/Sum15' incorporates:
     *  Abs: '<S2398>/Abs4'
     *  Constant: '<S2332>/Calib'
     *  DataStoreRead: '<S2297>/Dsr_InputSpeedProfile5'
     */
    rtb_Sum15 = fabsf(VeESSR_dn_TargetAcceltn_DS) + KeESSR_dn_NiTargetJerkLimit;

    /* Outputs for Atomic SubSystem: '<S2398>/GradientLimiter' */
    /* Sum: '<S2400>/Sum2' incorporates:
     *  Constant: '<S2309>/Calib'
     *  DataStoreRead: '<S2297>/Dsr_InputSpeedProfile4'
     *  Product: '<S2398>/Product6'
     *  Sum: '<S2398>/Sum14'
     *  UnitDelay: '<S2400>/Unit Delay'
     */
    rtb_Sum2_is = ((rtb_Multiplication1_bh - VeESSR_n_TargetSpeed_DS) /
                   HeESSR_t_MedTEB_dT) - localDW->UnitDelay_DSTATE_i;

    /* Outputs for Atomic SubSystem: '<S2400>/Limiter' */
    /* Switch: '<S2418>/Switch1' incorporates:
     *  RelationalOperator: '<S2418>/Relational Operator'
     */
    if (rtb_Sum15 < rtb_Sum2_is)
    {
        /* MinMax: '<S2401>/MinMax1' */
        rtb_MinMax1_kd = rtb_Sum15;
    }
    else
    {
        /* MinMax: '<S2401>/MinMax1' */
        rtb_MinMax1_kd = rtb_Sum2_is;
    }

    /* End of Switch: '<S2418>/Switch1' */

    /* Switch: '<S2418>/Switch' incorporates:
     *  Gain: '<S2398>/Gain'
     *  RelationalOperator: '<S2418>/Relational Operator1'
     */
    if (rtb_MinMax1_kd <= (-rtb_Sum15))
    {
        rtb_MinMax1_kd = -rtb_Sum15;
    }

    /* End of Switch: '<S2418>/Switch' */
    /* End of Outputs for SubSystem: '<S2400>/Limiter' */

    /* Sum: '<S2400>/Sum3' incorporates:
     *  UnitDelay: '<S2400>/Unit Delay'
     */
    rtb_Switch5_a2 = rtb_MinMax1_kd + localDW->UnitDelay_DSTATE_i;

    /* Update for UnitDelay: '<S2400>/Unit Delay' */
    localDW->UnitDelay_DSTATE_i = rtb_Switch5_a2;

    /* End of Outputs for SubSystem: '<S2398>/GradientLimiter' */

    /* Sum: '<S2399>/Subtraction1' incorporates:
     *  Constant: '<S2334>/Calib'
     *  DataStoreRead: '<S2297>/Dsr_InputSpeedProfile5'
     *  Product: '<S2399>/Multiplication'
     *  Sum: '<S2399>/Subtraction'
     */
    rtb_Sum15 = ((rtb_Switch5_a2 - VeESSR_dn_TargetAcceltn_DS) *
                 KeESSR_k_NiDotTargetFilt) + VeESSR_dn_TargetAcceltn_DS;

    /* DataStoreRead: '<S2297>/Dsr_InputAcceltnProf' */
    rtb_Switch5_a2 = VeESSR_dn_InputAcceltnProf_DS;

    /* Abs: '<S2349>/Abs' incorporates:
     *  DataStoreRead: '<S2297>/Dsr_NiProfGenDNiDLim1'
     */
    rtb_MinMax1_kd = fabsf(VeESSR_dn_StrtTypJerkMaxStartEng_DS);

    /* Switch: '<S2429>/Switch1' incorporates:
     *  Constant: '<S2427>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S2429>/Switch1' incorporates:
         *  Constant: '<S2428>/Calib'
         */
        rtb_Switch1_adj = HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S2416>/Sum6' incorporates:
         *  DataStoreRead: '<S2297>/Dsr_InputAcceltnProf'
         *  Sum: '<S2416>/Sum8'
         */
        rtb_Abs_kl = VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15;

        /* Abs: '<S2416>/Abs' incorporates:
         *  Sum: '<S2416>/Sum6'
         */
        rtb_Sum2_is = (rtb_Abs_kl - rtb_Gain_dx) + rtb_MinMax1_kd;

        /* MinMax: '<S2416>/MinMax2' incorporates:
         *  Abs: '<S2416>/Abs1'
         *  Constant: '<S2309>/Calib'
         *  Constant: '<S2416>/Constant Value'
         *  Constant: '<S2416>/Constant Value3'
         *  DataStoreRead: '<S2297>/Dsr_InputSpeedProfile1'
         *  Product: '<S2416>/Product2'
         *  Product: '<S2416>/Product7'
         *  Product: '<S2431>/Prod'
         *  Sum: '<S2416>/Sum3'
         *  Sum: '<S2416>/Sum5'
         */
        rtb_Sum2_is = fmaxf((fabsf((rtb_IntegerDelay -
                               VeESSR_n_InputSpeedProfile_DS) -
                              (HeESSR_t_MedTEB_dT * rtb_Sum15)) * (rtb_Product4 *
                              -2.0F)) - (rtb_Sum2_is * rtb_Sum2_is), 0.0F);

        /* Switch: '<S2433>/Switch' incorporates:
         *  Sqrt: '<S2433>/Sqrt'
         */
        rtb_Sum2_is = sqrtf(rtb_Sum2_is);

        /* Switch: '<S2429>/Switch1' incorporates:
         *  Abs: '<S2416>/Abs'
         *  Sum: '<S2416>/Sum7'
         *  Sum: '<S2416>/Sum8'
         */
        rtb_Switch1_adj = fabsf(rtb_Abs_kl + rtb_Gain_dx) + (rtb_Sum2_is +
            rtb_Sum15);
    }

    /* End of Switch: '<S2429>/Switch1' */

    /* Product: '<S2398>/Product1' incorporates:
     *  Constant: '<S2309>/Calib'
     */
    rtb_Sum2_is = rtb_MinMax1_kd / HeESSR_t_MedTEB_dT;

    /* Switch: '<S2430>/Switch1' incorporates:
     *  Constant: '<S2427>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S2430>/Switch1' incorporates:
         *  Constant: '<S2428>/Calib'
         *  Gain: '<S2416>/Gain1'
         */
        rtb_Switch1_esq = -HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S2416>/Sum11' incorporates:
         *  DataStoreRead: '<S2297>/Dsr_InputAcceltnProf'
         *  Sum: '<S2416>/Sum13'
         */
        rtb_Switch_bj = VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15;

        /* Abs: '<S2416>/Abs2' incorporates:
         *  Sum: '<S2416>/Sum11'
         */
        rtb_Abs_kl = (rtb_Switch_bj - rtb_MinMax1_kd) + rtb_Gain_dx;

        /* MinMax: '<S2416>/MinMax1' incorporates:
         *  Abs: '<S2416>/Abs3'
         *  Constant: '<S2309>/Calib'
         *  Constant: '<S2416>/Constant Value1'
         *  Constant: '<S2416>/Constant Value2'
         *  DataStoreRead: '<S2297>/Dsr_InputSpeedProfile1'
         *  Product: '<S2416>/Product5'
         *  Product: '<S2416>/Product8'
         *  Product: '<S2434>/Prod'
         *  Sum: '<S2416>/Sum10'
         *  Sum: '<S2416>/Sum9'
         */
        rtb_Abs_kl = fmaxf((fabsf((rtb_IntegerDelay -
                              VeESSR_n_InputSpeedProfile_DS) -
                             (HeESSR_t_MedTEB_dT * rtb_Sum15)) * (rtb_Sum2_is *
                             2.0F)) - (rtb_Abs_kl * rtb_Abs_kl), 0.0F);

        /* Switch: '<S2432>/Switch' incorporates:
         *  Sqrt: '<S2432>/Sqrt'
         */
        rtb_Abs_kl = sqrtf(rtb_Abs_kl);

        /* Switch: '<S2430>/Switch1' incorporates:
         *  Abs: '<S2416>/Abs2'
         *  Sum: '<S2416>/Sum12'
         *  Sum: '<S2416>/Sum13'
         */
        rtb_Switch1_esq = (rtb_Sum15 - rtb_Abs_kl) - fabsf(rtb_Switch_bj +
            rtb_MinMax1_kd);
    }

    /* End of Switch: '<S2430>/Switch1' */

    /* Switch: '<S2398>/Switch1' incorporates:
     *  Constant: '<S2403>/Calib'
     *  Constant: '<S2404>/Calib'
     *  DataStoreRead: '<S2297>/Data Store Read2'
     *  DataStoreRead: '<S2297>/Dsr_InputSpeedProfile8'
     *  Logic: '<S2398>/Logical1'
     *  Logic: '<S2398>/Logical6'
     *  Logic: '<S2398>/Logical8'
     */
    if (((HeESSR_b_NiLmtBypsLoopJerk) && (VeESSR_b_NiMaxActive_DS)) ||
            ((VeESSR_b_NiDotMaxActive_DS) && (HeESSR_b_NiDotLmtBypsLoopJerk)))
    {
        /* Switch: '<S2398>/Switch1' */
        rtb_MinMax1_kd = rtb_Switch1_adj;
    }
    else
    {
        /* Switch: '<S2398>/Switch1' incorporates:
         *  DataStoreRead: '<S2297>/Dsr_InputAcceltnProf'
         *  Sum: '<S2398>/Sum1'
         */
        rtb_MinMax1_kd += VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S2398>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S2398>/Limiter2' */
    /* Switch: '<S2411>/Switch1' incorporates:
     *  RelationalOperator: '<S2411>/Relational Operator'
     */
    if (rtb_Switch1_adj < rtb_MinMax1_kd)
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtb_Switch1_adj;
    }
    else
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtb_MinMax1_kd;
    }

    /* End of Switch: '<S2411>/Switch1' */

    /* Switch: '<S2411>/Switch' incorporates:
     *  RelationalOperator: '<S2411>/Relational Operator1'
     */
    if (rtb_Abs_kl > rtb_Switch1_esq)
    {
        /* Switch: '<S2411>/Switch' */
        rtb_MinMax1_kd = rtb_Abs_kl;
    }
    else
    {
        /* Switch: '<S2411>/Switch' */
        rtb_MinMax1_kd = rtb_Switch1_esq;
    }

    /* End of Switch: '<S2411>/Switch' */
    /* End of Outputs for SubSystem: '<S2398>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S2398>/Limiter4' */
    /* Switch: '<S2413>/Switch1' incorporates:
     *  DataStoreRead: '<S2297>/Dsr_NiProfGenNiDMax1'
     *  RelationalOperator: '<S2413>/Relational Operator'
     */
    if (VeESSR_dn_StrtTypNiDotMax_EngStrt_DS < rtb_MinMax1_kd)
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = VeESSR_dn_StrtTypNiDotMax_EngStrt_DS;
    }
    else
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtb_MinMax1_kd;
    }

    /* End of Switch: '<S2413>/Switch1' */

    /* Switch: '<S2413>/Switch' incorporates:
     *  DataStoreRead: '<S2297>/Dsr_NiProfGenNiDMin'
     *  RelationalOperator: '<S2413>/Relational Operator1'
     */
    if (rtb_Abs_kl > VeESSR_dn_StrtTypNiDotMin_DS)
    {
        /* Switch: '<S2413>/Switch' */
        rtb_Switch_bj = rtb_Abs_kl;
    }
    else
    {
        /* Switch: '<S2413>/Switch' */
        rtb_Switch_bj = VeESSR_dn_StrtTypNiDotMin_DS;
    }

    /* End of Switch: '<S2413>/Switch' */
    /* End of Outputs for SubSystem: '<S2398>/Limiter4' */

    /* Sum: '<S2402>/Sum6' incorporates:
     *  DataStoreRead: '<S2297>/Dsr_InputSpeedProfile1'
     */
    rtb_Sum6_hu = rtu_VeHSER_n_NiMax - VeESSR_n_InputSpeedProfile_DS;

    /* Abs: '<S2402>/Abs2' */
    rtb_Abs_kl = fabsf(rtb_Sum6_hu);

    /* Switch: '<S2402>/Switch' incorporates:
     *  Constant: '<S2402>/Constant Value7'
     *  RelationalOperator: '<S2402>/Comparison2'
     */
    if (rtb_Sum6_hu < 0.0F)
    {
        /* MinMax: '<S2401>/MinMax1' incorporates:
         *  Abs: '<S2402>/Abs'
         */
        rtb_MinMax1_kd = fabsf(rtb_Sum2_is);
    }
    else
    {
        /* MinMax: '<S2401>/MinMax1' incorporates:
         *  Abs: '<S2402>/Abs1'
         *  Gain: '<S2402>/Gain'
         */
        rtb_MinMax1_kd = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S2402>/Switch' */

    /* Product: '<S2402>/Product4' incorporates:
     *  Constant: '<S2309>/Calib'
     */
    rtb_Product4_o = (rtb_MinMax1_kd * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2402>/Protected Division1' */
    /* Switch: '<S2425>/Switch1' incorporates:
     *  Constant: '<S2425>/Constant Value'
     *  Constant: '<S2425>/Constant Value1'
     *  Constant: '<S2425>/Constant Value2'
     *  Logic: '<S2425>/AND'
     *  RelationalOperator: '<S2425>/Greater Than or Equal '
     *  RelationalOperator: '<S2425>/Not Equal'
     *  RelationalOperator: '<S2425>/Not Equal1'
     *  Switch: '<S2425>/Switch2'
     */
    if ((rtb_Abs_kl != 0.0F) && (rtb_Product4_o != 0.0F))
    {
        /* Switch: '<S2425>/Switch1' incorporates:
         *  Product: '<S2425>/Division'
         */
        rtb_Abs_kl /= rtb_Product4_o;
    }
    else if (rtb_Abs_kl > 0.0F)
    {
        /* Switch: '<S2425>/Switch2' incorporates:
         *  Constant: '<S2425>/MAXFLOAT'
         *  Switch: '<S2425>/Switch1'
         */
        rtb_Abs_kl = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2425>/Switch1' incorporates:
         *  Constant: '<S2425>/Constant Value4'
         *  Switch: '<S2425>/Switch2'
         *  Switch: '<S2425>/Switch3'
         */
        rtb_Abs_kl = 0.0F;
    }

    /* End of Switch: '<S2425>/Switch1' */
    /* End of Outputs for SubSystem: '<S2402>/Protected Division1' */

    /* Sum: '<S2402>/Sum4' incorporates:
     *  Abs: '<S2402>/Abs3'
     *  Constant: '<S2402>/Constant Value3'
     *  Constant: '<S2402>/Constant Value5'
     *  Product: '<S2402>/Product3'
     */
    rtb_Abs_kl = (fabsf(rtb_Abs_kl) * 8.0F) + 1.0F;

    /* Switch: '<S2426>/Switch' */
    if (rtb_Abs_kl >= 0.0F)
    {
        /* Abs: '<S2305>/Abs' incorporates:
         *  Sqrt: '<S2426>/Sqrt'
         */
        rtb_Abs_kl = sqrtf(rtb_Abs_kl);
    }
    else
    {
        /* Abs: '<S2305>/Abs' incorporates:
         *  Constant: '<S2426>/Zero'
         */
        rtb_Abs_kl = 0.0F;
    }

    /* End of Switch: '<S2426>/Switch' */

    /* Abs: '<S2305>/Abs' incorporates:
     *  Constant: '<S2402>/Constant Value'
     *  Constant: '<S2402>/Constant Value4'
     *  Constant: '<S2402>/Constant Value6'
     *  MinMax: '<S2402>/MinMax1'
     *  Product: '<S2402>/Product2'
     *  Rounding: '<S2402>/Rounding1'
     *  Sum: '<S2402>/Sum3'
     */
    rtb_Abs_kl = fmaxf(ceilf((rtb_Abs_kl - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S2402>/Product' incorporates:
     *  Constant: '<S2309>/Calib'
     */
    rtb_Product4_o = rtb_Abs_kl * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2402>/Protected Division' */
    /* Switch: '<S2424>/Switch1' incorporates:
     *  Constant: '<S2424>/Constant Value'
     *  Constant: '<S2424>/Constant Value1'
     *  Constant: '<S2424>/Constant Value2'
     *  Constant: '<S2424>/Constant Value3'
     *  Logic: '<S2424>/AND'
     *  RelationalOperator: '<S2424>/Greater Than or Equal '
     *  RelationalOperator: '<S2424>/Greater Than or Equal 1'
     *  RelationalOperator: '<S2424>/Not Equal'
     *  RelationalOperator: '<S2424>/Not Equal1'
     *  Switch: '<S2424>/Switch2'
     *  Switch: '<S2424>/Switch3'
     */
    if ((rtb_Sum6_hu != 0.0F) && (rtb_Product4_o != 0.0F))
    {
        /* Switch: '<S2424>/Switch1' incorporates:
         *  Product: '<S2424>/Division'
         */
        rtb_Sum6_hu /= rtb_Product4_o;
    }
    else if (rtb_Sum6_hu > 0.0F)
    {
        /* Switch: '<S2424>/Switch2' incorporates:
         *  Constant: '<S2424>/MAXFLOAT'
         *  Switch: '<S2424>/Switch1'
         */
        rtb_Sum6_hu = 3.402823466E+38F;
    }
    else if (rtb_Sum6_hu < 0.0F)
    {
        /* Switch: '<S2424>/Switch3' incorporates:
         *  Constant: '<S2424>/MINFLOAT'
         *  Switch: '<S2424>/Switch1'
         *  Switch: '<S2424>/Switch2'
         */
        rtb_Sum6_hu = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2424>/Switch1' incorporates:
         *  Constant: '<S2424>/Constant Value4'
         *  Switch: '<S2424>/Switch2'
         *  Switch: '<S2424>/Switch3'
         */
        rtb_Sum6_hu = 0.0F;
    }

    /* End of Switch: '<S2424>/Switch1' */
    /* End of Outputs for SubSystem: '<S2402>/Protected Division' */

    /* Sum: '<S2402>/Sum' incorporates:
     *  Constant: '<S2309>/Calib'
     *  Constant: '<S2402>/Constant Value1'
     *  Constant: '<S2402>/Constant Value2'
     *  Product: '<S2402>/Product1'
     *  Sum: '<S2402>/Sum2'
     */
    rtb_MinMax1_kd = rtb_Sum6_hu - (((0.5F * rtb_MinMax1_kd) * (rtb_Abs_kl -
        1.0F)) * HeESSR_t_MedTEB_dT);

    /* Switch: '<S2398>/Switch4' incorporates:
     *  Constant: '<S2405>/Calib'
     */
    if (!HeESSR_b_NiLmtForAccelByps)
    {
        /* Switch: '<S2398>/Switch4' incorporates:
         *  MinMax: '<S2398>/MinMax1'
         */
        rtb_Switch_bj = fminf(rtb_MinMax1_kd, rtb_Switch_bj);
    }

    /* End of Switch: '<S2398>/Switch4' */

    /* Outputs for Atomic SubSystem: '<S2398>/Limiter13' */
    /* RelationalOperator: '<S2410>/Relational Operator' */
    rtb_LogicalOperator3_c = (rtu_VeHSER_dn_NiDotMax <= rtb_Switch_bj);

    /* Switch: '<S2410>/Switch1' */
    if (rtb_LogicalOperator3_c)
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtu_VeHSER_dn_NiDotMax;
    }
    else
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtb_Switch_bj;
    }

    /* End of Switch: '<S2410>/Switch1' */

    /* Switch: '<S2410>/Switch' incorporates:
     *  RelationalOperator: '<S2410>/Relational Operator1'
     */
    if (rtb_Abs_kl <= rtu_VeHSER_dn_NiDotMin)
    {
        rtb_Abs_kl = rtu_VeHSER_dn_NiDotMin;
    }

    /* End of Switch: '<S2410>/Switch' */
    /* End of Outputs for SubSystem: '<S2398>/Limiter13' */

    /* Product: '<S2398>/Product9' incorporates:
     *  Constant: '<S2309>/Calib'
     */
    rtb_Switch_bj = rtb_Abs_kl * HeESSR_t_MedTEB_dT;

    /* Switch: '<S2398>/Switch2' incorporates:
     *  Constant: '<S2403>/Calib'
     *  DataStoreRead: '<S2297>/Dsr_InputSpeedProfile9'
     *  Logic: '<S2398>/Logical3'
     */
    if ((HeESSR_b_NiDotLmtBypsLoopJerk) && (VeESSR_b_NiDotMinActive_DS))
    {
        /* Switch: '<S2398>/Switch2' */
        rtb_Gain_dx = rtb_Switch1_esq;
    }
    else
    {
        /* Switch: '<S2398>/Switch2' incorporates:
         *  DataStoreRead: '<S2297>/Dsr_InputAcceltnProf'
         *  Sum: '<S2398>/Sum16'
         */
        rtb_Gain_dx += VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S2398>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S2398>/Limiter' */
    /* Switch: '<S2408>/Switch1' incorporates:
     *  RelationalOperator: '<S2408>/Relational Operator'
     */
    if (rtb_Switch1_adj < rtb_Gain_dx)
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtb_Switch1_adj;
    }
    else
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtb_Gain_dx;
    }

    /* End of Switch: '<S2408>/Switch1' */

    /* Switch: '<S2408>/Switch' incorporates:
     *  RelationalOperator: '<S2408>/Relational Operator1'
     */
    if (rtb_Abs_kl > rtb_Switch1_esq)
    {
        /* Switch: '<S2408>/Switch' */
        rtb_Gain_dx = rtb_Abs_kl;
    }
    else
    {
        /* Switch: '<S2408>/Switch' */
        rtb_Gain_dx = rtb_Switch1_esq;
    }

    /* End of Switch: '<S2408>/Switch' */
    /* End of Outputs for SubSystem: '<S2398>/Limiter' */

    /* Outputs for Atomic SubSystem: '<S2398>/Limiter3' */
    /* Switch: '<S2412>/Switch1' incorporates:
     *  DataStoreRead: '<S2297>/Dsr_NiProfGenNiDMax1'
     *  RelationalOperator: '<S2412>/Relational Operator'
     */
    if (VeESSR_dn_StrtTypNiDotMax_EngStrt_DS < rtb_Gain_dx)
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = VeESSR_dn_StrtTypNiDotMax_EngStrt_DS;
    }
    else
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtb_Gain_dx;
    }

    /* End of Switch: '<S2412>/Switch1' */
    /* End of Outputs for SubSystem: '<S2398>/Limiter3' */

    /* Switch: '<S2398>/Switch5' incorporates:
     *  Constant: '<S2405>/Calib'
     *  DataStoreRead: '<S2297>/Dsr_NiProfGenNiDMin'
     *  RelationalOperator: '<S2412>/Relational Operator1'
     *  Switch: '<S2412>/Switch'
     */
    if (HeESSR_b_NiLmtForAccelByps)
    {
        /* Outputs for Atomic SubSystem: '<S2398>/Limiter3' */
        /* Switch: '<S2412>/Switch' incorporates:
         *  DataStoreRead: '<S2297>/Dsr_NiProfGenNiDMin'
         *  RelationalOperator: '<S2412>/Relational Operator1'
         */
        if (rtb_Abs_kl > VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S2398>/Switch5' */
            rtb_Gain_dx = rtb_Abs_kl;
        }
        else
        {
            /* Switch: '<S2398>/Switch5' */
            rtb_Gain_dx = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Outputs for SubSystem: '<S2398>/Limiter3' */
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S2398>/Limiter3' */
        if (rtb_Abs_kl <= VeESSR_dn_StrtTypNiDotMin_DS)
        {
            /* Switch: '<S2412>/Switch' incorporates:
             *  DataStoreRead: '<S2297>/Dsr_NiProfGenNiDMin'
             */
            rtb_Abs_kl = VeESSR_dn_StrtTypNiDotMin_DS;
        }

        /* End of Outputs for SubSystem: '<S2398>/Limiter3' */

        /* Switch: '<S2398>/Switch5' incorporates:
         *  MinMax: '<S2398>/MinMax2'
         */
        rtb_Gain_dx = fminf(rtb_MinMax1_kd, rtb_Abs_kl);
    }

    /* End of Switch: '<S2398>/Switch5' */

    /* Outputs for Atomic SubSystem: '<S2398>/Limiter9' */
    /* Switch: '<S2415>/Switch1' incorporates:
     *  RelationalOperator: '<S2415>/Relational Operator'
     */
    if (rtu_VeHSER_dn_NiDotMax <= rtb_Gain_dx)
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtu_VeHSER_dn_NiDotMax;
    }
    else
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtb_Gain_dx;
    }

    /* End of Switch: '<S2415>/Switch1' */

    /* Logic: '<S2305>/Logical5' incorporates:
     *  RelationalOperator: '<S2415>/Relational Operator1'
     */
    rtb_OR1_p = (rtb_Abs_kl > rtu_VeHSER_dn_NiDotMin);

    /* Logic: '<S2415>/Logical2' */
    rtb_Logical2_c4 = !rtb_OR1_p;

    /* Switch: '<S2415>/Switch' */
    if (!rtb_OR1_p)
    {
        rtb_Abs_kl = rtu_VeHSER_dn_NiDotMin;
    }

    /* End of Switch: '<S2415>/Switch' */
    /* End of Outputs for SubSystem: '<S2398>/Limiter9' */

    /* Product: '<S2398>/Product10' incorporates:
     *  Constant: '<S2309>/Calib'
     */
    rtb_Gain_dx = rtb_Abs_kl * HeESSR_t_MedTEB_dT;

    /* Sum: '<S2398>/Sum2' incorporates:
     *  DataStoreRead: '<S2297>/Dsr_InputSpeedProfile1'
     */
    rtb_Switch1_adj = rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS;

    /* Sum: '<S2401>/Sum6' incorporates:
     *  Constant: '<S2309>/Calib'
     *  DataStoreRead: '<S2297>/Dsr_InputSpeedProfile1'
     *  Product: '<S2401>/Product7'
     *  Sum: '<S2398>/Sum6'
     *  Switch: '<S2398>/Switch3'
     */
    rtb_IntegerDelay = (rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS) -
        (rtb_Sum15 * HeESSR_t_MedTEB_dT);

    /* Abs: '<S2401>/Abs2' incorporates:
     *  Sum: '<S2401>/Sum6'
     */
    rtb_MinMax1_kd = fabsf(rtb_IntegerDelay);

    /* Switch: '<S2401>/Switch' incorporates:
     *  Constant: '<S2401>/Constant Value7'
     *  RelationalOperator: '<S2401>/Comparison2'
     *  Sum: '<S2401>/Sum6'
     */
    if (rtb_IntegerDelay < 0.0F)
    {
        /* Abs: '<S2305>/Abs' incorporates:
         *  Abs: '<S2401>/Abs'
         */
        rtb_Abs_kl = fabsf(rtb_Sum2_is);
    }
    else
    {
        /* Abs: '<S2305>/Abs' incorporates:
         *  Abs: '<S2401>/Abs1'
         *  Gain: '<S2401>/Gain'
         */
        rtb_Abs_kl = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S2401>/Switch' */

    /* Product: '<S2401>/Product4' incorporates:
     *  Constant: '<S2309>/Calib'
     */
    rtb_Product4 = (rtb_Abs_kl * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2401>/Protected Division1' */
    /* Switch: '<S2421>/Switch1' incorporates:
     *  Constant: '<S2421>/Constant Value'
     *  Constant: '<S2421>/Constant Value1'
     *  Constant: '<S2421>/Constant Value2'
     *  Logic: '<S2421>/AND'
     *  RelationalOperator: '<S2421>/Greater Than or Equal '
     *  RelationalOperator: '<S2421>/Not Equal'
     *  RelationalOperator: '<S2421>/Not Equal1'
     *  Switch: '<S2421>/Switch2'
     */
    if ((rtb_MinMax1_kd != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S2421>/Switch1' incorporates:
         *  Product: '<S2421>/Division'
         */
        rtb_Product4 = rtb_MinMax1_kd / rtb_Product4;
    }
    else if (rtb_MinMax1_kd > 0.0F)
    {
        /* Switch: '<S2421>/Switch2' incorporates:
         *  Constant: '<S2421>/MAXFLOAT'
         *  Switch: '<S2421>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2421>/Switch1' incorporates:
         *  Constant: '<S2421>/Constant Value4'
         *  Switch: '<S2421>/Switch2'
         *  Switch: '<S2421>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S2421>/Switch1' */
    /* End of Outputs for SubSystem: '<S2401>/Protected Division1' */

    /* Sum: '<S2401>/Sum4' incorporates:
     *  Abs: '<S2401>/Abs3'
     *  Constant: '<S2401>/Constant Value3'
     *  Constant: '<S2401>/Constant Value5'
     *  Product: '<S2401>/Product3'
     */
    rtb_Product4 = (fabsf(rtb_Product4) * 8.0F) + 1.0F;

    /* Switch: '<S2422>/Switch' incorporates:
     *  Constant: '<S2422>/Zero'
     *  Sqrt: '<S2422>/Sqrt'
     */
    if (rtb_Product4 >= 0.0F)
    {
        rtb_Product4 = sqrtf(rtb_Product4);
    }
    else
    {
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S2422>/Switch' */

    /* MinMax: '<S2401>/MinMax1' incorporates:
     *  Constant: '<S2401>/Constant Value'
     *  Constant: '<S2401>/Constant Value4'
     *  Constant: '<S2401>/Constant Value6'
     *  Product: '<S2401>/Product2'
     *  Rounding: '<S2401>/Rounding1'
     *  Sum: '<S2401>/Sum3'
     */
    rtb_MinMax1_kd = fmaxf(ceilf((rtb_Product4 - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S2401>/Product' incorporates:
     *  Constant: '<S2309>/Calib'
     */
    rtb_Product4 = rtb_MinMax1_kd * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2401>/Protected Division' */
    /* Switch: '<S2420>/Switch1' incorporates:
     *  Constant: '<S2420>/Constant Value'
     *  Constant: '<S2420>/Constant Value1'
     *  Constant: '<S2420>/Constant Value2'
     *  Constant: '<S2420>/Constant Value3'
     *  Logic: '<S2420>/AND'
     *  RelationalOperator: '<S2420>/Greater Than or Equal '
     *  RelationalOperator: '<S2420>/Greater Than or Equal 1'
     *  RelationalOperator: '<S2420>/Not Equal'
     *  RelationalOperator: '<S2420>/Not Equal1'
     *  Sum: '<S2401>/Sum6'
     *  Switch: '<S2420>/Switch2'
     *  Switch: '<S2420>/Switch3'
     */
    if ((rtb_IntegerDelay != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S2420>/Switch1' incorporates:
         *  Product: '<S2420>/Division'
         */
        rtb_Product4 = rtb_IntegerDelay / rtb_Product4;
    }
    else if (rtb_IntegerDelay > 0.0F)
    {
        /* Switch: '<S2420>/Switch2' incorporates:
         *  Constant: '<S2420>/MAXFLOAT'
         *  Switch: '<S2420>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else if (rtb_IntegerDelay < 0.0F)
    {
        /* Switch: '<S2420>/Switch3' incorporates:
         *  Constant: '<S2420>/MINFLOAT'
         *  Switch: '<S2420>/Switch1'
         *  Switch: '<S2420>/Switch2'
         */
        rtb_Product4 = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2420>/Switch1' incorporates:
         *  Constant: '<S2420>/Constant Value4'
         *  Switch: '<S2420>/Switch2'
         *  Switch: '<S2420>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S2420>/Switch1' */
    /* End of Outputs for SubSystem: '<S2401>/Protected Division' */

    /* Switch: '<S2398>/Switch3' incorporates:
     *  Constant: '<S2406>/Calib'
     */
    if (!HeESSR_b_TrnstnJerkByps)
    {
        /* Switch: '<S2398>/Switch8' incorporates:
         *  Constant: '<S2398>/Constant Value7'
         *  RelationalOperator: '<S2398>/Comparison'
         */
        if (rtb_IntegerDelay > 0.0F)
        {
            /* Switch: '<S2398>/Switch3' incorporates:
             *  Constant: '<S2309>/Calib'
             *  Constant: '<S2401>/Constant Value1'
             *  Constant: '<S2401>/Constant Value2'
             *  MinMax: '<S2398>/MinMax4'
             *  Product: '<S2398>/Product5'
             *  Product: '<S2401>/Product1'
             *  Sum: '<S2401>/Sum'
             *  Sum: '<S2401>/Sum2'
             *  Switch: '<S2398>/Switch8'
             */
            rtb_Switch1_adj = fminf(rtb_Switch1_adj, ((rtb_Product4 + rtb_Sum15)
                - (((0.5F * rtb_Abs_kl) * (rtb_MinMax1_kd - 1.0F)) *
                   HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }
        else
        {
            /* Switch: '<S2398>/Switch3' incorporates:
             *  Constant: '<S2309>/Calib'
             *  Constant: '<S2401>/Constant Value1'
             *  Constant: '<S2401>/Constant Value2'
             *  MinMax: '<S2398>/MinMax5'
             *  Product: '<S2398>/Product2'
             *  Product: '<S2401>/Product1'
             *  Sum: '<S2401>/Sum'
             *  Sum: '<S2401>/Sum2'
             *  Switch: '<S2398>/Switch8'
             */
            rtb_Switch1_adj = fmaxf(rtb_Switch1_adj, ((rtb_Product4 + rtb_Sum15)
                - (((0.5F * rtb_Abs_kl) * (rtb_MinMax1_kd - 1.0F)) *
                   HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }

        /* End of Switch: '<S2398>/Switch8' */
    }

    /* Outputs for Atomic SubSystem: '<S2398>/Limiter6' */
    /* RelationalOperator: '<S2414>/Relational Operator' */
    rtb_RelationalOperator_is = (rtb_Switch_bj <= rtb_Switch1_adj);

    /* Switch: '<S2414>/Switch1' */
    if (rtb_RelationalOperator_is)
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtb_Switch_bj;
    }
    else
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtb_Switch1_adj;
    }

    /* End of Switch: '<S2414>/Switch1' */

    /* Logic: '<S2305>/Logical5' incorporates:
     *  RelationalOperator: '<S2414>/Relational Operator1'
     */
    rtb_OR1_p = (rtb_Abs_kl > rtb_Gain_dx);

    /* Switch: '<S2414>/Switch' */
    if (rtb_OR1_p)
    {
        rtb_Gain_dx = rtb_Abs_kl;
    }

    /* End of Switch: '<S2414>/Switch' */
    /* End of Outputs for SubSystem: '<S2398>/Limiter6' */

    /* Sum: '<S2398>/Sum4' incorporates:
     *  DataStoreRead: '<S2297>/Dsr_InputSpeedProfile1'
     */
    rtb_IntegerDelay = rtb_Gain_dx + VeESSR_n_InputSpeedProfile_DS;

    /* Outputs for Atomic SubSystem: '<S2398>/Limiter1' */
    /* RelationalOperator: '<S2409>/Relational Operator' incorporates:
     *  DataStoreWrite: '<S2297>/Dsw_InputSpeedProfile5'
     */
    VeESSR_b_NiMaxActive_DS = (rtu_VeHSER_n_NiMax <= rtb_IntegerDelay);

    /* Switch: '<S2409>/Switch1' incorporates:
     *  DataStoreWrite: '<S2297>/Dsw_InputSpeedProfile5'
     */
    if (VeESSR_b_NiMaxActive_DS)
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtu_VeHSER_n_NiMax;
    }
    else
    {
        /* Abs: '<S2305>/Abs' */
        rtb_Abs_kl = rtb_IntegerDelay;
    }

    /* End of Switch: '<S2409>/Switch1' */

    /* Switch: '<S2409>/Switch' incorporates:
     *  Constant: '<S2398>/Constant Value4'
     *  RelationalOperator: '<S2409>/Relational Operator1'
     */
    if (rtb_Abs_kl > 0.0F)
    {
        /* Switch: '<S2409>/Switch' */
        rtb_IntegerDelay = rtb_Abs_kl;
    }
    else
    {
        /* Switch: '<S2409>/Switch' */
        rtb_IntegerDelay = 0.0F;
    }

    /* End of Switch: '<S2409>/Switch' */
    /* End of Outputs for SubSystem: '<S2398>/Limiter1' */

    /* Product: '<S2398>/Product3' incorporates:
     *  Constant: '<S2309>/Calib'
     *  DataStoreRead: '<S2297>/Dsr_InputSpeedProfile1'
     *  DataStoreWrite: '<S2297>/Dsw_InputAcceltnProf'
     *  Sum: '<S2398>/Sum'
     */
    VeESSR_dn_InputAcceltnProf_DS = (rtb_IntegerDelay -
        VeESSR_n_InputSpeedProfile_DS) / HeESSR_t_MedTEB_dT;

    /* DataStoreWrite: '<S2297>/Dsw_InputSpeedProfile' */
    VeESSR_n_InputSpeedProfile_DS = rtb_IntegerDelay;

    /* Logic: '<S2398>/Logical2' incorporates:
     *  DataStoreWrite: '<S2297>/Dsw_InputSpeedProfile1'
     */
    VeESSR_b_NiDotMaxActive_DS = (rtb_LogicalOperator3_c &&
        rtb_RelationalOperator_is);

    /* DataStoreWrite: '<S2297>/Dsw_InputSpeedProfile2' */
    VeESSR_n_TargetSpeed_DS = rtb_Multiplication1_bh;

    /* DataStoreWrite: '<S2297>/Dsw_InputSpeedProfile3' */
    VeESSR_dn_TargetAcceltn_DS = rtb_Sum15;

    /* Outputs for Atomic SubSystem: '<S2398>/Limiter6' */
    /* Logic: '<S2398>/Logical' incorporates:
     *  DataStoreWrite: '<S2297>/Dsw_InputSpeedProfile4'
     *  Logic: '<S2414>/Logical2'
     */
    VeESSR_b_NiDotMinActive_DS = (rtb_Logical2_c4 && (!rtb_OR1_p));

    /* End of Outputs for SubSystem: '<S2398>/Limiter6' */

    /* Outputs for Atomic SubSystem: '<S2297>/Hysteresis1' */
    /* Switch: '<S2312>/Switch1' incorporates:
     *  Constant: '<S2322>/Calib'
     *  RelationalOperator: '<S2312>/Greater  Than'
     */
    if (VeESSR_K_EMStrtBlendRatio > KeESSR_K_TitoEngTrqBlendThresh)
    {
        /* Switch: '<S2312>/Switch1' incorporates:
         *  Constant: '<S2312>/Constant Value'
         */
        rtb_OR1_p = true;
    }
    else
    {
        /* Switch: '<S2312>/Switch1' incorporates:
         *  Constant: '<S2321>/Calib'
         *  RelationalOperator: '<S2312>/Greater  Than1'
         *  Sum: '<S2297>/Sum8'
         *  UnitDelay: '<S2312>/Unit Delay'
         */
        rtb_OR1_p = ((VeESSR_K_EMStrtBlendRatio >=
                      (KeESSR_K_TitoEngTrqBlendThresh -
                       KeESSR_K_TitoEngTrqBlendHys)) &&
                     (localDW->UnitDelay_DSTATE_f));
    }

    /* End of Switch: '<S2312>/Switch1' */

    /* Update for UnitDelay: '<S2312>/Unit Delay' */
    localDW->UnitDelay_DSTATE_f = rtb_OR1_p;

    /* End of Outputs for SubSystem: '<S2297>/Hysteresis1' */

    /* Outputs for Atomic SubSystem: '<S2297>/Hysteresis' */
    /* Switch: '<S2311>/Switch1' incorporates:
     *  Constant: '<S2324>/Calib'
     *  RelationalOperator: '<S2311>/Greater  Than'
     */
    if (VeESSR_K_EMStrtBlendRatio > KeESSR_K_TitoZeroBlendThresh)
    {
        /* Switch: '<S2311>/Switch1' incorporates:
         *  Constant: '<S2311>/Constant Value'
         */
        rtb_LogicalOperator3_c = true;
    }
    else
    {
        /* Switch: '<S2311>/Switch1' incorporates:
         *  Constant: '<S2323>/Calib'
         *  RelationalOperator: '<S2311>/Greater  Than1'
         *  Sum: '<S2297>/Sum7'
         *  UnitDelay: '<S2311>/Unit Delay'
         */
        rtb_LogicalOperator3_c = ((VeESSR_K_EMStrtBlendRatio >=
            (KeESSR_K_TitoZeroBlendThresh - KeESSR_K_TitoZeroBlendHys)) &&
            (localDW->UnitDelay_DSTATE_cd));
    }

    /* End of Switch: '<S2311>/Switch1' */

    /* Update for UnitDelay: '<S2311>/Unit Delay' */
    localDW->UnitDelay_DSTATE_cd = rtb_LogicalOperator3_c;

    /* End of Outputs for SubSystem: '<S2297>/Hysteresis' */

    /* If: '<S2297>/If1' */
    if (rtb_OR1_p)
    {
        /* Switch: '<S2297>/Switch6' incorporates:
         *  Constant: '<S2330>/Calib'
         */
        if (KeESSR_b_LmtEngTrqAct)
        {
            /* Outputs for IfAction SubSystem: '<S2297>/TiEst_Blendto_EngTrqAct' incorporates:
             *  ActionPort: '<S2351>/Action Port'
             */
            /* Merge: '<S2297>/Merge1' incorporates:
             *  Inport: '<S2351>/EngTrqAct'
             *  MinMax: '<S2297>/MinMax'
             */
            VeESSR_M_EMTrgtEngTrqEst = fminf(rtu_VeOITR_M_InputTorqMaxTact,
                rtu_VeETQR_M_EngTrqActual);

            /* End of Outputs for SubSystem: '<S2297>/TiEst_Blendto_EngTrqAct' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S2297>/TiEst_Blendto_EngTrqAct' incorporates:
             *  ActionPort: '<S2351>/Action Port'
             */
            /* Merge: '<S2297>/Merge1' incorporates:
             *  Inport: '<S2351>/EngTrqAct'
             */
            VeESSR_M_EMTrgtEngTrqEst = rtu_VeETQR_M_EngTrqActual;

            /* End of Outputs for SubSystem: '<S2297>/TiEst_Blendto_EngTrqAct' */
        }

        /* End of Switch: '<S2297>/Switch6' */

        /* Outputs for IfAction SubSystem: '<S2297>/TiEst_Blendto_EngTrqAct' incorporates:
         *  ActionPort: '<S2351>/Action Port'
         */
        /* Merge: '<S2297>/Merge2' incorporates:
         *  Lookup_n-D: '<S2435>/Vector'
         *  Switch: '<S2342>/Switch'
         */
        VeESSR_K_EMTiEstBlndCoeff = look1_iflf_binlcapw
            (VeESSR_K_EMStrtBlendRatio, ((const float32 *)
              &(KxESSR_K_BlendTitoEngTrq[0])), ((const float32 *)
              &(KtESSR_K_BlendTitoEngTrq[0])), 6U);

        /* End of Outputs for SubSystem: '<S2297>/TiEst_Blendto_EngTrqAct' */
    }
    else if (rtb_LogicalOperator3_c)
    {
        /* Outputs for IfAction SubSystem: '<S2297>/TiEst_Blendto_ZeroTo' incorporates:
         *  ActionPort: '<S2352>/Action Port'
         */
        /* Merge: '<S2297>/Merge1' incorporates:
         *  Constant: '<S2352>/Constant Value'
         *  SignalConversion generated from: '<S2352>/TiEst'
         */
        VeESSR_M_EMTrgtEngTrqEst = 0.0F;

        /* Merge: '<S2297>/Merge2' incorporates:
         *  Constant: '<S2436>/Calib'
         *  SignalConversion generated from: '<S2352>/m_coeff'
         */
        VeESSR_K_EMTiEstBlndCoeff = KeESSR_K_BlendTitoTo;

        /* End of Outputs for SubSystem: '<S2297>/TiEst_Blendto_ZeroTo' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2297>/Hold_TiEst' incorporates:
         *  ActionPort: '<S2310>/Action Port'
         */
        /* Merge: '<S2297>/Merge2' incorporates:
         *  Constant: '<S2310>/Constant Value'
         *  SignalConversion generated from: '<S2310>/m_coeff'
         */
        VeESSR_K_EMTiEstBlndCoeff = 0.0F;

        /* End of Outputs for SubSystem: '<S2297>/Hold_TiEst' */
    }

    /* End of If: '<S2297>/If1' */

    /* Outputs for Atomic SubSystem: '<S2297>/Digital Lowpass Reset Enabled1' */
    /* Outputs for Atomic SubSystem: '<S2303>/Signal Latch On With Reset' */
    /* Logic: '<S2353>/OR1' incorporates:
     *  Logic: '<S2303>/Logical Operator'
     *  Logic: '<S2353>/OR'
     *  RelationalOperator: '<S2303>/Relational Operator'
     *  UnitDelay: '<S2353>/Unit Delay'
     */
    rtb_OR1_p = ((rtb_Switch1_mv && (VeESSR_M_EMTrgtEngTrqEst > rtu_TiEstMin)) ||
                 (rtb_OR1_ep_tmp && (localDW->UnitDelay_DSTATE_nt)));

    /* Update for UnitDelay: '<S2353>/Unit Delay' */
    localDW->UnitDelay_DSTATE_nt = rtb_OR1_p;

    /* End of Outputs for SubSystem: '<S2303>/Signal Latch On With Reset' */

    /* Switch: '<S2303>/Switch1' */
    if (rtb_Switch1_mv)
    {
        /* Switch: '<S2303>/Switch1' incorporates:
         *  DataStoreRead: '<S2297>/Data Store Read3'
         */
        rtb_IntegerDelay = VeESSR_M_TiEstEMOpnLp;
    }
    else
    {
        /* Switch: '<S2303>/Switch1' incorporates:
         *  Product: '<S2303>/Multiplication'
         *  Sum: '<S2303>/Subtraction'
         *  Sum: '<S2303>/Summation'
         *  UnitDelay: '<S2303>/Unit Delay'
         */
        rtb_IntegerDelay = ((VeESSR_M_EMTrgtEngTrqEst -
                             localDW->UnitDelay_DSTATE_n) *
                            VeESSR_K_EMTiEstBlndCoeff) +
            localDW->UnitDelay_DSTATE_n;
    }

    /* End of Switch: '<S2303>/Switch1' */

    /* If: '<S2303>/If' */
    rtPrevAction = localDW->If_ActiveSubsystem;
    rtAction = (sint8)((!rtb_OR1_p) ? 1 : 0);
    localDW->If_ActiveSubsystem = rtAction;
    if (rtAction == 0)
    {
        /* Outputs for IfAction SubSystem: '<S2303>/Subsystem' incorporates:
         *  ActionPort: '<S2354>/Action Port'
         */
        ESSR_ac_Subsystem(rtu_TiEstMin, rtb_IntegerDelay,
                          VeESSR_M_EMTrgtEngTrqEst,
                          (&(VeESSR_M_EMEngTorqEstOpnLoop)));

        /* End of Outputs for SubSystem: '<S2303>/Subsystem' */
    }
    else
    {
        if (rtAction != rtPrevAction)
        {
            /* SystemReset for IfAction SubSystem: '<S2303>/Subsystem1' incorporates:
             *  ActionPort: '<S2355>/Action Port'
             */
            /* SystemReset for If: '<S2303>/If' */
            ESSR_ac_Subsystem1_Reset(&localDW->Subsystem1);

            /* End of SystemReset for SubSystem: '<S2303>/Subsystem1' */
        }

        /* Outputs for IfAction SubSystem: '<S2303>/Subsystem1' incorporates:
         *  ActionPort: '<S2355>/Action Port'
         */
        ESSR_ac_Subsystem1(rtu_TiEstMin, rtb_IntegerDelay,
                           VeESSR_M_EMTrgtEngTrqEst,
                           rtu_VeENGR_b_EngCombustionCmnd,
                           (&(VeESSR_M_EMEngTorqEstOpnLoop)),
                           &localDW->Subsystem1);

        /* End of Outputs for SubSystem: '<S2303>/Subsystem1' */
    }

    /* End of If: '<S2303>/If' */

    /* Switch: '<S2303>/Switch' incorporates:
     *  Constant: '<S2303>/KeESSR_b_EnblTiEstFltLim'
     */
    if (KeESSR_b_EnblTiEstFltLim)
    {
        /* Update for UnitDelay: '<S2303>/Unit Delay' */
        localDW->UnitDelay_DSTATE_n = VeESSR_M_EMEngTorqEstOpnLoop;
    }
    else
    {
        /* Update for UnitDelay: '<S2303>/Unit Delay' */
        localDW->UnitDelay_DSTATE_n = rtb_IntegerDelay;
    }

    /* End of Switch: '<S2303>/Switch' */
    /* End of Outputs for SubSystem: '<S2297>/Digital Lowpass Reset Enabled1' */

    /* Outputs for Atomic SubSystem: '<S2297>/Protected Division1' */
    /* Switch: '<S2348>/Switch1' incorporates:
     *  Constant: '<S2340>/Calib'
     *  Constant: '<S2348>/Constant Value'
     *  Constant: '<S2348>/Constant Value1'
     *  Constant: '<S2348>/Constant Value2'
     *  Constant: '<S2348>/Constant Value3'
     *  Logic: '<S2348>/AND'
     *  RelationalOperator: '<S2348>/Greater Than or Equal '
     *  RelationalOperator: '<S2348>/Greater Than or Equal 1'
     *  RelationalOperator: '<S2348>/Not Equal'
     *  RelationalOperator: '<S2348>/Not Equal1'
     *  Switch: '<S2348>/Switch2'
     *  Switch: '<S2348>/Switch3'
     */
    if ((rtu_VeMSPR_n_MtrB_Spd != 0.0F) && (((float32)
            Rte_Prm_KeTSXR_r_P2p5_KeTSXR_r_P2p5()) != 0.0F))
    {
        /* Switch: '<S2348>/Switch1' incorporates:
         *  Product: '<S2348>/Division'
         */
        rtb_IntegerDelay = rtu_VeMSPR_n_MtrB_Spd / ((float32)
            Rte_Prm_KeTSXR_r_P2p5_KeTSXR_r_P2p5());
    }
    else if (rtu_VeMSPR_n_MtrB_Spd > 0.0F)
    {
        /* Switch: '<S2348>/Switch2' incorporates:
         *  Constant: '<S2348>/MAXFLOAT'
         *  Switch: '<S2348>/Switch1'
         */
        rtb_IntegerDelay = 3.402823466E+38F;
    }
    else if (rtu_VeMSPR_n_MtrB_Spd < 0.0F)
    {
        /* Switch: '<S2348>/Switch3' incorporates:
         *  Constant: '<S2348>/MINFLOAT'
         *  Switch: '<S2348>/Switch1'
         *  Switch: '<S2348>/Switch2'
         */
        rtb_IntegerDelay = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2348>/Switch1' incorporates:
         *  Constant: '<S2348>/Constant Value4'
         *  Switch: '<S2348>/Switch2'
         *  Switch: '<S2348>/Switch3'
         */
        rtb_IntegerDelay = 0.0F;
    }

    /* End of Switch: '<S2348>/Switch1' */
    /* End of Outputs for SubSystem: '<S2297>/Protected Division1' */

    /* Lookup_n-D: '<S2341>/Vector' incorporates:
     *  Sum: '<S2297>/Summation2'
     */
    VeESSR_K_EMStrtEngSpdCtlPgain = look1_iflf_binlcapw(rtb_IntegerDelay -
        VeESSR_n_NiAfterCombEM, ((const float32 *)&(KxESSR_K_EMStrtEngPgain[0])),
        ((const float32 *)&(KtESSR_K_EMStrtEngPgain[0])), 4U);

    /* Lookup_n-D: '<S2393>/Vector' incorporates:
     *  DataStoreRead: '<S2346>/Dsr_InputSpeedProfile6'
     *  Sum: '<S2346>/Sum1'
     */
    VeESSR_K_DeltaGainMultEM = look1_iflf_binlcapw(rtu_VeESSR_n_TransInSpdFlt -
        VeESSR_n_InputSpeedProfile_DS, ((const float32 *)
        &(KxESSR_K_DeltaGainMult[0])), ((const float32 *)
        &(KtESSR_K_DeltaGainMult[0])), 4U);

    /* Switch: '<S2346>/Switch1' */
    if (rtb_Switch1_mv)
    {
        /* Switch: '<S2346>/Switch1' */
        VeESSR_n_EMEngMinTgtPCtrl = rtu_VeESSR_n_TransInSpdFlt;
    }
    else
    {
        /* Abs: '<S2346>/Abs' */
        rtb_Sum15 = fabsf(rtu_VeETQR_M_EngCapacityMinOff);

        /* Outputs for Atomic SubSystem: '<S2346>/Protected Division1' */
        /* Switch: '<S2395>/Switch1' incorporates:
         *  Constant: '<S2395>/Constant Value'
         *  Constant: '<S2395>/Constant Value1'
         *  Constant: '<S2395>/Constant Value2'
         *  Logic: '<S2395>/AND'
         *  RelationalOperator: '<S2395>/Greater Than or Equal '
         *  RelationalOperator: '<S2395>/Not Equal'
         *  RelationalOperator: '<S2395>/Not Equal1'
         *  Switch: '<S2395>/Switch2'
         */
        if ((rtb_Sum15 != 0.0F) && (VeESSR_K_EMStrtEngSpdCtlPgain != 0.0F))
        {
            /* Switch: '<S2395>/Switch1' incorporates:
             *  Product: '<S2395>/Division'
             */
            rtb_Sum15 /= VeESSR_K_EMStrtEngSpdCtlPgain;
        }
        else if (rtb_Sum15 > 0.0F)
        {
            /* Switch: '<S2395>/Switch2' incorporates:
             *  Constant: '<S2395>/MAXFLOAT'
             *  Switch: '<S2395>/Switch1'
             */
            rtb_Sum15 = 3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S2395>/Switch1' incorporates:
             *  Constant: '<S2395>/Constant Value4'
             *  Switch: '<S2395>/Switch2'
             *  Switch: '<S2395>/Switch3'
             */
            rtb_Sum15 = 0.0F;
        }

        /* End of Switch: '<S2395>/Switch1' */
        /* End of Outputs for SubSystem: '<S2346>/Protected Division1' */

        /* Sum: '<S2346>/Sum3' incorporates:
         *  Constant: '<S2392>/Calib'
         *  DataStoreRead: '<S2346>/Dsr_InputSpeedProfile6'
         *  MinMax: '<S2346>/MinMax3'
         *  Product: '<S2346>/Product'
         *  Sum: '<S2346>/Sum2'
         *  UnitDelay: '<S2346>/Unit Delay'
         */
        rtb_Sum15 = (fminf(KeESSR_n_MaxOffstEngMinTgt, rtb_Sum15 *
                           VeESSR_K_DeltaGainMultEM) +
                     VeESSR_n_InputSpeedProfile_DS) - VeESSR_n_EMEngMinTgtPCtrl;

        /* Outputs for Atomic SubSystem: '<S2346>/Limiter' */
        /* Switch: '<S2394>/Switch1' incorporates:
         *  Constant: '<S2391>/Calib'
         *  RelationalOperator: '<S2394>/Relational Operator'
         */
        if (KeESSR_dn_PtgtLU < rtb_Sum15)
        {
            /* Switch: '<S2394>/Switch1' */
            rtb_Sum15 = KeESSR_dn_PtgtLU;
        }

        /* End of Switch: '<S2394>/Switch1' */

        /* Switch: '<S2394>/Switch' incorporates:
         *  Constant: '<S2390>/Calib'
         *  RelationalOperator: '<S2394>/Relational Operator1'
         */
        if (rtb_Sum15 <= KeESSR_dn_PtgtLD)
        {
            rtb_Sum15 = KeESSR_dn_PtgtLD;
        }

        /* End of Switch: '<S2394>/Switch' */
        /* End of Outputs for SubSystem: '<S2346>/Limiter' */

        /* Switch: '<S2346>/Switch1' incorporates:
         *  Sum: '<S2346>/Sum4'
         *  UnitDelay: '<S2346>/Unit Delay'
         */
        VeESSR_n_EMEngMinTgtPCtrl = rtb_Sum15 + VeESSR_n_EMEngMinTgtPCtrl;
    }

    /* End of Switch: '<S2346>/Switch1' */

    /* Sum: '<S2304>/Summation5' */
    VeESSR_n_EngStrtEMSpdError = rtu_VeESSR_n_TransInSpdFlt -
        VeESSR_n_EMEngMinTgtPCtrl;

    /* MinMax: '<S2304>/MinMax' incorporates:
     *  Constant: '<S2304>/Constant Value'
     *  Product: '<S2304>/Multiplication'
     */
    VeESSR_M_EngStrtEMPSpdCtl = fminf(0.0F, VeESSR_n_EngStrtEMSpdError *
        VeESSR_K_EMStrtEngSpdCtlPgain);

    /* MinMax: '<S2297>/MinMax1' incorporates:
     *  DataStoreWrite: '<S2297>/Dsw_InputTorqEst'
     *  Sum: '<S2297>/Sum'
     */
    VeESSR_M_EngTorqEst_DS = fmaxf(VeESSR_M_EMEngTorqEstOpnLoop +
        VeESSR_M_EngStrtEMPSpdCtl, rtu_TiEstMin);

    /* DataStoreWrite: '<S2297>/Dsw_Ni1stFlt_DS' */
    VeESSR_n_Ni1stFlt_DS = rtb_Multiplication1_fy;

    /* DataStoreWrite: '<S2297>/Dsw_STMTmr' incorporates:
     *  Constant: '<S2309>/Calib'
     *  DataStoreRead: '<S2297>/Dsr_STMTmr'
     *  Sum: '<S2297>/Summation1'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Logic: '<S2305>/Logical Operator3' incorporates:
     *  Abs: '<S2305>/Abs'
     *  Constant: '<S2366>/Calib'
     *  Constant: '<S2367>/Calib'
     *  Logic: '<S2305>/Logical3'
     *  RelationalOperator: '<S2305>/Greater  Than1'
     *  RelationalOperator: '<S2305>/Relational Operator'
     *  Sum: '<S2305>/Add'
     */
    rtb_LogicalOperator3_c = ((fabsf(rtu_VeESSR_M_EngStrtTorqSnsd -
        rtu_VeETQR_M_EngTrqActual) < KeESSR_M_MaxEngTorqError) ||
        (rtu_VeESSR_M_EngStrtTorqSnsd > KeESSR_M_MinEngStrtTorqSnsd));

    /* Outputs for Atomic SubSystem: '<S2305>/Signal Latch On With Reset' */
    /* Logic: '<S2372>/OR1' incorporates:
     *  Logic: '<S2305>/Logical4'
     *  Logic: '<S2372>/OR'
     *  UnitDelay: '<S2372>/Unit Delay'
     */
    rtb_OR1_p = ((rtb_LogicalOperator3_c && rtu_VeENGR_b_EngCombustionCmnd) ||
                 (rtb_OR1_ep_tmp && (localDW->UnitDelay_DSTATE_a)));

    /* Update for UnitDelay: '<S2372>/Unit Delay' */
    localDW->UnitDelay_DSTATE_a = rtb_OR1_p;

    /* End of Outputs for SubSystem: '<S2305>/Signal Latch On With Reset' */

    /* Outputs for Atomic SubSystem: '<S2361>/Accumulator Reset Limited' */
    /* Switch: '<S2373>/Switch1' incorporates:
     *  Constant: '<S2362>/Constant'
     *  DataStoreRead: '<S2305>/Dsr_STMTmr7'
     *  Logic: '<S2305>/Logical1'
     *  RelationalOperator: '<S2305>/Comparison7'
     */
    if (rtb_Switch1_mv || (CeESSR_e_Startng != ((uint32)
            VeESSR_e_TCM_TransitionStatus_DS)))
    {
        /* Switch: '<S2373>/Switch1' incorporates:
         *  Constant: '<S2361>/Constant Value1'
         */
        rtb_Multiplication1_fy = 0.0F;
    }
    else
    {
        /* Sum: '<S2373>/Summation' incorporates:
         *  Constant: '<S2374>/Calib'
         *  Constant: '<S2376>/Calib'
         *  Product: '<S2361>/Product'
         *  Sum: '<S2361>/Sum1'
         *  UnitDelay: '<S2373>/Unit Delay'
         */
        rtb_Multiplication1_fy = (((rtu_VeESSR_n_TransInSpdFlt -
            KeESSR_n_EngStrtExitSpdDelta) - VeESSR_n_NiAfterCombEM) *
            HeESSR_t_MedTEB_dT) + localDW->UnitDelay_DSTATE_c;

        /* Outputs for Atomic SubSystem: '<S2373>/Limiter' */
        /* Switch: '<S2377>/Switch1' incorporates:
         *  Constant: '<S2375>/Calib'
         *  RelationalOperator: '<S2377>/Relational Operator'
         */
        if (KeESSR_n_EngStrtExitIntgrlVal < rtb_Multiplication1_fy)
        {
            /* Switch: '<S2377>/Switch1' */
            rtb_Multiplication1_fy = KeESSR_n_EngStrtExitIntgrlVal;
        }

        /* End of Switch: '<S2377>/Switch1' */

        /* Switch: '<S2377>/Switch' incorporates:
         *  Constant: '<S2361>/Constant Value1'
         *  RelationalOperator: '<S2377>/Relational Operator1'
         */
        if (rtb_Multiplication1_fy <= 0.0F)
        {
            /* Switch: '<S2373>/Switch1' */
            rtb_Multiplication1_fy = 0.0F;
        }

        /* End of Switch: '<S2377>/Switch' */
        /* End of Outputs for SubSystem: '<S2373>/Limiter' */
    }

    /* End of Switch: '<S2373>/Switch1' */

    /* Update for UnitDelay: '<S2373>/Unit Delay' */
    localDW->UnitDelay_DSTATE_c = rtb_Multiplication1_fy;

    /* End of Outputs for SubSystem: '<S2361>/Accumulator Reset Limited' */

    /* RelationalOperator: '<S2361>/Comparison4' incorporates:
     *  Constant: '<S2375>/Calib'
     */
    VeESSR_b_SpdChk_EMStrtEng = (rtb_Multiplication1_fy ==
        KeESSR_n_EngStrtExitIntgrlVal);

    /* Logic: '<S2305>/Logical13' incorporates:
     *  Constant: '<S2363>/Constant'
     *  Constant: '<S2364>/Constant'
     *  RelationalOperator: '<S2305>/Comparison5'
     *  RelationalOperator: '<S2305>/Comparison6'
     */
    VeESSR_b_ETRQEMStrtEng = ((((uint32)rtu_VeENGR_e_ETRQ_Mode) ==
        CeENGR_e_DriverControl) || (((uint32)rtu_VeENGR_e_ETRQ_Mode) ==
        CeENGR_e_Idle));

    /* Switch: '<S2315>/Switch1' incorporates:
     *  Constant: '<S2302>/Constant'
     *  Constant: '<S2365>/Calib'
     *  Constant: '<S2368>/Calib'
     *  Constant: '<S2369>/Calib'
     *  Constant: '<S2370>/Calib'
     *  DataStoreRead: '<S2305>/Dsr_STMTmr2'
     *  DataStoreWrite: '<S2297>/Dsw_STMTrigger'
     *  Logic: '<S2305>/AND'
     *  Logic: '<S2305>/Logical11'
     *  Logic: '<S2305>/Logical12'
     *  Logic: '<S2305>/Logical6'
     *  Logic: '<S2305>/Logical7'
     *  Logic: '<S2305>/Logical9'
     *  RelationalOperator: '<S2305>/Greater  Than2'
     *  RelationalOperator: '<S2305>/Greater  Than4'
     *  RelationalOperator: '<S2305>/Relational Operator1'
     *  Switch: '<S2315>/Switch2'
     */
    if ((rtb_OR1_p && ((VeESSR_t_STMTmr_DS > KeESSR_t_HoldStartStateTime) ||
                       ((VeESSR_t_STMTmr_DS > KeESSR_t_HoldStartStateTimeMin) &&
                        (rtb_Sum5_fb < KeESSR_M_StrtEngTqExitDelta)))) &&
            ((!HeESSR_b_DtrmnEngRunExtra) || ((VeESSR_b_SpdChk_EMStrtEng) &&
            (VeESSR_b_ETRQEMStrtEng))))
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngRun;
    }
    else
    {
        if (rtb_GreaterThan1_eg)
        {
            /* Switch: '<S2297>/Switch' incorporates:
             *  Switch: '<S2297>/Switch2'
             *  Switch: '<S2315>/Switch2'
             */
            if (rtu_EMErlyExitLmp)
            {
                /* Switch: '<S2315>/Switch1' incorporates:
                 *  Constant: '<S2301>/Constant'
                 *  DataStoreWrite: '<S2297>/Dsw_STMTrigger'
                 *  Switch: '<S2297>/Switch'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;
            }
            else if (rtb_Logical5_nn)
            {
                /* Switch: '<S2297>/Switch2' incorporates:
                 *  Constant: '<S2300>/Constant'
                 *  DataStoreWrite: '<S2297>/Dsw_STMTrigger'
                 *  Switch: '<S2297>/Switch'
                 *  Switch: '<S2315>/Switch1'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_StopReq;
            }
            else
            {
                /* Switch: '<S2315>/Switch1' incorporates:
                 *  Constant: '<S2299>/Constant'
                 *  DataStoreWrite: '<S2297>/Dsw_STMTrigger'
                 *  Switch: '<S2297>/Switch'
                 *  Switch: '<S2297>/Switch2'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;
            }

            /* End of Switch: '<S2297>/Switch' */
        }
    }

    /* End of Switch: '<S2315>/Switch1' */

    /* Logic: '<S2305>/Logical Operator3' incorporates:
     *  Logic: '<S2305>/Logical Operator1'
     *  Logic: '<S2305>/Logical Operator7'
     *  Logic: '<S2305>/Logical Operator8'
     */
    rtb_LogicalOperator3_c = (((!rtb_LogicalOperator3_c) ||
        (!VeESSR_b_SpdChk_EMStrtEng)) && rtb_GreaterThan1_eg);

    /* Logic: '<S2305>/Logical Operator4' incorporates:
     *  Logic: '<S2305>/Logical Operator2'
     */
    rtb_Logical5_nn = ((!rtu_VeENGR_b_EngCombustionCmnd) && rtb_GreaterThan1_eg);

    /* Logic: '<S2305>/Logical Operator5' incorporates:
     *  Logic: '<S2305>/Logical14'
     */
    rtb_GreaterThan1_eg = (rtb_GreaterThan1_eg && (!VeESSR_b_ETRQEMStrtEng));

    /* Logic: '<S2305>/Logical5' */
    rtb_OR1_p = ((rtb_LogicalOperator3_c || rtb_Logical5_nn) ||
                 rtb_GreaterThan1_eg);

    /* If: '<S2297>/If' incorporates:
     *  DataStoreRead: '<S2297>/Data Store Read4'
     *  Logic: '<S2297>/Logical15'
     *  Logic: '<S2297>/Logical7'
     */
    if ((!VeESSR_b_AStrtReattmptAllowed_DS) && rtb_OR1_p)
    {
        /* Outputs for IfAction SubSystem: '<S2297>/If_StartEng_P1C64' incorporates:
         *  ActionPort: '<S2317>/Action Port'
         */
        /* DataStoreWrite: '<S2297>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_StartEng_P1C64((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S2297>/If_StartEng_P1C64' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2297>/If_StartEng_NoFault' incorporates:
         *  ActionPort: '<S2316>/Action Port'
         */
        /* DataStoreWrite: '<S2297>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_KeyCrank_NoFault((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S2297>/If_StartEng_NoFault' */
    }

    /* End of If: '<S2297>/If' */

    /* Switch: '<S2305>/Switch4' incorporates:
     *  S-Function (sfix_bitop): '<S2359>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator3_c)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 256U;
    }

    /* End of Switch: '<S2305>/Switch4' */

    /* Switch: '<S2305>/Switch2' incorporates:
     *  S-Function (sfix_bitop): '<S2357>/FixPt Bitwise Operator1'
     */
    if (rtb_Logical5_nn)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 512U;
    }

    /* End of Switch: '<S2305>/Switch2' */

    /* Switch: '<S2305>/Switch3' incorporates:
     *  S-Function (sfix_bitop): '<S2360>/FixPt Bitwise Operator1'
     */
    if (rtb_GreaterThan1_eg)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 536870912U;
    }

    /* End of Switch: '<S2305>/Switch3' */

    /* Switch: '<S2305>/Switch1' incorporates:
     *  Constant: '<S2305>/Constant Value'
     *  DataStoreRead: '<S2305>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S2305>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S2305>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S2305>/Logical21'
     *  RelationalOperator: '<S2305>/Comparison'
     *  S-Function (sfix_bitop): '<S2305>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S2358>/FixPt Bitwise Operator1'
     */
    if (rtb_OR1_p && ((VeESSR_g_StrtStpFailPhaseSelect_DS & 33554432U) > 0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 33554432U;
    }

    /* End of Switch: '<S2305>/Switch1' */

    /* DataStoreWrite: '<S2297>/Dsw_SpdCtlGainMod1' incorporates:
     *  Constant: '<S2297>/Constant Value8'
     */
    VeESSR_scl_SpdCtlGainMod_DS = 1.0F;

    /* Sum: '<S2398>/Sum17' incorporates:
     *  DataStoreWrite: '<S2297>/Dsw_InputAcceltnProf'
     */
    VeESSR_dn_InputJerkProfStartEngEM = VeESSR_dn_InputAcceltnProf_DS -
        rtb_Switch5_a2;

    /* Update for UnitDelay: '<S2417>/Unit Delay' incorporates:
     *  Switch: '<S2417>/Switch3'
     */
    localDW->UnitDelay_DSTATE = rtb_Sum6_k;

    /* Update for Delay: '<S2398>/IntegerDelay' */
    localDW->icLoad = 0U;
    for (i = 0; i < 15; i++)
    {
        localDW->IntegerDelay_DSTATE[i] = localDW->IntegerDelay_DSTATE[i + 1];
    }

    localDW->IntegerDelay_DSTATE[15] = rtb_Multiplication1_bh;

    /* End of Update for Delay: '<S2398>/IntegerDelay' */
}

#endif

/* Output and update for function-call system: '<S553>/StartEngP1fLmt_Dur' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_StartEngP1fLmt_Dur(VAR(float32,
    AUTOMATIC) rtu_VeESSR_M_EngStrtTorqSnsd, VAR(boolean, AUTOMATIC)
    rtu_VeENGR_b_EngCombustionCmnd, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngTrqActual, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_OptEngTrqReqPred, VAR(float32, AUTOMATIC)
    rtu_VeESSR_M_OptEngTrqReqImmed, VAR(float32, AUTOMATIC)
    rtu_VeETQR_r_MaxSparkAuthority, VAR(float32, AUTOMATIC)
    rtu_VeETQR_M_EngineLosses, VAR(TeENGR_e_ETRQ_Mode, AUTOMATIC)
    rtu_VeENGR_e_ETRQ_Mode, VAR(float32, AUTOMATIC) rtu_VeESSR_n_TransInSpdFlt,
    VAR(boolean, AUTOMATIC) rtu_VeRTMR_b_InPlantMode, VAR(boolean, AUTOMATIC)
    rtu_ErlyExitLmp, VAR(boolean, AUTOMATIC) rtu_LwrThresLmp, VAR(float32,
    AUTOMATIC) rtu_HTDR_TiMin, P2VAR(DW_StartEngP1fLmt_Dur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn)
{
    float32 rtb_Multiplication1_mo;
    float32 rtb_Sum1_fk;
    float32 rtb_Switch1_dg;
    float32 rtb_Switch3_by;
    boolean rtb_Equal2_gt;
    boolean rtb_GreaterThan1_d0;
    boolean rtb_Logical5_n4;
    boolean rtb_LogicalOperator3_n1;
    boolean rtb_LogicalOperator4_g;
    boolean rtb_OR1_d1;
    boolean rtb_OR1_ns;
    boolean tmp;

    /* RelationalOperator: '<S573>/Greater  Than1' incorporates:
     *  Constant: '<S604>/Calib'
     *  DataStoreRead: '<S573>/Dsr_STMTmr1'
     */
    rtb_GreaterThan1_d0 = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmP1fLmtStartEng);

    /* Logic: '<S573>/Logical5' incorporates:
     *  Constant: '<S593>/Calib'
     *  Constant: '<S594>/Calib'
     *  DataStoreRead: '<S573>/Data Store Read1'
     *  Logic: '<S573>/Logical2'
     *  Logic: '<S573>/Logical3'
     *  Logic: '<S573>/Logical8'
     */
    rtb_Logical5_n4 = (((!KeESSR_b_DsblEVStrtFailed_InPlant) ||
                        (!rtu_VeRTMR_b_InPlantMode)) &&
                       ((((KeESSR_b_AllowEV_StrtFailed) ||
                          (VeESSR_b_AStrtReattmptAllowed_DS)) || rtu_ErlyExitLmp)
                        || rtu_LwrThresLmp));

    /* Logic: '<S573>/Logical1' incorporates:
     *  DataStoreWrite: '<S573>/Dsw_AStrtFailed'
     */
    VeESSR_b_AStrtFailed_DS = (rtb_GreaterThan1_d0 && rtb_Logical5_n4);

    /* Switch: '<S585>/Switch1' incorporates:
     *  Constant: '<S573>/Constant Value3'
     *  DataStoreRead: '<S573>/Dsr_STMTmr3'
     *  DataStoreWrite: '<S573>/Dsw_AStrtFailed'
     *  DataStoreWrite: '<S573>/Dsw_AStrtFailed1'
     *  Sum: '<S573>/Sum3'
     */
    if (VeESSR_b_AStrtFailed_DS)
    {
        VeESSR_Cnt_AStrtFailAttmptCntr_DS = (uint8)(((uint32)
            VeESSR_Cnt_AStrtFailAttmptCntr_DS) + 1U);
    }

    /* End of Switch: '<S585>/Switch1' */

    /* RelationalOperator: '<S573>/Greater  Than2' incorporates:
     *  Constant: '<S590>/Calib'
     *  DataStoreWrite: '<S573>/Dsw_AStrtFailed1'
     *  DataStoreWrite: '<S573>/Dsw_AStrtFailed2'
     */
    VeESSR_b_AStrtReattmptAllowed_DS = (VeESSR_Cnt_AStrtFailAttmptCntr_DS <=
        KeESSR_Cnt_AStrtFailMaxAttmpts);

    /* Switch: '<S648>/Switch1' incorporates:
     *  Constant: '<S592>/Calib'
     *  MinMax: '<S573>/Maximum2'
     */
    rtb_Switch1_dg = fmaxf(rtu_VeESSR_M_OptEngTrqReqImmed,
                           KeESSR_M_MinStartDetectTorqP1fLmt);

    /* If: '<S579>/If1' incorporates:
     *  Constant: '<S582>/Constant'
     *  DataStoreWrite: '<S573>/Dsw_EngStrtType2'
     *  Switch: '<S573>/Switch1'
     */
    if (rtu_VeENGR_b_EngCombustionCmnd)
    {
        VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Startng;

        /* Outputs for IfAction SubSystem: '<S579>/ESSC_CombstDelay' incorporates:
         *  ActionPort: '<S633>/Action Port'
         */
        ESSR_ac_ESSC_CombstDelay(&rtb_LogicalOperator4_g);

        /* End of Outputs for SubSystem: '<S579>/ESSC_CombstDelay' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S579>/ESSC_CombstNoDelay' incorporates:
         *  ActionPort: '<S634>/Action Port'
         */
        ESSR_ac_ESSC_CmbstnNoDelay(&rtb_LogicalOperator4_g);

        /* End of Outputs for SubSystem: '<S579>/ESSC_CombstNoDelay' */
    }

    /* End of If: '<S579>/If1' */

    /* RelationalOperator: '<S573>/Equal2' incorporates:
     *  Constant: '<S584>/Calib'
     *  DataStoreRead: '<S573>/Dsr_STMTmr'
     */
    rtb_Equal2_gt = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

    /* Outputs for Atomic SubSystem: '<S578>/Signal Latch On With Reset' */
    /* Outputs for Atomic SubSystem: '<S579>/Signal Latch On With Reset' */
    /* Logic: '<S637>/NOT' incorporates:
     *  Logic: '<S625>/NOT'
     */
    rtb_OR1_d1 = !rtb_Equal2_gt;

    /* End of Outputs for SubSystem: '<S578>/Signal Latch On With Reset' */

    /* Logic: '<S637>/OR1' incorporates:
     *  Constant: '<S635>/Calib'
     *  DataStoreRead: '<S579>/Dsr_STMTmr'
     *  Logic: '<S579>/Logical3'
     *  Logic: '<S637>/NOT'
     *  Logic: '<S637>/OR'
     *  RelationalOperator: '<S579>/Equal1'
     *  UnitDelay: '<S637>/Unit Delay'
     */
    rtb_OR1_ns = ((rtb_LogicalOperator4_g || (VeESSR_t_STMTmr_DS >
                    KeESSR_t_FuelTmDelayHold)) || (rtb_OR1_d1 &&
                   (localDW->UnitDelay_DSTATE_e)));

    /* Update for UnitDelay: '<S637>/Unit Delay' */
    localDW->UnitDelay_DSTATE_e = rtb_OR1_ns;

    /* End of Outputs for SubSystem: '<S579>/Signal Latch On With Reset' */

    /* Sum: '<S573>/Sum1' incorporates:
     *  DataStoreRead: '<S573>/Dsr_StrtTypInitImmedTorq1'
     */
    rtb_Sum1_fk = rtb_Switch1_dg - VeESSR_M_EngTrqReqImmed_DS;

    /* Outputs for Atomic SubSystem: '<S573>/Lowpass Second Order Enabled1' */
    /* Switch: '<S608>/Switch3' incorporates:
     *  Logic: '<S579>/Logical4'
     *  Switch: '<S608>/Switch1'
     */
    if (!rtb_OR1_ns)
    {
        /* Switch: '<S608>/Switch3' */
        rtb_Switch3_by = rtb_Sum1_fk;

        /* Switch: '<S608>/Switch1' */
        rtb_Multiplication1_mo = rtb_Sum1_fk;
    }
    else
    {
        /* Switch: '<S608>/Switch3' incorporates:
         *  UnitDelay: '<S608>/x2'
         */
        rtb_Switch3_by = localDW->x2_DSTATE_l;

        /* Product: '<S608>/Multiplication1' incorporates:
         *  Constant: '<S584>/Calib'
         *  Constant: '<S601>/Calib'
         *  MinMax: '<S608>/Maximum'
         */
        rtb_Multiplication1_mo = (1.0F / fmaxf
            (KeESSR_k_P1fLmtEngTorqReqImmedFltT, HeESSR_t_MedTEB_dT)) *
            HeESSR_t_MedTEB_dT;

        /* Switch: '<S608>/Switch1' incorporates:
         *  Constant: '<S573>/Constant Value2'
         *  Constant: '<S600>/Calib'
         *  Gain: '<S608>/Gain'
         *  Gain: '<S608>/Gain1'
         *  Math: '<S608>/Square'
         *  Product: '<S608>/Multiplication2'
         *  Product: '<S608>/Multiplication3'
         *  Sum: '<S608>/Subtraction'
         *  Sum: '<S608>/Subtraction1'
         *  Sum: '<S608>/Summation'
         *  UnitDelay: '<S608>/temp'
         *  UnitDelay: '<S608>/x2'
         */
        rtb_Multiplication1_mo = (((((localDW->temp_DSTATE_e -
            localDW->x2_DSTATE_l) * (2.0F * KeESSR_k_P1fLmtEngTorqReqImmedFltD))
            * rtb_Multiplication1_mo) + ((rtb_Multiplication1_mo *
            rtb_Multiplication1_mo) * (0.0F - localDW->temp_DSTATE_e))) -
            localDW->temp_DSTATE_e) + (2.0F * localDW->x2_DSTATE_l);
    }

    /* End of Switch: '<S608>/Switch3' */

    /* Update for UnitDelay: '<S608>/x2' */
    localDW->x2_DSTATE_l = rtb_Multiplication1_mo;

    /* Update for UnitDelay: '<S608>/temp' */
    localDW->temp_DSTATE_e = rtb_Switch3_by;

    /* End of Outputs for SubSystem: '<S573>/Lowpass Second Order Enabled1' */

    /* Sum: '<S573>/Sum2' incorporates:
     *  DataStoreWrite: '<S573>/Dsw_EngTrqReqImmed'
     */
    VeESSR_M_EngTrqReqImmed_DS = rtb_Switch1_dg - rtb_Multiplication1_mo;

    /* Sum: '<S573>/Summation4' incorporates:
     *  Product: '<S573>/Product'
     *  Sum: '<S573>/Summation3'
     */
    rtb_Switch1_dg = ((rtb_Switch1_dg + rtu_VeETQR_M_EngineLosses) *
                      rtu_VeETQR_r_MaxSparkAuthority) -
        rtu_VeETQR_M_EngineLosses;

    /* Outputs for Atomic SubSystem: '<S573>/Lowpass Second Order Enabled2' */
    /* Switch: '<S609>/Switch3' incorporates:
     *  Switch: '<S609>/Switch1'
     */
    if (rtb_Equal2_gt)
    {
        /* Switch: '<S609>/Switch3' incorporates:
         *  DataStoreRead: '<S573>/Dsr_StrtTypInitImmedTorq6'
         */
        rtb_Switch3_by = VeESSR_M_EngTrqReqPrdtd_DS;

        /* Switch: '<S609>/Switch1' incorporates:
         *  DataStoreRead: '<S573>/Dsr_StrtTypInitImmedTorq6'
         */
        rtb_Multiplication1_mo = VeESSR_M_EngTrqReqPrdtd_DS;
    }
    else
    {
        /* Switch: '<S609>/Switch3' incorporates:
         *  UnitDelay: '<S609>/x2'
         */
        rtb_Switch3_by = localDW->x2_DSTATE;

        /* Product: '<S609>/Multiplication1' incorporates:
         *  Constant: '<S584>/Calib'
         *  Constant: '<S602>/Calib'
         *  MinMax: '<S609>/Maximum'
         */
        rtb_Multiplication1_mo = (1.0F / fmaxf(KeESSR_k_P1fLmtEngTorqReqPrdFltT,
            HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT;

        /* Switch: '<S609>/Switch1' incorporates:
         *  Constant: '<S592>/Calib'
         *  Constant: '<S600>/Calib'
         *  Gain: '<S609>/Gain'
         *  Gain: '<S609>/Gain1'
         *  Math: '<S609>/Square'
         *  MinMax: '<S573>/Maximum1'
         *  Product: '<S609>/Multiplication2'
         *  Product: '<S609>/Multiplication3'
         *  Sum: '<S609>/Subtraction'
         *  Sum: '<S609>/Subtraction1'
         *  Sum: '<S609>/Summation'
         *  UnitDelay: '<S609>/temp'
         *  UnitDelay: '<S609>/x2'
         */
        rtb_Multiplication1_mo = (((((localDW->temp_DSTATE - localDW->x2_DSTATE)
            * (2.0F * KeESSR_k_P1fLmtEngTorqReqImmedFltD)) *
            rtb_Multiplication1_mo) + ((rtb_Multiplication1_mo *
            rtb_Multiplication1_mo) * (fmaxf(rtu_VeESSR_M_OptEngTrqReqPred,
            KeESSR_M_MinStartDetectTorqP1fLmt) - localDW->temp_DSTATE))) -
            localDW->temp_DSTATE) + (2.0F * localDW->x2_DSTATE);
    }

    /* End of Switch: '<S609>/Switch3' */

    /* Outputs for Atomic SubSystem: '<S609>/Limiter' */
    /* Switch: '<S651>/Switch1' incorporates:
     *  RelationalOperator: '<S651>/Relational Operator'
     */
    if (rtb_Switch1_dg >= rtb_Multiplication1_mo)
    {
        /* Switch: '<S648>/Switch1' */
        rtb_Switch1_dg = rtb_Multiplication1_mo;
    }

    /* End of Switch: '<S651>/Switch1' */

    /* Switch: '<S651>/Switch' incorporates:
     *  DataStoreWrite: '<S573>/Dsw_EngTrqReqImmed'
     *  DataStoreWrite: '<S573>/Dsw_EngTrqReqPrdtd'
     *  RelationalOperator: '<S651>/Relational Operator1'
     */
    if (rtb_Switch1_dg > VeESSR_M_EngTrqReqImmed_DS)
    {
        VeESSR_M_EngTrqReqPrdtd_DS = rtb_Switch1_dg;
    }
    else
    {
        VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_EngTrqReqImmed_DS;
    }

    /* End of Switch: '<S651>/Switch' */
    /* End of Outputs for SubSystem: '<S609>/Limiter' */

    /* Update for UnitDelay: '<S609>/x2' incorporates:
     *  DataStoreWrite: '<S573>/Dsw_EngTrqReqPrdtd'
     */
    localDW->x2_DSTATE = VeESSR_M_EngTrqReqPrdtd_DS;

    /* Update for UnitDelay: '<S609>/temp' */
    localDW->temp_DSTATE = rtb_Switch3_by;

    /* End of Outputs for SubSystem: '<S573>/Lowpass Second Order Enabled2' */

    /* Switch: '<S586>/Switch1' incorporates:
     *  Constant: '<S595>/Calib'
     *  Constant: '<S596>/Calib'
     *  Constant: '<S605>/Calib'
     *  DataStoreRead: '<S573>/Dsr_STMTmr'
     *  DataStoreWrite: '<S573>/Dsw_InhibitShiftToMode'
     *  RelationalOperator: '<S573>/Greater  Than'
     */
    if (VeESSR_t_STMTmr_DS < KeESSR_t_ShftInhbtStrtEngTm)
    {
        VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtStrtEngStrt;
    }
    else
    {
        VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtStrtEngEnd;
    }

    /* End of Switch: '<S586>/Switch1' */

    /* Switch: '<S573>/Switch4' incorporates:
     *  DataStoreRead: '<S573>/Dsr_InputSpeedProfile8'
     *  DataStoreWrite: '<S573>/Dsw_InputSpeedProfile5'
     *  Sum: '<S573>/Sum6'
     */
    if (rtb_Equal2_gt)
    {
        VeESSR_n_InputSpeedProfile_DS = rtu_VeESSR_n_TransInSpdFlt;
    }
    else
    {
        /* Sum: '<S573>/Sum5' incorporates:
         *  Constant: '<S603>/Calib'
         *  DataStoreRead: '<S573>/Dsr_InputSpeedProfile8'
         */
        rtb_Switch1_dg = KeESSR_n_StrtEngP1fLmtTrgt -
            VeESSR_n_InputSpeedProfile_DS;

        /* Outputs for Atomic SubSystem: '<S573>/Limiter1' */
        /* Switch: '<S606>/Switch1' incorporates:
         *  Constant: '<S598>/Calib'
         *  RelationalOperator: '<S606>/Relational Operator'
         */
        if (KeESSR_dn_P1fLmtTrgtLU < rtb_Switch1_dg)
        {
            /* Switch: '<S606>/Switch1' */
            rtb_Switch1_dg = KeESSR_dn_P1fLmtTrgtLU;
        }

        /* End of Switch: '<S606>/Switch1' */

        /* Switch: '<S606>/Switch' incorporates:
         *  Constant: '<S597>/Calib'
         *  RelationalOperator: '<S606>/Relational Operator1'
         */
        if (rtb_Switch1_dg <= KeESSR_dn_P1fLmtTrgtLD)
        {
            rtb_Switch1_dg = KeESSR_dn_P1fLmtTrgtLD;
        }

        /* End of Switch: '<S606>/Switch' */
        /* End of Outputs for SubSystem: '<S573>/Limiter1' */
        VeESSR_n_InputSpeedProfile_DS = rtb_Switch1_dg +
            VeESSR_n_InputSpeedProfile_DS;
    }

    /* End of Switch: '<S573>/Switch4' */

    /* Sum: '<S610>/Summation5' incorporates:
     *  DataStoreRead: '<S610>/Dsr_InputSpeedProfile6'
     */
    VeESSR_n_P1fLmtSpdError = VeESSR_n_InputSpeedProfile_DS -
        rtu_VeESSR_n_TransInSpdFlt;

    /* Product: '<S610>/proportional_term' incorporates:
     *  Constant: '<S654>/Calib'
     */
    VeESSR_M_P1fLmtPSpdCtl = VeESSR_n_P1fLmtSpdError *
        KeESSR_K_P1fLmtSpdCtlPgain;

    /* Switch: '<S610>/Switch' */
    if (rtb_Equal2_gt)
    {
        /* Switch: '<S610>/Switch' incorporates:
         *  Constant: '<S610>/Constant Value1'
         */
        VeESSR_M_P1fLmtISpdCtl = 0.0F;
    }
    else
    {
        /* Switch: '<S610>/Switch' incorporates:
         *  Constant: '<S652>/Calib'
         *  Constant: '<S653>/Calib'
         *  Constant: '<S655>/Calib'
         *  Product: '<S610>/Multiplication1'
         *  Product: '<S610>/Product'
         *  Sum: '<S610>/Sum//Sub'
         *  Sum: '<S610>/Sum//Sub2'
         *  Sum: '<S610>/Sum//Sub3'
         *  UnitDelay: '<S610>/Unit Delay'
         *  UnitDelay: '<S610>/Unit Delay1'
         *  UnitDelay: '<S610>/Unit Delay2'
         */
        VeESSR_M_P1fLmtISpdCtl = (((VeESSR_n_P1fLmtSpdError -
            ((VeESSR_M_P1fLmtSpdCtlPre - VeESSR_M_P1fLmtSpdCtlPost) *
             KeESSR_K_P1fLmtWindupIgain)) * KeESSR_K_P1fLmtSpdCtlIgain) *
            HeESSR_t_MedTEB_dT) + VeESSR_M_P1fLmtISpdCtl;
    }

    /* End of Switch: '<S610>/Switch' */

    /* Sum: '<S610>/Sum//Sub1' */
    VeESSR_M_P1fLmtSpdCtlPre = VeESSR_M_P1fLmtPSpdCtl + VeESSR_M_P1fLmtISpdCtl;

    /* MinMax: '<S610>/MinMax' */
    VeESSR_M_P1fLmtSpdCtlPost = fmaxf(rtu_HTDR_TiMin, VeESSR_M_P1fLmtSpdCtlPre);

    /* Sum: '<S573>/Add' incorporates:
     *  Constant: '<S591>/Calib'
     *  DataStoreRead: '<S573>/Dsr_InputTorqEst'
     *  Product: '<S575>/Multiplication'
     *  Sum: '<S575>/Subtraction'
     *  Sum: '<S575>/Subtraction1'
     */
    rtb_Switch1_dg = (((rtu_VeETQR_M_EngTrqActual - VeESSR_M_EngTorqEst_DS) *
                       KeESSR_K_TiEstBlndP1fLmtd) + VeESSR_M_EngTorqEst_DS) +
        VeESSR_M_P1fLmtSpdCtlPost;

    /* Outputs for Atomic SubSystem: '<S573>/Limiter2' */
    /* Switch: '<S607>/Switch1' incorporates:
     *  RelationalOperator: '<S607>/Relational Operator'
     */
    if (rtu_VeETQR_M_EngTrqActual < rtb_Switch1_dg)
    {
        /* Switch: '<S648>/Switch1' */
        rtb_Switch1_dg = rtu_VeETQR_M_EngTrqActual;
    }

    /* End of Switch: '<S607>/Switch1' */

    /* Switch: '<S607>/Switch' incorporates:
     *  DataStoreWrite: '<S573>/Dsw_InputTorqEst'
     *  RelationalOperator: '<S607>/Relational Operator1'
     */
    if (rtb_Switch1_dg > rtu_HTDR_TiMin)
    {
        VeESSR_M_EngTorqEst_DS = rtb_Switch1_dg;
    }
    else
    {
        VeESSR_M_EngTorqEst_DS = rtu_HTDR_TiMin;
    }

    /* End of Switch: '<S607>/Switch' */
    /* End of Outputs for SubSystem: '<S573>/Limiter2' */

    /* DataStoreWrite: '<S573>/Dsw_STMTmr' incorporates:
     *  Constant: '<S584>/Calib'
     *  DataStoreRead: '<S573>/Dsr_STMTmr'
     *  Sum: '<S573>/Summation1'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Logic: '<S578>/Logical Operator4' incorporates:
     *  Abs: '<S578>/Abs'
     *  Constant: '<S619>/Calib'
     *  Constant: '<S620>/Calib'
     *  Logic: '<S578>/Logical3'
     *  RelationalOperator: '<S578>/Greater  Than1'
     *  RelationalOperator: '<S578>/Relational Operator'
     *  Sum: '<S578>/Add'
     */
    rtb_LogicalOperator4_g = ((fabsf(rtu_VeESSR_M_EngStrtTorqSnsd -
        rtu_VeETQR_M_EngTrqActual) < KeESSR_M_MaxEngTorqError) ||
        (rtu_VeESSR_M_EngStrtTorqSnsd > KeESSR_M_MinEngStrtTorqSnsd));

    /* Outputs for Atomic SubSystem: '<S578>/Signal Latch On With Reset' */
    /* Logic: '<S625>/OR1' incorporates:
     *  Logic: '<S578>/Logical4'
     *  Logic: '<S625>/OR'
     *  UnitDelay: '<S625>/Unit Delay'
     */
    rtb_OR1_d1 = ((rtb_LogicalOperator4_g && rtu_VeENGR_b_EngCombustionCmnd) ||
                  (rtb_OR1_d1 && (localDW->UnitDelay_DSTATE_i)));

    /* Update for UnitDelay: '<S625>/Unit Delay' */
    localDW->UnitDelay_DSTATE_i = rtb_OR1_d1;

    /* End of Outputs for SubSystem: '<S578>/Signal Latch On With Reset' */

    /* Logic: '<S578>/Logical Operator3' incorporates:
     *  Constant: '<S618>/Calib'
     *  Logic: '<S578>/Logical12'
     */
    rtb_LogicalOperator3_n1 = !HeESSR_b_DtrmnEngRunExtraPFS;

    /* Logic: '<S578>/Logical16' incorporates:
     *  Logic: '<S578>/Logical Operator2'
     */
    tmp = !rtu_VeENGR_b_EngCombustionCmnd;

    /* Outputs for Atomic SubSystem: '<S615>/Accumulator Reset Limited' */
    /* Switch: '<S626>/Switch1' incorporates:
     *  Constant: '<S627>/Calib'
     *  Logic: '<S578>/Logical1'
     *  Logic: '<S578>/Logical16'
     *  Logic: '<S578>/Logical2'
     *  Switch: '<S615>/Switch'
     */
    if (rtb_Equal2_gt || (tmp && (!rtb_LogicalOperator3_n1)))
    {
        /* Switch: '<S626>/Switch1' incorporates:
         *  Constant: '<S615>/Constant Value1'
         */
        rtb_Switch1_dg = 0.0F;
    }
    else
    {
        if (HeESSR_b_48VEngStrtExitSpd)
        {
            /* Switch: '<S615>/Switch' incorporates:
             *  Constant: '<S603>/Calib'
             */
            rtb_Switch1_dg = KeESSR_n_StrtEngP1fLmtTrgt;
        }
        else
        {
            /* Switch: '<S615>/Switch' incorporates:
             *  Constant: '<S630>/Calib'
             */
            rtb_Switch1_dg = KeESSR_n_EngStrtExitSpd;
        }

        /* Sum: '<S626>/Summation' incorporates:
         *  Constant: '<S628>/Calib'
         *  Constant: '<S631>/Calib'
         *  Product: '<S615>/Product'
         *  Sum: '<S615>/Sum1'
         *  UnitDelay: '<S626>/Unit Delay'
         */
        rtb_Switch1_dg = (((rtu_VeESSR_n_TransInSpdFlt -
                            KeESSR_n_P1fLmtEngStrtExitSpdDelta) - rtb_Switch1_dg)
                          * HeESSR_t_MedTEB_dT) + localDW->UnitDelay_DSTATE_c;

        /* Outputs for Atomic SubSystem: '<S626>/Limiter' */
        /* Switch: '<S632>/Switch1' incorporates:
         *  Constant: '<S629>/Calib'
         *  RelationalOperator: '<S632>/Relational Operator'
         */
        if (KeESSR_n_EngStrtExitIntgrlVal < rtb_Switch1_dg)
        {
            /* Switch: '<S632>/Switch1' */
            rtb_Switch1_dg = KeESSR_n_EngStrtExitIntgrlVal;
        }

        /* End of Switch: '<S632>/Switch1' */

        /* Switch: '<S632>/Switch' incorporates:
         *  Constant: '<S615>/Constant Value1'
         *  RelationalOperator: '<S632>/Relational Operator1'
         */
        if (rtb_Switch1_dg <= 0.0F)
        {
            /* Switch: '<S626>/Switch1' */
            rtb_Switch1_dg = 0.0F;
        }

        /* End of Switch: '<S632>/Switch' */
        /* End of Outputs for SubSystem: '<S626>/Limiter' */
    }

    /* End of Switch: '<S626>/Switch1' */

    /* Update for UnitDelay: '<S626>/Unit Delay' */
    localDW->UnitDelay_DSTATE_c = rtb_Switch1_dg;

    /* End of Outputs for SubSystem: '<S615>/Accumulator Reset Limited' */

    /* RelationalOperator: '<S615>/Comparison4' incorporates:
     *  Constant: '<S629>/Calib'
     */
    VeESSR_b_SpdChk_PiFLmtStrtEng = (rtb_Switch1_dg ==
        KeESSR_n_EngStrtExitIntgrlVal);

    /* Logic: '<S578>/Logical13' incorporates:
     *  Constant: '<S616>/Constant'
     *  Constant: '<S617>/Constant'
     *  RelationalOperator: '<S578>/Comparison5'
     *  RelationalOperator: '<S578>/Comparison6'
     */
    VeESSR_b_ETRQStrtEngP1fLmt = ((((uint32)rtu_VeENGR_e_ETRQ_Mode) ==
        CeENGR_e_DriverControl) || (((uint32)rtu_VeENGR_e_ETRQ_Mode) ==
        CeENGR_e_Idle));

    /* Switch: '<S587>/Switch1' incorporates:
     *  Constant: '<S577>/Constant'
     *  Constant: '<S621>/Calib'
     *  Constant: '<S622>/Calib'
     *  Constant: '<S623>/Calib'
     *  DataStoreRead: '<S578>/Dsr_STMTmr2'
     *  DataStoreWrite: '<S573>/Dsw_STMTrigger'
     *  Logic: '<S578>/AND'
     *  Logic: '<S578>/Logical11'
     *  Logic: '<S578>/Logical6'
     *  Logic: '<S578>/Logical7'
     *  RelationalOperator: '<S578>/Greater  Than2'
     *  RelationalOperator: '<S578>/Greater  Than4'
     *  RelationalOperator: '<S578>/Relational Operator1'
     *  Switch: '<S587>/Switch2'
     */
    if (((rtb_OR1_d1 && ((VeESSR_t_STMTmr_DS > KeESSR_t_HoldStartStateTime) ||
                         ((VeESSR_t_STMTmr_DS > KeESSR_t_HoldStartStateTimeMin) &&
                          (rtb_Sum1_fk < KeESSR_M_StrtEngTqExitDelta)))) &&
            (VeESSR_b_SpdChk_PiFLmtStrtEng)) && (rtb_LogicalOperator3_n1 ||
            (VeESSR_b_ETRQStrtEngP1fLmt)))
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngRun;
    }
    else
    {
        if (rtb_GreaterThan1_d0)
        {
            /* Switch: '<S573>/Switch' incorporates:
             *  Switch: '<S587>/Switch2'
             */
            if (rtb_Logical5_n4)
            {
                /* Switch: '<S587>/Switch1' incorporates:
                 *  Constant: '<S583>/Constant'
                 *  DataStoreWrite: '<S573>/Dsw_STMTrigger'
                 *  Switch: '<S587>/Switch2'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;
            }
            else
            {
                /* Switch: '<S587>/Switch1' incorporates:
                 *  Constant: '<S576>/Constant'
                 *  DataStoreWrite: '<S573>/Dsw_STMTrigger'
                 *  Switch: '<S587>/Switch2'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;
            }

            /* End of Switch: '<S573>/Switch' */
        }
    }

    /* End of Switch: '<S587>/Switch1' */

    /* Abs: '<S581>/Abs' incorporates:
     *  Constant: '<S584>/Calib'
     *  Constant: '<S599>/Calib'
     *  Product: '<S581>/Multiplication'
     */
    rtb_Switch1_dg = fabsf(KeESSR_dscl_RampUpRate * HeESSR_t_MedTEB_dT);

    /* Gain: '<S581>/Gain' */
    rtb_Sum1_fk = -rtb_Switch1_dg;

    /* Outputs for Atomic SubSystem: '<S581>/Limiter1' */
    /* Switch: '<S647>/Switch1' incorporates:
     *  Constant: '<S573>/Constant Value8'
     *  DataStoreRead: '<S573>/Dsr_SpdCtlGainMod1'
     *  RelationalOperator: '<S647>/Relational Operator'
     *  Sum: '<S581>/Sum'
     */
    if (rtb_Switch1_dg >= (1.0F - VeESSR_scl_SpdCtlGainMod_DS))
    {
        /* Switch: '<S648>/Switch1' */
        rtb_Switch1_dg = 1.0F - VeESSR_scl_SpdCtlGainMod_DS;
    }

    /* End of Switch: '<S647>/Switch1' */

    /* Switch: '<S647>/Switch' incorporates:
     *  RelationalOperator: '<S647>/Relational Operator1'
     */
    if (rtb_Switch1_dg > rtb_Sum1_fk)
    {
        rtb_Sum1_fk = rtb_Switch1_dg;
    }

    /* End of Switch: '<S647>/Switch' */
    /* End of Outputs for SubSystem: '<S581>/Limiter1' */

    /* Sum: '<S581>/Sum1' incorporates:
     *  DataStoreRead: '<S573>/Dsr_SpdCtlGainMod1'
     */
    rtb_Sum1_fk += VeESSR_scl_SpdCtlGainMod_DS;

    /* Outputs for Atomic SubSystem: '<S581>/Limiter2' */
    /* Switch: '<S648>/Switch1' incorporates:
     *  Constant: '<S573>/Constant Value7'
     *  RelationalOperator: '<S648>/Relational Operator'
     */
    if (2.0F < rtb_Sum1_fk)
    {
        /* Switch: '<S648>/Switch1' */
        rtb_Switch1_dg = 2.0F;
    }
    else
    {
        /* Switch: '<S648>/Switch1' */
        rtb_Switch1_dg = rtb_Sum1_fk;
    }

    /* End of Switch: '<S648>/Switch1' */

    /* Switch: '<S648>/Switch' incorporates:
     *  Constant: '<S573>/Constant Value4'
     *  DataStoreWrite: '<S573>/Dsw_SpdCtlGainMod1'
     *  RelationalOperator: '<S648>/Relational Operator1'
     */
    if (rtb_Switch1_dg > 0.0F)
    {
        VeESSR_scl_SpdCtlGainMod_DS = rtb_Switch1_dg;
    }
    else
    {
        VeESSR_scl_SpdCtlGainMod_DS = 0.0F;
    }

    /* End of Switch: '<S648>/Switch' */
    /* End of Outputs for SubSystem: '<S581>/Limiter2' */

    /* Logic: '<S578>/Logical Operator3' incorporates:
     *  Logic: '<S578>/Logical Operator1'
     *  Logic: '<S578>/Logical14'
     *  Logic: '<S578>/Logical15'
     */
    rtb_LogicalOperator3_n1 = (((!rtb_LogicalOperator4_g) ||
        (!VeESSR_b_SpdChk_PiFLmtStrtEng)) && rtb_GreaterThan1_d0);

    /* Logic: '<S578>/Logical Operator4' */
    rtb_LogicalOperator4_g = (tmp && rtb_GreaterThan1_d0);

    /* Logic: '<S578>/Logical Operator5' incorporates:
     *  Logic: '<S578>/Logical17'
     */
    rtb_GreaterThan1_d0 = (rtb_GreaterThan1_d0 && (!VeESSR_b_ETRQStrtEngP1fLmt));

    /* Logic: '<S578>/Logical5' */
    rtb_Logical5_n4 = ((rtb_LogicalOperator3_n1 || rtb_LogicalOperator4_g) ||
                       rtb_GreaterThan1_d0);

    /* If: '<S573>/If' incorporates:
     *  DataStoreRead: '<S573>/Data Store Read'
     *  Logic: '<S573>/Logical4'
     *  Logic: '<S573>/Logical7'
     */
    if ((!VeESSR_b_AStrtReattmptAllowed_DS) && rtb_Logical5_n4)
    {
        /* Outputs for IfAction SubSystem: '<S573>/If_StartEng_P1C64' incorporates:
         *  ActionPort: '<S589>/Action Port'
         */
        /* DataStoreWrite: '<S573>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_StartEng_P1C64((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S573>/If_StartEng_P1C64' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S573>/If_StartEng_NoFault' incorporates:
         *  ActionPort: '<S588>/Action Port'
         */
        /* DataStoreWrite: '<S573>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_KeyCrank_NoFault((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S573>/If_StartEng_NoFault' */
    }

    /* End of If: '<S573>/If' */

    /* Switch: '<S578>/Switch4' incorporates:
     *  S-Function (sfix_bitop): '<S611>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator3_n1)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 256U;
    }

    /* End of Switch: '<S578>/Switch4' */

    /* Switch: '<S578>/Switch2' incorporates:
     *  S-Function (sfix_bitop): '<S612>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator4_g)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 512U;
    }

    /* End of Switch: '<S578>/Switch2' */

    /* Switch: '<S578>/Switch3' incorporates:
     *  S-Function (sfix_bitop): '<S614>/FixPt Bitwise Operator1'
     */
    if (rtb_GreaterThan1_d0)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 536870912U;
    }

    /* End of Switch: '<S578>/Switch3' */

    /* Logic: '<S578>/Logical' incorporates:
     *  DataStoreWrite: '<S578>/Dsw_SE_EngFuelOn'
     */
    VeESSR_b_SE_EngFuelOn_DS = (rtb_OR1_d1 && (VeESSR_b_SpdChk_PiFLmtStrtEng));

    /* Switch: '<S578>/Switch1' incorporates:
     *  Constant: '<S578>/Constant Value'
     *  DataStoreRead: '<S578>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S578>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S578>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S578>/Logical21'
     *  RelationalOperator: '<S578>/Comparison'
     *  S-Function (sfix_bitop): '<S578>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S613>/FixPt Bitwise Operator1'
     */
    if (rtb_Logical5_n4 && ((VeESSR_g_StrtStpFailPhaseSelect_DS & 67108864U) >
                            0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 67108864U;
    }

    /* End of Switch: '<S578>/Switch1' */

    /* If: '<S579>/If' */
    if (rtb_OR1_ns)
    {
        /* Outputs for IfAction SubSystem: '<S573>/ESSC_PBatBoostReset' incorporates:
         *  ActionPort: '<S580>/Action Port'
         */
        ESSR_ac_ESSC_PBatBoostReset();

        /* End of Outputs for SubSystem: '<S573>/ESSC_PBatBoostReset' */
    }

    /* End of If: '<S579>/If' */
}

#endif

/* Output and update for function-call system: '<S564>/SpinUp_EMLowPwr_Du' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_SpinUp_EMLowPwr_Du(VAR(float32,
    AUTOMATIC) rtu_VeESSR_n_TransInSpdFlt, VAR(float32, AUTOMATIC)
    rtu_VeHTDR_M_MtrB_TorqCmnd, VAR(float32, AUTOMATIC)
    rtu_VeOHSR_n_IdleSpdBlended, VAR(boolean, AUTOMATIC)
    rtu_VeENGR_b_EngCombustionCmnd, VAR(float32, AUTOMATIC) rtu_TiEstMin, VAR
    (float32, AUTOMATIC) rtu_EngTrqAct, P2VAR(DW_SpinUp_EMLowPwr_Du_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn)
{
    float32 rtb_Sum6_gp;
    float32 rtb_Summation_oh;
    boolean rtb_Equal2_p;
    boolean rtb_GreaterThan1_mg;
    boolean rtb_LogicalOperator1_hs;
    boolean rtb_Switch1_jf2;

    /* RelationalOperator: '<S1359>/Equal2' incorporates:
     *  Constant: '<S1368>/Calib'
     *  DataStoreRead: '<S1359>/Dsr_STMTmr'
     */
    rtb_Equal2_p = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

    /* Outputs for Atomic SubSystem: '<S1365>/Accumulator Reset Limited' */
    /* Switch: '<S1388>/Switch1' incorporates:
     *  Constant: '<S1367>/Constant'
     *  DataStoreRead: '<S1359>/Dsr_STMTmr3'
     *  Logic: '<S1359>/Logical Operator4'
     *  RelationalOperator: '<S1359>/Relational Operator'
     */
    if (rtb_Equal2_p || (((uint32)VeESSR_e_TCM_TransitionStatus_DS) !=
                         CeESSR_e_Startng))
    {
        /* Switch: '<S1388>/Switch1' incorporates:
         *  Constant: '<S1365>/Constant Value1'
         */
        rtb_Summation_oh = 0.0F;
    }
    else
    {
        /* Sum: '<S1388>/Summation' incorporates:
         *  Constant: '<S1379>/Calib'
         *  Constant: '<S1389>/Calib'
         *  Constant: '<S1391>/Calib'
         *  Product: '<S1365>/Product'
         *  Sum: '<S1365>/Sum1'
         *  UnitDelay: '<S1388>/Unit Delay'
         */
        rtb_Summation_oh = (((rtu_VeESSR_n_TransInSpdFlt -
                              KeESSR_n_Strt2RunExitSpdDelta) -
                             KeESSR_n_Start2RunTgt) * HeESSR_t_MedTEB_dT) +
            localDW->UnitDelay_DSTATE_c;

        /* Outputs for Atomic SubSystem: '<S1388>/Limiter' */
        /* Switch: '<S1392>/Switch1' incorporates:
         *  Constant: '<S1390>/Calib'
         *  RelationalOperator: '<S1392>/Relational Operator'
         */
        if (KeESSR_n_Strt2RunExitIntgrlVal < rtb_Summation_oh)
        {
            /* Switch: '<S1392>/Switch1' */
            rtb_Summation_oh = KeESSR_n_Strt2RunExitIntgrlVal;
        }

        /* End of Switch: '<S1392>/Switch1' */

        /* Switch: '<S1392>/Switch' incorporates:
         *  Constant: '<S1365>/Constant Value1'
         *  RelationalOperator: '<S1392>/Relational Operator1'
         */
        if (rtb_Summation_oh <= 0.0F)
        {
            /* Switch: '<S1388>/Switch1' */
            rtb_Summation_oh = 0.0F;
        }

        /* End of Switch: '<S1392>/Switch' */
        /* End of Outputs for SubSystem: '<S1388>/Limiter' */
    }

    /* End of Switch: '<S1388>/Switch1' */

    /* Update for UnitDelay: '<S1388>/Unit Delay' */
    localDW->UnitDelay_DSTATE_c = rtb_Summation_oh;

    /* End of Outputs for SubSystem: '<S1365>/Accumulator Reset Limited' */

    /* RelationalOperator: '<S1365>/Comparison4' incorporates:
     *  Constant: '<S1390>/Calib'
     */
    VeESSR_b_Strt2RunSpdChk_EMLPS = (rtb_Summation_oh ==
        KeESSR_n_Strt2RunExitIntgrlVal);

    /* RelationalOperator: '<S1359>/Greater  Than1' incorporates:
     *  Constant: '<S1381>/Calib'
     *  DataStoreRead: '<S1359>/Dsr_STMTmr1'
     */
    rtb_GreaterThan1_mg = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmSpinUp_EMLPS);

    /* Logic: '<S1359>/Logical Operator1' incorporates:
     *  Logic: '<S1359>/Logical Operator'
     */
    rtb_LogicalOperator1_hs = ((!VeESSR_b_Strt2RunSpdChk_EMLPS) &&
        rtb_GreaterThan1_mg);

    /* Switch: '<S1359>/Switch' incorporates:
     *  S-Function (sfix_bitop): '<S1361>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator1_hs)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 2147483648U;
    }

    /* End of Switch: '<S1359>/Switch' */

    /* Outputs for Atomic SubSystem: '<S1359>/Hysteresis' */
    /* Switch: '<S1369>/Switch1' incorporates:
     *  Constant: '<S1375>/Calib'
     *  RelationalOperator: '<S1369>/Greater  Than'
     */
    if (rtu_VeHTDR_M_MtrB_TorqCmnd > KeESSR_M_EMLPSMtrBThres)
    {
        /* Switch: '<S1369>/Switch1' incorporates:
         *  Constant: '<S1369>/Constant Value'
         */
        rtb_Switch1_jf2 = true;
    }
    else
    {
        /* Switch: '<S1369>/Switch1' incorporates:
         *  Constant: '<S1374>/Calib'
         *  RelationalOperator: '<S1369>/Greater  Than1'
         *  Sum: '<S1359>/Sum2'
         *  UnitDelay: '<S1369>/Unit Delay'
         */
        rtb_Switch1_jf2 = ((rtu_VeHTDR_M_MtrB_TorqCmnd >=
                            (KeESSR_M_EMLPSMtrBThres - KeESSR_M_EMLPSMtrBHys)) &&
                           (localDW->UnitDelay_DSTATE_ca));
    }

    /* End of Switch: '<S1369>/Switch1' */

    /* Update for UnitDelay: '<S1369>/Unit Delay' */
    localDW->UnitDelay_DSTATE_ca = rtb_Switch1_jf2;

    /* End of Outputs for SubSystem: '<S1359>/Hysteresis' */

    /* Sum: '<S1359>/Sum5' incorporates:
     *  Constant: '<S1379>/Calib'
     */
    rtb_Summation_oh = rtu_VeESSR_n_TransInSpdFlt - KeESSR_n_Start2RunTgt;

    /* Sum: '<S1359>/Sum6' incorporates:
     *  Constant: '<S1379>/Calib'
     */
    rtb_Sum6_gp = rtu_VeOHSR_n_IdleSpdBlended - KeESSR_n_Start2RunTgt;

    /* Outputs for Atomic SubSystem: '<S1359>/Protected Division' */
    /* Switch: '<S1385>/Switch1' incorporates:
     *  Constant: '<S1385>/Constant Value'
     *  Constant: '<S1385>/Constant Value1'
     *  Constant: '<S1385>/Constant Value2'
     *  Constant: '<S1385>/Constant Value3'
     *  Logic: '<S1385>/AND'
     *  RelationalOperator: '<S1385>/Greater Than or Equal '
     *  RelationalOperator: '<S1385>/Greater Than or Equal 1'
     *  RelationalOperator: '<S1385>/Not Equal'
     *  RelationalOperator: '<S1385>/Not Equal1'
     *  Switch: '<S1385>/Switch2'
     *  Switch: '<S1385>/Switch3'
     */
    if ((rtb_Summation_oh != 0.0F) && (rtb_Sum6_gp != 0.0F))
    {
        /* Switch: '<S1385>/Switch1' incorporates:
         *  Product: '<S1385>/Division'
         */
        rtb_Summation_oh /= rtb_Sum6_gp;
    }
    else if (rtb_Summation_oh > 0.0F)
    {
        /* Switch: '<S1385>/Switch2' incorporates:
         *  Constant: '<S1385>/MAXFLOAT'
         *  Switch: '<S1385>/Switch1'
         */
        rtb_Summation_oh = 3.402823466E+38F;
    }
    else if (rtb_Summation_oh < 0.0F)
    {
        /* Switch: '<S1385>/Switch3' incorporates:
         *  Constant: '<S1385>/MINFLOAT'
         *  Switch: '<S1385>/Switch1'
         *  Switch: '<S1385>/Switch2'
         */
        rtb_Summation_oh = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S1385>/Switch1' incorporates:
         *  Constant: '<S1385>/Constant Value4'
         *  Switch: '<S1385>/Switch2'
         *  Switch: '<S1385>/Switch3'
         */
        rtb_Summation_oh = 0.0F;
    }

    /* End of Switch: '<S1385>/Switch1' */
    /* End of Outputs for SubSystem: '<S1359>/Protected Division' */

    /* Outputs for Atomic SubSystem: '<S1359>/Limiter1' */
    /* Switch: '<S1383>/Switch1' incorporates:
     *  Constant: '<S1359>/Constant Value6'
     *  RelationalOperator: '<S1383>/Relational Operator'
     */
    if (1.0F < rtb_Summation_oh)
    {
        /* Switch: '<S1399>/Switch1' */
        rtb_Summation_oh = 1.0F;
    }

    /* End of Switch: '<S1383>/Switch1' */

    /* Switch: '<S1383>/Switch' incorporates:
     *  Constant: '<S1359>/Constant Value5'
     *  RelationalOperator: '<S1383>/Relational Operator1'
     */
    if (rtb_Summation_oh > 0.0F)
    {
        /* Switch: '<S1383>/Switch' */
        VeESSR_K_EMLPS_StrtBlendRatio = rtb_Summation_oh;
    }
    else
    {
        /* Switch: '<S1383>/Switch' */
        VeESSR_K_EMLPS_StrtBlendRatio = 0.0F;
    }

    /* End of Switch: '<S1383>/Switch' */
    /* End of Outputs for SubSystem: '<S1359>/Limiter1' */

    /* Outputs for Atomic SubSystem: '<S1359>/Stop Watch Reset Enabled' */
    /* Switch: '<S1387>/Switch2' incorporates:
     *  Constant: '<S1373>/Calib'
     *  Logic: '<S1359>/Logical10'
     *  Logic: '<S1359>/Logical11'
     *  Logic: '<S1359>/Logical9'
     *  RelationalOperator: '<S1359>/Comparison1'
     *  Switch: '<S1387>/Switch1'
     */
    if (rtb_Switch1_jf2 || (VeESSR_K_EMLPS_StrtBlendRatio <=
                            KeESSR_K_EMLPSBlendStartThresh))
    {
        /* Switch: '<S1387>/Switch1' incorporates:
         *  Constant: '<S1387>/Constant Value2'
         */
        rtb_Summation_oh = 0.0F;
    }
    else
    {
        /* Switch: '<S1387>/Switch1' incorporates:
         *  Constant: '<S1368>/Calib'
         *  Sum: '<S1387>/Subtraction'
         *  Switch: '<S1387>/Switch2'
         *  UnitDelay: '<S1387>/Unit Delay'
         */
        rtb_Summation_oh = HeESSR_t_MedTEB_dT + localDW->UnitDelay_DSTATE_m;
    }

    /* End of Switch: '<S1387>/Switch2' */

    /* Update for UnitDelay: '<S1387>/Unit Delay' */
    localDW->UnitDelay_DSTATE_m = rtb_Summation_oh;

    /* End of Outputs for SubSystem: '<S1359>/Stop Watch Reset Enabled' */

    /* Switch: '<S1359>/Switch7' incorporates:
     *  Constant: '<S1366>/Constant'
     *  Constant: '<S1380>/Calib'
     *  DataStoreWrite: '<S1359>/Dsw_EngStrtType2'
     *  Logic: '<S1359>/Logical'
     *  RelationalOperator: '<S1359>/Comparison4'
     */
    if (rtu_VeENGR_b_EngCombustionCmnd && (rtb_Summation_oh >
            KeESSR_t_EMLPSStartTime))
    {
        VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Startng;
    }

    /* End of Switch: '<S1359>/Switch7' */

    /* Switch: '<S1359>/Switch3' incorporates:
     *  DataStoreRead: '<S1359>/Dsr_InputSpeedProfile6'
     *  DataStoreWrite: '<S1359>/Dsw_InputSpeedProfile'
     *  Sum: '<S1359>/Sum4'
     */
    if (rtb_Equal2_p)
    {
        VeESSR_n_InputSpeedProfile_DS = rtu_VeESSR_n_TransInSpdFlt;
    }
    else
    {
        /* Sum: '<S1359>/Sum3' incorporates:
         *  Constant: '<S1378>/Calib'
         *  Constant: '<S1379>/Calib'
         *  DataStoreRead: '<S1359>/Dsr_InputSpeedProfile6'
         *  Sum: '<S1359>/Sum1'
         */
        rtb_Summation_oh = (KeESSR_n_Start2RunTgt - KeESSR_n_NiTrgtOffst12VStrt)
            - VeESSR_n_InputSpeedProfile_DS;

        /* Outputs for Atomic SubSystem: '<S1359>/Limiter' */
        /* Switch: '<S1382>/Switch1' incorporates:
         *  Constant: '<S1377>/Calib'
         *  RelationalOperator: '<S1382>/Relational Operator'
         */
        if (KeESSR_dn_EM_LPS_PtgtLU < rtb_Summation_oh)
        {
            /* Switch: '<S1382>/Switch1' */
            rtb_Summation_oh = KeESSR_dn_EM_LPS_PtgtLU;
        }

        /* End of Switch: '<S1382>/Switch1' */

        /* Switch: '<S1382>/Switch' incorporates:
         *  Constant: '<S1376>/Calib'
         *  RelationalOperator: '<S1382>/Relational Operator1'
         */
        if (rtb_Summation_oh <= KeESSR_dn_EM_LPS_PtgtLD)
        {
            rtb_Summation_oh = KeESSR_dn_EM_LPS_PtgtLD;
        }

        /* End of Switch: '<S1382>/Switch' */
        /* End of Outputs for SubSystem: '<S1359>/Limiter' */
        VeESSR_n_InputSpeedProfile_DS = rtb_Summation_oh +
            VeESSR_n_InputSpeedProfile_DS;
    }

    /* End of Switch: '<S1359>/Switch3' */

    /* Sum: '<S1386>/Summation5' incorporates:
     *  DataStoreRead: '<S1386>/Dsr_InputSpeedProfile6'
     */
    VeESSR_n_SpinUpEMLPS_SpdError = VeESSR_n_InputSpeedProfile_DS -
        rtu_VeESSR_n_TransInSpdFlt;

    /* Product: '<S1386>/proportional_term' incorporates:
     *  Constant: '<S1397>/Calib'
     */
    VeESSR_M_SpinUpEMLPS_PSpdCtl = VeESSR_n_SpinUpEMLPS_SpdError *
        KeESSR_K_SpinUpEMLPS_SpdCtlPgain;

    /* Switch: '<S1386>/Switch' */
    if (rtb_Equal2_p)
    {
        /* Switch: '<S1386>/Switch' incorporates:
         *  DataStoreRead: '<S1386>/Dsr_InputSpeedProfile7'
         */
        VeESSR_M_SpinUpEMLPS_ISpdCtl = VeESSR_M_EngTorqEst_DS;
    }
    else
    {
        /* Switch: '<S1386>/Switch' incorporates:
         *  Constant: '<S1395>/Calib'
         *  Constant: '<S1396>/Calib'
         *  Constant: '<S1398>/Calib'
         *  Product: '<S1386>/Multiplication1'
         *  Product: '<S1386>/Product'
         *  Sum: '<S1386>/Sum//Sub'
         *  Sum: '<S1386>/Sum//Sub2'
         *  Sum: '<S1386>/Sum//Sub3'
         *  UnitDelay: '<S1386>/Unit Delay'
         *  UnitDelay: '<S1386>/Unit Delay1'
         *  UnitDelay: '<S1386>/Unit Delay2'
         */
        VeESSR_M_SpinUpEMLPS_ISpdCtl = (((VeESSR_n_SpinUpEMLPS_SpdError -
            ((VeESSR_M_SpinUpEMLPS_SpdCtlPre - VeESSR_M_SpinUpEMLPS_SpdCtlPost) *
             KeESSR_K_SpinUpEMLPS_WindupIgain)) *
            KeESSR_K_SpinUpEMLPS_SpdCtlIgain) * HeESSR_t_MedTEB_dT) +
            VeESSR_M_SpinUpEMLPS_ISpdCtl;
    }

    /* End of Switch: '<S1386>/Switch' */

    /* Sum: '<S1386>/Sum//Sub1' */
    VeESSR_M_SpinUpEMLPS_SpdCtlPre = VeESSR_M_SpinUpEMLPS_PSpdCtl +
        VeESSR_M_SpinUpEMLPS_ISpdCtl;

    /* Outputs for Atomic SubSystem: '<S1386>/Limiter' */
    /* Switch: '<S1399>/Switch1' incorporates:
     *  RelationalOperator: '<S1399>/Relational Operator'
     */
    if (rtu_EngTrqAct < VeESSR_M_SpinUpEMLPS_SpdCtlPre)
    {
        /* Switch: '<S1399>/Switch1' */
        rtb_Summation_oh = rtu_EngTrqAct;
    }
    else
    {
        /* Switch: '<S1399>/Switch1' */
        rtb_Summation_oh = VeESSR_M_SpinUpEMLPS_SpdCtlPre;
    }

    /* End of Switch: '<S1399>/Switch1' */

    /* Switch: '<S1399>/Switch' incorporates:
     *  RelationalOperator: '<S1399>/Relational Operator1'
     */
    if (rtb_Summation_oh > rtu_TiEstMin)
    {
        /* Switch: '<S1399>/Switch' */
        VeESSR_M_SpinUpEMLPS_SpdCtlPost = rtb_Summation_oh;
    }
    else
    {
        /* Switch: '<S1399>/Switch' */
        VeESSR_M_SpinUpEMLPS_SpdCtlPost = rtu_TiEstMin;
    }

    /* End of Switch: '<S1399>/Switch' */
    /* End of Outputs for SubSystem: '<S1386>/Limiter' */

    /* DataStoreWrite: '<S1359>/Dsw_InputTorqEst' */
    VeESSR_M_EngTorqEst_DS = VeESSR_M_SpinUpEMLPS_SpdCtlPost;

    /* DataStoreWrite: '<S1359>/Dsw_STMTmr' incorporates:
     *  Constant: '<S1368>/Calib'
     *  DataStoreRead: '<S1359>/Dsr_STMTmr'
     *  Sum: '<S1359>/Summation'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Switch: '<S1370>/Switch1' incorporates:
     *  Constant: '<S1363>/Constant'
     *  DataStoreWrite: '<S1359>/Dsw_STMTrigger'
     *  Switch: '<S1370>/Switch2'
     */
    if (VeESSR_b_Strt2RunSpdChk_EMLPS)
    {
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngSpdTgtAch;
    }
    else
    {
        if (rtb_GreaterThan1_mg)
        {
            /* Switch: '<S1370>/Switch1' incorporates:
             *  Constant: '<S1364>/Constant'
             *  DataStoreWrite: '<S1359>/Dsw_STMTrigger'
             *  Switch: '<S1370>/Switch2'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;
        }
    }

    /* End of Switch: '<S1370>/Switch1' */

    /* If: '<S1359>/If1' */
    if (rtb_LogicalOperator1_hs)
    {
        /* Outputs for IfAction SubSystem: '<S1359>/If_KeyCrank_P1C65' incorporates:
         *  ActionPort: '<S1372>/Action Port'
         */
        /* DataStoreWrite: '<S1359>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_KeyCrank_P1C65((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S1359>/If_KeyCrank_P1C65' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1359>/If_KeyCrank_NoFault' incorporates:
         *  ActionPort: '<S1371>/Action Port'
         */
        /* DataStoreWrite: '<S1359>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_KeyCrank_NoFault((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S1359>/If_KeyCrank_NoFault' */
    }

    /* End of If: '<S1359>/If1' */

    /* Switch: '<S1359>/Switch4' incorporates:
     *  Constant: '<S1359>/Constant Value'
     *  DataStoreRead: '<S1359>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S1359>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S1359>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S1359>/Logical21'
     *  RelationalOperator: '<S1359>/Comparison'
     *  S-Function (sfix_bitop): '<S1359>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S1362>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator1_hs && ((VeESSR_g_StrtStpFailPhaseSelect_DS &
            134217728U) > 0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 134217728U;
    }

    /* End of Switch: '<S1359>/Switch4' */

    /* DataStoreWrite: '<S1359>/Dsw_InputAcceltnProf' incorporates:
     *  Constant: '<S1359>/Constant Value1'
     */
    VeESSR_dn_InputAcceltnProf_DS = 0.0F;
}

#endif

/*
 * Output and update for action system:
 *    '<S2679>/UsingAdapt'
 *    '<S2492>/UsingAdapt'
 *    '<S2955>/UsingAdapt'
 *    '<S2920>/UsingAdapt'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_UsingAdapt(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Out1, P2VAR(float32,
    AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_k_EngStpProfAngAdpt)
{
    /* Product: '<S2688>/Product' */
    *rty_Out1 = (*rtd_NeESSR_k_EngStpProfAngAdpt) * rtu_In1;
}

#endif

/*
 * Output and update for action system:
 *    '<S2679>/PassThrough'
 *    '<S2721>/PassThrough'
 *    '<S2722>/PassThrough'
 *    '<S2492>/PassThrough'
 *    '<S2518>/PassThrough'
 *    '<S2519>/PassThrough'
 *    '<S2535>/PassThrough'
 *    '<S2536>/PassThrough'
 *    '<S2955>/PassThrough'
 *    '<S2976>/PassThrough'
 *    ...
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_PassThrough(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Out1)
{
    /* Inport: '<S2687>/In1' */
    *rty_Out1 = rtu_In1;
}

#endif

/*
 * Output and update for action system:
 *    '<S2721>/Subtract720'
 *    '<S2722>/Subtract720'
 *    '<S2518>/Subtract720'
 *    '<S2519>/Subtract720'
 *    '<S2535>/Subtract720'
 *    '<S2536>/Subtract720'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Subtract720(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Out1)
{
    /* Sum: '<S2724>/Subtraction' incorporates:
     *  Constant: '<S2724>/Constant Value2'
     */
    *rty_Out1 = rtu_In1 - 720.0F;
}

#endif

/* System initialize for function-call system: '<S2449>/PrepForStopDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_PrepForStopDur_Init(P2VAR
    (DW_PrepForStopDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW)
{
    /* InitializeConditions for Delay: '<S2735>/IntegerDelay' */
    localDW->icLoad = 1U;
}

#endif

/* Output and update for function-call system: '<S2449>/PrepForStopDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_PrepForStopDur(VAR(float32, AUTOMATIC)
    rtu_TransInSpdFlt, VAR(float32, AUTOMATIC) rtu_NiDotMax, VAR(float32,
    AUTOMATIC) rtu_NiDotMin, VAR(float32, AUTOMATIC) rtu_EngTrqActual, VAR
    (float32, AUTOMATIC) rtu_EngCapacityMinRun, VAR(boolean, AUTOMATIC)
    rtu_EngOnReq, VAR(float32, AUTOMATIC) rtu_EngAng720Est, VAR
    (TeENGR_e_CylinderDeacModes, AUTOMATIC) rtu_CylinderDeacMode, VAR(boolean,
    AUTOMATIC) rtu_AuxPumpRunning, VAR(float32, AUTOMATIC) rtu_OAT, VAR(float32,
    AUTOMATIC) rtu_TFT, VAR(float32, AUTOMATIC) rtu_EngCapacityMinRunImmed, VAR
    (float32, AUTOMATIC) rtu_OptInputTorq, VAR(float32, AUTOMATIC)
    rtu_VeHSER_n_NiMax, VAR(boolean, AUTOMATIC) rtu_EngAngle720SyncFA, VAR
    (boolean, AUTOMATIC) rtu_EngAngle720SyncLrn, VAR(boolean, AUTOMATIC)
    rtu_AStopEngCOMLmp, VAR(float32, AUTOMATIC) rtu_EngCapacityMinOff, VAR
    (TeENGR_e_EngDFSO_St, AUTOMATIC) rtu_DFCOSt, VAR(TeINVR_e_MtrInvrtrSt,
    AUTOMATIC) rtu_VeINVR_e_MtrA_InvrtrSt, P2VAR(DW_PrepForStopDur_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR(ZCE_PrepForStopDur_ESSR_ac_T,
    AUTOMATIC, ESSR_VAR_INIT) localZCE, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_k_EngStpProfAngAdpt)
{
    sint32 i;
    float32 rtb_Abs_k3;
    float32 rtb_Gain1_p;
    float32 rtb_Gain_d;
    float32 rtb_Gain_ne;
    float32 rtb_Gain_o5;
    float32 rtb_IntegerDelay;
    float32 rtb_Merge_hk;
    float32 rtb_MinMax3_d;
    float32 rtb_Product4;
    float32 rtb_Product4_oy;
    float32 rtb_Sum15;
    float32 rtb_Sum2_nb;
    float32 rtb_Sum6_np;
    float32 rtb_Sum_dj;
    float32 rtb_Sum_p5;
    float32 rtb_Switch1_b15;
    float32 rtb_Switch1_hm4;
    float32 rtb_Switch_eh2;
    float32 rtb_Vector_bu;
    uint8 tmp;
    boolean rtb_AND5_oc;
    boolean rtb_Comparison_ci;
    boolean rtb_Logical1_fj;
    boolean rtb_Logical1_ky;
    boolean rtb_Logical2_ep;
    boolean rtb_LogicalOperator10_a;
    boolean rtb_LogicalOperator11_n;
    boolean rtb_LogicalOperator7_f;
    boolean rtb_LogicalOperator8_i;
    boolean rtb_LogicalOperator9_l;
    boolean rtb_RelationalOperator_dhi;
    boolean rtb_RelationalOperator_ns;

    /* Abs: '<S2640>/Abs' incorporates:
     *  Constant: '<S2646>/Calib'
     *  Constant: '<S2656>/Calib'
     *  Product: '<S2640>/Multiplication'
     */
    rtb_Abs_k3 = fabsf(KeESSR_dM_PrepStopTiRmpRt * HeESSR_t_MedTEB_dT);

    /* MinMax: '<S2634>/MinMax3' incorporates:
     *  DataStoreRead: '<S2634>/Dsr_EngTrqReqImmed2'
     *  DataStoreRead: '<S2634>/Dsr_EngTrqReqImmed4'
     */
    rtb_MinMax3_d = fminf(VeESSR_M_PrepStpImmedTgt_DS,
                          VeESSR_M_EngTrqReqImmed_DS);

    /* Sum: '<S2640>/Sum' incorporates:
     *  DataStoreRead: '<S2634>/Dsr_EngTrqReqImmed1'
     */
    rtb_Sum_p5 = rtb_MinMax3_d - VeESSR_M_EngTrqReqImmed_DS;

    /* Outputs for Atomic SubSystem: '<S2640>/Limiter1' */
    /* Switch: '<S2713>/Switch1' incorporates:
     *  RelationalOperator: '<S2713>/Relational Operator'
     */
    if (rtb_Abs_k3 < rtb_Sum_p5)
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtb_Abs_k3;
    }
    else
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtb_Sum_p5;
    }

    /* End of Switch: '<S2713>/Switch1' */

    /* Switch: '<S2713>/Switch' incorporates:
     *  Gain: '<S2640>/Gain'
     *  RelationalOperator: '<S2713>/Relational Operator1'
     */
    if (rtb_Vector_bu <= (-rtb_Abs_k3))
    {
        rtb_Vector_bu = -rtb_Abs_k3;
    }

    /* End of Switch: '<S2713>/Switch' */
    /* End of Outputs for SubSystem: '<S2640>/Limiter1' */

    /* Sum: '<S2640>/Sum1' incorporates:
     *  DataStoreRead: '<S2634>/Dsr_EngTrqReqImmed1'
     */
    rtb_Gain_d = rtb_Vector_bu + VeESSR_M_EngTrqReqImmed_DS;

    /* Outputs for Atomic SubSystem: '<S2640>/Limiter2' */
    /* Switch: '<S2714>/Switch1' incorporates:
     *  Constant: '<S2634>/Constant Value5'
     *  RelationalOperator: '<S2714>/Relational Operator'
     */
    if (9999.0F < rtb_Gain_d)
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = 9999.0F;
    }
    else
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtb_Gain_d;
    }

    /* End of Switch: '<S2714>/Switch1' */

    /* Switch: '<S2714>/Switch' incorporates:
     *  Constant: '<S2634>/Constant Value1'
     *  DataStoreWrite: '<S2634>/Dsw_EngTrqReqImmed'
     *  RelationalOperator: '<S2714>/Relational Operator1'
     */
    if (rtb_Vector_bu > -9999.0F)
    {
        VeESSR_M_EngTrqReqImmed_DS = rtb_Vector_bu;
    }
    else
    {
        VeESSR_M_EngTrqReqImmed_DS = -9999.0F;
    }

    /* End of Switch: '<S2714>/Switch' */
    /* End of Outputs for SubSystem: '<S2640>/Limiter2' */

    /* Abs: '<S2641>/Abs' incorporates:
     *  Constant: '<S2646>/Calib'
     *  Constant: '<S2655>/Calib'
     *  Product: '<S2641>/Multiplication'
     */
    rtb_Sum_p5 = fabsf(KeESSR_dM_PrepStopPredTiRmpRt * HeESSR_t_MedTEB_dT);

    /* Switch: '<S2647>/Switch1' incorporates:
     *  Constant: '<S2644>/Constant'
     *  Constant: '<S2654>/Calib'
     *  RelationalOperator: '<S2634>/Comparison4'
     *  Switch: '<S2648>/Switch1'
     */
    if (KeESSR_b_MinEngRunTorqOvrrd)
    {
        /* Merge: '<S2722>/Merge' incorporates:
         *  Constant: '<S2651>/Calib'
         */
        rtb_Gain_d = KeESSR_M_MinEngRunTorq;
    }
    else if (((uint32)rtu_DFCOSt) == CeENGR_e_DFSO_Enabled)
    {
        /* Switch: '<S2648>/Switch1' incorporates:
         *  Merge: '<S2722>/Merge'
         */
        rtb_Gain_d = rtu_EngCapacityMinOff;
    }
    else
    {
        /* Merge: '<S2722>/Merge' incorporates:
         *  Switch: '<S2648>/Switch1'
         */
        rtb_Gain_d = rtu_EngCapacityMinRun;
    }

    /* End of Switch: '<S2647>/Switch1' */

    /* Sum: '<S2641>/Sum' incorporates:
     *  DataStoreRead: '<S2634>/Dsr_EngTrqReqPrdtd1'
     */
    rtb_Sum_dj = rtb_Gain_d - VeESSR_M_EngTrqReqPrdtd_DS;

    /* Outputs for Atomic SubSystem: '<S2641>/Limiter1' */
    /* Switch: '<S2715>/Switch1' incorporates:
     *  RelationalOperator: '<S2715>/Relational Operator'
     */
    if (rtb_Sum_p5 < rtb_Sum_dj)
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtb_Sum_p5;
    }
    else
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtb_Sum_dj;
    }

    /* End of Switch: '<S2715>/Switch1' */

    /* Switch: '<S2715>/Switch' incorporates:
     *  Gain: '<S2641>/Gain'
     *  RelationalOperator: '<S2715>/Relational Operator1'
     */
    if (rtb_Vector_bu <= (-rtb_Sum_p5))
    {
        rtb_Vector_bu = -rtb_Sum_p5;
    }

    /* End of Switch: '<S2715>/Switch' */
    /* End of Outputs for SubSystem: '<S2641>/Limiter1' */

    /* Sum: '<S2641>/Sum1' incorporates:
     *  DataStoreRead: '<S2634>/Dsr_EngTrqReqPrdtd1'
     */
    rtb_Abs_k3 = rtb_Vector_bu + VeESSR_M_EngTrqReqPrdtd_DS;

    /* Outputs for Atomic SubSystem: '<S2641>/Limiter2' */
    /* Switch: '<S2716>/Switch1' incorporates:
     *  Constant: '<S2634>/Constant Value3'
     *  RelationalOperator: '<S2716>/Relational Operator'
     */
    if (9999.0F < rtb_Abs_k3)
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = 9999.0F;
    }
    else
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtb_Abs_k3;
    }

    /* End of Switch: '<S2716>/Switch1' */

    /* Switch: '<S2716>/Switch' incorporates:
     *  Constant: '<S2634>/Constant Value4'
     *  DataStoreWrite: '<S2634>/Dsw_EngTrqReqPrdtd'
     *  RelationalOperator: '<S2716>/Relational Operator1'
     */
    if (rtb_Vector_bu > -9999.0F)
    {
        VeESSR_M_EngTrqReqPrdtd_DS = rtb_Vector_bu;
    }
    else
    {
        VeESSR_M_EngTrqReqPrdtd_DS = -9999.0F;
    }

    /* End of Switch: '<S2716>/Switch' */
    /* End of Outputs for SubSystem: '<S2641>/Limiter2' */

    /* MinMax: '<S2634>/MinMax1' incorporates:
     *  Constant: '<S2657>/Calib'
     */
    VeESSR_dn_NiDotMaxForPFS = fminf(rtu_NiDotMax, KeESSR_dn_AStp_PFS_NiDotMax);

    /* MinMax: '<S2634>/MinMax2' incorporates:
     *  Constant: '<S2658>/Calib'
     */
    VeESSR_dn_NiDotMinForPFS = fmaxf(rtu_NiDotMin, KeESSR_dn_AStp_PFS_NiDotMin);

    /* Gain: '<S2675>/Gain' incorporates:
     *  Abs: '<S2675>/Abs1'
     *  Constant: '<S2661>/Calib'
     */
    rtb_Gain_ne = -fabsf(KeESSR_dn_PFSJerkMin);

    /* Product: '<S2735>/Product4' incorporates:
     *  Constant: '<S2646>/Calib'
     */
    rtb_Product4 = rtb_Gain_ne / HeESSR_t_MedTEB_dT;

    /* DataStoreRead: '<S2634>/Dsr_InputSpeedProfile2' */
    rtb_Abs_k3 = VeESSR_n_InputSpeedProfile_DS;

    /* RelationalOperator: '<S2634>/Comparison' incorporates:
     *  Constant: '<S2646>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_STMTmr'
     */
    rtb_Comparison_ci = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

    /* Switch: '<S2676>/Switch1' */
    if (rtb_Comparison_ci)
    {
        /* Switch: '<S2676>/Switch1' incorporates:
         *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile2'
         */
        rtb_Sum_p5 = VeESSR_n_InputSpeedProfile_DS;
    }
    else
    {
        /* Switch: '<S2676>/Switch1' incorporates:
         *  UnitDelay: '<S2676>/Unit Delay'
         */
        rtb_Sum_p5 = localDW->UnitDelay_DSTATE;
    }

    /* End of Switch: '<S2676>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S2675>/LowpassT Reset Enabled' */
    /* Sum: '<S2733>/Summation' incorporates:
     *  Constant: '<S2646>/Calib'
     *  Constant: '<S2663>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_STMTmr5'
     *  MinMax: '<S2733>/Maximum'
     *  Product: '<S2733>/Multiplication'
     *  Product: '<S2733>/Multiplication1'
     *  Sum: '<S2733>/Subtraction'
     */
    rtb_Sum_p5 += ((VeESSR_n_TgtIdleSpd_DS - rtb_Sum_p5) * HeESSR_t_MedTEB_dT) *
        (1.0F / fmaxf(KeESSR_k_AStopScndOrdLwPassT, HeESSR_t_MedTEB_dT));

    /* End of Outputs for SubSystem: '<S2675>/LowpassT Reset Enabled' */

    /* Outputs for Atomic SubSystem: '<S2675>/LowpassT Reset Enabled1' */
    /* Sum: '<S2734>/Summation' incorporates:
     *  Constant: '<S2646>/Calib'
     *  Constant: '<S2662>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile3'
     *  MinMax: '<S2734>/Maximum'
     *  Product: '<S2734>/Multiplication'
     *  Product: '<S2734>/Multiplication1'
     *  Sum: '<S2734>/Subtraction'
     */
    rtb_Sum_dj = (((rtb_Sum_p5 - VeESSR_n_InputSpeedProfile_DS) *
                   HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                   (KeESSR_k_AStopFrstOrdLwPassT, HeESSR_t_MedTEB_dT))) +
        VeESSR_n_InputSpeedProfile_DS;

    /* End of Outputs for SubSystem: '<S2675>/LowpassT Reset Enabled1' */

    /* Switch: '<S2754>/Switch1' incorporates:
     *  UnitDelay: '<S2754>/Unit Delay'
     */
    if (rtb_Comparison_ci)
    {
        rtb_Vector_bu = rtb_Sum_dj;
    }
    else
    {
        rtb_Vector_bu = localDW->UnitDelay_DSTATE_g;
    }

    /* End of Switch: '<S2754>/Switch1' */

    /* Gain: '<S2735>/Gain1' incorporates:
     *  Sum: '<S2735>/Sum18'
     */
    rtb_Gain1_p = (rtb_Sum_dj + rtb_Vector_bu) * 0.5F;

    /* Delay: '<S2735>/IntegerDelay' incorporates:
     *  Constant: '<S2744>/Calib'
     */
    if (rtb_Comparison_ci && (((uint32)localZCE->IntegerDelay_Reset_ZCE_k) !=
                              POS_ZCSIG))
    {
        localDW->icLoad = 1U;
    }

    localZCE->IntegerDelay_Reset_ZCE_k = rtb_Comparison_ci ? ((ZCSigState)1) :
        ((ZCSigState)0);
    if (((sint32)localDW->icLoad) != 0)
    {
        for (i = 0; i < 16; i++)
        {
            localDW->IntegerDelay_DSTATE[i] = rtb_Gain1_p;
        }
    }

    if (((sint32)KeESSR_Cnt_DelayOptNi) <= 0)
    {
        /* Delay: '<S2735>/IntegerDelay' */
        rtb_IntegerDelay = rtb_Gain1_p;
    }
    else
    {
        if (((sint32)KeESSR_Cnt_DelayOptNi) > 16)
        {
            tmp = 16U;
        }
        else
        {
            tmp = KeESSR_Cnt_DelayOptNi;
        }

        /* Delay: '<S2735>/IntegerDelay' */
        rtb_IntegerDelay = localDW->IntegerDelay_DSTATE[(uint8)(16U - ((uint32)
            tmp))];
    }

    /* End of Delay: '<S2735>/IntegerDelay' */

    /* Sum: '<S2735>/Sum15' incorporates:
     *  Abs: '<S2735>/Abs4'
     *  Constant: '<S2659>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile5'
     */
    rtb_Sum15 = fabsf(VeESSR_dn_TargetAcceltn_DS) + KeESSR_dn_NiTargetJerkLimit;

    /* Outputs for Atomic SubSystem: '<S2735>/GradientLimiter' */
    /* Sum: '<S2737>/Sum2' incorporates:
     *  Constant: '<S2646>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile1'
     *  Product: '<S2735>/Product6'
     *  Sum: '<S2735>/Sum14'
     *  UnitDelay: '<S2737>/Unit Delay'
     */
    rtb_Sum2_nb = ((rtb_Gain1_p - VeESSR_n_TargetSpeed_DS) / HeESSR_t_MedTEB_dT)
        - localDW->UnitDelay_DSTATE_l;

    /* Outputs for Atomic SubSystem: '<S2737>/Limiter' */
    /* Switch: '<S2755>/Switch1' incorporates:
     *  RelationalOperator: '<S2755>/Relational Operator'
     */
    if (rtb_Sum15 < rtb_Sum2_nb)
    {
        /* Merge: '<S2721>/Merge' */
        rtb_Merge_hk = rtb_Sum15;
    }
    else
    {
        /* Merge: '<S2721>/Merge' */
        rtb_Merge_hk = rtb_Sum2_nb;
    }

    /* End of Switch: '<S2755>/Switch1' */

    /* Switch: '<S2755>/Switch' incorporates:
     *  Gain: '<S2735>/Gain'
     *  RelationalOperator: '<S2755>/Relational Operator1'
     */
    if (rtb_Merge_hk <= (-rtb_Sum15))
    {
        rtb_Merge_hk = -rtb_Sum15;
    }

    /* End of Switch: '<S2755>/Switch' */
    /* End of Outputs for SubSystem: '<S2737>/Limiter' */

    /* Sum: '<S2737>/Sum3' incorporates:
     *  UnitDelay: '<S2737>/Unit Delay'
     */
    rtb_Gain_o5 = rtb_Merge_hk + localDW->UnitDelay_DSTATE_l;

    /* Update for UnitDelay: '<S2737>/Unit Delay' */
    localDW->UnitDelay_DSTATE_l = rtb_Gain_o5;

    /* End of Outputs for SubSystem: '<S2735>/GradientLimiter' */

    /* Sum: '<S2736>/Subtraction1' incorporates:
     *  Constant: '<S2664>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile5'
     *  Product: '<S2736>/Multiplication'
     *  Sum: '<S2736>/Subtraction'
     */
    rtb_Sum15 = ((rtb_Gain_o5 - VeESSR_dn_TargetAcceltn_DS) *
                 KeESSR_k_NiDotTargetFilt) + VeESSR_dn_TargetAcceltn_DS;

    /* DataStoreRead: '<S2634>/Dsr_InputSpeedProfile4' */
    rtb_Gain_o5 = VeESSR_dn_InputAcceltnProf_DS;

    /* Abs: '<S2675>/Abs' incorporates:
     *  Constant: '<S2660>/Calib'
     */
    rtb_Vector_bu = fabsf(KeESSR_dn_PFSJerkMax);

    /* Switch: '<S2766>/Switch1' incorporates:
     *  Constant: '<S2764>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S2766>/Switch1' incorporates:
         *  Constant: '<S2765>/Calib'
         */
        rtb_Switch1_b15 = HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S2753>/Sum6' incorporates:
         *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile4'
         *  Sum: '<S2753>/Sum8'
         */
        rtb_Merge_hk = VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15;

        /* Abs: '<S2753>/Abs' incorporates:
         *  Sum: '<S2753>/Sum6'
         */
        rtb_Sum2_nb = (rtb_Merge_hk - rtb_Gain_ne) + rtb_Vector_bu;

        /* MinMax: '<S2753>/MinMax2' incorporates:
         *  Abs: '<S2753>/Abs1'
         *  Constant: '<S2646>/Calib'
         *  Constant: '<S2753>/Constant Value'
         *  Constant: '<S2753>/Constant Value3'
         *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile3'
         *  Product: '<S2753>/Product2'
         *  Product: '<S2753>/Product7'
         *  Product: '<S2768>/Prod'
         *  Sum: '<S2753>/Sum3'
         *  Sum: '<S2753>/Sum5'
         */
        rtb_Sum2_nb = fmaxf((fabsf((rtb_IntegerDelay -
                               VeESSR_n_InputSpeedProfile_DS) -
                              (HeESSR_t_MedTEB_dT * rtb_Sum15)) * (rtb_Product4 *
                              -2.0F)) - (rtb_Sum2_nb * rtb_Sum2_nb), 0.0F);

        /* Switch: '<S2770>/Switch' incorporates:
         *  Sqrt: '<S2770>/Sqrt'
         */
        rtb_Sum2_nb = sqrtf(rtb_Sum2_nb);

        /* Switch: '<S2766>/Switch1' incorporates:
         *  Abs: '<S2753>/Abs'
         *  Sum: '<S2753>/Sum7'
         *  Sum: '<S2753>/Sum8'
         */
        rtb_Switch1_b15 = fabsf(rtb_Merge_hk + rtb_Gain_ne) + (rtb_Sum2_nb +
            rtb_Sum15);
    }

    /* End of Switch: '<S2766>/Switch1' */

    /* Product: '<S2735>/Product1' incorporates:
     *  Constant: '<S2646>/Calib'
     */
    rtb_Sum2_nb = rtb_Vector_bu / HeESSR_t_MedTEB_dT;

    /* Switch: '<S2767>/Switch1' incorporates:
     *  Constant: '<S2764>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S2767>/Switch1' incorporates:
         *  Constant: '<S2765>/Calib'
         *  Gain: '<S2753>/Gain1'
         */
        rtb_Switch1_hm4 = -HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S2753>/Sum11' incorporates:
         *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile4'
         *  Sum: '<S2753>/Sum13'
         */
        rtb_Switch_eh2 = VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15;

        /* Abs: '<S2753>/Abs2' incorporates:
         *  Sum: '<S2753>/Sum11'
         */
        rtb_Merge_hk = (rtb_Switch_eh2 - rtb_Vector_bu) + rtb_Gain_ne;

        /* MinMax: '<S2753>/MinMax1' incorporates:
         *  Abs: '<S2753>/Abs3'
         *  Constant: '<S2646>/Calib'
         *  Constant: '<S2753>/Constant Value1'
         *  Constant: '<S2753>/Constant Value2'
         *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile3'
         *  Product: '<S2753>/Product5'
         *  Product: '<S2753>/Product8'
         *  Product: '<S2771>/Prod'
         *  Sum: '<S2753>/Sum10'
         *  Sum: '<S2753>/Sum9'
         */
        rtb_Merge_hk = fmaxf((fabsf((rtb_IntegerDelay -
                                VeESSR_n_InputSpeedProfile_DS) -
                               (HeESSR_t_MedTEB_dT * rtb_Sum15)) * (rtb_Sum2_nb *
                               2.0F)) - (rtb_Merge_hk * rtb_Merge_hk), 0.0F);

        /* Switch: '<S2769>/Switch' incorporates:
         *  Sqrt: '<S2769>/Sqrt'
         */
        rtb_Merge_hk = sqrtf(rtb_Merge_hk);

        /* Switch: '<S2767>/Switch1' incorporates:
         *  Abs: '<S2753>/Abs2'
         *  Sum: '<S2753>/Sum12'
         *  Sum: '<S2753>/Sum13'
         */
        rtb_Switch1_hm4 = (rtb_Sum15 - rtb_Merge_hk) - fabsf(rtb_Switch_eh2 +
            rtb_Vector_bu);
    }

    /* End of Switch: '<S2767>/Switch1' */

    /* Switch: '<S2735>/Switch1' incorporates:
     *  Constant: '<S2740>/Calib'
     *  Constant: '<S2741>/Calib'
     *  DataStoreRead: '<S2634>/Data Store Read'
     *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile6'
     *  Logic: '<S2735>/Logical1'
     *  Logic: '<S2735>/Logical6'
     *  Logic: '<S2735>/Logical8'
     */
    if (((HeESSR_b_NiLmtBypsLoopJerk) && (VeESSR_b_NiMaxActive_DS)) ||
            ((VeESSR_b_NiDotMaxActive_DS) && (HeESSR_b_NiDotLmtBypsLoopJerk)))
    {
        /* Switch: '<S2735>/Switch1' */
        rtb_Vector_bu = rtb_Switch1_b15;
    }
    else
    {
        /* Switch: '<S2735>/Switch1' incorporates:
         *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile4'
         *  Sum: '<S2735>/Sum1'
         */
        rtb_Vector_bu += VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S2735>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S2735>/Limiter2' */
    /* Switch: '<S2748>/Switch1' incorporates:
     *  RelationalOperator: '<S2748>/Relational Operator'
     */
    if (rtb_Switch1_b15 < rtb_Vector_bu)
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtb_Switch1_b15;
    }

    /* End of Switch: '<S2748>/Switch1' */

    /* Switch: '<S2748>/Switch' incorporates:
     *  RelationalOperator: '<S2748>/Relational Operator1'
     */
    if (rtb_Vector_bu <= rtb_Switch1_hm4)
    {
        /* Switch: '<S2748>/Switch' */
        rtb_Vector_bu = rtb_Switch1_hm4;
    }

    /* End of Switch: '<S2748>/Switch' */
    /* End of Outputs for SubSystem: '<S2735>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S2735>/Limiter4' */
    /* Switch: '<S2750>/Switch1' incorporates:
     *  RelationalOperator: '<S2750>/Relational Operator'
     */
    if (VeESSR_dn_NiDotMaxForPFS < rtb_Vector_bu)
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = VeESSR_dn_NiDotMaxForPFS;
    }

    /* End of Switch: '<S2750>/Switch1' */

    /* Switch: '<S2750>/Switch' incorporates:
     *  RelationalOperator: '<S2750>/Relational Operator1'
     */
    if (rtb_Vector_bu > VeESSR_dn_NiDotMinForPFS)
    {
        /* Switch: '<S2750>/Switch' */
        rtb_Switch_eh2 = rtb_Vector_bu;
    }
    else
    {
        /* Switch: '<S2750>/Switch' */
        rtb_Switch_eh2 = VeESSR_dn_NiDotMinForPFS;
    }

    /* End of Switch: '<S2750>/Switch' */
    /* End of Outputs for SubSystem: '<S2735>/Limiter4' */

    /* Sum: '<S2739>/Sum6' incorporates:
     *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile3'
     */
    rtb_Sum6_np = rtu_VeHSER_n_NiMax - VeESSR_n_InputSpeedProfile_DS;

    /* Abs: '<S2739>/Abs2' */
    rtb_Vector_bu = fabsf(rtb_Sum6_np);

    /* Switch: '<S2739>/Switch' incorporates:
     *  Constant: '<S2739>/Constant Value7'
     *  RelationalOperator: '<S2739>/Comparison2'
     */
    if (rtb_Sum6_np < 0.0F)
    {
        /* Merge: '<S2721>/Merge' incorporates:
         *  Abs: '<S2739>/Abs'
         */
        rtb_Merge_hk = fabsf(rtb_Sum2_nb);
    }
    else
    {
        /* Merge: '<S2721>/Merge' incorporates:
         *  Abs: '<S2739>/Abs1'
         *  Gain: '<S2739>/Gain'
         */
        rtb_Merge_hk = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S2739>/Switch' */

    /* Product: '<S2739>/Product4' incorporates:
     *  Constant: '<S2646>/Calib'
     */
    rtb_Product4_oy = (rtb_Merge_hk * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2739>/Protected Division1' */
    /* Switch: '<S2762>/Switch1' incorporates:
     *  Constant: '<S2762>/Constant Value'
     *  Constant: '<S2762>/Constant Value1'
     *  Constant: '<S2762>/Constant Value2'
     *  Logic: '<S2762>/AND'
     *  RelationalOperator: '<S2762>/Greater Than or Equal '
     *  RelationalOperator: '<S2762>/Not Equal'
     *  RelationalOperator: '<S2762>/Not Equal1'
     *  Switch: '<S2762>/Switch2'
     */
    if ((rtb_Vector_bu != 0.0F) && (rtb_Product4_oy != 0.0F))
    {
        /* Switch: '<S2762>/Switch1' incorporates:
         *  Product: '<S2762>/Division'
         */
        rtb_Vector_bu /= rtb_Product4_oy;
    }
    else if (rtb_Vector_bu > 0.0F)
    {
        /* Switch: '<S2762>/Switch2' incorporates:
         *  Constant: '<S2762>/MAXFLOAT'
         *  Switch: '<S2762>/Switch1'
         */
        rtb_Vector_bu = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2762>/Switch1' incorporates:
         *  Constant: '<S2762>/Constant Value4'
         *  Switch: '<S2762>/Switch2'
         *  Switch: '<S2762>/Switch3'
         */
        rtb_Vector_bu = 0.0F;
    }

    /* End of Switch: '<S2762>/Switch1' */
    /* End of Outputs for SubSystem: '<S2739>/Protected Division1' */

    /* Sum: '<S2739>/Sum4' incorporates:
     *  Abs: '<S2739>/Abs3'
     *  Constant: '<S2739>/Constant Value3'
     *  Constant: '<S2739>/Constant Value5'
     *  Product: '<S2739>/Product3'
     */
    rtb_Vector_bu = (fabsf(rtb_Vector_bu) * 8.0F) + 1.0F;

    /* Switch: '<S2763>/Switch' */
    if (rtb_Vector_bu >= 0.0F)
    {
        /* Lookup_n-D: '<S2669>/Vector' incorporates:
         *  Sqrt: '<S2763>/Sqrt'
         */
        rtb_Vector_bu = sqrtf(rtb_Vector_bu);
    }
    else
    {
        /* Lookup_n-D: '<S2669>/Vector' incorporates:
         *  Constant: '<S2763>/Zero'
         */
        rtb_Vector_bu = 0.0F;
    }

    /* End of Switch: '<S2763>/Switch' */

    /* Lookup_n-D: '<S2669>/Vector' incorporates:
     *  Constant: '<S2739>/Constant Value'
     *  Constant: '<S2739>/Constant Value4'
     *  Constant: '<S2739>/Constant Value6'
     *  MinMax: '<S2739>/MinMax1'
     *  Product: '<S2739>/Product2'
     *  Rounding: '<S2739>/Rounding1'
     *  Sum: '<S2739>/Sum3'
     */
    rtb_Vector_bu = fmaxf(ceilf((rtb_Vector_bu - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S2739>/Product' incorporates:
     *  Constant: '<S2646>/Calib'
     */
    rtb_Product4_oy = rtb_Vector_bu * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2739>/Protected Division' */
    /* Switch: '<S2761>/Switch1' incorporates:
     *  Constant: '<S2761>/Constant Value'
     *  Constant: '<S2761>/Constant Value1'
     *  Constant: '<S2761>/Constant Value2'
     *  Constant: '<S2761>/Constant Value3'
     *  Logic: '<S2761>/AND'
     *  RelationalOperator: '<S2761>/Greater Than or Equal '
     *  RelationalOperator: '<S2761>/Greater Than or Equal 1'
     *  RelationalOperator: '<S2761>/Not Equal'
     *  RelationalOperator: '<S2761>/Not Equal1'
     *  Switch: '<S2761>/Switch2'
     *  Switch: '<S2761>/Switch3'
     */
    if ((rtb_Sum6_np != 0.0F) && (rtb_Product4_oy != 0.0F))
    {
        /* Switch: '<S2761>/Switch1' incorporates:
         *  Product: '<S2761>/Division'
         */
        rtb_Sum6_np /= rtb_Product4_oy;
    }
    else if (rtb_Sum6_np > 0.0F)
    {
        /* Switch: '<S2761>/Switch2' incorporates:
         *  Constant: '<S2761>/MAXFLOAT'
         *  Switch: '<S2761>/Switch1'
         */
        rtb_Sum6_np = 3.402823466E+38F;
    }
    else if (rtb_Sum6_np < 0.0F)
    {
        /* Switch: '<S2761>/Switch3' incorporates:
         *  Constant: '<S2761>/MINFLOAT'
         *  Switch: '<S2761>/Switch1'
         *  Switch: '<S2761>/Switch2'
         */
        rtb_Sum6_np = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2761>/Switch1' incorporates:
         *  Constant: '<S2761>/Constant Value4'
         *  Switch: '<S2761>/Switch2'
         *  Switch: '<S2761>/Switch3'
         */
        rtb_Sum6_np = 0.0F;
    }

    /* End of Switch: '<S2761>/Switch1' */
    /* End of Outputs for SubSystem: '<S2739>/Protected Division' */

    /* Sum: '<S2739>/Sum' incorporates:
     *  Constant: '<S2646>/Calib'
     *  Constant: '<S2739>/Constant Value1'
     *  Constant: '<S2739>/Constant Value2'
     *  Product: '<S2739>/Product1'
     *  Sum: '<S2739>/Sum2'
     */
    rtb_Merge_hk = rtb_Sum6_np - (((0.5F * rtb_Merge_hk) * (rtb_Vector_bu - 1.0F))
        * HeESSR_t_MedTEB_dT);

    /* Switch: '<S2735>/Switch4' incorporates:
     *  Constant: '<S2742>/Calib'
     */
    if (!HeESSR_b_NiLmtForAccelByps)
    {
        /* Switch: '<S2735>/Switch4' incorporates:
         *  MinMax: '<S2735>/MinMax1'
         */
        rtb_Switch_eh2 = fminf(rtb_Merge_hk, rtb_Switch_eh2);
    }

    /* End of Switch: '<S2735>/Switch4' */

    /* Outputs for Atomic SubSystem: '<S2735>/Limiter13' */
    /* RelationalOperator: '<S2747>/Relational Operator' */
    rtb_RelationalOperator_ns = (rtu_NiDotMax <= rtb_Switch_eh2);

    /* Switch: '<S2747>/Switch1' */
    if (rtb_RelationalOperator_ns)
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtu_NiDotMax;
    }
    else
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtb_Switch_eh2;
    }

    /* End of Switch: '<S2747>/Switch1' */

    /* Switch: '<S2747>/Switch' incorporates:
     *  RelationalOperator: '<S2747>/Relational Operator1'
     */
    if (rtb_Vector_bu <= rtu_NiDotMin)
    {
        rtb_Vector_bu = rtu_NiDotMin;
    }

    /* End of Switch: '<S2747>/Switch' */
    /* End of Outputs for SubSystem: '<S2735>/Limiter13' */

    /* Product: '<S2735>/Product9' incorporates:
     *  Constant: '<S2646>/Calib'
     */
    rtb_Switch_eh2 = rtb_Vector_bu * HeESSR_t_MedTEB_dT;

    /* Switch: '<S2735>/Switch2' incorporates:
     *  Constant: '<S2740>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile7'
     *  Logic: '<S2735>/Logical3'
     */
    if ((HeESSR_b_NiDotLmtBypsLoopJerk) && (VeESSR_b_NiDotMinActive_DS))
    {
        /* Switch: '<S2735>/Switch2' */
        rtb_Gain_ne = rtb_Switch1_hm4;
    }
    else
    {
        /* Switch: '<S2735>/Switch2' incorporates:
         *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile4'
         *  Sum: '<S2735>/Sum16'
         */
        rtb_Gain_ne += VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S2735>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S2735>/Limiter' */
    /* Switch: '<S2745>/Switch1' incorporates:
     *  RelationalOperator: '<S2745>/Relational Operator'
     */
    if (rtb_Switch1_b15 < rtb_Gain_ne)
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtb_Switch1_b15;
    }
    else
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtb_Gain_ne;
    }

    /* End of Switch: '<S2745>/Switch1' */

    /* Switch: '<S2745>/Switch' incorporates:
     *  RelationalOperator: '<S2745>/Relational Operator1'
     */
    if (rtb_Vector_bu > rtb_Switch1_hm4)
    {
        /* Switch: '<S2745>/Switch' */
        rtb_Gain_ne = rtb_Vector_bu;
    }
    else
    {
        /* Switch: '<S2745>/Switch' */
        rtb_Gain_ne = rtb_Switch1_hm4;
    }

    /* End of Switch: '<S2745>/Switch' */
    /* End of Outputs for SubSystem: '<S2735>/Limiter' */

    /* Outputs for Atomic SubSystem: '<S2735>/Limiter3' */
    /* Switch: '<S2749>/Switch1' incorporates:
     *  RelationalOperator: '<S2749>/Relational Operator'
     */
    if (VeESSR_dn_NiDotMaxForPFS < rtb_Gain_ne)
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = VeESSR_dn_NiDotMaxForPFS;
    }
    else
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtb_Gain_ne;
    }

    /* End of Switch: '<S2749>/Switch1' */
    /* End of Outputs for SubSystem: '<S2735>/Limiter3' */

    /* Switch: '<S2735>/Switch5' incorporates:
     *  Constant: '<S2742>/Calib'
     *  RelationalOperator: '<S2749>/Relational Operator1'
     *  Switch: '<S2749>/Switch'
     */
    if (HeESSR_b_NiLmtForAccelByps)
    {
        /* Outputs for Atomic SubSystem: '<S2735>/Limiter3' */
        /* Switch: '<S2749>/Switch' incorporates:
         *  RelationalOperator: '<S2749>/Relational Operator1'
         */
        if (rtb_Vector_bu > VeESSR_dn_NiDotMinForPFS)
        {
            /* Switch: '<S2735>/Switch5' */
            rtb_Gain_ne = rtb_Vector_bu;
        }
        else
        {
            /* Switch: '<S2735>/Switch5' */
            rtb_Gain_ne = VeESSR_dn_NiDotMinForPFS;
        }

        /* End of Outputs for SubSystem: '<S2735>/Limiter3' */
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S2735>/Limiter3' */
        if (rtb_Vector_bu <= VeESSR_dn_NiDotMinForPFS)
        {
            /* Switch: '<S2749>/Switch' */
            rtb_Vector_bu = VeESSR_dn_NiDotMinForPFS;
        }

        /* End of Outputs for SubSystem: '<S2735>/Limiter3' */

        /* Switch: '<S2735>/Switch5' incorporates:
         *  MinMax: '<S2735>/MinMax2'
         */
        rtb_Gain_ne = fminf(rtb_Merge_hk, rtb_Vector_bu);
    }

    /* End of Switch: '<S2735>/Switch5' */

    /* Outputs for Atomic SubSystem: '<S2735>/Limiter9' */
    /* Switch: '<S2752>/Switch1' incorporates:
     *  RelationalOperator: '<S2752>/Relational Operator'
     */
    if (rtu_NiDotMax <= rtb_Gain_ne)
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtu_NiDotMax;
    }
    else
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtb_Gain_ne;
    }

    /* End of Switch: '<S2752>/Switch1' */

    /* Logic: '<S2639>/Logical1' incorporates:
     *  RelationalOperator: '<S2752>/Relational Operator1'
     */
    rtb_Logical1_ky = (rtb_Vector_bu > rtu_NiDotMin);

    /* Logic: '<S2752>/Logical2' */
    rtb_Logical2_ep = !rtb_Logical1_ky;

    /* Switch: '<S2752>/Switch' */
    if (!rtb_Logical1_ky)
    {
        rtb_Vector_bu = rtu_NiDotMin;
    }

    /* End of Switch: '<S2752>/Switch' */
    /* End of Outputs for SubSystem: '<S2735>/Limiter9' */

    /* Product: '<S2735>/Product10' incorporates:
     *  Constant: '<S2646>/Calib'
     */
    rtb_Gain_ne = rtb_Vector_bu * HeESSR_t_MedTEB_dT;

    /* Sum: '<S2735>/Sum2' incorporates:
     *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile3'
     */
    rtb_Switch1_b15 = rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS;

    /* Sum: '<S2738>/Sum6' incorporates:
     *  Constant: '<S2646>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile3'
     *  Product: '<S2738>/Product7'
     *  Sum: '<S2735>/Sum6'
     *  Switch: '<S2735>/Switch3'
     */
    rtb_IntegerDelay = (rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS) -
        (rtb_Sum15 * HeESSR_t_MedTEB_dT);

    /* Abs: '<S2738>/Abs2' incorporates:
     *  Sum: '<S2738>/Sum6'
     */
    rtb_Merge_hk = fabsf(rtb_IntegerDelay);

    /* Switch: '<S2738>/Switch' incorporates:
     *  Constant: '<S2738>/Constant Value7'
     *  RelationalOperator: '<S2738>/Comparison2'
     *  Sum: '<S2738>/Sum6'
     */
    if (rtb_IntegerDelay < 0.0F)
    {
        /* Lookup_n-D: '<S2669>/Vector' incorporates:
         *  Abs: '<S2738>/Abs'
         */
        rtb_Vector_bu = fabsf(rtb_Sum2_nb);
    }
    else
    {
        /* Lookup_n-D: '<S2669>/Vector' incorporates:
         *  Abs: '<S2738>/Abs1'
         *  Gain: '<S2738>/Gain'
         */
        rtb_Vector_bu = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S2738>/Switch' */

    /* Product: '<S2738>/Product4' incorporates:
     *  Constant: '<S2646>/Calib'
     */
    rtb_Product4 = (rtb_Vector_bu * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2738>/Protected Division1' */
    /* Switch: '<S2758>/Switch1' incorporates:
     *  Constant: '<S2758>/Constant Value'
     *  Constant: '<S2758>/Constant Value1'
     *  Constant: '<S2758>/Constant Value2'
     *  Logic: '<S2758>/AND'
     *  RelationalOperator: '<S2758>/Greater Than or Equal '
     *  RelationalOperator: '<S2758>/Not Equal'
     *  RelationalOperator: '<S2758>/Not Equal1'
     *  Switch: '<S2758>/Switch2'
     */
    if ((rtb_Merge_hk != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S2758>/Switch1' incorporates:
         *  Product: '<S2758>/Division'
         */
        rtb_Product4 = rtb_Merge_hk / rtb_Product4;
    }
    else if (rtb_Merge_hk > 0.0F)
    {
        /* Switch: '<S2758>/Switch2' incorporates:
         *  Constant: '<S2758>/MAXFLOAT'
         *  Switch: '<S2758>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2758>/Switch1' incorporates:
         *  Constant: '<S2758>/Constant Value4'
         *  Switch: '<S2758>/Switch2'
         *  Switch: '<S2758>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S2758>/Switch1' */
    /* End of Outputs for SubSystem: '<S2738>/Protected Division1' */

    /* Sum: '<S2738>/Sum4' incorporates:
     *  Abs: '<S2738>/Abs3'
     *  Constant: '<S2738>/Constant Value3'
     *  Constant: '<S2738>/Constant Value5'
     *  Product: '<S2738>/Product3'
     */
    rtb_Product4 = (fabsf(rtb_Product4) * 8.0F) + 1.0F;

    /* Switch: '<S2759>/Switch' incorporates:
     *  Constant: '<S2759>/Zero'
     *  Sqrt: '<S2759>/Sqrt'
     */
    if (rtb_Product4 >= 0.0F)
    {
        rtb_Product4 = sqrtf(rtb_Product4);
    }
    else
    {
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S2759>/Switch' */

    /* Merge: '<S2721>/Merge' incorporates:
     *  Constant: '<S2738>/Constant Value'
     *  Constant: '<S2738>/Constant Value4'
     *  Constant: '<S2738>/Constant Value6'
     *  MinMax: '<S2738>/MinMax1'
     *  Product: '<S2738>/Product2'
     *  Rounding: '<S2738>/Rounding1'
     *  Sum: '<S2738>/Sum3'
     */
    rtb_Merge_hk = fmaxf(ceilf((rtb_Product4 - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S2738>/Product' incorporates:
     *  Constant: '<S2646>/Calib'
     */
    rtb_Product4 = rtb_Merge_hk * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2738>/Protected Division' */
    /* Switch: '<S2757>/Switch1' incorporates:
     *  Constant: '<S2757>/Constant Value'
     *  Constant: '<S2757>/Constant Value1'
     *  Constant: '<S2757>/Constant Value2'
     *  Constant: '<S2757>/Constant Value3'
     *  Logic: '<S2757>/AND'
     *  RelationalOperator: '<S2757>/Greater Than or Equal '
     *  RelationalOperator: '<S2757>/Greater Than or Equal 1'
     *  RelationalOperator: '<S2757>/Not Equal'
     *  RelationalOperator: '<S2757>/Not Equal1'
     *  Sum: '<S2738>/Sum6'
     *  Switch: '<S2757>/Switch2'
     *  Switch: '<S2757>/Switch3'
     */
    if ((rtb_IntegerDelay != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S2757>/Switch1' incorporates:
         *  Product: '<S2757>/Division'
         */
        rtb_Product4 = rtb_IntegerDelay / rtb_Product4;
    }
    else if (rtb_IntegerDelay > 0.0F)
    {
        /* Switch: '<S2757>/Switch2' incorporates:
         *  Constant: '<S2757>/MAXFLOAT'
         *  Switch: '<S2757>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else if (rtb_IntegerDelay < 0.0F)
    {
        /* Switch: '<S2757>/Switch3' incorporates:
         *  Constant: '<S2757>/MINFLOAT'
         *  Switch: '<S2757>/Switch1'
         *  Switch: '<S2757>/Switch2'
         */
        rtb_Product4 = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2757>/Switch1' incorporates:
         *  Constant: '<S2757>/Constant Value4'
         *  Switch: '<S2757>/Switch2'
         *  Switch: '<S2757>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S2757>/Switch1' */
    /* End of Outputs for SubSystem: '<S2738>/Protected Division' */

    /* Switch: '<S2735>/Switch3' incorporates:
     *  Constant: '<S2743>/Calib'
     */
    if (!HeESSR_b_TrnstnJerkByps)
    {
        /* Switch: '<S2735>/Switch8' incorporates:
         *  Constant: '<S2735>/Constant Value7'
         *  RelationalOperator: '<S2735>/Comparison'
         */
        if (rtb_IntegerDelay > 0.0F)
        {
            /* Switch: '<S2735>/Switch3' incorporates:
             *  Constant: '<S2646>/Calib'
             *  Constant: '<S2738>/Constant Value1'
             *  Constant: '<S2738>/Constant Value2'
             *  MinMax: '<S2735>/MinMax4'
             *  Product: '<S2735>/Product5'
             *  Product: '<S2738>/Product1'
             *  Sum: '<S2738>/Sum'
             *  Sum: '<S2738>/Sum2'
             *  Switch: '<S2735>/Switch8'
             */
            rtb_Switch1_b15 = fminf(rtb_Switch1_b15, ((rtb_Product4 + rtb_Sum15)
                - (((0.5F * rtb_Vector_bu) * (rtb_Merge_hk - 1.0F)) *
                   HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }
        else
        {
            /* Switch: '<S2735>/Switch3' incorporates:
             *  Constant: '<S2646>/Calib'
             *  Constant: '<S2738>/Constant Value1'
             *  Constant: '<S2738>/Constant Value2'
             *  MinMax: '<S2735>/MinMax5'
             *  Product: '<S2735>/Product2'
             *  Product: '<S2738>/Product1'
             *  Sum: '<S2738>/Sum'
             *  Sum: '<S2738>/Sum2'
             *  Switch: '<S2735>/Switch8'
             */
            rtb_Switch1_b15 = fmaxf(rtb_Switch1_b15, ((rtb_Product4 + rtb_Sum15)
                - (((0.5F * rtb_Vector_bu) * (rtb_Merge_hk - 1.0F)) *
                   HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }

        /* End of Switch: '<S2735>/Switch8' */
    }

    /* Outputs for Atomic SubSystem: '<S2735>/Limiter6' */
    /* RelationalOperator: '<S2751>/Relational Operator' */
    rtb_RelationalOperator_dhi = (rtb_Switch_eh2 <= rtb_Switch1_b15);

    /* Switch: '<S2751>/Switch1' */
    if (rtb_RelationalOperator_dhi)
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtb_Switch_eh2;
    }
    else
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtb_Switch1_b15;
    }

    /* End of Switch: '<S2751>/Switch1' */

    /* Logic: '<S2639>/Logical1' incorporates:
     *  RelationalOperator: '<S2751>/Relational Operator1'
     */
    rtb_Logical1_ky = (rtb_Vector_bu > rtb_Gain_ne);

    /* Switch: '<S2751>/Switch' */
    if (rtb_Logical1_ky)
    {
        rtb_Gain_ne = rtb_Vector_bu;
    }

    /* End of Switch: '<S2751>/Switch' */
    /* End of Outputs for SubSystem: '<S2735>/Limiter6' */

    /* Sum: '<S2735>/Sum4' incorporates:
     *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile3'
     */
    rtb_IntegerDelay = rtb_Gain_ne + VeESSR_n_InputSpeedProfile_DS;

    /* Outputs for Atomic SubSystem: '<S2735>/Limiter1' */
    /* RelationalOperator: '<S2746>/Relational Operator' incorporates:
     *  DataStoreWrite: '<S2634>/Dsw_InputSpeedProfile5'
     */
    VeESSR_b_NiMaxActive_DS = (rtu_VeHSER_n_NiMax <= rtb_IntegerDelay);

    /* Switch: '<S2746>/Switch1' incorporates:
     *  DataStoreWrite: '<S2634>/Dsw_InputSpeedProfile5'
     */
    if (VeESSR_b_NiMaxActive_DS)
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtu_VeHSER_n_NiMax;
    }
    else
    {
        /* Lookup_n-D: '<S2669>/Vector' */
        rtb_Vector_bu = rtb_IntegerDelay;
    }

    /* End of Switch: '<S2746>/Switch1' */

    /* Switch: '<S2746>/Switch' incorporates:
     *  Constant: '<S2735>/Constant Value4'
     *  RelationalOperator: '<S2746>/Relational Operator1'
     */
    if (rtb_Vector_bu > 0.0F)
    {
        /* Switch: '<S2746>/Switch' */
        rtb_IntegerDelay = rtb_Vector_bu;
    }
    else
    {
        /* Switch: '<S2746>/Switch' */
        rtb_IntegerDelay = 0.0F;
    }

    /* End of Switch: '<S2746>/Switch' */
    /* End of Outputs for SubSystem: '<S2735>/Limiter1' */

    /* Product: '<S2735>/Product3' incorporates:
     *  Constant: '<S2646>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_InputSpeedProfile3'
     *  DataStoreWrite: '<S2634>/Dsw_InputAcceltnProf'
     *  Sum: '<S2735>/Sum'
     */
    VeESSR_dn_InputAcceltnProf_DS = (rtb_IntegerDelay -
        VeESSR_n_InputSpeedProfile_DS) / HeESSR_t_MedTEB_dT;

    /* DataStoreWrite: '<S2634>/Dsw_InputSpeedProfile' */
    VeESSR_n_InputSpeedProfile_DS = rtb_IntegerDelay;

    /* Logic: '<S2735>/Logical2' incorporates:
     *  DataStoreWrite: '<S2634>/Dsw_InputSpeedProfile1'
     */
    VeESSR_b_NiDotMaxActive_DS = (rtb_RelationalOperator_ns &&
        rtb_RelationalOperator_dhi);

    /* DataStoreWrite: '<S2634>/Dsw_InputSpeedProfile2' */
    VeESSR_n_TargetSpeed_DS = rtb_Gain1_p;

    /* DataStoreWrite: '<S2634>/Dsw_InputSpeedProfile3' */
    VeESSR_dn_TargetAcceltn_DS = rtb_Sum15;

    /* Outputs for Atomic SubSystem: '<S2735>/Limiter6' */
    /* Logic: '<S2735>/Logical' incorporates:
     *  DataStoreWrite: '<S2634>/Dsw_InputSpeedProfile4'
     *  Logic: '<S2751>/Logical2'
     */
    VeESSR_b_NiDotMinActive_DS = (rtb_Logical2_ep && (!rtb_Logical1_ky));

    /* End of Outputs for SubSystem: '<S2735>/Limiter6' */

    /* DataStoreWrite: '<S2634>/Dsw_STMTmr' incorporates:
     *  Constant: '<S2646>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_STMTmr'
     *  Sum: '<S2634>/Summation1'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Switch: '<S2642>/Switch' incorporates:
     *  Constant: '<S2717>/Calib'
     *  Logic: '<S2642>/Logical1'
     *  Logic: '<S2642>/Logical2'
     */
    if ((rtu_EngAngle720SyncFA || rtu_EngAngle720SyncLrn) ||
            (!KeESSR_b_TrgtAngCntrl))
    {
        /* Switch: '<S2642>/Switch' incorporates:
         *  Constant: '<S2642>/TRUE Constant'
         */
        VeESSR_b_AngleLrnWaitTmPFS = true;
    }
    else
    {
        /* Switch: '<S2642>/Switch' incorporates:
         *  Constant: '<S2718>/Calib'
         *  DataStoreRead: '<S2634>/Dsr_STMTmr7'
         *  RelationalOperator: '<S2642>/Greater  Than'
         */
        VeESSR_b_AngleLrnWaitTmPFS = (VeESSR_t_STMTmr_DS >=
            KeESSR_t_AngleLrnWaitTmPFS);
    }

    /* End of Switch: '<S2642>/Switch' */

    /* Lookup_n-D: '<S2669>/Vector' */
    rtb_Vector_bu = look2_iflf_binlcapw(rtu_TFT, rtu_OAT, ((const float32 *)
        &(KxESSR_t_AuxPumpRunningDelay[0])), ((const float32 *)
        &(KyESSR_t_AuxPumpRunningDelay[0])), ((const float32 *)
        &(KtESSR_t_AuxPumpRunningDelay[0])), ESSR_ac_ConstP.Vector_maxIndex_l,
        4U);

    /* Switch: '<S2670>/Switch' incorporates:
     *  Constant: '<S2727>/Calib'
     *  Logic: '<S2670>/AND1'
     *  Logic: '<S2670>/AND2'
     *  Logic: '<S2670>/AND3'
     */
    if (((KeESSR_b_TrgtAngCntrl) && (!rtu_EngAngle720SyncFA)) &&
            (!rtu_EngAngle720SyncLrn))
    {
        /* Switch: '<S2670>/Switch' incorporates:
         *  Constant: '<S2667>/Calib'
         *  Constant: '<S2728>/Calib'
         *  MinMax: '<S2670>/MinMax1'
         *  Sum: '<S2634>/Summation3'
         */
        VeESSR_t_MaxStTm_PFS = fmaxf(KeESSR_t_AngleLrnWaitTmPFS,
            KeESSR_t_MaxStTmPrepStp + rtb_Vector_bu);
    }
    else
    {
        /* Switch: '<S2670>/Switch' incorporates:
         *  Constant: '<S2667>/Calib'
         *  Sum: '<S2634>/Summation3'
         */
        VeESSR_t_MaxStTm_PFS = KeESSR_t_MaxStTmPrepStp + rtb_Vector_bu;
    }

    /* End of Switch: '<S2670>/Switch' */

    /* Logic: '<S2639>/Logical Operator13' incorporates:
     *  DataStoreRead: '<S2634>/Dsr_STMTmr4'
     *  RelationalOperator: '<S2634>/Greater  Than1'
     */
    rtb_RelationalOperator_ns = (VeESSR_t_STMTmr_DS > VeESSR_t_MaxStTm_PFS);

    /* Logic: '<S2639>/AND4' incorporates:
     *  Constant: '<S2701>/Calib'
     *  Logic: '<S2639>/Logical Operator17'
     *  Logic: '<S2639>/Logical Operator18'
     */
    rtb_Logical2_ep = ((!KeESSD_b_P1C68_PFS_Enbl) && rtb_RelationalOperator_ns);

    /* Logic: '<S2639>/AND3' incorporates:
     *  Constant: '<S2702>/Calib'
     *  Constant: '<S2705>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_STMTmr3'
     *  DataStoreRead: '<S2634>/Dsr_STMTmr6'
     *  DataStoreRead: '<S2639>/Dsr_InputSpeedProfile1'
     *  Logic: '<S2639>/Logical Operator12'
     *  RelationalOperator: '<S2639>/Comparison2'
     *  RelationalOperator: '<S2639>/Less  Than4'
     *  Sum: '<S2639>/Summation1'
     */
    rtb_RelationalOperator_dhi = ((VeESSR_n_InputSpeedProfile_DS <=
        (VeESSR_n_TgtIdleSpd_DS + KeESSR_n_PFS_ProfTgtTol)) ||
        ((VeESSR_t_STMTmr_DS > KeESSR_t_PFS_ProfTgtTm) || rtb_Logical2_ep));

    /* Switch: '<S2708>/Switch1' incorporates:
     *  Constant: '<S2697>/Constant Value2'
     *  Constant: '<S2707>/Calib'
     *  Constant: '<S2709>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_STMTmr6'
     *  DataStoreRead: '<S2697>/Dsr_EngIdleTm'
     *  DataStoreWrite: '<S2697>/Dsw_EngIdleTm'
     *  RelationalOperator: '<S2697>/Less  Than1'
     *  Sum: '<S2697>/Sum'
     *  Sum: '<S2697>/Summation3'
     */
    if (rtu_TransInSpdFlt <= (VeESSR_n_TgtIdleSpd_DS +
                              KeESSR_n_PrepStopTargIdleDB))
    {
        VeESSR_t_EngIdleTm_DS = VeESSR_t_EngIdleTm_DS + HeESSR_t_MedTEB_dT;
    }
    else
    {
        VeESSR_t_EngIdleTm_DS = 0.0F;
    }

    /* End of Switch: '<S2708>/Switch1' */

    /* Logic: '<S2639>/AND4' incorporates:
     *  Constant: '<S2706>/Calib'
     *  Constant: '<S2710>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_STMTmr3'
     *  DataStoreWrite: '<S2697>/Dsw_EngIdleTm'
     *  Logic: '<S2639>/Logical Operator26'
     *  RelationalOperator: '<S2639>/Comparison3'
     *  RelationalOperator: '<S2697>/Less  Than3'
     */
    rtb_Logical2_ep = ((rtb_Logical2_ep || (VeESSR_t_STMTmr_DS >
                         KeESSR_t_PFS_SpdTgtTm)) || (VeESSR_t_EngIdleTm_DS >
                        KeESSR_t_MinEngIdleTm));

    /* Logic: '<S2639>/Logical Operator8' incorporates:
     *  Constant: '<S2704>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_STMTmr3'
     *  DataStoreRead: '<S2639>/Dsr_InputSpeedProfile2'
     *  Logic: '<S2639>/AND1'
     *  Logic: '<S2639>/Logical Operator16'
     *  RelationalOperator: '<S2639>/Less  Than'
     *  RelationalOperator: '<S2639>/Less  Than2'
     */
    rtb_LogicalOperator8_i = ((rtu_EngCapacityMinRunImmed <
        VeESSR_M_EngTrqReqImmed_DS) || ((VeESSR_t_STMTmr_DS >
        KeESSR_t_MaxTmEngCapMinRunImmedDecay) || rtb_RelationalOperator_ns));

    /* Logic: '<S2639>/Logical Operator9' incorporates:
     *  Constant: '<S2698>/Constant'
     *  Constant: '<S2703>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_STMTmr3'
     *  Logic: '<S2639>/AND2'
     *  Logic: '<S2639>/Logical Operator19'
     *  RelationalOperator: '<S2639>/Comparison1'
     *  RelationalOperator: '<S2639>/Comparison4'
     */
    rtb_LogicalOperator9_l = ((((uint32)rtu_CylinderDeacMode) ==
        CeENGR_e_AllCylindersActive) || ((VeESSR_t_STMTmr_DS >
        KeESSR_t_AStopAllCylWaitTm) || rtb_RelationalOperator_ns));

    /* Logic: '<S2639>/Logical Operator10' incorporates:
     *  Constant: '<S2634>/Constant Value2'
     *  DataStoreWrite: '<S2634>/Dsw_EngTrqReqPrdtd'
     *  Logic: '<S2639>/Logical Operator15'
     *  RelationalOperator: '<S2634>/Comparison3'
     *  Sum: '<S2634>/Sum1'
     */
    rtb_LogicalOperator10_a = (((VeESSR_M_EngTrqReqPrdtd_DS - rtb_Gain_d) <=
        10.0F) || rtb_RelationalOperator_ns);

    /* Logic: '<S2639>/Logical Operator11' incorporates:
     *  Constant: '<S2634>/Constant Value2'
     *  DataStoreWrite: '<S2634>/Dsw_EngTrqReqImmed'
     *  Logic: '<S2639>/Logical Operator14'
     *  RelationalOperator: '<S2634>/Comparison1'
     *  Sum: '<S2634>/Sum2'
     */
    rtb_LogicalOperator11_n = (rtb_RelationalOperator_ns ||
        ((VeESSR_M_EngTrqReqImmed_DS - rtb_MinMax3_d) <= 10.0F));

    /* If: '<S2679>/If' incorporates:
     *  Constant: '<S2638>/Constant Value5'
     *  Constant: '<S2684>/Calib'
     *  Lookup_n-D: '<S2685>/Vector'
     */
    if (KeESSR_b_EngStpProfUseAngAdpt)
    {
        /* Outputs for IfAction SubSystem: '<S2679>/UsingAdapt' incorporates:
         *  ActionPort: '<S2688>/Action Port'
         */
        ESSR_ac_UsingAdapt(look1_iflf_binlcapw(0.0F, ((const float32 *)
                             &(KxESSR_k_EngStpAngleFactor[0])), ((const float32 *)
                             &(KtESSR_k_EngStpAngleFactor[0])), 40U),
                           &rtb_Merge_hk, rtd_NeESSR_k_EngStpProfAngAdpt);

        /* End of Outputs for SubSystem: '<S2679>/UsingAdapt' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2679>/PassThrough' incorporates:
         *  ActionPort: '<S2687>/Action Port'
         */
        ESSR_ac_PassThrough(look1_iflf_binlcapw(0.0F, ((const float32 *)
                              &(KxESSR_k_EngStpAngleFactor[0])), ((const float32
                               *)&(KtESSR_k_EngStpAngleFactor[0])), 40U),
                            &rtb_Merge_hk);

        /* End of Outputs for SubSystem: '<S2679>/PassThrough' */
    }

    /* End of If: '<S2679>/If' */

    /* Merge: '<S2721>/Merge' incorporates:
     *  Constant: '<S2638>/Constant Value1'
     *  Constant: '<S2638>/RPM2DegPerSec'
     *  Constant: '<S2680>/Calib'
     *  Constant: '<S2681>/Calib'
     *  Constant: '<S2682>/Calib'
     *  DataStoreRead: '<S2638>/Dsr_InputSpeedProfile1'
     *  Product: '<S2638>/Multiplication'
     *  Product: '<S2638>/Multiplication1'
     *  Product: '<S2683>/Division'
     *  Sum: '<S2638>/Subtraction'
     */
    rtb_Merge_hk = (((KeESSR_phi_EngStpTgtAngle - (rtb_Merge_hk *
                       VeESSR_n_InputSpeedProfile_DS)) -
                     ((VeESSR_n_InputSpeedProfile_DS * KeESSR_t_ProfRmpStrtDelay)
                      * 6.0F)) - KeESSR_phi_FuelBurnOutAngle) / 720.0F;

    /* Product: '<S2683>/Multiplication' incorporates:
     *  Constant: '<S2638>/Constant Value1'
     *  DataStoreWrite: '<S2638>/Dsw_EngStrtStpMd1'
     *  Rounding: '<S2683>/Floor'
     *  Sum: '<S2683>/Subtraction'
     */
    VeESSR_phi_EngStpRmpDwnStrtAng_DS = (rtb_Merge_hk - floorf(rtb_Merge_hk)) *
        720.0F;

    /* Sum: '<S2643>/Subtraction4' incorporates:
     *  Constant: '<S2643>/Constant Value1'
     *  DataStoreWrite: '<S2638>/Dsw_EngStrtStpMd1'
     *  Sum: '<S2643>/Subtraction3'
     *  UnitDelay: '<S2634>/Unit Delay'
     */
    rtb_MinMax3_d = (720.0F - localDW->UnitDelay_DSTATE_n) +
        VeESSR_phi_EngStpRmpDwnStrtAng_DS;

    /* If: '<S2721>/If' */
    if (rtb_MinMax3_d <= 720.0F)
    {
        /* Outputs for IfAction SubSystem: '<S2721>/PassThrough' incorporates:
         *  ActionPort: '<S2723>/Action Port'
         */
        ESSR_ac_PassThrough(rtb_MinMax3_d, &rtb_Merge_hk);

        /* End of Outputs for SubSystem: '<S2721>/PassThrough' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2721>/Subtract720' incorporates:
         *  ActionPort: '<S2724>/Action Port'
         */
        ESSR_ac_Subtract720(rtb_MinMax3_d, &rtb_Merge_hk);

        /* End of Outputs for SubSystem: '<S2721>/Subtract720' */
    }

    /* End of If: '<S2721>/If' */

    /* Sum: '<S2643>/Subtraction2' incorporates:
     *  Constant: '<S2643>/Constant Value2'
     *  DataStoreWrite: '<S2638>/Dsw_EngStrtStpMd1'
     *  Sum: '<S2643>/Subtraction1'
     */
    rtb_MinMax3_d = (720.0F - rtu_EngAng720Est) +
        VeESSR_phi_EngStpRmpDwnStrtAng_DS;

    /* If: '<S2722>/If' */
    if (rtb_MinMax3_d <= 720.0F)
    {
        /* Outputs for IfAction SubSystem: '<S2722>/PassThrough' incorporates:
         *  ActionPort: '<S2725>/Action Port'
         */
        ESSR_ac_PassThrough(rtb_MinMax3_d, &rtb_Gain_d);

        /* End of Outputs for SubSystem: '<S2722>/PassThrough' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2722>/Subtract720' incorporates:
         *  ActionPort: '<S2726>/Action Port'
         */
        ESSR_ac_Subtract720(rtb_MinMax3_d, &rtb_Gain_d);

        /* End of Outputs for SubSystem: '<S2722>/Subtract720' */
    }

    /* End of If: '<S2722>/If' */

    /* Logic: '<S2634>/Logical1' incorporates:
     *  Constant: '<S2643>/Constant Value'
     *  Constant: '<S2643>/Constant Value3'
     *  Constant: '<S2643>/Constant Value4'
     *  Constant: '<S2643>/Constant Value5'
     *  Constant: '<S2666>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_STMTmr2'
     *  Logic: '<S2634>/Logical Operator17'
     *  Logic: '<S2643>/Logical'
     *  Logic: '<S2643>/Logical1'
     *  RelationalOperator: '<S2634>/Greater  Than2'
     *  RelationalOperator: '<S2643>/Comparison1'
     *  RelationalOperator: '<S2643>/Comparison2'
     *  RelationalOperator: '<S2643>/Comparison3'
     *  RelationalOperator: '<S2643>/Comparison4'
     */
    rtb_Logical1_fj = ((((rtb_Merge_hk == 0.0F) || (rtb_Gain_d == 0.0F)) ||
                        ((rtb_Merge_hk <= 360.0F) && (rtb_Gain_d > 360.0F))) ||
                       ((VeESSR_t_STMTmr_DS > KeESSR_t_MaxAngleWaitTm) ||
                        rtb_RelationalOperator_ns));

    /* Logic: '<S2634>/AND3' incorporates:
     *  Constant: '<S2653>/Calib'
     */
    VeESSR_b_AuxPumpRunning = (rtu_AuxPumpRunning || (KeESSR_b_AuxPumpRunEnbl));

    /* Logic: '<S2639>/Logical Operator7' incorporates:
     *  Logic: '<S2634>/Logical6'
     */
    rtb_LogicalOperator7_f = (rtu_EngOnReq && rtu_AStopEngCOMLmp);

    /* Sum: '<S2634>/Sum3' incorporates:
     *  DataStoreRead: '<S2634>/Dsr_EngTrqReqImmed3'
     */
    VeESSR_M_CoMTrqDelta = rtu_OptInputTorq - VeESSR_M_EngTrqReqImmed_DS;

    /* Logic: '<S2639>/Logical1' incorporates:
     *  Constant: '<S2650>/Calib'
     *  RelationalOperator: '<S2634>/Greater  Than3'
     */
    rtb_Logical1_ky = (VeESSR_M_CoMTrqDelta > KeESSR_M_CoMTrqDeltaMax);

    /* Logic: '<S2634>/AND5' */
    rtb_AND5_oc = (rtb_LogicalOperator7_f && rtb_Logical1_ky);

    /* Logic: '<S2639>/Logical Operator7' incorporates:
     *  Constant: '<S2652>/Calib'
     *  Constant: '<S2665>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_STMTmr1'
     *  Logic: '<S2634>/AND'
     *  Logic: '<S2634>/AND1'
     *  Logic: '<S2634>/AND2'
     *  Logic: '<S2634>/Logical2'
     *  RelationalOperator: '<S2634>/Greater  Than'
     *  Sum: '<S2634>/Summation2'
     */
    rtb_LogicalOperator7_f = (((((!VeESSR_b_AuxPumpRunning) &&
        (VeESSR_t_STMTmr_DS > (KeESSR_t_AuxPumpWaitTm + rtb_Vector_bu))) ||
        rtu_EngOnReq) || rtb_LogicalOperator7_f) && (KeESSR_b_AllowStopAbrtsPFS));

    /* If: '<S2634>/If1' incorporates:
     *  Constant: '<S2645>/Constant'
     *  Constant: '<S2668>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_STMTmr8'
     *  Logic: '<S2634>/AND4'
     *  Logic: '<S2634>/AND6'
     *  Logic: '<S2634>/Logical3'
     *  Logic: '<S2634>/OR2'
     *  Logic: '<S2639>/AND'
     *  RelationalOperator: '<S2634>/Comparison2'
     *  RelationalOperator: '<S2634>/Greater  Than4'
     */
    if (((((uint32)rtu_VeINVR_e_MtrA_InvrtrSt) == CeINVR_e_InverterFaulted) &&
            (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmPrepStpMtrAFlt)) ||
            ((((VeESSR_b_AngleLrnWaitTmPFS) && (((((rtb_RelationalOperator_dhi &&
                rtb_Logical2_ep) && rtb_LogicalOperator8_i) &&
              rtb_LogicalOperator9_l) && rtb_LogicalOperator10_a) &&
            rtb_LogicalOperator11_n)) && rtb_Logical1_fj) &&
             (VeESSR_b_AuxPumpRunning)))
    {
        /* Outputs for IfAction SubSystem: '<S2634>/NormExit' incorporates:
         *  ActionPort: '<S2671>/Action Port'
         */
        /* DataStoreWrite: '<S2634>/Dsw_STMTrigger1' incorporates:
         *  Constant: '<S2729>/Constant'
         *  Merge: '<S2634>/Merge1'
         *  SignalConversion generated from: '<S2671>/Out1'
         */
        VeESSR_e_STMTrigger_DS = CeESSR_e_IdlePumpDwnAch;

        /* End of Outputs for SubSystem: '<S2634>/NormExit' */
    }
    else if (rtb_AND5_oc)
    {
        /* Outputs for IfAction SubSystem: '<S2634>/Restart1' incorporates:
         *  ActionPort: '<S2673>/Action Port'
         */
        /* DataStoreWrite: '<S2673>/Dsw_EngRestartReq' incorporates:
         *  Constant: '<S2673>/TRUE Constant'
         */
        VeESSR_b_LmtP1fRestartReq_DS = true;

        /* DataStoreWrite: '<S2634>/Dsw_STMTrigger1' incorporates:
         *  Constant: '<S2731>/Constant'
         *  Merge: '<S2634>/Merge1'
         *  SignalConversion generated from: '<S2673>/Out1'
         */
        VeESSR_e_STMTrigger_DS = CeESSR_e_StartReq;

        /* End of Outputs for SubSystem: '<S2634>/Restart1' */
    }
    else if (rtb_LogicalOperator7_f && rtb_Logical1_ky)
    {
        /* Outputs for IfAction SubSystem: '<S2634>/RestartExit' incorporates:
         *  ActionPort: '<S2674>/Action Port'
         */
        /* DataStoreWrite: '<S2674>/Dsw_EngRestartReq' incorporates:
         *  Constant: '<S2674>/TRUE Constant'
         */
        VeESSR_b_PFSRunReq_DS = true;

        /* DataStoreWrite: '<S2634>/Dsw_STMTrigger1' incorporates:
         *  Constant: '<S2732>/Constant'
         *  Merge: '<S2634>/Merge1'
         *  SignalConversion generated from: '<S2674>/Out1'
         */
        VeESSR_e_STMTrigger_DS = CeESSR_e_StartReq;

        /* End of Outputs for SubSystem: '<S2634>/RestartExit' */
    }
    else if (rtb_LogicalOperator7_f)
    {
        /* Outputs for IfAction SubSystem: '<S2634>/BackToRun' incorporates:
         *  ActionPort: '<S2637>/Action Port'
         */
        /* DataStoreWrite: '<S2634>/Dsw_STMTrigger1' incorporates:
         *  Constant: '<S2678>/Constant'
         *  Merge: '<S2634>/Merge1'
         *  SignalConversion generated from: '<S2637>/Out1'
         */
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngRun;

        /* End of Outputs for SubSystem: '<S2634>/BackToRun' */
    }
    else
    {
        if (rtb_RelationalOperator_ns)
        {
            /* Outputs for IfAction SubSystem: '<S2634>/OffFail' incorporates:
             *  ActionPort: '<S2672>/Action Port'
             */
            /* DataStoreWrite: '<S2634>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S2730>/Constant'
             *  Merge: '<S2634>/Merge1'
             *  SignalConversion generated from: '<S2672>/Out1'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

            /* End of Outputs for SubSystem: '<S2634>/OffFail' */
        }
    }

    /* End of If: '<S2634>/If1' */

    /* Logic: '<S2639>/Logical1' incorporates:
     *  Logic: '<S2639>/Logical Operator'
     *  Logic: '<S2639>/Logical Operator6'
     */
    rtb_Logical1_ky = ((!rtb_RelationalOperator_dhi) &&
                       rtb_RelationalOperator_ns);

    /* Switch: '<S2639>/Switch' incorporates:
     *  S-Function (sfix_bitop): '<S2689>/FixPt Bitwise Operator1'
     */
    if (rtb_Logical1_ky)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 1024U;
    }

    /* End of Switch: '<S2639>/Switch' */

    /* Logic: '<S2639>/Logical Operator7' incorporates:
     *  Logic: '<S2639>/Logical Operator1'
     */
    rtb_LogicalOperator7_f = ((!rtb_Logical2_ep) && rtb_RelationalOperator_ns);

    /* Switch: '<S2639>/Switch2' incorporates:
     *  S-Function (sfix_bitop): '<S2690>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator7_f)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 2048U;
    }

    /* End of Switch: '<S2639>/Switch2' */

    /* Logic: '<S2639>/Logical Operator8' incorporates:
     *  Logic: '<S2639>/Logical Operator2'
     */
    rtb_LogicalOperator8_i = ((!rtb_LogicalOperator8_i) &&
        rtb_RelationalOperator_ns);

    /* Switch: '<S2639>/Switch4' incorporates:
     *  S-Function (sfix_bitop): '<S2691>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator8_i)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 4096U;
    }

    /* End of Switch: '<S2639>/Switch4' */

    /* Logic: '<S2639>/Logical Operator9' incorporates:
     *  Logic: '<S2639>/Logical Operator3'
     */
    rtb_LogicalOperator9_l = ((!rtb_LogicalOperator9_l) &&
        rtb_RelationalOperator_ns);

    /* Switch: '<S2639>/Switch6' incorporates:
     *  S-Function (sfix_bitop): '<S2692>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator9_l)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 8192U;
    }

    /* End of Switch: '<S2639>/Switch6' */

    /* Logic: '<S2639>/Logical Operator10' incorporates:
     *  Logic: '<S2639>/Logical Operator4'
     */
    rtb_LogicalOperator10_a = ((!rtb_LogicalOperator10_a) &&
        rtb_RelationalOperator_ns);

    /* Switch: '<S2639>/Switch8' incorporates:
     *  S-Function (sfix_bitop): '<S2693>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator10_a)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 16384U;
    }

    /* End of Switch: '<S2639>/Switch8' */

    /* Logic: '<S2639>/Logical Operator11' incorporates:
     *  Logic: '<S2639>/Logical Operator5'
     */
    rtb_LogicalOperator11_n = ((!rtb_LogicalOperator11_n) &&
        rtb_RelationalOperator_ns);

    /* Switch: '<S2639>/Switch10' incorporates:
     *  S-Function (sfix_bitop): '<S2694>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator11_n)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 32768U;
    }

    /* End of Switch: '<S2639>/Switch10' */

    /* Logic: '<S2639>/Logical Operator13' incorporates:
     *  Logic: '<S2634>/Logical Operator12'
     */
    rtb_RelationalOperator_ns = ((!rtb_Logical1_fj) && rtb_RelationalOperator_ns);

    /* Switch: '<S2639>/Switch12' incorporates:
     *  S-Function (sfix_bitop): '<S2695>/FixPt Bitwise Operator1'
     */
    if (rtb_RelationalOperator_ns)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 65536U;
    }

    /* End of Switch: '<S2639>/Switch12' */

    /* Logic: '<S2639>/Logical1' */
    rtb_Logical1_ky = (rtb_Logical1_ky || rtb_LogicalOperator7_f);

    /* If: '<S2639>/If' */
    if (rtb_Logical1_ky)
    {
        /* Outputs for IfAction SubSystem: '<S2639>/If_PrepForStop_P1C68' incorporates:
         *  ActionPort: '<S2700>/Action Port'
         */
        /* DataStoreWrite: '<S2639>/Dsw_StrtStpFailDTC' incorporates:
         *  Constant: '<S2712>/Constant'
         *  Merge: '<S2639>/Merge'
         *  SignalConversion generated from: '<S2700>/Out1'
         */
        VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C68;

        /* End of Outputs for SubSystem: '<S2639>/If_PrepForStop_P1C68' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2639>/If_PrepForStop_NoFault' incorporates:
         *  ActionPort: '<S2699>/Action Port'
         */
        /* DataStoreWrite: '<S2639>/Dsw_StrtStpFailDTC' */
        ESSR_ac_If_AutoStrt_NoFault((&(VeESSR_e_StrtStpFailDTC)));

        /* End of Outputs for SubSystem: '<S2639>/If_PrepForStop_NoFault' */
    }

    /* End of If: '<S2639>/If' */

    /* Switch: '<S2639>/Switch1' incorporates:
     *  Constant: '<S2639>/Constant Value2'
     *  DataStoreRead: '<S2639>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S2639>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S2639>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S2639>/Logical2'
     *  Logic: '<S2639>/Logical21'
     *  Logic: '<S2639>/Logical3'
     *  RelationalOperator: '<S2639>/Comparison'
     *  S-Function (sfix_bitop): '<S2639>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S2696>/FixPt Bitwise Operator1'
     */
    if (((((rtb_Logical1_ky || rtb_LogicalOperator8_i) || rtb_LogicalOperator9_l)
          || (rtb_LogicalOperator10_a || rtb_LogicalOperator11_n)) ||
            rtb_RelationalOperator_ns) && ((VeESSR_g_StrtStpFailPhaseSelect_DS &
          65536U) > 0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 65536U;
    }

    /* End of Switch: '<S2639>/Switch1' */

    /* DataStoreWrite: '<S2634>/Dsw_InputTorqEst' incorporates:
     *  Constant: '<S2649>/Calib'
     *  DataStoreRead: '<S2634>/Dsr_InputTorqEst'
     *  Product: '<S2636>/Multiplication'
     *  Sum: '<S2636>/Subtraction'
     *  Sum: '<S2636>/Subtraction1'
     */
    VeESSR_M_EngTorqEst_DS = ((rtu_EngTrqActual - VeESSR_M_EngTorqEst_DS) *
        KeESSR_K_TiEstBlndPrepStp) + VeESSR_M_EngTorqEst_DS;

    /* Sum: '<S2735>/Sum17' incorporates:
     *  DataStoreWrite: '<S2634>/Dsw_InputAcceltnProf'
     */
    VeESSR_dn_InputJerkProfPrepStop = VeESSR_dn_InputAcceltnProf_DS -
        rtb_Gain_o5;

    /* Switch: '<S2676>/Switch3' */
    if (rtb_Comparison_ci)
    {
        /* Update for UnitDelay: '<S2676>/Unit Delay' */
        localDW->UnitDelay_DSTATE = rtb_Abs_k3;
    }
    else
    {
        /* Update for UnitDelay: '<S2676>/Unit Delay' */
        localDW->UnitDelay_DSTATE = rtb_Sum_p5;
    }

    /* End of Switch: '<S2676>/Switch3' */

    /* Update for UnitDelay: '<S2754>/Unit Delay' incorporates:
     *  Switch: '<S2754>/Switch3'
     */
    localDW->UnitDelay_DSTATE_g = rtb_Sum_dj;

    /* Update for Delay: '<S2735>/IntegerDelay' */
    localDW->icLoad = 0U;
    for (i = 0; i < 15; i++)
    {
        localDW->IntegerDelay_DSTATE[i] = localDW->IntegerDelay_DSTATE[i + 1];
    }

    localDW->IntegerDelay_DSTATE[15] = rtb_Gain1_p;

    /* End of Update for Delay: '<S2735>/IntegerDelay' */

    /* Update for UnitDelay: '<S2634>/Unit Delay' */
    localDW->UnitDelay_DSTATE_n = rtu_EngAng720Est;
}

#endif

/* Output and update for function-call system: '<S2447>/DisableFuelEnt' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_DisableFuelEnt(void)
{
    /* DataStoreWrite: '<S2452>/Dsw_InputAcceltnProf' incorporates:
     *  Constant: '<S2452>/Constant Value1'
     */
    VeESSR_dn_InputAcceltnProf_DS = 0.0F;

    /* Switch: '<S2452>/Switch3' incorporates:
     *  Constant: '<S2452>/Constant Value2'
     *  Constant: '<S2556>/Calib'
     *  DataStoreWrite: '<S2452>/Data Store Write3'
     */
    if (!HeESSR_b_EngStrtTorq)
    {
        VeESSR_M_EngStrtTorq_DS = 0.0F;
    }

    /* End of Switch: '<S2452>/Switch3' */

    /* Switch: '<S2452>/Switch1' incorporates:
     *  Constant: '<S2452>/FALSE Constant2'
     *  Constant: '<S2553>/Constant'
     *  Constant: '<S2555>/Calib'
     *  DataStoreWrite: '<S2452>/Dsw_Dsbl_ICSRFor12vStart'
     *  DataStoreWrite: '<S2452>/Dsw_EngCntrlMode_DS'
     *  Switch: '<S2452>/Switch'
     */
    if (HeESSR_b_EngStpEnbNiTrqMd)
    {
        VeESSR_b_DsblNiClsdLoopCntrl_DS = false;
        VeESSR_e_EngCntrlMode_DS = CeTRAR_e_TorqueMode;
    }

    /* End of Switch: '<S2452>/Switch1' */

    /* DataStoreWrite: '<S2452>/Data Store Write' incorporates:
     *  Constant: '<S2452>/FALSE Constant'
     */
    VeESSR_b_DSO2Mon_Enbld_DS = false;

    /* DataStoreWrite: '<S2452>/Data Store Write1' incorporates:
     *  Constant: '<S2452>/FALSE Constant1'
     */
    VeESSR_b_DSO2Mon_Cmplt_DS = false;

    /* MinMax: '<S2452>/MinMax1' incorporates:
     *  DataStoreRead: '<S2452>/VeESSR_e_StrtStpTypEngTorqRespType_DS'
     *  DataStoreRead: '<S2452>/VeESSR_e_StrtStpTypEngTorqRespType_DS1'
     *  DataTypeConversion: '<S2452>/Data Type Conversion1'
     *  DataTypeConversion: '<S2452>/Data Type Conversion2'
     */
    if (VeESSR_e_StrtStpTypEngTorqRespType_DS > VeESSR_e_EngTrqRespType_DS)
    {
        /* DataTypeConversion: '<S2551>/DataTypeConversion' incorporates:
         *  DataStoreWrite: '<S2452>/Dsw_EngTrqRespType'
         */
        VeESSR_e_EngTrqRespType_DS = VeESSR_e_StrtStpTypEngTorqRespType_DS;
    }
    else
    {
        /* DataTypeConversion: '<S2551>/DataTypeConversion' incorporates:
         *  DataStoreWrite: '<S2452>/Dsw_EngTrqRespType'
         */
        VeESSR_e_EngTrqRespType_DS = VeESSR_e_EngTrqRespType_DS;
    }

    /* End of MinMax: '<S2452>/MinMax1' */

    /* DataStoreWrite: '<S2452>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
     *  Constant: '<S2557>/Calib'
     */
    VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

    /* DataStoreWrite: '<S2452>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
     *  Constant: '<S2558>/Calib'
     */
    VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

    /* DataStoreWrite: '<S2452>/Dsw_EngStartStopSt' incorporates:
     *  Constant: '<S2550>/Constant'
     */
    VeESSR_e_EngStartStopSt_DS = CeESSR_e_DisableFuelSt;

    /* DataStoreWrite: '<S2452>/Dsw_EngStrtStpMd2' incorporates:
     *  Constant: '<S2560>/Calib'
     */
    VeESSR_e_EngStrtStpMd_DS = KeESSR_e_MdInDisFuelSt;

    /* DataStoreWrite: '<S2452>/Dsw_EngStrtType1' incorporates:
     *  Constant: '<S2561>/Calib'
     */
    VeESSR_e_TCM_StartStopType_DS = KeESSR_e_TCM_StartStopType_DsblFuel;

    /* DataStoreWrite: '<S2452>/Dsw_EngStrtType2' incorporates:
     *  Constant: '<S2554>/Constant'
     */
    VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_PrepStop;

    /* DataStoreWrite: '<S2452>/Dsw_InhibitShiftToMode' incorporates:
     *  Constant: '<S2559>/Calib'
     */
    VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtDisFuelSt;

    /* DataStoreWrite: '<S2452>/Dsw_InputSpeedProfile1' incorporates:
     *  Constant: '<S2563>/Calib'
     */
    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

    /* DataStoreWrite: '<S2452>/Dsw_StrtStpFailDTC' incorporates:
     *  Constant: '<S2552>/Constant'
     */
    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

    /* DataStoreWrite: '<S2452>/Dsw_TransFldPmpSel' incorporates:
     *  Constant: '<S2562>/Calib'
     */
    VeESSR_e_TransFldPmpSel_DS = KeESSR_e_TransFldPmpSelDisableFuelSt;
}

#endif

/*
 * Output and update for action system:
 *    '<S2451>/If_DisableFuel_NoFault'
 *    '<S2799>/If_RampDown_NoFault'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_If_DisableFuel_NoFault(void)
{
    /* DataStoreWrite: '<S2466>/Dsw_StrtStpFailDTC' incorporates:
     *  Constant: '<S2545>/Constant'
     */
    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
}

#endif

/*
 * Output and update for action system:
 *    '<S2451>/Restart1'
 *    '<S2799>/Restart1'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Restart1(void)
{
    /* DataStoreWrite: '<S2476>/Dsw_STMTrigger' incorporates:
     *  Constant: '<S2548>/Constant'
     */
    VeESSR_e_STMTrigger_DS = CeESSR_e_StartReq;

    /* DataStoreWrite: '<S2476>/Dsw_EngRestartReq' incorporates:
     *  Constant: '<S2476>/TRUE Constant'
     */
    VeESSR_b_LmtP1fRestartReq_DS = true;
}

#endif

/* Output and update for function-call system: '<S2447>/DisableFuelDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_DisableFuelDur(VAR(float32, AUTOMATIC)
    rtu_EngTrqActual, VAR(boolean, AUTOMATIC) rtu_EngOnReq, VAR(float32,
    AUTOMATIC) rtu_EngAng720Est, VAR(TeENGR_e_Cam_Phsr_Stat, AUTOMATIC)
    rtu_CamPhaserStat, VAR(TeENGR_e_EngDFSO_St, AUTOMATIC) rtu_EngDFSO_Req, VAR
    (boolean, AUTOMATIC) rtu_EngTLCLearnReq, VAR(float32, AUTOMATIC)
    rtu_EngCapacityMinRunImmed, VAR(boolean, AUTOMATIC) rtu_EngCmbstCmnd, VAR
    (float32, AUTOMATIC) rtu_TransInSpdFlt, VAR(float32, AUTOMATIC)
    rtu_EngCapacityMinOff, VAR(float32, AUTOMATIC) rtu_EngAngle720Sync, VAR
    (boolean, AUTOMATIC) rtu_EngAngle720SyncFA, VAR(boolean, AUTOMATIC)
    rtu_EngAngle720SyncLrn, VAR(boolean, AUTOMATIC) rtu_AStopEngCOMLmp, P2VAR
    (DW_DisableFuelDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW, P2VAR
    (uint32, AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_g_StrtStpFailRsn, P2VAR
    (float32, AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_k_EngStpProfAngAdpt)
{
    float32 rtb_Merge_g1;
    float32 rtb_Merge_ow_tmp;
    float32 rtb_Subtraction2_f;
    float32 rtb_Subtraction4_l;
    boolean rtb_AND2_ca;
    boolean rtb_AND4_o;
    boolean rtb_GreaterThan_l3;
    boolean rtb_Logical1_c4;
    boolean rtb_Logical2_ks;
    boolean rtb_Logical2_ps;
    boolean rtb_LogicalOperator2_ck;
    boolean rtb_LogicalOperator4_b;
    boolean rtb_LogicalOperator7_kc;

    /* RelationalOperator: '<S2451>/Greater  Than' incorporates:
     *  Constant: '<S2473>/Calib'
     *  DataStoreRead: '<S2451>/Dsr_STMTmr1'
     */
    rtb_GreaterThan_l3 = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmDsblFuel);

    /* Logic: '<S2461>/Logical2' incorporates:
     *  Constant: '<S2485>/Constant'
     *  Constant: '<S2490>/Calib'
     *  DataStoreRead: '<S2461>/Dsr_STMTmr4'
     *  Logic: '<S2461>/Logical Operator10'
     *  RelationalOperator: '<S2461>/Greater  Than3'
     *  RelationalOperator: '<S2461>/Greater  Than4'
     */
    rtb_Logical2_ps = ((((uint32)rtu_CamPhaserStat) == CeENGR_e_AllPhasersParked)
                       || ((VeESSR_t_STMTmr_DS > KeESSR_t_StopPhsrPrkMaxTm) ||
                           rtb_GreaterThan_l3));

    /* Logic: '<S2451>/Logical Operator7' incorporates:
     *  Logic: '<S2461>/Logical Operator'
     */
    rtb_LogicalOperator7_kc = ((!rtb_Logical2_ps) && rtb_GreaterThan_l3);

    /* Switch: '<S2451>/Switch' incorporates:
     *  S-Function (sfix_bitop): '<S2455>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator7_kc)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 131072U;
    }

    /* End of Switch: '<S2451>/Switch' */

    /* If: '<S2492>/If' incorporates:
     *  Constant: '<S2481>/Constant Value5'
     *  Constant: '<S2496>/Calib'
     *  Lookup_n-D: '<S2497>/Vector'
     */
    if (KeESSR_b_EngStpProfUseAngAdpt)
    {
        /* Outputs for IfAction SubSystem: '<S2492>/UsingAdapt' incorporates:
         *  ActionPort: '<S2500>/Action Port'
         */
        ESSR_ac_UsingAdapt(look1_iflf_binlcapw(0.0F, ((const float32 *)
                             &(KxESSR_k_EngStpAngleFactor[0])), ((const float32 *)
                             &(KtESSR_k_EngStpAngleFactor[0])), 40U),
                           &rtb_Merge_g1, rtd_NeESSR_k_EngStpProfAngAdpt);

        /* End of Outputs for SubSystem: '<S2492>/UsingAdapt' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2492>/PassThrough' incorporates:
         *  ActionPort: '<S2499>/Action Port'
         */
        ESSR_ac_PassThrough(look1_iflf_binlcapw(0.0F, ((const float32 *)
                              &(KxESSR_k_EngStpAngleFactor[0])), ((const float32
                               *)&(KtESSR_k_EngStpAngleFactor[0])), 40U),
                            &rtb_Merge_g1);

        /* End of Outputs for SubSystem: '<S2492>/PassThrough' */
    }

    /* End of If: '<S2492>/If' */

    /* Product: '<S2481>/Multiplication1' incorporates:
     *  Constant: '<S2481>/RPM2DegPerSec'
     *  Constant: '<S2494>/Calib'
     *  DataStoreRead: '<S2481>/Dsr_InputSpeedProfile1'
     *  Product: '<S2524>/Multiplication1'
     */
    rtb_Merge_ow_tmp = (VeESSR_n_InputSpeedProfile_DS *
                        KeESSR_t_ProfRmpStrtDelay) * 6.0F;

    /* Merge: '<S2535>/Merge' incorporates:
     *  Constant: '<S2481>/Constant Value1'
     *  Constant: '<S2493>/Calib'
     *  DataStoreRead: '<S2481>/Dsr_InputSpeedProfile1'
     *  Product: '<S2481>/Multiplication'
     *  Product: '<S2481>/Multiplication1'
     *  Product: '<S2495>/Division'
     *  Sum: '<S2481>/Subtraction'
     */
    rtb_Merge_g1 = ((KeESSR_phi_EngStpTgtAngle - (rtb_Merge_g1 *
                      VeESSR_n_InputSpeedProfile_DS)) - rtb_Merge_ow_tmp) /
        720.0F;

    /* Product: '<S2495>/Multiplication' incorporates:
     *  Constant: '<S2481>/Constant Value1'
     *  DataStoreWrite: '<S2481>/Dsw_EngStrtStpMd1'
     *  Rounding: '<S2495>/Floor'
     *  Sum: '<S2495>/Subtraction'
     */
    VeESSR_phi_EngStpRmpDwnStrtAng_DS = (rtb_Merge_g1 - floorf(rtb_Merge_g1)) *
        720.0F;

    /* Sum: '<S2484>/Subtraction4' incorporates:
     *  Constant: '<S2484>/Constant Value5'
     *  DataStoreWrite: '<S2481>/Dsw_EngStrtStpMd1'
     *  Sum: '<S2484>/Subtraction3'
     *  UnitDelay: '<S2461>/Unit Delay1'
     */
    rtb_Subtraction4_l = (720.0F - localDW->UnitDelay1_DSTATE) +
        VeESSR_phi_EngStpRmpDwnStrtAng_DS;

    /* If: '<S2519>/If' */
    if (rtb_Subtraction4_l <= 720.0F)
    {
        /* Outputs for IfAction SubSystem: '<S2519>/PassThrough' incorporates:
         *  ActionPort: '<S2522>/Action Port'
         */
        ESSR_ac_PassThrough(rtb_Subtraction4_l, &rtb_Merge_g1);

        /* End of Outputs for SubSystem: '<S2519>/PassThrough' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2519>/Subtract720' incorporates:
         *  ActionPort: '<S2523>/Action Port'
         */
        ESSR_ac_Subtract720(rtb_Subtraction4_l, &rtb_Merge_g1);

        /* End of Outputs for SubSystem: '<S2519>/Subtract720' */
    }

    /* End of If: '<S2519>/If' */

    /* Sum: '<S2484>/Subtraction2' incorporates:
     *  Constant: '<S2484>/Constant Value2'
     *  DataStoreWrite: '<S2481>/Dsw_EngStrtStpMd1'
     *  Sum: '<S2484>/Subtraction1'
     */
    rtb_Subtraction2_f = (720.0F - rtu_EngAng720Est) +
        VeESSR_phi_EngStpRmpDwnStrtAng_DS;

    /* If: '<S2518>/If' */
    if (rtb_Subtraction2_f <= 720.0F)
    {
        /* Outputs for IfAction SubSystem: '<S2518>/PassThrough' incorporates:
         *  ActionPort: '<S2520>/Action Port'
         */
        ESSR_ac_PassThrough(rtb_Subtraction2_f, &rtb_Subtraction4_l);

        /* End of Outputs for SubSystem: '<S2518>/PassThrough' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2518>/Subtract720' incorporates:
         *  ActionPort: '<S2521>/Action Port'
         */
        ESSR_ac_Subtract720(rtb_Subtraction2_f, &rtb_Subtraction4_l);

        /* End of Outputs for SubSystem: '<S2518>/Subtract720' */
    }

    /* End of If: '<S2518>/If' */

    /* Logic: '<S2461>/Logical1' incorporates:
     *  Constant: '<S2484>/Constant Value'
     *  Constant: '<S2484>/Constant Value1'
     *  Constant: '<S2484>/Constant Value3'
     *  Constant: '<S2484>/Constant Value4'
     *  Constant: '<S2489>/Calib'
     *  DataStoreRead: '<S2461>/Dsr_STMTmr3'
     *  Logic: '<S2461>/Logical Operator3'
     *  Logic: '<S2484>/Logical'
     *  Logic: '<S2484>/Logical1'
     *  RelationalOperator: '<S2461>/Greater  Than2'
     *  RelationalOperator: '<S2484>/Comparison1'
     *  RelationalOperator: '<S2484>/Comparison2'
     *  RelationalOperator: '<S2484>/Comparison3'
     *  RelationalOperator: '<S2484>/Comparison4'
     */
    rtb_Logical1_c4 = ((((rtb_Merge_g1 == 0.0F) || (rtb_Subtraction4_l == 0.0F))
                        || ((rtb_Merge_g1 <= 360.0F) && (rtb_Subtraction4_l >
                          360.0F))) || ((VeESSR_t_STMTmr_DS >
                         KeESSR_t_MaxAngleWaitTm) || rtb_GreaterThan_l3));

    /* Logic: '<S2451>/Logical Operator2' incorporates:
     *  Logic: '<S2461>/Logical Operator1'
     */
    rtb_LogicalOperator2_ck = ((!rtb_Logical1_c4) && rtb_GreaterThan_l3);

    /* Switch: '<S2451>/Switch1' incorporates:
     *  S-Function (sfix_bitop): '<S2456>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator2_ck)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 262144U;
    }

    /* End of Switch: '<S2451>/Switch1' */

    /* Logic: '<S2461>/AND4' incorporates:
     *  Constant: '<S2486>/Calib'
     *  Logic: '<S2461>/Logical Operator17'
     *  Logic: '<S2461>/Logical Operator18'
     */
    rtb_AND4_o = ((!KeESSD_b_P1C68_DF_Enbl) && rtb_GreaterThan_l3);

    /* Logic: '<S2461>/AND2' incorporates:
     *  Constant: '<S2487>/Calib'
     *  DataStoreRead: '<S2451>/Dsr_STMTmr3'
     *  Logic: '<S2461>/Logical Operator8'
     *  Logic: '<S2461>/Logical Operator9'
     *  RelationalOperator: '<S2461>/Comparison1'
     */
    rtb_AND2_ca = ((!rtu_EngCmbstCmnd) || ((VeESSR_t_STMTmr_DS >
                     KeESSR_t_DF_CmbstnCmdTm) || rtb_AND4_o));

    /* Logic: '<S2451>/Logical Operator4' incorporates:
     *  Logic: '<S2451>/Logical Operator1'
     *  Logic: '<S2461>/Logical Operator13'
     */
    rtb_LogicalOperator4_b = ((!rtb_AND2_ca) && rtb_GreaterThan_l3);

    /* Switch: '<S2451>/Switch2' incorporates:
     *  S-Function (sfix_bitop): '<S2457>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator4_b)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 134217728U;
    }

    /* End of Switch: '<S2451>/Switch2' */

    /* Switch: '<S2502>/Switch1' incorporates:
     *  Constant: '<S2482>/Constant Value2'
     *  Constant: '<S2501>/Calib'
     *  Constant: '<S2503>/Calib'
     *  DataStoreRead: '<S2451>/Dsr_STMTmr6'
     *  DataStoreRead: '<S2482>/Dsr_EngIdleTm'
     *  DataStoreWrite: '<S2482>/Dsw_EngIdleTm'
     *  RelationalOperator: '<S2482>/Less  Than1'
     *  Sum: '<S2482>/Sum'
     *  Sum: '<S2482>/Summation3'
     */
    if (rtu_TransInSpdFlt <= (VeESSR_n_TgtIdleSpd_DS +
                              KeESSR_n_PrepStopTargIdleDB))
    {
        VeESSR_t_EngIdleTm_DS = VeESSR_t_EngIdleTm_DS + HeESSR_t_MedTEB_dT;
    }
    else
    {
        VeESSR_t_EngIdleTm_DS = 0.0F;
    }

    /* End of Switch: '<S2502>/Switch1' */

    /* Logic: '<S2461>/AND4' incorporates:
     *  Constant: '<S2488>/Calib'
     *  Constant: '<S2504>/Calib'
     *  DataStoreRead: '<S2451>/Dsr_STMTmr3'
     *  DataStoreWrite: '<S2482>/Dsw_EngIdleTm'
     *  Logic: '<S2461>/Logical Operator26'
     *  RelationalOperator: '<S2461>/Comparison3'
     *  RelationalOperator: '<S2482>/Less  Than3'
     */
    rtb_AND4_o = ((rtb_AND4_o || (VeESSR_t_STMTmr_DS > KeESSR_t_DF_SpdTgtTm)) ||
                  (VeESSR_t_EngIdleTm_DS > KeESSR_t_MinEngIdleTm));

    /* Logic: '<S2451>/Logical2' incorporates:
     *  Logic: '<S2451>/Logical Operator3'
     *  Logic: '<S2461>/Logical Operator6'
     */
    rtb_Logical2_ks = ((!rtb_AND4_o) && rtb_GreaterThan_l3);

    /* Switch: '<S2451>/Switch3' incorporates:
     *  S-Function (sfix_bitop): '<S2458>/FixPt Bitwise Operator1'
     */
    if (rtb_Logical2_ks)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 268435456U;
    }

    /* End of Switch: '<S2451>/Switch3' */

    /* Abs: '<S2462>/Abs' incorporates:
     *  Abs: '<S2463>/Abs'
     *  Constant: '<S2465>/Calib'
     *  Constant: '<S2471>/Calib'
     *  Product: '<S2462>/Multiplication'
     */
    rtb_Merge_g1 = fabsf(KeESSR_dM_PrepStopTiRmpRt * HeESSR_t_MedTEB_dT);

    /* Sum: '<S2462>/Sum' incorporates:
     *  DataStoreRead: '<S2451>/Dsr_EngTrqReqImmed1'
     *  DataStoreRead: '<S2451>/Dsr_EngTrqReqImmed2'
     *  DataStoreRead: '<S2451>/Dsr_EngTrqReqImmed4'
     *  MinMax: '<S2451>/MinMax3'
     */
    rtb_Subtraction4_l = fminf(VeESSR_M_PrepStpImmedTgt_DS,
        VeESSR_M_EngTrqReqImmed_DS) - VeESSR_M_EngTrqReqImmed_DS;

    /* Outputs for Atomic SubSystem: '<S2462>/Limiter1' */
    /* Switch: '<S2541>/Switch1' incorporates:
     *  Abs: '<S2462>/Abs'
     *  RelationalOperator: '<S2541>/Relational Operator'
     */
    if (rtb_Merge_g1 < rtb_Subtraction4_l)
    {
        /* Merge: '<S2536>/Merge' */
        rtb_Subtraction4_l = rtb_Merge_g1;
    }

    /* End of Switch: '<S2541>/Switch1' */

    /* Switch: '<S2541>/Switch' incorporates:
     *  Abs: '<S2462>/Abs'
     *  Gain: '<S2462>/Gain'
     *  RelationalOperator: '<S2541>/Relational Operator1'
     */
    if (rtb_Subtraction4_l <= (-rtb_Merge_g1))
    {
        rtb_Subtraction4_l = -rtb_Merge_g1;
    }

    /* End of Switch: '<S2541>/Switch' */
    /* End of Outputs for SubSystem: '<S2462>/Limiter1' */

    /* Sum: '<S2462>/Sum1' incorporates:
     *  DataStoreRead: '<S2451>/Dsr_EngTrqReqImmed1'
     */
    rtb_Subtraction4_l += VeESSR_M_EngTrqReqImmed_DS;

    /* Outputs for Atomic SubSystem: '<S2462>/Limiter2' */
    /* Switch: '<S2542>/Switch1' incorporates:
     *  Constant: '<S2451>/Constant Value5'
     *  RelationalOperator: '<S2542>/Relational Operator'
     */
    if (9999.0F < rtb_Subtraction4_l)
    {
        /* Merge: '<S2536>/Merge' */
        rtb_Subtraction4_l = 9999.0F;
    }

    /* End of Switch: '<S2542>/Switch1' */

    /* Switch: '<S2542>/Switch' incorporates:
     *  Constant: '<S2451>/Constant Value1'
     *  DataStoreWrite: '<S2451>/Dsw_EngTrqReqImmed'
     *  RelationalOperator: '<S2542>/Relational Operator1'
     */
    if (rtb_Subtraction4_l > -9999.0F)
    {
        VeESSR_M_EngTrqReqImmed_DS = rtb_Subtraction4_l;
    }
    else
    {
        VeESSR_M_EngTrqReqImmed_DS = -9999.0F;
    }

    /* End of Switch: '<S2542>/Switch' */
    /* End of Outputs for SubSystem: '<S2462>/Limiter2' */

    /* Sum: '<S2463>/Sum' incorporates:
     *  Constant: '<S2469>/Calib'
     *  DataStoreRead: '<S2451>/Dsr_EngTrqReqPrdtd1'
     *  MinMax: '<S2451>/MinMax1'
     */
    rtb_Subtraction4_l = fmaxf(KeESSR_M_AStopPrdtTrqTgt, rtu_EngCapacityMinOff)
        - VeESSR_M_EngTrqReqPrdtd_DS;

    /* Outputs for Atomic SubSystem: '<S2463>/Limiter1' */
    /* Switch: '<S2543>/Switch1' incorporates:
     *  RelationalOperator: '<S2543>/Relational Operator'
     */
    if (rtb_Merge_g1 < rtb_Subtraction4_l)
    {
        /* Merge: '<S2536>/Merge' */
        rtb_Subtraction4_l = rtb_Merge_g1;
    }

    /* End of Switch: '<S2543>/Switch1' */

    /* Switch: '<S2543>/Switch' incorporates:
     *  Gain: '<S2463>/Gain'
     *  RelationalOperator: '<S2543>/Relational Operator1'
     */
    if (rtb_Subtraction4_l <= (-rtb_Merge_g1))
    {
        rtb_Subtraction4_l = -rtb_Merge_g1;
    }

    /* End of Switch: '<S2543>/Switch' */
    /* End of Outputs for SubSystem: '<S2463>/Limiter1' */

    /* Sum: '<S2463>/Sum1' incorporates:
     *  DataStoreRead: '<S2451>/Dsr_EngTrqReqPrdtd1'
     */
    rtb_Subtraction4_l += VeESSR_M_EngTrqReqPrdtd_DS;

    /* Outputs for Atomic SubSystem: '<S2463>/Limiter2' */
    /* Switch: '<S2544>/Switch1' incorporates:
     *  Constant: '<S2451>/Constant Value3'
     *  RelationalOperator: '<S2544>/Relational Operator'
     */
    if (9999.0F < rtb_Subtraction4_l)
    {
        /* Merge: '<S2536>/Merge' */
        rtb_Subtraction4_l = 9999.0F;
    }

    /* End of Switch: '<S2544>/Switch1' */

    /* Switch: '<S2544>/Switch' incorporates:
     *  Constant: '<S2451>/Constant Value4'
     *  DataStoreWrite: '<S2451>/Dsw_EngTrqReqPrdtd'
     *  RelationalOperator: '<S2544>/Relational Operator1'
     */
    if (rtb_Subtraction4_l > -9999.0F)
    {
        VeESSR_M_EngTrqReqPrdtd_DS = rtb_Subtraction4_l;
    }
    else
    {
        VeESSR_M_EngTrqReqPrdtd_DS = -9999.0F;
    }

    /* End of Switch: '<S2544>/Switch' */
    /* End of Outputs for SubSystem: '<S2463>/Limiter2' */

    /* Merge: '<S2536>/Merge' incorporates:
     *  DataStoreRead: '<S2451>/Dsr_STMTmr'
     */
    rtb_Subtraction4_l = VeESSR_t_STMTmr_DS;

    /* Sum: '<S2451>/Summation1' incorporates:
     *  Constant: '<S2465>/Calib'
     *  DataStoreRead: '<S2451>/Dsr_STMTmr'
     *  DataStoreWrite: '<S2451>/Dsw_STMTmr'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Logic: '<S2451>/Logical Operator4' */
    rtb_LogicalOperator4_b = (rtb_LogicalOperator4_b || rtb_Logical2_ks);

    /* Switch: '<S2451>/Switch4' incorporates:
     *  Constant: '<S2451>/Constant Value2'
     *  DataStoreRead: '<S2451>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S2451>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S2451>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S2451>/Logical21'
     *  Logic: '<S2451>/Logical3'
     *  RelationalOperator: '<S2451>/Comparison1'
     *  S-Function (sfix_bitop): '<S2451>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S2459>/FixPt Bitwise Operator1'
     */
    if (((rtb_LogicalOperator7_kc || rtb_LogicalOperator2_ck) ||
            rtb_LogicalOperator4_b) && ((VeESSR_g_StrtStpFailPhaseSelect_DS &
            131072U) > 0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 131072U;
    }

    /* End of Switch: '<S2451>/Switch4' */

    /* RelationalOperator: '<S2483>/Greater  Than5' incorporates:
     *  Constant: '<S2508>/Calib'
     *  DataStoreRead: '<S2483>/Dsr_STMTmr5'
     */
    VeESSR_b_DSO2Mon_InitTm_Chk = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxDSO2InitTm);

    /* Logic: '<S2483>/Logical Operator6' incorporates:
     *  DataStoreRead: '<S2483>/Data Store Read'
     *  DataStoreRead: '<S2483>/Data Store Read1'
     *  Logic: '<S2483>/Logical Operator3'
     *  Logic: '<S2483>/Logical Operator8'
     */
    VeESSR_b_DSO2Mon_Enbld_Chk = (((!VeESSR_b_DSO2Mon_Enbld_DS) &&
        (!VeESSR_b_DSO2Mon_Cmplt_DS)) && (VeESSR_b_DSO2Mon_InitTm_Chk));

    /* Outputs for Atomic SubSystem: '<S2483>/Stop Watch Reset Enabled' */
    /* Switch: '<S2510>/Switch2' incorporates:
     *  DataStoreRead: '<S2483>/Data Store Read'
     *  Logic: '<S2483>/Logical Operator9'
     *  Switch: '<S2510>/Switch1'
     */
    if (!VeESSR_b_DSO2Mon_Enbld_DS)
    {
        /* Switch: '<S2510>/Switch1' incorporates:
         *  Constant: '<S2510>/Constant Value2'
         */
        VeESSR_t_DSO2Mon_EnbldTm = 0.0F;
    }
    else
    {
        /* Switch: '<S2510>/Switch1' incorporates:
         *  Constant: '<S2465>/Calib'
         *  Sum: '<S2510>/Subtraction'
         *  Switch: '<S2510>/Switch2'
         *  UnitDelay: '<S2510>/Unit Delay'
         */
        VeESSR_t_DSO2Mon_EnbldTm = HeESSR_t_MedTEB_dT + VeESSR_t_DSO2Mon_EnbldTm;
    }

    /* End of Switch: '<S2510>/Switch2' */
    /* End of Outputs for SubSystem: '<S2483>/Stop Watch Reset Enabled' */

    /* RelationalOperator: '<S2483>/Greater  Than6' incorporates:
     *  Constant: '<S2507>/Calib'
     */
    VeESSR_b_DSO2Mon_Cmplt_Chk = (VeESSR_t_DSO2Mon_EnbldTm >
        KeESSR_t_MaxDSO2CmpltTm);

    /* RelationalOperator: '<S2451>/Comparison' incorporates:
     *  Constant: '<S2465>/Calib'
     */
    rtb_LogicalOperator7_kc = (HeESSR_t_MedTEB_dT > rtb_Subtraction4_l);

    /* Outputs for Atomic SubSystem: '<S2506>/FallingEdgeReset' */
    /* Outputs for Atomic SubSystem: '<S2483>/Stop Watch Reset Enabled1' */
    /* Switch: '<S2511>/Switch1' incorporates:
     *  Constant: '<S2513>/FALSE Constant'
     *  DataStoreRead: '<S2483>/Data Store Read1'
     *  Switch: '<S2511>/Switch2'
     *  Switch: '<S2515>/Switch1'
     *  UnitDelay: '<S2515>/Unit Delay'
     */
    if (rtb_LogicalOperator7_kc)
    {
        /* Switch: '<S2511>/Switch1' incorporates:
         *  Constant: '<S2511>/Constant Value2'
         */
        VeESSR_t_DSO2Mon_TrqTm = 0.0F;
        rtb_LogicalOperator2_ck = false;
    }
    else
    {
        if (VeESSR_b_DSO2Mon_Cmplt_DS)
        {
            /* Switch: '<S2511>/Switch1' incorporates:
             *  Constant: '<S2465>/Calib'
             *  Sum: '<S2511>/Subtraction'
             *  Switch: '<S2511>/Switch2'
             *  UnitDelay: '<S2511>/Unit Delay'
             */
            VeESSR_t_DSO2Mon_TrqTm = HeESSR_t_MedTEB_dT + VeESSR_t_DSO2Mon_TrqTm;
        }

        rtb_LogicalOperator2_ck = localDW->UnitDelay_DSTATE_k;
    }

    /* End of Switch: '<S2511>/Switch1' */
    /* End of Outputs for SubSystem: '<S2483>/Stop Watch Reset Enabled1' */
    /* End of Outputs for SubSystem: '<S2506>/FallingEdgeReset' */

    /* RelationalOperator: '<S2483>/Greater  Than7' incorporates:
     *  Constant: '<S2509>/Calib'
     */
    VeESSR_b_DSO2Mon_TrqTm_Chk = (VeESSR_t_DSO2Mon_TrqTm > KeESSR_t_MaxDSO2TrqTm);

    /* Logic: '<S2483>/Logical Operator1' incorporates:
     *  DataStoreRead: '<S2483>/Data Store Read1'
     *  DataStoreRead: '<S2483>/Dsr_InputSpeedProfile2'
     *  Logic: '<S2483>/AND2'
     *  RelationalOperator: '<S2483>/Less  Than'
     */
    VeESSR_b_DSO2Mon_Trq_Chk = ((VeESSR_b_DSO2Mon_Cmplt_DS) &&
        ((rtu_EngCapacityMinRunImmed < VeESSR_M_EngTrqReqImmed_DS) ||
         (VeESSR_b_DSO2Mon_TrqTm_Chk)));

    /* Logic: '<S2483>/Logical3' */
    VeESSR_b_DSO2Mon_Chk = (((VeESSR_b_DSO2Mon_Enbld_Chk) ||
        (VeESSR_b_DSO2Mon_Cmplt_Chk)) || (VeESSR_b_DSO2Mon_Trq_Chk));

    /* Logic: '<S2506>/Logical Operator2' incorporates:
     *  Constant: '<S2512>/Constant'
     *  Logic: '<S2506>/Logical Operator13'
     *  RelationalOperator: '<S2506>/Greater  Than8'
     */
    VeESSR_b_DSO2Mon_Enbld = ((((uint32)rtu_EngDFSO_Req) ==
        CeENGR_e_DFSO_Enabled) && (!rtu_EngTLCLearnReq));

    /* DataStoreWrite: '<S2506>/Data Store Write' */
    VeESSR_b_DSO2Mon_Enbld_DS = VeESSR_b_DSO2Mon_Enbld;

    /* Outputs for Atomic SubSystem: '<S2506>/FallingEdgeReset' */
    /* Logic: '<S2513>/AND' incorporates:
     *  DataStoreRead: '<S2506>/Data Store Read'
     *  Logic: '<S2513>/OR1'
     */
    VeESSR_b_DSO2Mon_Enbld_FE = ((!VeESSR_b_DSO2Mon_Enbld_DS) &&
        rtb_LogicalOperator2_ck);

    /* Outputs for Atomic SubSystem: '<S2506>/Signal Latch On With Reset' */
    /* Logic: '<S2514>/NOT' incorporates:
     *  Switch: '<S2515>/Switch3'
     */
    rtb_LogicalOperator7_kc = !rtb_LogicalOperator7_kc;

    /* End of Outputs for SubSystem: '<S2506>/Signal Latch On With Reset' */

    /* Update for UnitDelay: '<S2515>/Unit Delay' incorporates:
     *  DataStoreRead: '<S2506>/Data Store Read'
     *  Switch: '<S2515>/Switch3'
     */
    localDW->UnitDelay_DSTATE_k = (rtb_LogicalOperator7_kc &&
        (VeESSR_b_DSO2Mon_Enbld_DS));

    /* End of Outputs for SubSystem: '<S2506>/FallingEdgeReset' */

    /* Outputs for Atomic SubSystem: '<S2506>/Signal Latch On With Reset' */
    /* Logic: '<S2514>/OR1' incorporates:
     *  Logic: '<S2514>/OR'
     *  UnitDelay: '<S2514>/Unit Delay'
     */
    VeESSR_b_DSO2Mon_Cmplt = ((VeESSR_b_DSO2Mon_Enbld_FE) ||
        (rtb_LogicalOperator7_kc && (VeESSR_b_DSO2Mon_Cmplt)));

    /* End of Outputs for SubSystem: '<S2506>/Signal Latch On With Reset' */

    /* DataStoreWrite: '<S2506>/Data Store Write1' */
    VeESSR_b_DSO2Mon_Cmplt_DS = VeESSR_b_DSO2Mon_Cmplt;

    /* Merge: '<S2536>/Merge' incorporates:
     *  Constant: '<S2524>/Constant Value1'
     *  Constant: '<S2529>/Calib'
     *  DataStoreRead: '<S2524>/Dsr_InputSpeedProfile1'
     *  Lookup_n-D: '<S2531>/Vector'
     *  Product: '<S2532>/Division'
     *  Sum: '<S2524>/Subtraction'
     */
    rtb_Subtraction4_l = ((KeESSR_phi_EngStpTgtAngle - look1_iflf_binlcapw
                           (VeESSR_n_InputSpeedProfile_DS, ((const float32 *)
        &(KxESSR_phi_TotalTravelAng[0])), ((const float32 *)
        &(KtESSR_phi_TotalTravelAng[0])), 8U)) - rtb_Merge_ow_tmp) / 720.0F;

    /* Product: '<S2532>/Multiplication' incorporates:
     *  Constant: '<S2524>/Constant Value1'
     *  Rounding: '<S2532>/Floor'
     *  Sum: '<S2532>/Subtraction'
     */
    VeESSR_phi_RmpDwnStrtAng = (rtb_Subtraction4_l - floorf(rtb_Subtraction4_l))
        * 720.0F;

    /* Sum: '<S2525>/Subtraction4' incorporates:
     *  Constant: '<S2525>/Constant Value5'
     *  Sum: '<S2525>/Subtraction3'
     *  UnitDelay: '<S2491>/Unit Delay'
     */
    rtb_Merge_g1 = (720.0F - localDW->UnitDelay_DSTATE) +
        VeESSR_phi_RmpDwnStrtAng;

    /* If: '<S2536>/If' */
    if (rtb_Merge_g1 <= 720.0F)
    {
        /* Outputs for IfAction SubSystem: '<S2536>/PassThrough' incorporates:
         *  ActionPort: '<S2539>/Action Port'
         */
        ESSR_ac_PassThrough(rtb_Merge_g1, &rtb_Subtraction4_l);

        /* End of Outputs for SubSystem: '<S2536>/PassThrough' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2536>/Subtract720' incorporates:
         *  ActionPort: '<S2540>/Action Port'
         */
        ESSR_ac_Subtract720(rtb_Merge_g1, &rtb_Subtraction4_l);

        /* End of Outputs for SubSystem: '<S2536>/Subtract720' */
    }

    /* End of If: '<S2536>/If' */

    /* Sum: '<S2525>/Subtraction2' incorporates:
     *  Constant: '<S2525>/Constant Value2'
     *  Sum: '<S2525>/Subtraction1'
     */
    rtb_Subtraction2_f = (720.0F - rtu_EngAngle720Sync) +
        VeESSR_phi_RmpDwnStrtAng;

    /* If: '<S2535>/If' */
    if (rtb_Subtraction2_f <= 720.0F)
    {
        /* Outputs for IfAction SubSystem: '<S2535>/PassThrough' incorporates:
         *  ActionPort: '<S2537>/Action Port'
         */
        ESSR_ac_PassThrough(rtb_Subtraction2_f, &rtb_Merge_g1);

        /* End of Outputs for SubSystem: '<S2535>/PassThrough' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2535>/Subtract720' incorporates:
         *  ActionPort: '<S2538>/Action Port'
         */
        ESSR_ac_Subtract720(rtb_Subtraction2_f, &rtb_Merge_g1);

        /* End of Outputs for SubSystem: '<S2535>/Subtract720' */
    }

    /* End of If: '<S2535>/If' */

    /* Switch: '<S2525>/Switch' incorporates:
     *  Constant: '<S2525>/Constant Value'
     *  Constant: '<S2525>/Constant Value1'
     *  Constant: '<S2525>/Constant Value3'
     *  Constant: '<S2525>/Constant Value4'
     *  Logic: '<S2525>/Logical'
     *  Logic: '<S2525>/Logical1'
     *  RelationalOperator: '<S2525>/Comparison1'
     *  RelationalOperator: '<S2525>/Comparison2'
     *  RelationalOperator: '<S2525>/Comparison3'
     *  RelationalOperator: '<S2525>/Comparison4'
     */
    VeESSR_b_RmpDwnStrtAngInRng = (((rtb_Subtraction4_l == 0.0F) ||
        (rtb_Merge_g1 == 0.0F)) || ((rtb_Subtraction4_l <= 360.0F) &&
        (rtb_Merge_g1 > 360.0F)));

    /* Logic: '<S2491>/AND3' incorporates:
     *  Constant: '<S2526>/Calib'
     *  Constant: '<S2527>/Calib'
     *  Constant: '<S2528>/Calib'
     *  DataStoreRead: '<S2491>/Dsr_STMTmr1'
     *  Logic: '<S2491>/AND5'
     *  Logic: '<S2491>/Logical Operator1'
     *  Logic: '<S2491>/Logical Operator2'
     *  RelationalOperator: '<S2491>/Greater  Than1'
     */
    VeESSR_b_RmpDwnStrtAngInRngFnl = (((((!KeESSR_b_TrgtAngCntrl) ||
        (VeESSR_b_RmpDwnStrtAngInRng)) || rtu_EngAngle720SyncFA) ||
        ((KeESSR_b_EnblSyncLrnChk_DF) && (!rtu_EngAngle720SyncLrn))) ||
        (VeESSR_t_STMTmr_DS > KeESSR_t_MaxRmpDwnStrtAngWait));

    /* Logic: '<S2451>/Logical2' */
    rtb_Logical2_ks = (rtu_AStopEngCOMLmp && rtu_EngOnReq);

    /* If: '<S2451>/If1' incorporates:
     *  Constant: '<S2464>/Calib'
     *  Constant: '<S2470>/Calib'
     *  Constant: '<S2472>/Calib'
     *  Constant: '<S2474>/Calib'
     *  DataStoreRead: '<S2451>/Data Store Read4'
     *  DataStoreRead: '<S2451>/Dsr_STMTmr2'
     *  Logic: '<S2451>/AND'
     *  Logic: '<S2451>/AND1'
     *  Logic: '<S2451>/AND2'
     *  Logic: '<S2451>/Logical7'
     *  Logic: '<S2461>/AND1'
     *  RelationalOperator: '<S2451>/Comparison2'
     *  RelationalOperator: '<S2451>/Greater  Than1'
     */
    if ((((((rtb_Logical2_ps && rtb_Logical1_c4) && (VeESSR_b_DSO2Mon_Chk)) &&
            (VeESSR_b_RmpDwnStrtAngInRngFnl)) && rtb_AND2_ca) && rtb_AND4_o) &&
            (VeESSR_t_STMTmr_DS > KeESSR_t_MinTmDsblFuel))
    {
        /* Outputs for IfAction SubSystem: '<S2451>/NormExit' incorporates:
         *  ActionPort: '<S2475>/Action Port'
         */
        /* DataStoreWrite: '<S2475>/Dsw_STMTrigger1' incorporates:
         *  Constant: '<S2547>/Constant'
         */
        VeESSR_e_STMTrigger_DS = CeESSR_e_DamperLocked;

        /* End of Outputs for SubSystem: '<S2451>/NormExit' */
    }
    else if ((VeESSR_b_CoastDownTrigger_DS) || ((rtu_TransInSpdFlt <
               KeESSR_n_EngTrqOnlySpdMin) && rtb_Logical2_ks))
    {
        /* Outputs for IfAction SubSystem: '<S2451>/CoastDown' incorporates:
         *  ActionPort: '<S2460>/Action Port'
         */
        /* DataStoreWrite: '<S2460>/Dsw_STMTrigger1' incorporates:
         *  Constant: '<S2480>/Constant'
         */
        VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

        /* End of Outputs for SubSystem: '<S2451>/CoastDown' */
    }
    else if ((HeESSR_b_EngTrqOnlyCOM) && rtb_Logical2_ks)
    {
        /* Outputs for IfAction SubSystem: '<S2451>/Restart1' incorporates:
         *  ActionPort: '<S2476>/Action Port'
         */
        ESSR_ac_Restart1();

        /* End of Outputs for SubSystem: '<S2451>/Restart1' */
    }
    else if (rtu_EngOnReq && (KeESSR_b_AllowStopAbrtsDFA))
    {
        /* Outputs for IfAction SubSystem: '<S2451>/BackToStarting' incorporates:
         *  ActionPort: '<S2454>/Action Port'
         */
        /* DataStoreWrite: '<S2454>/Dsw_STMTrigger1' incorporates:
         *  Constant: '<S2479>/Constant'
         */
        VeESSR_e_STMTrigger_DS = CeESSR_e_StartReq;

        /* DataStoreWrite: '<S2454>/Dsw_EngRestartReq' incorporates:
         *  Constant: '<S2454>/TRUE Constant'
         */
        VeESSR_b_EngRestartReq_DS = true;

        /* End of Outputs for SubSystem: '<S2451>/BackToStarting' */
    }
    else
    {
        if (rtb_GreaterThan_l3)
        {
            /* Outputs for IfAction SubSystem: '<S2451>/RestartExit' incorporates:
             *  ActionPort: '<S2477>/Action Port'
             */
            /* DataStoreWrite: '<S2477>/Dsw_EngRestartReq' incorporates:
             *  Constant: '<S2477>/TRUE Constant'
             */
            VeESSR_b_PFSRunReq_DS = true;

            /* DataStoreWrite: '<S2477>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S2549>/Constant'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_StartReq;

            /* End of Outputs for SubSystem: '<S2451>/RestartExit' */
        }
    }

    /* End of If: '<S2451>/If1' */

    /* If: '<S2451>/If' */
    if (rtb_LogicalOperator4_b)
    {
        /* Outputs for IfAction SubSystem: '<S2451>/If_DisableFuel_P1C68' incorporates:
         *  ActionPort: '<S2467>/Action Port'
         */
        ESSR_ac_If_RampDown_P1C68();

        /* End of Outputs for SubSystem: '<S2451>/If_DisableFuel_P1C68' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2451>/If_DisableFuel_NoFault' incorporates:
         *  ActionPort: '<S2466>/Action Port'
         */
        ESSR_ac_If_DisableFuel_NoFault();

        /* End of Outputs for SubSystem: '<S2451>/If_DisableFuel_NoFault' */
    }

    /* End of If: '<S2451>/If' */

    /* DataStoreWrite: '<S2451>/Dsw_InputTorqEst' incorporates:
     *  Constant: '<S2468>/Calib'
     *  DataStoreRead: '<S2451>/Dsr_InputTorqEst'
     *  Product: '<S2453>/Multiplication'
     *  Sum: '<S2453>/Subtraction'
     *  Sum: '<S2453>/Subtraction1'
     */
    VeESSR_M_EngTorqEst_DS = ((rtu_EngTrqActual - VeESSR_M_EngTorqEst_DS) *
        KeESSR_K_TiEstBlndDsblFuel) + VeESSR_M_EngTorqEst_DS;

    /* Update for UnitDelay: '<S2461>/Unit Delay1' */
    localDW->UnitDelay1_DSTATE = rtu_EngAng720Est;

    /* Update for UnitDelay: '<S2491>/Unit Delay' */
    localDW->UnitDelay_DSTATE = rtu_EngAngle720Sync;
}

#endif

/*
 * Output and update for action system:
 *    '<S2976>/Sub720'
 *    '<S2919>/Sub720'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Sub720(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Out1)
{
    /* Sum: '<S2985>/Summation' incorporates:
     *  Constant: '<S2985>/Constant Value'
     */
    *rty_Out1 = rtu_In1 + -720.0F;
}

#endif

/*
 * Output and update for action system:
 *    '<S2976>/Add720'
 *    '<S2919>/Add720'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Add720(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Out1)
{
    /* Sum: '<S2983>/Summation' incorporates:
     *  Constant: '<S2983>/Constant Value'
     */
    *rty_Out1 = rtu_In1 + 720.0F;
}

#endif

/* Output and update for function-call system: '<S2450>/ESSC_RampDownEnt' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_RampDownEnt(VAR(float32,
    AUTOMATIC) rtu_EngAngle720Est, VAR(float32, AUTOMATIC) rtu_EngCapacityMinOff,
    P2VAR(B_ESSC_RampDownEnt_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localB, P2VAR
    (float32, AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_k_EngStpProfAngAdpt, P2VAR
    (float32, AUTOMATIC, ESSR_VAR_INIT) rtd_NeESSR_k_EngStpProfNiDotGai)
{
    float32 rtb_Multiplication_me;
    float32 rtb_Summation3_hp;
    float32 rtb_Switch1_pds;

    /* DataStoreWrite: '<S2800>/Dsw_EngAng720EstOld1' */
    VeESSR_phi_EngAng720EstOld_DS = rtu_EngAngle720Est;

    /* DataStoreRead: '<S2800>/Dsr_InputSpeedProfile1' */
    localB->Dsr_InputSpeedProfile1 = VeESSR_n_InputSpeedProfile_DS;

    /* If: '<S2955>/If' incorporates:
     *  Constant: '<S2800>/Constant Value6'
     *  Constant: '<S2978>/Calib'
     *  Lookup_n-D: '<S2979>/Vector'
     */
    if (KeESSR_b_EngStpProfUseAngAdpt)
    {
        /* Outputs for IfAction SubSystem: '<S2955>/UsingAdapt' incorporates:
         *  ActionPort: '<S2982>/Action Port'
         */
        ESSR_ac_UsingAdapt(look1_iflf_binlcapw(0.0F, ((const float32 *)
                             &(KxESSR_k_EngStpAngleFactor[0])), ((const float32 *)
                             &(KtESSR_k_EngStpAngleFactor[0])), 40U),
                           &rtb_Switch1_pds, rtd_NeESSR_k_EngStpProfAngAdpt);

        /* End of Outputs for SubSystem: '<S2955>/UsingAdapt' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2955>/PassThrough' incorporates:
         *  ActionPort: '<S2981>/Action Port'
         */
        ESSR_ac_PassThrough(look1_iflf_binlcapw(0.0F, ((const float32 *)
                              &(KxESSR_k_EngStpAngleFactor[0])), ((const float32
                               *)&(KtESSR_k_EngStpAngleFactor[0])), 40U),
                            &rtb_Switch1_pds);

        /* End of Outputs for SubSystem: '<S2955>/PassThrough' */
    }

    /* End of If: '<S2955>/If' */

    /* Product: '<S2800>/Multiplication' */
    rtb_Multiplication_me = localB->Dsr_InputSpeedProfile1 * rtb_Switch1_pds;

    /* Switch: '<S2973>/Switch1' incorporates:
     *  Constant: '<S2800>/Constant Value1'
     *  Constant: '<S2972>/Calib'
     *  Product: '<S2974>/Division'
     *  Sum: '<S2800>/Subtraction'
     */
    rtb_Switch1_pds = (KeESSR_phi_EngStpTgtAngle - rtb_Multiplication_me) /
        720.0F;

    /* Product: '<S2974>/Multiplication' incorporates:
     *  Constant: '<S2800>/Constant Value1'
     *  Rounding: '<S2974>/Floor'
     *  Sum: '<S2974>/Subtraction'
     */
    VeESSR_phi_SpinDwnInitAngle = (rtb_Switch1_pds - floorf(rtb_Switch1_pds)) *
        720.0F;

    /* Sum: '<S2976>/Summation3' */
    rtb_Summation3_hp = rtu_EngAngle720Est - VeESSR_phi_SpinDwnInitAngle;

    /* If: '<S2976>/If' */
    if (rtb_Summation3_hp > 360.0F)
    {
        /* Outputs for IfAction SubSystem: '<S2976>/Sub720' incorporates:
         *  ActionPort: '<S2985>/Action Port'
         */
        ESSR_ac_Sub720(rtb_Summation3_hp, &rtb_Switch1_pds);

        /* End of Outputs for SubSystem: '<S2976>/Sub720' */
    }
    else if (rtb_Summation3_hp < -360.0F)
    {
        /* Outputs for IfAction SubSystem: '<S2976>/Add720' incorporates:
         *  ActionPort: '<S2983>/Action Port'
         */
        ESSR_ac_Add720(rtb_Summation3_hp, &rtb_Switch1_pds);

        /* End of Outputs for SubSystem: '<S2976>/Add720' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2976>/PassThrough' incorporates:
         *  ActionPort: '<S2984>/Action Port'
         */
        ESSR_ac_PassThrough(rtb_Summation3_hp, &rtb_Switch1_pds);

        /* End of Outputs for SubSystem: '<S2976>/PassThrough' */
    }

    /* End of If: '<S2976>/If' */

    /* Sum: '<S2800>/Subtraction2' incorporates:
     *  DataStoreWrite: '<S2800>/Dsw_EngStpAngleElpsdDes'
     *  Sum: '<S2976>/Summation4'
     */
    VeESSR_phi_EngStpAngleElpsdDes_DS = rtb_Multiplication_me - rtb_Switch1_pds;

    /* Outputs for Atomic SubSystem: '<S2800>/Protected Division' */
    /* Switch: '<S2975>/Switch1' incorporates:
     *  Constant: '<S2975>/Constant Value'
     *  Constant: '<S2975>/Constant Value1'
     *  Constant: '<S2975>/Constant Value2'
     *  Constant: '<S2975>/Constant Value3'
     *  DataStoreWrite: '<S2800>/Dsw_EngStpAngleElpsdDes'
     *  Logic: '<S2975>/AND'
     *  RelationalOperator: '<S2975>/Greater Than or Equal '
     *  RelationalOperator: '<S2975>/Greater Than or Equal 1'
     *  RelationalOperator: '<S2975>/Not Equal'
     *  RelationalOperator: '<S2975>/Not Equal1'
     *  Switch: '<S2975>/Switch2'
     *  Switch: '<S2975>/Switch3'
     */
    if ((rtb_Multiplication_me != 0.0F) && (VeESSR_phi_EngStpAngleElpsdDes_DS !=
         0.0F))
    {
        /* Switch: '<S2975>/Switch1' incorporates:
         *  Product: '<S2975>/Division'
         */
        rtb_Switch1_pds = rtb_Multiplication_me /
            VeESSR_phi_EngStpAngleElpsdDes_DS;
    }
    else if (rtb_Multiplication_me > 0.0F)
    {
        /* Switch: '<S2975>/Switch2' incorporates:
         *  Constant: '<S2975>/MAXFLOAT'
         *  Switch: '<S2975>/Switch1'
         */
        rtb_Switch1_pds = 3.402823466E+38F;
    }
    else if (rtb_Multiplication_me < 0.0F)
    {
        /* Switch: '<S2975>/Switch3' incorporates:
         *  Constant: '<S2975>/MINFLOAT'
         *  Switch: '<S2975>/Switch1'
         *  Switch: '<S2975>/Switch2'
         */
        rtb_Switch1_pds = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2975>/Switch1' incorporates:
         *  Constant: '<S2975>/Constant Value4'
         *  Switch: '<S2975>/Switch2'
         *  Switch: '<S2975>/Switch3'
         */
        rtb_Switch1_pds = 0.0F;
    }

    /* End of Switch: '<S2975>/Switch1' */
    /* End of Outputs for SubSystem: '<S2800>/Protected Division' */

    /* Product: '<S2800>/Multiplication1' incorporates:
     *  Constant: '<S2962>/Calib'
     *  DataStoreWrite: '<S2800>/Dsw_EngStpProfCntr_Inc2'
     */
    VeESSR_Cnt_EngStpProfCntrInit_DS = HeESSR_t_MedTEB_dT * rtb_Switch1_pds;

    /* DataStoreWrite: '<S2800>/Data Store Write' incorporates:
     *  Constant: '<S2800>/Constant Value8'
     */
    VeESSR_k_EngStpProfNiDotGain_DS = 1.0F;

    /* MinMax: '<S2800>/MinMax1' incorporates:
     *  Constant: '<S2963>/Calib'
     *  DataStoreWrite: '<S2800>/Dsw_EngTrqReqPrdtd'
     */
    VeESSR_M_EngTrqReqPrdtd_DS = fmaxf(KeESSR_M_AStopPrdtTrqTgt,
        rtu_EngCapacityMinOff);

    /* DataStoreWrite: '<S2800>/Dsw_EngStpProfCntr' incorporates:
     *  Constant: '<S2800>/Constant Value3'
     */
    VeESSR_Cnt_EngStpProfCntr_DS = 0.0F;

    /* DataStoreWrite: '<S2800>/Dsw_EngTrqReqImmed' incorporates:
     *  Constant: '<S2800>/Constant Value4'
     */
    VeESSR_M_EngTrqReqImmed_DS = -500.0F;

    /* DataStoreWrite: '<S2800>/Dsw_EngStpAngleElpsd1' incorporates:
     *  Constant: '<S2800>/Constant Value7'
     */
    VeESSR_phi_EngStpAngleElpsd_DS = 0.0F;

    /* Switch: '<S2800>/Switch3' incorporates:
     *  Constant: '<S2800>/Constant Value9'
     *  Constant: '<S2960>/Calib'
     *  DataStoreWrite: '<S2800>/Data Store Write2'
     */
    if (!HeESSR_b_EngStrtTorq)
    {
        VeESSR_M_EngStrtTorq_DS = 0.0F;
    }

    /* End of Switch: '<S2800>/Switch3' */

    /* Switch: '<S2800>/Switch2' incorporates:
     *  Constant: '<S2961>/Calib'
     *  DataStoreWrite: '<S2800>/Dsw_Dsbl_ICSRFor12vStart'
     */
    VeESSR_b_DsblNiClsdLoopCntrl_DS = ((HeESSR_b_RmpDwnDisableNiSpeedMd) ||
        (VeESSR_b_DsblNiClsdLoopCntrl_DS));

    /* DataStoreWrite: '<S2800>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
     *  Constant: '<S2964>/Calib'
     */
    VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

    /* DataStoreWrite: '<S2800>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
     *  Constant: '<S2965>/Calib'
     */
    VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

    /* DataStoreWrite: '<S2800>/Dsw_EngStartStopSt' incorporates:
     *  Constant: '<S2956>/Constant'
     */
    VeESSR_e_EngStartStopSt_DS = CeESSR_e_RampDownSt;

    /* DataStoreWrite: '<S2800>/Dsw_EngStrtStpMd2' incorporates:
     *  Constant: '<S2959>/Constant'
     */
    VeESSR_e_EngStrtStpMd_DS = CeESSR_e_DisableFuel;

    /* DataStoreWrite: '<S2800>/Dsw_EngStrtType1' incorporates:
     *  Constant: '<S2967>/Calib'
     */
    VeESSR_e_TCM_StartStopType_DS = KeESSR_e_TCM_StartStopType_RampDown;

    /* DataStoreWrite: '<S2800>/Dsw_EngStrtType2' incorporates:
     *  Constant: '<S2958>/Constant'
     */
    VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Stopng;

    /* DataStoreWrite: '<S2800>/Dsw_InhibitShiftToMode' incorporates:
     *  Constant: '<S2966>/Calib'
     */
    VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtRampDownSt;

    /* DataStoreWrite: '<S2800>/Dsw_InputSpeedProfile1' incorporates:
     *  Constant: '<S2971>/Calib'
     */
    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

    /* DataStoreWrite: '<S2800>/Dsw_StrtStpFailDTC' incorporates:
     *  Constant: '<S2957>/Constant'
     */
    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

    /* DataStoreWrite: '<S2800>/Dsw_TransFldPmpSel' incorporates:
     *  Constant: '<S2968>/Calib'
     */
    VeESSR_e_TransFldPmpSel_DS = KeESSR_e_TransFldPmpSelRampDownSt;

    /* Outputs for Atomic SubSystem: '<S2800>/Limiter' */
    /* Switch: '<S2973>/Switch1' incorporates:
     *  Constant: '<S2969>/Calib'
     *  RelationalOperator: '<S2973>/Relational Operator'
     */
    if (KeESSR_k_EngStpProfNiDotGainAdpt_Max < (*rtd_NeESSR_k_EngStpProfNiDotGai))
    {
        /* Switch: '<S2973>/Switch1' */
        rtb_Switch1_pds = KeESSR_k_EngStpProfNiDotGainAdpt_Max;
    }
    else
    {
        /* Switch: '<S2973>/Switch1' */
        rtb_Switch1_pds = *rtd_NeESSR_k_EngStpProfNiDotGai;
    }

    /* End of Switch: '<S2973>/Switch1' */

    /* Switch: '<S2973>/Switch' incorporates:
     *  Constant: '<S2970>/Calib'
     *  RelationalOperator: '<S2973>/Relational Operator1'
     */
    if (rtb_Switch1_pds <= KeESSR_k_EngStpProfNiDotGainAdpt_Min)
    {
        /* Switch: '<S2973>/Switch' */
        rtb_Switch1_pds = KeESSR_k_EngStpProfNiDotGainAdpt_Min;
    }

    /* End of Switch: '<S2973>/Switch' */
    /* End of Outputs for SubSystem: '<S2800>/Limiter' */

    /* If: '<S2800>/If' */
    if (rtb_Switch1_pds != (*rtd_NeESSR_k_EngStpProfNiDotGai))
    {
        /* Outputs for IfAction SubSystem: '<S2800>/Update_Adapt_Value' incorporates:
         *  ActionPort: '<S2977>/Action Port'
         */
        /* DataStoreWrite: '<S2977>/Data Store Write1' */
        *rtd_NeESSR_k_EngStpProfNiDotGai = rtb_Switch1_pds;

        /* End of Outputs for SubSystem: '<S2800>/Update_Adapt_Value' */
    }

    /* End of If: '<S2800>/If' */
}

#endif

/*
 * Output and update for action system:
 *    '<S2852>/AdaptUp'
 *    '<S2859>/AdaptUp'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_AdaptUp(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Positive)
{
    /* Inport: '<S2854>/In1' */
    *rty_Positive = rtu_In1;
}

#endif

/*
 * Output and update for action system:
 *    '<S2852>/AdaptDown'
 *    '<S2859>/AdaptDown'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_AdaptDown(VAR(float32, AUTOMATIC)
    rtu_In1, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT) rty_Negative)
{
    /* Gain: '<S2853>/Gain' */
    *rty_Negative = -rtu_In1;
}

#endif

/*
 * Output and update for action system:
 *    '<S2799>/CoastDown'
 *    '<S2564>/CoastDown'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_CoastDown(void)
{
    /* DataStoreWrite: '<S2807>/Dsw_STMTrigger1' incorporates:
     *  Constant: '<S2866>/Constant'
     */
    VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;
}

#endif

/*
 * Output and update for action system:
 *    '<S2799>/Restart'
 *    '<S2564>/Restart'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Restart(void)
{
    /* DataStoreWrite: '<S2841>/Dsw_STMTrigger' incorporates:
     *  Constant: '<S2872>/Constant'
     */
    VeESSR_e_STMTrigger_DS = CeESSR_e_StartReq;

    /* DataStoreWrite: '<S2841>/Dsw_EngRestartReq' incorporates:
     *  Constant: '<S2841>/TRUE Constant'
     */
    VeESSR_b_EngRestartReq_DS = true;
}

#endif

/*
 * Output and update for action system:
 *    '<S2799>/EngFail'
 *    '<S2564>/EngFail'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_EngFail(void)
{
    /* DataStoreWrite: '<S2810>/Dsw_STMTrigger' incorporates:
     *  Constant: '<S2869>/Constant'
     */
    VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;
}

#endif

/*
 * Output and update for action system:
 *    '<S2799>/Use_ShapeNi'
 *    '<S2799>/AngleRatio'
 */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_Use_ShapeNi(VAR(float32, AUTOMATIC)
    rtu_InputSpdProfile, VAR(float32, AUTOMATIC) rtu_InputSpdProfDn, P2VAR
    (float32, AUTOMATIC, ESSR_VAR_INIT) rty_InpSpdProf, P2VAR(float32, AUTOMATIC,
    ESSR_VAR_INIT) rty_InpSpdDn)
{
    /* Inport: '<S2847>/InputSpdProfile' */
    *rty_InpSpdProf = rtu_InputSpdProfile;

    /* Inport: '<S2847>/InputSpdProfDn' */
    *rty_InpSpdDn = rtu_InputSpdProfDn;
}

#endif

/* System initialize for function-call system: '<S2450>/ESSC_RampDownDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_RampDownDur_Init(P2VAR
    (DW_ESSC_RampDownDur_ESSR_ac_T, AUTOMATIC, ESSR_VAR_INIT) localDW)
{
    /* InitializeConditions for Delay: '<S2876>/IntegerDelay' */
    localDW->icLoad = 1U;
}

#endif

/* Output and update for function-call system: '<S2450>/ESSC_RampDownDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_RampDownDur(VAR(float32,
    AUTOMATIC) rtu_InitEngSpd, VAR(float32, AUTOMATIC) rtu_TransInSpdFlt, VAR
    (float32, AUTOMATIC) rtu_EngTrqActual, VAR(float32, AUTOMATIC)
    rtu_SpinDownDragCorr, VAR(float32, AUTOMATIC) rtu_EngAngle720Est, VAR
    (boolean, AUTOMATIC) rtu_EngOnReq, VAR(float32, AUTOMATIC) rtu_EntrySpd, VAR
    (float32, AUTOMATIC) rtu_NiDotMax, VAR(float32, AUTOMATIC) rtu_NiDotMin, VAR
    (float32, AUTOMATIC) rtu_VeHSER_n_NiMax, VAR(boolean, AUTOMATIC)
    rtu_InCltchStrtZn, VAR(boolean, AUTOMATIC) rtu_CltchStrtRsrvAvail, VAR
    (boolean, AUTOMATIC) rtu_AStopEngCOMLmp, VAR(boolean, AUTOMATIC)
    rtu_AStopReStrtPrepLmp, P2VAR(B_ESSC_RampDownDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localB, P2VAR(DW_ESSC_RampDownDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(ZCE_ESSC_RampDownDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localZCE, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_k_EngStpProfAngAdpt, P2VAR(float32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_k_EngStpProfNiDotGai)
{
    sint32 i;
    float32 rtb_Abs_pi;
    float32 rtb_Gain1_bp;
    float32 rtb_Gain_d;
    float32 rtb_Gain_n3;
    float32 rtb_IntegerDelay;
    float32 rtb_Merge4_o;
    float32 rtb_Product4;
    float32 rtb_Product4_a;
    float32 rtb_Sum15;
    float32 rtb_Sum2_d0;
    float32 rtb_Sum6_j;
    float32 rtb_Summation_go;
    float32 rtb_Summation_i;
    float32 rtb_Switch1_b5;
    float32 rtb_Switch1_cfe;
    float32 rtb_Switch_ab2;
    uint8 tmp;
    boolean rtb_Comparison_id;
    boolean rtb_GreaterThan1_c0;
    boolean rtb_GreaterThan_os;
    boolean rtb_GreaterThanorEqual_mr;
    boolean rtb_Logical2_ls;
    boolean rtb_LogicalOperator2_il;
    boolean rtb_RelationalOperator_jnm;
    boolean rtb_RelationalOperator_ppl;
    boolean rtb_Switch6_b;

    /* Switch: '<S2815>/Switch1' incorporates:
     *  Constant: '<S2819>/Calib'
     *  Constant: '<S2834>/Calib'
     *  Constant: '<S2835>/Calib'
     */
    if (KeESSR_b_AStopParkEngEnable)
    {
        rtb_Summation_i = KeESSR_n_EngReleaseSpdForEngPark;
    }
    else
    {
        rtb_Summation_i = KeESSR_n_EngReleaseSpd;
    }

    /* End of Switch: '<S2815>/Switch1' */

    /* RelationalOperator: '<S2799>/Greater Than or Equal ' incorporates:
     *  DataStoreRead: '<S2799>/Dsr_InputSpeedProfile1'
     */
    rtb_GreaterThanorEqual_mr = (VeESSR_n_InputSpeedProfile_DS <=
        rtb_Summation_i);

    /* RelationalOperator: '<S2799>/Greater  Than' incorporates:
     *  Constant: '<S2839>/Calib'
     *  DataStoreRead: '<S2799>/Dsr_STMTmr1'
     */
    rtb_GreaterThan_os = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmRmpDwn);

    /* Logic: '<S2799>/Logical Operator2' incorporates:
     *  Logic: '<S2799>/Logical Operator7'
     *  Logic: '<S2799>/Logical4'
     */
    rtb_LogicalOperator2_il = ((!rtb_GreaterThanorEqual_mr) &&
        rtb_GreaterThan_os);

    /* Switch: '<S2799>/Switch' incorporates:
     *  S-Function (sfix_bitop): '<S2804>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator2_il)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 524288U;
    }

    /* End of Switch: '<S2799>/Switch' */

    /* RelationalOperator: '<S2799>/Greater  Than1' incorporates:
     *  Constant: '<S2837>/Calib'
     */
    rtb_GreaterThan1_c0 = (rtu_TransInSpdFlt > KeESSR_n_StopAbrtMinSpd);

    /* Logic: '<S2799>/Logical' incorporates:
     *  Constant: '<S2840>/Calib'
     *  DataStoreRead: '<S2799>/Dsr_STMTmr2'
     *  DataStoreWrite: '<S2799>/Dsw_CltchStckOn'
     *  RelationalOperator: '<S2799>/Greater  Than2'
     */
    VeESSR_b_CltchStckOn_DS = (rtb_GreaterThan1_c0 && (VeESSR_t_STMTmr_DS >
        KeESSR_t_RmpDwnAbrtTm));

    /* Switch: '<S2799>/Switch6' incorporates:
     *  DataStoreWrite: '<S2799>/Dsw_CltchStckOn'
     *  Logic: '<S2799>/Logical Operator1'
     *  Logic: '<S2799>/Logical5'
     */
    rtb_Switch6_b = ((!VeESSR_b_CltchStckOn_DS) && rtb_GreaterThan_os);

    /* Switch: '<S2799>/Switch1' incorporates:
     *  S-Function (sfix_bitop): '<S2805>/FixPt Bitwise Operator1'
     */
    if (rtb_Switch6_b)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 1048576U;
    }

    /* End of Switch: '<S2799>/Switch1' */

    /* Switch: '<S2799>/Switch3' incorporates:
     *  Constant: '<S2799>/Constant Value3'
     *  Constant: '<S2813>/Calib'
     *  Switch: '<S2799>/Switch2'
     *  Switch: '<S2799>/Switch5'
     */
    if (HeESSR_b_RmpDwnDisableNiSpeedMd)
    {
        /* Switch: '<S2799>/Switch3' incorporates:
         *  Constant: '<S2799>/Constant Value1'
         */
        VeESSR_dn_NiDotMaxForAStop = 10000.0F;

        /* Switch: '<S2799>/Switch5' incorporates:
         *  Constant: '<S2799>/Constant Value4'
         */
        VeESSR_dn_NiDotMinForAStop = -10000.0F;
        rtb_Summation_i = rtu_TransInSpdFlt;
    }
    else
    {
        /* Switch: '<S2799>/Switch3' incorporates:
         *  Constant: '<S2825>/Calib'
         *  MinMax: '<S2799>/MinMax1'
         */
        VeESSR_dn_NiDotMaxForAStop = fminf(KeESSR_dn_AStp_RmpDwn_NiDotMax,
            rtu_NiDotMax);

        /* Switch: '<S2799>/Switch5' incorporates:
         *  Constant: '<S2826>/Calib'
         *  MinMax: '<S2799>/MinMax2'
         */
        VeESSR_dn_NiDotMinForAStop = fmaxf(rtu_NiDotMin,
            KeESSR_dn_AStp_RmpDwn_NiDotMin);
        rtb_Summation_i = 0.0F;
    }

    /* End of Switch: '<S2799>/Switch3' */

    /* Gain: '<S2843>/Gain' incorporates:
     *  Abs: '<S2843>/Abs1'
     *  Constant: '<S2829>/Calib'
     */
    rtb_Gain_d = -fabsf(KeESSR_dn_RmpDwnJerkMin);

    /* Product: '<S2876>/Product4' incorporates:
     *  Constant: '<S2814>/Calib'
     */
    rtb_Product4 = rtb_Gain_d / HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2843>/LowpassT Reset Enabled' */
    /* Sum: '<S2874>/Summation' incorporates:
     *  Constant: '<S2814>/Calib'
     *  Constant: '<S2832>/Calib'
     *  DataStoreRead: '<S2799>/Dsr_Ni1stFlt_DS'
     *  MinMax: '<S2874>/Maximum'
     *  Product: '<S2874>/Multiplication'
     *  Product: '<S2874>/Multiplication1'
     *  Sum: '<S2874>/Subtraction'
     */
    rtb_Summation_i = (((rtb_Summation_i - VeESSR_n_Ni1stFlt_DS) *
                        HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                        (KeESSR_k_AsScndOrdLwPassT, HeESSR_t_MedTEB_dT))) +
        VeESSR_n_Ni1stFlt_DS;

    /* End of Outputs for SubSystem: '<S2843>/LowpassT Reset Enabled' */

    /* Outputs for Atomic SubSystem: '<S2843>/LowpassT Reset Enabled1' */
    /* Sum: '<S2875>/Summation' incorporates:
     *  Constant: '<S2814>/Calib'
     *  Constant: '<S2831>/Calib'
     *  DataStoreRead: '<S2799>/Dsr_InputSpeedProfile2'
     *  MinMax: '<S2875>/Maximum'
     *  Product: '<S2875>/Multiplication'
     *  Product: '<S2875>/Multiplication1'
     *  Sum: '<S2875>/Subtraction'
     */
    rtb_Summation_go = (((rtb_Summation_i - VeESSR_n_InputSpeedProfile_DS) *
                         HeESSR_t_MedTEB_dT) * (1.0F / fmaxf
                         (KeESSR_k_AsFrstOrdLwPassT, HeESSR_t_MedTEB_dT))) +
        VeESSR_n_InputSpeedProfile_DS;

    /* End of Outputs for SubSystem: '<S2843>/LowpassT Reset Enabled1' */

    /* RelationalOperator: '<S2799>/Comparison' incorporates:
     *  Constant: '<S2814>/Calib'
     *  DataStoreRead: '<S2799>/Dsr_STMTmr'
     */
    rtb_Comparison_id = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

    /* Switch: '<S2895>/Switch1' incorporates:
     *  UnitDelay: '<S2895>/Unit Delay'
     */
    if (rtb_Comparison_id)
    {
        rtb_Gain1_bp = rtb_Summation_go;
    }
    else
    {
        rtb_Gain1_bp = localDW->UnitDelay_DSTATE;
    }

    /* End of Switch: '<S2895>/Switch1' */

    /* Gain: '<S2876>/Gain1' incorporates:
     *  Sum: '<S2876>/Sum18'
     */
    rtb_Gain1_bp = (rtb_Summation_go + rtb_Gain1_bp) * 0.5F;

    /* Delay: '<S2876>/IntegerDelay' incorporates:
     *  Constant: '<S2885>/Calib'
     */
    if (rtb_Comparison_id && (((uint32)localZCE->IntegerDelay_Reset_ZCE) !=
                              POS_ZCSIG))
    {
        localDW->icLoad = 1U;
    }

    localZCE->IntegerDelay_Reset_ZCE = rtb_Comparison_id ? ((ZCSigState)1) :
        ((ZCSigState)0);
    if (((sint32)localDW->icLoad) != 0)
    {
        for (i = 0; i < 16; i++)
        {
            localDW->IntegerDelay_DSTATE[i] = rtb_Gain1_bp;
        }
    }

    if (((sint32)KeESSR_Cnt_DelayOptNi) <= 0)
    {
        /* Delay: '<S2876>/IntegerDelay' */
        rtb_IntegerDelay = rtb_Gain1_bp;
    }
    else
    {
        if (((sint32)KeESSR_Cnt_DelayOptNi) > 16)
        {
            tmp = 16U;
        }
        else
        {
            tmp = KeESSR_Cnt_DelayOptNi;
        }

        /* Delay: '<S2876>/IntegerDelay' */
        rtb_IntegerDelay = localDW->IntegerDelay_DSTATE[(uint8)(16U - ((uint32)
            tmp))];
    }

    /* End of Delay: '<S2876>/IntegerDelay' */

    /* Sum: '<S2876>/Sum15' incorporates:
     *  Abs: '<S2876>/Abs4'
     *  Constant: '<S2827>/Calib'
     *  DataStoreRead: '<S2799>/Dsr_InputSpeedProfile5'
     */
    rtb_Sum15 = fabsf(VeESSR_dn_TargetAcceltn_DS) + KeESSR_dn_NiTargetJerkLimit;

    /* Outputs for Atomic SubSystem: '<S2876>/GradientLimiter' */
    /* Sum: '<S2878>/Sum2' incorporates:
     *  Constant: '<S2814>/Calib'
     *  DataStoreRead: '<S2799>/Dsr_InputSpeedProfile4'
     *  Product: '<S2876>/Product6'
     *  Sum: '<S2876>/Sum14'
     *  UnitDelay: '<S2878>/Unit Delay'
     */
    rtb_Sum2_d0 = ((rtb_Gain1_bp - VeESSR_n_TargetSpeed_DS) / HeESSR_t_MedTEB_dT)
        - localDW->UnitDelay_DSTATE_l;

    /* Outputs for Atomic SubSystem: '<S2878>/Limiter' */
    /* Switch: '<S2896>/Switch1' incorporates:
     *  RelationalOperator: '<S2896>/Relational Operator'
     */
    if (rtb_Sum15 < rtb_Sum2_d0)
    {
        /* Merge: '<S2799>/Merge4' */
        rtb_Merge4_o = rtb_Sum15;
    }
    else
    {
        /* Merge: '<S2799>/Merge4' */
        rtb_Merge4_o = rtb_Sum2_d0;
    }

    /* End of Switch: '<S2896>/Switch1' */

    /* Switch: '<S2896>/Switch' incorporates:
     *  Gain: '<S2876>/Gain'
     *  RelationalOperator: '<S2896>/Relational Operator1'
     */
    if (rtb_Merge4_o <= (-rtb_Sum15))
    {
        rtb_Merge4_o = -rtb_Sum15;
    }

    /* End of Switch: '<S2896>/Switch' */
    /* End of Outputs for SubSystem: '<S2878>/Limiter' */

    /* Sum: '<S2878>/Sum3' incorporates:
     *  UnitDelay: '<S2878>/Unit Delay'
     */
    rtb_Gain_n3 = rtb_Merge4_o + localDW->UnitDelay_DSTATE_l;

    /* Update for UnitDelay: '<S2878>/Unit Delay' */
    localDW->UnitDelay_DSTATE_l = rtb_Gain_n3;

    /* End of Outputs for SubSystem: '<S2876>/GradientLimiter' */

    /* Sum: '<S2877>/Subtraction1' incorporates:
     *  Constant: '<S2833>/Calib'
     *  DataStoreRead: '<S2799>/Dsr_InputSpeedProfile5'
     *  Product: '<S2877>/Multiplication'
     *  Sum: '<S2877>/Subtraction'
     */
    rtb_Sum15 = ((rtb_Gain_n3 - VeESSR_dn_TargetAcceltn_DS) *
                 KeESSR_k_NiDotTargetFilt) + VeESSR_dn_TargetAcceltn_DS;

    /* DataStoreRead: '<S2799>/Dsr_InputAcceltnProf' */
    rtb_Gain_n3 = VeESSR_dn_InputAcceltnProf_DS;

    /* Abs: '<S2843>/Abs' incorporates:
     *  Constant: '<S2828>/Calib'
     */
    rtb_Sum2_d0 = fabsf(KeESSR_dn_RmpDwnJerkMax);

    /* Switch: '<S2907>/Switch1' incorporates:
     *  Constant: '<S2905>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S2907>/Switch1' incorporates:
         *  Constant: '<S2906>/Calib'
         */
        rtb_Switch1_cfe = HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S2894>/Sum6' incorporates:
         *  DataStoreRead: '<S2799>/Dsr_InputAcceltnProf'
         *  Sum: '<S2894>/Sum8'
         */
        rtb_Merge4_o = VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15;

        /* Abs: '<S2894>/Abs' incorporates:
         *  Sum: '<S2894>/Sum6'
         */
        rtb_Abs_pi = (rtb_Merge4_o - rtb_Gain_d) + rtb_Sum2_d0;

        /* MinMax: '<S2894>/MinMax2' incorporates:
         *  Abs: '<S2894>/Abs1'
         *  Constant: '<S2814>/Calib'
         *  Constant: '<S2894>/Constant Value'
         *  Constant: '<S2894>/Constant Value3'
         *  DataStoreRead: '<S2799>/Dsr_InputSpeedProfile2'
         *  Product: '<S2894>/Product2'
         *  Product: '<S2894>/Product7'
         *  Product: '<S2909>/Prod'
         *  Sum: '<S2894>/Sum3'
         *  Sum: '<S2894>/Sum5'
         */
        rtb_Abs_pi = fmaxf((fabsf((rtb_IntegerDelay -
                              VeESSR_n_InputSpeedProfile_DS) -
                             (HeESSR_t_MedTEB_dT * rtb_Sum15)) * (rtb_Product4 *
                             -2.0F)) - (rtb_Abs_pi * rtb_Abs_pi), 0.0F);

        /* Switch: '<S2911>/Switch' incorporates:
         *  Sqrt: '<S2911>/Sqrt'
         */
        rtb_Abs_pi = sqrtf(rtb_Abs_pi);

        /* Switch: '<S2907>/Switch1' incorporates:
         *  Abs: '<S2894>/Abs'
         *  Sum: '<S2894>/Sum7'
         *  Sum: '<S2894>/Sum8'
         */
        rtb_Switch1_cfe = fabsf(rtb_Merge4_o + rtb_Gain_d) + (rtb_Abs_pi +
            rtb_Sum15);
    }

    /* End of Switch: '<S2907>/Switch1' */

    /* Product: '<S2876>/Product1' incorporates:
     *  Constant: '<S2814>/Calib'
     */
    rtb_Abs_pi = rtb_Sum2_d0 / HeESSR_t_MedTEB_dT;

    /* Switch: '<S2908>/Switch1' incorporates:
     *  Constant: '<S2905>/Calib'
     */
    if (HeESSR_b_NiDotLmt4JerkOvrdEnbl)
    {
        /* Switch: '<S2908>/Switch1' incorporates:
         *  Constant: '<S2906>/Calib'
         *  Gain: '<S2894>/Gain1'
         */
        rtb_Switch1_b5 = -HeESSR_dn_NiDotLmt4JerkOvrdVal;
    }
    else
    {
        /* Sum: '<S2894>/Sum11' incorporates:
         *  DataStoreRead: '<S2799>/Dsr_InputAcceltnProf'
         *  Sum: '<S2894>/Sum13'
         */
        rtb_Switch_ab2 = VeESSR_dn_InputAcceltnProf_DS - rtb_Sum15;

        /* Abs: '<S2894>/Abs2' incorporates:
         *  Sum: '<S2894>/Sum11'
         */
        rtb_Merge4_o = (rtb_Switch_ab2 - rtb_Sum2_d0) + rtb_Gain_d;

        /* MinMax: '<S2894>/MinMax1' incorporates:
         *  Abs: '<S2894>/Abs3'
         *  Constant: '<S2814>/Calib'
         *  Constant: '<S2894>/Constant Value1'
         *  Constant: '<S2894>/Constant Value2'
         *  DataStoreRead: '<S2799>/Dsr_InputSpeedProfile2'
         *  Product: '<S2894>/Product5'
         *  Product: '<S2894>/Product8'
         *  Product: '<S2912>/Prod'
         *  Sum: '<S2894>/Sum10'
         *  Sum: '<S2894>/Sum9'
         */
        rtb_Merge4_o = fmaxf((fabsf((rtb_IntegerDelay -
                                VeESSR_n_InputSpeedProfile_DS) -
                               (HeESSR_t_MedTEB_dT * rtb_Sum15)) * (rtb_Abs_pi *
                               2.0F)) - (rtb_Merge4_o * rtb_Merge4_o), 0.0F);

        /* Switch: '<S2910>/Switch' incorporates:
         *  Sqrt: '<S2910>/Sqrt'
         */
        rtb_Merge4_o = sqrtf(rtb_Merge4_o);

        /* Switch: '<S2908>/Switch1' incorporates:
         *  Abs: '<S2894>/Abs2'
         *  Sum: '<S2894>/Sum12'
         *  Sum: '<S2894>/Sum13'
         */
        rtb_Switch1_b5 = (rtb_Sum15 - rtb_Merge4_o) - fabsf(rtb_Switch_ab2 +
            rtb_Sum2_d0);
    }

    /* End of Switch: '<S2908>/Switch1' */

    /* Switch: '<S2876>/Switch1' incorporates:
     *  Constant: '<S2881>/Calib'
     *  Constant: '<S2882>/Calib'
     *  DataStoreRead: '<S2799>/Data Store Read'
     *  DataStoreRead: '<S2799>/Dsr_InputSpeedProfile3'
     *  Logic: '<S2876>/Logical1'
     *  Logic: '<S2876>/Logical6'
     *  Logic: '<S2876>/Logical8'
     */
    if (((HeESSR_b_NiLmtBypsLoopJerk) && (VeESSR_b_NiMaxActive_DS)) ||
            ((VeESSR_b_NiDotMaxActive_DS) && (HeESSR_b_NiDotLmtBypsLoopJerk)))
    {
        /* Switch: '<S2876>/Switch1' */
        rtb_Sum2_d0 = rtb_Switch1_cfe;
    }
    else
    {
        /* Switch: '<S2876>/Switch1' incorporates:
         *  DataStoreRead: '<S2799>/Dsr_InputAcceltnProf'
         *  Sum: '<S2876>/Sum1'
         */
        rtb_Sum2_d0 += VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S2876>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S2876>/Limiter2' */
    /* Switch: '<S2889>/Switch1' incorporates:
     *  RelationalOperator: '<S2889>/Relational Operator'
     */
    if (rtb_Switch1_cfe < rtb_Sum2_d0)
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = rtb_Switch1_cfe;
    }

    /* End of Switch: '<S2889>/Switch1' */

    /* Switch: '<S2889>/Switch' incorporates:
     *  RelationalOperator: '<S2889>/Relational Operator1'
     */
    if (rtb_Sum2_d0 <= rtb_Switch1_b5)
    {
        /* Switch: '<S2889>/Switch' */
        rtb_Sum2_d0 = rtb_Switch1_b5;
    }

    /* End of Switch: '<S2889>/Switch' */
    /* End of Outputs for SubSystem: '<S2876>/Limiter2' */

    /* Outputs for Atomic SubSystem: '<S2876>/Limiter4' */
    /* Switch: '<S2891>/Switch1' incorporates:
     *  RelationalOperator: '<S2891>/Relational Operator'
     */
    if (VeESSR_dn_NiDotMaxForAStop < rtb_Sum2_d0)
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = VeESSR_dn_NiDotMaxForAStop;
    }

    /* End of Switch: '<S2891>/Switch1' */

    /* Switch: '<S2891>/Switch' incorporates:
     *  RelationalOperator: '<S2891>/Relational Operator1'
     */
    if (rtb_Sum2_d0 > VeESSR_dn_NiDotMinForAStop)
    {
        /* Switch: '<S2891>/Switch' */
        rtb_Switch_ab2 = rtb_Sum2_d0;
    }
    else
    {
        /* Switch: '<S2891>/Switch' */
        rtb_Switch_ab2 = VeESSR_dn_NiDotMinForAStop;
    }

    /* End of Switch: '<S2891>/Switch' */
    /* End of Outputs for SubSystem: '<S2876>/Limiter4' */

    /* Sum: '<S2880>/Sum6' incorporates:
     *  DataStoreRead: '<S2799>/Dsr_InputSpeedProfile2'
     */
    rtb_Sum6_j = rtu_VeHSER_n_NiMax - VeESSR_n_InputSpeedProfile_DS;

    /* Abs: '<S2880>/Abs2' */
    rtb_Sum2_d0 = fabsf(rtb_Sum6_j);

    /* Switch: '<S2880>/Switch' incorporates:
     *  Constant: '<S2880>/Constant Value7'
     *  RelationalOperator: '<S2880>/Comparison2'
     */
    if (rtb_Sum6_j < 0.0F)
    {
        /* Merge: '<S2799>/Merge4' incorporates:
         *  Abs: '<S2880>/Abs'
         */
        rtb_Merge4_o = fabsf(rtb_Abs_pi);
    }
    else
    {
        /* Merge: '<S2799>/Merge4' incorporates:
         *  Abs: '<S2880>/Abs1'
         *  Gain: '<S2880>/Gain'
         */
        rtb_Merge4_o = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S2880>/Switch' */

    /* Product: '<S2880>/Product4' incorporates:
     *  Constant: '<S2814>/Calib'
     */
    rtb_Product4_a = (rtb_Merge4_o * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2880>/Protected Division1' */
    /* Switch: '<S2903>/Switch1' incorporates:
     *  Constant: '<S2903>/Constant Value'
     *  Constant: '<S2903>/Constant Value1'
     *  Constant: '<S2903>/Constant Value2'
     *  Logic: '<S2903>/AND'
     *  RelationalOperator: '<S2903>/Greater Than or Equal '
     *  RelationalOperator: '<S2903>/Not Equal'
     *  RelationalOperator: '<S2903>/Not Equal1'
     *  Switch: '<S2903>/Switch2'
     */
    if ((rtb_Sum2_d0 != 0.0F) && (rtb_Product4_a != 0.0F))
    {
        /* Switch: '<S2903>/Switch1' incorporates:
         *  Product: '<S2903>/Division'
         */
        rtb_Sum2_d0 /= rtb_Product4_a;
    }
    else if (rtb_Sum2_d0 > 0.0F)
    {
        /* Switch: '<S2903>/Switch2' incorporates:
         *  Constant: '<S2903>/MAXFLOAT'
         *  Switch: '<S2903>/Switch1'
         */
        rtb_Sum2_d0 = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2903>/Switch1' incorporates:
         *  Constant: '<S2903>/Constant Value4'
         *  Switch: '<S2903>/Switch2'
         *  Switch: '<S2903>/Switch3'
         */
        rtb_Sum2_d0 = 0.0F;
    }

    /* End of Switch: '<S2903>/Switch1' */
    /* End of Outputs for SubSystem: '<S2880>/Protected Division1' */

    /* Sum: '<S2880>/Sum4' incorporates:
     *  Abs: '<S2880>/Abs3'
     *  Constant: '<S2880>/Constant Value3'
     *  Constant: '<S2880>/Constant Value5'
     *  Product: '<S2880>/Product3'
     */
    rtb_Sum2_d0 = (fabsf(rtb_Sum2_d0) * 8.0F) + 1.0F;

    /* Switch: '<S2904>/Switch' */
    if (rtb_Sum2_d0 >= 0.0F)
    {
        /* Switch: '<S2868>/Switch1' incorporates:
         *  Sqrt: '<S2904>/Sqrt'
         */
        rtb_Sum2_d0 = sqrtf(rtb_Sum2_d0);
    }
    else
    {
        /* Switch: '<S2868>/Switch1' incorporates:
         *  Constant: '<S2904>/Zero'
         */
        rtb_Sum2_d0 = 0.0F;
    }

    /* End of Switch: '<S2904>/Switch' */

    /* Switch: '<S2868>/Switch1' incorporates:
     *  Constant: '<S2880>/Constant Value'
     *  Constant: '<S2880>/Constant Value4'
     *  Constant: '<S2880>/Constant Value6'
     *  MinMax: '<S2880>/MinMax1'
     *  Product: '<S2880>/Product2'
     *  Rounding: '<S2880>/Rounding1'
     *  Sum: '<S2880>/Sum3'
     */
    rtb_Sum2_d0 = fmaxf(ceilf((rtb_Sum2_d0 - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S2880>/Product' incorporates:
     *  Constant: '<S2814>/Calib'
     */
    rtb_Product4_a = rtb_Sum2_d0 * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2880>/Protected Division' */
    /* Switch: '<S2902>/Switch1' incorporates:
     *  Constant: '<S2902>/Constant Value'
     *  Constant: '<S2902>/Constant Value1'
     *  Constant: '<S2902>/Constant Value2'
     *  Constant: '<S2902>/Constant Value3'
     *  Logic: '<S2902>/AND'
     *  RelationalOperator: '<S2902>/Greater Than or Equal '
     *  RelationalOperator: '<S2902>/Greater Than or Equal 1'
     *  RelationalOperator: '<S2902>/Not Equal'
     *  RelationalOperator: '<S2902>/Not Equal1'
     *  Switch: '<S2902>/Switch2'
     *  Switch: '<S2902>/Switch3'
     */
    if ((rtb_Sum6_j != 0.0F) && (rtb_Product4_a != 0.0F))
    {
        /* Switch: '<S2902>/Switch1' incorporates:
         *  Product: '<S2902>/Division'
         */
        rtb_Sum6_j /= rtb_Product4_a;
    }
    else if (rtb_Sum6_j > 0.0F)
    {
        /* Switch: '<S2902>/Switch2' incorporates:
         *  Constant: '<S2902>/MAXFLOAT'
         *  Switch: '<S2902>/Switch1'
         */
        rtb_Sum6_j = 3.402823466E+38F;
    }
    else if (rtb_Sum6_j < 0.0F)
    {
        /* Switch: '<S2902>/Switch3' incorporates:
         *  Constant: '<S2902>/MINFLOAT'
         *  Switch: '<S2902>/Switch1'
         *  Switch: '<S2902>/Switch2'
         */
        rtb_Sum6_j = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2902>/Switch1' incorporates:
         *  Constant: '<S2902>/Constant Value4'
         *  Switch: '<S2902>/Switch2'
         *  Switch: '<S2902>/Switch3'
         */
        rtb_Sum6_j = 0.0F;
    }

    /* End of Switch: '<S2902>/Switch1' */
    /* End of Outputs for SubSystem: '<S2880>/Protected Division' */

    /* Sum: '<S2880>/Sum' incorporates:
     *  Constant: '<S2814>/Calib'
     *  Constant: '<S2880>/Constant Value1'
     *  Constant: '<S2880>/Constant Value2'
     *  Product: '<S2880>/Product1'
     *  Sum: '<S2880>/Sum2'
     */
    rtb_Merge4_o = rtb_Sum6_j - (((0.5F * rtb_Merge4_o) * (rtb_Sum2_d0 - 1.0F)) *
        HeESSR_t_MedTEB_dT);

    /* Switch: '<S2876>/Switch4' incorporates:
     *  Constant: '<S2883>/Calib'
     */
    if (!HeESSR_b_NiLmtForAccelByps)
    {
        /* Switch: '<S2876>/Switch4' incorporates:
         *  MinMax: '<S2876>/MinMax1'
         */
        rtb_Switch_ab2 = fminf(rtb_Merge4_o, rtb_Switch_ab2);
    }

    /* End of Switch: '<S2876>/Switch4' */

    /* Outputs for Atomic SubSystem: '<S2876>/Limiter13' */
    /* RelationalOperator: '<S2888>/Relational Operator' */
    rtb_RelationalOperator_jnm = (rtu_NiDotMax <= rtb_Switch_ab2);

    /* Switch: '<S2888>/Switch1' */
    if (rtb_RelationalOperator_jnm)
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = rtu_NiDotMax;
    }
    else
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = rtb_Switch_ab2;
    }

    /* End of Switch: '<S2888>/Switch1' */

    /* Switch: '<S2888>/Switch' incorporates:
     *  RelationalOperator: '<S2888>/Relational Operator1'
     */
    if (rtb_Sum2_d0 <= rtu_NiDotMin)
    {
        rtb_Sum2_d0 = rtu_NiDotMin;
    }

    /* End of Switch: '<S2888>/Switch' */
    /* End of Outputs for SubSystem: '<S2876>/Limiter13' */

    /* Product: '<S2876>/Product9' incorporates:
     *  Constant: '<S2814>/Calib'
     */
    rtb_Switch_ab2 = rtb_Sum2_d0 * HeESSR_t_MedTEB_dT;

    /* Switch: '<S2876>/Switch2' incorporates:
     *  Constant: '<S2881>/Calib'
     *  DataStoreRead: '<S2799>/Dsr_InputSpeedProfile6'
     *  Logic: '<S2876>/Logical3'
     */
    if ((HeESSR_b_NiDotLmtBypsLoopJerk) && (VeESSR_b_NiDotMinActive_DS))
    {
        /* Switch: '<S2876>/Switch2' */
        rtb_Sum2_d0 = rtb_Switch1_b5;
    }
    else
    {
        /* Switch: '<S2876>/Switch2' incorporates:
         *  DataStoreRead: '<S2799>/Dsr_InputAcceltnProf'
         *  Sum: '<S2876>/Sum16'
         */
        rtb_Sum2_d0 = VeESSR_dn_InputAcceltnProf_DS + rtb_Gain_d;
    }

    /* End of Switch: '<S2876>/Switch2' */

    /* Outputs for Atomic SubSystem: '<S2876>/Limiter' */
    /* Switch: '<S2886>/Switch1' incorporates:
     *  RelationalOperator: '<S2886>/Relational Operator'
     */
    if (rtb_Switch1_cfe < rtb_Sum2_d0)
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = rtb_Switch1_cfe;
    }

    /* End of Switch: '<S2886>/Switch1' */

    /* Switch: '<S2886>/Switch' incorporates:
     *  RelationalOperator: '<S2886>/Relational Operator1'
     */
    if (rtb_Sum2_d0 <= rtb_Switch1_b5)
    {
        /* Switch: '<S2886>/Switch' */
        rtb_Sum2_d0 = rtb_Switch1_b5;
    }

    /* End of Switch: '<S2886>/Switch' */
    /* End of Outputs for SubSystem: '<S2876>/Limiter' */

    /* Outputs for Atomic SubSystem: '<S2876>/Limiter3' */
    /* Switch: '<S2890>/Switch1' incorporates:
     *  RelationalOperator: '<S2890>/Relational Operator'
     */
    if (VeESSR_dn_NiDotMaxForAStop < rtb_Sum2_d0)
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = VeESSR_dn_NiDotMaxForAStop;
    }

    /* End of Switch: '<S2890>/Switch1' */
    /* End of Outputs for SubSystem: '<S2876>/Limiter3' */

    /* Switch: '<S2876>/Switch5' incorporates:
     *  Constant: '<S2883>/Calib'
     *  RelationalOperator: '<S2890>/Relational Operator1'
     *  Switch: '<S2890>/Switch'
     */
    if (HeESSR_b_NiLmtForAccelByps)
    {
        /* Outputs for Atomic SubSystem: '<S2876>/Limiter3' */
        /* Switch: '<S2890>/Switch' incorporates:
         *  RelationalOperator: '<S2890>/Relational Operator1'
         */
        if (rtb_Sum2_d0 <= VeESSR_dn_NiDotMinForAStop)
        {
            /* Switch: '<S2876>/Switch5' */
            rtb_Sum2_d0 = VeESSR_dn_NiDotMinForAStop;
        }

        /* End of Outputs for SubSystem: '<S2876>/Limiter3' */
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S2876>/Limiter3' */
        if (rtb_Sum2_d0 <= VeESSR_dn_NiDotMinForAStop)
        {
            /* Switch: '<S2890>/Switch' */
            rtb_Sum2_d0 = VeESSR_dn_NiDotMinForAStop;
        }

        /* End of Outputs for SubSystem: '<S2876>/Limiter3' */

        /* Switch: '<S2876>/Switch5' incorporates:
         *  MinMax: '<S2876>/MinMax2'
         */
        rtb_Sum2_d0 = fminf(rtb_Merge4_o, rtb_Sum2_d0);
    }

    /* End of Switch: '<S2876>/Switch5' */

    /* Outputs for Atomic SubSystem: '<S2876>/Limiter9' */
    /* Switch: '<S2893>/Switch1' incorporates:
     *  RelationalOperator: '<S2893>/Relational Operator'
     */
    if (rtu_NiDotMax <= rtb_Sum2_d0)
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = rtu_NiDotMax;
    }

    /* End of Switch: '<S2893>/Switch1' */

    /* Logic: '<S2799>/Logical8' incorporates:
     *  RelationalOperator: '<S2893>/Relational Operator1'
     */
    rtb_Comparison_id = (rtb_Sum2_d0 > rtu_NiDotMin);

    /* Logic: '<S2893>/Logical2' */
    rtb_Logical2_ls = !rtb_Comparison_id;

    /* Switch: '<S2893>/Switch' */
    if (!rtb_Comparison_id)
    {
        rtb_Sum2_d0 = rtu_NiDotMin;
    }

    /* End of Switch: '<S2893>/Switch' */
    /* End of Outputs for SubSystem: '<S2876>/Limiter9' */

    /* Product: '<S2876>/Product10' incorporates:
     *  Constant: '<S2814>/Calib'
     */
    rtb_Gain_d = rtb_Sum2_d0 * HeESSR_t_MedTEB_dT;

    /* Sum: '<S2876>/Sum2' incorporates:
     *  DataStoreRead: '<S2799>/Dsr_InputSpeedProfile2'
     */
    rtb_Switch1_cfe = rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS;

    /* Sum: '<S2879>/Sum6' incorporates:
     *  Constant: '<S2814>/Calib'
     *  DataStoreRead: '<S2799>/Dsr_InputSpeedProfile2'
     *  Product: '<S2879>/Product7'
     *  Sum: '<S2876>/Sum6'
     *  Switch: '<S2876>/Switch3'
     */
    rtb_IntegerDelay = (rtb_IntegerDelay - VeESSR_n_InputSpeedProfile_DS) -
        (rtb_Sum15 * HeESSR_t_MedTEB_dT);

    /* Abs: '<S2879>/Abs2' incorporates:
     *  Sum: '<S2879>/Sum6'
     */
    rtb_Merge4_o = fabsf(rtb_IntegerDelay);

    /* Switch: '<S2879>/Switch' incorporates:
     *  Constant: '<S2879>/Constant Value7'
     *  RelationalOperator: '<S2879>/Comparison2'
     *  Sum: '<S2879>/Sum6'
     */
    if (rtb_IntegerDelay < 0.0F)
    {
        /* Switch: '<S2868>/Switch1' incorporates:
         *  Abs: '<S2879>/Abs'
         */
        rtb_Sum2_d0 = fabsf(rtb_Abs_pi);
    }
    else
    {
        /* Switch: '<S2868>/Switch1' incorporates:
         *  Abs: '<S2879>/Abs1'
         *  Gain: '<S2879>/Gain'
         */
        rtb_Sum2_d0 = -fabsf(rtb_Product4);
    }

    /* End of Switch: '<S2879>/Switch' */

    /* Product: '<S2879>/Product4' incorporates:
     *  Constant: '<S2814>/Calib'
     */
    rtb_Product4 = (rtb_Sum2_d0 * HeESSR_t_MedTEB_dT) * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2879>/Protected Division1' */
    /* Switch: '<S2899>/Switch1' incorporates:
     *  Constant: '<S2899>/Constant Value'
     *  Constant: '<S2899>/Constant Value1'
     *  Constant: '<S2899>/Constant Value2'
     *  Logic: '<S2899>/AND'
     *  RelationalOperator: '<S2899>/Greater Than or Equal '
     *  RelationalOperator: '<S2899>/Not Equal'
     *  RelationalOperator: '<S2899>/Not Equal1'
     *  Switch: '<S2899>/Switch2'
     */
    if ((rtb_Merge4_o != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S2899>/Switch1' incorporates:
         *  Product: '<S2899>/Division'
         */
        rtb_Product4 = rtb_Merge4_o / rtb_Product4;
    }
    else if (rtb_Merge4_o > 0.0F)
    {
        /* Switch: '<S2899>/Switch2' incorporates:
         *  Constant: '<S2899>/MAXFLOAT'
         *  Switch: '<S2899>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2899>/Switch1' incorporates:
         *  Constant: '<S2899>/Constant Value4'
         *  Switch: '<S2899>/Switch2'
         *  Switch: '<S2899>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S2899>/Switch1' */
    /* End of Outputs for SubSystem: '<S2879>/Protected Division1' */

    /* Sum: '<S2879>/Sum4' incorporates:
     *  Abs: '<S2879>/Abs3'
     *  Constant: '<S2879>/Constant Value3'
     *  Constant: '<S2879>/Constant Value5'
     *  Product: '<S2879>/Product3'
     */
    rtb_Product4 = (fabsf(rtb_Product4) * 8.0F) + 1.0F;

    /* Switch: '<S2900>/Switch' incorporates:
     *  Constant: '<S2900>/Zero'
     *  Sqrt: '<S2900>/Sqrt'
     */
    if (rtb_Product4 >= 0.0F)
    {
        rtb_Product4 = sqrtf(rtb_Product4);
    }
    else
    {
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S2900>/Switch' */

    /* Merge: '<S2799>/Merge4' incorporates:
     *  Constant: '<S2879>/Constant Value'
     *  Constant: '<S2879>/Constant Value4'
     *  Constant: '<S2879>/Constant Value6'
     *  MinMax: '<S2879>/MinMax1'
     *  Product: '<S2879>/Product2'
     *  Rounding: '<S2879>/Rounding1'
     *  Sum: '<S2879>/Sum3'
     */
    rtb_Merge4_o = fmaxf(ceilf((rtb_Product4 - 1.0F) * 0.5F), 1.0F);

    /* Product: '<S2879>/Product' incorporates:
     *  Constant: '<S2814>/Calib'
     */
    rtb_Product4 = rtb_Merge4_o * HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2879>/Protected Division' */
    /* Switch: '<S2898>/Switch1' incorporates:
     *  Constant: '<S2898>/Constant Value'
     *  Constant: '<S2898>/Constant Value1'
     *  Constant: '<S2898>/Constant Value2'
     *  Constant: '<S2898>/Constant Value3'
     *  Logic: '<S2898>/AND'
     *  RelationalOperator: '<S2898>/Greater Than or Equal '
     *  RelationalOperator: '<S2898>/Greater Than or Equal 1'
     *  RelationalOperator: '<S2898>/Not Equal'
     *  RelationalOperator: '<S2898>/Not Equal1'
     *  Sum: '<S2879>/Sum6'
     *  Switch: '<S2898>/Switch2'
     *  Switch: '<S2898>/Switch3'
     */
    if ((rtb_IntegerDelay != 0.0F) && (rtb_Product4 != 0.0F))
    {
        /* Switch: '<S2898>/Switch1' incorporates:
         *  Product: '<S2898>/Division'
         */
        rtb_Product4 = rtb_IntegerDelay / rtb_Product4;
    }
    else if (rtb_IntegerDelay > 0.0F)
    {
        /* Switch: '<S2898>/Switch2' incorporates:
         *  Constant: '<S2898>/MAXFLOAT'
         *  Switch: '<S2898>/Switch1'
         */
        rtb_Product4 = 3.402823466E+38F;
    }
    else if (rtb_IntegerDelay < 0.0F)
    {
        /* Switch: '<S2898>/Switch3' incorporates:
         *  Constant: '<S2898>/MINFLOAT'
         *  Switch: '<S2898>/Switch1'
         *  Switch: '<S2898>/Switch2'
         */
        rtb_Product4 = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2898>/Switch1' incorporates:
         *  Constant: '<S2898>/Constant Value4'
         *  Switch: '<S2898>/Switch2'
         *  Switch: '<S2898>/Switch3'
         */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S2898>/Switch1' */
    /* End of Outputs for SubSystem: '<S2879>/Protected Division' */

    /* Switch: '<S2876>/Switch3' incorporates:
     *  Constant: '<S2884>/Calib'
     */
    if (!HeESSR_b_TrnstnJerkByps)
    {
        /* Switch: '<S2876>/Switch8' incorporates:
         *  Constant: '<S2876>/Constant Value7'
         *  RelationalOperator: '<S2876>/Comparison'
         */
        if (rtb_IntegerDelay > 0.0F)
        {
            /* Switch: '<S2876>/Switch3' incorporates:
             *  Constant: '<S2814>/Calib'
             *  Constant: '<S2879>/Constant Value1'
             *  Constant: '<S2879>/Constant Value2'
             *  MinMax: '<S2876>/MinMax4'
             *  Product: '<S2876>/Product5'
             *  Product: '<S2879>/Product1'
             *  Sum: '<S2879>/Sum'
             *  Sum: '<S2879>/Sum2'
             *  Switch: '<S2876>/Switch8'
             */
            rtb_Switch1_cfe = fminf(rtb_Switch1_cfe, ((rtb_Product4 + rtb_Sum15)
                - (((0.5F * rtb_Sum2_d0) * (rtb_Merge4_o - 1.0F)) *
                   HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }
        else
        {
            /* Switch: '<S2876>/Switch3' incorporates:
             *  Constant: '<S2814>/Calib'
             *  Constant: '<S2879>/Constant Value1'
             *  Constant: '<S2879>/Constant Value2'
             *  MinMax: '<S2876>/MinMax5'
             *  Product: '<S2876>/Product2'
             *  Product: '<S2879>/Product1'
             *  Sum: '<S2879>/Sum'
             *  Sum: '<S2879>/Sum2'
             *  Switch: '<S2876>/Switch8'
             */
            rtb_Switch1_cfe = fmaxf(rtb_Switch1_cfe, ((rtb_Product4 + rtb_Sum15)
                - (((0.5F * rtb_Sum2_d0) * (rtb_Merge4_o - 1.0F)) *
                   HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT);
        }

        /* End of Switch: '<S2876>/Switch8' */
    }

    /* Outputs for Atomic SubSystem: '<S2876>/Limiter6' */
    /* RelationalOperator: '<S2892>/Relational Operator' */
    rtb_RelationalOperator_ppl = (rtb_Switch_ab2 <= rtb_Switch1_cfe);

    /* Switch: '<S2892>/Switch1' */
    if (rtb_RelationalOperator_ppl)
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = rtb_Switch_ab2;
    }
    else
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = rtb_Switch1_cfe;
    }

    /* End of Switch: '<S2892>/Switch1' */

    /* Logic: '<S2799>/Logical8' incorporates:
     *  RelationalOperator: '<S2892>/Relational Operator1'
     */
    rtb_Comparison_id = (rtb_Sum2_d0 > rtb_Gain_d);

    /* Switch: '<S2892>/Switch' */
    if (rtb_Comparison_id)
    {
        rtb_Gain_d = rtb_Sum2_d0;
    }

    /* End of Switch: '<S2892>/Switch' */
    /* End of Outputs for SubSystem: '<S2876>/Limiter6' */

    /* Sum: '<S2876>/Sum4' incorporates:
     *  DataStoreRead: '<S2799>/Dsr_InputSpeedProfile2'
     */
    rtb_IntegerDelay = rtb_Gain_d + VeESSR_n_InputSpeedProfile_DS;

    /* Outputs for Atomic SubSystem: '<S2876>/Limiter1' */
    /* RelationalOperator: '<S2887>/Relational Operator' incorporates:
     *  DataStoreWrite: '<S2799>/Dsw_InputSpeedProfile5'
     */
    VeESSR_b_NiMaxActive_DS = (rtu_VeHSER_n_NiMax <= rtb_IntegerDelay);

    /* Switch: '<S2887>/Switch1' incorporates:
     *  DataStoreWrite: '<S2799>/Dsw_InputSpeedProfile5'
     */
    if (VeESSR_b_NiMaxActive_DS)
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = rtu_VeHSER_n_NiMax;
    }
    else
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = rtb_IntegerDelay;
    }

    /* End of Switch: '<S2887>/Switch1' */

    /* Switch: '<S2887>/Switch' incorporates:
     *  Constant: '<S2876>/Constant Value4'
     *  RelationalOperator: '<S2887>/Relational Operator1'
     */
    if (rtb_Sum2_d0 > 0.0F)
    {
        /* Switch: '<S2887>/Switch' */
        rtb_Product4 = rtb_Sum2_d0;
    }
    else
    {
        /* Switch: '<S2887>/Switch' */
        rtb_Product4 = 0.0F;
    }

    /* End of Switch: '<S2887>/Switch' */
    /* End of Outputs for SubSystem: '<S2876>/Limiter1' */

    /* Product: '<S2876>/Product3' incorporates:
     *  Constant: '<S2814>/Calib'
     *  DataStoreRead: '<S2799>/Dsr_InputSpeedProfile2'
     *  Sum: '<S2876>/Sum'
     */
    rtb_IntegerDelay = (rtb_Product4 - VeESSR_n_InputSpeedProfile_DS) /
        HeESSR_t_MedTEB_dT;

    /* Outputs for Atomic SubSystem: '<S2799>/Target_Angle_Stop' */
    /* DataStoreRead: '<S2846>/Dsr_EngAng720EstOld' */
    rtb_Sum2_d0 = VeESSR_phi_EngAng720EstOld_DS;

    /* DataStoreWrite: '<S2846>/Dsw_EngAng720EstOld' */
    VeESSR_phi_EngAng720EstOld_DS = rtu_EngAngle720Est;

    /* Sum: '<S2919>/Summation3' */
    rtb_Gain_d = rtu_EngAngle720Est - rtb_Sum2_d0;

    /* If: '<S2919>/If' */
    if (rtb_Gain_d > 360.0F)
    {
        /* Outputs for IfAction SubSystem: '<S2919>/Sub720' incorporates:
         *  ActionPort: '<S2954>/Action Port'
         */
        ESSR_ac_Sub720(rtb_Gain_d, &rtb_Sum2_d0);

        /* End of Outputs for SubSystem: '<S2919>/Sub720' */
    }
    else if (rtb_Gain_d < -360.0F)
    {
        /* Outputs for IfAction SubSystem: '<S2919>/Add720' incorporates:
         *  ActionPort: '<S2952>/Action Port'
         */
        ESSR_ac_Add720(rtb_Gain_d, &rtb_Sum2_d0);

        /* End of Outputs for SubSystem: '<S2919>/Add720' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2919>/PassThrough' incorporates:
         *  ActionPort: '<S2953>/Action Port'
         */
        ESSR_ac_PassThrough(rtb_Gain_d, &rtb_Sum2_d0);

        /* End of Outputs for SubSystem: '<S2919>/PassThrough' */
    }

    /* End of If: '<S2919>/If' */

    /* Sum: '<S2919>/Summation4' incorporates:
     *  DataStoreRead: '<S2846>/Dsr_EngStpAngleElpsd'
     */
    rtb_Sum2_d0 += VeESSR_phi_EngStpAngleElpsd_DS;

    /* DataStoreWrite: '<S2846>/Dsw_EngStpAngleElpsd' */
    VeESSR_phi_EngStpAngleElpsd_DS = rtb_Sum2_d0;

    /* DataStoreRead: '<S2846>/Dsr_EngStpProfCntr' */
    rtb_Gain_d = VeESSR_Cnt_EngStpProfCntr_DS;

    /* Outputs for Atomic SubSystem: '<S2846>/AdjstPrfIncrmnt' */
    /* Sum: '<S2915>/Subtraction' incorporates:
     *  DataStoreRead: '<S2915>/Dsr_EngStpRmpDwnStrtAng'
     */
    VeESSR_phi_ActAngRemainingRaw = VeESSR_phi_EngStpAngleElpsdDes_DS -
        rtb_Sum2_d0;

    /* If: '<S2920>/If' incorporates:
     *  Constant: '<S2931>/Calib'
     *  DataStoreRead: '<S2846>/Dsr_EngStpProfCntr'
     *  Lookup_n-D: '<S2932>/Vector'
     */
    if (KeESSR_b_EngStpProfUseAngAdpt)
    {
        /* Outputs for IfAction SubSystem: '<S2920>/UsingAdapt' incorporates:
         *  ActionPort: '<S2935>/Action Port'
         */
        ESSR_ac_UsingAdapt(look1_iflf_binlcapw(VeESSR_Cnt_EngStpProfCntr_DS, ((
                              const float32 *)&(KxESSR_k_EngStpAngleFactor[0])),
                            ((const float32 *)&(KtESSR_k_EngStpAngleFactor[0])),
                            40U), &rtb_Sum2_d0, rtd_NeESSR_k_EngStpProfAngAdpt);

        /* End of Outputs for SubSystem: '<S2920>/UsingAdapt' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2920>/PassThrough' incorporates:
         *  ActionPort: '<S2934>/Action Port'
         */
        ESSR_ac_PassThrough(look1_iflf_binlcapw(VeESSR_Cnt_EngStpProfCntr_DS, ((
                               const float32 *)&(KxESSR_k_EngStpAngleFactor[0])),
                             ((const float32 *)&(KtESSR_k_EngStpAngleFactor[0])),
                             40U), &rtb_Sum2_d0);

        /* End of Outputs for SubSystem: '<S2920>/PassThrough' */
    }

    /* End of If: '<S2920>/If' */

    /* Switch: '<S2922>/Switch1' incorporates:
     *  Constant: '<S2915>/Constant Value1'
     *  Constant: '<S2924>/Calib'
     *  Constant: '<S2925>/Calib'
     *  RelationalOperator: '<S2915>/Comparison1'
     */
    if (rtu_EntrySpd > KeESSR_v_RampDownEntrySpd)
    {
        rtb_Abs_pi = KeESSR_scl_RampDownNiMultiply;
    }
    else
    {
        rtb_Abs_pi = 1.0F;
    }

    /* End of Switch: '<S2922>/Switch1' */

    /* Product: '<S2915>/Product2' incorporates:
     *  DataStoreRead: '<S2915>/Dsr_EngStpProfCntr_Inc1'
     */
    rtb_Abs_pi *= VeESSR_Cnt_EngStpProfCntrInit_DS;

    /* Outputs for Atomic SubSystem: '<S2915>/Protected Division' */
    /* Switch: '<S2928>/Switch1' incorporates:
     *  Constant: '<S2921>/Calib'
     *  Constant: '<S2928>/Constant Value'
     *  Constant: '<S2928>/Constant Value1'
     *  Constant: '<S2928>/Constant Value2'
     *  Constant: '<S2928>/Constant Value3'
     *  DataStoreRead: '<S2915>/Dsr_EngStpProfCntr_Inc'
     *  Logic: '<S2928>/AND'
     *  RelationalOperator: '<S2928>/Greater Than or Equal '
     *  RelationalOperator: '<S2928>/Greater Than or Equal 1'
     *  RelationalOperator: '<S2928>/Not Equal'
     *  RelationalOperator: '<S2928>/Not Equal1'
     *  Switch: '<S2928>/Switch2'
     *  Switch: '<S2928>/Switch3'
     */
    if ((HeESSR_t_MedTEB_dT != 0.0F) && (VeESSR_Cnt_EngStpProfCntrInit_DS !=
            0.0F))
    {
        /* Switch: '<S2928>/Switch1' incorporates:
         *  Product: '<S2928>/Division'
         */
        rtb_Merge4_o = HeESSR_t_MedTEB_dT / VeESSR_Cnt_EngStpProfCntrInit_DS;
    }
    else if (HeESSR_t_MedTEB_dT > 0.0F)
    {
        /* Switch: '<S2928>/Switch2' incorporates:
         *  Constant: '<S2928>/MAXFLOAT'
         *  Switch: '<S2928>/Switch1'
         */
        rtb_Merge4_o = 3.402823466E+38F;
    }
    else if (HeESSR_t_MedTEB_dT < 0.0F)
    {
        /* Switch: '<S2928>/Switch3' incorporates:
         *  Constant: '<S2928>/MINFLOAT'
         *  Switch: '<S2928>/Switch1'
         *  Switch: '<S2928>/Switch2'
         */
        rtb_Merge4_o = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2928>/Switch1' incorporates:
         *  Constant: '<S2928>/Constant Value4'
         *  Switch: '<S2928>/Switch2'
         *  Switch: '<S2928>/Switch3'
         */
        rtb_Merge4_o = 0.0F;
    }

    /* End of Switch: '<S2928>/Switch1' */
    /* End of Outputs for SubSystem: '<S2915>/Protected Division' */

    /* Product: '<S2915>/Multiplication' */
    VeESSR_phi_ProfAngRemaining = (rtu_InitEngSpd * rtb_Sum2_d0) * rtb_Merge4_o;

    /* If: '<S2915>/If1' incorporates:
     *  Constant: '<S2915>/Constant Value'
     *  RelationalOperator: '<S2915>/Comparison'
     */
    if (VeESSR_phi_ActAngRemainingRaw > 0.0F)
    {
        /* Outputs for IfAction SubSystem: '<S2915>/Normal' incorporates:
         *  ActionPort: '<S2926>/Action Port'
         */
        /* Outputs for Atomic SubSystem: '<S2926>/Protected Division' */
        /* Switch: '<S2936>/Switch1' incorporates:
         *  Constant: '<S2926>/Constant Value'
         *  Constant: '<S2936>/Constant Value'
         *  Constant: '<S2936>/Constant Value1'
         *  Constant: '<S2936>/Constant Value2'
         *  Constant: '<S2936>/Constant Value3'
         *  Logic: '<S2936>/AND'
         *  RelationalOperator: '<S2936>/Greater Than or Equal '
         *  RelationalOperator: '<S2936>/Greater Than or Equal 1'
         *  RelationalOperator: '<S2936>/Not Equal'
         *  RelationalOperator: '<S2936>/Not Equal1'
         *  Sum: '<S2926>/Sum'
         *  Switch: '<S2936>/Switch2'
         *  Switch: '<S2936>/Switch3'
         */
        if (((VeESSR_phi_ProfAngRemaining + 0.01F) != 0.0F) &&
                (VeESSR_phi_ActAngRemainingRaw != 0.0F))
        {
            /* Merge: '<S2915>/Merge2' incorporates:
             *  Product: '<S2936>/Division'
             */
            VeESSR_k_AngleRatioRaw = (VeESSR_phi_ProfAngRemaining + 0.01F) /
                VeESSR_phi_ActAngRemainingRaw;
        }
        else if ((VeESSR_phi_ProfAngRemaining + 0.01F) > 0.0F)
        {
            /* Switch: '<S2936>/Switch2' incorporates:
             *  Constant: '<S2936>/MAXFLOAT'
             *  Merge: '<S2915>/Merge2'
             */
            VeESSR_k_AngleRatioRaw = 3.402823466E+38F;
        }
        else if ((VeESSR_phi_ProfAngRemaining + 0.01F) < 0.0F)
        {
            /* Switch: '<S2936>/Switch3' incorporates:
             *  Constant: '<S2936>/MINFLOAT'
             *  Merge: '<S2915>/Merge2'
             *  Switch: '<S2936>/Switch2'
             */
            VeESSR_k_AngleRatioRaw = -3.402823466E+38F;
        }
        else
        {
            /* Merge: '<S2915>/Merge2' incorporates:
             *  Constant: '<S2936>/Constant Value4'
             *  Switch: '<S2936>/Switch2'
             *  Switch: '<S2936>/Switch3'
             */
            VeESSR_k_AngleRatioRaw = 0.0F;
        }

        /* End of Switch: '<S2936>/Switch1' */
        /* End of Outputs for SubSystem: '<S2926>/Protected Division' */
        /* End of Outputs for SubSystem: '<S2915>/Normal' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2915>/Overshoot' incorporates:
         *  ActionPort: '<S2927>/Action Port'
         */
        /* Merge: '<S2915>/Merge2' incorporates:
         *  Constant: '<S2927>/Constant Value1'
         *  SignalConversion generated from: '<S2927>/Out'
         */
        VeESSR_k_AngleRatioRaw = 99.0F;

        /* End of Outputs for SubSystem: '<S2915>/Overshoot' */
    }

    /* End of If: '<S2915>/If1' */

    /* If: '<S2915>/If' incorporates:
     *  Constant: '<S2923>/Calib'
     *  Constant: '<S2930>/Constant Value1'
     *  RelationalOperator: '<S2930>/Less  Than'
     *  Switch: '<S2930>/Switch'
     */
    if (KeESSR_b_EngStpProfUseNiDotGain)
    {
        /* Outputs for IfAction SubSystem: '<S2915>/Use_NiDotGain_Method' incorporates:
         *  ActionPort: '<S2929>/Action Port'
         */
        /* Outputs for Atomic SubSystem: '<S2929>/Limiter1' */
        /* Switch: '<S2941>/Switch1' incorporates:
         *  Constant: '<S2937>/Calib'
         *  RelationalOperator: '<S2941>/Relational Operator'
         */
        if (KeESSR_k_EngStpProfNiDotGainMax < VeESSR_k_AngleRatioRaw)
        {
            /* Sum: '<S2942>/Sum' */
            rtb_Sum2_d0 = KeESSR_k_EngStpProfNiDotGainMax;
        }
        else
        {
            /* Sum: '<S2942>/Sum' */
            rtb_Sum2_d0 = VeESSR_k_AngleRatioRaw;
        }

        /* End of Switch: '<S2941>/Switch1' */

        /* Switch: '<S2941>/Switch' incorporates:
         *  Constant: '<S2938>/Calib'
         *  RelationalOperator: '<S2941>/Relational Operator1'
         */
        if (rtb_Sum2_d0 <= KeESSR_k_EngStpProfNiDotGainMin)
        {
            rtb_Sum2_d0 = KeESSR_k_EngStpProfNiDotGainMin;
        }

        /* End of Switch: '<S2941>/Switch' */
        /* End of Outputs for SubSystem: '<S2929>/Limiter1' */

        /* Sum: '<S2942>/Sum1' incorporates:
         *  DataStoreRead: '<S2942>/Data Store Read'
         */
        rtb_Sum2_d0 -= VeESSR_k_EngStpProfNiDotGain_DS;

        /* Outputs for Atomic SubSystem: '<S2942>/Limiter' */
        /* Switch: '<S2943>/Switch1' incorporates:
         *  Constant: '<S2940>/Calib'
         *  RelationalOperator: '<S2943>/Relational Operator'
         */
        if (KeESSR_k_EngStpProfNiDotGainRtLmUp < rtb_Sum2_d0)
        {
            /* Sum: '<S2942>/Sum' */
            rtb_Sum2_d0 = KeESSR_k_EngStpProfNiDotGainRtLmUp;
        }

        /* End of Switch: '<S2943>/Switch1' */

        /* Switch: '<S2943>/Switch' incorporates:
         *  Constant: '<S2939>/Calib'
         *  RelationalOperator: '<S2943>/Relational Operator1'
         */
        if (rtb_Sum2_d0 <= KeESSR_k_EngStpProfNiDotGainRtLmDwn)
        {
            rtb_Sum2_d0 = KeESSR_k_EngStpProfNiDotGainRtLmDwn;
        }

        /* End of Switch: '<S2943>/Switch' */
        /* End of Outputs for SubSystem: '<S2942>/Limiter' */

        /* Sum: '<S2942>/Sum' incorporates:
         *  DataStoreRead: '<S2942>/Data Store Read'
         */
        rtb_Sum2_d0 += VeESSR_k_EngStpProfNiDotGain_DS;

        /* DataStoreWrite: '<S2942>/Data Store Write' */
        VeESSR_k_EngStpProfNiDotGain_DS = rtb_Sum2_d0;

        /* Merge: '<S2915>/Merge1' incorporates:
         *  Gain: '<S2944>/Gain'
         */
        VeESSR_k_EngStpProfNiDotGain = rtb_Sum2_d0;

        /* End of Outputs for SubSystem: '<S2915>/Use_NiDotGain_Method' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2915>/Use_ProfileIncAdj_Method' incorporates:
         *  ActionPort: '<S2930>/Action Port'
         */
        if (VeESSR_phi_ActAngRemainingRaw < 0.0F)
        {
            /* Merge: '<S2915>/Merge' incorporates:
             *  Constant: '<S2945>/Calib'
             *  Switch: '<S2930>/Switch'
             */
            rtb_Abs_pi = KeESSR_dphi_EngStpProfCntrIncMax;
        }
        else
        {
            /* Product: '<S2930>/Multiplication2' incorporates:
             *  Switch: '<S2930>/Switch'
             */
            rtb_Sum2_d0 = rtb_Abs_pi * VeESSR_k_AngleRatioRaw;

            /* Outputs for Atomic SubSystem: '<S2930>/Limiter' */
            /* Switch: '<S2947>/Switch1' incorporates:
             *  Constant: '<S2945>/Calib'
             *  RelationalOperator: '<S2947>/Relational Operator'
             *  Switch: '<S2930>/Switch'
             */
            if (KeESSR_dphi_EngStpProfCntrIncMax < rtb_Sum2_d0)
            {
                /* Switch: '<S2947>/Switch1' */
                rtb_Sum2_d0 = KeESSR_dphi_EngStpProfCntrIncMax;
            }

            /* End of Switch: '<S2947>/Switch1' */

            /* Switch: '<S2947>/Switch' incorporates:
             *  Constant: '<S2946>/Calib'
             *  RelationalOperator: '<S2947>/Relational Operator1'
             *  Switch: '<S2930>/Switch'
             */
            if (rtb_Sum2_d0 > KeESSR_dphi_EngStpProfCntrIncMin)
            {
                /* Merge: '<S2915>/Merge' */
                rtb_Abs_pi = rtb_Sum2_d0;
            }
            else
            {
                /* Merge: '<S2915>/Merge' */
                rtb_Abs_pi = KeESSR_dphi_EngStpProfCntrIncMin;
            }

            /* End of Switch: '<S2947>/Switch' */
            /* End of Outputs for SubSystem: '<S2930>/Limiter' */
        }

        /* Merge: '<S2915>/Merge1' incorporates:
         *  Constant: '<S2930>/Constant Value2'
         *  SignalConversion generated from: '<S2930>/NiDotGain'
         */
        VeESSR_k_EngStpProfNiDotGain = 1.0F;

        /* End of Outputs for SubSystem: '<S2915>/Use_ProfileIncAdj_Method' */
    }

    /* End of If: '<S2915>/If' */
    /* End of Outputs for SubSystem: '<S2846>/AdjstPrfIncrmnt' */

    /* Sum: '<S2846>/Summation1' incorporates:
     *  DataStoreRead: '<S2846>/Dsr_EngStpProfCntr'
     *  DataStoreWrite: '<S2846>/Dsw_EngStpProfCntr'
     */
    VeESSR_Cnt_EngStpProfCntr_DS = VeESSR_Cnt_EngStpProfCntr_DS + rtb_Abs_pi;

    /* DataStoreWrite: '<S2846>/Dsw_EngStpProfCntr_Inc' */
    VeESSR_Cnt_EngStpProfCntr_Inc_DS = rtb_Abs_pi;

    /* Product: '<S2916>/Division1' incorporates:
     *  DataStoreRead: '<S2846>/Dsr_EngStpProfCntr'
     *  Lookup_n-D: '<S2948>/Vector'
     */
    rtb_Gain_d = look1_iflf_binlcapw(rtb_Gain_d, ((const float32 *)
        &(KxESSR_k_EngStpNiFactor[0])), ((const float32 *)
        &(KtESSR_k_EngStpNiFactor[0])), 40U) * rtu_InitEngSpd;

    /* Sum: '<S2916>/Summation2' incorporates:
     *  DataStoreRead: '<S2799>/Dsr_InputSpeedProfile'
     */
    rtb_Sum2_d0 = rtb_Gain_d - VeESSR_n_InputSpeedProfile_DS;

    /* Outputs for Atomic SubSystem: '<S2916>/Protected Division' */
    /* Switch: '<S2949>/Switch1' incorporates:
     *  Constant: '<S2917>/Calib'
     *  Constant: '<S2949>/Constant Value'
     *  Constant: '<S2949>/Constant Value1'
     *  Constant: '<S2949>/Constant Value2'
     *  Constant: '<S2949>/Constant Value3'
     *  Logic: '<S2949>/AND'
     *  RelationalOperator: '<S2949>/Greater Than or Equal '
     *  RelationalOperator: '<S2949>/Greater Than or Equal 1'
     *  RelationalOperator: '<S2949>/Not Equal'
     *  RelationalOperator: '<S2949>/Not Equal1'
     *  Switch: '<S2949>/Switch2'
     *  Switch: '<S2949>/Switch3'
     */
    if ((rtb_Sum2_d0 != 0.0F) && (HeESSR_t_MedTEB_dT != 0.0F))
    {
        /* Switch: '<S2949>/Switch1' incorporates:
         *  Product: '<S2949>/Division'
         */
        rtb_Abs_pi = rtb_Sum2_d0 / HeESSR_t_MedTEB_dT;
    }
    else if (rtb_Sum2_d0 > 0.0F)
    {
        /* Switch: '<S2949>/Switch2' incorporates:
         *  Constant: '<S2949>/MAXFLOAT'
         *  Switch: '<S2949>/Switch1'
         */
        rtb_Abs_pi = 3.402823466E+38F;
    }
    else if (rtb_Sum2_d0 < 0.0F)
    {
        /* Switch: '<S2949>/Switch3' incorporates:
         *  Constant: '<S2949>/MINFLOAT'
         *  Switch: '<S2949>/Switch1'
         *  Switch: '<S2949>/Switch2'
         */
        rtb_Abs_pi = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S2949>/Switch1' incorporates:
         *  Constant: '<S2949>/Constant Value4'
         *  Switch: '<S2949>/Switch2'
         *  Switch: '<S2949>/Switch3'
         */
        rtb_Abs_pi = 0.0F;
    }

    /* End of Switch: '<S2949>/Switch1' */
    /* End of Outputs for SubSystem: '<S2916>/Protected Division' */

    /* Switch: '<S2846>/Switch' incorporates:
     *  Constant: '<S2918>/Calib'
     */
    if (KeESSR_b_EngStpProfUseAngAdpt)
    {
        /* Switch: '<S2868>/Switch1' incorporates:
         *  Constant: '<S2846>/Constant Value'
         */
        rtb_Sum2_d0 = 1.0F;
    }
    else
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = *rtd_NeESSR_k_EngStpProfNiDotGai;
    }

    /* End of Switch: '<S2846>/Switch' */
    /* End of Outputs for SubSystem: '<S2799>/Target_Angle_Stop' */

    /* If: '<S2799>/If3' incorporates:
     *  Constant: '<S2824>/Calib'
     *  MinMax: '<S2799>/MinMax'
     *  Product: '<S2846>/Product'
     *  Product: '<S2846>/Product1'
     */
    if (KeESSR_b_UseShpNiForAstop)
    {
        /* Outputs for IfAction SubSystem: '<S2799>/Use_ShapeNi' incorporates:
         *  ActionPort: '<S2847>/Action Port'
         */
        ESSR_ac_Use_ShapeNi(rtb_Product4, rtb_IntegerDelay, &rtb_Merge4_o,
                            &rtb_Sum2_d0);

        /* End of Outputs for SubSystem: '<S2799>/Use_ShapeNi' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2799>/AngleRatio' incorporates:
         *  ActionPort: '<S2802>/Action Port'
         */
        /* Outputs for Atomic SubSystem: '<S2799>/Target_Angle_Stop' */
        ESSR_ac_Use_ShapeNi(rtb_Gain_d, (VeESSR_k_EngStpProfNiDotGain *
                             rtb_Abs_pi) * rtb_Sum2_d0, &rtb_Merge4_o,
                            &rtb_Sum2_d0);

        /* End of Outputs for SubSystem: '<S2799>/Target_Angle_Stop' */
        /* End of Outputs for SubSystem: '<S2799>/AngleRatio' */
    }

    /* End of If: '<S2799>/If3' */

    /* DataStoreWrite: '<S2799>/Dsw_InputAcceltnProf' */
    VeESSR_dn_InputAcceltnProf_DS = rtb_Sum2_d0;

    /* DataStoreWrite: '<S2799>/Dsw_InputSpeedProfile' */
    VeESSR_n_InputSpeedProfile_DS = rtb_Merge4_o;

    /* Logic: '<S2876>/Logical2' incorporates:
     *  DataStoreWrite: '<S2799>/Dsw_InputSpeedProfile1'
     */
    VeESSR_b_NiDotMaxActive_DS = (rtb_RelationalOperator_jnm &&
        rtb_RelationalOperator_ppl);

    /* DataStoreWrite: '<S2799>/Dsw_InputSpeedProfile2' */
    VeESSR_n_TargetSpeed_DS = rtb_Gain1_bp;

    /* DataStoreWrite: '<S2799>/Dsw_InputSpeedProfile3' */
    VeESSR_dn_TargetAcceltn_DS = rtb_Sum15;

    /* Outputs for Atomic SubSystem: '<S2876>/Limiter6' */
    /* Logic: '<S2876>/Logical' incorporates:
     *  DataStoreWrite: '<S2799>/Dsw_InputSpeedProfile4'
     *  Logic: '<S2892>/Logical2'
     */
    VeESSR_b_NiDotMinActive_DS = (rtb_Logical2_ls && (!rtb_Comparison_id));

    /* End of Outputs for SubSystem: '<S2876>/Limiter6' */

    /* DataStoreWrite: '<S2799>/Dsw_Ni1stFlt_DS' */
    VeESSR_n_Ni1stFlt_DS = rtb_Summation_i;

    /* DataStoreWrite: '<S2799>/Dsw_STMTmr' incorporates:
     *  Constant: '<S2814>/Calib'
     *  DataStoreRead: '<S2799>/Dsr_STMTmr'
     *  Sum: '<S2799>/Summation1'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Abs: '<S2809>/Abs' incorporates:
     *  Constant: '<S2814>/Calib'
     *  Constant: '<S2830>/Calib'
     *  Product: '<S2809>/Multiplication'
     */
    rtb_Sum15 = fabsf(KeESSR_dscl_RampDownRate * HeESSR_t_MedTEB_dT);

    /* Sum: '<S2809>/Sum' incorporates:
     *  Constant: '<S2838>/Calib'
     *  DataStoreRead: '<S2799>/Dsr_SpdCtlGainMod1'
     */
    rtb_Product4 = KeESSR_scl_RampDownHold - VeESSR_scl_SpdCtlGainMod_DS;

    /* Outputs for Atomic SubSystem: '<S2809>/Limiter1' */
    /* Switch: '<S2867>/Switch1' incorporates:
     *  RelationalOperator: '<S2867>/Relational Operator'
     */
    if (rtb_Sum15 < rtb_Product4)
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = rtb_Sum15;
    }
    else
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = rtb_Product4;
    }

    /* End of Switch: '<S2867>/Switch1' */

    /* Switch: '<S2867>/Switch' incorporates:
     *  Gain: '<S2809>/Gain'
     *  RelationalOperator: '<S2867>/Relational Operator1'
     */
    if (rtb_Sum2_d0 <= (-rtb_Sum15))
    {
        rtb_Sum2_d0 = -rtb_Sum15;
    }

    /* End of Switch: '<S2867>/Switch' */
    /* End of Outputs for SubSystem: '<S2809>/Limiter1' */

    /* Sum: '<S2809>/Sum1' incorporates:
     *  DataStoreRead: '<S2799>/Dsr_SpdCtlGainMod1'
     */
    rtb_Summation_i = rtb_Sum2_d0 + VeESSR_scl_SpdCtlGainMod_DS;

    /* Outputs for Atomic SubSystem: '<S2809>/Limiter2' */
    /* Switch: '<S2868>/Switch1' incorporates:
     *  Constant: '<S2799>/Constant Value7'
     *  RelationalOperator: '<S2868>/Relational Operator'
     */
    if (2.0F < rtb_Summation_i)
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = 2.0F;
    }
    else
    {
        /* Switch: '<S2868>/Switch1' */
        rtb_Sum2_d0 = rtb_Summation_i;
    }

    /* End of Switch: '<S2868>/Switch1' */

    /* Switch: '<S2868>/Switch' incorporates:
     *  Constant: '<S2799>/Constant Value6'
     *  DataStoreWrite: '<S2799>/Dsw_SpdCtlGainMod'
     *  RelationalOperator: '<S2868>/Relational Operator1'
     */
    if (rtb_Sum2_d0 > 0.0F)
    {
        VeESSR_scl_SpdCtlGainMod_DS = rtb_Sum2_d0;
    }
    else
    {
        VeESSR_scl_SpdCtlGainMod_DS = 0.0F;
    }

    /* End of Switch: '<S2868>/Switch' */
    /* End of Outputs for SubSystem: '<S2809>/Limiter2' */

    /* Logic: '<S2799>/Logical Operator2' */
    rtb_LogicalOperator2_il = (rtb_LogicalOperator2_il || rtb_Switch6_b);

    /* Switch: '<S2799>/Switch4' incorporates:
     *  Constant: '<S2799>/Constant Value5'
     *  DataStoreRead: '<S2799>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S2799>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S2799>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S2799>/Logical21'
     *  RelationalOperator: '<S2799>/Comparison1'
     *  S-Function (sfix_bitop): '<S2799>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S2806>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator2_il && ((VeESSR_g_StrtStpFailPhaseSelect_DS &
            262144U) > 0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 262144U;
    }

    /* End of Switch: '<S2799>/Switch4' */

    /* DataStoreWrite: '<S2799>/Dsw_InputTorqEst' incorporates:
     *  Constant: '<S2818>/Calib'
     *  DataStoreRead: '<S2799>/Dsr_InputTorqEst'
     *  Product: '<S2803>/Multiplication'
     *  Sum: '<S2799>/Summation2'
     *  Sum: '<S2803>/Subtraction'
     *  Sum: '<S2803>/Subtraction1'
     */
    VeESSR_M_EngTorqEst_DS = (((rtu_EngTrqActual - rtu_SpinDownDragCorr) -
        VeESSR_M_EngTorqEst_DS) * KeESSR_K_TiEstBlndRmpDwn) +
        VeESSR_M_EngTorqEst_DS;

    /* Logic: '<S2845>/Logical2' incorporates:
     *  Constant: '<S2914>/Calib'
     *  DataStoreRead: '<S2845>/Dsr_InputSpeedProfile1'
     *  RelationalOperator: '<S2845>/Comparison1'
     *  RelationalOperator: '<S2845>/Comparison3'
     */
    VeESSR_b_TgtStpAngRmpDwnExtSpd = ((rtu_TransInSpdFlt <=
        KeESSR_n_TrgtStpAngRmpDwnExit) || (VeESSR_n_InputSpeedProfile_DS <=
        KeESSR_n_TrgtStpAngRmpDwnExit));

    /* Switch: '<S2799>/Switch6' incorporates:
     *  Constant: '<S2823>/Calib'
     */
    if (KeESSR_b_TrgtAngCntrl)
    {
        /* Switch: '<S2799>/Switch6' */
        rtb_Switch6_b = VeESSR_b_TgtStpAngRmpDwnExtSpd;
    }
    else
    {
        /* Switch: '<S2799>/Switch6' incorporates:
         *  Logic: '<S2799>/Logical2'
         *  Logic: '<S2799>/Logical3'
         */
        rtb_Switch6_b = ((!rtb_GreaterThan1_c0) && rtb_GreaterThanorEqual_mr);
    }

    /* End of Switch: '<S2799>/Switch6' */

    /* Logic: '<S2799>/Logical12' */
    rtb_GreaterThanorEqual_mr = (rtu_EngOnReq && rtu_AStopEngCOMLmp);

    /* RelationalOperator: '<S2799>/Comparison2' incorporates:
     *  Constant: '<S2836>/Calib'
     */
    rtb_RelationalOperator_jnm = (rtu_TransInSpdFlt > KeESSR_n_EngTrqOnlySpdMin);

    /* Logic: '<S2799>/Logical8' incorporates:
     *  Constant: '<S2811>/Calib'
     *  Constant: '<S2821>/Calib'
     *  Logic: '<S2799>/Logical11'
     *  Logic: '<S2799>/Logical13'
     *  Logic: '<S2799>/Logical9'
     */
    rtb_Comparison_id = (((HeESSR_b_CltchStrtEquipped) && rtu_EngOnReq) &&
                         ((((!rtu_CltchStrtRsrvAvail) &&
                            (!KeESSR_b_DsblCltchStrtRsrvChk)) ||
                           (!rtu_InCltchStrtZn)) || rtu_AStopReStrtPrepLmp));

    /* If: '<S2799>/If' incorporates:
     *  Constant: '<S2811>/Calib'
     *  Constant: '<S2812>/Calib'
     *  Constant: '<S2820>/Calib'
     *  Constant: '<S2822>/Calib'
     *  DataStoreRead: '<S2799>/Data Store Read4'
     *  DataStoreWrite: '<S2799>/Dsw_CltchStckOn'
     *  Logic: '<S2799>/AND'
     *  Logic: '<S2799>/Logical1'
     *  Logic: '<S2799>/Logical10'
     *  Logic: '<S2799>/Logical14'
     *  Logic: '<S2799>/Logical15'
     *  Logic: '<S2799>/Logical16'
     *  Logic: '<S2799>/Logical17'
     *  Logic: '<S2799>/Logical18'
     *  Logic: '<S2799>/Logical19'
     *  Logic: '<S2799>/Logical20'
     *  Logic: '<S2799>/Logical22'
     *  Logic: '<S2799>/Logical6'
     *  Logic: '<S2799>/Logical7'
     */
    if (rtb_Switch6_b)
    {
        /* Outputs for IfAction SubSystem: '<S2799>/AchieveAndAdapt' incorporates:
         *  ActionPort: '<S2801>/Action Port'
         */
        /* DataStoreWrite: '<S2801>/Dsw_STMTrigger' incorporates:
         *  Constant: '<S2850>/Constant'
         */
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngSpdTgtAch;

        /* If: '<S2801>/If' incorporates:
         *  Constant: '<S2851>/Calib'
         *  If: '<S2859>/If'
         */
        if (KeESSR_b_EngStpProfUseAngAdpt)
        {
            /* Outputs for IfAction SubSystem: '<S2801>/Adapt_Angle_Factor' incorporates:
             *  ActionPort: '<S2848>/Action Port'
             */
            /* If: '<S2852>/If' incorporates:
             *  Constant: '<S2855>/Calib'
             */
            if (VeESSR_k_AngleRatioRaw > 1.0F)
            {
                /* Outputs for IfAction SubSystem: '<S2852>/AdaptUp' incorporates:
                 *  ActionPort: '<S2854>/Action Port'
                 */
                ESSR_ac_AdaptUp(KeESSR_k_EngStpProfNiDotGainAdpt_Inc,
                                &localB->Merge_l);

                /* End of Outputs for SubSystem: '<S2852>/AdaptUp' */
            }
            else
            {
                if (VeESSR_k_AngleRatioRaw < 1.0F)
                {
                    /* Outputs for IfAction SubSystem: '<S2852>/AdaptDown' incorporates:
                     *  ActionPort: '<S2853>/Action Port'
                     */
                    ESSR_ac_AdaptDown(KeESSR_k_EngStpProfNiDotGainAdpt_Inc,
                                      &localB->Merge_l);

                    /* End of Outputs for SubSystem: '<S2852>/AdaptDown' */
                }
            }

            /* End of If: '<S2852>/If' */

            /* Sum: '<S2852>/Sum' */
            rtb_Summation_i = (*rtd_NeESSR_k_EngStpProfAngAdpt) +
                localB->Merge_l;

            /* Outputs for Atomic SubSystem: '<S2852>/Limiter' */
            /* Switch: '<S2858>/Switch1' incorporates:
             *  Constant: '<S2856>/Calib'
             *  RelationalOperator: '<S2858>/Relational Operator'
             */
            if (KeESSR_k_EngStpProfNiDotGainAdpt_Max < rtb_Summation_i)
            {
                /* Switch: '<S2858>/Switch1' */
                rtb_Summation_i = KeESSR_k_EngStpProfNiDotGainAdpt_Max;
            }

            /* End of Switch: '<S2858>/Switch1' */

            /* Switch: '<S2858>/Switch' incorporates:
             *  Constant: '<S2857>/Calib'
             *  RelationalOperator: '<S2858>/Relational Operator1'
             */
            if (rtb_Summation_i > KeESSR_k_EngStpProfNiDotGainAdpt_Min)
            {
                /* DataStoreWrite: '<S2852>/Data Store Write1' */
                *rtd_NeESSR_k_EngStpProfAngAdpt = rtb_Summation_i;
            }
            else
            {
                /* DataStoreWrite: '<S2852>/Data Store Write1' */
                *rtd_NeESSR_k_EngStpProfAngAdpt =
                    KeESSR_k_EngStpProfNiDotGainAdpt_Min;
            }

            /* End of Switch: '<S2858>/Switch' */
            /* End of Outputs for SubSystem: '<S2852>/Limiter' */
            /* End of Outputs for SubSystem: '<S2801>/Adapt_Angle_Factor' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S2801>/Adapt_NiGain' incorporates:
             *  ActionPort: '<S2849>/Action Port'
             */
            if (VeESSR_k_AngleRatioRaw > 1.0F)
            {
                /* Outputs for IfAction SubSystem: '<S2859>/AdaptUp' incorporates:
                 *  ActionPort: '<S2861>/Action Port'
                 */
                /* If: '<S2859>/If' incorporates:
                 *  Constant: '<S2862>/Calib'
                 */
                ESSR_ac_AdaptUp(KeESSR_k_EngStpProfNiDotGainAdpt_Inc,
                                &localB->Merge);

                /* End of Outputs for SubSystem: '<S2859>/AdaptUp' */
            }
            else
            {
                if (VeESSR_k_AngleRatioRaw < 1.0F)
                {
                    /* Outputs for IfAction SubSystem: '<S2859>/AdaptDown' incorporates:
                     *  ActionPort: '<S2860>/Action Port'
                     */
                    /* If: '<S2859>/If' incorporates:
                     *  Constant: '<S2862>/Calib'
                     */
                    ESSR_ac_AdaptDown(KeESSR_k_EngStpProfNiDotGainAdpt_Inc,
                                      &localB->Merge);

                    /* End of Outputs for SubSystem: '<S2859>/AdaptDown' */
                }
            }

            /* Sum: '<S2859>/Sum' incorporates:
             *  If: '<S2859>/If'
             */
            rtb_Summation_i = (*rtd_NeESSR_k_EngStpProfNiDotGai) + localB->Merge;

            /* Outputs for Atomic SubSystem: '<S2859>/Limiter' */
            /* Switch: '<S2865>/Switch1' incorporates:
             *  Constant: '<S2863>/Calib'
             *  RelationalOperator: '<S2865>/Relational Operator'
             */
            if (KeESSR_k_EngStpProfNiDotGainAdpt_Max < rtb_Summation_i)
            {
                /* Switch: '<S2865>/Switch1' */
                rtb_Summation_i = KeESSR_k_EngStpProfNiDotGainAdpt_Max;
            }

            /* End of Switch: '<S2865>/Switch1' */

            /* Switch: '<S2865>/Switch' incorporates:
             *  Constant: '<S2864>/Calib'
             *  RelationalOperator: '<S2865>/Relational Operator1'
             */
            if (rtb_Summation_i > KeESSR_k_EngStpProfNiDotGainAdpt_Min)
            {
                /* DataStoreWrite: '<S2859>/Data Store Write1' */
                *rtd_NeESSR_k_EngStpProfNiDotGai = rtb_Summation_i;
            }
            else
            {
                /* DataStoreWrite: '<S2859>/Data Store Write1' */
                *rtd_NeESSR_k_EngStpProfNiDotGai =
                    KeESSR_k_EngStpProfNiDotGainAdpt_Min;
            }

            /* End of Switch: '<S2865>/Switch' */
            /* End of Outputs for SubSystem: '<S2859>/Limiter' */
            /* End of Outputs for SubSystem: '<S2801>/Adapt_NiGain' */
        }

        /* End of If: '<S2801>/If' */
        /* End of Outputs for SubSystem: '<S2799>/AchieveAndAdapt' */
    }
    else if ((VeESSR_b_CoastDownTrigger_DS) || ((rtb_GreaterThanorEqual_mr &&
               (!rtb_RelationalOperator_jnm)) && (!rtb_Comparison_id)))
    {
        /* Outputs for IfAction SubSystem: '<S2799>/CoastDown' incorporates:
         *  ActionPort: '<S2807>/Action Port'
         */
        ESSR_ac_CoastDown();

        /* End of Outputs for SubSystem: '<S2799>/CoastDown' */
    }
    else if (((HeESSR_b_EngTrqOnlyCOM) && (rtb_GreaterThanorEqual_mr ||
               (rtu_InCltchStrtZn && rtu_EngOnReq))) &&
             rtb_RelationalOperator_jnm)
    {
        /* Outputs for IfAction SubSystem: '<S2799>/Restart1' incorporates:
         *  ActionPort: '<S2842>/Action Port'
         */
        ESSR_ac_Restart1();

        /* End of Outputs for SubSystem: '<S2799>/Restart1' */
    }
    else if ((((((!HeESSR_b_CltchStrtEquipped) && rtu_EngOnReq) &&
                (KeESSR_b_AllowStopAbrts)) && rtb_GreaterThan1_c0) ||
              (VeESSR_b_CltchStckOn_DS)) || (rtb_Comparison_id &&
              (!rtb_GreaterThanorEqual_mr)))
    {
        /* Outputs for IfAction SubSystem: '<S2799>/Restart' incorporates:
         *  ActionPort: '<S2841>/Action Port'
         */
        ESSR_ac_Restart();

        /* End of Outputs for SubSystem: '<S2799>/Restart' */
    }
    else if ((KeESSR_b_P1C68_RD_CoastDownEnbl) && rtb_GreaterThan_os)
    {
        /* Outputs for IfAction SubSystem: '<S2799>/StartEng' incorporates:
         *  ActionPort: '<S2844>/Action Port'
         */
        /* DataStoreWrite: '<S2844>/Dsw_STMTrigger' incorporates:
         *  Constant: '<S2913>/Constant'
         */
        VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

        /* End of Outputs for SubSystem: '<S2799>/StartEng' */
    }
    else
    {
        if (rtb_GreaterThan_os)
        {
            /* Outputs for IfAction SubSystem: '<S2799>/EngFail' incorporates:
             *  ActionPort: '<S2810>/Action Port'
             */
            ESSR_ac_EngFail();

            /* End of Outputs for SubSystem: '<S2799>/EngFail' */
        }
    }

    /* End of If: '<S2799>/If' */

    /* If: '<S2799>/If1' */
    if (rtb_LogicalOperator2_il)
    {
        /* Outputs for IfAction SubSystem: '<S2799>/If_RampDown_P1C68' incorporates:
         *  ActionPort: '<S2817>/Action Port'
         */
        ESSR_ac_If_RampDown_P1C68();

        /* End of Outputs for SubSystem: '<S2799>/If_RampDown_P1C68' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2799>/If_RampDown_NoFault' incorporates:
         *  ActionPort: '<S2816>/Action Port'
         */
        ESSR_ac_If_DisableFuel_NoFault();

        /* End of Outputs for SubSystem: '<S2799>/If_RampDown_NoFault' */
    }

    /* End of If: '<S2799>/If1' */

    /* Sum: '<S2876>/Sum17' */
    VeESSR_dn_InputJerkProfRampDwn = rtb_IntegerDelay - rtb_Gain_n3;

    /* Update for UnitDelay: '<S2895>/Unit Delay' incorporates:
     *  Switch: '<S2895>/Switch3'
     */
    localDW->UnitDelay_DSTATE = rtb_Summation_go;

    /* Update for Delay: '<S2876>/IntegerDelay' */
    localDW->icLoad = 0U;
    for (i = 0; i < 15; i++)
    {
        localDW->IntegerDelay_DSTATE[i] = localDW->IntegerDelay_DSTATE[i + 1];
    }

    localDW->IntegerDelay_DSTATE[15] = rtb_Gain1_bp;

    /* End of Update for Delay: '<S2876>/IntegerDelay' */
}

#endif

/* Output and update for function-call system: '<S2448>/ESSC_FinishStopDur' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_FinishStopDur(VAR(float32,
    AUTOMATIC) rtu_Ni, VAR(boolean, AUTOMATIC) rtu_EngOnReq, VAR(float32,
    AUTOMATIC) rtu_EngAngle720Est, VAR(float32, AUTOMATIC) rtu_EngTrqActual, VAR
    (float32, AUTOMATIC) rtu_SpinDownDragCorr, VAR(boolean, AUTOMATIC)
    rtu_CltchStrtRsrvAvail, VAR(boolean, AUTOMATIC) rtu_InCltchStrtZn, VAR
    (boolean, AUTOMATIC) rtu_AStopEngCOMLmp, VAR(boolean, AUTOMATIC)
    rtu_AStopReStrtPrepLmp, P2VAR(DW_ESSC_FinishStopDur_ESSR_ac_T, AUTOMATIC,
    ESSR_VAR_INIT) localDW, P2VAR(uint32, AUTOMATIC, ESSR_VAR_INIT)
    rtd_NeESSR_g_StrtStpFailRsn)
{
    float32 rtb_MinMax2_jh;
    float32 rtb_Sum_m5;
    float32 rtb_Switch1_bx;
    float32 rtb_Switch1_idh;
    boolean rtb_AND2_n;
    boolean rtb_Comparison_p;
    boolean rtb_GreaterThan_px;
    boolean rtb_Logical9_i;
    boolean rtb_LogicalOperator3_k;
    boolean rtb_LogicalOperator7_a;
    boolean rtb_OR1_jq;
    boolean rtb_OR1_mi;

    /* RelationalOperator: '<S2564>/Greater  Than' incorporates:
     *  Constant: '<S2607>/Calib'
     *  DataStoreRead: '<S2564>/Dsr_STMTmr'
     */
    rtb_GreaterThan_px = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmFnshStp);

    /* Logic: '<S2564>/Logical9' incorporates:
     *  Constant: '<S2609>/Calib'
     *  DataStoreRead: '<S2564>/Dsr_STMTmr1'
     *  Logic: '<S2564>/Logical Operator10'
     *  RelationalOperator: '<S2564>/Greater  Than1'
     */
    rtb_Logical9_i = ((VeESSR_t_STMTmr_DS > KeESSR_t_MinFinishStpTm) ||
                      rtb_GreaterThan_px);

    /* Logic: '<S2564>/AND2' incorporates:
     *  Constant: '<S2601>/Calib'
     *  Logic: '<S2564>/AND3'
     *  Logic: '<S2564>/AND5'
     *  RelationalOperator: '<S2564>/Less Than  or Equal'
     */
    rtb_AND2_n = (((rtu_Ni <= KeESSR_n_FinishStpCmpltSpd) && rtu_EngOnReq) ||
                  rtb_Logical9_i);

    /* Logic: '<S2564>/Logical Operator7' incorporates:
     *  Logic: '<S2564>/Logical7'
     */
    rtb_LogicalOperator7_a = ((!rtb_AND2_n) && rtb_GreaterThan_px);

    /* Switch: '<S2564>/Switch' incorporates:
     *  S-Function (sfix_bitop): '<S2571>/FixPt Bitwise Operator1'
     */
    if (rtb_LogicalOperator7_a)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 2097152U;
    }

    /* End of Switch: '<S2564>/Switch' */

    /* RelationalOperator: '<S2564>/Comparison' incorporates:
     *  Constant: '<S2584>/Calib'
     *  DataStoreRead: '<S2564>/Dsr_STMTmr2'
     */
    rtb_Comparison_p = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

    /* Chart: '<S2577>/FinishStopTgtEngParkAngle_Chart' incorporates:
     *  Constant: '<S2615>/Calib'
     *  Constant: '<S2616>/Calib'
     */
    /* Gateway: ESSC_StopStates/ESSC_FinishStop/ESSC_FinishStopDur/ESSC_ParkEngAngleInFinishPhase/FinishStopTgtEngParkAngle_Chart */
    /* During: ESSC_StopStates/ESSC_FinishStop/ESSC_FinishStopDur/ESSC_ParkEngAngleInFinishPhase/FinishStopTgtEngParkAngle_Chart */
    /* Entry Internal: ESSC_StopStates/ESSC_FinishStop/ESSC_FinishStopDur/ESSC_ParkEngAngleInFinishPhase/FinishStopTgtEngParkAngle_Chart */
    /* Transition: '<S2614>:1' */
    if (!rtb_Comparison_p)
    {
        /* Transition: '<S2614>:2' */
        /* Transition: '<S2614>:3' */
        while ((((sint32)localDW->Index) <= (((sint32)KeESSR_Cnt_EngCylTotal) -
                 1)) && (!VeESSR_b_FinishStopEngParkAngleFound))
        {
            /* Transition: '<S2614>:4' */
            /* Transition: '<S2614>:5' */
            if (rtu_EngAngle720Est > KaESSR_phi_TgtEngParkAngle[(localDW->Index)])
            {
                /* Transition: '<S2614>:6' */
                /* Transition: '<S2614>:12' */
                if ((((sint32)KeESSR_Cnt_EngCylTotal) - 1) == ((sint32)
                        localDW->Index))
                {
                    /* Transition: '<S2614>:13' */
                    /* Transition: '<S2614>:16' */
                    VeESSR_phi_FinishStopTgtEngParkAngle =
                        KaESSR_phi_TgtEngParkAngle[0];
                    VeESSR_b_FinishStopEngParkAngleFound = true;

                    /* Transition: '<S2614>:17' */
                }
                else
                {
                    /* Transition: '<S2614>:14' */
                    localDW->Index = (uint8)((sint32)(((sint32)localDW->Index) +
                        1));
                }

                /* Transition: '<S2614>:15' */
            }
            else
            {
                /* Transition: '<S2614>:7' */
                VeESSR_phi_FinishStopTgtEngParkAngle =
                    KaESSR_phi_TgtEngParkAngle[(localDW->Index)];
                VeESSR_b_FinishStopEngParkAngleFound = true;
            }

            /* Transition: '<S2614>:8' */
        }

        /* Transition: '<S2614>:9' */
        /* Transition: '<S2614>:11' */
    }
    else
    {
        /* Transition: '<S2614>:10' */
        localDW->Index = 0U;
        VeESSR_b_FinishStopEngParkAngleFound = false;
    }

    /* End of Chart: '<S2577>/FinishStopTgtEngParkAngle_Chart' */

    /* Outputs for Atomic SubSystem: '<S2564>/Signal Latch On With Reset' */
    /* Logic: '<S2612>/OR1' incorporates:
     *  Logic: '<S2612>/NOT'
     *  Logic: '<S2612>/OR'
     *  RelationalOperator: '<S2564>/Comparison1'
     *  UnitDelay: '<S2612>/Unit Delay'
     */
    VeESSR_b_TgtAngleAboveCrnt = ((VeESSR_phi_FinishStopTgtEngParkAngle >
        rtu_EngAngle720Est) || ((!rtb_Comparison_p) &&
        (VeESSR_b_TgtAngleAboveCrnt)));

    /* End of Outputs for SubSystem: '<S2564>/Signal Latch On With Reset' */

    /* MinMax: '<S2564>/MinMax2' incorporates:
     *  Constant: '<S2564>/Constant Value8'
     *  Sum: '<S2564>/Sum2'
     *  UnitDelay: '<S2564>/Unit Delay'
     */
    rtb_MinMax2_jh = fmaxf(localDW->UnitDelay_DSTATE, rtu_EngAngle720Est -
                           720.0F);

    /* Switch: '<S2585>/Switch1' */
    if (VeESSR_b_TgtAngleAboveCrnt)
    {
        /* Sum: '<S2564>/Sum4' incorporates:
         *  Sum: '<S2564>/Sum1'
         *  Switch: '<S2592>/Switch1'
         */
        rtb_Sum_m5 = VeESSR_phi_FinishStopTgtEngParkAngle - rtu_EngAngle720Est;

        /* Switch: '<S2592>/Switch1' incorporates:
         *  Constant: '<S2564>/Constant Value15'
         *  RelationalOperator: '<S2564>/RollBack'
         *  Sum: '<S2564>/Sum4'
         */
        if (rtb_Sum_m5 < 0.0F)
        {
            /* Switch: '<S2585>/Switch1' incorporates:
             *  Constant: '<S2564>/Constant Value16'
             *  Constant: '<S2593>/Calib'
             *  Product: '<S2564>/Divide'
             *  Switch: '<S2592>/Switch1'
             */
            VeESSR_phi_FinishStopParkEngAngDiff = 360.0F / ((float32)
                KeESSR_Cnt_EngCylTotal);
        }
        else
        {
            /* Switch: '<S2585>/Switch1' incorporates:
             *  Constant: '<S2564>/Constant Value5'
             *  MinMax: '<S2564>/MinMax1'
             *  Switch: '<S2592>/Switch1'
             */
            VeESSR_phi_FinishStopParkEngAngDiff = fmaxf(0.0F, rtb_Sum_m5);
        }
    }
    else
    {
        /* Switch: '<S2589>/Switch1' incorporates:
         *  Sum: '<S2564>/Sum3'
         */
        rtb_Switch1_bx = VeESSR_phi_FinishStopTgtEngParkAngle -
            rtu_EngAngle720Est;

        /* Switch: '<S2589>/Switch1' incorporates:
         *  Constant: '<S2564>/Constant Value9'
         *  RelationalOperator: '<S2564>/Comparison3'
         */
        if (rtb_Switch1_bx < 0.0F)
        {
            /* Switch: '<S2589>/Switch1' incorporates:
             *  Constant: '<S2564>/Constant Value6'
             *  Constant: '<S2593>/Calib'
             *  Product: '<S2564>/Divide1'
             */
            rtb_Switch1_bx = 360.0F / ((float32)KeESSR_Cnt_EngCylTotal);
        }

        /* End of Switch: '<S2589>/Switch1' */

        /* Switch: '<S2585>/Switch1' incorporates:
         *  Abs: '<S2564>/Abs'
         *  Sum: '<S2564>/Sum'
         */
        VeESSR_phi_FinishStopParkEngAngDiff = fabsf(rtb_MinMax2_jh) +
            rtb_Switch1_bx;
    }

    /* End of Switch: '<S2585>/Switch1' */

    /* Logic: '<S2564>/Logical3' incorporates:
     *  Constant: '<S2603>/Calib'
     *  Constant: '<S2606>/Calib'
     *  DataStoreRead: '<S2564>/Dsr_STMTmr3'
     *  RelationalOperator: '<S2564>/Comparison2'
     *  RelationalOperator: '<S2564>/Greater  Than3'
     */
    VeESSR_b_FinishPosEng = ((VeESSR_phi_FinishStopParkEngAngDiff >
        KeESSR_phi_FinishStopEngAngDiffThres) && (VeESSR_t_STMTmr_DS <
        KeESSR_t_MaxPositionEngTm));

    /* Outputs for Atomic SubSystem: '<S2564>/EdgeRising' */
    /* Logic: '<S2579>/OR1' incorporates:
     *  UnitDelay: '<S2579>/Unit Delay'
     */
    rtb_OR1_mi = !localDW->UnitDelay_DSTATE_e;

    /* Update for UnitDelay: '<S2579>/Unit Delay' */
    localDW->UnitDelay_DSTATE_e = rtb_Comparison_p;

    /* Outputs for Atomic SubSystem: '<S2564>/Accumulator Reset' */
    /* Switch: '<S2566>/Switch1' incorporates:
     *  Logic: '<S2564>/Logical6'
     *  Logic: '<S2579>/AND'
     *  Switch: '<S2564>/Switch5'
     */
    if (rtb_Comparison_p && rtb_OR1_mi)
    {
        /* Switch: '<S2566>/Switch1' incorporates:
         *  Constant: '<S2564>/Constant Value11'
         */
        rtb_Switch1_bx = 0.0F;
    }
    else
    {
        if (!VeESSR_b_FinishPosEng)
        {
            /* Switch: '<S2564>/Switch5' incorporates:
             *  Constant: '<S2584>/Calib'
             */
            rtb_Sum_m5 = HeESSR_t_MedTEB_dT;
        }
        else
        {
            /* Switch: '<S2564>/Switch5' incorporates:
             *  Constant: '<S2564>/Constant Value3'
             */
            rtb_Sum_m5 = 0.0F;
        }

        /* Switch: '<S2566>/Switch1' incorporates:
         *  Sum: '<S2566>/Summation'
         *  UnitDelay: '<S2566>/Unit Delay'
         */
        rtb_Switch1_bx = rtb_Sum_m5 + localDW->UnitDelay_DSTATE_n;
    }

    /* End of Switch: '<S2566>/Switch1' */
    /* End of Outputs for SubSystem: '<S2564>/EdgeRising' */

    /* Update for UnitDelay: '<S2566>/Unit Delay' */
    localDW->UnitDelay_DSTATE_n = rtb_Switch1_bx;

    /* End of Outputs for SubSystem: '<S2564>/Accumulator Reset' */

    /* Logic: '<S2564>/Logical9' incorporates:
     *  Constant: '<S2596>/Calib'
     *  Constant: '<S2608>/Calib'
     *  Logic: '<S2564>/AND'
     *  Logic: '<S2564>/AND4'
     *  Logic: '<S2564>/Logical4'
     *  Logic: '<S2564>/Logical5'
     *  RelationalOperator: '<S2564>/Greater  Than4'
     *  UnitDelay: '<S2564>/Unit Delay1'
     */
    rtb_Logical9_i = (rtb_Logical9_i || ((rtb_Switch1_bx >
                        KeESSR_t_MinFinishStpPrkTm) && ((!VeESSR_b_EngParking) &&
                        (KeESSR_b_AStopParkEngEnable))));

    /* Logic: '<S2564>/Logical Operator1' incorporates:
     *  Logic: '<S2564>/Logical8'
     */
    rtb_Comparison_p = ((!rtb_Logical9_i) && rtb_GreaterThan_px);

    /* Switch: '<S2564>/Switch1' incorporates:
     *  S-Function (sfix_bitop): '<S2572>/FixPt Bitwise Operator1'
     */
    if (rtb_Comparison_p)
    {
        *rtd_NeESSR_g_StrtStpFailRsn |= 4194304U;
    }

    /* End of Switch: '<S2564>/Switch1' */

    /* DataStoreWrite: '<S2564>/Dsw_InputAcceltnProf' incorporates:
     *  Constant: '<S2564>/Constant Value1'
     *  Constant: '<S2594>/Calib'
     *  DataStoreRead: '<S2564>/Dsr_InputAcceltnProf'
     *  Product: '<S2568>/Multiplication'
     *  Sum: '<S2568>/Subtraction'
     *  Sum: '<S2568>/Subtraction1'
     */
    VeESSR_dn_InputAcceltnProf_DS = ((0.0F - VeESSR_dn_InputAcceltnProf_DS) *
        KeESSR_K_FinishStpFlt) + VeESSR_dn_InputAcceltnProf_DS;

    /* Logic: '<S2564>/Logical1' incorporates:
     *  Constant: '<S2596>/Calib'
     */
    rtb_OR1_mi = ((VeESSR_b_FinishPosEng) && (KeESSR_b_AStopParkEngEnable));

    /* Outputs for Atomic SubSystem: '<S2564>/EdgeRising1' */
    /* Logic: '<S2580>/OR1' incorporates:
     *  UnitDelay: '<S2580>/Unit Delay'
     */
    rtb_OR1_jq = !localDW->UnitDelay_DSTATE_p;

    /* Update for UnitDelay: '<S2580>/Unit Delay' */
    localDW->UnitDelay_DSTATE_p = rtb_OR1_mi;

    /* End of Outputs for SubSystem: '<S2564>/EdgeRising1' */

    /* Logic: '<S2564>/AND2' */
    rtb_AND2_n = (rtb_AND2_n || rtb_Logical9_i);

    /* Logic: '<S2564>/Logical9' incorporates:
     *  Constant: '<S2583>/Calib'
     *  Constant: '<S2598>/Calib'
     *  Logic: '<S2564>/Logical Operator6'
     *  Logic: '<S2564>/Logical11'
     *  Logic: '<S2564>/Logical12'
     */
    rtb_Logical9_i = (((HeESSR_b_CltchStrtEquipped) && rtu_EngOnReq) &&
                      ((((!rtu_CltchStrtRsrvAvail) &&
                         (!KeESSR_b_DsblCltchStrtRsrvChk)) ||
                        (!rtu_InCltchStrtZn)) || rtu_AStopReStrtPrepLmp));

    /* Logic: '<S2564>/Logical Operator3' incorporates:
     *  Constant: '<S2583>/Calib'
     *  Constant: '<S2597>/Calib'
     *  Constant: '<S2602>/Calib'
     *  Logic: '<S2564>/AND1'
     *  Logic: '<S2564>/Logical Operator8'
     *  Logic: '<S2564>/Logical10'
     *  Logic: '<S2564>/Logical14'
     *  RelationalOperator: '<S2564>/Greater  Than2'
     */
    rtb_LogicalOperator3_k = ((((rtu_EngOnReq && (KeESSR_b_AllowStopAbrts)) &&
        (rtu_Ni > KeESSR_n_StopAbrtMinSpd)) && (!HeESSR_b_CltchStrtEquipped)) ||
        (rtb_Logical9_i && (!rtu_AStopEngCOMLmp)));

    /* Outputs for Atomic SubSystem: '<S2564>/Accumulator Reset1' */
    /* Switch: '<S2567>/Switch1' incorporates:
     *  Logic: '<S2564>/Logical2'
     */
    if (rtb_AND2_n || rtb_LogicalOperator3_k)
    {
        /* Switch: '<S2567>/Switch1' incorporates:
         *  Constant: '<S2564>/Constant Value13'
         */
        VeESSR_Cnt_AccumPark = 0U;
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S2564>/EdgeRising1' */
        /* Switch: '<S2567>/Switch1' incorporates:
         *  Logic: '<S2580>/AND'
         *  Sum: '<S2567>/Summation'
         *  UnitDelay: '<S2567>/Unit Delay'
         */
        VeESSR_Cnt_AccumPark = (uint16)(((uint32)((rtb_OR1_mi && rtb_OR1_jq) ? 1
            : 0)) + ((uint32)VeESSR_Cnt_AccumPark));

        /* End of Outputs for SubSystem: '<S2564>/EdgeRising1' */
    }

    /* End of Switch: '<S2567>/Switch1' */
    /* End of Outputs for SubSystem: '<S2564>/Accumulator Reset1' */

    /* Switch: '<S2591>/Switch1' incorporates:
     *  Constant: '<S2564>/Constant Value12'
     *  RelationalOperator: '<S2564>/Comparison4'
     */
    VeESSR_b_EngParking = ((((sint32)VeESSR_Cnt_AccumPark) == 1) && rtb_OR1_mi);

    /* Switch: '<S2587>/Switch1' incorporates:
     *  Constant: '<S2564>/Constant Value10'
     *  DataStoreRead: '<S2564>/Dsr_InputAcceltnProf2'
     */
    if (VeESSR_b_EngParking)
    {
        rtb_Sum_m5 = VeESSR_n_InputSpeedProfile_DS;
    }
    else
    {
        rtb_Sum_m5 = 0.0F;
    }

    /* End of Switch: '<S2587>/Switch1' */

    /* DataStoreWrite: '<S2564>/Dsw_InputSpeedProfile' incorporates:
     *  Constant: '<S2594>/Calib'
     *  DataStoreRead: '<S2564>/Dsr_InputAcceltnProf1'
     *  Product: '<S2570>/Multiplication'
     *  Sum: '<S2570>/Subtraction'
     *  Sum: '<S2570>/Subtraction1'
     */
    VeESSR_n_InputSpeedProfile_DS = ((rtb_Sum_m5 - VeESSR_n_InputSpeedProfile_DS)
        * KeESSR_K_FinishStpFlt) + VeESSR_n_InputSpeedProfile_DS;

    /* Switch: '<S2588>/Switch1' incorporates:
     *  Constant: '<S2594>/Calib'
     *  Constant: '<S2595>/Calib'
     *  Constant: '<S2599>/Calib'
     *  Switch: '<S2564>/Switch4'
     *  Switch: '<S2590>/Switch1'
     */
    if (VeESSR_b_EngParking)
    {
        /* Switch: '<S2588>/Switch1' */
        rtb_Switch1_bx = rtu_EngTrqActual;
        rtb_Sum_m5 = KeESSR_K_FinishStpFlt;
    }
    else
    {
        if (KeESSR_b_UseZeroTiEstFinishStp)
        {
            /* Switch: '<S2564>/Switch4' incorporates:
             *  Constant: '<S2564>/Constant Value17'
             *  Switch: '<S2588>/Switch1'
             */
            rtb_Switch1_bx = 0.0F;
        }
        else
        {
            /* Switch: '<S2588>/Switch1' incorporates:
             *  Lookup_n-D: '<S2610>/Vector'
             *  MinMax: '<S2564>/MinMax3'
             *  Sum: '<S2564>/Summation2'
             *  Switch: '<S2564>/Switch4'
             */
            rtb_Switch1_bx = fmaxf(rtu_EngTrqActual - rtu_SpinDownDragCorr,
                                   look1_iflf_binlcapw(rtu_Ni, ((const float32 *)
                &(KxESSR_M_NiBsdTiEstFinishStp[0])), ((const float32 *)
                &(KtESSR_M_NiBsdTiEstFinishStp[0])), 6U));
        }

        rtb_Sum_m5 = KeESSR_K_FinishStpFltNoPark;
    }

    /* End of Switch: '<S2588>/Switch1' */

    /* DataStoreWrite: '<S2564>/Dsw_InputTorqEst' incorporates:
     *  DataStoreRead: '<S2564>/Dsr_InputTorqEst'
     *  Product: '<S2569>/Multiplication'
     *  Sum: '<S2569>/Subtraction'
     *  Sum: '<S2569>/Subtraction1'
     */
    VeESSR_M_EngTorqEst_DS = ((rtb_Switch1_bx - VeESSR_M_EngTorqEst_DS) *
        rtb_Sum_m5) + VeESSR_M_EngTorqEst_DS;

    /* DataStoreWrite: '<S2564>/Dsw_STMTmr' incorporates:
     *  Constant: '<S2584>/Calib'
     *  DataStoreRead: '<S2564>/Dsr_STMTmr2'
     *  Sum: '<S2564>/Summation1'
     */
    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

    /* Abs: '<S2578>/Abs' incorporates:
     *  Constant: '<S2584>/Calib'
     *  Constant: '<S2600>/Calib'
     *  Product: '<S2578>/Multiplication'
     */
    rtb_Switch1_idh = fabsf(KeESSR_dscl_RampDownRate * HeESSR_t_MedTEB_dT);

    /* Gain: '<S2578>/Gain' */
    rtb_Switch1_bx = -rtb_Switch1_idh;

    /* Switch: '<S2586>/Switch1' incorporates:
     *  Constant: '<S2604>/Calib'
     *  Constant: '<S2605>/Calib'
     */
    if (VeESSR_b_EngParking)
    {
        rtb_Sum_m5 = KeESSR_scl_RampDownHold;
    }
    else
    {
        rtb_Sum_m5 = KeESSR_scl_SpdCtrlEngOff;
    }

    /* End of Switch: '<S2586>/Switch1' */

    /* Sum: '<S2578>/Sum' incorporates:
     *  DataStoreRead: '<S2564>/Dsr_SpdCtlGainMod1'
     */
    rtb_Sum_m5 -= VeESSR_scl_SpdCtlGainMod_DS;

    /* Outputs for Atomic SubSystem: '<S2578>/Limiter1' */
    /* Switch: '<S2617>/Switch1' incorporates:
     *  RelationalOperator: '<S2617>/Relational Operator'
     */
    if (rtb_Switch1_idh >= rtb_Sum_m5)
    {
        /* Switch: '<S2618>/Switch1' */
        rtb_Switch1_idh = rtb_Sum_m5;
    }

    /* End of Switch: '<S2617>/Switch1' */

    /* Switch: '<S2617>/Switch' incorporates:
     *  RelationalOperator: '<S2617>/Relational Operator1'
     */
    if (rtb_Switch1_idh > rtb_Switch1_bx)
    {
        rtb_Switch1_bx = rtb_Switch1_idh;
    }

    /* End of Switch: '<S2617>/Switch' */
    /* End of Outputs for SubSystem: '<S2578>/Limiter1' */

    /* Sum: '<S2578>/Sum1' incorporates:
     *  DataStoreRead: '<S2564>/Dsr_SpdCtlGainMod1'
     */
    rtb_Switch1_bx += VeESSR_scl_SpdCtlGainMod_DS;

    /* Outputs for Atomic SubSystem: '<S2578>/Limiter2' */
    /* Switch: '<S2618>/Switch1' incorporates:
     *  Constant: '<S2564>/Constant Value7'
     *  RelationalOperator: '<S2618>/Relational Operator'
     */
    if (2.0F < rtb_Switch1_bx)
    {
        /* Switch: '<S2618>/Switch1' */
        rtb_Switch1_idh = 2.0F;
    }
    else
    {
        /* Switch: '<S2618>/Switch1' */
        rtb_Switch1_idh = rtb_Switch1_bx;
    }

    /* End of Switch: '<S2618>/Switch1' */

    /* Switch: '<S2618>/Switch' incorporates:
     *  Constant: '<S2564>/Constant Value2'
     *  DataStoreWrite: '<S2564>/Dsw_SpdCtlGainMod1'
     *  RelationalOperator: '<S2618>/Relational Operator1'
     */
    if (rtb_Switch1_idh > 0.0F)
    {
        VeESSR_scl_SpdCtlGainMod_DS = rtb_Switch1_idh;
    }
    else
    {
        VeESSR_scl_SpdCtlGainMod_DS = 0.0F;
    }

    /* End of Switch: '<S2618>/Switch' */
    /* End of Outputs for SubSystem: '<S2578>/Limiter2' */

    /* Switch: '<S2564>/Switch2' incorporates:
     *  Constant: '<S2564>/Constant Value4'
     *  DataStoreRead: '<S2564>/Dsr_EngTrqRespType2'
     *  DataStoreRead: '<S2564>/Dsr_EngTrqRespType6'
     *  DataStoreWrite: '<S2564>/Dsw_StrtStpFailDTC2'
     *  Logic: '<S2564>/Logical Operator2'
     *  Logic: '<S2564>/Logical21'
     *  RelationalOperator: '<S2564>/Comparison5'
     *  S-Function (sfix_bitop): '<S2564>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S2573>/FixPt Bitwise Operator1'
     */
    if ((rtb_LogicalOperator7_a || rtb_Comparison_p) &&
            ((VeESSR_g_StrtStpFailPhaseSelect_DS & 524288U) > 0U))
    {
        VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 524288U;
    }

    /* End of Switch: '<S2564>/Switch2' */

    /* If: '<S2564>/If' incorporates:
     *  DataStoreRead: '<S2564>/Data Store Read4'
     *  Logic: '<S2564>/Logical Operator4'
     *  Logic: '<S2564>/Logical Operator5'
     *  Logic: '<S2564>/Logical13'
     */
    if (rtb_AND2_n)
    {
        /* Outputs for IfAction SubSystem: '<S2564>/EngStop' incorporates:
         *  ActionPort: '<S2582>/Action Port'
         */
        /* DataStoreWrite: '<S2582>/Dsw_STMTrigger' incorporates:
         *  Constant: '<S2620>/Constant'
         */
        VeESSR_e_STMTrigger_DS = CeESSR_e_EngStop;

        /* End of Outputs for SubSystem: '<S2564>/EngStop' */
    }
    else if ((VeESSR_b_CoastDownTrigger_DS) || (rtu_AStopEngCOMLmp &&
              (!rtb_Logical9_i)))
    {
        /* Outputs for IfAction SubSystem: '<S2564>/CoastDown' incorporates:
         *  ActionPort: '<S2575>/Action Port'
         */
        ESSR_ac_CoastDown();

        /* End of Outputs for SubSystem: '<S2564>/CoastDown' */
    }
    else if (rtb_LogicalOperator3_k)
    {
        /* Outputs for IfAction SubSystem: '<S2564>/Restart' incorporates:
         *  ActionPort: '<S2611>/Action Port'
         */
        ESSR_ac_Restart();

        /* End of Outputs for SubSystem: '<S2564>/Restart' */
    }
    else
    {
        if (rtb_GreaterThan_px)
        {
            /* Outputs for IfAction SubSystem: '<S2564>/EngFail' incorporates:
             *  ActionPort: '<S2581>/Action Port'
             */
            ESSR_ac_EngFail();

            /* End of Outputs for SubSystem: '<S2564>/EngFail' */
        }
    }

    /* End of If: '<S2564>/If' */

    /* Update for UnitDelay: '<S2564>/Unit Delay' */
    localDW->UnitDelay_DSTATE = rtb_MinMax2_jh;
}

#endif

/* Output and update for function-call system: '<S13>/ESSC_ResetVars' */
#if Rte_SysCon_Variant_ESSR_Func

static FUNC(void, ESSR_CODE_LOCAL) ESSR_ac_ESSC_ResetVars(void)
{
    /* DataStoreWrite: '<S167>/Dsw_StrtStopFail' incorporates:
     *  Constant: '<S547>/Constant'
     *  DataStoreRead: '<S167>/Dsr_STMTrigger'
     *  DataStoreRead: '<S167>/Dsr_StrtStopFail'
     *  RelationalOperator: '<S167>/Equal'
     *  Switch: '<S550>/Switch1'
     */
    VeESSR_b_StrtStopFail_DS = ((((uint32)VeESSR_e_STMTrigger_DS) ==
        CeESSR_e_EngFail) || (VeESSR_b_StrtStopFail_DS));

    /* DataStoreWrite: '<S167>/Dsw_EngStartAbort' incorporates:
     *  Constant: '<S548>/Constant'
     *  DataStoreRead: '<S167>/Dsr_EngStartAbort'
     *  DataStoreRead: '<S167>/Dsr_STMTrigger'
     *  RelationalOperator: '<S167>/Equal'
     *  RelationalOperator: '<S167>/Equal1'
     *  Switch: '<S551>/Switch1'
     */
    VeESSR_b_EngStartAbort_DS = ((((uint32)VeESSR_e_STMTrigger_DS) ==
        CeESSR_e_StartAbort) || (VeESSR_b_EngStartAbort_DS));

    /* DataStoreWrite: '<S167>/Dsw_STMTrigger' incorporates:
     *  Constant: '<S546>/Constant'
     */
    VeESSR_e_STMTrigger_DS = CeESSR_e_Inactive;

    /* DataStoreWrite: '<S167>/Dsw_STMTmr' incorporates:
     *  Constant: '<S167>/Constant Value'
     */
    VeESSR_t_STMTmr_DS = 0.0F;

    /* DataStoreRead: '<S167>/Dsr_EngStartStopSt' */
    VeESSR_e_EngStartStopStPrev = VeESSR_e_EngStartStopSt_DS;

    /* DataStoreWrite: '<S167>/Data Store Write' incorporates:
     *  DataStoreRead: '<S167>/Dsr_EngStartStopSt'
     */
    VeESSR_e_EngStartStopStPrev_DS = VeESSR_e_EngStartStopStPrev;

    /* DataStoreWrite: '<S167>/Dsw_EngRestartReq' incorporates:
     *  Constant: '<S167>/FALSE Constant'
     */
    VeESSR_b_PFSRunReq_DS = false;

    /* DataStoreWrite: '<S167>/Dsw_SE_EngFuelOn' incorporates:
     *  Constant: '<S167>/FALSE Constant1'
     */
    VeESSR_b_SE_EngFuelOn_DS = false;
}

#endif

/* Function for Chart: '<S13>/ESSC_EngStartStopSTM' */
#if Rte_SysCon_Variant_ESSR_Func

static void ESS_enter_internal_EngStartCtrl(const boolean *Dsr_EngRestartReq,
    const boolean *Dsr_PFSRunReq, const boolean *BmpStrtFailed, const boolean
    *Dsr_PFSRunReq1, const TeESSR_e_StrtType *Dsr_EngStrtType)
{
    sint32 iU;
    float32 rtb_MinMax_if[2];
    float32 rtb_Product_in;
    float32 rtb_Sum_k0;
    float32 rtb_Switch1_oim;
    boolean rtb_Equal2;
    boolean rtb_GreaterThan1_f;
    boolean rtb_Logical2_eb;
    boolean rtb_LogicalOperator_h;
    boolean rtb_Switch1_au;
    boolean rtb_Switch5_hb;

    /* Inport: '<Root>/VeESMR_P_BatSTMinLim' */
    /* Entry Internal 'EngStartCtrl': '<S165>:4' */
    /* Transition: '<S165>:30' */
    (void)Rte_Read_VeESMR_P_BatSTMinLim_Value(&rtb_Sum_k0);
    rtb_Equal2 = !(*Dsr_EngRestartReq);
    rtb_Switch1_au = ((HeESSR_b_CltchStrtEquipped) && rtb_Equal2);

    /* DataStoreRead: '<S13>/Dsr_EngStrtType' incorporates:
     *  Inport: '<Root>/VeBPCR_T_BatModTmp'
     */
    if (rtb_Switch1_au && (((uint32)(*Dsr_EngStrtType)) ==
                           CeESSR_e_EMLwPwrStrtAlgo))
    {
        /* Transition: '<S165>:224' */
        ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_InitEngSpin_7;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'InitEngSpin_7': '<S165>:225' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

        /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinEnt' */
        /* Event: '<S165>:80' */
        ESSR_ac_InitEngSpinEnt(ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                               ESSR_ac_B.TmpSignalConversionAtVeESMR_P_d,
                               rtb_Sum_k0,
                               ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d);

        /* End of Outputs for SubSystem: '<S559>/InitEngSpinEnt' */

        /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinDur' */
        /* RelationalOperator: '<S1022>/Equal2' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr'
         */
        /* Event: '<S165>:81' */
        rtb_Equal2 = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

        /* Switch: '<S1078>/Switch1' incorporates:
         *  Constant: '<S1033>/Constant Value5'
         *  UnitDelay: '<S1078>/Unit Delay'
         */
        if (rtb_Equal2)
        {
            rtb_Sum_k0 = 0.0F;
        }
        else
        {
            rtb_Sum_k0 = ESSR_ac_DW.UnitDelay_DSTATE_iu;
        }

        /* Sum: '<S1033>/Sum' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitSpinScaler'
         *  Product: '<S1022>/Product'
         */
        rtb_Sum_k0 += HeESSR_t_MedTEB_dT * VeESSR_k_StrtTypInitSpinScaler_DS;

        /* Outputs for Atomic SubSystem: '<S1033>/Limiter' */
        /* Switch: '<S1077>/Switch1' incorporates:
         *  DataStoreRead: '<S1033>/Dsr_StrtTypInitSpinEndPnt'
         *  RelationalOperator: '<S1077>/Relational Operator'
         */
        if (VeESSR_Cnt_StrtTypInitSpinEndPnt_DS < rtb_Sum_k0)
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;
        }
        else
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = rtb_Sum_k0;
        }

        /* Switch: '<S1077>/Switch' incorporates:
         *  Constant: '<S1033>/Constant Value1'
         *  RelationalOperator: '<S1077>/Relational Operator1'
         */
        if (rtb_Product_in > 0.0F)
        {
            /* Switch: '<S1077>/Switch' */
            VeESSR_Cnt_InitSpnStepPt = rtb_Product_in;
        }
        else
        {
            /* Switch: '<S1077>/Switch' */
            VeESSR_Cnt_InitSpnStepPt = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1033>/Limiter' */

        /* RelationalOperator: '<S1034>/Greater  Than2' incorporates:
         *  DataStoreRead: '<S1034>/Dsr_StrtTypInitSpinEndPnt'
         */
        VeESSR_b_InitSpnTmrCmplt = (VeESSR_Cnt_InitSpnStepPt >=
            VeESSR_Cnt_StrtTypInitSpinEndPnt_DS);

        /* Outputs for Atomic SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */
        /* Switch: '<S1058>/Switch' */
        if (rtb_Equal2)
        {
            /* Switch: '<S1058>/Switch' incorporates:
             *  Constant: '<S1029>/Constant Value4'
             */
            rtb_Switch1_oim = 0.0F;
        }
        else
        {
            /* Switch: '<S1058>/Switch' incorporates:
             *  Constant: '<S1029>/Cnvrt2Deg'
             *  Constant: '<S1057>/Calib'
             *  Product: '<S1058>/Division'
             *  Product: '<S1058>/Multiplication'
             *  Sum: '<S1058>/Sum//Sub'
             *  UnitDelay: '<S1058>/Unit Delay'
             */
            rtb_Switch1_oim = ((HeESSR_t_MedTEB_dT / 0.166666672F) *
                               ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I) +
                ESSR_ac_DW.UnitDelay_DSTATE_e;
        }

        /* Outputs for Atomic SubSystem: '<S1058>/Limiter' */
        /* Switch: '<S1061>/Switch1' incorporates:
         *  Constant: '<S1029>/Constant Value1'
         *  RelationalOperator: '<S1061>/Relational Operator'
         */
        if (999.0F < rtb_Switch1_oim)
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = 999.0F;
        }
        else
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = rtb_Switch1_oim;
        }

        /* Switch: '<S1061>/Switch' incorporates:
         *  Constant: '<S1029>/Constant Value'
         *  RelationalOperator: '<S1061>/Relational Operator1'
         */
        if (rtb_Product_in <= 0.0F)
        {
            /* Switch: '<S1061>/Switch' */
            rtb_Product_in = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1058>/Limiter' */

        /* Update for UnitDelay: '<S1058>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_e = rtb_Product_in;

        /* End of Outputs for SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */

        /* Switch: '<S1070>/Switch1' incorporates:
         *  Constant: '<S1029>/Constant Value3'
         *  DataStoreRead: '<S1029>/Dsr_STMTmr3'
         *  Product: '<S1060>/Division'
         *  Sum: '<S1029>/Subtraction'
         */
        rtb_Switch1_oim = (ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi -
                           VeESSR_phi_InitEngAng720_DS) / 720.0F;

        /* Logic: '<S1029>/AND' incorporates:
         *  Constant: '<S1029>/Constant Value3'
         *  DataStoreRead: '<S1029>/Dsr_STMTmr1'
         *  Product: '<S1060>/Multiplication'
         *  RelationalOperator: '<S1029>/Greater  Than1'
         *  RelationalOperator: '<S1029>/Greater  Than2'
         *  Rounding: '<S1060>/Floor'
         *  Sum: '<S1060>/Subtraction'
         */
        VeESSR_b_InitSpnEngMvmntDet = ((rtb_Product_in >
            VeESSR_phi_StrtTypInitSpinBrkAng_DS) || (((rtb_Switch1_oim - roundf
            (rtb_Switch1_oim)) * 720.0F) > VeESSR_phi_StrtTypInitSpinBrkAng_DS));

        /* Switch: '<S1044>/Switch1' incorporates:
         *  Logic: '<S1022>/Logical'
         */
        rtb_Switch1_au = ((VeESSR_b_InitSpnTmrCmplt) ||
                          (VeESSR_b_InitSpnEngMvmntDet));

        /* RelationalOperator: '<S1022>/Greater  Than1' incorporates:
         *  Constant: '<S1050>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr1'
         */
        rtb_GreaterThan1_f = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmInitSpin);

        /* Logic: '<S1022>/Logical Operator' incorporates:
         *  Logic: '<S1022>/Logical Operator1'
         */
        rtb_LogicalOperator_h = ((!rtb_Switch1_au) && rtb_GreaterThan1_f);

        /* Switch: '<S1022>/Switch3' incorporates:
         *  DataStoreRead: '<S1022>/Data Store Read'
         *  DataStoreRead: '<S1022>/Data Store Read1'
         *  DataStoreWrite: '<S1022>/Data Store Write'
         *  DataStoreWrite: '<S1022>/Data Store Write1'
         *  S-Function (sfix_bitop): '<S1026>/FixPt Bitwise Operator1'
         *  S-Function (sfix_bitop): '<S1027>/FixPt Bitwise Operator1'
         *  Switch: '<S1022>/Switch1'
         */
        if (rtb_LogicalOperator_h)
        {
            ESSR_ac_DW.NeESSR_g_StrtStpFailRsn |= 4U;
            VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS | 1U;
        }

        /* Outputs for Atomic SubSystem: '<S1030>/Protected Division' */
        /* Switch: '<S1069>/Switch1' incorporates:
         *  Constant: '<S1063>/Calib'
         *  Constant: '<S1069>/Constant Value'
         *  Constant: '<S1069>/Constant Value1'
         *  Constant: '<S1069>/Constant Value2'
         *  Constant: '<S1069>/Constant Value3'
         *  DataStoreRead: '<S1030>/Dsr_STMTmr2'
         *  Logic: '<S1069>/AND'
         *  RelationalOperator: '<S1069>/Greater Than or Equal '
         *  RelationalOperator: '<S1069>/Greater Than or Equal 1'
         *  RelationalOperator: '<S1069>/Not Equal'
         *  RelationalOperator: '<S1069>/Not Equal1'
         *  Switch: '<S1069>/Switch2'
         *  Switch: '<S1069>/Switch3'
         */
        if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT != 0.0F))
        {
            /* Switch: '<S1069>/Switch1' incorporates:
             *  Product: '<S1069>/Division'
             */
            rtb_Switch1_oim = VeESSR_t_STMTmr_DS / HeESSR_t_MedTEB_dT;
        }
        else if (VeESSR_t_STMTmr_DS > 0.0F)
        {
            /* Switch: '<S1069>/Switch2' incorporates:
             *  Constant: '<S1069>/MAXFLOAT'
             *  Switch: '<S1069>/Switch1'
             */
            rtb_Switch1_oim = 3.402823466E+38F;
        }
        else if (VeESSR_t_STMTmr_DS < 0.0F)
        {
            /* Switch: '<S1069>/Switch3' incorporates:
             *  Constant: '<S1069>/MINFLOAT'
             *  Switch: '<S1069>/Switch1'
             *  Switch: '<S1069>/Switch2'
             */
            rtb_Switch1_oim = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1069>/Switch1' incorporates:
             *  Constant: '<S1069>/Constant Value4'
             *  Switch: '<S1069>/Switch2'
             *  Switch: '<S1069>/Switch3'
             */
            rtb_Switch1_oim = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1030>/Protected Division' */

        /* Sum: '<S1030>/Summation2' incorporates:
         *  Constant: '<S1030>/Constant Value'
         *  Gain: '<S1030>/Gain'
         *  Lookup_n-D: '<S1066>/Vector'
         *  Lookup_n-D: '<S1068>/Vector'
         *  MinMax: '<S1030>/MinMax'
         *  Product: '<S1030>/Product1'
         *  Switch: '<S1069>/Switch1'
         */
        VeESSR_M_InitSpinEngFricEngStrtTorq = (fmaxf(-VeESSR_M_EngTrqAct_Lmtd,
            0.0F) * look1_iflf_binlcapw(rtb_Switch1_oim, ((const float32 *)
            &(KxESSR_K_InitSpinEngStrtTorqGain[0])), ((const float32 *)
            &(KtESSR_K_InitSpinEngStrtTorqGain[0])), 4U)) + look1_iflf_binlcapw
            (rtb_Switch1_oim, ((const float32 *)
                               &(KxESSR_M_InitSpinEngStrtTorqOffset[0])), ((
               const float32 *)&(KtESSR_M_InitSpinEngStrtTorqOffset[0])), 4U);

        /* Abs: '<S1030>/Abs' */
        VeESSR_M_InitSpinEngPulseEngStrtTorq = fabsf
            (ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E);

        /* Lookup_n-D: '<S1067>/Vector' incorporates:
         *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
         */
        VeESSR_M_InitSpinECTEngStrtTorq = look1_iflf_binlcapw
            (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const float32 *)
              &(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((const float32 *)
              &(KtESSR_M_ECTAddtlEngStrtTorq[0])), 6U);

        /* Sum: '<S1030>/Summation1' */
        VeESSR_M_InitSpinEngStrtTorqRaw = (VeESSR_M_InitSpinEngFricEngStrtTorq +
            VeESSR_M_InitSpinEngPulseEngStrtTorq) +
            VeESSR_M_InitSpinECTEngStrtTorq;

        /* Outputs for Atomic SubSystem: '<S1030>/GradientLimiter' */
        /* Product: '<S1032>/Product' incorporates:
         *  UnitDelay: '<S1062>/Unit Delay'
         */
        rtb_Product_in = ESSR_ac_DW.UnitDelay_DSTATE_h;

        /* Sum: '<S1062>/Sum2' */
        rtb_Switch1_oim = VeESSR_M_InitSpinEngStrtTorqRaw - rtb_Product_in;

        /* Outputs for Atomic SubSystem: '<S1062>/Limiter' */
        /* Switch: '<S1070>/Switch1' incorporates:
         *  Constant: '<S1065>/Calib'
         *  RelationalOperator: '<S1070>/Relational Operator'
         */
        if (KeESSR_dM_InitSpinEngStrtTorqLU < rtb_Switch1_oim)
        {
            /* Switch: '<S1070>/Switch1' */
            rtb_Switch1_oim = KeESSR_dM_InitSpinEngStrtTorqLU;
        }

        /* Switch: '<S1070>/Switch' incorporates:
         *  Constant: '<S1064>/Calib'
         *  RelationalOperator: '<S1070>/Relational Operator1'
         */
        if (rtb_Switch1_oim <= KeESSR_dM_InitSpinEngStrtTorqLD)
        {
            rtb_Switch1_oim = KeESSR_dM_InitSpinEngStrtTorqLD;
        }

        /* End of Outputs for SubSystem: '<S1062>/Limiter' */

        /* Sum: '<S1062>/Sum3' */
        VeESSR_M_InitSpinEngStrtTorqLmtd = rtb_Switch1_oim + rtb_Product_in;

        /* Update for UnitDelay: '<S1062>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_h = VeESSR_M_InitSpinEngStrtTorqLmtd;

        /* End of Outputs for SubSystem: '<S1030>/GradientLimiter' */

        /* Switch: '<S1022>/Switch7' incorporates:
         *  Constant: '<S1040>/Calib'
         *  DataStoreWrite: '<S1022>/Data Store Write3'
         */
        if (!HeESSR_b_EngStrtTorq)
        {
            VeESSR_M_EngStrtTorq_DS = VeESSR_M_InitSpinEngStrtTorqLmtd;
        }

        /* Logic: '<S1022>/Logical2' incorporates:
         *  Constant: '<S1036>/Constant'
         *  Constant: '<S1037>/Constant'
         *  Constant: '<S1038>/Calib'
         *  Constant: '<S1039>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
         *  Logic: '<S1022>/Logical1'
         *  Logic: '<S1022>/Logical3'
         *  Logic: '<S1022>/Logical6'
         *  RelationalOperator: '<S1022>/Comparison1'
         *  RelationalOperator: '<S1022>/Comparison4'
         */
        rtb_Logical2_eb = ((((uint32)VeESSR_e_EngStrtProfType_DS) ==
                            CeESSR_e_KeyCrnkAlgo) || (((uint32)
                             VeESSR_e_EngStrtProfType_DS) == CeESSR_e_LowPwrAlgo));
        rtb_Logical2_eb = (((HeESSR_b_12vStrtrEquipped) ||
                            ((HeESSR_b_BumpStrtEquipped) && rtb_Logical2_eb)) &&
                           rtb_Logical2_eb);

        /* MinMax: '<S1032>/MinMax' incorporates:
         *  DataStoreRead: '<S1032>/Dsr_StrtTypInitSpinEndPnt'
         *  SignalConversion generated from: '<S1075>/Vector'
         */
        rtb_MinMax_if[0] = VeESSR_Cnt_InitSpnStepPt;
        rtb_MinMax_if[1] = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;

        /* Sum: '<S1032>/Sum' */
        rtb_Switch1_oim = VeESSR_M_EngTrqAct_Lmtd - VeESSR_M_SpnUpAddtlTorq;
        for (iU = 0; iU < 2; iU++)
        {
            rtb_MinMax_if[iU] = fmaxf(VeESSR_M_TiEstMin, look1_iflf_binlcapw
                (rtb_MinMax_if[iU], ((const float32 *)&(KxESSR_K_InitSpinTiProf
                [0])), ((const float32 *)&(KtESSR_K_InitSpinTiProf[0])), 6U) *
                rtb_Switch1_oim);
        }

        /* Switch: '<S1022>/Switch2' incorporates:
         *  Constant: '<S1022>/Constant Value1'
         *  DataStoreWrite: '<S1022>/Dsw_InputTorqEst'
         *  Lookup_n-D: '<S1075>/Vector'
         *  MinMax: '<S1032>/MinMax'
         *  Product: '<S1032>/Product1'
         */
        if (rtb_Logical2_eb)
        {
            VeESSR_M_EngTorqEst_DS = 0.0F;
        }
        else
        {
            VeESSR_M_EngTorqEst_DS = rtb_MinMax_if[0];
        }

        /* DataStoreWrite: '<S1022>/Dsw_STMTmr' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr'
         *  Sum: '<S1022>/Summation'
         */
        VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

        /* Switch: '<S1044>/Switch1' incorporates:
         *  Constant: '<S1049>/Calib'
         */
        if (KeESSR_b_InitSpnTmrChkOnly)
        {
            /* Switch: '<S1044>/Switch1' */
            rtb_Switch1_au = VeESSR_b_InitSpnTmrCmplt;
        }

        /* SignalConversion generated from: '<S1022>/Variant Source' incorporates:
         *  Logic: '<S1054>/Logical1'
         *  Logic: '<S1054>/Logical2'
         *  Logic: '<S1054>/Logical3'
         *  Logic: '<S1054>/Logical4'
         *  RelationalOperator: '<S1054>/Comparison1'
         *  RelationalOperator: '<S1054>/Comparison6'
         *  RelationalOperator: '<S1054>/Comparison7'
         *  RelationalOperator: '<S1054>/Comparison8'
         */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

        /* Switch: '<S1022>/Switch5' incorporates:
         *  Constant: '<S1022>/FALSE Constant1'
         */
        rtb_Switch5_hb = false;

#else

        /* Logic: '<S1054>/Logical4' incorporates:
         *  Constant: '<S1085>/Constant'
         *  Constant: '<S1086>/Constant'
         *  Constant: '<S1087>/Constant'
         *  Constant: '<S1088>/Constant'
         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
         *  Logic: '<S1054>/Logical1'
         *  Logic: '<S1054>/Logical2'
         *  Logic: '<S1054>/Logical3'
         *  RelationalOperator: '<S1022>/Comparison4'
         *  RelationalOperator: '<S1054>/Comparison1'
         *  RelationalOperator: '<S1054>/Comparison6'
         *  RelationalOperator: '<S1054>/Comparison7'
         *  RelationalOperator: '<S1054>/Comparison8'
         */
        VeESSR_b_InitSpin_48VP2CoastDown = (((((((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMStrtAlgo) || (((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_ImplStrtAlgo)) || (((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo)) &&
            (VeESSR_b_EMErlyExitLmp)) || ((((uint32)VeESSR_e_EngStrtProfType_DS)
            == CeESSR_e_CltchStrtAlgo) && (VeESSR_b_ClthErlyExitLmp)));

        /* Switch: '<S1022>/Switch5' */
        rtb_Switch5_hb = VeESSR_b_InitSpin_48VP2CoastDown;

#endif

        /* Switch: '<S1022>/Switch5' */
        if (!VeESSR_b_StrtTypChngDisbl)
        {
            /* Switch: '<S1022>/Switch5' incorporates:
             *  Constant: '<S1035>/Constant'
             *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
             *  Logic: '<S1022>/Logical Operator4'
             *  Logic: '<S1022>/Logical Operator5'
             *  RelationalOperator: '<S1022>/Comparison2'
             *  RelationalOperator: '<S1022>/Comparison4'
             */
            rtb_Switch5_hb = (((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B) ||
                               ((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d) &&
                                (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                 CeESSR_e_KeyCrnkAlgo))) ||
                              (VeESSR_b_ErlyExitLmp));
        }

        /* Logic: '<S1022>/Logical Operator3' incorporates:
         *  Constant: '<S1041>/Calib'
         *  Constant: '<S1045>/Calib'
         *  Constant: '<S1046>/Calib'
         *  Constant: '<S1047>/Calib'
         *  Constant: '<S1048>/Calib'
         *  DataStoreRead: '<S1022>/Data Store Read18'
         *  DataStoreRead: '<S1022>/Data Store Read19'
         *  Logic: '<S1022>/Logical Operator2'
         *  Logic: '<S1022>/Logical5'
         *  Logic: '<S1022>/Logical8'
         *  Logic: '<S1022>/Logical9'
         *  RelationalOperator: '<S1022>/Greater  Than11'
         *  RelationalOperator: '<S1022>/Greater  Than15'
         */
        VeESSR_b_InitSpin_CoastDownTrig = ((rtb_Switch5_hb ||
            rtb_LogicalOperator_h) && ((((KeESSR_b_EnblFtrBackupStrt) &&
            (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
             KeESSR_Cnt_BackupStrtMaxAttmpts)) || ((KeESSR_b_EnblFtrBumpStrt) &&
            (VeESSR_Cnt_BumpStrtAttmptCntr_DS < KeESSR_Cnt_BumpStrtMaxAttmpts)))
            || (HeESSR_b_LimphomeEnbl)));

        /* If: '<S1022>/If1' */
        if (rtb_Switch1_au)
        {
            /* Outputs for IfAction SubSystem: '<S1022>/NormExit' incorporates:
             *  ActionPort: '<S1052>/Action Port'
             */
            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S1082>/Constant'
             *  Merge: '<S1022>/Merge1'
             *  SignalConversion generated from: '<S1052>/ESSTrig'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_EngBrkawayAch;

            /* End of Outputs for SubSystem: '<S1022>/NormExit' */
        }
        else if (VeESSR_b_InitSpin_CoastDownTrig)
        {
            /* Outputs for IfAction SubSystem: '<S1022>/If Action Subsystem' incorporates:
             *  ActionPort: '<S1043>/Action Port'
             */
            /* Switch: '<S1043>/Switch' incorporates:
             *  Constant: '<S1080>/Constant'
             *  Constant: '<S1081>/Constant'
             *  DataStoreRead: '<S1043>/Data Store Read5'
             *  DataStoreWrite: '<S1043>/Dsw_StrtStpFailDTC'
             */
            if (VeESSR_b_BSGStrtFailed_DS)
            {
                VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;
            }
            else
            {
                VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
            }

            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S1079>/Constant'
             *  Merge: '<S1022>/Merge1'
             *  SignalConversion generated from: '<S1043>/ESSTrig'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

            /* End of Outputs for SubSystem: '<S1022>/If Action Subsystem' */
        }
        else
        {
            if (rtb_GreaterThan1_f)
            {
                /* Outputs for IfAction SubSystem: '<S1022>/OffFail' incorporates:
                 *  ActionPort: '<S1053>/Action Port'
                 */
                /* DataStoreWrite: '<S1053>/Dsw_StrtStpFailDTC' incorporates:
                 *  Constant: '<S1084>/Constant'
                 */
                VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;

                /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                 *  Constant: '<S1083>/Constant'
                 *  Merge: '<S1022>/Merge1'
                 *  SignalConversion generated from: '<S1053>/ESSTrig'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

                /* End of Outputs for SubSystem: '<S1022>/OffFail' */
            }
        }

        /* Switch: '<S1022>/Switch4' incorporates:
         *  Constant: '<S1022>/Constant Value2'
         *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType2'
         *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType6'
         *  DataStoreWrite: '<S1022>/Dsw_StrtStpFailDTC1'
         *  Logic: '<S1022>/Logical21'
         *  Logic: '<S1022>/Logical7'
         *  RelationalOperator: '<S1022>/Comparison'
         *  S-Function (sfix_bitop): '<S1022>/Bitwise Operator'
         *  S-Function (sfix_bitop): '<S1028>/FixPt Bitwise Operator1'
         */
        if (((VeESSR_b_InitSpin_CoastDownTrig) || rtb_GreaterThan1_f) &&
                ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16U) > 0U))
        {
            VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 16U;
        }

        /* Switch: '<S1071>/Switch1' incorporates:
         *  Constant: '<S1072>/Calib'
         *  DataStoreWrite: '<S1031>/Dsw_InitEngAng720'
         *  RelationalOperator: '<S1031>/Equal1'
         */
        if (VeESSR_Cnt_InitSpnStepPt <= KeESSR_t_InitSpnInitAngTm)
        {
            VeESSR_phi_InitEngAng720_DS =
                ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi;
        }

        /* Sum: '<S1032>/Subtract' incorporates:
         *  Constant: '<S1074>/Calib'
         *  DataStoreRead: '<S1032>/Dsr_NiProfGenNiDMax'
         *  DataStoreWrite: '<S1032>/Data Store Write'
         *  Product: '<S1032>/Product'
         */
        ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = rtb_MinMax_if[1] -
            (VeESSR_dn_StrtTypNiDotMax_DS * KeESSR_r_NiDtoTiMargin);

        /* DataStoreWrite: '<S1022>/Dsw_InputAcceltnProf1' */
        VeESSR_dn_InputAcceltnProf_DS =
            ESSR_ac_B.VariantMerge_For_Variant_Source;

        /* RelationalOperator: '<S1022>/Equal1' incorporates:
         *  Constant: '<S1022>/Constant Value'
         *  DataStoreRead: '<S1022>/Data Store Read5'
         *  DataStoreWrite: '<S1022>/Data Store Write5'
         */
        VeESSR_b_BSGStrtFailed_DS = (VeESSR_g_BSGStrtFailRsn_DS != 0U);

        /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqImmed' incorporates:
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitImmedTorq'
         */
        VeESSR_M_EngTrqReqImmed_DS = VeESSR_M_StrtTypInitImmedTorq_DS;

        /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqPrdtd1' incorporates:
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitPredTorq'
         */
        VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

        /* Switch: '<S1078>/Switch3' */
        if (rtb_Equal2)
        {
            /* Update for UnitDelay: '<S1078>/Unit Delay' incorporates:
             *  Constant: '<S1033>/Constant Value5'
             */
            ESSR_ac_DW.UnitDelay_DSTATE_iu = 0.0F;
        }
        else
        {
            /* Update for UnitDelay: '<S1078>/Unit Delay' */
            ESSR_ac_DW.UnitDelay_DSTATE_iu = rtb_Sum_k0;
        }

        /* End of Outputs for SubSystem: '<S559>/InitEngSpinDur' */
    }
    else if (rtb_Switch1_au && (((uint32)(*Dsr_EngStrtType)) ==
                                CeESSR_e_EMStrtAlgo))
    {
        /* Transition: '<S165>:206' */
        ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_InitEngSpin_6;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'InitEngSpin_6': '<S165>:195' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

        /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinEnt' */
        /* Event: '<S165>:80' */
        ESSR_ac_InitEngSpinEnt(ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                               ESSR_ac_B.TmpSignalConversionAtVeESMR_P_d,
                               rtb_Sum_k0,
                               ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d);

        /* End of Outputs for SubSystem: '<S559>/InitEngSpinEnt' */

        /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinDur' */
        /* RelationalOperator: '<S1022>/Equal2' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr'
         */
        /* Event: '<S165>:81' */
        rtb_Equal2 = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

        /* Switch: '<S1078>/Switch1' incorporates:
         *  Constant: '<S1033>/Constant Value5'
         *  UnitDelay: '<S1078>/Unit Delay'
         */
        if (rtb_Equal2)
        {
            rtb_Sum_k0 = 0.0F;
        }
        else
        {
            rtb_Sum_k0 = ESSR_ac_DW.UnitDelay_DSTATE_iu;
        }

        /* Sum: '<S1033>/Sum' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitSpinScaler'
         *  Product: '<S1022>/Product'
         */
        rtb_Sum_k0 += HeESSR_t_MedTEB_dT * VeESSR_k_StrtTypInitSpinScaler_DS;

        /* Outputs for Atomic SubSystem: '<S1033>/Limiter' */
        /* Switch: '<S1077>/Switch1' incorporates:
         *  DataStoreRead: '<S1033>/Dsr_StrtTypInitSpinEndPnt'
         *  RelationalOperator: '<S1077>/Relational Operator'
         */
        if (VeESSR_Cnt_StrtTypInitSpinEndPnt_DS < rtb_Sum_k0)
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;
        }
        else
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = rtb_Sum_k0;
        }

        /* Switch: '<S1077>/Switch' incorporates:
         *  Constant: '<S1033>/Constant Value1'
         *  RelationalOperator: '<S1077>/Relational Operator1'
         */
        if (rtb_Product_in > 0.0F)
        {
            /* Switch: '<S1077>/Switch' */
            VeESSR_Cnt_InitSpnStepPt = rtb_Product_in;
        }
        else
        {
            /* Switch: '<S1077>/Switch' */
            VeESSR_Cnt_InitSpnStepPt = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1033>/Limiter' */

        /* RelationalOperator: '<S1034>/Greater  Than2' incorporates:
         *  DataStoreRead: '<S1034>/Dsr_StrtTypInitSpinEndPnt'
         */
        VeESSR_b_InitSpnTmrCmplt = (VeESSR_Cnt_InitSpnStepPt >=
            VeESSR_Cnt_StrtTypInitSpinEndPnt_DS);

        /* Outputs for Atomic SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */
        /* Switch: '<S1058>/Switch' */
        if (rtb_Equal2)
        {
            /* Switch: '<S1058>/Switch' incorporates:
             *  Constant: '<S1029>/Constant Value4'
             */
            rtb_Switch1_oim = 0.0F;
        }
        else
        {
            /* Switch: '<S1058>/Switch' incorporates:
             *  Constant: '<S1029>/Cnvrt2Deg'
             *  Constant: '<S1057>/Calib'
             *  Product: '<S1058>/Division'
             *  Product: '<S1058>/Multiplication'
             *  Sum: '<S1058>/Sum//Sub'
             *  UnitDelay: '<S1058>/Unit Delay'
             */
            rtb_Switch1_oim = ((HeESSR_t_MedTEB_dT / 0.166666672F) *
                               ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I) +
                ESSR_ac_DW.UnitDelay_DSTATE_e;
        }

        /* Outputs for Atomic SubSystem: '<S1058>/Limiter' */
        /* Switch: '<S1061>/Switch1' incorporates:
         *  Constant: '<S1029>/Constant Value1'
         *  RelationalOperator: '<S1061>/Relational Operator'
         */
        if (999.0F < rtb_Switch1_oim)
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = 999.0F;
        }
        else
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = rtb_Switch1_oim;
        }

        /* Switch: '<S1061>/Switch' incorporates:
         *  Constant: '<S1029>/Constant Value'
         *  RelationalOperator: '<S1061>/Relational Operator1'
         */
        if (rtb_Product_in <= 0.0F)
        {
            /* Switch: '<S1061>/Switch' */
            rtb_Product_in = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1058>/Limiter' */

        /* Update for UnitDelay: '<S1058>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_e = rtb_Product_in;

        /* End of Outputs for SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */

        /* Switch: '<S1070>/Switch1' incorporates:
         *  Constant: '<S1029>/Constant Value3'
         *  DataStoreRead: '<S1029>/Dsr_STMTmr3'
         *  Product: '<S1060>/Division'
         *  Sum: '<S1029>/Subtraction'
         */
        rtb_Switch1_oim = (ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi -
                           VeESSR_phi_InitEngAng720_DS) / 720.0F;

        /* Logic: '<S1029>/AND' incorporates:
         *  Constant: '<S1029>/Constant Value3'
         *  DataStoreRead: '<S1029>/Dsr_STMTmr1'
         *  Product: '<S1060>/Multiplication'
         *  RelationalOperator: '<S1029>/Greater  Than1'
         *  RelationalOperator: '<S1029>/Greater  Than2'
         *  Rounding: '<S1060>/Floor'
         *  Sum: '<S1060>/Subtraction'
         */
        VeESSR_b_InitSpnEngMvmntDet = ((rtb_Product_in >
            VeESSR_phi_StrtTypInitSpinBrkAng_DS) || (((rtb_Switch1_oim - roundf
            (rtb_Switch1_oim)) * 720.0F) > VeESSR_phi_StrtTypInitSpinBrkAng_DS));

        /* Switch: '<S1044>/Switch1' incorporates:
         *  Logic: '<S1022>/Logical'
         */
        rtb_Switch1_au = ((VeESSR_b_InitSpnTmrCmplt) ||
                          (VeESSR_b_InitSpnEngMvmntDet));

        /* RelationalOperator: '<S1022>/Greater  Than1' incorporates:
         *  Constant: '<S1050>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr1'
         */
        rtb_GreaterThan1_f = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmInitSpin);

        /* Logic: '<S1022>/Logical Operator' incorporates:
         *  Logic: '<S1022>/Logical Operator1'
         */
        rtb_LogicalOperator_h = ((!rtb_Switch1_au) && rtb_GreaterThan1_f);

        /* Switch: '<S1022>/Switch3' incorporates:
         *  DataStoreRead: '<S1022>/Data Store Read'
         *  DataStoreRead: '<S1022>/Data Store Read1'
         *  DataStoreWrite: '<S1022>/Data Store Write'
         *  DataStoreWrite: '<S1022>/Data Store Write1'
         *  S-Function (sfix_bitop): '<S1026>/FixPt Bitwise Operator1'
         *  S-Function (sfix_bitop): '<S1027>/FixPt Bitwise Operator1'
         *  Switch: '<S1022>/Switch1'
         */
        if (rtb_LogicalOperator_h)
        {
            ESSR_ac_DW.NeESSR_g_StrtStpFailRsn |= 4U;
            VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS | 1U;
        }

        /* Outputs for Atomic SubSystem: '<S1030>/Protected Division' */
        /* Switch: '<S1069>/Switch1' incorporates:
         *  Constant: '<S1063>/Calib'
         *  Constant: '<S1069>/Constant Value'
         *  Constant: '<S1069>/Constant Value1'
         *  Constant: '<S1069>/Constant Value2'
         *  Constant: '<S1069>/Constant Value3'
         *  DataStoreRead: '<S1030>/Dsr_STMTmr2'
         *  Logic: '<S1069>/AND'
         *  RelationalOperator: '<S1069>/Greater Than or Equal '
         *  RelationalOperator: '<S1069>/Greater Than or Equal 1'
         *  RelationalOperator: '<S1069>/Not Equal'
         *  RelationalOperator: '<S1069>/Not Equal1'
         *  Switch: '<S1069>/Switch2'
         *  Switch: '<S1069>/Switch3'
         */
        if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT != 0.0F))
        {
            /* Switch: '<S1069>/Switch1' incorporates:
             *  Product: '<S1069>/Division'
             */
            rtb_Switch1_oim = VeESSR_t_STMTmr_DS / HeESSR_t_MedTEB_dT;
        }
        else if (VeESSR_t_STMTmr_DS > 0.0F)
        {
            /* Switch: '<S1069>/Switch2' incorporates:
             *  Constant: '<S1069>/MAXFLOAT'
             *  Switch: '<S1069>/Switch1'
             */
            rtb_Switch1_oim = 3.402823466E+38F;
        }
        else if (VeESSR_t_STMTmr_DS < 0.0F)
        {
            /* Switch: '<S1069>/Switch3' incorporates:
             *  Constant: '<S1069>/MINFLOAT'
             *  Switch: '<S1069>/Switch1'
             *  Switch: '<S1069>/Switch2'
             */
            rtb_Switch1_oim = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1069>/Switch1' incorporates:
             *  Constant: '<S1069>/Constant Value4'
             *  Switch: '<S1069>/Switch2'
             *  Switch: '<S1069>/Switch3'
             */
            rtb_Switch1_oim = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1030>/Protected Division' */

        /* Sum: '<S1030>/Summation2' incorporates:
         *  Constant: '<S1030>/Constant Value'
         *  Gain: '<S1030>/Gain'
         *  Lookup_n-D: '<S1066>/Vector'
         *  Lookup_n-D: '<S1068>/Vector'
         *  MinMax: '<S1030>/MinMax'
         *  Product: '<S1030>/Product1'
         *  Switch: '<S1069>/Switch1'
         */
        VeESSR_M_InitSpinEngFricEngStrtTorq = (fmaxf(-VeESSR_M_EngTrqAct_Lmtd,
            0.0F) * look1_iflf_binlcapw(rtb_Switch1_oim, ((const float32 *)
            &(KxESSR_K_InitSpinEngStrtTorqGain[0])), ((const float32 *)
            &(KtESSR_K_InitSpinEngStrtTorqGain[0])), 4U)) + look1_iflf_binlcapw
            (rtb_Switch1_oim, ((const float32 *)
                               &(KxESSR_M_InitSpinEngStrtTorqOffset[0])), ((
               const float32 *)&(KtESSR_M_InitSpinEngStrtTorqOffset[0])), 4U);

        /* Abs: '<S1030>/Abs' */
        VeESSR_M_InitSpinEngPulseEngStrtTorq = fabsf
            (ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E);

        /* Lookup_n-D: '<S1067>/Vector' incorporates:
         *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
         */
        VeESSR_M_InitSpinECTEngStrtTorq = look1_iflf_binlcapw
            (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const float32 *)
              &(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((const float32 *)
              &(KtESSR_M_ECTAddtlEngStrtTorq[0])), 6U);

        /* Sum: '<S1030>/Summation1' */
        VeESSR_M_InitSpinEngStrtTorqRaw = (VeESSR_M_InitSpinEngFricEngStrtTorq +
            VeESSR_M_InitSpinEngPulseEngStrtTorq) +
            VeESSR_M_InitSpinECTEngStrtTorq;

        /* Outputs for Atomic SubSystem: '<S1030>/GradientLimiter' */
        /* Product: '<S1032>/Product' incorporates:
         *  UnitDelay: '<S1062>/Unit Delay'
         */
        rtb_Product_in = ESSR_ac_DW.UnitDelay_DSTATE_h;

        /* Sum: '<S1062>/Sum2' */
        rtb_Switch1_oim = VeESSR_M_InitSpinEngStrtTorqRaw - rtb_Product_in;

        /* Outputs for Atomic SubSystem: '<S1062>/Limiter' */
        /* Switch: '<S1070>/Switch1' incorporates:
         *  Constant: '<S1065>/Calib'
         *  RelationalOperator: '<S1070>/Relational Operator'
         */
        if (KeESSR_dM_InitSpinEngStrtTorqLU < rtb_Switch1_oim)
        {
            /* Switch: '<S1070>/Switch1' */
            rtb_Switch1_oim = KeESSR_dM_InitSpinEngStrtTorqLU;
        }

        /* Switch: '<S1070>/Switch' incorporates:
         *  Constant: '<S1064>/Calib'
         *  RelationalOperator: '<S1070>/Relational Operator1'
         */
        if (rtb_Switch1_oim <= KeESSR_dM_InitSpinEngStrtTorqLD)
        {
            rtb_Switch1_oim = KeESSR_dM_InitSpinEngStrtTorqLD;
        }

        /* End of Outputs for SubSystem: '<S1062>/Limiter' */

        /* Sum: '<S1062>/Sum3' */
        VeESSR_M_InitSpinEngStrtTorqLmtd = rtb_Switch1_oim + rtb_Product_in;

        /* Update for UnitDelay: '<S1062>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_h = VeESSR_M_InitSpinEngStrtTorqLmtd;

        /* End of Outputs for SubSystem: '<S1030>/GradientLimiter' */

        /* Switch: '<S1022>/Switch7' incorporates:
         *  Constant: '<S1040>/Calib'
         *  DataStoreWrite: '<S1022>/Data Store Write3'
         */
        if (!HeESSR_b_EngStrtTorq)
        {
            VeESSR_M_EngStrtTorq_DS = VeESSR_M_InitSpinEngStrtTorqLmtd;
        }

        /* Logic: '<S1022>/Logical2' incorporates:
         *  Constant: '<S1036>/Constant'
         *  Constant: '<S1037>/Constant'
         *  Constant: '<S1038>/Calib'
         *  Constant: '<S1039>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
         *  Logic: '<S1022>/Logical1'
         *  Logic: '<S1022>/Logical3'
         *  Logic: '<S1022>/Logical6'
         *  RelationalOperator: '<S1022>/Comparison1'
         *  RelationalOperator: '<S1022>/Comparison4'
         */
        rtb_Logical2_eb = ((((uint32)VeESSR_e_EngStrtProfType_DS) ==
                            CeESSR_e_KeyCrnkAlgo) || (((uint32)
                             VeESSR_e_EngStrtProfType_DS) == CeESSR_e_LowPwrAlgo));
        rtb_Logical2_eb = (((HeESSR_b_12vStrtrEquipped) ||
                            ((HeESSR_b_BumpStrtEquipped) && rtb_Logical2_eb)) &&
                           rtb_Logical2_eb);

        /* MinMax: '<S1032>/MinMax' incorporates:
         *  DataStoreRead: '<S1032>/Dsr_StrtTypInitSpinEndPnt'
         *  SignalConversion generated from: '<S1075>/Vector'
         */
        rtb_MinMax_if[0] = VeESSR_Cnt_InitSpnStepPt;
        rtb_MinMax_if[1] = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;

        /* Sum: '<S1032>/Sum' */
        rtb_Switch1_oim = VeESSR_M_EngTrqAct_Lmtd - VeESSR_M_SpnUpAddtlTorq;
        for (iU = 0; iU < 2; iU++)
        {
            rtb_MinMax_if[iU] = fmaxf(VeESSR_M_TiEstMin, look1_iflf_binlcapw
                (rtb_MinMax_if[iU], ((const float32 *)&(KxESSR_K_InitSpinTiProf
                [0])), ((const float32 *)&(KtESSR_K_InitSpinTiProf[0])), 6U) *
                rtb_Switch1_oim);
        }

        /* Switch: '<S1022>/Switch2' incorporates:
         *  Constant: '<S1022>/Constant Value1'
         *  DataStoreWrite: '<S1022>/Dsw_InputTorqEst'
         *  Lookup_n-D: '<S1075>/Vector'
         *  MinMax: '<S1032>/MinMax'
         *  Product: '<S1032>/Product1'
         */
        if (rtb_Logical2_eb)
        {
            VeESSR_M_EngTorqEst_DS = 0.0F;
        }
        else
        {
            VeESSR_M_EngTorqEst_DS = rtb_MinMax_if[0];
        }

        /* DataStoreWrite: '<S1022>/Dsw_STMTmr' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr'
         *  Sum: '<S1022>/Summation'
         */
        VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

        /* Switch: '<S1044>/Switch1' incorporates:
         *  Constant: '<S1049>/Calib'
         */
        if (KeESSR_b_InitSpnTmrChkOnly)
        {
            /* Switch: '<S1044>/Switch1' */
            rtb_Switch1_au = VeESSR_b_InitSpnTmrCmplt;
        }

        /* SignalConversion generated from: '<S1022>/Variant Source' incorporates:
         *  Logic: '<S1054>/Logical1'
         *  Logic: '<S1054>/Logical2'
         *  Logic: '<S1054>/Logical3'
         *  Logic: '<S1054>/Logical4'
         *  RelationalOperator: '<S1054>/Comparison1'
         *  RelationalOperator: '<S1054>/Comparison6'
         *  RelationalOperator: '<S1054>/Comparison7'
         *  RelationalOperator: '<S1054>/Comparison8'
         */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

        /* Switch: '<S1022>/Switch5' incorporates:
         *  Constant: '<S1022>/FALSE Constant1'
         */
        rtb_Switch5_hb = false;

#else

        /* Logic: '<S1054>/Logical4' incorporates:
         *  Constant: '<S1085>/Constant'
         *  Constant: '<S1086>/Constant'
         *  Constant: '<S1087>/Constant'
         *  Constant: '<S1088>/Constant'
         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
         *  Logic: '<S1054>/Logical1'
         *  Logic: '<S1054>/Logical2'
         *  Logic: '<S1054>/Logical3'
         *  RelationalOperator: '<S1022>/Comparison4'
         *  RelationalOperator: '<S1054>/Comparison1'
         *  RelationalOperator: '<S1054>/Comparison6'
         *  RelationalOperator: '<S1054>/Comparison7'
         *  RelationalOperator: '<S1054>/Comparison8'
         */
        VeESSR_b_InitSpin_48VP2CoastDown = (((((((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMStrtAlgo) || (((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_ImplStrtAlgo)) || (((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo)) &&
            (VeESSR_b_EMErlyExitLmp)) || ((((uint32)VeESSR_e_EngStrtProfType_DS)
            == CeESSR_e_CltchStrtAlgo) && (VeESSR_b_ClthErlyExitLmp)));

        /* Switch: '<S1022>/Switch5' */
        rtb_Switch5_hb = VeESSR_b_InitSpin_48VP2CoastDown;

#endif

        /* Switch: '<S1022>/Switch5' */
        if (!VeESSR_b_StrtTypChngDisbl)
        {
            /* Switch: '<S1022>/Switch5' incorporates:
             *  Constant: '<S1035>/Constant'
             *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
             *  Logic: '<S1022>/Logical Operator4'
             *  Logic: '<S1022>/Logical Operator5'
             *  RelationalOperator: '<S1022>/Comparison2'
             *  RelationalOperator: '<S1022>/Comparison4'
             */
            rtb_Switch5_hb = (((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B) ||
                               ((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d) &&
                                (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                 CeESSR_e_KeyCrnkAlgo))) ||
                              (VeESSR_b_ErlyExitLmp));
        }

        /* Logic: '<S1022>/Logical Operator3' incorporates:
         *  Constant: '<S1041>/Calib'
         *  Constant: '<S1045>/Calib'
         *  Constant: '<S1046>/Calib'
         *  Constant: '<S1047>/Calib'
         *  Constant: '<S1048>/Calib'
         *  DataStoreRead: '<S1022>/Data Store Read18'
         *  DataStoreRead: '<S1022>/Data Store Read19'
         *  Logic: '<S1022>/Logical Operator2'
         *  Logic: '<S1022>/Logical5'
         *  Logic: '<S1022>/Logical8'
         *  Logic: '<S1022>/Logical9'
         *  RelationalOperator: '<S1022>/Greater  Than11'
         *  RelationalOperator: '<S1022>/Greater  Than15'
         */
        VeESSR_b_InitSpin_CoastDownTrig = ((rtb_Switch5_hb ||
            rtb_LogicalOperator_h) && ((((KeESSR_b_EnblFtrBackupStrt) &&
            (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
             KeESSR_Cnt_BackupStrtMaxAttmpts)) || ((KeESSR_b_EnblFtrBumpStrt) &&
            (VeESSR_Cnt_BumpStrtAttmptCntr_DS < KeESSR_Cnt_BumpStrtMaxAttmpts)))
            || (HeESSR_b_LimphomeEnbl)));

        /* If: '<S1022>/If1' */
        if (rtb_Switch1_au)
        {
            /* Outputs for IfAction SubSystem: '<S1022>/NormExit' incorporates:
             *  ActionPort: '<S1052>/Action Port'
             */
            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S1082>/Constant'
             *  Merge: '<S1022>/Merge1'
             *  SignalConversion generated from: '<S1052>/ESSTrig'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_EngBrkawayAch;

            /* End of Outputs for SubSystem: '<S1022>/NormExit' */
        }
        else if (VeESSR_b_InitSpin_CoastDownTrig)
        {
            /* Outputs for IfAction SubSystem: '<S1022>/If Action Subsystem' incorporates:
             *  ActionPort: '<S1043>/Action Port'
             */
            /* Switch: '<S1043>/Switch' incorporates:
             *  Constant: '<S1080>/Constant'
             *  Constant: '<S1081>/Constant'
             *  DataStoreRead: '<S1043>/Data Store Read5'
             *  DataStoreWrite: '<S1043>/Dsw_StrtStpFailDTC'
             */
            if (VeESSR_b_BSGStrtFailed_DS)
            {
                VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;
            }
            else
            {
                VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
            }

            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S1079>/Constant'
             *  Merge: '<S1022>/Merge1'
             *  SignalConversion generated from: '<S1043>/ESSTrig'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

            /* End of Outputs for SubSystem: '<S1022>/If Action Subsystem' */
        }
        else
        {
            if (rtb_GreaterThan1_f)
            {
                /* Outputs for IfAction SubSystem: '<S1022>/OffFail' incorporates:
                 *  ActionPort: '<S1053>/Action Port'
                 */
                /* DataStoreWrite: '<S1053>/Dsw_StrtStpFailDTC' incorporates:
                 *  Constant: '<S1084>/Constant'
                 */
                VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;

                /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                 *  Constant: '<S1083>/Constant'
                 *  Merge: '<S1022>/Merge1'
                 *  SignalConversion generated from: '<S1053>/ESSTrig'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

                /* End of Outputs for SubSystem: '<S1022>/OffFail' */
            }
        }

        /* Switch: '<S1022>/Switch4' incorporates:
         *  Constant: '<S1022>/Constant Value2'
         *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType2'
         *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType6'
         *  DataStoreWrite: '<S1022>/Dsw_StrtStpFailDTC1'
         *  Logic: '<S1022>/Logical21'
         *  Logic: '<S1022>/Logical7'
         *  RelationalOperator: '<S1022>/Comparison'
         *  S-Function (sfix_bitop): '<S1022>/Bitwise Operator'
         *  S-Function (sfix_bitop): '<S1028>/FixPt Bitwise Operator1'
         */
        if (((VeESSR_b_InitSpin_CoastDownTrig) || rtb_GreaterThan1_f) &&
                ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16U) > 0U))
        {
            VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 16U;
        }

        /* Switch: '<S1071>/Switch1' incorporates:
         *  Constant: '<S1072>/Calib'
         *  DataStoreWrite: '<S1031>/Dsw_InitEngAng720'
         *  RelationalOperator: '<S1031>/Equal1'
         */
        if (VeESSR_Cnt_InitSpnStepPt <= KeESSR_t_InitSpnInitAngTm)
        {
            VeESSR_phi_InitEngAng720_DS =
                ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi;
        }

        /* Sum: '<S1032>/Subtract' incorporates:
         *  Constant: '<S1074>/Calib'
         *  DataStoreRead: '<S1032>/Dsr_NiProfGenNiDMax'
         *  DataStoreWrite: '<S1032>/Data Store Write'
         *  Product: '<S1032>/Product'
         */
        ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = rtb_MinMax_if[1] -
            (VeESSR_dn_StrtTypNiDotMax_DS * KeESSR_r_NiDtoTiMargin);

        /* DataStoreWrite: '<S1022>/Dsw_InputAcceltnProf1' */
        VeESSR_dn_InputAcceltnProf_DS =
            ESSR_ac_B.VariantMerge_For_Variant_Source;

        /* RelationalOperator: '<S1022>/Equal1' incorporates:
         *  Constant: '<S1022>/Constant Value'
         *  DataStoreRead: '<S1022>/Data Store Read5'
         *  DataStoreWrite: '<S1022>/Data Store Write5'
         */
        VeESSR_b_BSGStrtFailed_DS = (VeESSR_g_BSGStrtFailRsn_DS != 0U);

        /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqImmed' incorporates:
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitImmedTorq'
         */
        VeESSR_M_EngTrqReqImmed_DS = VeESSR_M_StrtTypInitImmedTorq_DS;

        /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqPrdtd1' incorporates:
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitPredTorq'
         */
        VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

        /* Switch: '<S1078>/Switch3' */
        if (rtb_Equal2)
        {
            /* Update for UnitDelay: '<S1078>/Unit Delay' incorporates:
             *  Constant: '<S1033>/Constant Value5'
             */
            ESSR_ac_DW.UnitDelay_DSTATE_iu = 0.0F;
        }
        else
        {
            /* Update for UnitDelay: '<S1078>/Unit Delay' */
            ESSR_ac_DW.UnitDelay_DSTATE_iu = rtb_Sum_k0;
        }

        /* End of Outputs for SubSystem: '<S559>/InitEngSpinDur' */
    }
    else if (rtb_Switch1_au && ((((uint32)(*Dsr_EngStrtType)) ==
               CeESSR_e_CltchStrtAlgo) || (((uint32)(*Dsr_EngStrtType)) ==
               CeESSR_e_ImplStrtAlgo)))
    {
        /* Transition: '<S165>:187' */
        ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_InitEngSpin_5;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'InitEngSpin_5': '<S165>:182' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

        /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinEnt' */
        /* Event: '<S165>:80' */
        ESSR_ac_InitEngSpinEnt(ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                               ESSR_ac_B.TmpSignalConversionAtVeESMR_P_d,
                               rtb_Sum_k0,
                               ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d);

        /* End of Outputs for SubSystem: '<S559>/InitEngSpinEnt' */

        /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinDur' */
        /* RelationalOperator: '<S1022>/Equal2' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr'
         */
        /* Event: '<S165>:81' */
        rtb_Equal2 = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

        /* Switch: '<S1078>/Switch1' incorporates:
         *  Constant: '<S1033>/Constant Value5'
         *  UnitDelay: '<S1078>/Unit Delay'
         */
        if (rtb_Equal2)
        {
            rtb_Sum_k0 = 0.0F;
        }
        else
        {
            rtb_Sum_k0 = ESSR_ac_DW.UnitDelay_DSTATE_iu;
        }

        /* Sum: '<S1033>/Sum' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitSpinScaler'
         *  Product: '<S1022>/Product'
         */
        rtb_Sum_k0 += HeESSR_t_MedTEB_dT * VeESSR_k_StrtTypInitSpinScaler_DS;

        /* Outputs for Atomic SubSystem: '<S1033>/Limiter' */
        /* Switch: '<S1077>/Switch1' incorporates:
         *  DataStoreRead: '<S1033>/Dsr_StrtTypInitSpinEndPnt'
         *  RelationalOperator: '<S1077>/Relational Operator'
         */
        if (VeESSR_Cnt_StrtTypInitSpinEndPnt_DS < rtb_Sum_k0)
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;
        }
        else
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = rtb_Sum_k0;
        }

        /* Switch: '<S1077>/Switch' incorporates:
         *  Constant: '<S1033>/Constant Value1'
         *  RelationalOperator: '<S1077>/Relational Operator1'
         */
        if (rtb_Product_in > 0.0F)
        {
            /* Switch: '<S1077>/Switch' */
            VeESSR_Cnt_InitSpnStepPt = rtb_Product_in;
        }
        else
        {
            /* Switch: '<S1077>/Switch' */
            VeESSR_Cnt_InitSpnStepPt = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1033>/Limiter' */

        /* RelationalOperator: '<S1034>/Greater  Than2' incorporates:
         *  DataStoreRead: '<S1034>/Dsr_StrtTypInitSpinEndPnt'
         */
        VeESSR_b_InitSpnTmrCmplt = (VeESSR_Cnt_InitSpnStepPt >=
            VeESSR_Cnt_StrtTypInitSpinEndPnt_DS);

        /* Outputs for Atomic SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */
        /* Switch: '<S1058>/Switch' */
        if (rtb_Equal2)
        {
            /* Switch: '<S1058>/Switch' incorporates:
             *  Constant: '<S1029>/Constant Value4'
             */
            rtb_Switch1_oim = 0.0F;
        }
        else
        {
            /* Switch: '<S1058>/Switch' incorporates:
             *  Constant: '<S1029>/Cnvrt2Deg'
             *  Constant: '<S1057>/Calib'
             *  Product: '<S1058>/Division'
             *  Product: '<S1058>/Multiplication'
             *  Sum: '<S1058>/Sum//Sub'
             *  UnitDelay: '<S1058>/Unit Delay'
             */
            rtb_Switch1_oim = ((HeESSR_t_MedTEB_dT / 0.166666672F) *
                               ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I) +
                ESSR_ac_DW.UnitDelay_DSTATE_e;
        }

        /* Outputs for Atomic SubSystem: '<S1058>/Limiter' */
        /* Switch: '<S1061>/Switch1' incorporates:
         *  Constant: '<S1029>/Constant Value1'
         *  RelationalOperator: '<S1061>/Relational Operator'
         */
        if (999.0F < rtb_Switch1_oim)
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = 999.0F;
        }
        else
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = rtb_Switch1_oim;
        }

        /* Switch: '<S1061>/Switch' incorporates:
         *  Constant: '<S1029>/Constant Value'
         *  RelationalOperator: '<S1061>/Relational Operator1'
         */
        if (rtb_Product_in <= 0.0F)
        {
            /* Switch: '<S1061>/Switch' */
            rtb_Product_in = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1058>/Limiter' */

        /* Update for UnitDelay: '<S1058>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_e = rtb_Product_in;

        /* End of Outputs for SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */

        /* Switch: '<S1070>/Switch1' incorporates:
         *  Constant: '<S1029>/Constant Value3'
         *  DataStoreRead: '<S1029>/Dsr_STMTmr3'
         *  Product: '<S1060>/Division'
         *  Sum: '<S1029>/Subtraction'
         */
        rtb_Switch1_oim = (ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi -
                           VeESSR_phi_InitEngAng720_DS) / 720.0F;

        /* Logic: '<S1029>/AND' incorporates:
         *  Constant: '<S1029>/Constant Value3'
         *  DataStoreRead: '<S1029>/Dsr_STMTmr1'
         *  Product: '<S1060>/Multiplication'
         *  RelationalOperator: '<S1029>/Greater  Than1'
         *  RelationalOperator: '<S1029>/Greater  Than2'
         *  Rounding: '<S1060>/Floor'
         *  Sum: '<S1060>/Subtraction'
         */
        VeESSR_b_InitSpnEngMvmntDet = ((rtb_Product_in >
            VeESSR_phi_StrtTypInitSpinBrkAng_DS) || (((rtb_Switch1_oim - roundf
            (rtb_Switch1_oim)) * 720.0F) > VeESSR_phi_StrtTypInitSpinBrkAng_DS));

        /* Switch: '<S1044>/Switch1' incorporates:
         *  Logic: '<S1022>/Logical'
         */
        rtb_Switch1_au = ((VeESSR_b_InitSpnTmrCmplt) ||
                          (VeESSR_b_InitSpnEngMvmntDet));

        /* RelationalOperator: '<S1022>/Greater  Than1' incorporates:
         *  Constant: '<S1050>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr1'
         */
        rtb_GreaterThan1_f = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmInitSpin);

        /* Logic: '<S1022>/Logical Operator' incorporates:
         *  Logic: '<S1022>/Logical Operator1'
         */
        rtb_LogicalOperator_h = ((!rtb_Switch1_au) && rtb_GreaterThan1_f);

        /* Switch: '<S1022>/Switch3' incorporates:
         *  DataStoreRead: '<S1022>/Data Store Read'
         *  DataStoreRead: '<S1022>/Data Store Read1'
         *  DataStoreWrite: '<S1022>/Data Store Write'
         *  DataStoreWrite: '<S1022>/Data Store Write1'
         *  S-Function (sfix_bitop): '<S1026>/FixPt Bitwise Operator1'
         *  S-Function (sfix_bitop): '<S1027>/FixPt Bitwise Operator1'
         *  Switch: '<S1022>/Switch1'
         */
        if (rtb_LogicalOperator_h)
        {
            ESSR_ac_DW.NeESSR_g_StrtStpFailRsn |= 4U;
            VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS | 1U;
        }

        /* Outputs for Atomic SubSystem: '<S1030>/Protected Division' */
        /* Switch: '<S1069>/Switch1' incorporates:
         *  Constant: '<S1063>/Calib'
         *  Constant: '<S1069>/Constant Value'
         *  Constant: '<S1069>/Constant Value1'
         *  Constant: '<S1069>/Constant Value2'
         *  Constant: '<S1069>/Constant Value3'
         *  DataStoreRead: '<S1030>/Dsr_STMTmr2'
         *  Logic: '<S1069>/AND'
         *  RelationalOperator: '<S1069>/Greater Than or Equal '
         *  RelationalOperator: '<S1069>/Greater Than or Equal 1'
         *  RelationalOperator: '<S1069>/Not Equal'
         *  RelationalOperator: '<S1069>/Not Equal1'
         *  Switch: '<S1069>/Switch2'
         *  Switch: '<S1069>/Switch3'
         */
        if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT != 0.0F))
        {
            /* Switch: '<S1069>/Switch1' incorporates:
             *  Product: '<S1069>/Division'
             */
            rtb_Switch1_oim = VeESSR_t_STMTmr_DS / HeESSR_t_MedTEB_dT;
        }
        else if (VeESSR_t_STMTmr_DS > 0.0F)
        {
            /* Switch: '<S1069>/Switch2' incorporates:
             *  Constant: '<S1069>/MAXFLOAT'
             *  Switch: '<S1069>/Switch1'
             */
            rtb_Switch1_oim = 3.402823466E+38F;
        }
        else if (VeESSR_t_STMTmr_DS < 0.0F)
        {
            /* Switch: '<S1069>/Switch3' incorporates:
             *  Constant: '<S1069>/MINFLOAT'
             *  Switch: '<S1069>/Switch1'
             *  Switch: '<S1069>/Switch2'
             */
            rtb_Switch1_oim = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1069>/Switch1' incorporates:
             *  Constant: '<S1069>/Constant Value4'
             *  Switch: '<S1069>/Switch2'
             *  Switch: '<S1069>/Switch3'
             */
            rtb_Switch1_oim = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1030>/Protected Division' */

        /* Sum: '<S1030>/Summation2' incorporates:
         *  Constant: '<S1030>/Constant Value'
         *  Gain: '<S1030>/Gain'
         *  Lookup_n-D: '<S1066>/Vector'
         *  Lookup_n-D: '<S1068>/Vector'
         *  MinMax: '<S1030>/MinMax'
         *  Product: '<S1030>/Product1'
         *  Switch: '<S1069>/Switch1'
         */
        VeESSR_M_InitSpinEngFricEngStrtTorq = (fmaxf(-VeESSR_M_EngTrqAct_Lmtd,
            0.0F) * look1_iflf_binlcapw(rtb_Switch1_oim, ((const float32 *)
            &(KxESSR_K_InitSpinEngStrtTorqGain[0])), ((const float32 *)
            &(KtESSR_K_InitSpinEngStrtTorqGain[0])), 4U)) + look1_iflf_binlcapw
            (rtb_Switch1_oim, ((const float32 *)
                               &(KxESSR_M_InitSpinEngStrtTorqOffset[0])), ((
               const float32 *)&(KtESSR_M_InitSpinEngStrtTorqOffset[0])), 4U);

        /* Abs: '<S1030>/Abs' */
        VeESSR_M_InitSpinEngPulseEngStrtTorq = fabsf
            (ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E);

        /* Lookup_n-D: '<S1067>/Vector' incorporates:
         *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
         */
        VeESSR_M_InitSpinECTEngStrtTorq = look1_iflf_binlcapw
            (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const float32 *)
              &(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((const float32 *)
              &(KtESSR_M_ECTAddtlEngStrtTorq[0])), 6U);

        /* Sum: '<S1030>/Summation1' */
        VeESSR_M_InitSpinEngStrtTorqRaw = (VeESSR_M_InitSpinEngFricEngStrtTorq +
            VeESSR_M_InitSpinEngPulseEngStrtTorq) +
            VeESSR_M_InitSpinECTEngStrtTorq;

        /* Outputs for Atomic SubSystem: '<S1030>/GradientLimiter' */
        /* Product: '<S1032>/Product' incorporates:
         *  UnitDelay: '<S1062>/Unit Delay'
         */
        rtb_Product_in = ESSR_ac_DW.UnitDelay_DSTATE_h;

        /* Sum: '<S1062>/Sum2' */
        rtb_Switch1_oim = VeESSR_M_InitSpinEngStrtTorqRaw - rtb_Product_in;

        /* Outputs for Atomic SubSystem: '<S1062>/Limiter' */
        /* Switch: '<S1070>/Switch1' incorporates:
         *  Constant: '<S1065>/Calib'
         *  RelationalOperator: '<S1070>/Relational Operator'
         */
        if (KeESSR_dM_InitSpinEngStrtTorqLU < rtb_Switch1_oim)
        {
            /* Switch: '<S1070>/Switch1' */
            rtb_Switch1_oim = KeESSR_dM_InitSpinEngStrtTorqLU;
        }

        /* Switch: '<S1070>/Switch' incorporates:
         *  Constant: '<S1064>/Calib'
         *  RelationalOperator: '<S1070>/Relational Operator1'
         */
        if (rtb_Switch1_oim <= KeESSR_dM_InitSpinEngStrtTorqLD)
        {
            rtb_Switch1_oim = KeESSR_dM_InitSpinEngStrtTorqLD;
        }

        /* End of Outputs for SubSystem: '<S1062>/Limiter' */

        /* Sum: '<S1062>/Sum3' */
        VeESSR_M_InitSpinEngStrtTorqLmtd = rtb_Switch1_oim + rtb_Product_in;

        /* Update for UnitDelay: '<S1062>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_h = VeESSR_M_InitSpinEngStrtTorqLmtd;

        /* End of Outputs for SubSystem: '<S1030>/GradientLimiter' */

        /* Switch: '<S1022>/Switch7' incorporates:
         *  Constant: '<S1040>/Calib'
         *  DataStoreWrite: '<S1022>/Data Store Write3'
         */
        if (!HeESSR_b_EngStrtTorq)
        {
            VeESSR_M_EngStrtTorq_DS = VeESSR_M_InitSpinEngStrtTorqLmtd;
        }

        /* Logic: '<S1022>/Logical2' incorporates:
         *  Constant: '<S1036>/Constant'
         *  Constant: '<S1037>/Constant'
         *  Constant: '<S1038>/Calib'
         *  Constant: '<S1039>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
         *  Logic: '<S1022>/Logical1'
         *  Logic: '<S1022>/Logical3'
         *  Logic: '<S1022>/Logical6'
         *  RelationalOperator: '<S1022>/Comparison1'
         *  RelationalOperator: '<S1022>/Comparison4'
         */
        rtb_Logical2_eb = ((((uint32)VeESSR_e_EngStrtProfType_DS) ==
                            CeESSR_e_KeyCrnkAlgo) || (((uint32)
                             VeESSR_e_EngStrtProfType_DS) == CeESSR_e_LowPwrAlgo));
        rtb_Logical2_eb = (((HeESSR_b_12vStrtrEquipped) ||
                            ((HeESSR_b_BumpStrtEquipped) && rtb_Logical2_eb)) &&
                           rtb_Logical2_eb);

        /* MinMax: '<S1032>/MinMax' incorporates:
         *  DataStoreRead: '<S1032>/Dsr_StrtTypInitSpinEndPnt'
         *  SignalConversion generated from: '<S1075>/Vector'
         */
        rtb_MinMax_if[0] = VeESSR_Cnt_InitSpnStepPt;
        rtb_MinMax_if[1] = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;

        /* Sum: '<S1032>/Sum' */
        rtb_Switch1_oim = VeESSR_M_EngTrqAct_Lmtd - VeESSR_M_SpnUpAddtlTorq;
        for (iU = 0; iU < 2; iU++)
        {
            rtb_MinMax_if[iU] = fmaxf(VeESSR_M_TiEstMin, look1_iflf_binlcapw
                (rtb_MinMax_if[iU], ((const float32 *)&(KxESSR_K_InitSpinTiProf
                [0])), ((const float32 *)&(KtESSR_K_InitSpinTiProf[0])), 6U) *
                rtb_Switch1_oim);
        }

        /* Switch: '<S1022>/Switch2' incorporates:
         *  Constant: '<S1022>/Constant Value1'
         *  DataStoreWrite: '<S1022>/Dsw_InputTorqEst'
         *  Lookup_n-D: '<S1075>/Vector'
         *  MinMax: '<S1032>/MinMax'
         *  Product: '<S1032>/Product1'
         */
        if (rtb_Logical2_eb)
        {
            VeESSR_M_EngTorqEst_DS = 0.0F;
        }
        else
        {
            VeESSR_M_EngTorqEst_DS = rtb_MinMax_if[0];
        }

        /* DataStoreWrite: '<S1022>/Dsw_STMTmr' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr'
         *  Sum: '<S1022>/Summation'
         */
        VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

        /* Switch: '<S1044>/Switch1' incorporates:
         *  Constant: '<S1049>/Calib'
         */
        if (KeESSR_b_InitSpnTmrChkOnly)
        {
            /* Switch: '<S1044>/Switch1' */
            rtb_Switch1_au = VeESSR_b_InitSpnTmrCmplt;
        }

        /* SignalConversion generated from: '<S1022>/Variant Source' incorporates:
         *  Logic: '<S1054>/Logical1'
         *  Logic: '<S1054>/Logical2'
         *  Logic: '<S1054>/Logical3'
         *  Logic: '<S1054>/Logical4'
         *  RelationalOperator: '<S1054>/Comparison1'
         *  RelationalOperator: '<S1054>/Comparison6'
         *  RelationalOperator: '<S1054>/Comparison7'
         *  RelationalOperator: '<S1054>/Comparison8'
         */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

        /* Switch: '<S1022>/Switch5' incorporates:
         *  Constant: '<S1022>/FALSE Constant1'
         */
        rtb_Switch5_hb = false;

#else

        /* Logic: '<S1054>/Logical4' incorporates:
         *  Constant: '<S1085>/Constant'
         *  Constant: '<S1086>/Constant'
         *  Constant: '<S1087>/Constant'
         *  Constant: '<S1088>/Constant'
         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
         *  Logic: '<S1054>/Logical1'
         *  Logic: '<S1054>/Logical2'
         *  Logic: '<S1054>/Logical3'
         *  RelationalOperator: '<S1022>/Comparison4'
         *  RelationalOperator: '<S1054>/Comparison1'
         *  RelationalOperator: '<S1054>/Comparison6'
         *  RelationalOperator: '<S1054>/Comparison7'
         *  RelationalOperator: '<S1054>/Comparison8'
         */
        VeESSR_b_InitSpin_48VP2CoastDown = (((((((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMStrtAlgo) || (((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_ImplStrtAlgo)) || (((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo)) &&
            (VeESSR_b_EMErlyExitLmp)) || ((((uint32)VeESSR_e_EngStrtProfType_DS)
            == CeESSR_e_CltchStrtAlgo) && (VeESSR_b_ClthErlyExitLmp)));

        /* Switch: '<S1022>/Switch5' */
        rtb_Switch5_hb = VeESSR_b_InitSpin_48VP2CoastDown;

#endif

        /* Switch: '<S1022>/Switch5' */
        if (!VeESSR_b_StrtTypChngDisbl)
        {
            /* Switch: '<S1022>/Switch5' incorporates:
             *  Constant: '<S1035>/Constant'
             *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
             *  Logic: '<S1022>/Logical Operator4'
             *  Logic: '<S1022>/Logical Operator5'
             *  RelationalOperator: '<S1022>/Comparison2'
             *  RelationalOperator: '<S1022>/Comparison4'
             */
            rtb_Switch5_hb = (((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B) ||
                               ((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d) &&
                                (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                 CeESSR_e_KeyCrnkAlgo))) ||
                              (VeESSR_b_ErlyExitLmp));
        }

        /* Logic: '<S1022>/Logical Operator3' incorporates:
         *  Constant: '<S1041>/Calib'
         *  Constant: '<S1045>/Calib'
         *  Constant: '<S1046>/Calib'
         *  Constant: '<S1047>/Calib'
         *  Constant: '<S1048>/Calib'
         *  DataStoreRead: '<S1022>/Data Store Read18'
         *  DataStoreRead: '<S1022>/Data Store Read19'
         *  Logic: '<S1022>/Logical Operator2'
         *  Logic: '<S1022>/Logical5'
         *  Logic: '<S1022>/Logical8'
         *  Logic: '<S1022>/Logical9'
         *  RelationalOperator: '<S1022>/Greater  Than11'
         *  RelationalOperator: '<S1022>/Greater  Than15'
         */
        VeESSR_b_InitSpin_CoastDownTrig = ((rtb_Switch5_hb ||
            rtb_LogicalOperator_h) && ((((KeESSR_b_EnblFtrBackupStrt) &&
            (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
             KeESSR_Cnt_BackupStrtMaxAttmpts)) || ((KeESSR_b_EnblFtrBumpStrt) &&
            (VeESSR_Cnt_BumpStrtAttmptCntr_DS < KeESSR_Cnt_BumpStrtMaxAttmpts)))
            || (HeESSR_b_LimphomeEnbl)));

        /* If: '<S1022>/If1' */
        if (rtb_Switch1_au)
        {
            /* Outputs for IfAction SubSystem: '<S1022>/NormExit' incorporates:
             *  ActionPort: '<S1052>/Action Port'
             */
            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S1082>/Constant'
             *  Merge: '<S1022>/Merge1'
             *  SignalConversion generated from: '<S1052>/ESSTrig'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_EngBrkawayAch;

            /* End of Outputs for SubSystem: '<S1022>/NormExit' */
        }
        else if (VeESSR_b_InitSpin_CoastDownTrig)
        {
            /* Outputs for IfAction SubSystem: '<S1022>/If Action Subsystem' incorporates:
             *  ActionPort: '<S1043>/Action Port'
             */
            /* Switch: '<S1043>/Switch' incorporates:
             *  Constant: '<S1080>/Constant'
             *  Constant: '<S1081>/Constant'
             *  DataStoreRead: '<S1043>/Data Store Read5'
             *  DataStoreWrite: '<S1043>/Dsw_StrtStpFailDTC'
             */
            if (VeESSR_b_BSGStrtFailed_DS)
            {
                VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;
            }
            else
            {
                VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
            }

            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S1079>/Constant'
             *  Merge: '<S1022>/Merge1'
             *  SignalConversion generated from: '<S1043>/ESSTrig'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

            /* End of Outputs for SubSystem: '<S1022>/If Action Subsystem' */
        }
        else
        {
            if (rtb_GreaterThan1_f)
            {
                /* Outputs for IfAction SubSystem: '<S1022>/OffFail' incorporates:
                 *  ActionPort: '<S1053>/Action Port'
                 */
                /* DataStoreWrite: '<S1053>/Dsw_StrtStpFailDTC' incorporates:
                 *  Constant: '<S1084>/Constant'
                 */
                VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;

                /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                 *  Constant: '<S1083>/Constant'
                 *  Merge: '<S1022>/Merge1'
                 *  SignalConversion generated from: '<S1053>/ESSTrig'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

                /* End of Outputs for SubSystem: '<S1022>/OffFail' */
            }
        }

        /* Switch: '<S1022>/Switch4' incorporates:
         *  Constant: '<S1022>/Constant Value2'
         *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType2'
         *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType6'
         *  DataStoreWrite: '<S1022>/Dsw_StrtStpFailDTC1'
         *  Logic: '<S1022>/Logical21'
         *  Logic: '<S1022>/Logical7'
         *  RelationalOperator: '<S1022>/Comparison'
         *  S-Function (sfix_bitop): '<S1022>/Bitwise Operator'
         *  S-Function (sfix_bitop): '<S1028>/FixPt Bitwise Operator1'
         */
        if (((VeESSR_b_InitSpin_CoastDownTrig) || rtb_GreaterThan1_f) &&
                ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16U) > 0U))
        {
            VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 16U;
        }

        /* Switch: '<S1071>/Switch1' incorporates:
         *  Constant: '<S1072>/Calib'
         *  DataStoreWrite: '<S1031>/Dsw_InitEngAng720'
         *  RelationalOperator: '<S1031>/Equal1'
         */
        if (VeESSR_Cnt_InitSpnStepPt <= KeESSR_t_InitSpnInitAngTm)
        {
            VeESSR_phi_InitEngAng720_DS =
                ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi;
        }

        /* Sum: '<S1032>/Subtract' incorporates:
         *  Constant: '<S1074>/Calib'
         *  DataStoreRead: '<S1032>/Dsr_NiProfGenNiDMax'
         *  DataStoreWrite: '<S1032>/Data Store Write'
         *  Product: '<S1032>/Product'
         */
        ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = rtb_MinMax_if[1] -
            (VeESSR_dn_StrtTypNiDotMax_DS * KeESSR_r_NiDtoTiMargin);

        /* DataStoreWrite: '<S1022>/Dsw_InputAcceltnProf1' */
        VeESSR_dn_InputAcceltnProf_DS =
            ESSR_ac_B.VariantMerge_For_Variant_Source;

        /* RelationalOperator: '<S1022>/Equal1' incorporates:
         *  Constant: '<S1022>/Constant Value'
         *  DataStoreRead: '<S1022>/Data Store Read5'
         *  DataStoreWrite: '<S1022>/Data Store Write5'
         */
        VeESSR_b_BSGStrtFailed_DS = (VeESSR_g_BSGStrtFailRsn_DS != 0U);

        /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqImmed' incorporates:
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitImmedTorq'
         */
        VeESSR_M_EngTrqReqImmed_DS = VeESSR_M_StrtTypInitImmedTorq_DS;

        /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqPrdtd1' incorporates:
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitPredTorq'
         */
        VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

        /* Switch: '<S1078>/Switch3' */
        if (rtb_Equal2)
        {
            /* Update for UnitDelay: '<S1078>/Unit Delay' incorporates:
             *  Constant: '<S1033>/Constant Value5'
             */
            ESSR_ac_DW.UnitDelay_DSTATE_iu = 0.0F;
        }
        else
        {
            /* Update for UnitDelay: '<S1078>/Unit Delay' */
            ESSR_ac_DW.UnitDelay_DSTATE_iu = rtb_Sum_k0;
        }

        /* End of Outputs for SubSystem: '<S559>/InitEngSpinDur' */
    }
    else if ((((HeESSR_b_BumpStrtEquipped) && rtb_Equal2) && (!(*BmpStrtFailed)))
             && ((((uint32)(*Dsr_EngStrtType)) == CeESSR_e_LowPwrAlgo) ||
                 (((uint32)(*Dsr_EngStrtType)) == CeESSR_e_KeyCrnkAlgo)))
    {
        /* Transition: '<S165>:156' */
        ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_InitEngSpin_4;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'InitEngSpin_4': '<S165>:145' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

        /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinEnt' */
        /* Event: '<S165>:80' */
        ESSR_ac_InitEngSpinEnt(ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                               ESSR_ac_B.TmpSignalConversionAtVeESMR_P_d,
                               rtb_Sum_k0,
                               ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d);

        /* End of Outputs for SubSystem: '<S559>/InitEngSpinEnt' */

        /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinDur' */
        /* RelationalOperator: '<S1022>/Equal2' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr'
         */
        /* Event: '<S165>:81' */
        rtb_Equal2 = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

        /* Switch: '<S1078>/Switch1' incorporates:
         *  Constant: '<S1033>/Constant Value5'
         *  UnitDelay: '<S1078>/Unit Delay'
         */
        if (rtb_Equal2)
        {
            rtb_Sum_k0 = 0.0F;
        }
        else
        {
            rtb_Sum_k0 = ESSR_ac_DW.UnitDelay_DSTATE_iu;
        }

        /* Sum: '<S1033>/Sum' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitSpinScaler'
         *  Product: '<S1022>/Product'
         */
        rtb_Sum_k0 += HeESSR_t_MedTEB_dT * VeESSR_k_StrtTypInitSpinScaler_DS;

        /* Outputs for Atomic SubSystem: '<S1033>/Limiter' */
        /* Switch: '<S1077>/Switch1' incorporates:
         *  DataStoreRead: '<S1033>/Dsr_StrtTypInitSpinEndPnt'
         *  RelationalOperator: '<S1077>/Relational Operator'
         */
        if (VeESSR_Cnt_StrtTypInitSpinEndPnt_DS < rtb_Sum_k0)
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;
        }
        else
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = rtb_Sum_k0;
        }

        /* Switch: '<S1077>/Switch' incorporates:
         *  Constant: '<S1033>/Constant Value1'
         *  RelationalOperator: '<S1077>/Relational Operator1'
         */
        if (rtb_Product_in > 0.0F)
        {
            /* Switch: '<S1077>/Switch' */
            VeESSR_Cnt_InitSpnStepPt = rtb_Product_in;
        }
        else
        {
            /* Switch: '<S1077>/Switch' */
            VeESSR_Cnt_InitSpnStepPt = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1033>/Limiter' */

        /* RelationalOperator: '<S1034>/Greater  Than2' incorporates:
         *  DataStoreRead: '<S1034>/Dsr_StrtTypInitSpinEndPnt'
         */
        VeESSR_b_InitSpnTmrCmplt = (VeESSR_Cnt_InitSpnStepPt >=
            VeESSR_Cnt_StrtTypInitSpinEndPnt_DS);

        /* Outputs for Atomic SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */
        /* Switch: '<S1058>/Switch' */
        if (rtb_Equal2)
        {
            /* Switch: '<S1058>/Switch' incorporates:
             *  Constant: '<S1029>/Constant Value4'
             */
            rtb_Switch1_oim = 0.0F;
        }
        else
        {
            /* Switch: '<S1058>/Switch' incorporates:
             *  Constant: '<S1029>/Cnvrt2Deg'
             *  Constant: '<S1057>/Calib'
             *  Product: '<S1058>/Division'
             *  Product: '<S1058>/Multiplication'
             *  Sum: '<S1058>/Sum//Sub'
             *  UnitDelay: '<S1058>/Unit Delay'
             */
            rtb_Switch1_oim = ((HeESSR_t_MedTEB_dT / 0.166666672F) *
                               ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I) +
                ESSR_ac_DW.UnitDelay_DSTATE_e;
        }

        /* Outputs for Atomic SubSystem: '<S1058>/Limiter' */
        /* Switch: '<S1061>/Switch1' incorporates:
         *  Constant: '<S1029>/Constant Value1'
         *  RelationalOperator: '<S1061>/Relational Operator'
         */
        if (999.0F < rtb_Switch1_oim)
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = 999.0F;
        }
        else
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = rtb_Switch1_oim;
        }

        /* Switch: '<S1061>/Switch' incorporates:
         *  Constant: '<S1029>/Constant Value'
         *  RelationalOperator: '<S1061>/Relational Operator1'
         */
        if (rtb_Product_in <= 0.0F)
        {
            /* Switch: '<S1061>/Switch' */
            rtb_Product_in = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1058>/Limiter' */

        /* Update for UnitDelay: '<S1058>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_e = rtb_Product_in;

        /* End of Outputs for SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */

        /* Switch: '<S1070>/Switch1' incorporates:
         *  Constant: '<S1029>/Constant Value3'
         *  DataStoreRead: '<S1029>/Dsr_STMTmr3'
         *  Product: '<S1060>/Division'
         *  Sum: '<S1029>/Subtraction'
         */
        rtb_Switch1_oim = (ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi -
                           VeESSR_phi_InitEngAng720_DS) / 720.0F;

        /* Logic: '<S1029>/AND' incorporates:
         *  Constant: '<S1029>/Constant Value3'
         *  DataStoreRead: '<S1029>/Dsr_STMTmr1'
         *  Product: '<S1060>/Multiplication'
         *  RelationalOperator: '<S1029>/Greater  Than1'
         *  RelationalOperator: '<S1029>/Greater  Than2'
         *  Rounding: '<S1060>/Floor'
         *  Sum: '<S1060>/Subtraction'
         */
        VeESSR_b_InitSpnEngMvmntDet = ((rtb_Product_in >
            VeESSR_phi_StrtTypInitSpinBrkAng_DS) || (((rtb_Switch1_oim - roundf
            (rtb_Switch1_oim)) * 720.0F) > VeESSR_phi_StrtTypInitSpinBrkAng_DS));

        /* Switch: '<S1044>/Switch1' incorporates:
         *  Logic: '<S1022>/Logical'
         */
        rtb_Switch1_au = ((VeESSR_b_InitSpnTmrCmplt) ||
                          (VeESSR_b_InitSpnEngMvmntDet));

        /* RelationalOperator: '<S1022>/Greater  Than1' incorporates:
         *  Constant: '<S1050>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr1'
         */
        rtb_GreaterThan1_f = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmInitSpin);

        /* Logic: '<S1022>/Logical Operator' incorporates:
         *  Logic: '<S1022>/Logical Operator1'
         */
        rtb_LogicalOperator_h = ((!rtb_Switch1_au) && rtb_GreaterThan1_f);

        /* Switch: '<S1022>/Switch3' incorporates:
         *  DataStoreRead: '<S1022>/Data Store Read'
         *  DataStoreRead: '<S1022>/Data Store Read1'
         *  DataStoreWrite: '<S1022>/Data Store Write'
         *  DataStoreWrite: '<S1022>/Data Store Write1'
         *  S-Function (sfix_bitop): '<S1026>/FixPt Bitwise Operator1'
         *  S-Function (sfix_bitop): '<S1027>/FixPt Bitwise Operator1'
         *  Switch: '<S1022>/Switch1'
         */
        if (rtb_LogicalOperator_h)
        {
            ESSR_ac_DW.NeESSR_g_StrtStpFailRsn |= 4U;
            VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS | 1U;
        }

        /* Outputs for Atomic SubSystem: '<S1030>/Protected Division' */
        /* Switch: '<S1069>/Switch1' incorporates:
         *  Constant: '<S1063>/Calib'
         *  Constant: '<S1069>/Constant Value'
         *  Constant: '<S1069>/Constant Value1'
         *  Constant: '<S1069>/Constant Value2'
         *  Constant: '<S1069>/Constant Value3'
         *  DataStoreRead: '<S1030>/Dsr_STMTmr2'
         *  Logic: '<S1069>/AND'
         *  RelationalOperator: '<S1069>/Greater Than or Equal '
         *  RelationalOperator: '<S1069>/Greater Than or Equal 1'
         *  RelationalOperator: '<S1069>/Not Equal'
         *  RelationalOperator: '<S1069>/Not Equal1'
         *  Switch: '<S1069>/Switch2'
         *  Switch: '<S1069>/Switch3'
         */
        if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT != 0.0F))
        {
            /* Switch: '<S1069>/Switch1' incorporates:
             *  Product: '<S1069>/Division'
             */
            rtb_Switch1_oim = VeESSR_t_STMTmr_DS / HeESSR_t_MedTEB_dT;
        }
        else if (VeESSR_t_STMTmr_DS > 0.0F)
        {
            /* Switch: '<S1069>/Switch2' incorporates:
             *  Constant: '<S1069>/MAXFLOAT'
             *  Switch: '<S1069>/Switch1'
             */
            rtb_Switch1_oim = 3.402823466E+38F;
        }
        else if (VeESSR_t_STMTmr_DS < 0.0F)
        {
            /* Switch: '<S1069>/Switch3' incorporates:
             *  Constant: '<S1069>/MINFLOAT'
             *  Switch: '<S1069>/Switch1'
             *  Switch: '<S1069>/Switch2'
             */
            rtb_Switch1_oim = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1069>/Switch1' incorporates:
             *  Constant: '<S1069>/Constant Value4'
             *  Switch: '<S1069>/Switch2'
             *  Switch: '<S1069>/Switch3'
             */
            rtb_Switch1_oim = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1030>/Protected Division' */

        /* Sum: '<S1030>/Summation2' incorporates:
         *  Constant: '<S1030>/Constant Value'
         *  Gain: '<S1030>/Gain'
         *  Lookup_n-D: '<S1066>/Vector'
         *  Lookup_n-D: '<S1068>/Vector'
         *  MinMax: '<S1030>/MinMax'
         *  Product: '<S1030>/Product1'
         *  Switch: '<S1069>/Switch1'
         */
        VeESSR_M_InitSpinEngFricEngStrtTorq = (fmaxf(-VeESSR_M_EngTrqAct_Lmtd,
            0.0F) * look1_iflf_binlcapw(rtb_Switch1_oim, ((const float32 *)
            &(KxESSR_K_InitSpinEngStrtTorqGain[0])), ((const float32 *)
            &(KtESSR_K_InitSpinEngStrtTorqGain[0])), 4U)) + look1_iflf_binlcapw
            (rtb_Switch1_oim, ((const float32 *)
                               &(KxESSR_M_InitSpinEngStrtTorqOffset[0])), ((
               const float32 *)&(KtESSR_M_InitSpinEngStrtTorqOffset[0])), 4U);

        /* Abs: '<S1030>/Abs' */
        VeESSR_M_InitSpinEngPulseEngStrtTorq = fabsf
            (ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E);

        /* Lookup_n-D: '<S1067>/Vector' incorporates:
         *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
         */
        VeESSR_M_InitSpinECTEngStrtTorq = look1_iflf_binlcapw
            (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const float32 *)
              &(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((const float32 *)
              &(KtESSR_M_ECTAddtlEngStrtTorq[0])), 6U);

        /* Sum: '<S1030>/Summation1' */
        VeESSR_M_InitSpinEngStrtTorqRaw = (VeESSR_M_InitSpinEngFricEngStrtTorq +
            VeESSR_M_InitSpinEngPulseEngStrtTorq) +
            VeESSR_M_InitSpinECTEngStrtTorq;

        /* Outputs for Atomic SubSystem: '<S1030>/GradientLimiter' */
        /* Product: '<S1032>/Product' incorporates:
         *  UnitDelay: '<S1062>/Unit Delay'
         */
        rtb_Product_in = ESSR_ac_DW.UnitDelay_DSTATE_h;

        /* Sum: '<S1062>/Sum2' */
        rtb_Switch1_oim = VeESSR_M_InitSpinEngStrtTorqRaw - rtb_Product_in;

        /* Outputs for Atomic SubSystem: '<S1062>/Limiter' */
        /* Switch: '<S1070>/Switch1' incorporates:
         *  Constant: '<S1065>/Calib'
         *  RelationalOperator: '<S1070>/Relational Operator'
         */
        if (KeESSR_dM_InitSpinEngStrtTorqLU < rtb_Switch1_oim)
        {
            /* Switch: '<S1070>/Switch1' */
            rtb_Switch1_oim = KeESSR_dM_InitSpinEngStrtTorqLU;
        }

        /* Switch: '<S1070>/Switch' incorporates:
         *  Constant: '<S1064>/Calib'
         *  RelationalOperator: '<S1070>/Relational Operator1'
         */
        if (rtb_Switch1_oim <= KeESSR_dM_InitSpinEngStrtTorqLD)
        {
            rtb_Switch1_oim = KeESSR_dM_InitSpinEngStrtTorqLD;
        }

        /* End of Outputs for SubSystem: '<S1062>/Limiter' */

        /* Sum: '<S1062>/Sum3' */
        VeESSR_M_InitSpinEngStrtTorqLmtd = rtb_Switch1_oim + rtb_Product_in;

        /* Update for UnitDelay: '<S1062>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_h = VeESSR_M_InitSpinEngStrtTorqLmtd;

        /* End of Outputs for SubSystem: '<S1030>/GradientLimiter' */

        /* Switch: '<S1022>/Switch7' incorporates:
         *  Constant: '<S1040>/Calib'
         *  DataStoreWrite: '<S1022>/Data Store Write3'
         */
        if (!HeESSR_b_EngStrtTorq)
        {
            VeESSR_M_EngStrtTorq_DS = VeESSR_M_InitSpinEngStrtTorqLmtd;
        }

        /* Logic: '<S1022>/Logical2' incorporates:
         *  Constant: '<S1036>/Constant'
         *  Constant: '<S1037>/Constant'
         *  Constant: '<S1038>/Calib'
         *  Constant: '<S1039>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
         *  Logic: '<S1022>/Logical1'
         *  Logic: '<S1022>/Logical3'
         *  Logic: '<S1022>/Logical6'
         *  RelationalOperator: '<S1022>/Comparison1'
         *  RelationalOperator: '<S1022>/Comparison4'
         */
        rtb_Logical2_eb = ((((uint32)VeESSR_e_EngStrtProfType_DS) ==
                            CeESSR_e_KeyCrnkAlgo) || (((uint32)
                             VeESSR_e_EngStrtProfType_DS) == CeESSR_e_LowPwrAlgo));
        rtb_Logical2_eb = (((HeESSR_b_12vStrtrEquipped) ||
                            ((HeESSR_b_BumpStrtEquipped) && rtb_Logical2_eb)) &&
                           rtb_Logical2_eb);

        /* MinMax: '<S1032>/MinMax' incorporates:
         *  DataStoreRead: '<S1032>/Dsr_StrtTypInitSpinEndPnt'
         *  SignalConversion generated from: '<S1075>/Vector'
         */
        rtb_MinMax_if[0] = VeESSR_Cnt_InitSpnStepPt;
        rtb_MinMax_if[1] = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;

        /* Sum: '<S1032>/Sum' */
        rtb_Switch1_oim = VeESSR_M_EngTrqAct_Lmtd - VeESSR_M_SpnUpAddtlTorq;
        for (iU = 0; iU < 2; iU++)
        {
            rtb_MinMax_if[iU] = fmaxf(VeESSR_M_TiEstMin, look1_iflf_binlcapw
                (rtb_MinMax_if[iU], ((const float32 *)&(KxESSR_K_InitSpinTiProf
                [0])), ((const float32 *)&(KtESSR_K_InitSpinTiProf[0])), 6U) *
                rtb_Switch1_oim);
        }

        /* Switch: '<S1022>/Switch2' incorporates:
         *  Constant: '<S1022>/Constant Value1'
         *  DataStoreWrite: '<S1022>/Dsw_InputTorqEst'
         *  Lookup_n-D: '<S1075>/Vector'
         *  MinMax: '<S1032>/MinMax'
         *  Product: '<S1032>/Product1'
         */
        if (rtb_Logical2_eb)
        {
            VeESSR_M_EngTorqEst_DS = 0.0F;
        }
        else
        {
            VeESSR_M_EngTorqEst_DS = rtb_MinMax_if[0];
        }

        /* DataStoreWrite: '<S1022>/Dsw_STMTmr' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr'
         *  Sum: '<S1022>/Summation'
         */
        VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

        /* Switch: '<S1044>/Switch1' incorporates:
         *  Constant: '<S1049>/Calib'
         */
        if (KeESSR_b_InitSpnTmrChkOnly)
        {
            /* Switch: '<S1044>/Switch1' */
            rtb_Switch1_au = VeESSR_b_InitSpnTmrCmplt;
        }

        /* SignalConversion generated from: '<S1022>/Variant Source' incorporates:
         *  Logic: '<S1054>/Logical1'
         *  Logic: '<S1054>/Logical2'
         *  Logic: '<S1054>/Logical3'
         *  Logic: '<S1054>/Logical4'
         *  RelationalOperator: '<S1054>/Comparison1'
         *  RelationalOperator: '<S1054>/Comparison6'
         *  RelationalOperator: '<S1054>/Comparison7'
         *  RelationalOperator: '<S1054>/Comparison8'
         */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

        /* Switch: '<S1022>/Switch5' incorporates:
         *  Constant: '<S1022>/FALSE Constant1'
         */
        rtb_Switch5_hb = false;

#else

        /* Logic: '<S1054>/Logical4' incorporates:
         *  Constant: '<S1085>/Constant'
         *  Constant: '<S1086>/Constant'
         *  Constant: '<S1087>/Constant'
         *  Constant: '<S1088>/Constant'
         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
         *  Logic: '<S1054>/Logical1'
         *  Logic: '<S1054>/Logical2'
         *  Logic: '<S1054>/Logical3'
         *  RelationalOperator: '<S1022>/Comparison4'
         *  RelationalOperator: '<S1054>/Comparison1'
         *  RelationalOperator: '<S1054>/Comparison6'
         *  RelationalOperator: '<S1054>/Comparison7'
         *  RelationalOperator: '<S1054>/Comparison8'
         */
        VeESSR_b_InitSpin_48VP2CoastDown = (((((((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMStrtAlgo) || (((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_ImplStrtAlgo)) || (((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo)) &&
            (VeESSR_b_EMErlyExitLmp)) || ((((uint32)VeESSR_e_EngStrtProfType_DS)
            == CeESSR_e_CltchStrtAlgo) && (VeESSR_b_ClthErlyExitLmp)));

        /* Switch: '<S1022>/Switch5' */
        rtb_Switch5_hb = VeESSR_b_InitSpin_48VP2CoastDown;

#endif

        /* Switch: '<S1022>/Switch5' */
        if (!VeESSR_b_StrtTypChngDisbl)
        {
            /* Switch: '<S1022>/Switch5' incorporates:
             *  Constant: '<S1035>/Constant'
             *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
             *  Logic: '<S1022>/Logical Operator4'
             *  Logic: '<S1022>/Logical Operator5'
             *  RelationalOperator: '<S1022>/Comparison2'
             *  RelationalOperator: '<S1022>/Comparison4'
             */
            rtb_Switch5_hb = (((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B) ||
                               ((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d) &&
                                (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                 CeESSR_e_KeyCrnkAlgo))) ||
                              (VeESSR_b_ErlyExitLmp));
        }

        /* Logic: '<S1022>/Logical Operator3' incorporates:
         *  Constant: '<S1041>/Calib'
         *  Constant: '<S1045>/Calib'
         *  Constant: '<S1046>/Calib'
         *  Constant: '<S1047>/Calib'
         *  Constant: '<S1048>/Calib'
         *  DataStoreRead: '<S1022>/Data Store Read18'
         *  DataStoreRead: '<S1022>/Data Store Read19'
         *  Logic: '<S1022>/Logical Operator2'
         *  Logic: '<S1022>/Logical5'
         *  Logic: '<S1022>/Logical8'
         *  Logic: '<S1022>/Logical9'
         *  RelationalOperator: '<S1022>/Greater  Than11'
         *  RelationalOperator: '<S1022>/Greater  Than15'
         */
        VeESSR_b_InitSpin_CoastDownTrig = ((rtb_Switch5_hb ||
            rtb_LogicalOperator_h) && ((((KeESSR_b_EnblFtrBackupStrt) &&
            (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
             KeESSR_Cnt_BackupStrtMaxAttmpts)) || ((KeESSR_b_EnblFtrBumpStrt) &&
            (VeESSR_Cnt_BumpStrtAttmptCntr_DS < KeESSR_Cnt_BumpStrtMaxAttmpts)))
            || (HeESSR_b_LimphomeEnbl)));

        /* If: '<S1022>/If1' */
        if (rtb_Switch1_au)
        {
            /* Outputs for IfAction SubSystem: '<S1022>/NormExit' incorporates:
             *  ActionPort: '<S1052>/Action Port'
             */
            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S1082>/Constant'
             *  Merge: '<S1022>/Merge1'
             *  SignalConversion generated from: '<S1052>/ESSTrig'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_EngBrkawayAch;

            /* End of Outputs for SubSystem: '<S1022>/NormExit' */
        }
        else if (VeESSR_b_InitSpin_CoastDownTrig)
        {
            /* Outputs for IfAction SubSystem: '<S1022>/If Action Subsystem' incorporates:
             *  ActionPort: '<S1043>/Action Port'
             */
            /* Switch: '<S1043>/Switch' incorporates:
             *  Constant: '<S1080>/Constant'
             *  Constant: '<S1081>/Constant'
             *  DataStoreRead: '<S1043>/Data Store Read5'
             *  DataStoreWrite: '<S1043>/Dsw_StrtStpFailDTC'
             */
            if (VeESSR_b_BSGStrtFailed_DS)
            {
                VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;
            }
            else
            {
                VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
            }

            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S1079>/Constant'
             *  Merge: '<S1022>/Merge1'
             *  SignalConversion generated from: '<S1043>/ESSTrig'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

            /* End of Outputs for SubSystem: '<S1022>/If Action Subsystem' */
        }
        else
        {
            if (rtb_GreaterThan1_f)
            {
                /* Outputs for IfAction SubSystem: '<S1022>/OffFail' incorporates:
                 *  ActionPort: '<S1053>/Action Port'
                 */
                /* DataStoreWrite: '<S1053>/Dsw_StrtStpFailDTC' incorporates:
                 *  Constant: '<S1084>/Constant'
                 */
                VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;

                /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                 *  Constant: '<S1083>/Constant'
                 *  Merge: '<S1022>/Merge1'
                 *  SignalConversion generated from: '<S1053>/ESSTrig'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

                /* End of Outputs for SubSystem: '<S1022>/OffFail' */
            }
        }

        /* Switch: '<S1022>/Switch4' incorporates:
         *  Constant: '<S1022>/Constant Value2'
         *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType2'
         *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType6'
         *  DataStoreWrite: '<S1022>/Dsw_StrtStpFailDTC1'
         *  Logic: '<S1022>/Logical21'
         *  Logic: '<S1022>/Logical7'
         *  RelationalOperator: '<S1022>/Comparison'
         *  S-Function (sfix_bitop): '<S1022>/Bitwise Operator'
         *  S-Function (sfix_bitop): '<S1028>/FixPt Bitwise Operator1'
         */
        if (((VeESSR_b_InitSpin_CoastDownTrig) || rtb_GreaterThan1_f) &&
                ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16U) > 0U))
        {
            VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 16U;
        }

        /* Switch: '<S1071>/Switch1' incorporates:
         *  Constant: '<S1072>/Calib'
         *  DataStoreWrite: '<S1031>/Dsw_InitEngAng720'
         *  RelationalOperator: '<S1031>/Equal1'
         */
        if (VeESSR_Cnt_InitSpnStepPt <= KeESSR_t_InitSpnInitAngTm)
        {
            VeESSR_phi_InitEngAng720_DS =
                ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi;
        }

        /* Sum: '<S1032>/Subtract' incorporates:
         *  Constant: '<S1074>/Calib'
         *  DataStoreRead: '<S1032>/Dsr_NiProfGenNiDMax'
         *  DataStoreWrite: '<S1032>/Data Store Write'
         *  Product: '<S1032>/Product'
         */
        ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = rtb_MinMax_if[1] -
            (VeESSR_dn_StrtTypNiDotMax_DS * KeESSR_r_NiDtoTiMargin);

        /* DataStoreWrite: '<S1022>/Dsw_InputAcceltnProf1' */
        VeESSR_dn_InputAcceltnProf_DS =
            ESSR_ac_B.VariantMerge_For_Variant_Source;

        /* RelationalOperator: '<S1022>/Equal1' incorporates:
         *  Constant: '<S1022>/Constant Value'
         *  DataStoreRead: '<S1022>/Data Store Read5'
         *  DataStoreWrite: '<S1022>/Data Store Write5'
         */
        VeESSR_b_BSGStrtFailed_DS = (VeESSR_g_BSGStrtFailRsn_DS != 0U);

        /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqImmed' incorporates:
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitImmedTorq'
         */
        VeESSR_M_EngTrqReqImmed_DS = VeESSR_M_StrtTypInitImmedTorq_DS;

        /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqPrdtd1' incorporates:
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitPredTorq'
         */
        VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

        /* Switch: '<S1078>/Switch3' */
        if (rtb_Equal2)
        {
            /* Update for UnitDelay: '<S1078>/Unit Delay' incorporates:
             *  Constant: '<S1033>/Constant Value5'
             */
            ESSR_ac_DW.UnitDelay_DSTATE_iu = 0.0F;
        }
        else
        {
            /* Update for UnitDelay: '<S1078>/Unit Delay' */
            ESSR_ac_DW.UnitDelay_DSTATE_iu = rtb_Sum_k0;
        }

        /* End of Outputs for SubSystem: '<S559>/InitEngSpinDur' */
    }
    else if (((((HeESSR_b_12vStrtrEquipped) || (HeESSR_b_12vBSGLowPwr)) &&
               rtb_Equal2) && ((((uint32)(*Dsr_EngStrtType)) ==
                                CeESSR_e_LowPwrAlgo) || (((uint32)
                 (*Dsr_EngStrtType)) == CeESSR_e_KeyCrnkAlgo))) &&
             (!(*Dsr_PFSRunReq1)))
    {
        /* Transition: '<S165>:103' */
        ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_InitEngSpin_3;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'InitEngSpin_3': '<S165>:102' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

        /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinEnt' */
        /* Event: '<S165>:80' */
        ESSR_ac_InitEngSpinEnt(ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                               ESSR_ac_B.TmpSignalConversionAtVeESMR_P_d,
                               rtb_Sum_k0,
                               ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d);

        /* End of Outputs for SubSystem: '<S559>/InitEngSpinEnt' */

        /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinDur' */
        /* RelationalOperator: '<S1022>/Equal2' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr'
         */
        /* Event: '<S165>:81' */
        rtb_Equal2 = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

        /* Switch: '<S1078>/Switch1' incorporates:
         *  Constant: '<S1033>/Constant Value5'
         *  UnitDelay: '<S1078>/Unit Delay'
         */
        if (rtb_Equal2)
        {
            rtb_Sum_k0 = 0.0F;
        }
        else
        {
            rtb_Sum_k0 = ESSR_ac_DW.UnitDelay_DSTATE_iu;
        }

        /* Sum: '<S1033>/Sum' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitSpinScaler'
         *  Product: '<S1022>/Product'
         */
        rtb_Sum_k0 += HeESSR_t_MedTEB_dT * VeESSR_k_StrtTypInitSpinScaler_DS;

        /* Outputs for Atomic SubSystem: '<S1033>/Limiter' */
        /* Switch: '<S1077>/Switch1' incorporates:
         *  DataStoreRead: '<S1033>/Dsr_StrtTypInitSpinEndPnt'
         *  RelationalOperator: '<S1077>/Relational Operator'
         */
        if (VeESSR_Cnt_StrtTypInitSpinEndPnt_DS < rtb_Sum_k0)
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;
        }
        else
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = rtb_Sum_k0;
        }

        /* Switch: '<S1077>/Switch' incorporates:
         *  Constant: '<S1033>/Constant Value1'
         *  RelationalOperator: '<S1077>/Relational Operator1'
         */
        if (rtb_Product_in > 0.0F)
        {
            /* Switch: '<S1077>/Switch' */
            VeESSR_Cnt_InitSpnStepPt = rtb_Product_in;
        }
        else
        {
            /* Switch: '<S1077>/Switch' */
            VeESSR_Cnt_InitSpnStepPt = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1033>/Limiter' */

        /* RelationalOperator: '<S1034>/Greater  Than2' incorporates:
         *  DataStoreRead: '<S1034>/Dsr_StrtTypInitSpinEndPnt'
         */
        VeESSR_b_InitSpnTmrCmplt = (VeESSR_Cnt_InitSpnStepPt >=
            VeESSR_Cnt_StrtTypInitSpinEndPnt_DS);

        /* Outputs for Atomic SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */
        /* Switch: '<S1058>/Switch' */
        if (rtb_Equal2)
        {
            /* Switch: '<S1058>/Switch' incorporates:
             *  Constant: '<S1029>/Constant Value4'
             */
            rtb_Switch1_oim = 0.0F;
        }
        else
        {
            /* Switch: '<S1058>/Switch' incorporates:
             *  Constant: '<S1029>/Cnvrt2Deg'
             *  Constant: '<S1057>/Calib'
             *  Product: '<S1058>/Division'
             *  Product: '<S1058>/Multiplication'
             *  Sum: '<S1058>/Sum//Sub'
             *  UnitDelay: '<S1058>/Unit Delay'
             */
            rtb_Switch1_oim = ((HeESSR_t_MedTEB_dT / 0.166666672F) *
                               ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I) +
                ESSR_ac_DW.UnitDelay_DSTATE_e;
        }

        /* Outputs for Atomic SubSystem: '<S1058>/Limiter' */
        /* Switch: '<S1061>/Switch1' incorporates:
         *  Constant: '<S1029>/Constant Value1'
         *  RelationalOperator: '<S1061>/Relational Operator'
         */
        if (999.0F < rtb_Switch1_oim)
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = 999.0F;
        }
        else
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = rtb_Switch1_oim;
        }

        /* Switch: '<S1061>/Switch' incorporates:
         *  Constant: '<S1029>/Constant Value'
         *  RelationalOperator: '<S1061>/Relational Operator1'
         */
        if (rtb_Product_in <= 0.0F)
        {
            /* Switch: '<S1061>/Switch' */
            rtb_Product_in = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1058>/Limiter' */

        /* Update for UnitDelay: '<S1058>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_e = rtb_Product_in;

        /* End of Outputs for SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */

        /* Switch: '<S1070>/Switch1' incorporates:
         *  Constant: '<S1029>/Constant Value3'
         *  DataStoreRead: '<S1029>/Dsr_STMTmr3'
         *  Product: '<S1060>/Division'
         *  Sum: '<S1029>/Subtraction'
         */
        rtb_Switch1_oim = (ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi -
                           VeESSR_phi_InitEngAng720_DS) / 720.0F;

        /* Logic: '<S1029>/AND' incorporates:
         *  Constant: '<S1029>/Constant Value3'
         *  DataStoreRead: '<S1029>/Dsr_STMTmr1'
         *  Product: '<S1060>/Multiplication'
         *  RelationalOperator: '<S1029>/Greater  Than1'
         *  RelationalOperator: '<S1029>/Greater  Than2'
         *  Rounding: '<S1060>/Floor'
         *  Sum: '<S1060>/Subtraction'
         */
        VeESSR_b_InitSpnEngMvmntDet = ((rtb_Product_in >
            VeESSR_phi_StrtTypInitSpinBrkAng_DS) || (((rtb_Switch1_oim - roundf
            (rtb_Switch1_oim)) * 720.0F) > VeESSR_phi_StrtTypInitSpinBrkAng_DS));

        /* Switch: '<S1044>/Switch1' incorporates:
         *  Logic: '<S1022>/Logical'
         */
        rtb_Switch1_au = ((VeESSR_b_InitSpnTmrCmplt) ||
                          (VeESSR_b_InitSpnEngMvmntDet));

        /* RelationalOperator: '<S1022>/Greater  Than1' incorporates:
         *  Constant: '<S1050>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr1'
         */
        rtb_GreaterThan1_f = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmInitSpin);

        /* Logic: '<S1022>/Logical Operator' incorporates:
         *  Logic: '<S1022>/Logical Operator1'
         */
        rtb_LogicalOperator_h = ((!rtb_Switch1_au) && rtb_GreaterThan1_f);

        /* Switch: '<S1022>/Switch3' incorporates:
         *  DataStoreRead: '<S1022>/Data Store Read'
         *  DataStoreRead: '<S1022>/Data Store Read1'
         *  DataStoreWrite: '<S1022>/Data Store Write'
         *  DataStoreWrite: '<S1022>/Data Store Write1'
         *  S-Function (sfix_bitop): '<S1026>/FixPt Bitwise Operator1'
         *  S-Function (sfix_bitop): '<S1027>/FixPt Bitwise Operator1'
         *  Switch: '<S1022>/Switch1'
         */
        if (rtb_LogicalOperator_h)
        {
            ESSR_ac_DW.NeESSR_g_StrtStpFailRsn |= 4U;
            VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS | 1U;
        }

        /* Outputs for Atomic SubSystem: '<S1030>/Protected Division' */
        /* Switch: '<S1069>/Switch1' incorporates:
         *  Constant: '<S1063>/Calib'
         *  Constant: '<S1069>/Constant Value'
         *  Constant: '<S1069>/Constant Value1'
         *  Constant: '<S1069>/Constant Value2'
         *  Constant: '<S1069>/Constant Value3'
         *  DataStoreRead: '<S1030>/Dsr_STMTmr2'
         *  Logic: '<S1069>/AND'
         *  RelationalOperator: '<S1069>/Greater Than or Equal '
         *  RelationalOperator: '<S1069>/Greater Than or Equal 1'
         *  RelationalOperator: '<S1069>/Not Equal'
         *  RelationalOperator: '<S1069>/Not Equal1'
         *  Switch: '<S1069>/Switch2'
         *  Switch: '<S1069>/Switch3'
         */
        if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT != 0.0F))
        {
            /* Switch: '<S1069>/Switch1' incorporates:
             *  Product: '<S1069>/Division'
             */
            rtb_Switch1_oim = VeESSR_t_STMTmr_DS / HeESSR_t_MedTEB_dT;
        }
        else if (VeESSR_t_STMTmr_DS > 0.0F)
        {
            /* Switch: '<S1069>/Switch2' incorporates:
             *  Constant: '<S1069>/MAXFLOAT'
             *  Switch: '<S1069>/Switch1'
             */
            rtb_Switch1_oim = 3.402823466E+38F;
        }
        else if (VeESSR_t_STMTmr_DS < 0.0F)
        {
            /* Switch: '<S1069>/Switch3' incorporates:
             *  Constant: '<S1069>/MINFLOAT'
             *  Switch: '<S1069>/Switch1'
             *  Switch: '<S1069>/Switch2'
             */
            rtb_Switch1_oim = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1069>/Switch1' incorporates:
             *  Constant: '<S1069>/Constant Value4'
             *  Switch: '<S1069>/Switch2'
             *  Switch: '<S1069>/Switch3'
             */
            rtb_Switch1_oim = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1030>/Protected Division' */

        /* Sum: '<S1030>/Summation2' incorporates:
         *  Constant: '<S1030>/Constant Value'
         *  Gain: '<S1030>/Gain'
         *  Lookup_n-D: '<S1066>/Vector'
         *  Lookup_n-D: '<S1068>/Vector'
         *  MinMax: '<S1030>/MinMax'
         *  Product: '<S1030>/Product1'
         *  Switch: '<S1069>/Switch1'
         */
        VeESSR_M_InitSpinEngFricEngStrtTorq = (fmaxf(-VeESSR_M_EngTrqAct_Lmtd,
            0.0F) * look1_iflf_binlcapw(rtb_Switch1_oim, ((const float32 *)
            &(KxESSR_K_InitSpinEngStrtTorqGain[0])), ((const float32 *)
            &(KtESSR_K_InitSpinEngStrtTorqGain[0])), 4U)) + look1_iflf_binlcapw
            (rtb_Switch1_oim, ((const float32 *)
                               &(KxESSR_M_InitSpinEngStrtTorqOffset[0])), ((
               const float32 *)&(KtESSR_M_InitSpinEngStrtTorqOffset[0])), 4U);

        /* Abs: '<S1030>/Abs' */
        VeESSR_M_InitSpinEngPulseEngStrtTorq = fabsf
            (ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E);

        /* Lookup_n-D: '<S1067>/Vector' incorporates:
         *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
         */
        VeESSR_M_InitSpinECTEngStrtTorq = look1_iflf_binlcapw
            (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const float32 *)
              &(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((const float32 *)
              &(KtESSR_M_ECTAddtlEngStrtTorq[0])), 6U);

        /* Sum: '<S1030>/Summation1' */
        VeESSR_M_InitSpinEngStrtTorqRaw = (VeESSR_M_InitSpinEngFricEngStrtTorq +
            VeESSR_M_InitSpinEngPulseEngStrtTorq) +
            VeESSR_M_InitSpinECTEngStrtTorq;

        /* Outputs for Atomic SubSystem: '<S1030>/GradientLimiter' */
        /* Product: '<S1032>/Product' incorporates:
         *  UnitDelay: '<S1062>/Unit Delay'
         */
        rtb_Product_in = ESSR_ac_DW.UnitDelay_DSTATE_h;

        /* Sum: '<S1062>/Sum2' */
        rtb_Switch1_oim = VeESSR_M_InitSpinEngStrtTorqRaw - rtb_Product_in;

        /* Outputs for Atomic SubSystem: '<S1062>/Limiter' */
        /* Switch: '<S1070>/Switch1' incorporates:
         *  Constant: '<S1065>/Calib'
         *  RelationalOperator: '<S1070>/Relational Operator'
         */
        if (KeESSR_dM_InitSpinEngStrtTorqLU < rtb_Switch1_oim)
        {
            /* Switch: '<S1070>/Switch1' */
            rtb_Switch1_oim = KeESSR_dM_InitSpinEngStrtTorqLU;
        }

        /* Switch: '<S1070>/Switch' incorporates:
         *  Constant: '<S1064>/Calib'
         *  RelationalOperator: '<S1070>/Relational Operator1'
         */
        if (rtb_Switch1_oim <= KeESSR_dM_InitSpinEngStrtTorqLD)
        {
            rtb_Switch1_oim = KeESSR_dM_InitSpinEngStrtTorqLD;
        }

        /* End of Outputs for SubSystem: '<S1062>/Limiter' */

        /* Sum: '<S1062>/Sum3' */
        VeESSR_M_InitSpinEngStrtTorqLmtd = rtb_Switch1_oim + rtb_Product_in;

        /* Update for UnitDelay: '<S1062>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_h = VeESSR_M_InitSpinEngStrtTorqLmtd;

        /* End of Outputs for SubSystem: '<S1030>/GradientLimiter' */

        /* Switch: '<S1022>/Switch7' incorporates:
         *  Constant: '<S1040>/Calib'
         *  DataStoreWrite: '<S1022>/Data Store Write3'
         */
        if (!HeESSR_b_EngStrtTorq)
        {
            VeESSR_M_EngStrtTorq_DS = VeESSR_M_InitSpinEngStrtTorqLmtd;
        }

        /* Logic: '<S1022>/Logical2' incorporates:
         *  Constant: '<S1036>/Constant'
         *  Constant: '<S1037>/Constant'
         *  Constant: '<S1038>/Calib'
         *  Constant: '<S1039>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
         *  Logic: '<S1022>/Logical1'
         *  Logic: '<S1022>/Logical3'
         *  Logic: '<S1022>/Logical6'
         *  RelationalOperator: '<S1022>/Comparison1'
         *  RelationalOperator: '<S1022>/Comparison4'
         */
        rtb_Logical2_eb = ((((uint32)VeESSR_e_EngStrtProfType_DS) ==
                            CeESSR_e_KeyCrnkAlgo) || (((uint32)
                             VeESSR_e_EngStrtProfType_DS) == CeESSR_e_LowPwrAlgo));
        rtb_Logical2_eb = (((HeESSR_b_12vStrtrEquipped) ||
                            ((HeESSR_b_BumpStrtEquipped) && rtb_Logical2_eb)) &&
                           rtb_Logical2_eb);

        /* MinMax: '<S1032>/MinMax' incorporates:
         *  DataStoreRead: '<S1032>/Dsr_StrtTypInitSpinEndPnt'
         *  SignalConversion generated from: '<S1075>/Vector'
         */
        rtb_MinMax_if[0] = VeESSR_Cnt_InitSpnStepPt;
        rtb_MinMax_if[1] = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;

        /* Sum: '<S1032>/Sum' */
        rtb_Switch1_oim = VeESSR_M_EngTrqAct_Lmtd - VeESSR_M_SpnUpAddtlTorq;
        for (iU = 0; iU < 2; iU++)
        {
            rtb_MinMax_if[iU] = fmaxf(VeESSR_M_TiEstMin, look1_iflf_binlcapw
                (rtb_MinMax_if[iU], ((const float32 *)&(KxESSR_K_InitSpinTiProf
                [0])), ((const float32 *)&(KtESSR_K_InitSpinTiProf[0])), 6U) *
                rtb_Switch1_oim);
        }

        /* Switch: '<S1022>/Switch2' incorporates:
         *  Constant: '<S1022>/Constant Value1'
         *  DataStoreWrite: '<S1022>/Dsw_InputTorqEst'
         *  Lookup_n-D: '<S1075>/Vector'
         *  MinMax: '<S1032>/MinMax'
         *  Product: '<S1032>/Product1'
         */
        if (rtb_Logical2_eb)
        {
            VeESSR_M_EngTorqEst_DS = 0.0F;
        }
        else
        {
            VeESSR_M_EngTorqEst_DS = rtb_MinMax_if[0];
        }

        /* DataStoreWrite: '<S1022>/Dsw_STMTmr' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr'
         *  Sum: '<S1022>/Summation'
         */
        VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

        /* Switch: '<S1044>/Switch1' incorporates:
         *  Constant: '<S1049>/Calib'
         */
        if (KeESSR_b_InitSpnTmrChkOnly)
        {
            /* Switch: '<S1044>/Switch1' */
            rtb_Switch1_au = VeESSR_b_InitSpnTmrCmplt;
        }

        /* SignalConversion generated from: '<S1022>/Variant Source' incorporates:
         *  Logic: '<S1054>/Logical1'
         *  Logic: '<S1054>/Logical2'
         *  Logic: '<S1054>/Logical3'
         *  Logic: '<S1054>/Logical4'
         *  RelationalOperator: '<S1054>/Comparison1'
         *  RelationalOperator: '<S1054>/Comparison6'
         *  RelationalOperator: '<S1054>/Comparison7'
         *  RelationalOperator: '<S1054>/Comparison8'
         */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

        /* Switch: '<S1022>/Switch5' incorporates:
         *  Constant: '<S1022>/FALSE Constant1'
         */
        rtb_Switch5_hb = false;

#else

        /* Logic: '<S1054>/Logical4' incorporates:
         *  Constant: '<S1085>/Constant'
         *  Constant: '<S1086>/Constant'
         *  Constant: '<S1087>/Constant'
         *  Constant: '<S1088>/Constant'
         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
         *  Logic: '<S1054>/Logical1'
         *  Logic: '<S1054>/Logical2'
         *  Logic: '<S1054>/Logical3'
         *  RelationalOperator: '<S1022>/Comparison4'
         *  RelationalOperator: '<S1054>/Comparison1'
         *  RelationalOperator: '<S1054>/Comparison6'
         *  RelationalOperator: '<S1054>/Comparison7'
         *  RelationalOperator: '<S1054>/Comparison8'
         */
        VeESSR_b_InitSpin_48VP2CoastDown = (((((((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMStrtAlgo) || (((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_ImplStrtAlgo)) || (((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo)) &&
            (VeESSR_b_EMErlyExitLmp)) || ((((uint32)VeESSR_e_EngStrtProfType_DS)
            == CeESSR_e_CltchStrtAlgo) && (VeESSR_b_ClthErlyExitLmp)));

        /* Switch: '<S1022>/Switch5' */
        rtb_Switch5_hb = VeESSR_b_InitSpin_48VP2CoastDown;

#endif

        /* Switch: '<S1022>/Switch5' */
        if (!VeESSR_b_StrtTypChngDisbl)
        {
            /* Switch: '<S1022>/Switch5' incorporates:
             *  Constant: '<S1035>/Constant'
             *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
             *  Logic: '<S1022>/Logical Operator4'
             *  Logic: '<S1022>/Logical Operator5'
             *  RelationalOperator: '<S1022>/Comparison2'
             *  RelationalOperator: '<S1022>/Comparison4'
             */
            rtb_Switch5_hb = (((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B) ||
                               ((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d) &&
                                (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                 CeESSR_e_KeyCrnkAlgo))) ||
                              (VeESSR_b_ErlyExitLmp));
        }

        /* Logic: '<S1022>/Logical Operator3' incorporates:
         *  Constant: '<S1041>/Calib'
         *  Constant: '<S1045>/Calib'
         *  Constant: '<S1046>/Calib'
         *  Constant: '<S1047>/Calib'
         *  Constant: '<S1048>/Calib'
         *  DataStoreRead: '<S1022>/Data Store Read18'
         *  DataStoreRead: '<S1022>/Data Store Read19'
         *  Logic: '<S1022>/Logical Operator2'
         *  Logic: '<S1022>/Logical5'
         *  Logic: '<S1022>/Logical8'
         *  Logic: '<S1022>/Logical9'
         *  RelationalOperator: '<S1022>/Greater  Than11'
         *  RelationalOperator: '<S1022>/Greater  Than15'
         */
        VeESSR_b_InitSpin_CoastDownTrig = ((rtb_Switch5_hb ||
            rtb_LogicalOperator_h) && ((((KeESSR_b_EnblFtrBackupStrt) &&
            (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
             KeESSR_Cnt_BackupStrtMaxAttmpts)) || ((KeESSR_b_EnblFtrBumpStrt) &&
            (VeESSR_Cnt_BumpStrtAttmptCntr_DS < KeESSR_Cnt_BumpStrtMaxAttmpts)))
            || (HeESSR_b_LimphomeEnbl)));

        /* If: '<S1022>/If1' */
        if (rtb_Switch1_au)
        {
            /* Outputs for IfAction SubSystem: '<S1022>/NormExit' incorporates:
             *  ActionPort: '<S1052>/Action Port'
             */
            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S1082>/Constant'
             *  Merge: '<S1022>/Merge1'
             *  SignalConversion generated from: '<S1052>/ESSTrig'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_EngBrkawayAch;

            /* End of Outputs for SubSystem: '<S1022>/NormExit' */
        }
        else if (VeESSR_b_InitSpin_CoastDownTrig)
        {
            /* Outputs for IfAction SubSystem: '<S1022>/If Action Subsystem' incorporates:
             *  ActionPort: '<S1043>/Action Port'
             */
            /* Switch: '<S1043>/Switch' incorporates:
             *  Constant: '<S1080>/Constant'
             *  Constant: '<S1081>/Constant'
             *  DataStoreRead: '<S1043>/Data Store Read5'
             *  DataStoreWrite: '<S1043>/Dsw_StrtStpFailDTC'
             */
            if (VeESSR_b_BSGStrtFailed_DS)
            {
                VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;
            }
            else
            {
                VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
            }

            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S1079>/Constant'
             *  Merge: '<S1022>/Merge1'
             *  SignalConversion generated from: '<S1043>/ESSTrig'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

            /* End of Outputs for SubSystem: '<S1022>/If Action Subsystem' */
        }
        else
        {
            if (rtb_GreaterThan1_f)
            {
                /* Outputs for IfAction SubSystem: '<S1022>/OffFail' incorporates:
                 *  ActionPort: '<S1053>/Action Port'
                 */
                /* DataStoreWrite: '<S1053>/Dsw_StrtStpFailDTC' incorporates:
                 *  Constant: '<S1084>/Constant'
                 */
                VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;

                /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                 *  Constant: '<S1083>/Constant'
                 *  Merge: '<S1022>/Merge1'
                 *  SignalConversion generated from: '<S1053>/ESSTrig'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

                /* End of Outputs for SubSystem: '<S1022>/OffFail' */
            }
        }

        /* Switch: '<S1022>/Switch4' incorporates:
         *  Constant: '<S1022>/Constant Value2'
         *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType2'
         *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType6'
         *  DataStoreWrite: '<S1022>/Dsw_StrtStpFailDTC1'
         *  Logic: '<S1022>/Logical21'
         *  Logic: '<S1022>/Logical7'
         *  RelationalOperator: '<S1022>/Comparison'
         *  S-Function (sfix_bitop): '<S1022>/Bitwise Operator'
         *  S-Function (sfix_bitop): '<S1028>/FixPt Bitwise Operator1'
         */
        if (((VeESSR_b_InitSpin_CoastDownTrig) || rtb_GreaterThan1_f) &&
                ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16U) > 0U))
        {
            VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 16U;
        }

        /* Switch: '<S1071>/Switch1' incorporates:
         *  Constant: '<S1072>/Calib'
         *  DataStoreWrite: '<S1031>/Dsw_InitEngAng720'
         *  RelationalOperator: '<S1031>/Equal1'
         */
        if (VeESSR_Cnt_InitSpnStepPt <= KeESSR_t_InitSpnInitAngTm)
        {
            VeESSR_phi_InitEngAng720_DS =
                ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi;
        }

        /* Sum: '<S1032>/Subtract' incorporates:
         *  Constant: '<S1074>/Calib'
         *  DataStoreRead: '<S1032>/Dsr_NiProfGenNiDMax'
         *  DataStoreWrite: '<S1032>/Data Store Write'
         *  Product: '<S1032>/Product'
         */
        ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = rtb_MinMax_if[1] -
            (VeESSR_dn_StrtTypNiDotMax_DS * KeESSR_r_NiDtoTiMargin);

        /* DataStoreWrite: '<S1022>/Dsw_InputAcceltnProf1' */
        VeESSR_dn_InputAcceltnProf_DS =
            ESSR_ac_B.VariantMerge_For_Variant_Source;

        /* RelationalOperator: '<S1022>/Equal1' incorporates:
         *  Constant: '<S1022>/Constant Value'
         *  DataStoreRead: '<S1022>/Data Store Read5'
         *  DataStoreWrite: '<S1022>/Data Store Write5'
         */
        VeESSR_b_BSGStrtFailed_DS = (VeESSR_g_BSGStrtFailRsn_DS != 0U);

        /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqImmed' incorporates:
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitImmedTorq'
         */
        VeESSR_M_EngTrqReqImmed_DS = VeESSR_M_StrtTypInitImmedTorq_DS;

        /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqPrdtd1' incorporates:
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitPredTorq'
         */
        VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

        /* Switch: '<S1078>/Switch3' */
        if (rtb_Equal2)
        {
            /* Update for UnitDelay: '<S1078>/Unit Delay' incorporates:
             *  Constant: '<S1033>/Constant Value5'
             */
            ESSR_ac_DW.UnitDelay_DSTATE_iu = 0.0F;
        }
        else
        {
            /* Update for UnitDelay: '<S1078>/Unit Delay' */
            ESSR_ac_DW.UnitDelay_DSTATE_iu = rtb_Sum_k0;
        }

        /* End of Outputs for SubSystem: '<S559>/InitEngSpinDur' */
    }
    else if ((((!HeESSR_b_12vStrtrEquipped) && (!HeESSR_b_12vBSGLowPwr)) &&
              rtb_Equal2) && ((((uint32)(*Dsr_EngStrtType)) ==
                               CeESSR_e_LowPwrAlgo) || (((uint32)
                (*Dsr_EngStrtType)) == CeESSR_e_KeyCrnkAlgo)))
    {
        /* Transition: '<S165>:19' */
        ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_InitEngSpin_2;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'InitEngSpin_2': '<S165>:6' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

        /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinEnt' */
        /* Event: '<S165>:80' */
        ESSR_ac_InitEngSpinEnt(ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                               ESSR_ac_B.TmpSignalConversionAtVeESMR_P_d,
                               rtb_Sum_k0,
                               ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d);

        /* End of Outputs for SubSystem: '<S559>/InitEngSpinEnt' */

        /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinDur' */
        /* RelationalOperator: '<S1022>/Equal2' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr'
         */
        /* Event: '<S165>:81' */
        rtb_Equal2 = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

        /* Switch: '<S1078>/Switch1' incorporates:
         *  Constant: '<S1033>/Constant Value5'
         *  UnitDelay: '<S1078>/Unit Delay'
         */
        if (rtb_Equal2)
        {
            rtb_Sum_k0 = 0.0F;
        }
        else
        {
            rtb_Sum_k0 = ESSR_ac_DW.UnitDelay_DSTATE_iu;
        }

        /* Sum: '<S1033>/Sum' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitSpinScaler'
         *  Product: '<S1022>/Product'
         */
        rtb_Sum_k0 += HeESSR_t_MedTEB_dT * VeESSR_k_StrtTypInitSpinScaler_DS;

        /* Outputs for Atomic SubSystem: '<S1033>/Limiter' */
        /* Switch: '<S1077>/Switch1' incorporates:
         *  DataStoreRead: '<S1033>/Dsr_StrtTypInitSpinEndPnt'
         *  RelationalOperator: '<S1077>/Relational Operator'
         */
        if (VeESSR_Cnt_StrtTypInitSpinEndPnt_DS < rtb_Sum_k0)
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;
        }
        else
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = rtb_Sum_k0;
        }

        /* Switch: '<S1077>/Switch' incorporates:
         *  Constant: '<S1033>/Constant Value1'
         *  RelationalOperator: '<S1077>/Relational Operator1'
         */
        if (rtb_Product_in > 0.0F)
        {
            /* Switch: '<S1077>/Switch' */
            VeESSR_Cnt_InitSpnStepPt = rtb_Product_in;
        }
        else
        {
            /* Switch: '<S1077>/Switch' */
            VeESSR_Cnt_InitSpnStepPt = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1033>/Limiter' */

        /* RelationalOperator: '<S1034>/Greater  Than2' incorporates:
         *  DataStoreRead: '<S1034>/Dsr_StrtTypInitSpinEndPnt'
         */
        VeESSR_b_InitSpnTmrCmplt = (VeESSR_Cnt_InitSpnStepPt >=
            VeESSR_Cnt_StrtTypInitSpinEndPnt_DS);

        /* Outputs for Atomic SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */
        /* Switch: '<S1058>/Switch' */
        if (rtb_Equal2)
        {
            /* Switch: '<S1058>/Switch' incorporates:
             *  Constant: '<S1029>/Constant Value4'
             */
            rtb_Switch1_oim = 0.0F;
        }
        else
        {
            /* Switch: '<S1058>/Switch' incorporates:
             *  Constant: '<S1029>/Cnvrt2Deg'
             *  Constant: '<S1057>/Calib'
             *  Product: '<S1058>/Division'
             *  Product: '<S1058>/Multiplication'
             *  Sum: '<S1058>/Sum//Sub'
             *  UnitDelay: '<S1058>/Unit Delay'
             */
            rtb_Switch1_oim = ((HeESSR_t_MedTEB_dT / 0.166666672F) *
                               ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I) +
                ESSR_ac_DW.UnitDelay_DSTATE_e;
        }

        /* Outputs for Atomic SubSystem: '<S1058>/Limiter' */
        /* Switch: '<S1061>/Switch1' incorporates:
         *  Constant: '<S1029>/Constant Value1'
         *  RelationalOperator: '<S1061>/Relational Operator'
         */
        if (999.0F < rtb_Switch1_oim)
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = 999.0F;
        }
        else
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = rtb_Switch1_oim;
        }

        /* Switch: '<S1061>/Switch' incorporates:
         *  Constant: '<S1029>/Constant Value'
         *  RelationalOperator: '<S1061>/Relational Operator1'
         */
        if (rtb_Product_in <= 0.0F)
        {
            /* Switch: '<S1061>/Switch' */
            rtb_Product_in = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1058>/Limiter' */

        /* Update for UnitDelay: '<S1058>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_e = rtb_Product_in;

        /* End of Outputs for SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */

        /* Switch: '<S1070>/Switch1' incorporates:
         *  Constant: '<S1029>/Constant Value3'
         *  DataStoreRead: '<S1029>/Dsr_STMTmr3'
         *  Product: '<S1060>/Division'
         *  Sum: '<S1029>/Subtraction'
         */
        rtb_Switch1_oim = (ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi -
                           VeESSR_phi_InitEngAng720_DS) / 720.0F;

        /* Logic: '<S1029>/AND' incorporates:
         *  Constant: '<S1029>/Constant Value3'
         *  DataStoreRead: '<S1029>/Dsr_STMTmr1'
         *  Product: '<S1060>/Multiplication'
         *  RelationalOperator: '<S1029>/Greater  Than1'
         *  RelationalOperator: '<S1029>/Greater  Than2'
         *  Rounding: '<S1060>/Floor'
         *  Sum: '<S1060>/Subtraction'
         */
        VeESSR_b_InitSpnEngMvmntDet = ((rtb_Product_in >
            VeESSR_phi_StrtTypInitSpinBrkAng_DS) || (((rtb_Switch1_oim - roundf
            (rtb_Switch1_oim)) * 720.0F) > VeESSR_phi_StrtTypInitSpinBrkAng_DS));

        /* Switch: '<S1044>/Switch1' incorporates:
         *  Logic: '<S1022>/Logical'
         */
        rtb_Switch1_au = ((VeESSR_b_InitSpnTmrCmplt) ||
                          (VeESSR_b_InitSpnEngMvmntDet));

        /* RelationalOperator: '<S1022>/Greater  Than1' incorporates:
         *  Constant: '<S1050>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr1'
         */
        rtb_GreaterThan1_f = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmInitSpin);

        /* Logic: '<S1022>/Logical Operator' incorporates:
         *  Logic: '<S1022>/Logical Operator1'
         */
        rtb_LogicalOperator_h = ((!rtb_Switch1_au) && rtb_GreaterThan1_f);

        /* Switch: '<S1022>/Switch3' incorporates:
         *  DataStoreRead: '<S1022>/Data Store Read'
         *  DataStoreRead: '<S1022>/Data Store Read1'
         *  DataStoreWrite: '<S1022>/Data Store Write'
         *  DataStoreWrite: '<S1022>/Data Store Write1'
         *  S-Function (sfix_bitop): '<S1026>/FixPt Bitwise Operator1'
         *  S-Function (sfix_bitop): '<S1027>/FixPt Bitwise Operator1'
         *  Switch: '<S1022>/Switch1'
         */
        if (rtb_LogicalOperator_h)
        {
            ESSR_ac_DW.NeESSR_g_StrtStpFailRsn |= 4U;
            VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS | 1U;
        }

        /* Outputs for Atomic SubSystem: '<S1030>/Protected Division' */
        /* Switch: '<S1069>/Switch1' incorporates:
         *  Constant: '<S1063>/Calib'
         *  Constant: '<S1069>/Constant Value'
         *  Constant: '<S1069>/Constant Value1'
         *  Constant: '<S1069>/Constant Value2'
         *  Constant: '<S1069>/Constant Value3'
         *  DataStoreRead: '<S1030>/Dsr_STMTmr2'
         *  Logic: '<S1069>/AND'
         *  RelationalOperator: '<S1069>/Greater Than or Equal '
         *  RelationalOperator: '<S1069>/Greater Than or Equal 1'
         *  RelationalOperator: '<S1069>/Not Equal'
         *  RelationalOperator: '<S1069>/Not Equal1'
         *  Switch: '<S1069>/Switch2'
         *  Switch: '<S1069>/Switch3'
         */
        if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT != 0.0F))
        {
            /* Switch: '<S1069>/Switch1' incorporates:
             *  Product: '<S1069>/Division'
             */
            rtb_Switch1_oim = VeESSR_t_STMTmr_DS / HeESSR_t_MedTEB_dT;
        }
        else if (VeESSR_t_STMTmr_DS > 0.0F)
        {
            /* Switch: '<S1069>/Switch2' incorporates:
             *  Constant: '<S1069>/MAXFLOAT'
             *  Switch: '<S1069>/Switch1'
             */
            rtb_Switch1_oim = 3.402823466E+38F;
        }
        else if (VeESSR_t_STMTmr_DS < 0.0F)
        {
            /* Switch: '<S1069>/Switch3' incorporates:
             *  Constant: '<S1069>/MINFLOAT'
             *  Switch: '<S1069>/Switch1'
             *  Switch: '<S1069>/Switch2'
             */
            rtb_Switch1_oim = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1069>/Switch1' incorporates:
             *  Constant: '<S1069>/Constant Value4'
             *  Switch: '<S1069>/Switch2'
             *  Switch: '<S1069>/Switch3'
             */
            rtb_Switch1_oim = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1030>/Protected Division' */

        /* Sum: '<S1030>/Summation2' incorporates:
         *  Constant: '<S1030>/Constant Value'
         *  Gain: '<S1030>/Gain'
         *  Lookup_n-D: '<S1066>/Vector'
         *  Lookup_n-D: '<S1068>/Vector'
         *  MinMax: '<S1030>/MinMax'
         *  Product: '<S1030>/Product1'
         *  Switch: '<S1069>/Switch1'
         */
        VeESSR_M_InitSpinEngFricEngStrtTorq = (fmaxf(-VeESSR_M_EngTrqAct_Lmtd,
            0.0F) * look1_iflf_binlcapw(rtb_Switch1_oim, ((const float32 *)
            &(KxESSR_K_InitSpinEngStrtTorqGain[0])), ((const float32 *)
            &(KtESSR_K_InitSpinEngStrtTorqGain[0])), 4U)) + look1_iflf_binlcapw
            (rtb_Switch1_oim, ((const float32 *)
                               &(KxESSR_M_InitSpinEngStrtTorqOffset[0])), ((
               const float32 *)&(KtESSR_M_InitSpinEngStrtTorqOffset[0])), 4U);

        /* Abs: '<S1030>/Abs' */
        VeESSR_M_InitSpinEngPulseEngStrtTorq = fabsf
            (ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E);

        /* Lookup_n-D: '<S1067>/Vector' incorporates:
         *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
         */
        VeESSR_M_InitSpinECTEngStrtTorq = look1_iflf_binlcapw
            (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const float32 *)
              &(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((const float32 *)
              &(KtESSR_M_ECTAddtlEngStrtTorq[0])), 6U);

        /* Sum: '<S1030>/Summation1' */
        VeESSR_M_InitSpinEngStrtTorqRaw = (VeESSR_M_InitSpinEngFricEngStrtTorq +
            VeESSR_M_InitSpinEngPulseEngStrtTorq) +
            VeESSR_M_InitSpinECTEngStrtTorq;

        /* Outputs for Atomic SubSystem: '<S1030>/GradientLimiter' */
        /* Product: '<S1032>/Product' incorporates:
         *  UnitDelay: '<S1062>/Unit Delay'
         */
        rtb_Product_in = ESSR_ac_DW.UnitDelay_DSTATE_h;

        /* Sum: '<S1062>/Sum2' */
        rtb_Switch1_oim = VeESSR_M_InitSpinEngStrtTorqRaw - rtb_Product_in;

        /* Outputs for Atomic SubSystem: '<S1062>/Limiter' */
        /* Switch: '<S1070>/Switch1' incorporates:
         *  Constant: '<S1065>/Calib'
         *  RelationalOperator: '<S1070>/Relational Operator'
         */
        if (KeESSR_dM_InitSpinEngStrtTorqLU < rtb_Switch1_oim)
        {
            /* Switch: '<S1070>/Switch1' */
            rtb_Switch1_oim = KeESSR_dM_InitSpinEngStrtTorqLU;
        }

        /* Switch: '<S1070>/Switch' incorporates:
         *  Constant: '<S1064>/Calib'
         *  RelationalOperator: '<S1070>/Relational Operator1'
         */
        if (rtb_Switch1_oim <= KeESSR_dM_InitSpinEngStrtTorqLD)
        {
            rtb_Switch1_oim = KeESSR_dM_InitSpinEngStrtTorqLD;
        }

        /* End of Outputs for SubSystem: '<S1062>/Limiter' */

        /* Sum: '<S1062>/Sum3' */
        VeESSR_M_InitSpinEngStrtTorqLmtd = rtb_Switch1_oim + rtb_Product_in;

        /* Update for UnitDelay: '<S1062>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_h = VeESSR_M_InitSpinEngStrtTorqLmtd;

        /* End of Outputs for SubSystem: '<S1030>/GradientLimiter' */

        /* Switch: '<S1022>/Switch7' incorporates:
         *  Constant: '<S1040>/Calib'
         *  DataStoreWrite: '<S1022>/Data Store Write3'
         */
        if (!HeESSR_b_EngStrtTorq)
        {
            VeESSR_M_EngStrtTorq_DS = VeESSR_M_InitSpinEngStrtTorqLmtd;
        }

        /* Logic: '<S1022>/Logical2' incorporates:
         *  Constant: '<S1036>/Constant'
         *  Constant: '<S1037>/Constant'
         *  Constant: '<S1038>/Calib'
         *  Constant: '<S1039>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
         *  Logic: '<S1022>/Logical1'
         *  Logic: '<S1022>/Logical3'
         *  Logic: '<S1022>/Logical6'
         *  RelationalOperator: '<S1022>/Comparison1'
         *  RelationalOperator: '<S1022>/Comparison4'
         */
        rtb_Logical2_eb = ((((uint32)VeESSR_e_EngStrtProfType_DS) ==
                            CeESSR_e_KeyCrnkAlgo) || (((uint32)
                             VeESSR_e_EngStrtProfType_DS) == CeESSR_e_LowPwrAlgo));
        rtb_Logical2_eb = (((HeESSR_b_12vStrtrEquipped) ||
                            ((HeESSR_b_BumpStrtEquipped) && rtb_Logical2_eb)) &&
                           rtb_Logical2_eb);

        /* MinMax: '<S1032>/MinMax' incorporates:
         *  DataStoreRead: '<S1032>/Dsr_StrtTypInitSpinEndPnt'
         *  SignalConversion generated from: '<S1075>/Vector'
         */
        rtb_MinMax_if[0] = VeESSR_Cnt_InitSpnStepPt;
        rtb_MinMax_if[1] = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;

        /* Sum: '<S1032>/Sum' */
        rtb_Switch1_oim = VeESSR_M_EngTrqAct_Lmtd - VeESSR_M_SpnUpAddtlTorq;
        for (iU = 0; iU < 2; iU++)
        {
            rtb_MinMax_if[iU] = fmaxf(VeESSR_M_TiEstMin, look1_iflf_binlcapw
                (rtb_MinMax_if[iU], ((const float32 *)&(KxESSR_K_InitSpinTiProf
                [0])), ((const float32 *)&(KtESSR_K_InitSpinTiProf[0])), 6U) *
                rtb_Switch1_oim);
        }

        /* Switch: '<S1022>/Switch2' incorporates:
         *  Constant: '<S1022>/Constant Value1'
         *  DataStoreWrite: '<S1022>/Dsw_InputTorqEst'
         *  Lookup_n-D: '<S1075>/Vector'
         *  MinMax: '<S1032>/MinMax'
         *  Product: '<S1032>/Product1'
         */
        if (rtb_Logical2_eb)
        {
            VeESSR_M_EngTorqEst_DS = 0.0F;
        }
        else
        {
            VeESSR_M_EngTorqEst_DS = rtb_MinMax_if[0];
        }

        /* DataStoreWrite: '<S1022>/Dsw_STMTmr' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr'
         *  Sum: '<S1022>/Summation'
         */
        VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

        /* Switch: '<S1044>/Switch1' incorporates:
         *  Constant: '<S1049>/Calib'
         */
        if (KeESSR_b_InitSpnTmrChkOnly)
        {
            /* Switch: '<S1044>/Switch1' */
            rtb_Switch1_au = VeESSR_b_InitSpnTmrCmplt;
        }

        /* SignalConversion generated from: '<S1022>/Variant Source' incorporates:
         *  Logic: '<S1054>/Logical1'
         *  Logic: '<S1054>/Logical2'
         *  Logic: '<S1054>/Logical3'
         *  Logic: '<S1054>/Logical4'
         *  RelationalOperator: '<S1054>/Comparison1'
         *  RelationalOperator: '<S1054>/Comparison6'
         *  RelationalOperator: '<S1054>/Comparison7'
         *  RelationalOperator: '<S1054>/Comparison8'
         */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

        /* Switch: '<S1022>/Switch5' incorporates:
         *  Constant: '<S1022>/FALSE Constant1'
         */
        rtb_Switch5_hb = false;

#else

        /* Logic: '<S1054>/Logical4' incorporates:
         *  Constant: '<S1085>/Constant'
         *  Constant: '<S1086>/Constant'
         *  Constant: '<S1087>/Constant'
         *  Constant: '<S1088>/Constant'
         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
         *  Logic: '<S1054>/Logical1'
         *  Logic: '<S1054>/Logical2'
         *  Logic: '<S1054>/Logical3'
         *  RelationalOperator: '<S1022>/Comparison4'
         *  RelationalOperator: '<S1054>/Comparison1'
         *  RelationalOperator: '<S1054>/Comparison6'
         *  RelationalOperator: '<S1054>/Comparison7'
         *  RelationalOperator: '<S1054>/Comparison8'
         */
        VeESSR_b_InitSpin_48VP2CoastDown = (((((((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMStrtAlgo) || (((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_ImplStrtAlgo)) || (((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo)) &&
            (VeESSR_b_EMErlyExitLmp)) || ((((uint32)VeESSR_e_EngStrtProfType_DS)
            == CeESSR_e_CltchStrtAlgo) && (VeESSR_b_ClthErlyExitLmp)));

        /* Switch: '<S1022>/Switch5' */
        rtb_Switch5_hb = VeESSR_b_InitSpin_48VP2CoastDown;

#endif

        /* Switch: '<S1022>/Switch5' */
        if (!VeESSR_b_StrtTypChngDisbl)
        {
            /* Switch: '<S1022>/Switch5' incorporates:
             *  Constant: '<S1035>/Constant'
             *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
             *  Logic: '<S1022>/Logical Operator4'
             *  Logic: '<S1022>/Logical Operator5'
             *  RelationalOperator: '<S1022>/Comparison2'
             *  RelationalOperator: '<S1022>/Comparison4'
             */
            rtb_Switch5_hb = (((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B) ||
                               ((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d) &&
                                (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                 CeESSR_e_KeyCrnkAlgo))) ||
                              (VeESSR_b_ErlyExitLmp));
        }

        /* Logic: '<S1022>/Logical Operator3' incorporates:
         *  Constant: '<S1041>/Calib'
         *  Constant: '<S1045>/Calib'
         *  Constant: '<S1046>/Calib'
         *  Constant: '<S1047>/Calib'
         *  Constant: '<S1048>/Calib'
         *  DataStoreRead: '<S1022>/Data Store Read18'
         *  DataStoreRead: '<S1022>/Data Store Read19'
         *  Logic: '<S1022>/Logical Operator2'
         *  Logic: '<S1022>/Logical5'
         *  Logic: '<S1022>/Logical8'
         *  Logic: '<S1022>/Logical9'
         *  RelationalOperator: '<S1022>/Greater  Than11'
         *  RelationalOperator: '<S1022>/Greater  Than15'
         */
        VeESSR_b_InitSpin_CoastDownTrig = ((rtb_Switch5_hb ||
            rtb_LogicalOperator_h) && ((((KeESSR_b_EnblFtrBackupStrt) &&
            (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
             KeESSR_Cnt_BackupStrtMaxAttmpts)) || ((KeESSR_b_EnblFtrBumpStrt) &&
            (VeESSR_Cnt_BumpStrtAttmptCntr_DS < KeESSR_Cnt_BumpStrtMaxAttmpts)))
            || (HeESSR_b_LimphomeEnbl)));

        /* If: '<S1022>/If1' */
        if (rtb_Switch1_au)
        {
            /* Outputs for IfAction SubSystem: '<S1022>/NormExit' incorporates:
             *  ActionPort: '<S1052>/Action Port'
             */
            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S1082>/Constant'
             *  Merge: '<S1022>/Merge1'
             *  SignalConversion generated from: '<S1052>/ESSTrig'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_EngBrkawayAch;

            /* End of Outputs for SubSystem: '<S1022>/NormExit' */
        }
        else if (VeESSR_b_InitSpin_CoastDownTrig)
        {
            /* Outputs for IfAction SubSystem: '<S1022>/If Action Subsystem' incorporates:
             *  ActionPort: '<S1043>/Action Port'
             */
            /* Switch: '<S1043>/Switch' incorporates:
             *  Constant: '<S1080>/Constant'
             *  Constant: '<S1081>/Constant'
             *  DataStoreRead: '<S1043>/Data Store Read5'
             *  DataStoreWrite: '<S1043>/Dsw_StrtStpFailDTC'
             */
            if (VeESSR_b_BSGStrtFailed_DS)
            {
                VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;
            }
            else
            {
                VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
            }

            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S1079>/Constant'
             *  Merge: '<S1022>/Merge1'
             *  SignalConversion generated from: '<S1043>/ESSTrig'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

            /* End of Outputs for SubSystem: '<S1022>/If Action Subsystem' */
        }
        else
        {
            if (rtb_GreaterThan1_f)
            {
                /* Outputs for IfAction SubSystem: '<S1022>/OffFail' incorporates:
                 *  ActionPort: '<S1053>/Action Port'
                 */
                /* DataStoreWrite: '<S1053>/Dsw_StrtStpFailDTC' incorporates:
                 *  Constant: '<S1084>/Constant'
                 */
                VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;

                /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                 *  Constant: '<S1083>/Constant'
                 *  Merge: '<S1022>/Merge1'
                 *  SignalConversion generated from: '<S1053>/ESSTrig'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

                /* End of Outputs for SubSystem: '<S1022>/OffFail' */
            }
        }

        /* Switch: '<S1022>/Switch4' incorporates:
         *  Constant: '<S1022>/Constant Value2'
         *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType2'
         *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType6'
         *  DataStoreWrite: '<S1022>/Dsw_StrtStpFailDTC1'
         *  Logic: '<S1022>/Logical21'
         *  Logic: '<S1022>/Logical7'
         *  RelationalOperator: '<S1022>/Comparison'
         *  S-Function (sfix_bitop): '<S1022>/Bitwise Operator'
         *  S-Function (sfix_bitop): '<S1028>/FixPt Bitwise Operator1'
         */
        if (((VeESSR_b_InitSpin_CoastDownTrig) || rtb_GreaterThan1_f) &&
                ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16U) > 0U))
        {
            VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 16U;
        }

        /* Switch: '<S1071>/Switch1' incorporates:
         *  Constant: '<S1072>/Calib'
         *  DataStoreWrite: '<S1031>/Dsw_InitEngAng720'
         *  RelationalOperator: '<S1031>/Equal1'
         */
        if (VeESSR_Cnt_InitSpnStepPt <= KeESSR_t_InitSpnInitAngTm)
        {
            VeESSR_phi_InitEngAng720_DS =
                ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi;
        }

        /* Sum: '<S1032>/Subtract' incorporates:
         *  Constant: '<S1074>/Calib'
         *  DataStoreRead: '<S1032>/Dsr_NiProfGenNiDMax'
         *  DataStoreWrite: '<S1032>/Data Store Write'
         *  Product: '<S1032>/Product'
         */
        ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = rtb_MinMax_if[1] -
            (VeESSR_dn_StrtTypNiDotMax_DS * KeESSR_r_NiDtoTiMargin);

        /* DataStoreWrite: '<S1022>/Dsw_InputAcceltnProf1' */
        VeESSR_dn_InputAcceltnProf_DS =
            ESSR_ac_B.VariantMerge_For_Variant_Source;

        /* RelationalOperator: '<S1022>/Equal1' incorporates:
         *  Constant: '<S1022>/Constant Value'
         *  DataStoreRead: '<S1022>/Data Store Read5'
         *  DataStoreWrite: '<S1022>/Data Store Write5'
         */
        VeESSR_b_BSGStrtFailed_DS = (VeESSR_g_BSGStrtFailRsn_DS != 0U);

        /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqImmed' incorporates:
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitImmedTorq'
         */
        VeESSR_M_EngTrqReqImmed_DS = VeESSR_M_StrtTypInitImmedTorq_DS;

        /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqPrdtd1' incorporates:
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitPredTorq'
         */
        VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

        /* Switch: '<S1078>/Switch3' */
        if (rtb_Equal2)
        {
            /* Update for UnitDelay: '<S1078>/Unit Delay' incorporates:
             *  Constant: '<S1033>/Constant Value5'
             */
            ESSR_ac_DW.UnitDelay_DSTATE_iu = 0.0F;
        }
        else
        {
            /* Update for UnitDelay: '<S1078>/Unit Delay' */
            ESSR_ac_DW.UnitDelay_DSTATE_iu = rtb_Sum_k0;
        }

        /* End of Outputs for SubSystem: '<S559>/InitEngSpinDur' */
    }
    else if (*Dsr_PFSRunReq)
    {
        /* Transition: '<S165>:139' */
        ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_StartEngPFS;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'StartEngPFS': '<S165>:138' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

        /* Outputs for Function Call SubSystem: '<S570>/StartEngPFS_Ent' */
        /* DataStoreWrite: '<S2077>/Dsw_EngTrqReqPrdtd1' */
        /* Event: '<S165>:141' */
        VeESSR_M_EngTrqReqPrdtd_DS = ESSR_ac_B.TmpSignalConversionAtVeETQR_M_E;

        /* DataStoreWrite: '<S2077>/Dsw_InputAcceltnProf' incorporates:
         *  Constant: '<S2077>/Constant Value1'
         */
        VeESSR_phi_CombstDelay_DS = 0.0F;

        /* Switch: '<S2077>/Switch3' incorporates:
         *  Constant: '<S2077>/Constant Value3'
         *  Constant: '<S2221>/Calib'
         *  DataStoreWrite: '<S2077>/Data Store Write1'
         */
        if (!HeESSR_b_EngStrtTorq)
        {
            VeESSR_M_EngStrtTorq_DS = 0.0F;
        }

        /* End of Switch: '<S2077>/Switch3' */

        /* Switch: '<S2077>/Switch2' incorporates:
         *  Constant: '<S2220>/Calib'
         *  Constant: '<S2227>/Calib'
         *  DataStoreWrite: '<S2077>/Dsw_AEMDMtrBGain'
         */
        if (HeESSR_b_AEMDMtrBGain)
        {
            VeESSR_scl_AEMDMtrBGain_DS = KeESSR_scl_AEMDMtrBGain_StrtEngAutoSt;
        }

        /* End of Switch: '<S2077>/Switch2' */

        /* Switch: '<S2077>/Switch1' incorporates:
         *  Constant: '<S2218>/Constant'
         *  Constant: '<S2222>/Calib'
         *  DataStoreWrite: '<S2077>/Dsw_EngCntrlMode_DS'
         */
        if (HeESSR_b_StrtEngSpeedMdECM)
        {
            VeESSR_e_EngCntrlMode_DS = CeTRAR_e_SpeedMode;
        }

        /* End of Switch: '<S2077>/Switch1' */
        /* End of Outputs for SubSystem: '<S570>/StartEngPFS_Ent' */
        (void)Rte_Read_VeBPCR_T_BatModTmp_Value(&rtb_Switch1_oim);

        /* Outputs for Function Call SubSystem: '<S570>/StartEngPFS_Ent' */
        /* DataStoreWrite: '<S2077>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
         *  Constant: '<S2223>/Calib'
         *  Inport: '<Root>/VeBPCR_T_BatModTmp'
         */
        VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

        /* DataStoreWrite: '<S2077>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
         *  Constant: '<S2224>/Calib'
         */
        VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

        /* DataStoreWrite: '<S2077>/Dsw_EngStartStopSt' incorporates:
         *  Constant: '<S2215>/Constant'
         */
        VeESSR_e_EngStartStopSt_DS = CeESSR_e_StartEngPFSSt;

        /* DataStoreWrite: '<S2077>/Dsw_EngStrtStpMd2' incorporates:
         *  Constant: '<S2219>/Constant'
         */
        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_EnableFuel;

        /* DataStoreWrite: '<S2077>/Dsw_EngStrtType1' incorporates:
         *  Constant: '<S2217>/Constant'
         */
        VeESSR_e_TCM_StartStopType_DS = CeESSR_e_NormalStart;

        /* DataStoreWrite: '<S2077>/Dsw_EngTrqRespType' incorporates:
         *  DataStoreRead: '<S2077>/VeESSR_e_StrtStpTypEngTorqRespType_DS'
         */
        VeESSR_e_EngTrqRespType_DS = VeESSR_e_StrtStpTypEngTorqRespType_DS;

        /* DataStoreWrite: '<S2077>/Dsw_InputSpeedProfile1' incorporates:
         *  Constant: '<S2226>/Calib'
         */
        VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

        /* DataStoreWrite: '<S2077>/Dsw_TransFldPmpSel' incorporates:
         *  Constant: '<S2225>/Calib'
         */
        VeESSR_e_TransFldPmpSel_DS = KeESSR_e_TransFldPmpSelStartEngPFSSt;

        /* End of Outputs for SubSystem: '<S570>/StartEngPFS_Ent' */

        /* Outputs for Function Call SubSystem: '<S570>/StartEngPFS_Dur' */
        /* Event: '<S165>:142' */
        ESSR_ac_StartEngPFS_Dur(ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                                VeESSR_n_OptInputSpd_Local,
                                VeESSR_M_EngTrqAct_Lmtd,
                                VeESSR_M_EngStrtTorqSnsd,
                                ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                                ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I,
                                rtb_Switch1_oim,
                                ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B,
                                ESSR_ac_B.TmpSignalConversionAtVeENGR_e_E,
                                VeESSR_n_TransInSpdFlt,
                                ESSR_ac_B.TmpSignalConversionAtVeOHSR_n_I,
                                ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                                VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                                VeESSR_M_TiEstMin,
                                ESSR_ac_B.TmpSignalConversionAtVeENGR_b_P,
                                ESSR_ac_B.TmpSignalConversionAtVeETQR_M_P,
                                ESSR_ac_B.TmpSignalConversionAtVeOITR_M_I,
                                &ESSR_ac_DW.StartEngPFS_Dur,
                                &ESSR_ac_PrevZCX.StartEngPFS_Dur,
                                &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

        /* End of Outputs for SubSystem: '<S570>/StartEngPFS_Dur' */
    }
    else if (*Dsr_PFSRunReq1)
    {
        /* Transition: '<S165>:217' */
        ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_StartEngP1fLmt;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'StartEngP1fLmt': '<S165>:216' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */
        /* Event: '<S165>:218' */
        /* Event: '<S165>:219' */
#if Rte_SysCon_Variant_ESSR_Limphome

        /* Outputs for Function Call SubSystem: '<S553>/StartEngP1fLmt_Ent' */
        /* DataStoreWrite: '<S574>/Dsw_EngTrqReqImmed' */
        VeESSR_M_EngTrqReqImmed_DS = ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o;

        /* DataStoreWrite: '<S574>/Dsw_EngTrqReqPrdtd1' */
        VeESSR_M_EngTrqReqPrdtd_DS = ESSR_ac_B.TmpSignalConversionAtVeETQR_M_E;

        /* DataStoreWrite: '<S574>/Dsw_InputSpeedProfile' */
        VeESSR_n_InputSpeedProfile_DS = VeESSR_n_TransInSpdFlt;

        /* DataStoreWrite: '<S574>/Dsw_InputAcceltnProf1' incorporates:
         *  Constant: '<S574>/Constant Value'
         */
        VeESSR_dn_InputAcceltnProf_DS = 0.0F;

        /* DataStoreWrite: '<S574>/Dsw_InputAcceltnProf' incorporates:
         *  Constant: '<S574>/Constant Value1'
         */
        VeESSR_phi_CombstDelay_DS = 0.0F;

        /* Switch: '<S574>/Switch2' incorporates:
         *  Constant: '<S662>/Calib'
         *  Constant: '<S667>/Calib'
         *  DataStoreWrite: '<S574>/Dsw_AEMDMtrBGain'
         */
        if (HeESSR_b_AEMDMtrBGain)
        {
            VeESSR_scl_AEMDMtrBGain_DS = KeESSR_scl_AEMDMtrBGain_StrtEngAutoSt;
        }

        /* End of Switch: '<S574>/Switch2' */

        /* DataStoreWrite: '<S574>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
         *  Constant: '<S663>/Calib'
         */
        VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

        /* DataStoreWrite: '<S574>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
         *  Constant: '<S664>/Calib'
         */
        VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

        /* DataStoreWrite: '<S574>/Dsw_EngCntrlMode_DS' incorporates:
         *  Constant: '<S659>/Constant'
         */
        VeESSR_e_EngCntrlMode_DS = CeTRAR_e_SpeedMode;

        /* DataStoreWrite: '<S574>/Dsw_EngRestartReq' incorporates:
         *  Constant: '<S574>/FALSE Constant'
         */
        VeESSR_b_LmtP1fRestartReq_DS = false;

        /* DataStoreWrite: '<S574>/Dsw_EngStartStopSt' incorporates:
         *  Constant: '<S656>/Constant'
         */
        VeESSR_e_EngStartStopSt_DS = CeESSR_e_StrtEngOnlyChngMind;

        /* DataStoreWrite: '<S574>/Dsw_EngStrtStpMd2' incorporates:
         *  Constant: '<S660>/Constant'
         */
        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_EnableFuel;

        /* DataStoreWrite: '<S574>/Dsw_EngStrtType1' incorporates:
         *  Constant: '<S658>/Constant'
         */
        VeESSR_e_TCM_StartStopType_DS = CeESSR_e_NormalStart;

        /* DataStoreWrite: '<S574>/Dsw_EngStrtType2' incorporates:
         *  Constant: '<S661>/Constant'
         */
        VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Cranking;

        /* DataStoreWrite: '<S574>/Dsw_EngTrqRespType' incorporates:
         *  Constant: '<S665>/Calib'
         */
        VeESSR_e_EngTrqRespType_DS = KeESSR_e_EngTrqRespTypP1fLmt;

        /* DataStoreWrite: '<S574>/Dsw_InputSpeedProfile1' incorporates:
         *  Constant: '<S666>/Calib'
         */
        VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

        /* DataStoreWrite: '<S574>/Dsw_StrtStpFailDTC' incorporates:
         *  Constant: '<S657>/Constant'
         */
        VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

        /* End of Outputs for SubSystem: '<S553>/StartEngP1fLmt_Ent' */

        /* Outputs for Function Call SubSystem: '<S553>/StartEngP1fLmt_Dur' */
        ESSR_ac_StartEngP1fLmt_Dur(VeESSR_M_EngStrtTorqSnsd,
            ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
            ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
            ESSR_ac_B.TmpSignalConversionAtVeESSR_M_d,
            ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
            ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p,
            ESSR_ac_B.TmpSignalConversionAtEngineLoss,
            ESSR_ac_B.TmpSignalConversionAtVeENGR_e_E, VeESSR_n_TransInSpdFlt,
            ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I, VeESSR_b_ErlyExitLmp,
            VeESSR_b_LwrThresLmp, VeESSR_M_TiEstMin,
            &ESSR_ac_DW.StartEngP1fLmt_Dur, &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

        /* End of Outputs for SubSystem: '<S553>/StartEngP1fLmt_Dur' */
#endif

    }
    else if (*Dsr_EngRestartReq)
    {
        /* Transition: '<S165>:42' */
        ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_RestartPrep;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'RestartPrep': '<S165>:17' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

        /* Outputs for Function Call SubSystem: '<S561>/RestartPrepEnt' */
        /* Switch: '<S1174>/Switch1' incorporates:
         *  Constant: '<S1174>/Constant Value1'
         *  Constant: '<S1233>/Calib'
         *  DataStoreWrite: '<S1174>/Data Store Write1'
         */
        /* Event: '<S165>:78' */
        if (!HeESSR_b_EngStrtTorq)
        {
            VeESSR_M_EngStrtTorq_DS = 0.0F;
        }

        /* End of Switch: '<S1174>/Switch1' */

        /* DataStoreWrite: '<S1174>/Dsw_Ni1stFlt' incorporates:
         *  DataStoreRead: '<S1174>/Dsr_InputSpeedProfile1'
         */
        VeESSR_n_Ni1stFlt_DS = VeESSR_n_InputSpeedProfile_DS;

        /* DataStoreWrite: '<S1174>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
         *  Constant: '<S1234>/Calib'
         */
        VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

        /* DataStoreWrite: '<S1174>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
         *  Constant: '<S1235>/Calib'
         */
        VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

        /* DataStoreWrite: '<S1174>/Dsw_EngRestartReq' incorporates:
         *  Constant: '<S1174>/FALSE Constant'
         */
        VeESSR_b_EngRestartReq_DS = false;

        /* DataStoreWrite: '<S1174>/Dsw_EngStartStopSt' incorporates:
         *  Constant: '<S1229>/Constant'
         */
        VeESSR_e_EngStartStopSt_DS = CeESSR_e_RestartPrepSt;

        /* DataStoreWrite: '<S1174>/Dsw_EngStrtStpMd2' incorporates:
         *  Constant: '<S1232>/Constant'
         */
        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_StartPending;

        /* DataStoreWrite: '<S1174>/Dsw_EngStrtType1' incorporates:
         *  Constant: '<S1231>/Constant'
         */
        VeESSR_e_TCM_StartStopType_DS = CeESSR_e_NormalStart;

        /* DataStoreWrite: '<S1174>/Dsw_EngTrqRespType' incorporates:
         *  DataStoreRead: '<S1174>/VeESSR_e_StrtStpTypEngTorqRespType_DS'
         */
        VeESSR_e_EngTrqRespType_DS = VeESSR_e_StrtStpTypEngTorqRespType_DS;

        /* DataStoreWrite: '<S1174>/Dsw_InhibitShiftToMode' incorporates:
         *  Constant: '<S1236>/Calib'
         */
        VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtRestartPrepSt;

        /* DataStoreWrite: '<S1174>/Dsw_InputSpeedProfile1' incorporates:
         *  Constant: '<S1238>/Calib'
         */
        VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

        /* DataStoreWrite: '<S1174>/Dsw_StrtStpFailDTC' incorporates:
         *  Constant: '<S1230>/Constant'
         */
        VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

        /* DataStoreWrite: '<S1174>/Dsw_TransFldPmpSel' incorporates:
         *  Constant: '<S1237>/Calib'
         */
        VeESSR_e_TransFldPmpSel_DS = KeESSR_e_TransFldPmpSelRestartPrepSt;

        /* End of Outputs for SubSystem: '<S561>/RestartPrepEnt' */

        /* Outputs for Function Call SubSystem: '<S561>/RestartPrepDur' */
        /* Event: '<S165>:79' */
        ESSR_ac_RestartPrepDur(VeESSR_n_OptInputSpd_Local,
                               VeESSR_M_EngTrqAct_Lmtd, VeESSR_M_SpnUpAddtlTorq,
                               ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                               VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                               VeESSR_M_TiEstMin, &ESSR_ac_DW.RestartPrepDur,
                               &ESSR_ac_PrevZCX.RestartPrepDur);

        /* End of Outputs for SubSystem: '<S561>/RestartPrepDur' */
    }
    else
    {
        /* Transition: '<S165>:22' */
        ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_InitEngSpin_1;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'InitEngSpin_1': '<S165>:10' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

        /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinEnt' */
        /* Event: '<S165>:80' */
        ESSR_ac_InitEngSpinEnt(ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                               ESSR_ac_B.TmpSignalConversionAtVeESMR_P_d,
                               rtb_Sum_k0,
                               ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d);

        /* End of Outputs for SubSystem: '<S559>/InitEngSpinEnt' */

        /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinDur' */
        /* RelationalOperator: '<S1022>/Equal2' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr'
         */
        /* Event: '<S165>:81' */
        rtb_Equal2 = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

        /* Switch: '<S1078>/Switch1' incorporates:
         *  Constant: '<S1033>/Constant Value5'
         *  UnitDelay: '<S1078>/Unit Delay'
         */
        if (rtb_Equal2)
        {
            rtb_Sum_k0 = 0.0F;
        }
        else
        {
            rtb_Sum_k0 = ESSR_ac_DW.UnitDelay_DSTATE_iu;
        }

        /* Sum: '<S1033>/Sum' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitSpinScaler'
         *  Product: '<S1022>/Product'
         */
        rtb_Sum_k0 += HeESSR_t_MedTEB_dT * VeESSR_k_StrtTypInitSpinScaler_DS;

        /* Outputs for Atomic SubSystem: '<S1033>/Limiter' */
        /* Switch: '<S1077>/Switch1' incorporates:
         *  DataStoreRead: '<S1033>/Dsr_StrtTypInitSpinEndPnt'
         *  RelationalOperator: '<S1077>/Relational Operator'
         */
        if (VeESSR_Cnt_StrtTypInitSpinEndPnt_DS < rtb_Sum_k0)
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;
        }
        else
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = rtb_Sum_k0;
        }

        /* Switch: '<S1077>/Switch' incorporates:
         *  Constant: '<S1033>/Constant Value1'
         *  RelationalOperator: '<S1077>/Relational Operator1'
         */
        if (rtb_Product_in > 0.0F)
        {
            /* Switch: '<S1077>/Switch' */
            VeESSR_Cnt_InitSpnStepPt = rtb_Product_in;
        }
        else
        {
            /* Switch: '<S1077>/Switch' */
            VeESSR_Cnt_InitSpnStepPt = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1033>/Limiter' */

        /* RelationalOperator: '<S1034>/Greater  Than2' incorporates:
         *  DataStoreRead: '<S1034>/Dsr_StrtTypInitSpinEndPnt'
         */
        VeESSR_b_InitSpnTmrCmplt = (VeESSR_Cnt_InitSpnStepPt >=
            VeESSR_Cnt_StrtTypInitSpinEndPnt_DS);

        /* Outputs for Atomic SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */
        /* Switch: '<S1058>/Switch' */
        if (rtb_Equal2)
        {
            /* Switch: '<S1058>/Switch' incorporates:
             *  Constant: '<S1029>/Constant Value4'
             */
            rtb_Switch1_oim = 0.0F;
        }
        else
        {
            /* Switch: '<S1058>/Switch' incorporates:
             *  Constant: '<S1029>/Cnvrt2Deg'
             *  Constant: '<S1057>/Calib'
             *  Product: '<S1058>/Division'
             *  Product: '<S1058>/Multiplication'
             *  Sum: '<S1058>/Sum//Sub'
             *  UnitDelay: '<S1058>/Unit Delay'
             */
            rtb_Switch1_oim = ((HeESSR_t_MedTEB_dT / 0.166666672F) *
                               ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I) +
                ESSR_ac_DW.UnitDelay_DSTATE_e;
        }

        /* Outputs for Atomic SubSystem: '<S1058>/Limiter' */
        /* Switch: '<S1061>/Switch1' incorporates:
         *  Constant: '<S1029>/Constant Value1'
         *  RelationalOperator: '<S1061>/Relational Operator'
         */
        if (999.0F < rtb_Switch1_oim)
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = 999.0F;
        }
        else
        {
            /* Product: '<S1032>/Product' */
            rtb_Product_in = rtb_Switch1_oim;
        }

        /* Switch: '<S1061>/Switch' incorporates:
         *  Constant: '<S1029>/Constant Value'
         *  RelationalOperator: '<S1061>/Relational Operator1'
         */
        if (rtb_Product_in <= 0.0F)
        {
            /* Switch: '<S1061>/Switch' */
            rtb_Product_in = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1058>/Limiter' */

        /* Update for UnitDelay: '<S1058>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_e = rtb_Product_in;

        /* End of Outputs for SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */

        /* Switch: '<S1070>/Switch1' incorporates:
         *  Constant: '<S1029>/Constant Value3'
         *  DataStoreRead: '<S1029>/Dsr_STMTmr3'
         *  Product: '<S1060>/Division'
         *  Sum: '<S1029>/Subtraction'
         */
        rtb_Switch1_oim = (ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi -
                           VeESSR_phi_InitEngAng720_DS) / 720.0F;

        /* Logic: '<S1029>/AND' incorporates:
         *  Constant: '<S1029>/Constant Value3'
         *  DataStoreRead: '<S1029>/Dsr_STMTmr1'
         *  Product: '<S1060>/Multiplication'
         *  RelationalOperator: '<S1029>/Greater  Than1'
         *  RelationalOperator: '<S1029>/Greater  Than2'
         *  Rounding: '<S1060>/Floor'
         *  Sum: '<S1060>/Subtraction'
         */
        VeESSR_b_InitSpnEngMvmntDet = ((rtb_Product_in >
            VeESSR_phi_StrtTypInitSpinBrkAng_DS) || (((rtb_Switch1_oim - roundf
            (rtb_Switch1_oim)) * 720.0F) > VeESSR_phi_StrtTypInitSpinBrkAng_DS));

        /* Switch: '<S1044>/Switch1' incorporates:
         *  Logic: '<S1022>/Logical'
         */
        rtb_Switch1_au = ((VeESSR_b_InitSpnTmrCmplt) ||
                          (VeESSR_b_InitSpnEngMvmntDet));

        /* RelationalOperator: '<S1022>/Greater  Than1' incorporates:
         *  Constant: '<S1050>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr1'
         */
        rtb_GreaterThan1_f = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmInitSpin);

        /* Logic: '<S1022>/Logical Operator' incorporates:
         *  Logic: '<S1022>/Logical Operator1'
         */
        rtb_LogicalOperator_h = ((!rtb_Switch1_au) && rtb_GreaterThan1_f);

        /* Switch: '<S1022>/Switch3' incorporates:
         *  DataStoreRead: '<S1022>/Data Store Read'
         *  DataStoreRead: '<S1022>/Data Store Read1'
         *  DataStoreWrite: '<S1022>/Data Store Write'
         *  DataStoreWrite: '<S1022>/Data Store Write1'
         *  S-Function (sfix_bitop): '<S1026>/FixPt Bitwise Operator1'
         *  S-Function (sfix_bitop): '<S1027>/FixPt Bitwise Operator1'
         *  Switch: '<S1022>/Switch1'
         */
        if (rtb_LogicalOperator_h)
        {
            ESSR_ac_DW.NeESSR_g_StrtStpFailRsn |= 4U;
            VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS | 1U;
        }

        /* Outputs for Atomic SubSystem: '<S1030>/Protected Division' */
        /* Switch: '<S1069>/Switch1' incorporates:
         *  Constant: '<S1063>/Calib'
         *  Constant: '<S1069>/Constant Value'
         *  Constant: '<S1069>/Constant Value1'
         *  Constant: '<S1069>/Constant Value2'
         *  Constant: '<S1069>/Constant Value3'
         *  DataStoreRead: '<S1030>/Dsr_STMTmr2'
         *  Logic: '<S1069>/AND'
         *  RelationalOperator: '<S1069>/Greater Than or Equal '
         *  RelationalOperator: '<S1069>/Greater Than or Equal 1'
         *  RelationalOperator: '<S1069>/Not Equal'
         *  RelationalOperator: '<S1069>/Not Equal1'
         *  Switch: '<S1069>/Switch2'
         *  Switch: '<S1069>/Switch3'
         */
        if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT != 0.0F))
        {
            /* Switch: '<S1069>/Switch1' incorporates:
             *  Product: '<S1069>/Division'
             */
            rtb_Switch1_oim = VeESSR_t_STMTmr_DS / HeESSR_t_MedTEB_dT;
        }
        else if (VeESSR_t_STMTmr_DS > 0.0F)
        {
            /* Switch: '<S1069>/Switch2' incorporates:
             *  Constant: '<S1069>/MAXFLOAT'
             *  Switch: '<S1069>/Switch1'
             */
            rtb_Switch1_oim = 3.402823466E+38F;
        }
        else if (VeESSR_t_STMTmr_DS < 0.0F)
        {
            /* Switch: '<S1069>/Switch3' incorporates:
             *  Constant: '<S1069>/MINFLOAT'
             *  Switch: '<S1069>/Switch1'
             *  Switch: '<S1069>/Switch2'
             */
            rtb_Switch1_oim = -3.402823466E+38F;
        }
        else
        {
            /* Switch: '<S1069>/Switch1' incorporates:
             *  Constant: '<S1069>/Constant Value4'
             *  Switch: '<S1069>/Switch2'
             *  Switch: '<S1069>/Switch3'
             */
            rtb_Switch1_oim = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S1030>/Protected Division' */

        /* Sum: '<S1030>/Summation2' incorporates:
         *  Constant: '<S1030>/Constant Value'
         *  Gain: '<S1030>/Gain'
         *  Lookup_n-D: '<S1066>/Vector'
         *  Lookup_n-D: '<S1068>/Vector'
         *  MinMax: '<S1030>/MinMax'
         *  Product: '<S1030>/Product1'
         *  Switch: '<S1069>/Switch1'
         */
        VeESSR_M_InitSpinEngFricEngStrtTorq = (fmaxf(-VeESSR_M_EngTrqAct_Lmtd,
            0.0F) * look1_iflf_binlcapw(rtb_Switch1_oim, ((const float32 *)
            &(KxESSR_K_InitSpinEngStrtTorqGain[0])), ((const float32 *)
            &(KtESSR_K_InitSpinEngStrtTorqGain[0])), 4U)) + look1_iflf_binlcapw
            (rtb_Switch1_oim, ((const float32 *)
                               &(KxESSR_M_InitSpinEngStrtTorqOffset[0])), ((
               const float32 *)&(KtESSR_M_InitSpinEngStrtTorqOffset[0])), 4U);

        /* Abs: '<S1030>/Abs' */
        VeESSR_M_InitSpinEngPulseEngStrtTorq = fabsf
            (ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E);

        /* Lookup_n-D: '<S1067>/Vector' incorporates:
         *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
         */
        VeESSR_M_InitSpinECTEngStrtTorq = look1_iflf_binlcapw
            (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const float32 *)
              &(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((const float32 *)
              &(KtESSR_M_ECTAddtlEngStrtTorq[0])), 6U);

        /* Sum: '<S1030>/Summation1' */
        VeESSR_M_InitSpinEngStrtTorqRaw = (VeESSR_M_InitSpinEngFricEngStrtTorq +
            VeESSR_M_InitSpinEngPulseEngStrtTorq) +
            VeESSR_M_InitSpinECTEngStrtTorq;

        /* Outputs for Atomic SubSystem: '<S1030>/GradientLimiter' */
        /* Product: '<S1032>/Product' incorporates:
         *  UnitDelay: '<S1062>/Unit Delay'
         */
        rtb_Product_in = ESSR_ac_DW.UnitDelay_DSTATE_h;

        /* Sum: '<S1062>/Sum2' */
        rtb_Switch1_oim = VeESSR_M_InitSpinEngStrtTorqRaw - rtb_Product_in;

        /* Outputs for Atomic SubSystem: '<S1062>/Limiter' */
        /* Switch: '<S1070>/Switch1' incorporates:
         *  Constant: '<S1065>/Calib'
         *  RelationalOperator: '<S1070>/Relational Operator'
         */
        if (KeESSR_dM_InitSpinEngStrtTorqLU < rtb_Switch1_oim)
        {
            /* Switch: '<S1070>/Switch1' */
            rtb_Switch1_oim = KeESSR_dM_InitSpinEngStrtTorqLU;
        }

        /* Switch: '<S1070>/Switch' incorporates:
         *  Constant: '<S1064>/Calib'
         *  RelationalOperator: '<S1070>/Relational Operator1'
         */
        if (rtb_Switch1_oim <= KeESSR_dM_InitSpinEngStrtTorqLD)
        {
            rtb_Switch1_oim = KeESSR_dM_InitSpinEngStrtTorqLD;
        }

        /* End of Outputs for SubSystem: '<S1062>/Limiter' */

        /* Sum: '<S1062>/Sum3' */
        VeESSR_M_InitSpinEngStrtTorqLmtd = rtb_Switch1_oim + rtb_Product_in;

        /* Update for UnitDelay: '<S1062>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_h = VeESSR_M_InitSpinEngStrtTorqLmtd;

        /* End of Outputs for SubSystem: '<S1030>/GradientLimiter' */

        /* Switch: '<S1022>/Switch7' incorporates:
         *  Constant: '<S1040>/Calib'
         *  DataStoreWrite: '<S1022>/Data Store Write3'
         */
        if (!HeESSR_b_EngStrtTorq)
        {
            VeESSR_M_EngStrtTorq_DS = VeESSR_M_InitSpinEngStrtTorqLmtd;
        }

        /* Logic: '<S1022>/Logical2' incorporates:
         *  Constant: '<S1036>/Constant'
         *  Constant: '<S1037>/Constant'
         *  Constant: '<S1038>/Calib'
         *  Constant: '<S1039>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
         *  Logic: '<S1022>/Logical1'
         *  Logic: '<S1022>/Logical3'
         *  Logic: '<S1022>/Logical6'
         *  RelationalOperator: '<S1022>/Comparison1'
         *  RelationalOperator: '<S1022>/Comparison4'
         */
        rtb_Logical2_eb = ((((uint32)VeESSR_e_EngStrtProfType_DS) ==
                            CeESSR_e_KeyCrnkAlgo) || (((uint32)
                             VeESSR_e_EngStrtProfType_DS) == CeESSR_e_LowPwrAlgo));
        rtb_Logical2_eb = (((HeESSR_b_12vStrtrEquipped) ||
                            ((HeESSR_b_BumpStrtEquipped) && rtb_Logical2_eb)) &&
                           rtb_Logical2_eb);

        /* MinMax: '<S1032>/MinMax' incorporates:
         *  DataStoreRead: '<S1032>/Dsr_StrtTypInitSpinEndPnt'
         *  SignalConversion generated from: '<S1075>/Vector'
         */
        rtb_MinMax_if[0] = VeESSR_Cnt_InitSpnStepPt;
        rtb_MinMax_if[1] = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;

        /* Sum: '<S1032>/Sum' */
        rtb_Switch1_oim = VeESSR_M_EngTrqAct_Lmtd - VeESSR_M_SpnUpAddtlTorq;
        for (iU = 0; iU < 2; iU++)
        {
            rtb_MinMax_if[iU] = fmaxf(VeESSR_M_TiEstMin, look1_iflf_binlcapw
                (rtb_MinMax_if[iU], ((const float32 *)&(KxESSR_K_InitSpinTiProf
                [0])), ((const float32 *)&(KtESSR_K_InitSpinTiProf[0])), 6U) *
                rtb_Switch1_oim);
        }

        /* Switch: '<S1022>/Switch2' incorporates:
         *  Constant: '<S1022>/Constant Value1'
         *  DataStoreWrite: '<S1022>/Dsw_InputTorqEst'
         *  Lookup_n-D: '<S1075>/Vector'
         *  MinMax: '<S1032>/MinMax'
         *  Product: '<S1032>/Product1'
         */
        if (rtb_Logical2_eb)
        {
            VeESSR_M_EngTorqEst_DS = 0.0F;
        }
        else
        {
            VeESSR_M_EngTorqEst_DS = rtb_MinMax_if[0];
        }

        /* DataStoreWrite: '<S1022>/Dsw_STMTmr' incorporates:
         *  Constant: '<S1042>/Calib'
         *  DataStoreRead: '<S1022>/Dsr_STMTmr'
         *  Sum: '<S1022>/Summation'
         */
        VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

        /* Switch: '<S1044>/Switch1' incorporates:
         *  Constant: '<S1049>/Calib'
         */
        if (KeESSR_b_InitSpnTmrChkOnly)
        {
            /* Switch: '<S1044>/Switch1' */
            rtb_Switch1_au = VeESSR_b_InitSpnTmrCmplt;
        }

        /* SignalConversion generated from: '<S1022>/Variant Source' incorporates:
         *  Logic: '<S1054>/Logical1'
         *  Logic: '<S1054>/Logical2'
         *  Logic: '<S1054>/Logical3'
         *  Logic: '<S1054>/Logical4'
         *  RelationalOperator: '<S1054>/Comparison1'
         *  RelationalOperator: '<S1054>/Comparison6'
         *  RelationalOperator: '<S1054>/Comparison7'
         *  RelationalOperator: '<S1054>/Comparison8'
         */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

        /* Switch: '<S1022>/Switch5' incorporates:
         *  Constant: '<S1022>/FALSE Constant1'
         */
        rtb_Switch5_hb = false;

#else

        /* Logic: '<S1054>/Logical4' incorporates:
         *  Constant: '<S1085>/Constant'
         *  Constant: '<S1086>/Constant'
         *  Constant: '<S1087>/Constant'
         *  Constant: '<S1088>/Constant'
         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
         *  Logic: '<S1054>/Logical1'
         *  Logic: '<S1054>/Logical2'
         *  Logic: '<S1054>/Logical3'
         *  RelationalOperator: '<S1022>/Comparison4'
         *  RelationalOperator: '<S1054>/Comparison1'
         *  RelationalOperator: '<S1054>/Comparison6'
         *  RelationalOperator: '<S1054>/Comparison7'
         *  RelationalOperator: '<S1054>/Comparison8'
         */
        VeESSR_b_InitSpin_48VP2CoastDown = (((((((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMStrtAlgo) || (((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_ImplStrtAlgo)) || (((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo)) &&
            (VeESSR_b_EMErlyExitLmp)) || ((((uint32)VeESSR_e_EngStrtProfType_DS)
            == CeESSR_e_CltchStrtAlgo) && (VeESSR_b_ClthErlyExitLmp)));

        /* Switch: '<S1022>/Switch5' */
        rtb_Switch5_hb = VeESSR_b_InitSpin_48VP2CoastDown;

#endif

        /* Switch: '<S1022>/Switch5' */
        if (!VeESSR_b_StrtTypChngDisbl)
        {
            /* Switch: '<S1022>/Switch5' incorporates:
             *  Constant: '<S1035>/Constant'
             *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
             *  Logic: '<S1022>/Logical Operator4'
             *  Logic: '<S1022>/Logical Operator5'
             *  RelationalOperator: '<S1022>/Comparison2'
             *  RelationalOperator: '<S1022>/Comparison4'
             */
            rtb_Switch5_hb = (((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B) ||
                               ((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d) &&
                                (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                 CeESSR_e_KeyCrnkAlgo))) ||
                              (VeESSR_b_ErlyExitLmp));
        }

        /* Logic: '<S1022>/Logical Operator3' incorporates:
         *  Constant: '<S1041>/Calib'
         *  Constant: '<S1045>/Calib'
         *  Constant: '<S1046>/Calib'
         *  Constant: '<S1047>/Calib'
         *  Constant: '<S1048>/Calib'
         *  DataStoreRead: '<S1022>/Data Store Read18'
         *  DataStoreRead: '<S1022>/Data Store Read19'
         *  Logic: '<S1022>/Logical Operator2'
         *  Logic: '<S1022>/Logical5'
         *  Logic: '<S1022>/Logical8'
         *  Logic: '<S1022>/Logical9'
         *  RelationalOperator: '<S1022>/Greater  Than11'
         *  RelationalOperator: '<S1022>/Greater  Than15'
         */
        VeESSR_b_InitSpin_CoastDownTrig = ((rtb_Switch5_hb ||
            rtb_LogicalOperator_h) && ((((KeESSR_b_EnblFtrBackupStrt) &&
            (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
             KeESSR_Cnt_BackupStrtMaxAttmpts)) || ((KeESSR_b_EnblFtrBumpStrt) &&
            (VeESSR_Cnt_BumpStrtAttmptCntr_DS < KeESSR_Cnt_BumpStrtMaxAttmpts)))
            || (HeESSR_b_LimphomeEnbl)));

        /* If: '<S1022>/If1' */
        if (rtb_Switch1_au)
        {
            /* Outputs for IfAction SubSystem: '<S1022>/NormExit' incorporates:
             *  ActionPort: '<S1052>/Action Port'
             */
            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S1082>/Constant'
             *  Merge: '<S1022>/Merge1'
             *  SignalConversion generated from: '<S1052>/ESSTrig'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_EngBrkawayAch;

            /* End of Outputs for SubSystem: '<S1022>/NormExit' */
        }
        else if (VeESSR_b_InitSpin_CoastDownTrig)
        {
            /* Outputs for IfAction SubSystem: '<S1022>/If Action Subsystem' incorporates:
             *  ActionPort: '<S1043>/Action Port'
             */
            /* Switch: '<S1043>/Switch' incorporates:
             *  Constant: '<S1080>/Constant'
             *  Constant: '<S1081>/Constant'
             *  DataStoreRead: '<S1043>/Data Store Read5'
             *  DataStoreWrite: '<S1043>/Dsw_StrtStpFailDTC'
             */
            if (VeESSR_b_BSGStrtFailed_DS)
            {
                VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;
            }
            else
            {
                VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
            }

            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
             *  Constant: '<S1079>/Constant'
             *  Merge: '<S1022>/Merge1'
             *  SignalConversion generated from: '<S1043>/ESSTrig'
             */
            VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

            /* End of Outputs for SubSystem: '<S1022>/If Action Subsystem' */
        }
        else
        {
            if (rtb_GreaterThan1_f)
            {
                /* Outputs for IfAction SubSystem: '<S1022>/OffFail' incorporates:
                 *  ActionPort: '<S1053>/Action Port'
                 */
                /* DataStoreWrite: '<S1053>/Dsw_StrtStpFailDTC' incorporates:
                 *  Constant: '<S1084>/Constant'
                 */
                VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;

                /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                 *  Constant: '<S1083>/Constant'
                 *  Merge: '<S1022>/Merge1'
                 *  SignalConversion generated from: '<S1053>/ESSTrig'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

                /* End of Outputs for SubSystem: '<S1022>/OffFail' */
            }
        }

        /* Switch: '<S1022>/Switch4' incorporates:
         *  Constant: '<S1022>/Constant Value2'
         *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType2'
         *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType6'
         *  DataStoreWrite: '<S1022>/Dsw_StrtStpFailDTC1'
         *  Logic: '<S1022>/Logical21'
         *  Logic: '<S1022>/Logical7'
         *  RelationalOperator: '<S1022>/Comparison'
         *  S-Function (sfix_bitop): '<S1022>/Bitwise Operator'
         *  S-Function (sfix_bitop): '<S1028>/FixPt Bitwise Operator1'
         */
        if (((VeESSR_b_InitSpin_CoastDownTrig) || rtb_GreaterThan1_f) &&
                ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16U) > 0U))
        {
            VeESSR_g_StrtStpFailPhase_DS = VeESSR_g_StrtStpFailPhase_DS | 16U;
        }

        /* Switch: '<S1071>/Switch1' incorporates:
         *  Constant: '<S1072>/Calib'
         *  DataStoreWrite: '<S1031>/Dsw_InitEngAng720'
         *  RelationalOperator: '<S1031>/Equal1'
         */
        if (VeESSR_Cnt_InitSpnStepPt <= KeESSR_t_InitSpnInitAngTm)
        {
            VeESSR_phi_InitEngAng720_DS =
                ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi;
        }

        /* Sum: '<S1032>/Subtract' incorporates:
         *  Constant: '<S1074>/Calib'
         *  DataStoreRead: '<S1032>/Dsr_NiProfGenNiDMax'
         *  DataStoreWrite: '<S1032>/Data Store Write'
         *  Product: '<S1032>/Product'
         */
        ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = rtb_MinMax_if[1] -
            (VeESSR_dn_StrtTypNiDotMax_DS * KeESSR_r_NiDtoTiMargin);

        /* DataStoreWrite: '<S1022>/Dsw_InputAcceltnProf1' */
        VeESSR_dn_InputAcceltnProf_DS =
            ESSR_ac_B.VariantMerge_For_Variant_Source;

        /* RelationalOperator: '<S1022>/Equal1' incorporates:
         *  Constant: '<S1022>/Constant Value'
         *  DataStoreRead: '<S1022>/Data Store Read5'
         *  DataStoreWrite: '<S1022>/Data Store Write5'
         */
        VeESSR_b_BSGStrtFailed_DS = (VeESSR_g_BSGStrtFailRsn_DS != 0U);

        /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqImmed' incorporates:
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitImmedTorq'
         */
        VeESSR_M_EngTrqReqImmed_DS = VeESSR_M_StrtTypInitImmedTorq_DS;

        /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqPrdtd1' incorporates:
         *  DataStoreRead: '<S1022>/Dsr_StrtTypInitPredTorq'
         */
        VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

        /* Switch: '<S1078>/Switch3' */
        if (rtb_Equal2)
        {
            /* Update for UnitDelay: '<S1078>/Unit Delay' incorporates:
             *  Constant: '<S1033>/Constant Value5'
             */
            ESSR_ac_DW.UnitDelay_DSTATE_iu = 0.0F;
        }
        else
        {
            /* Update for UnitDelay: '<S1078>/Unit Delay' */
            ESSR_ac_DW.UnitDelay_DSTATE_iu = rtb_Sum_k0;
        }

        /* End of Outputs for SubSystem: '<S559>/InitEngSpinDur' */
    }

    /* End of DataStoreRead: '<S13>/Dsr_EngStrtType' */
}

#endif

/* Function for Chart: '<S13>/ESSC_EngStartStopSTM' */
#if Rte_SysCon_Variant_ESSR_Func

static void ESSR_enter_internal_EngStopCtrl(const boolean *Dsr_DsblFuelReq,
    const boolean *Dsr_RmpDwnReq)
{
    float32 rtb_Switch1_hg;
    float32 tmpRead;
    float32 tmpRead_3;
    float32 tmpRead_4;
    TeENGR_e_EngDFSO_St tmpRead_0;
    TeINVR_e_MtrInvrtrSt tmpRead_1;
    TeTRAR_e_HybCmndEngTorqRespTyp tmp;
    boolean tmpRead_2;

    /* Entry Internal 'EngStopCtrl': '<S165>:13' */
    /* Transition: '<S165>:18' */
    if (*Dsr_DsblFuelReq)
    {
        /* Inport: '<Root>/VeENGR_b_EngTLCLearnReq' */
        (void)Rte_Read_VeENGR_b_EngTLCLearnReq_Value(&tmpRead_2);

        /* Inport: '<Root>/VeENGR_e_EngDFSO_Req' */
        (void)Rte_Read_VeENGR_e_EngDFSO_Req_Value(&tmpRead_0);

        /* Transition: '<S165>:170' */
        ESSR_ac_DW.is_EngStopCtrl = ESSR_ac_IN_DisableFuel;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'DisableFuel': '<S165>:15' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

        /* Outputs for Function Call SubSystem: '<S2447>/DisableFuelEnt' */
        /* Event: '<S165>:95' */
        ESSR_ac_DisableFuelEnt();

        /* End of Outputs for SubSystem: '<S2447>/DisableFuelEnt' */

        /* Outputs for Function Call SubSystem: '<S2447>/DisableFuelDur' */
        /* Event: '<S165>:96' */
        ESSR_ac_DisableFuelDur(ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                               ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                               ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                               ESSR_ac_B.TmpSignalConversionAtVeENGR_e_g,
                               tmpRead_0, tmpRead_2,
                               ESSR_ac_B.TmpSignalConversionAtVeESSR__no,
                               ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                               VeESSR_n_TransInSpdFlt,
                               ESSR_ac_B.TmpSignalConversionAtVeETQR_M_e,
                               ESSR_ac_B.TmpSignalConversionAtVeESPR_phi,
                               ESSR_ac_B.TmpSignalConversionAtVeESPR_b_h,
                               ESSR_ac_B.TmpSignalConversionAtVeESPR_b_E,
                               VeESSR_b_AStopEngCOMLmp,
                               &ESSR_ac_DW.DisableFuelDur,
                               &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn,
                               &ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt);

        /* End of Outputs for SubSystem: '<S2447>/DisableFuelDur' */
    }
    else if (*Dsr_RmpDwnReq)
    {
        /* Transition: '<S165>:171' */
        ESSR_ac_DW.is_EngStopCtrl = ESSR_ac_IN_RampDown;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'RampDown': '<S165>:16' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

        /* Outputs for Function Call SubSystem: '<S2450>/ESSC_RampDownEnt' */
        /* Event: '<S165>:97' */
        ESSR_ac_ESSC_RampDownEnt(ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
            ESSR_ac_B.TmpSignalConversionAtVeETQR_M_e,
            &ESSR_ac_B.ESSC_RampDownEnt, &ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt,
            &ESSR_ac_DW.NeESSR_k_EngStpProfNiDotGainAda);

        /* End of Outputs for SubSystem: '<S2450>/ESSC_RampDownEnt' */

        /* Outputs for Function Call SubSystem: '<S2450>/ESSC_RampDownDur' */
        /* Event: '<S165>:98' */
        ESSR_ac_ESSC_RampDownDur
            (ESSR_ac_B.ESSC_RampDownEnt.Dsr_InputSpeedProfile1,
             VeESSR_n_TransInSpdFlt, ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
             VeESSR_M_SpnDwnAddtlTorq, ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
             ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
             ESSR_ac_B.TmpSignalConversionAtVeCSVR_v_V, VeESSR_dn_NiDotMax,
             VeESSR_dn_NiDotMin, ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
             ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_I,
             ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_C, VeESSR_b_AStopEngCOMLmp,
             VeESSR_b_AStopReStrtPrepLmp, &ESSR_ac_B.ESSC_RampDownDur,
             &ESSR_ac_DW.ESSC_RampDownDur, &ESSR_ac_PrevZCX.ESSC_RampDownDur,
             &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn,
             &ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt,
             &ESSR_ac_DW.NeESSR_k_EngStpProfNiDotGainAda);

        /* End of Outputs for SubSystem: '<S2450>/ESSC_RampDownDur' */
    }
    else
    {
        /* Outputs for Function Call SubSystem: '<S2449>/PrepForStopEnt' */
        /* DataStoreWrite: '<S2635>/Dsw_EngTrqReqPrdtd' incorporates:
         *  Inport: '<Root>/VeTRAR_M_HybCmndEngTorqPrdtd'
         */
        (void)Rte_Read_VeTRAR_M_HybCmndEngTorqPrdtd_Value
            ((&(VeESSR_M_EngTrqReqPrdtd_DS)));

        /* End of Outputs for SubSystem: '<S2449>/PrepForStopEnt' */
        /* Transition: '<S165>:168' */
        ESSR_ac_DW.is_EngStopCtrl = ESSR_ac_IN_PrepForStop;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'PrepForStop': '<S165>:14' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

        /* Outputs for Function Call SubSystem: '<S2449>/PrepForStopEnt' */
        /* Outputs for Atomic SubSystem: '<S2635>/ClosedInterval' */
        /* RelationalOperator: '<S2772>/Relatonal Operator' incorporates:
         *  DataTypeConversion: '<S2635>/Data Type Conversion1'
         *  RelationalOperator: '<S2772>/Relatonal Operator1'
         *  SignalConversion generated from: '<S2>/VeTRAR_e_HybCmndEngTorqRespTyp'
         */
        /* Event: '<S165>:93' */
        tmp = ESSR_ac_B.TmpSignalConversionAtVeTRAR_e_H;

        /* Switch: '<S2635>/Switch' incorporates:
         *  Constant: '<S2777>/Constant'
         *  Constant: '<S2778>/Constant'
         *  DataStoreWrite: '<S2635>/Dsw_EngTrqReqImmed'
         *  Logic: '<S2772>/Logical Operator'
         *  RelationalOperator: '<S2772>/Relatonal Operator'
         *  RelationalOperator: '<S2772>/Relatonal Operator1'
         */
        if ((((uint32)tmp) >= CeTRAR_e_Pleasability_Limited) && (((uint32)tmp) <=
             CeTRAR_e_Maximum_Range))
        {
            VeESSR_M_EngTrqReqImmed_DS =
                ESSR_ac_B.TmpSignalConversionAtVeTRAR_M_E;
        }
        else
        {
            VeESSR_M_EngTrqReqImmed_DS =
                ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o;
        }

        /* End of Switch: '<S2635>/Switch' */
        /* End of Outputs for SubSystem: '<S2635>/ClosedInterval' */

        /* MinMax: '<S2635>/MinMax1' incorporates:
         *  DataStoreRead: '<S2635>/VeESSR_e_StrtStpTypEngTorqRespType_DS'
         *  DataTypeConversion: '<S2635>/Data Type Conversion'
         */
        if (VeESSR_e_StrtStpTypEngTorqRespType_DS >
                ((TePTAR_e_ImmediateTorqRespType)tmp))
        {
            /* DataTypeConversion: '<S2775>/DataTypeConversion' incorporates:
             *  DataStoreWrite: '<S2635>/Dsw_EngTrqRespType'
             */
            VeESSR_e_EngTrqRespType_DS = VeESSR_e_StrtStpTypEngTorqRespType_DS;
        }
        else
        {
            /* DataTypeConversion: '<S2775>/DataTypeConversion' incorporates:
             *  DataStoreWrite: '<S2635>/Dsw_EngTrqRespType'
             */
            VeESSR_e_EngTrqRespType_DS = tmp;
        }

        /* End of MinMax: '<S2635>/MinMax1' */

        /* Outputs for Atomic SubSystem: '<S2773>/ClosedInterval' */
        /* Switch: '<S2796>/Switch1' incorporates:
         *  Constant: '<S2797>/Calib'
         *  Constant: '<S2798>/Calib'
         *  DataStoreWrite: '<S2635>/Dsw_EngIdleTm1'
         *  Logic: '<S2795>/Logical Operator'
         *  RelationalOperator: '<S2795>/Relatonal Operator'
         *  RelationalOperator: '<S2795>/Relatonal Operator1'
         *  Sum: '<S2773>/Sum2'
         *  Sum: '<S2773>/Sum3'
         */
        if ((ESSR_ac_B.TmpSignalConversionAtVeHSER_n_I >=
                (KeESSR_n_PrepStopDsrdEngSpd - KeESSR_n_PrepStopIdleSpdDB)) &&
                (ESSR_ac_B.TmpSignalConversionAtVeHSER_n_I <=
                 (KeESSR_n_PrepStopDsrdEngSpd + KeESSR_n_PrepStopIdleSpdDB)))
        {
            VeESSR_n_TgtIdleSpd_DS = ESSR_ac_B.TmpSignalConversionAtVeHSER_n_I;
        }
        else
        {
            VeESSR_n_TgtIdleSpd_DS = KeESSR_n_PrepStopDsrdEngSpd;
        }

        /* End of Switch: '<S2796>/Switch1' */
        /* End of Outputs for SubSystem: '<S2773>/ClosedInterval' */

        /* DataStoreWrite: '<S2635>/Dsw_InputSpeedProfile2' incorporates:
         *  DataStoreWrite: '<S2635>/Dsw_EngIdleTm1'
         */
        VeESSR_n_TargetSpeed_DS = VeESSR_n_TgtIdleSpd_DS;

        /* Lookup_n-D: '<S2792>/Vector' incorporates:
         *  DataStoreWrite: '<S2635>/Dsw_EngIdleTm2'
         *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
         */
        VeESSR_M_PrepStpImmedTgt_DS = look1_iflf_binlcapw
            (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const float32 *)
              &(KxESSR_M_PrepStpImmedTrgt[0])), ((const float32 *)
              &(KtESSR_M_PrepStpImmedTrgt[0])), 2U);

        /* DataStoreWrite: '<S2635>/Dsw_InputSpeedProfile3' incorporates:
         *  Constant: '<S2635>/Constant Value1'
         */
        VeESSR_dn_TargetAcceltn_DS = 0.0F;

        /* Switch: '<S2635>/Switch3' incorporates:
         *  Constant: '<S2635>/Constant Value3'
         *  Constant: '<S2781>/Calib'
         *  DataStoreWrite: '<S2635>/Data Store Write2'
         */
        if (!HeESSR_b_EngStrtTorq)
        {
            VeESSR_M_EngStrtTorq_DS = 0.0F;
        }

        /* End of Switch: '<S2635>/Switch3' */

        /* DataStoreWrite: '<S2635>/Dsw_EngIdleTm' incorporates:
         *  Constant: '<S2635>/Constant Value4'
         */
        VeESSR_t_EngIdleTm_DS = 0.0F;

        /* Switch: '<S2635>/Switch2' incorporates:
         *  Constant: '<S2635>/TRUE Constant'
         *  Constant: '<S2780>/Constant'
         *  Constant: '<S2782>/Calib'
         *  DataStoreWrite: '<S2635>/Dsw_Dsbl_ICSRFor12vStart'
         *  DataStoreWrite: '<S2635>/Dsw_EngCntrlMode_DS'
         *  Switch: '<S2635>/Switch1'
         */
        if (HeESSR_b_PrepStpDisableNiSpeedMd)
        {
            VeESSR_b_DsblNiClsdLoopCntrl_DS = true;
            VeESSR_e_EngCntrlMode_DS = CeTRAR_e_TorqueMode;
        }

        /* End of Switch: '<S2635>/Switch2' */

        /* DataStoreWrite: '<S2635>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
         *  Constant: '<S2783>/Calib'
         */
        VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

        /* DataStoreWrite: '<S2635>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
         *  Constant: '<S2784>/Calib'
         */
        VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

        /* DataStoreWrite: '<S2635>/Dsw_EngStartStopSt' incorporates:
         *  Constant: '<S2774>/Constant'
         */
        VeESSR_e_EngStartStopSt_DS = CeESSR_e_PrepForStopSt;

        /* DataStoreWrite: '<S2635>/Dsw_EngStrtStpMd2' incorporates:
         *  Constant: '<S2786>/Calib'
         */
        VeESSR_e_EngStrtStpMd_DS = KeESSR_e_MdInPrepStopSt;

        /* DataStoreWrite: '<S2635>/Dsw_EngStrtType1' incorporates:
         *  Constant: '<S2787>/Calib'
         */
        VeESSR_e_TCM_StartStopType_DS = KeESSR_e_TCM_StartStopType_PFS;

        /* DataStoreWrite: '<S2635>/Dsw_EngStrtType2' incorporates:
         *  Constant: '<S2779>/Constant'
         */
        VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_PrepStop;

        /* DataStoreWrite: '<S2635>/Dsw_InhibitShiftToMode' incorporates:
         *  Constant: '<S2785>/Calib'
         */
        VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtPrepStopSt;

        /* DataStoreWrite: '<S2635>/Dsw_InputSpeedProfile1' incorporates:
         *  Constant: '<S2791>/Calib'
         */
        VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

        /* DataStoreWrite: '<S2635>/Dsw_TransFldPmpSel' incorporates:
         *  Constant: '<S2788>/Calib'
         */
        VeESSR_e_TransFldPmpSel_DS = KeESSR_e_TransFldPmpSelPrepForStopSt;

        /* Outputs for Atomic SubSystem: '<S2635>/Limiter' */
        /* Switch: '<S2793>/Switch1' incorporates:
         *  Constant: '<S2789>/Calib'
         *  DataStoreRead: '<S2635>/Data Store Read'
         *  RelationalOperator: '<S2793>/Relational Operator'
         */
        if (KeESSR_k_EngStpProfNiDotGainAdpt_Max <
                ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt)
        {
            /* Switch: '<S2793>/Switch1' */
            rtb_Switch1_hg = KeESSR_k_EngStpProfNiDotGainAdpt_Max;
        }
        else
        {
            /* Switch: '<S2793>/Switch1' */
            rtb_Switch1_hg = ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt;
        }

        /* End of Switch: '<S2793>/Switch1' */

        /* Switch: '<S2793>/Switch' incorporates:
         *  Constant: '<S2790>/Calib'
         *  RelationalOperator: '<S2793>/Relational Operator1'
         */
        if (rtb_Switch1_hg <= KeESSR_k_EngStpProfNiDotGainAdpt_Min)
        {
            /* Switch: '<S2793>/Switch' */
            rtb_Switch1_hg = KeESSR_k_EngStpProfNiDotGainAdpt_Min;
        }

        /* End of Switch: '<S2793>/Switch' */
        /* End of Outputs for SubSystem: '<S2635>/Limiter' */

        /* If: '<S2635>/If' incorporates:
         *  DataStoreRead: '<S2635>/Data Store Read'
         */
        if (rtb_Switch1_hg != ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt)
        {
            /* Outputs for IfAction SubSystem: '<S2635>/Update_Adapt_Value' incorporates:
             *  ActionPort: '<S2794>/Action Port'
             */
            /* DataStoreWrite: '<S2794>/Data Store Write1' */
            ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt = rtb_Switch1_hg;

            /* End of Outputs for SubSystem: '<S2635>/Update_Adapt_Value' */
        }

        /* End of If: '<S2635>/If' */
        /* End of Outputs for SubSystem: '<S2449>/PrepForStopEnt' */

        /* Inport: '<Root>/VeETQR_M_EngCapacityMinRun' */
        (void)Rte_Read_VeETQR_M_EngCapacityMinRun_Value(&tmpRead_4);

        /* Inport: '<Root>/VeTFTR_T_TransOilTemp' */
        (void)Rte_Read_VeTFTR_T_TransOilTemp_Value(&tmpRead_3);

        /* Inport: '<Root>/VeTAPR_b_AuxPumpRunning' */
        (void)Rte_Read_VeTAPR_b_AuxPumpRunning_Value(&tmpRead_2);

        /* Inport: '<Root>/VeINVR_e_MtrA_InvrtrSt' */
        (void)Rte_Read_VeINVR_e_MtrA_InvrtrSt_Value(&tmpRead_1);

        /* Inport: '<Root>/VeENGR_e_EngDFSO_St' */
        (void)Rte_Read_VeENGR_e_EngDFSO_St_Value(&tmpRead_0);

        /* Inport: '<Root>/VeAATR_T_EstAmbAirTemp' */
        (void)Rte_Read_VeAATR_T_EstAmbAirTemp_Value(&tmpRead);

        /* Outputs for Function Call SubSystem: '<S2449>/PrepForStopDur' */
        /* Event: '<S165>:94' */
        ESSR_ac_PrepForStopDur(VeESSR_n_TransInSpdFlt, VeESSR_dn_NiDotMax,
                               VeESSR_dn_NiDotMin,
                               ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                               tmpRead_4,
                               ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                               ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                               ESSR_ac_B.TmpSignalConversionAtVeENGR_e_C,
                               tmpRead_2, tmpRead, tmpRead_3,
                               ESSR_ac_B.TmpSignalConversionAtVeESSR__no,
                               ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                               ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                               ESSR_ac_B.TmpSignalConversionAtVeESPR_b_h,
                               ESSR_ac_B.TmpSignalConversionAtVeESPR_b_E,
                               VeESSR_b_AStopEngCOMLmp,
                               ESSR_ac_B.TmpSignalConversionAtVeETQR_M_e,
                               tmpRead_0, tmpRead_1, &ESSR_ac_DW.PrepForStopDur,
                               &ESSR_ac_PrevZCX.PrepForStopDur,
                               &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn,
                               &ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt);

        /* End of Outputs for SubSystem: '<S2449>/PrepForStopDur' */
    }
}

#endif

/* Function for Chart: '<S13>/ESSC_EngStartStopSTM' */
#if Rte_SysCon_Variant_ESSR_Func

static void ESSR_exit_internal_EngStartCtrl(void)
{
    /* Exit Internal 'EngStartCtrl': '<S165>:4' */
    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_NO_ACTIVE_CHILD;
}

#endif

/* Function for Chart: '<S13>/ESSC_EngStartStopSTM' */
#if Rte_SysCon_Variant_ESSR_Func

static void ESSR_ac_EngStartCtrl(const boolean *Dsr_DsblFuelReq, const boolean
    *Dsr_RmpDwnReq, const TeESSR_e_STMTrigger *Dsr_STMTrigger, const
    TeESSR_e_StrtType *Dsr_EngStrtType)
{
    sint32 iU;
    float32 rtb_MinMax_e[2];
    float32 rtb_Abs_ogo;
    float32 rtb_Gain_kd;
    float32 rtb_Multiplication1_cp;
    float32 rtb_Sum_og;
    float32 rtb_Switch3_bg;
    uint32 tmpRead_0;
    TeHCCR_e_ClutchStatus tmpRead_1;
    TeHPMR_e_PropSysMode tmpRead;
    boolean rtb_Equal_d;
    boolean rtb_GreaterThan1_gb;
    boolean rtb_Logical2_dq;
    boolean rtb_LogicalOperator1_cd;
    boolean rtb_LogicalOperator_h;
    boolean rtb_NOT_i;

    /* DataStoreRead: '<S13>/Dsr_STMTrigger' incorporates:
     *  DataStoreRead: '<S13>/Dsr_EngStrtType'
     *  Inport: '<Root>/VeBPCR_T_BatModTmp'
     *  Inport: '<Root>/VeENGR_b_EngineStallDetected'
     *  Inport: '<Root>/VeENGR_b_GasFlowActuator'
     *  Inport: '<Root>/VeESMR_P_BatEstdVoltMinLim'
     *  Inport: '<Root>/VeESPR_n_EngSpdMaxLim'
     *  Inport: '<Root>/VeHPMR_e_PropSysMode'
     *  Inport: '<Root>/VePMDR_b_StrtCntrlStOn'
     *  Inport: '<Root>/VeSRAR_b_MtrBZeroTrqActv'
     *  Inport: '<Root>/VeSTRR_g_AStpInhbtRsn2'
     *  Inport: '<Root>/VeTRNR_e_ILEStat'
     */
    /* During 'EngStartCtrl': '<S165>:4' */
    if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngRun)
    {
        (void)Rte_Read_VeENGR_b_EngineStallDetected_Value
            (&rtb_LogicalOperator1_cd);

        /* Transition: '<S165>:21' */
        ESSR_exit_internal_EngStartCtrl();

        /* Outputs for Function Call SubSystem: '<S176>/MainEngStartExit' */
        /* Exit 'EngStartCtrl': '<S165>:4' */
        /* Event: '<S165>:71' */
        ESSR_ac_MainEngStartExit();

        /* End of Outputs for SubSystem: '<S176>/MainEngStartExit' */
        ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_EngRunning;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'EngRunning': '<S165>:12' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

        /* Outputs for Function Call SubSystem: '<S174>/ESSC_EngRunEnt' */
        /* Event: '<S165>:67' */
        ESSR_ac_ESSC_EngRunEnt();

        /* End of Outputs for SubSystem: '<S174>/ESSC_EngRunEnt' */

        /* Outputs for Function Call SubSystem: '<S174>/ESSC_EngRunDur' */
        /* Event: '<S165>:68' */
        ESSR_ac_ESSC_EngRunDur(ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                               VeESSR_n_TransInSpdFlt,
                               ESSR_ac_B.TmpSignalConversionAtVeHSER_dn_,
                               ESSR_ac_B.TmpSignalConversionAtVeHSER_n_I,
                               ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_E,
                               ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                               rtb_LogicalOperator1_cd,
                               ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R,
                               &ESSR_ac_DW.ESSC_EngRunDur,
                               &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn,
                               &ESSR_ac_DW.VeESSR_M_BCTiMargin_DS);

        /* End of Outputs for SubSystem: '<S174>/ESSC_EngRunDur' */
    }
    else if (((((uint32)(*Dsr_STMTrigger)) == CeESSR_e_ImmedStopReq) ||
              (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngFail)) || (((uint32)
               (*Dsr_STMTrigger)) == CeESSR_e_StartAbort))
    {
        (void)Rte_Read_VePMDR_b_StrtCntrlStOn_Value(&rtb_LogicalOperator1_cd);

        /* Transition: '<S165>:29' */
        ESSR_exit_internal_EngStartCtrl();

        /* Outputs for Function Call SubSystem: '<S176>/MainEngStartExit' */
        /* Exit 'EngStartCtrl': '<S165>:4' */
        /* Event: '<S165>:71' */
        ESSR_ac_MainEngStartExit();

        /* End of Outputs for SubSystem: '<S176>/MainEngStartExit' */
        ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_ImmedStop;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'ImmedStop': '<S165>:5' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

        /* Outputs for Function Call SubSystem: '<S175>/ESSC_ImmedStopEnt' */
        /* Event: '<S165>:75' */
        ESSR_ac_ESSC_ImmedStopEnt(VeESSR_n_TransInSpdFlt,
            ESSR_ac_B.TmpSignalConversionAtVeTRAR_e_H,
            ESSR_ac_B.TmpSignalConversionAtVeTRAR_M_E);

        /* End of Outputs for SubSystem: '<S175>/ESSC_ImmedStopEnt' */

        /* Outputs for Function Call SubSystem: '<S175>/ESSC_ImmedStopDur' */
        /* Event: '<S165>:76' */
        ESSR_ac_ESSC_ImmedStopDur(VeESSR_n_TransInSpdFlt, VeESSR_dn_NiDotMax,
            VeESSR_dn_NiDotMin, ESSR_ac_B.TmpSignalConversionAtVeENGR_e_C,
            ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o, VeESSR_M_SpnDwnAddtlTorq,
            ESSR_ac_B.TmpSignalConversionAtVeHPMR_b_P, rtb_LogicalOperator1_cd,
            ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
            &ESSR_ac_DW.ESSC_ImmedStopDur, &ESSR_ac_PrevZCX.ESSC_ImmedStopDur,
            &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

        /* End of Outputs for SubSystem: '<S175>/ESSC_ImmedStopDur' */
    }
    else
    {
        switch (*Dsr_STMTrigger)
        {
          case CeESSR_e_CoastDown:
            (void)Rte_Read_VeTRNR_e_ILEStat_Value(&tmpRead_1);
            (void)Rte_Read_VeSTRR_g_AStpInhbtRsn2_Value(&tmpRead_0);
            (void)Rte_Read_VeSRAR_b_MtrBZeroTrqActv_Value
                (&rtb_LogicalOperator1_cd);

            /* Transition: '<S165>:128' */
            ESSR_exit_internal_EngStartCtrl();

            /* Outputs for Function Call SubSystem: '<S176>/MainEngStartExit' */
            /* Exit 'EngStartCtrl': '<S165>:4' */
            /* Event: '<S165>:71' */
            ESSR_ac_MainEngStartExit();

            /* End of Outputs for SubSystem: '<S176>/MainEngStartExit' */
            ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_CoastDown;

            /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
            /* Entry 'CoastDown': '<S165>:126' */
            /* Event: '<S165>:101' */
            ESSR_ac_ESSC_ResetVars();

            /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

            /* Outputs for Function Call SubSystem: '<S171>/ESSC_CoastDownEnt' */
            /* Event: '<S165>:133' */
            ESSR_ac_ESSC_CoastDownEnt(ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E);

            /* End of Outputs for SubSystem: '<S171>/ESSC_CoastDownEnt' */

            /* Outputs for Function Call SubSystem: '<S171>/ESSC_CoastDownDur' */
            /* Event: '<S165>:134' */
            ESSR_ac_ESSC_CoastDownDur(VeESSR_n_TransInSpdFlt,
                ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_E,
                ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                rtb_LogicalOperator1_cd, tmpRead_0,
                ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d,
                ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_e,
                ESSR_ac_B.TmpSignalConversionAtVeTRNR_e_A, tmpRead_1);

            /* End of Outputs for SubSystem: '<S171>/ESSC_CoastDownDur' */
            break;

          case CeESSR_e_StopReq:
            /* Transition: '<S165>:125' */
            ESSR_exit_internal_EngStartCtrl();

            /* Outputs for Function Call SubSystem: '<S176>/MainEngStartExit' */
            /* Exit 'EngStartCtrl': '<S165>:4' */
            /* Event: '<S165>:71' */
            ESSR_ac_MainEngStartExit();

            /* End of Outputs for SubSystem: '<S176>/MainEngStartExit' */
            ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_EngStopCtrl;

            /* Outputs for Function Call SubSystem: '<S177>/MainEngStopEntry' */
            /* Entry 'EngStopCtrl': '<S165>:13' */
            /* Event: '<S165>:72' */
            ESSR_ac_MainEngStopEntry();

            /* End of Outputs for SubSystem: '<S177>/MainEngStopEntry' */
            ESSR_enter_internal_EngStopCtrl(Dsr_DsblFuelReq, Dsr_RmpDwnReq);
            break;

          default:
            /* Outputs for Function Call SubSystem: '<S176>/MainEngStartDur' */
            /* If: '<S461>/If' incorporates:
             *  Constant: '<S476>/Calib'
             *  Constant: '<S479>/Calib'
             *  DataStoreRead: '<S461>/Dsr_InputSpeedProfile1'
             *  DataStoreRead: '<S461>/Dsr_STMTmr1'
             *  RelationalOperator: '<S461>/Comparison2'
             *  RelationalOperator: '<S461>/Comparison3'
             */
            /* Event: '<S165>:70' */
            if ((VeESSR_n_InputSpeedProfile_DS > KeESSR_n_MaxCancelRPM) ||
                    (VeESSR_t_MainSTMTmr_DS > KeESSR_t_MaxCancelTime))
            {
                /* Outputs for IfAction SubSystem: '<S461>/DmprOpenNoPC' incorporates:
                 *  ActionPort: '<S468>/Action Port'
                 */
                /* Abs: '<S484>/Abs' incorporates:
                 *  Constant: '<S485>/Calib'
                 *  Constant: '<S486>/Calib'
                 *  Product: '<S484>/Multiplication'
                 */
                rtb_Abs_ogo = fabsf(KeESSR_dscl_TorqCancelRampOutRt *
                                    HeESSR_t_MedTEB_dT);

                /* Gain: '<S484>/Gain' */
                rtb_Gain_kd = -rtb_Abs_ogo;

                /* Outputs for Atomic SubSystem: '<S484>/Limiter1' */
                /* Switch: '<S487>/Switch1' incorporates:
                 *  Constant: '<S468>/Constant Value1'
                 *  DataStoreRead: '<S468>/Dsr_TorqCancelDsrd1'
                 *  RelationalOperator: '<S487>/Relational Operator'
                 *  Sum: '<S484>/Sum'
                 */
                if (rtb_Abs_ogo >= (0.0F - VeESSR_k_TorqCancelGain_DS))
                {
                    /* Switch: '<S488>/Switch1' */
                    rtb_Abs_ogo = 0.0F - VeESSR_k_TorqCancelGain_DS;
                }

                /* End of Switch: '<S487>/Switch1' */

                /* Switch: '<S487>/Switch' incorporates:
                 *  RelationalOperator: '<S487>/Relational Operator1'
                 */
                if (rtb_Abs_ogo > rtb_Gain_kd)
                {
                    rtb_Gain_kd = rtb_Abs_ogo;
                }

                /* End of Switch: '<S487>/Switch' */
                /* End of Outputs for SubSystem: '<S484>/Limiter1' */

                /* Sum: '<S484>/Sum1' incorporates:
                 *  DataStoreRead: '<S468>/Dsr_TorqCancelDsrd1'
                 */
                rtb_Gain_kd += VeESSR_k_TorqCancelGain_DS;

                /* Outputs for Atomic SubSystem: '<S484>/Limiter2' */
                /* Switch: '<S488>/Switch1' incorporates:
                 *  Constant: '<S468>/Constant Value5'
                 *  RelationalOperator: '<S488>/Relational Operator'
                 */
                if (2.0F < rtb_Gain_kd)
                {
                    /* Switch: '<S488>/Switch1' */
                    rtb_Abs_ogo = 2.0F;
                }
                else
                {
                    /* Switch: '<S488>/Switch1' */
                    rtb_Abs_ogo = rtb_Gain_kd;
                }

                /* End of Switch: '<S488>/Switch1' */

                /* Switch: '<S488>/Switch' incorporates:
                 *  Constant: '<S468>/Constant Value4'
                 *  RelationalOperator: '<S488>/Relational Operator1'
                 */
                if (rtb_Abs_ogo > 0.0F)
                {
                    /* Merge: '<S461>/Merge' */
                    rtb_Gain_kd = rtb_Abs_ogo;
                }
                else
                {
                    /* Merge: '<S461>/Merge' */
                    rtb_Gain_kd = 0.0F;
                }

                /* End of Switch: '<S488>/Switch' */
                /* End of Outputs for SubSystem: '<S484>/Limiter2' */
                /* End of Outputs for SubSystem: '<S461>/DmprOpenNoPC' */
            }
            else
            {
                /* Outputs for IfAction SubSystem: '<S461>/DmprOpenPC' incorporates:
                 *  ActionPort: '<S469>/Action Port'
                 */
                /* Abs: '<S489>/Abs' incorporates:
                 *  Constant: '<S490>/Calib'
                 *  Constant: '<S491>/Calib'
                 *  Product: '<S489>/Multiplication'
                 */
                rtb_Abs_ogo = fabsf(KeESSR_dscl_TorqCancelRampInRt *
                                    HeESSR_t_MedTEB_dT);

                /* Gain: '<S489>/Gain' */
                rtb_Gain_kd = -rtb_Abs_ogo;

                /* Sum: '<S489>/Sum' incorporates:
                 *  DataStoreRead: '<S469>/Dsr_StrtTypPulseCnclTorqScaler1'
                 *  DataStoreRead: '<S469>/Dsr_TorqCancelDsrd1'
                 */
                rtb_Sum_og = VeESSR_scl_StrtTypPulseCnclTorqScaler_DS -
                    VeESSR_k_TorqCancelGain_DS;

                /* Outputs for Atomic SubSystem: '<S489>/Limiter1' */
                /* Switch: '<S492>/Switch1' incorporates:
                 *  RelationalOperator: '<S492>/Relational Operator'
                 */
                if (rtb_Abs_ogo >= rtb_Sum_og)
                {
                    /* Switch: '<S493>/Switch1' */
                    rtb_Abs_ogo = rtb_Sum_og;
                }

                /* End of Switch: '<S492>/Switch1' */

                /* Switch: '<S492>/Switch' incorporates:
                 *  RelationalOperator: '<S492>/Relational Operator1'
                 */
                if (rtb_Abs_ogo > rtb_Gain_kd)
                {
                    rtb_Gain_kd = rtb_Abs_ogo;
                }

                /* End of Switch: '<S492>/Switch' */
                /* End of Outputs for SubSystem: '<S489>/Limiter1' */

                /* Sum: '<S489>/Sum1' incorporates:
                 *  DataStoreRead: '<S469>/Dsr_TorqCancelDsrd1'
                 */
                rtb_Gain_kd += VeESSR_k_TorqCancelGain_DS;

                /* Outputs for Atomic SubSystem: '<S489>/Limiter2' */
                /* Switch: '<S493>/Switch1' incorporates:
                 *  Constant: '<S469>/Constant Value5'
                 *  RelationalOperator: '<S493>/Relational Operator'
                 */
                if (2.0F < rtb_Gain_kd)
                {
                    /* Switch: '<S493>/Switch1' */
                    rtb_Abs_ogo = 2.0F;
                }
                else
                {
                    /* Switch: '<S493>/Switch1' */
                    rtb_Abs_ogo = rtb_Gain_kd;
                }

                /* End of Switch: '<S493>/Switch1' */

                /* Switch: '<S493>/Switch' incorporates:
                 *  Constant: '<S469>/Constant Value4'
                 *  RelationalOperator: '<S493>/Relational Operator1'
                 */
                if (rtb_Abs_ogo > 0.0F)
                {
                    /* Merge: '<S461>/Merge' */
                    rtb_Gain_kd = rtb_Abs_ogo;
                }
                else
                {
                    /* Merge: '<S461>/Merge' */
                    rtb_Gain_kd = 0.0F;
                }

                /* End of Switch: '<S493>/Switch' */
                /* End of Outputs for SubSystem: '<S489>/Limiter2' */
                /* End of Outputs for SubSystem: '<S461>/DmprOpenPC' */
            }

            /* End of If: '<S461>/If' */

            /* DataStoreWrite: '<S461>/Dsw_TorqCancelDsrd2' */
            VeESSR_k_TorqCancelGain_DS = rtb_Gain_kd;

            /* DataStoreWrite: '<S461>/Dsw_STMTmr1' incorporates:
             *  Constant: '<S472>/Calib'
             *  DataStoreRead: '<S461>/Dsr_STMTmr4'
             *  Sum: '<S461>/Summation2'
             */
            VeESSR_t_MainSTMTmr_DS = VeESSR_t_MainSTMTmr_DS + HeESSR_t_MedTEB_dT;

            /* Switch: '<S461>/Switch' incorporates:
             *  Constant: '<S471>/Calib'
             *  Constant: '<S478>/Calib'
             *  DataStoreWrite: '<S461>/Dsw_AEMDMtrBGain'
             */
            if (!HeESSR_b_AEMDMtrBGain)
            {
                VeESSR_scl_AEMDMtrBGain_DS = KeESSR_scl_AEMDMtrBGain_MainStart;
            }

            /* End of Switch: '<S461>/Switch' */

            /* DataStoreWrite: '<S461>/Dsw_AEMDMtrAGain' incorporates:
             *  Constant: '<S477>/Calib'
             */
            VeESSR_scl_AEMDMtrAGain_DS = KeESSR_scl_AEMDMtrAGain_MainStart;

            /* Logic: '<S461>/NOT' */
            rtb_NOT_i = !ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E;

            /* If: '<S461>/If1' incorporates:
             *  Constant: '<S465>/Constant'
             *  Constant: '<S466>/Constant'
             *  Constant: '<S467>/Constant'
             *  Constant: '<S474>/Calib'
             *  Constant: '<S475>/Calib'
             *  DataStoreRead: '<S461>/BmpStrtFailed'
             *  DataStoreRead: '<S461>/Dsr_EngStrtStpMd'
             *  DataStoreRead: '<S461>/Dsr_STMTmr6'
             *  Logic: '<S461>/AND'
             *  Logic: '<S461>/AND1'
             *  Logic: '<S461>/AND2'
             *  Logic: '<S461>/AND4'
             *  Logic: '<S461>/AND5'
             *  RelationalOperator: '<S461>/Equal'
             *  RelationalOperator: '<S461>/Equal1'
             *  RelationalOperator: '<S461>/Equal2'
             *  RelationalOperator: '<S461>/Equal3'
             *  SignalConversion generated from: '<S2>/VeSTRR_e_EngStrtStopType'
             */
            if ((((uint32)ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_E) ==
                    CeSTRR_e_StopImmed) && rtb_NOT_i)
            {
                /* Outputs for IfAction SubSystem: '<S461>/ImmedStop' incorporates:
                 *  ActionPort: '<S473>/Action Port'
                 */
                /* DataStoreWrite: '<S473>/Dsw_STMTrigger1' incorporates:
                 *  Constant: '<S495>/Constant'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_ImmedStopReq;

                /* End of Outputs for SubSystem: '<S461>/ImmedStop' */
            }
            else if ((rtb_NOT_i && (VeESSR_n_TransInSpdFlt >=
                                    VeESSR_n_TgtIdleSpd_DS)) &&
                     (KeESSR_b_EnblStrtStpChngMind))
            {
                /* Outputs for IfAction SubSystem: '<S461>/PrepForStop' incorporates:
                 *  ActionPort: '<S480>/Action Port'
                 */
                /* DataStoreWrite: '<S480>/Dsw_STMTrigger1' incorporates:
                 *  Constant: '<S496>/Constant'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_StopReq;

                /* End of Outputs for SubSystem: '<S461>/PrepForStop' */
            }
            else if (((KeESSR_b_EnblStrtStpChngMind) && (CeESSR_e_EnableFuel ==
                       ((uint32)VeESSR_e_EngStrtStpMd_DS))) && rtb_NOT_i)
            {
                /* Outputs for IfAction SubSystem: '<S461>/DsblFuel' incorporates:
                 *  ActionPort: '<S470>/Action Port'
                 */
                /* DataStoreWrite: '<S470>/Dsw_STMTrigger1' incorporates:
                 *  Constant: '<S494>/Constant'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_StopReq;

                /* DataStoreWrite: '<S470>/Dsw_EngRestartReq' incorporates:
                 *  Constant: '<S470>/TRUE Constant'
                 */
                VeESSR_b_DsblFuelReq_DS = true;

                /* End of Outputs for SubSystem: '<S461>/DsblFuel' */
            }
            else if ((((((uint32)VeESSR_e_EngStrtStpMd_DS) ==
                        CeESSR_e_EngineTorqueStart) && rtb_NOT_i) &&
                      (VeESSR_b_BumpStrtFailed_DS)) &&
                     (KeESSR_b_SpnUpBmpStrtFailEV_Enbl))
            {
                /* Outputs for IfAction SubSystem: '<S461>/CoastDwn' incorporates:
                 *  ActionPort: '<S464>/Action Port'
                 */
                /* DataStoreWrite: '<S464>/Dsw_STMTrigger1' incorporates:
                 *  Constant: '<S483>/Constant'
                 */
                VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

                /* DataStoreWrite: '<S464>/Dsw_EngRestartReq' incorporates:
                 *  Constant: '<S464>/TRUE Constant'
                 */
                VeESSR_b_ETSDsblFuelReq_DS = true;

                /* End of Outputs for SubSystem: '<S461>/CoastDwn' */
            }
            else
            {
                if ((KeESSR_b_EnblStrtStpChngMind) && rtb_NOT_i)
                {
                    /* Outputs for IfAction SubSystem: '<S461>/RampDown' incorporates:
                     *  ActionPort: '<S481>/Action Port'
                     */
                    /* DataStoreWrite: '<S481>/Dsw_STMTrigger1' incorporates:
                     *  Constant: '<S497>/Constant'
                     */
                    VeESSR_e_STMTrigger_DS = CeESSR_e_StopReq;

                    /* DataStoreWrite: '<S481>/Dsw_EngRestartReq' incorporates:
                     *  Constant: '<S481>/TRUE Constant'
                     */
                    VeESSR_b_RmpDwnReq_DS = true;

                    /* End of Outputs for SubSystem: '<S461>/RampDown' */
                }
            }

            /* End of If: '<S461>/If1' */
            /* End of Outputs for SubSystem: '<S176>/MainEngStartDur' */
            (void)Rte_Read_VeENGR_b_GasFlowActuator_Value
                (&rtb_LogicalOperator1_cd);
            (void)Rte_Read_VeESPR_n_EngSpdMaxLim_Value(&rtb_Multiplication1_cp);
            (void)Rte_Read_VeHPMR_e_PropSysMode_Value(&tmpRead);
            switch (ESSR_ac_DW.is_EngStartCtrl)
            {
              case ESSR_ac_IN_AchEngIdle:
                /* Outputs for Function Call SubSystem: '<S554>/ESSC_AchEngIdleDur' */
                /* During 'AchEngIdle': '<S165>:2' */
                /* Event: '<S165>:89' */
                ESSR_ac_ESSC_AchEngIdleDur
                    (ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                     VeESSR_n_OptInputSpd_Local, VeESSR_M_EngTrqAct_Lmtd,
                     ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                     ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                     VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                     &ESSR_ac_DW.ESSC_AchEngIdleDur,
                     &ESSR_ac_PrevZCX.ESSC_AchEngIdleDur);

                /* End of Outputs for SubSystem: '<S554>/ESSC_AchEngIdleDur' */
                break;

              case ESSR_ac_IN_AchEngIdle_12vStrt:
                /* Outputs for Function Call SubSystem: '<S555>/AchIdle_12vStrt_Du' */
                /* During 'AchEngIdle_12vStrt': '<S165>:107' */
                /* Event: '<S165>:113' */
                ESSR_ac_AchIdle_12vStrt_Du
                    (ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                     VeESSR_n_OptInputSpd_Local, VeESSR_M_EngTrqAct_Lmtd,
                     ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                     VeESSR_e_IdleCtrlrSelect_12vStrt,
                     ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                     VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                     &ESSR_ac_DW.AchIdle_12vStrt_Du,
                     &ESSR_ac_PrevZCX.AchIdle_12vStrt_Du);

                /* End of Outputs for SubSystem: '<S555>/AchIdle_12vStrt_Du' */
                break;

              case ESSR_ac_IN_AchEngIdle_BumpStrt:
                /* During 'AchEngIdle_BumpStrt': '<S165>:150' */
                /* Event: '<S165>:162' */
#if Rte_SysCon_Variant_ESSR_P1P2Func

                /* Outputs for Function Call SubSystem: '<S556>/AchIdle_BmpStrt_Du' */
                ESSR_ac_AchIdle_BmpStrt_Du
                    (ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                     VeESSR_M_EngTrqAct_Lmtd,
                     ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                     ESSR_ac_B.LeESSI_M_MtrA_MaxTorq,
                     ESSR_ac_B.LeESSI_M_MtrA_MinTorq,
                     ESSR_ac_B.LeESSI_n_InputSpeedDsrdM2,
                     ESSR_ac_B.TmpSignalConversionAtVeESSR_M_d,
                     ESSR_ac_B.TmpSignalConversionAtVeESMR_P_B,
                     ESSR_ac_B.LeESSI_n_TransMinInputSpd, VeESSR_n_TransInSpdFlt,
                     ESSR_ac_B.LeESSI_n_MtrB_Spd_i,
                     ESSR_ac_B.TmpSignalConversionAtVeETQR_M_e,
                     ESSR_ac_B.LeESSI_e_VldtdTransRngSt,
                     ESSR_ac_B.LeESSI_M_OutputTorqReqImmedHTDR,
                     ESSR_ac_B.LeESSI_M_InputTorqMaxTact_p,
                     &ESSR_ac_B.AchIdle_BmpStrt_Du,
                     &ESSR_ac_DW.AchIdle_BmpStrt_Du);

                /* End of Outputs for SubSystem: '<S556>/AchIdle_BmpStrt_Du' */
#endif

                break;

              case ESSR_ac_IN_AchEngIdle_EMLowPwr:
                /* Outputs for Function Call SubSystem: '<S555>/AchIdle_12vStrt_Du' */
                /* During 'AchEngIdle_EMLowPwr': '<S165>:223' */
                /* Event: '<S165>:113' */
                ESSR_ac_AchIdle_12vStrt_Du
                    (ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                     VeESSR_n_OptInputSpd_Local, VeESSR_M_EngTrqAct_Lmtd,
                     ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                     VeESSR_e_IdleCtrlrSelect_12vStrt,
                     ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                     VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                     &ESSR_ac_DW.AchIdle_12vStrt_Du,
                     &ESSR_ac_PrevZCX.AchIdle_12vStrt_Du);

                /* End of Outputs for SubSystem: '<S555>/AchIdle_12vStrt_Du' */
                break;

              case ESSR_ac_IN_ColdCrank:
                /* During 'ColdCrank': '<S165>:7' */
                if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngSpdTgtAch)
                {
                    /* Transition: '<S165>:32' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_AchEngIdle;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'AchEngIdle': '<S165>:2' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                    /* Outputs for Function Call SubSystem: '<S554>/ESSC_AchEngIdleEnt' */
                    /* Event: '<S165>:88' */
                    ESSR_ac_ESSC_AchEngIdleEnt();

                    /* End of Outputs for SubSystem: '<S554>/ESSC_AchEngIdleEnt' */

                    /* Outputs for Function Call SubSystem: '<S554>/ESSC_AchEngIdleDur' */
                    /* Event: '<S165>:89' */
                    ESSR_ac_ESSC_AchEngIdleDur
                        (ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                         VeESSR_n_OptInputSpd_Local, VeESSR_M_EngTrqAct_Lmtd,
                         ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                         ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                         VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                         &ESSR_ac_DW.ESSC_AchEngIdleDur,
                         &ESSR_ac_PrevZCX.ESSC_AchEngIdleDur);

                    /* End of Outputs for SubSystem: '<S554>/ESSC_AchEngIdleDur' */
                }
                else
                {
                    /* Outputs for Function Call SubSystem: '<S557>/ESSC_ColdCrankDur' */
                    /* RelationalOperator: '<S928>/Equal' incorporates:
                     *  Constant: '<S928>/Constant Value1'
                     *  DataStoreRead: '<S928>/Dsr_STMTmr'
                     */
                    /* Event: '<S165>:91' */
                    rtb_Equal_d = (0.015F > VeESSR_t_STMTmr_DS);

                    /* Outputs for Atomic SubSystem: '<S941>/Lowpass Second Order Enabled' */
                    /* Switch: '<S999>/Switch3' incorporates:
                     *  Switch: '<S999>/Switch1'
                     */
                    if (rtb_Equal_d)
                    {
                        /* Switch: '<S999>/Switch3' */
                        rtb_Switch3_bg =
                            ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I;

                        /* Switch: '<S999>/Switch1' */
                        VeESSR_n_CCTransInSpdFlt =
                            ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I;
                    }
                    else
                    {
                        /* Switch: '<S999>/Switch3' incorporates:
                         *  UnitDelay: '<S999>/x2'
                         */
                        rtb_Switch3_bg = ESSR_ac_DW.x2_DSTATE;

                        /* Product: '<S999>/Multiplication1' incorporates:
                         *  Constant: '<S996>/Calib'
                         *  Lookup_n-D: '<S998>/Vector'
                         *  MinMax: '<S999>/Maximum'
                         *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                         */
                        rtb_Multiplication1_cp = (1.0F / fmaxf
                            (look1_iflf_binlcapw
                             (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                            float32 *)&(KxESSR_K_CCFiltCoefT[0])), ((const
                            float32 *)&(KtESSR_K_CCFiltCoefT[0])), 3U),
                             HeESSR_t_MedTEB_dT)) * HeESSR_t_MedTEB_dT;

                        /* Switch: '<S999>/Switch1' incorporates:
                         *  Constant: '<S997>/Calib'
                         *  Gain: '<S999>/Gain'
                         *  Gain: '<S999>/Gain1'
                         *  Math: '<S999>/Square'
                         *  Product: '<S999>/Multiplication2'
                         *  Product: '<S999>/Multiplication3'
                         *  Sum: '<S999>/Subtraction'
                         *  Sum: '<S999>/Subtraction1'
                         *  Sum: '<S999>/Summation'
                         *  UnitDelay: '<S999>/temp'
                         */
                        VeESSR_n_CCTransInSpdFlt = (((((ESSR_ac_DW.temp_DSTATE -
                            rtb_Switch3_bg) * (2.0F * KeESSR_K_CCFiltCoefD)) *
                            rtb_Multiplication1_cp) + ((rtb_Multiplication1_cp *
                            rtb_Multiplication1_cp) *
                            (ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I -
                             ESSR_ac_DW.temp_DSTATE))) - ESSR_ac_DW.temp_DSTATE)
                            + (2.0F * rtb_Switch3_bg);
                    }

                    /* End of Switch: '<S999>/Switch3' */

                    /* Update for UnitDelay: '<S999>/x2' */
                    ESSR_ac_DW.x2_DSTATE = VeESSR_n_CCTransInSpdFlt;

                    /* Update for UnitDelay: '<S999>/temp' */
                    ESSR_ac_DW.temp_DSTATE = rtb_Switch3_bg;

                    /* End of Outputs for SubSystem: '<S941>/Lowpass Second Order Enabled' */

                    /* Outputs for Atomic SubSystem: '<S928>/ESSC_CC_PowerLimits' */
                    /* Outputs for Atomic SubSystem: '<S963>/Accumulator Reset Limited1' */
                    /* Switch: '<S968>/Switch1' incorporates:
                     *  If: '<S963>/If'
                     *  UnitDelay: '<S963>/Unit Delay'
                     */
                    if (rtb_Equal_d)
                    {
                        /* Switch: '<S968>/Switch1' incorporates:
                         *  Constant: '<S963>/Constant Value3'
                         */
                        VeESSR_M_CCDragAdapt = 0.0F;
                    }
                    else
                    {
                        if (ESSR_ac_DW.UnitDelay_DSTATE_dq)
                        {
                            /* Outputs for IfAction SubSystem: '<S963>/Inc' incorporates:
                             *  ActionPort: '<S971>/Action Port'
                             */
                            /* If: '<S963>/If' incorporates:
                             *  Constant: '<S980>/Calib'
                             *  SignalConversion generated from: '<S971>/Out1'
                             */
                            rtb_Multiplication1_cp = KeESSR_M_CCDragTorqInc;

                            /* End of Outputs for SubSystem: '<S963>/Inc' */
                        }
                        else
                        {
                            /* Outputs for IfAction SubSystem: '<S963>/NoInc' incorporates:
                             *  ActionPort: '<S977>/Action Port'
                             */
                            /* If: '<S963>/If' incorporates:
                             *  Constant: '<S977>/Constant Value2'
                             *  SignalConversion generated from: '<S977>/Out1'
                             */
                            rtb_Multiplication1_cp = 0.0F;

                            /* End of Outputs for SubSystem: '<S963>/NoInc' */
                        }

                        /* Sum: '<S968>/Summation' incorporates:
                         *  UnitDelay: '<S968>/Unit Delay'
                         */
                        rtb_Switch3_bg = rtb_Multiplication1_cp +
                            ESSR_ac_DW.UnitDelay_DSTATE_i;

                        /* Outputs for Atomic SubSystem: '<S968>/Limiter' */
                        /* Switch: '<S978>/Switch1' incorporates:
                         *  Constant: '<S972>/Calib'
                         *  RelationalOperator: '<S978>/Relational Operator'
                         */
                        if (KeESSR_M_CCMaxDragIncTot < rtb_Switch3_bg)
                        {
                            /* Switch: '<S978>/Switch1' */
                            rtb_Switch3_bg = KeESSR_M_CCMaxDragIncTot;
                        }

                        /* End of Switch: '<S978>/Switch1' */

                        /* Switch: '<S978>/Switch' incorporates:
                         *  Constant: '<S963>/Constant Value3'
                         *  RelationalOperator: '<S978>/Relational Operator1'
                         */
                        if (rtb_Switch3_bg > 0.0F)
                        {
                            /* Switch: '<S968>/Switch1' */
                            VeESSR_M_CCDragAdapt = rtb_Switch3_bg;
                        }
                        else
                        {
                            /* Switch: '<S968>/Switch1' */
                            VeESSR_M_CCDragAdapt = 0.0F;
                        }

                        /* End of Switch: '<S978>/Switch' */
                        /* End of Outputs for SubSystem: '<S968>/Limiter' */
                    }

                    /* End of Switch: '<S968>/Switch1' */

                    /* Update for UnitDelay: '<S968>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_i = VeESSR_M_CCDragAdapt;

                    /* End of Outputs for SubSystem: '<S963>/Accumulator Reset Limited1' */

                    /* Lookup_n-D: '<S985>/Vector' incorporates:
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     */
                    VeESSR_n_DsrdCrankSpd = look1_iflf_binlcapw
                        (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                           float32 *)&(KxESSR_n_DsrdCrankSpd[0])), ((const
                           float32 *)&(KtESSR_n_DsrdCrankSpd[0])), 2U);

                    /* Sum: '<S963>/Sum1' */
                    rtb_Switch3_bg = VeESSR_n_CCTransInSpdFlt -
                        VeESSR_n_DsrdCrankSpd;

                    /* Outputs for Atomic SubSystem: '<S963>/Accumulator Reset Limited2' */
                    /* Switch: '<S969>/Switch1' incorporates:
                     *  Logic: '<S963>/Logical3'
                     *  UnitDelay: '<S963>/Unit Delay'
                     */
                    if (rtb_Equal_d || (ESSR_ac_DW.UnitDelay_DSTATE_dq))
                    {
                        /* Switch: '<S969>/Switch1' incorporates:
                         *  Constant: '<S963>/Constant Value2'
                         */
                        VeESSR_n_CCSpdErrIntgl = 0.0F;
                    }
                    else
                    {
                        /* Sum: '<S969>/Summation' incorporates:
                         *  Constant: '<S970>/Calib'
                         *  Product: '<S963>/Product1'
                         *  UnitDelay: '<S969>/Unit Delay'
                         */
                        rtb_Multiplication1_cp = (rtb_Switch3_bg *
                            HeESSR_t_MedTEB_dT) + ESSR_ac_DW.UnitDelay_DSTATE_ka;

                        /* Outputs for Atomic SubSystem: '<S969>/Limiter' */
                        /* Switch: '<S979>/Switch1' incorporates:
                         *  Constant: '<S963>/Constant Value2'
                         *  RelationalOperator: '<S979>/Relational Operator'
                         */
                        if (0.0F < rtb_Multiplication1_cp)
                        {
                            /* Switch: '<S979>/Switch1' */
                            rtb_Multiplication1_cp = 0.0F;
                        }

                        /* End of Switch: '<S979>/Switch1' */

                        /* Switch: '<S979>/Switch' incorporates:
                         *  Constant: '<S974>/Calib'
                         *  RelationalOperator: '<S979>/Relational Operator1'
                         */
                        if (rtb_Multiplication1_cp >
                                KeESSR_n_CCSpdErrAdptIntgrlVal)
                        {
                            /* Switch: '<S969>/Switch1' */
                            VeESSR_n_CCSpdErrIntgl = rtb_Multiplication1_cp;
                        }
                        else
                        {
                            /* Switch: '<S969>/Switch1' */
                            VeESSR_n_CCSpdErrIntgl =
                                KeESSR_n_CCSpdErrAdptIntgrlVal;
                        }

                        /* End of Switch: '<S979>/Switch' */
                        /* End of Outputs for SubSystem: '<S969>/Limiter' */
                    }

                    /* End of Switch: '<S969>/Switch1' */

                    /* Update for UnitDelay: '<S969>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_ka = VeESSR_n_CCSpdErrIntgl;

                    /* End of Outputs for SubSystem: '<S963>/Accumulator Reset Limited2' */

                    /* Switch: '<S960>/Switch1' incorporates:
                     *  Constant: '<S966>/Calib'
                     */
                    if (KeESSR_b_CCUseEngActforHold)
                    {
                        /* Switch: '<S960>/Switch' incorporates:
                         *  Constant: '<S965>/Calib'
                         *  RelationalOperator: '<S960>/Relational Operator'
                         */
                        if (ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o <=
                                KeESSR_M_CCEngFricHoldTq)
                        {
                            rtb_Multiplication1_cp =
                                ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o;
                        }
                        else
                        {
                            rtb_Multiplication1_cp = KeESSR_M_CCEngFricHoldTq;
                        }

                        /* End of Switch: '<S960>/Switch' */
                    }
                    else
                    {
                        rtb_Multiplication1_cp =
                            ESSR_ac_B.TmpSignalConversionAtVeETQR_M_e;
                    }

                    /* End of Switch: '<S960>/Switch1' */

                    /* Sum: '<S960>/Subtraction1' incorporates:
                     *  Constant: '<S964>/Calib'
                     *  MinMax: '<S960>/MinMax'
                     *  Product: '<S960>/Product'
                     *  Sum: '<S960>/Subtraction6'
                     */
                    VeESSR_M_CCDschrgTq = (((VeESSR_n_DsrdCrankSpd - fminf
                        (VeESSR_n_CCTransInSpdFlt, VeESSR_n_DsrdCrankSpd)) *
                                            KeESSR_K_CCHoldTqPGain) +
                                           (VeESSR_M_SpnUpAddtlTorq -
                                            rtb_Multiplication1_cp)) +
                        VeESSR_M_CCDragAdapt;

                    /* Lookup_n-D: '<S986>/Vector' incorporates:
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     */
                    VeESSR_n_CCTargetRunSpd = look1_iflf_binlcapw
                        (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                           float32 *)&(KxESSR_n_TargetRunSpd[0])), ((const
                           float32 *)&(KtESSR_n_TargetRunSpd[0])), 2U);

                    /* Sum: '<S961>/Add' incorporates:
                     *  Constant: '<S982>/Calib'
                     */
                    rtb_Multiplication1_cp = VeESSR_n_CCTargetRunSpd +
                        KeESSR_n_OverRunSpdDelta;

                    /* Lookup_n-D: '<S984>/Vector' incorporates:
                     *  DataStoreWrite: '<S928>/Dsw_EngTrqReqPrdtd1'
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     */
                    VeESSR_M_EngTrqReqPrdtd_DS = look1_iflf_binlcapw
                        (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                           float32 *)&(KxESSR_M_CCEngPrdtdTrq[0])), ((const
                           float32 *)&(KtESSR_M_CCEngPrdtdTrq[0])), 3U);

                    /* Product: '<S961>/Product' incorporates:
                     *  Constant: '<S961>/Constant'
                     */
                    rtb_Gain_kd = VeESSR_P_BatMaxLim * 9549.3F;

                    /* Product: '<S961>/Product1' incorporates:
                     *  Constant: '<S961>/Constant1'
                     */
                    rtb_Abs_ogo = VeESSR_P_BatMinLim * 9549.3F;

                    /* Outputs for Atomic SubSystem: '<S961>/Protected Division' */
                    /* Switch: '<S988>/Switch1' incorporates:
                     *  Constant: '<S988>/Constant Value'
                     *  Constant: '<S988>/Constant Value1'
                     *  Constant: '<S988>/Constant Value2'
                     *  Constant: '<S988>/Constant Value3'
                     *  Logic: '<S988>/AND'
                     *  RelationalOperator: '<S988>/Greater Than or Equal '
                     *  RelationalOperator: '<S988>/Greater Than or Equal 1'
                     *  RelationalOperator: '<S988>/Not Equal'
                     *  RelationalOperator: '<S988>/Not Equal1'
                     *  Switch: '<S988>/Switch2'
                     *  Switch: '<S988>/Switch3'
                     */
                    if ((rtb_Gain_kd != 0.0F) && (VeESSR_n_DsrdCrankSpd != 0.0F))
                    {
                        /* Switch: '<S988>/Switch1' incorporates:
                         *  Product: '<S988>/Division'
                         */
                        VeESSR_M_CCDschrgPowerLimit = rtb_Gain_kd /
                            VeESSR_n_DsrdCrankSpd;
                    }
                    else if (rtb_Gain_kd > 0.0F)
                    {
                        /* Switch: '<S988>/Switch2' incorporates:
                         *  Constant: '<S988>/MAXFLOAT'
                         *  Switch: '<S988>/Switch1'
                         */
                        VeESSR_M_CCDschrgPowerLimit = 3.402823466E+38F;
                    }
                    else if (rtb_Gain_kd < 0.0F)
                    {
                        /* Switch: '<S988>/Switch3' incorporates:
                         *  Constant: '<S988>/MINFLOAT'
                         *  Switch: '<S988>/Switch1'
                         *  Switch: '<S988>/Switch2'
                         */
                        VeESSR_M_CCDschrgPowerLimit = -3.402823466E+38F;
                    }
                    else
                    {
                        /* Switch: '<S988>/Switch1' incorporates:
                         *  Constant: '<S988>/Constant Value4'
                         *  Switch: '<S988>/Switch2'
                         *  Switch: '<S988>/Switch3'
                         */
                        VeESSR_M_CCDschrgPowerLimit = 0.0F;
                    }

                    /* End of Switch: '<S988>/Switch1' */
                    /* End of Outputs for SubSystem: '<S961>/Protected Division' */

                    /* Outputs for Atomic SubSystem: '<S961>/Protected Division1' */
                    /* Switch: '<S989>/Switch1' incorporates:
                     *  Constant: '<S989>/Constant Value'
                     *  Constant: '<S989>/Constant Value1'
                     *  Constant: '<S989>/Constant Value2'
                     *  Constant: '<S989>/Constant Value3'
                     *  Logic: '<S989>/AND'
                     *  RelationalOperator: '<S989>/Greater Than or Equal '
                     *  RelationalOperator: '<S989>/Greater Than or Equal 1'
                     *  RelationalOperator: '<S989>/Not Equal'
                     *  RelationalOperator: '<S989>/Not Equal1'
                     *  Switch: '<S989>/Switch2'
                     *  Switch: '<S989>/Switch3'
                     */
                    if ((rtb_Abs_ogo != 0.0F) && (rtb_Multiplication1_cp != 0.0F))
                    {
                        /* Switch: '<S989>/Switch1' incorporates:
                         *  Product: '<S989>/Division'
                         */
                        VeESSR_M_CCChrgPowerLimit = rtb_Abs_ogo /
                            rtb_Multiplication1_cp;
                    }
                    else if (rtb_Abs_ogo > 0.0F)
                    {
                        /* Switch: '<S989>/Switch2' incorporates:
                         *  Constant: '<S989>/MAXFLOAT'
                         *  Switch: '<S989>/Switch1'
                         */
                        VeESSR_M_CCChrgPowerLimit = 3.402823466E+38F;
                    }
                    else if (rtb_Abs_ogo < 0.0F)
                    {
                        /* Switch: '<S989>/Switch3' incorporates:
                         *  Constant: '<S989>/MINFLOAT'
                         *  Switch: '<S989>/Switch1'
                         *  Switch: '<S989>/Switch2'
                         */
                        VeESSR_M_CCChrgPowerLimit = -3.402823466E+38F;
                    }
                    else
                    {
                        /* Switch: '<S989>/Switch1' incorporates:
                         *  Constant: '<S989>/Constant Value4'
                         *  Switch: '<S989>/Switch2'
                         *  Switch: '<S989>/Switch3'
                         */
                        VeESSR_M_CCChrgPowerLimit = 0.0F;
                    }

                    /* End of Switch: '<S989>/Switch1' */
                    /* End of Outputs for SubSystem: '<S961>/Protected Division1' */

                    /* Update for UnitDelay: '<S963>/Unit Delay' incorporates:
                     *  Constant: '<S973>/Calib'
                     *  Constant: '<S974>/Calib'
                     *  Constant: '<S975>/Calib'
                     *  Logic: '<S963>/Logical'
                     *  RelationalOperator: '<S963>/Comparison1'
                     *  RelationalOperator: '<S963>/Comparison2'
                     */
                    ESSR_ac_DW.UnitDelay_DSTATE_dq = (((KeESSR_b_CCDragAdaptEnab)
                        && (KeESSR_n_CCSpdMinErr > rtb_Switch3_bg)) &&
                        (VeESSR_n_CCSpdErrIntgl <=
                         KeESSR_n_CCSpdErrAdptIntgrlVal));

                    /* End of Outputs for SubSystem: '<S928>/ESSC_CC_PowerLimits' */

                    /* Outputs for Atomic SubSystem: '<S939>/Accumulator Reset Limited' */
                    /* Sum: '<S950>/Sum1' incorporates:
                     *  Constant: '<S954>/Calib'
                     *  Sum: '<S939>/Sum1'
                     *  Switch: '<S939>/Switch'
                     *  Switch: '<S990>/Switch1'
                     */
                    rtb_Switch3_bg = (VeESSR_n_CCTransInSpdFlt -
                                      VeESSR_n_CCTargetRunSpd) -
                        KeESSR_n_CCStateExitSpdDelta;

                    /* End of Outputs for SubSystem: '<S939>/Accumulator Reset Limited' */

                    /* MinMax: '<S935>/MinMax3' incorporates:
                     *  Constant: '<S951>/Calib'
                     *  Constant: '<S952>/Calib'
                     *  Constant: '<S953>/Calib'
                     *  MinMax: '<S935>/MinMax'
                     *  MinMax: '<S935>/MinMax1'
                     *  MinMax: '<S950>/MinMax'
                     *  MinMax: '<S950>/MinMax1'
                     *  Product: '<S950>/Product'
                     *  Product: '<S950>/Product2'
                     *  Sum: '<S935>/Add1'
                     *  Sum: '<S950>/Add'
                     *  Sum: '<S950>/Sum1'
                     */
                    VeESSR_M_MtrSpdCtrl = fminf(fminf
                        (VeESSR_M_CCDschrgPowerLimit, VeESSR_M_CCDschrgTq),
                        fmaxf(VeESSR_M_CCChrgPowerLimit, VeESSR_M_CCDschrgTq -
                              fmaxf(fminf(VeESSR_M_CCDschrgTq,
                                          (VeESSR_n_CCTransInSpdFlt -
                                           KeESSR_n_CCDropMtrATqSpd) *
                                          KeESSR_K_CCDropMtrAZeroPGain),
                                    KeESSR_K_CCRunTqPGain * rtb_Switch3_bg)));

                    /* Outputs for Atomic SubSystem: '<S939>/Accumulator Reset Limited' */
                    /* Switch: '<S990>/Switch1' incorporates:
                     *  Constant: '<S939>/Constant'
                     *  RelationalOperator: '<S939>/Relational Operator'
                     *  Switch: '<S939>/Switch'
                     */
                    if (rtb_Equal_d)
                    {
                        /* Switch: '<S990>/Switch1' incorporates:
                         *  Constant: '<S939>/Constant Value1'
                         */
                        rtb_Multiplication1_cp = 0.0F;
                    }
                    else
                    {
                        if (VeESSR_M_MtrSpdCtrl <= 0.0F)
                        {
                            /* Switch: '<S939>/Switch' incorporates:
                             *  Constant: '<S991>/Calib'
                             *  Product: '<S939>/Product'
                             */
                            rtb_Multiplication1_cp = rtb_Switch3_bg *
                                HeESSR_t_MedTEB_dT;
                        }
                        else
                        {
                            /* Switch: '<S939>/Switch' incorporates:
                             *  Constant: '<S939>/Constant'
                             */
                            rtb_Multiplication1_cp = 0.0F;
                        }

                        /* Sum: '<S990>/Summation' incorporates:
                         *  UnitDelay: '<S990>/Unit Delay'
                         */
                        rtb_Multiplication1_cp += ESSR_ac_DW.UnitDelay_DSTATE_jw;

                        /* Outputs for Atomic SubSystem: '<S990>/Limiter' */
                        /* Switch: '<S995>/Switch1' incorporates:
                         *  Constant: '<S992>/Calib'
                         *  RelationalOperator: '<S995>/Relational Operator'
                         */
                        if (KeESSR_n_CCStateExitIntgrlVal <
                                rtb_Multiplication1_cp)
                        {
                            /* Switch: '<S995>/Switch1' */
                            rtb_Multiplication1_cp =
                                KeESSR_n_CCStateExitIntgrlVal;
                        }

                        /* End of Switch: '<S995>/Switch1' */

                        /* Switch: '<S995>/Switch' incorporates:
                         *  Constant: '<S939>/Constant Value1'
                         *  RelationalOperator: '<S995>/Relational Operator1'
                         */
                        if (rtb_Multiplication1_cp <= 0.0F)
                        {
                            /* Switch: '<S990>/Switch1' */
                            rtb_Multiplication1_cp = 0.0F;
                        }

                        /* End of Switch: '<S995>/Switch' */
                        /* End of Outputs for SubSystem: '<S990>/Limiter' */
                    }

                    /* Update for UnitDelay: '<S990>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_jw = rtb_Multiplication1_cp;

                    /* End of Outputs for SubSystem: '<S939>/Accumulator Reset Limited' */

                    /* Logic: '<S939>/Logical' incorporates:
                     *  Constant: '<S992>/Calib'
                     *  RelationalOperator: '<S939>/Comparison4'
                     */
                    rtb_Equal_d = ((rtb_Multiplication1_cp ==
                                    KeESSR_n_CCStateExitIntgrlVal) &&
                                   (ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E));

                    /* RelationalOperator: '<S928>/Greater  Than1' incorporates:
                     *  Constant: '<S946>/Calib'
                     *  DataStoreRead: '<S928>/Dsr_STMTmr1'
                     */
                    rtb_NOT_i = (VeESSR_t_STMTmr_DS > KeESSR_t_MaxStTmColdCrnk);

                    /* Logic: '<S928>/Logical Operator1' incorporates:
                     *  Logic: '<S928>/Logical Operator'
                     */
                    rtb_LogicalOperator1_cd = ((!rtb_Equal_d) && rtb_NOT_i);

                    /* Switch: '<S928>/Switch' incorporates:
                     *  DataStoreRead: '<S928>/Data Store Read'
                     *  DataStoreWrite: '<S928>/Data Store Write'
                     *  S-Function (sfix_bitop): '<S931>/FixPt Bitwise Operator1'
                     */
                    if (rtb_LogicalOperator1_cd)
                    {
                        ESSR_ac_DW.NeESSR_g_StrtStpFailRsn |= 8U;
                    }

                    /* End of Switch: '<S928>/Switch' */

                    /* MinMax: '<S935>/MinMax2' incorporates:
                     *  Constant: '<S935>/Constant'
                     *  Constant: '<S948>/Calib'
                     *  Product: '<S935>/Product1'
                     *  Sum: '<S950>/Sum1'
                     */
                    VeESSR_M_SprkTorqCtrl_DurRun = fminf(rtb_Switch3_bg *
                        KeESSR_K_EngSprkCtrl, 0.0F);

                    /* Outputs for Atomic SubSystem: '<S928>/ESSC_CC_PowerLimits' */
                    /* Sum: '<S940>/Summation2' incorporates:
                     *  DataStoreWrite: '<S928>/Dsw_EngTrqReqImmed1'
                     *  Lookup_n-D: '<S983>/Vector'
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     */
                    VeESSR_M_EngTrqReqImmed_DS = look1_iflf_binlcapw
                        (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                           float32 *)&(KxESSR_M_CCEngImmedTrq[0])), ((const
                           float32 *)&(KtESSR_M_CCEngImmedTrq[0])), 3U) +
                        VeESSR_M_SprkTorqCtrl_DurRun;

                    /* End of Outputs for SubSystem: '<S928>/ESSC_CC_PowerLimits' */

                    /* DataStoreWrite: '<S928>/Dsw_InputSpeedProfile' */
                    VeESSR_n_InputSpeedProfile_DS =
                        ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I;

                    /* Switch: '<S956>/Switch1' incorporates:
                     *  DataStoreRead: '<S928>/Dsr_STMTmr2'
                     *  Lookup_n-D: '<S958>/Vector'
                     */
                    rtb_Multiplication1_cp = look1_iflf_binlcapw
                        (VeESSR_t_STMTmr_DS, ((const float32 *)
                          &(KxESSR_r_CCTiRamp[0])), ((const float32 *)
                          &(KtESSR_r_CCTiRamp[0])), 15U);

                    /* Gain: '<S928>/Negation' incorporates:
                     *  Constant: '<S937>/Constant Value5'
                     *  DataStoreRead: '<S928>/Dsr_InputTorqEst'
                     *  DataStoreWrite: '<S928>/Dsw_InputTorqEst1'
                     *  Gain: '<S937>/Negation'
                     *  Product: '<S937>/Multiplication'
                     *  Product: '<S937>/Multiplication1'
                     *  Sum: '<S937>/Subtraction'
                     *  Sum: '<S937>/Summation'
                     */
                    VeESSR_M_EngTorqEst_DS = -(((1.0F - rtb_Multiplication1_cp) *
                        (-VeESSR_M_EngTorqEstTmp_DS)) + (VeESSR_M_MtrSpdCtrl *
                        rtb_Multiplication1_cp));

                    /* DataStoreWrite: '<S928>/Dsw_STMTmr' incorporates:
                     *  Constant: '<S942>/Calib'
                     *  DataStoreRead: '<S928>/Dsr_STMTmr'
                     *  Sum: '<S928>/Summation1'
                     */
                    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

                    /* Logic: '<S928>/Logical Operator2' incorporates:
                     *  DataStoreRead: '<S928>/BmpStrtFailed'
                     *  Logic: '<S928>/Logical Operator3'
                     */
                    VeESSR_b_SpnUpLowPwrFail = ((!VeESSR_b_BumpStrtFailed_DS) &&
                        rtb_NOT_i);

                    /* Switch: '<S943>/Switch1' incorporates:
                     *  Constant: '<S933>/Constant'
                     *  DataStoreWrite: '<S928>/Dsw_STMTrigger'
                     *  Switch: '<S943>/Switch2'
                     */
                    if (rtb_Equal_d)
                    {
                        VeESSR_e_STMTrigger_DS = CeESSR_e_EngSpdTgtAch;
                    }
                    else
                    {
                        if (VeESSR_b_SpnUpLowPwrFail)
                        {
                            /* Switch: '<S943>/Switch1' incorporates:
                             *  Constant: '<S934>/Constant'
                             *  DataStoreWrite: '<S928>/Dsw_STMTrigger'
                             *  Switch: '<S943>/Switch2'
                             */
                            VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;
                        }
                    }

                    /* End of Switch: '<S943>/Switch1' */

                    /* If: '<S928>/If1' */
                    if (rtb_LogicalOperator1_cd)
                    {
                        /* Outputs for IfAction SubSystem: '<S928>/If_ColdCrank_P1C65' incorporates:
                         *  ActionPort: '<S945>/Action Port'
                         */
                        /* DataStoreWrite: '<S928>/Dsw_StrtStpFailDTC' */
                        ESSR_ac_If_AutoStrt_P1C65((&(VeESSR_e_StrtStpFailDTC)));

                        /* End of Outputs for SubSystem: '<S928>/If_ColdCrank_P1C65' */
                    }
                    else
                    {
                        /* Outputs for IfAction SubSystem: '<S928>/If_ColdCrank_NoFault' incorporates:
                         *  ActionPort: '<S944>/Action Port'
                         */
                        /* DataStoreWrite: '<S928>/Dsw_StrtStpFailDTC' */
                        ESSR_ac_If_AutoStrt_NoFault((&(VeESSR_e_StrtStpFailDTC)));

                        /* End of Outputs for SubSystem: '<S928>/If_ColdCrank_NoFault' */
                    }

                    /* End of If: '<S928>/If1' */

                    /* Switch: '<S928>/Switch4' incorporates:
                     *  Constant: '<S928>/Constant Value'
                     *  DataStoreRead: '<S928>/Dsr_EngTrqRespType2'
                     *  DataStoreRead: '<S928>/Dsr_EngTrqRespType6'
                     *  DataStoreWrite: '<S928>/Dsw_StrtStpFailDTC1'
                     *  Logic: '<S928>/Logical21'
                     *  RelationalOperator: '<S928>/Comparison'
                     *  S-Function (sfix_bitop): '<S928>/Bitwise Operator'
                     *  S-Function (sfix_bitop): '<S932>/FixPt Bitwise Operator1'
                     */
                    if (rtb_LogicalOperator1_cd &&
                            ((VeESSR_g_StrtStpFailPhaseSelect_DS & 256U) > 0U))
                    {
                        VeESSR_g_StrtStpFailPhase_DS =
                            VeESSR_g_StrtStpFailPhase_DS | 256U;
                    }

                    /* End of Switch: '<S928>/Switch4' */

                    /* Product: '<S936>/Product' incorporates:
                     *  DataStoreRead: '<S936>/Dsr_STMTmr3'
                     *  Lookup_n-D: '<S955>/Vector'
                     */
                    rtb_Switch3_bg = look1_iflf_binlcapw(VeESSR_t_STMTmr_DS, ((
                        const float32 *)&(KxESSR_K_CCNiDotGain[0])), ((const
                        float32 *)&(KtESSR_K_CCNiDotGain[0])), 16U) *
                        VeESSR_n_DsrdCrankSpd;

                    /* Outputs for Atomic SubSystem: '<S936>/Limiter' */
                    /* Switch: '<S956>/Switch1' incorporates:
                     *  DataStoreRead: '<S936>/Dsr_NiProfGenNiDMax'
                     *  RelationalOperator: '<S956>/Relational Operator'
                     */
                    if (VeESSR_dn_StrtTypNiDotMax_DS < rtb_Switch3_bg)
                    {
                        /* Switch: '<S956>/Switch1' */
                        rtb_Multiplication1_cp = VeESSR_dn_StrtTypNiDotMax_DS;
                    }
                    else
                    {
                        /* Switch: '<S956>/Switch1' */
                        rtb_Multiplication1_cp = rtb_Switch3_bg;
                    }

                    /* End of Switch: '<S956>/Switch1' */

                    /* Switch: '<S956>/Switch' incorporates:
                     *  DataStoreRead: '<S936>/Dsr_NiProfGenNiDMin'
                     *  DataStoreWrite: '<S936>/Dsw_InputAcceltnProf'
                     *  RelationalOperator: '<S956>/Relational Operator1'
                     */
                    if (rtb_Multiplication1_cp > VeESSR_dn_StrtTypNiDotMin_DS)
                    {
                        VeESSR_dn_InputAcceltnProf_DS = rtb_Multiplication1_cp;
                    }
                    else
                    {
                        VeESSR_dn_InputAcceltnProf_DS =
                            VeESSR_dn_StrtTypNiDotMin_DS;
                    }

                    /* End of Switch: '<S956>/Switch' */
                    /* End of Outputs for SubSystem: '<S936>/Limiter' */
                    /* End of Outputs for SubSystem: '<S557>/ESSC_ColdCrankDur' */
                }
                break;

              case ESSR_ac_IN_ESSC_SpinUp_CS:
                /* During 'ESSC_SpinUp_CS': '<S165>:184' */
                if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngSpdTgtAch)
                {
                    /* Transition: '<S165>:189' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_ESSC_StartEng_CS;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'ESSC_StartEng_CS': '<S165>:188' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Event: '<S165>:192' */
                    /* Event: '<S165>:193' */
#if Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* Outputs for Function Call SubSystem: '<S571>/StartEngCS_Ent' */
                    /* MinMax: '<S2231>/MinMax1' incorporates:
                     *  DataStoreRead: '<S2231>/Dsr_InputSpeedProfile2'
                     *  DataStoreRead: '<S2231>/Dsr_StrtTypInitImmedTorq'
                     *  DataStoreWrite: '<S2231>/Dsw_EngTrqReqImmed'
                     *  Lookup_n-D: '<S2294>/Vector'
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     *  Sum: '<S2231>/Sum1'
                     *  Sum: '<S2231>/Sum2'
                     */
                    VeESSR_M_EngTrqReqImmed_DS = fminf
                        (ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o +
                         VeESSR_M_MinImmedExitTorqDelta_DS,
                         VeESSR_M_StrtTypInitImmedTorq_DS - look1_iflf_binlcapw
                         (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                            float32 *)&(KxESSR_M_StrtEngCSInitImmedTorq_ECT[0])),
                          ((const float32 *)
                           &(KtESSR_M_StrtEngCSInitImmedTorq_ECT[0])), 2U));

                    /* DataStoreWrite: '<S2231>/Dsw_InputAcceltnProf' incorporates:
                     *  Constant: '<S2231>/Constant Value1'
                     */
                    VeESSR_phi_CombstDelay_DS = 0.0F;

                    /* DataStoreWrite: '<S2231>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
                     *  Constant: '<S2231>/Constant Value2'
                     */
                    VeESSR_M_MtrA_MaxTorq_DS = 0.0F;

                    /* DataStoreWrite: '<S2231>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
                     *  Constant: '<S2231>/Constant Value2'
                     */
                    VeESSR_M_MtrA_MinTorq_DS = 0.0F;

                    /* DataStoreWrite: '<S2231>/Dsw_AEMDMtrBGain' incorporates:
                     *  Constant: '<S2293>/Calib'
                     */
                    VeESSR_scl_AEMDMtrBGain_DS =
                        KeESSR_scl_AEMDMtrBGain_StrtEngClSt;

                    /* DataStoreWrite: '<S2231>/Dsw_EngCntrlMode_DS' incorporates:
                     *  Constant: '<S2291>/Constant'
                     */
                    VeESSR_e_EngCntrlMode_DS = CeTRAR_e_SpeedMode;

                    /* DataStoreWrite: '<S2231>/Dsw_EngStartStopSt' incorporates:
                     *  Constant: '<S2288>/Constant'
                     */
                    VeESSR_e_EngStartStopSt_DS = CeESSR_e_StrtEngClStrtSt;

                    /* DataStoreWrite: '<S2231>/Dsw_EngStrtStpMd2' incorporates:
                     *  Constant: '<S2292>/Constant'
                     */
                    VeESSR_e_EngStrtStpMd_DS = CeESSR_e_EnableFuel;

                    /* DataStoreWrite: '<S2231>/Dsw_EngStrtType1' incorporates:
                     *  Constant: '<S2290>/Constant'
                     */
                    VeESSR_e_TCM_StartStopType_DS = CeESSR_e_CltchStrt;

                    /* DataStoreWrite: '<S2231>/Dsw_EngTrqRespType' incorporates:
                     *  DataStoreRead: '<S2231>/VeESSR_e_StrtStpTypEngTorqRespType_DS'
                     */
                    VeESSR_e_EngTrqRespType_DS =
                        VeESSR_e_StrtStpTypEngTorqRespType_DS;

                    /* DataStoreWrite: '<S2231>/Dsw_StrtStpFailDTC' incorporates:
                     *  Constant: '<S2289>/Constant'
                     */
                    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

                    /* End of Outputs for SubSystem: '<S571>/StartEngCS_Ent' */

                    /* Outputs for Function Call SubSystem: '<S571>/StartEngCS_Dur' */
                    ESSR_ac_StartEngCS_Dur(VeESSR_M_EngTrqAct_Lmtd,
                                           ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                                           ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                           ESSR_ac_B.TmpSignalConversionAtVeESSR_M_d,
                                           ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                                           ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p,
                                           ESSR_ac_B.TmpSignalConversionAtEngineLoss,
                                           ESSR_ac_B.TmpSignalConversionAtVeENGR_e_E,
                                           VeESSR_n_TransInSpdFlt,
                                           ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                                           ESSR_ac_B.LeESSI_M_Clch1_TrqEst_In,
                                           ESSR_ac_B.LeESSI_M_Clch3_TrqEst_In,
                                           ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I,
                                           VeESSR_b_ClthErlyExitLmp,
                                           &ESSR_ac_DW.StartEngCS_Dur,
                                           &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                    /* End of Outputs for SubSystem: '<S571>/StartEngCS_Dur' */
#endif

                }
                else
                {
                    /* Event: '<S165>:191' */
#if Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* Outputs for Function Call SubSystem: '<S567>/SpinUp_CS_Dur' */
                    ESSR_ac_SpinUp_CS_Dur(VeESSR_M_EngTrqAct_Lmtd,
                                          VeESSR_M_SpnUpAddtlTorq,
                                          VeESSR_n_TransInSpdFlt,
                                          ESSR_ac_B.TmpSignalConversionAtVeESSR__no,
                                          ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                          ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p,
                                          ESSR_ac_B.TmpSignalConversionAtEngineLoss,
                                          ESSR_ac_B.TmpSignalConversionAtVeENGR_p_E,
                                          VeESSR_b_ClthLwrThresLmp,
                                          VeESSR_b_ClthErlyExitLmp,
                                          &ESSR_ac_DW.SpinUp_CS_Dur,
                                          &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                    /* End of Outputs for SubSystem: '<S567>/SpinUp_CS_Dur' */
#endif

                }
                break;

              case ESSR_ac_IN_ESSC_SpinUp_EM:
                /* During 'ESSC_SpinUp_EM': '<S165>:197' */
                if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngSpdTgtAch)
                {
                    /* Transition: '<S165>:205' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_ESSC_StartEng_EM;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'ESSC_StartEng_EM': '<S165>:200' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Event: '<S165>:210' */
                    /* Event: '<S165>:211' */
#if Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* Outputs for Function Call SubSystem: '<S572>/StartEng_EM_Ent' */
                    /* MinMax: '<S2298>/MinMax1' incorporates:
                     *  DataStoreRead: '<S2298>/Dsr_InputSpeedProfile2'
                     *  DataStoreRead: '<S2298>/Dsr_StrtTypInitImmedTorq'
                     *  DataStoreWrite: '<S2298>/Dsw_EngTrqReqImmed'
                     *  Lookup_n-D: '<S2444>/Vector'
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     *  Sum: '<S2298>/Sum1'
                     *  Sum: '<S2298>/Sum2'
                     */
                    VeESSR_M_EngTrqReqImmed_DS = fminf
                        (ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o +
                         VeESSR_M_MinImmedExitTorqDelta_DS,
                         VeESSR_M_StrtTypInitImmedTorq_DS - look1_iflf_binlcapw
                         (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                            float32 *)&(KxESSR_M_InitImmedTorq_ECT[0])), ((const
                            float32 *)&(KtESSR_M_InitImmedTorq_ECT[0])), 2U));

                    /* Switch: '<S2298>/Switch' incorporates:
                     *  Constant: '<S2298>/Constant Value3'
                     *  Constant: '<S2443>/Calib'
                     *  DataStoreWrite: '<S2298>/Data Store Write1'
                     */
                    if (!HeESSR_b_EngStrtTorq)
                    {
                        VeESSR_M_EngStrtTorq_DS = 0.0F;
                    }

                    /* End of Switch: '<S2298>/Switch' */

                    /* DataStoreWrite: '<S2298>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
                     *  Constant: '<S2298>/Constant Value4'
                     */
                    VeESSR_M_MtrA_MaxTorq_DS = 0.0F;

                    /* DataStoreWrite: '<S2298>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
                     *  Constant: '<S2298>/Constant Value4'
                     */
                    VeESSR_M_MtrA_MinTorq_DS = 0.0F;

                    /* DataStoreWrite: '<S2298>/Dsw_EngCntrlMode_DS' incorporates:
                     *  Constant: '<S2440>/Constant'
                     */
                    VeESSR_e_EngCntrlMode_DS = CeTRAR_e_SpeedMode;

                    /* DataStoreWrite: '<S2298>/Dsw_EngStartStopSt' incorporates:
                     *  Constant: '<S2437>/Constant'
                     */
                    VeESSR_e_EngStartStopSt_DS = CeESSR_e_StrtEngEMStrtSt;

                    /* DataStoreWrite: '<S2298>/Dsw_EngStrtStpMd2' incorporates:
                     *  Constant: '<S2441>/Constant'
                     */
                    VeESSR_e_EngStrtStpMd_DS = CeESSR_e_EnableFuel;

                    /* DataStoreWrite: '<S2298>/Dsw_EngStrtType1' incorporates:
                     *  Constant: '<S2439>/Constant'
                     */
                    VeESSR_e_TCM_StartStopType_DS = CeESSR_e_EMStrt;

                    /* DataStoreWrite: '<S2298>/Dsw_EngStrtType2' incorporates:
                     *  Constant: '<S2442>/Constant'
                     */
                    VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Cranking;

                    /* DataStoreWrite: '<S2298>/Dsw_EngTrqRespType' incorporates:
                     *  DataStoreRead: '<S2298>/VeESSR_e_StrtStpTypEngTorqRespType_DS'
                     */
                    VeESSR_e_EngTrqRespType_DS =
                        VeESSR_e_StrtStpTypEngTorqRespType_DS;

                    /* DataStoreWrite: '<S2298>/Dsw_InhibitShiftToMode' incorporates:
                     *  Constant: '<S2298>/FALSE Constant'
                     */
                    VeESSR_b_InhibitShiftToMode_DS = false;

                    /* DataStoreWrite: '<S2298>/Dsw_StrtStpFailDTC' incorporates:
                     *  Constant: '<S2438>/Constant'
                     */
                    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

                    /* End of Outputs for SubSystem: '<S572>/StartEng_EM_Ent' */

                    /* Outputs for Function Call SubSystem: '<S572>/StartEng_EM_Dur' */
                    ESSR_ac_StartEng_EM_Dur(VeESSR_M_EngStrtTorqSnsd,
                                            ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                                            ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                            ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I,
                                            ESSR_ac_B.TmpSignalConversionAtVeESSR_M_d,
                                            ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                                            ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p,
                                            ESSR_ac_B.TmpSignalConversionAtEngineLoss,
                                            ESSR_ac_B.TmpSignalConversionAtVeENGR_e_E,
                                            VeESSR_n_TransInSpdFlt,
                                            ESSR_ac_B.TmpSignalConversionAtVeOHSR_n_I,
                                            ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                                            ESSR_ac_B.LeESSI_n_MtrB_Spd,
                                            ESSR_ac_B.TmpSignalConversionAtVeETQR_M_e,
                                            ESSR_ac_B.LeESSI_M_InputTorqMaxTact,
                                            ESSR_ac_B.LeESSI_M_MtrB_TorqCmnd,
                                            VeESSR_dn_NiDotMax,
                                            VeESSR_dn_NiDotMin,
                                            VeESSR_b_EMErlyExitLmp,
                                            ESSR_ac_B.LeESSI_e_RngSt,
                                            VeESSR_M_TiEstMin,
                                            &ESSR_ac_DW.StartEng_EM_Dur,
                                            &ESSR_ac_PrevZCX.StartEng_EM_Dur,
                                            &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                    /* End of Outputs for SubSystem: '<S572>/StartEng_EM_Dur' */
#endif

                }
                else
                {
                    /* Event: '<S165>:209' */
#if Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* Outputs for Function Call SubSystem: '<S568>/ESSC_SpinUp_EM_Dur' */
                    ESSR_ac_ESSC_SpinUp_EM_Dur(VeESSR_M_EngTrqAct_Lmtd,
                        VeESSR_M_SpnUpAddtlTorq, VeESSR_n_TransInSpdFlt,
                        ESSR_ac_B.TmpSignalConversionAtVeESSR__no,
                        ESSR_ac_B.TmpSignalConversionAtVeHVTR_U_H,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                        ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p,
                        ESSR_ac_B.TmpSignalConversionAtEngineLoss,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_p_E,
                        ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I,
                        ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                        VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                        VeESSR_b_EMErlyExitLmp, VeESSR_M_TiEstMin,
                        &ESSR_ac_DW.ESSC_SpinUp_EM_Dur,
                        &ESSR_ac_PrevZCX.ESSC_SpinUp_EM_Dur,
                        &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                    /* End of Outputs for SubSystem: '<S568>/ESSC_SpinUp_EM_Dur' */
#endif

                }
                break;

              case ESSR_ac_IN_ESSC_SpinUp_EMLowPwr:
                /* During 'ESSC_SpinUp_EMLowPwr': '<S165>:226' */
                if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngSpdTgtAch)
                {
                    /* Transition: '<S165>:228' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_AchEngIdle_EMLowPwr;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'AchEngIdle_EMLowPwr': '<S165>:223' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                    /* Outputs for Function Call SubSystem: '<S555>/AchIdle_12vStrt_En' */
                    /* Event: '<S165>:112' */
                    ESSR_ac_AchIdle_12vStrt_En
                        (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_F, tmpRead);

                    /* End of Outputs for SubSystem: '<S555>/AchIdle_12vStrt_En' */

                    /* Outputs for Function Call SubSystem: '<S555>/AchIdle_12vStrt_Du' */
                    /* Event: '<S165>:113' */
                    ESSR_ac_AchIdle_12vStrt_Du
                        (ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                         VeESSR_n_OptInputSpd_Local, VeESSR_M_EngTrqAct_Lmtd,
                         ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                         VeESSR_e_IdleCtrlrSelect_12vStrt,
                         ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                         VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                         &ESSR_ac_DW.AchIdle_12vStrt_Du,
                         &ESSR_ac_PrevZCX.AchIdle_12vStrt_Du);

                    /* End of Outputs for SubSystem: '<S555>/AchIdle_12vStrt_Du' */
                }
                else
                {
                    /* Event: '<S165>:232' */
#if Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* Outputs for Function Call SubSystem: '<S564>/SpinUp_EMLowPwr_Du' */
                    ESSR_ac_SpinUp_EMLowPwr_Du(VeESSR_n_TransInSpdFlt,
                        ESSR_ac_B.LeESSI_M_MtrB_TorqCmnd_o,
                        ESSR_ac_B.TmpSignalConversionAtVeOHSR_n_I,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                        VeESSR_M_TiEstMin,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                        &ESSR_ac_DW.SpinUp_EMLowPwr_Du,
                        &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                    /* End of Outputs for SubSystem: '<S564>/SpinUp_EMLowPwr_Du' */
#endif

                }
                break;

              case ESSR_ac_IN_ESSC_StartEng_CS:
                /* During 'ESSC_StartEng_CS': '<S165>:188' */
                /* Event: '<S165>:193' */
#if Rte_SysCon_Variant_ESSR_P1P2p5Func

                /* Outputs for Function Call SubSystem: '<S571>/StartEngCS_Dur' */
                ESSR_ac_StartEngCS_Dur(VeESSR_M_EngTrqAct_Lmtd,
                                       ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                                       ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                       ESSR_ac_B.TmpSignalConversionAtVeESSR_M_d,
                                       ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                                       ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p,
                                       ESSR_ac_B.TmpSignalConversionAtEngineLoss,
                                       ESSR_ac_B.TmpSignalConversionAtVeENGR_e_E,
                                       VeESSR_n_TransInSpdFlt,
                                       ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                                       ESSR_ac_B.LeESSI_M_Clch1_TrqEst_In,
                                       ESSR_ac_B.LeESSI_M_Clch3_TrqEst_In,
                                       ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I,
                                       VeESSR_b_ClthErlyExitLmp,
                                       &ESSR_ac_DW.StartEngCS_Dur,
                                       &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                /* End of Outputs for SubSystem: '<S571>/StartEngCS_Dur' */
#endif

                break;

              case ESSR_ac_IN_ESSC_StartEng_EM:
                /* During 'ESSC_StartEng_EM': '<S165>:200' */
                /* Event: '<S165>:211' */
#if Rte_SysCon_Variant_ESSR_P1P2p5Func

                /* Outputs for Function Call SubSystem: '<S572>/StartEng_EM_Dur' */
                ESSR_ac_StartEng_EM_Dur(VeESSR_M_EngStrtTorqSnsd,
                                        ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                        ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I,
                                        ESSR_ac_B.TmpSignalConversionAtVeESSR_M_d,
                                        ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                                        ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p,
                                        ESSR_ac_B.TmpSignalConversionAtEngineLoss,
                                        ESSR_ac_B.TmpSignalConversionAtVeENGR_e_E,
                                        VeESSR_n_TransInSpdFlt,
                                        ESSR_ac_B.TmpSignalConversionAtVeOHSR_n_I,
                                        ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                                        ESSR_ac_B.LeESSI_n_MtrB_Spd,
                                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_e,
                                        ESSR_ac_B.LeESSI_M_InputTorqMaxTact,
                                        ESSR_ac_B.LeESSI_M_MtrB_TorqCmnd,
                                        VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                                        VeESSR_b_EMErlyExitLmp,
                                        ESSR_ac_B.LeESSI_e_RngSt,
                                        VeESSR_M_TiEstMin,
                                        &ESSR_ac_DW.StartEng_EM_Dur,
                                        &ESSR_ac_PrevZCX.StartEng_EM_Dur,
                                        &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                /* End of Outputs for SubSystem: '<S572>/StartEng_EM_Dur' */
#endif

                break;

              case ESSR_ac_IN_InitEngSpin_1:
                /* During 'InitEngSpin_1': '<S165>:10' */
                if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngBrkawayAch)
                {
                    /* Transition: '<S165>:27' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_SpinUpEng_SFS;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'SpinUpEng_SFS': '<S165>:11' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                    /* Outputs for Function Call SubSystem: '<S565>/SpinUpEng_SFS_Ent' */
                    /* Event: '<S165>:82' */
                    ESSR_ac_SpinUpEng_SFS_Ent();

                    /* End of Outputs for SubSystem: '<S565>/SpinUpEng_SFS_Ent' */

                    /* Outputs for Function Call SubSystem: '<S565>/SpinUpEng_SFS_Dur' */
                    /* Event: '<S165>:83' */
                    ESSR_ac_SpinUpEng_SFS_Dur(VeESSR_M_EngTrqAct_Lmtd,
                        VeESSR_M_SpnUpAddtlTorq, VeESSR_n_TransInSpdFlt,
                        VeESSR_n_OptInputSpd_Local,
                        ESSR_ac_B.TmpSignalConversionAtVeESSR__no,
                        ESSR_ac_B.TmpSignalConversionAtVeVSDR_n_P,
                        rtb_Multiplication1_cp,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_e_g,
                        ESSR_ac_B.TmpSignalConversionAtVeHVTR_U_H,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                        ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p,
                        ESSR_ac_B.TmpSignalConversionAtEngineLoss,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_p_E,
                        ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I,
                        ESSR_ac_B.TmpSignalConversionAtVeBPDR_b_P,
                        ESSR_ac_B.TmpSignalConversionAtVeBCPR_b_P,
                        ESSR_ac_B.TmpSignalConversionAtVeTISR_n_N,
                        ESSR_ac_B.TmpSignalConversionAtVeOHSR_n_I,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d,
                        ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                        VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_e,
                        VeESSR_b_ErlyExitLmp, VeESSR_b_LwrThresLmp,
                        VeESSR_M_TiEstMin,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_E,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_b_P,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_P,
                        ESSR_ac_B.TmpSignalConversionAtVeOITR_M_I,
                        rtb_LogicalOperator1_cd, &ESSR_ac_DW.SpinUpEng_SFS_Dur,
                        &ESSR_ac_PrevZCX.SpinUpEng_SFS_Dur,
                        &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn,
                        &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn2,
                        &ESSR_ac_DW.VeESSR_t_StrtTypGasFlwActrDlyTm);

                    /* End of Outputs for SubSystem: '<S565>/SpinUpEng_SFS_Dur' */
                }
                else
                {
                    /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinDur' */
                    /* RelationalOperator: '<S1022>/Equal2' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr'
                     */
                    /* Event: '<S165>:81' */
                    rtb_NOT_i = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

                    /* Switch: '<S1078>/Switch1' incorporates:
                     *  Constant: '<S1033>/Constant Value5'
                     *  UnitDelay: '<S1078>/Unit Delay'
                     */
                    if (rtb_NOT_i)
                    {
                        rtb_Multiplication1_cp = 0.0F;
                    }
                    else
                    {
                        rtb_Multiplication1_cp = ESSR_ac_DW.UnitDelay_DSTATE_iu;
                    }

                    /* Sum: '<S1033>/Sum' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitSpinScaler'
                     *  Product: '<S1022>/Product'
                     */
                    rtb_Switch3_bg = (HeESSR_t_MedTEB_dT *
                                      VeESSR_k_StrtTypInitSpinScaler_DS) +
                        rtb_Multiplication1_cp;

                    /* Outputs for Atomic SubSystem: '<S1033>/Limiter' */
                    /* Switch: '<S1077>/Switch1' incorporates:
                     *  DataStoreRead: '<S1033>/Dsr_StrtTypInitSpinEndPnt'
                     *  RelationalOperator: '<S1077>/Relational Operator'
                     */
                    if (VeESSR_Cnt_StrtTypInitSpinEndPnt_DS < rtb_Switch3_bg)
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;
                    }
                    else
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = rtb_Switch3_bg;
                    }

                    /* Switch: '<S1077>/Switch' incorporates:
                     *  Constant: '<S1033>/Constant Value1'
                     *  RelationalOperator: '<S1077>/Relational Operator1'
                     */
                    if (rtb_Gain_kd > 0.0F)
                    {
                        /* Switch: '<S1077>/Switch' */
                        VeESSR_Cnt_InitSpnStepPt = rtb_Gain_kd;
                    }
                    else
                    {
                        /* Switch: '<S1077>/Switch' */
                        VeESSR_Cnt_InitSpnStepPt = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1033>/Limiter' */

                    /* RelationalOperator: '<S1034>/Greater  Than2' incorporates:
                     *  DataStoreRead: '<S1034>/Dsr_StrtTypInitSpinEndPnt'
                     */
                    VeESSR_b_InitSpnTmrCmplt = (VeESSR_Cnt_InitSpnStepPt >=
                        VeESSR_Cnt_StrtTypInitSpinEndPnt_DS);

                    /* Outputs for Atomic SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */
                    /* Switch: '<S1058>/Switch' */
                    if (rtb_NOT_i)
                    {
                        /* Switch: '<S1058>/Switch' incorporates:
                         *  Constant: '<S1029>/Constant Value4'
                         */
                        rtb_Multiplication1_cp = 0.0F;
                    }
                    else
                    {
                        /* Switch: '<S1058>/Switch' incorporates:
                         *  Constant: '<S1029>/Cnvrt2Deg'
                         *  Constant: '<S1057>/Calib'
                         *  Product: '<S1058>/Division'
                         *  Product: '<S1058>/Multiplication'
                         *  Sum: '<S1058>/Sum//Sub'
                         *  UnitDelay: '<S1058>/Unit Delay'
                         */
                        rtb_Multiplication1_cp = ((HeESSR_t_MedTEB_dT /
                            0.166666672F) *
                            ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I) +
                            ESSR_ac_DW.UnitDelay_DSTATE_e;
                    }

                    /* Outputs for Atomic SubSystem: '<S1058>/Limiter' */
                    /* Switch: '<S1061>/Switch1' incorporates:
                     *  Constant: '<S1029>/Constant Value1'
                     *  RelationalOperator: '<S1061>/Relational Operator'
                     */
                    if (999.0F < rtb_Multiplication1_cp)
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = 999.0F;
                    }
                    else
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = rtb_Multiplication1_cp;
                    }

                    /* Switch: '<S1061>/Switch' incorporates:
                     *  Constant: '<S1029>/Constant Value'
                     *  RelationalOperator: '<S1061>/Relational Operator1'
                     */
                    if (rtb_Gain_kd <= 0.0F)
                    {
                        /* Switch: '<S1061>/Switch' */
                        rtb_Gain_kd = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1058>/Limiter' */

                    /* Update for UnitDelay: '<S1058>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_e = rtb_Gain_kd;

                    /* End of Outputs for SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */

                    /* Switch: '<S1070>/Switch1' incorporates:
                     *  Constant: '<S1029>/Constant Value3'
                     *  DataStoreRead: '<S1029>/Dsr_STMTmr3'
                     *  Product: '<S1060>/Division'
                     *  Sum: '<S1029>/Subtraction'
                     */
                    rtb_Multiplication1_cp =
                        (ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi -
                         VeESSR_phi_InitEngAng720_DS) / 720.0F;

                    /* Logic: '<S1029>/AND' incorporates:
                     *  Constant: '<S1029>/Constant Value3'
                     *  DataStoreRead: '<S1029>/Dsr_STMTmr1'
                     *  Product: '<S1060>/Multiplication'
                     *  RelationalOperator: '<S1029>/Greater  Than1'
                     *  RelationalOperator: '<S1029>/Greater  Than2'
                     *  Rounding: '<S1060>/Floor'
                     *  Sum: '<S1060>/Subtraction'
                     */
                    VeESSR_b_InitSpnEngMvmntDet = ((rtb_Gain_kd >
                        VeESSR_phi_StrtTypInitSpinBrkAng_DS) ||
                        (((rtb_Multiplication1_cp - roundf
                           (rtb_Multiplication1_cp)) * 720.0F) >
                         VeESSR_phi_StrtTypInitSpinBrkAng_DS));

                    /* Switch: '<S1044>/Switch1' incorporates:
                     *  Logic: '<S1022>/Logical'
                     */
                    rtb_LogicalOperator1_cd = ((VeESSR_b_InitSpnTmrCmplt) ||
                        (VeESSR_b_InitSpnEngMvmntDet));

                    /* RelationalOperator: '<S1022>/Greater  Than1' incorporates:
                     *  Constant: '<S1050>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr1'
                     */
                    rtb_GreaterThan1_gb = (VeESSR_t_STMTmr_DS >
                                           KeESSR_t_MaxStTmInitSpin);

                    /* Logic: '<S1022>/Logical Operator' incorporates:
                     *  Logic: '<S1022>/Logical Operator1'
                     */
                    rtb_LogicalOperator_h = ((!rtb_LogicalOperator1_cd) &&
                        rtb_GreaterThan1_gb);

                    /* Switch: '<S1022>/Switch3' incorporates:
                     *  DataStoreRead: '<S1022>/Data Store Read'
                     *  DataStoreRead: '<S1022>/Data Store Read1'
                     *  DataStoreWrite: '<S1022>/Data Store Write'
                     *  DataStoreWrite: '<S1022>/Data Store Write1'
                     *  S-Function (sfix_bitop): '<S1026>/FixPt Bitwise Operator1'
                     *  S-Function (sfix_bitop): '<S1027>/FixPt Bitwise Operator1'
                     *  Switch: '<S1022>/Switch1'
                     */
                    if (rtb_LogicalOperator_h)
                    {
                        ESSR_ac_DW.NeESSR_g_StrtStpFailRsn |= 4U;
                        VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS |
                            1U;
                    }

                    /* Outputs for Atomic SubSystem: '<S1030>/Protected Division' */
                    /* Switch: '<S1069>/Switch1' incorporates:
                     *  Constant: '<S1063>/Calib'
                     *  Constant: '<S1069>/Constant Value'
                     *  Constant: '<S1069>/Constant Value1'
                     *  Constant: '<S1069>/Constant Value2'
                     *  Constant: '<S1069>/Constant Value3'
                     *  DataStoreRead: '<S1030>/Dsr_STMTmr2'
                     *  Logic: '<S1069>/AND'
                     *  RelationalOperator: '<S1069>/Greater Than or Equal '
                     *  RelationalOperator: '<S1069>/Greater Than or Equal 1'
                     *  RelationalOperator: '<S1069>/Not Equal'
                     *  RelationalOperator: '<S1069>/Not Equal1'
                     *  Switch: '<S1069>/Switch2'
                     *  Switch: '<S1069>/Switch3'
                     */
                    if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT !=
                            0.0F))
                    {
                        /* Switch: '<S1069>/Switch1' incorporates:
                         *  Product: '<S1069>/Division'
                         */
                        rtb_Multiplication1_cp = VeESSR_t_STMTmr_DS /
                            HeESSR_t_MedTEB_dT;
                    }
                    else if (VeESSR_t_STMTmr_DS > 0.0F)
                    {
                        /* Switch: '<S1069>/Switch2' incorporates:
                         *  Constant: '<S1069>/MAXFLOAT'
                         *  Switch: '<S1069>/Switch1'
                         */
                        rtb_Multiplication1_cp = 3.402823466E+38F;
                    }
                    else if (VeESSR_t_STMTmr_DS < 0.0F)
                    {
                        /* Switch: '<S1069>/Switch3' incorporates:
                         *  Constant: '<S1069>/MINFLOAT'
                         *  Switch: '<S1069>/Switch1'
                         *  Switch: '<S1069>/Switch2'
                         */
                        rtb_Multiplication1_cp = -3.402823466E+38F;
                    }
                    else
                    {
                        /* Switch: '<S1069>/Switch1' incorporates:
                         *  Constant: '<S1069>/Constant Value4'
                         *  Switch: '<S1069>/Switch2'
                         *  Switch: '<S1069>/Switch3'
                         */
                        rtb_Multiplication1_cp = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1030>/Protected Division' */

                    /* Sum: '<S1030>/Summation2' incorporates:
                     *  Constant: '<S1030>/Constant Value'
                     *  Gain: '<S1030>/Gain'
                     *  Lookup_n-D: '<S1066>/Vector'
                     *  Lookup_n-D: '<S1068>/Vector'
                     *  MinMax: '<S1030>/MinMax'
                     *  Product: '<S1030>/Product1'
                     *  Switch: '<S1069>/Switch1'
                     */
                    VeESSR_M_InitSpinEngFricEngStrtTorq = (fmaxf
                        (-VeESSR_M_EngTrqAct_Lmtd, 0.0F) * look1_iflf_binlcapw
                        (rtb_Multiplication1_cp, ((const float32 *)
                        &(KxESSR_K_InitSpinEngStrtTorqGain[0])), ((const float32
                        *)&(KtESSR_K_InitSpinEngStrtTorqGain[0])), 4U)) +
                        look1_iflf_binlcapw(rtb_Multiplication1_cp, ((const
                        float32 *)&(KxESSR_M_InitSpinEngStrtTorqOffset[0])), ((
                        const float32 *)&(KtESSR_M_InitSpinEngStrtTorqOffset[0])),
                                            4U);

                    /* Abs: '<S1030>/Abs' */
                    VeESSR_M_InitSpinEngPulseEngStrtTorq = fabsf
                        (ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E);

                    /* Lookup_n-D: '<S1067>/Vector' incorporates:
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     */
                    VeESSR_M_InitSpinECTEngStrtTorq = look1_iflf_binlcapw
                        (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                           float32 *)&(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((
                           const float32 *)&(KtESSR_M_ECTAddtlEngStrtTorq[0])),
                         6U);

                    /* Sum: '<S1030>/Summation1' */
                    VeESSR_M_InitSpinEngStrtTorqRaw =
                        (VeESSR_M_InitSpinEngFricEngStrtTorq +
                         VeESSR_M_InitSpinEngPulseEngStrtTorq) +
                        VeESSR_M_InitSpinECTEngStrtTorq;

                    /* Outputs for Atomic SubSystem: '<S1030>/GradientLimiter' */
                    /* Product: '<S1032>/Product' incorporates:
                     *  UnitDelay: '<S1062>/Unit Delay'
                     */
                    rtb_Gain_kd = ESSR_ac_DW.UnitDelay_DSTATE_h;

                    /* Sum: '<S1062>/Sum2' */
                    rtb_Multiplication1_cp = VeESSR_M_InitSpinEngStrtTorqRaw -
                        rtb_Gain_kd;

                    /* Outputs for Atomic SubSystem: '<S1062>/Limiter' */
                    /* Switch: '<S1070>/Switch1' incorporates:
                     *  Constant: '<S1065>/Calib'
                     *  RelationalOperator: '<S1070>/Relational Operator'
                     */
                    if (KeESSR_dM_InitSpinEngStrtTorqLU < rtb_Multiplication1_cp)
                    {
                        /* Switch: '<S1070>/Switch1' */
                        rtb_Multiplication1_cp = KeESSR_dM_InitSpinEngStrtTorqLU;
                    }

                    /* Switch: '<S1070>/Switch' incorporates:
                     *  Constant: '<S1064>/Calib'
                     *  RelationalOperator: '<S1070>/Relational Operator1'
                     */
                    if (rtb_Multiplication1_cp <=
                            KeESSR_dM_InitSpinEngStrtTorqLD)
                    {
                        rtb_Multiplication1_cp = KeESSR_dM_InitSpinEngStrtTorqLD;
                    }

                    /* End of Outputs for SubSystem: '<S1062>/Limiter' */

                    /* Sum: '<S1062>/Sum3' */
                    VeESSR_M_InitSpinEngStrtTorqLmtd = rtb_Multiplication1_cp +
                        rtb_Gain_kd;

                    /* Update for UnitDelay: '<S1062>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_h =
                        VeESSR_M_InitSpinEngStrtTorqLmtd;

                    /* End of Outputs for SubSystem: '<S1030>/GradientLimiter' */

                    /* Switch: '<S1022>/Switch7' incorporates:
                     *  Constant: '<S1040>/Calib'
                     *  DataStoreWrite: '<S1022>/Data Store Write3'
                     */
                    if (!HeESSR_b_EngStrtTorq)
                    {
                        VeESSR_M_EngStrtTorq_DS =
                            VeESSR_M_InitSpinEngStrtTorqLmtd;
                    }

                    /* Logic: '<S1022>/Logical2' incorporates:
                     *  Constant: '<S1036>/Constant'
                     *  Constant: '<S1037>/Constant'
                     *  Constant: '<S1038>/Calib'
                     *  Constant: '<S1039>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                     *  Logic: '<S1022>/Logical1'
                     *  Logic: '<S1022>/Logical3'
                     *  Logic: '<S1022>/Logical6'
                     *  RelationalOperator: '<S1022>/Comparison1'
                     *  RelationalOperator: '<S1022>/Comparison4'
                     */
                    rtb_Logical2_dq = ((((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                        CeESSR_e_KeyCrnkAlgo) || (((uint32)
                                         VeESSR_e_EngStrtProfType_DS) ==
                                        CeESSR_e_LowPwrAlgo));
                    rtb_Logical2_dq = (((HeESSR_b_12vStrtrEquipped) ||
                                        ((HeESSR_b_BumpStrtEquipped) &&
                                         rtb_Logical2_dq)) && rtb_Logical2_dq);

                    /* MinMax: '<S1032>/MinMax' incorporates:
                     *  DataStoreRead: '<S1032>/Dsr_StrtTypInitSpinEndPnt'
                     *  SignalConversion generated from: '<S1075>/Vector'
                     */
                    rtb_MinMax_e[0] = VeESSR_Cnt_InitSpnStepPt;
                    rtb_MinMax_e[1] = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;

                    /* Sum: '<S1032>/Sum' */
                    rtb_Multiplication1_cp = VeESSR_M_EngTrqAct_Lmtd -
                        VeESSR_M_SpnUpAddtlTorq;
                    for (iU = 0; iU < 2; iU++)
                    {
                        rtb_MinMax_e[iU] = fmaxf(VeESSR_M_TiEstMin,
                            look1_iflf_binlcapw(rtb_MinMax_e[iU], ((const
                            float32 *)&(KxESSR_K_InitSpinTiProf[0])), ((const
                            float32 *)&(KtESSR_K_InitSpinTiProf[0])), 6U) *
                            rtb_Multiplication1_cp);
                    }

                    /* Switch: '<S1022>/Switch2' incorporates:
                     *  Constant: '<S1022>/Constant Value1'
                     *  DataStoreWrite: '<S1022>/Dsw_InputTorqEst'
                     *  Lookup_n-D: '<S1075>/Vector'
                     *  MinMax: '<S1032>/MinMax'
                     *  Product: '<S1032>/Product1'
                     */
                    if (rtb_Logical2_dq)
                    {
                        VeESSR_M_EngTorqEst_DS = 0.0F;
                    }
                    else
                    {
                        VeESSR_M_EngTorqEst_DS = rtb_MinMax_e[0];
                    }

                    /* DataStoreWrite: '<S1022>/Dsw_STMTmr' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr'
                     *  Sum: '<S1022>/Summation'
                     */
                    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

                    /* Switch: '<S1044>/Switch1' incorporates:
                     *  Constant: '<S1049>/Calib'
                     */
                    if (KeESSR_b_InitSpnTmrChkOnly)
                    {
                        /* Switch: '<S1044>/Switch1' */
                        rtb_LogicalOperator1_cd = VeESSR_b_InitSpnTmrCmplt;
                    }

                    /* SignalConversion generated from: '<S1022>/Variant Source' incorporates:
                     *  Logic: '<S1054>/Logical1'
                     *  Logic: '<S1054>/Logical2'
                     *  Logic: '<S1054>/Logical3'
                     *  Logic: '<S1054>/Logical4'
                     *  RelationalOperator: '<S1054>/Comparison1'
                     *  RelationalOperator: '<S1054>/Comparison6'
                     *  RelationalOperator: '<S1054>/Comparison7'
                     *  RelationalOperator: '<S1054>/Comparison8'
                     */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* Switch: '<S1022>/Switch5' incorporates:
                     *  Constant: '<S1022>/FALSE Constant1'
                     */
                    rtb_Equal_d = false;

#else

                    /* Logic: '<S1054>/Logical4' incorporates:
                     *  Constant: '<S1085>/Constant'
                     *  Constant: '<S1086>/Constant'
                     *  Constant: '<S1087>/Constant'
                     *  Constant: '<S1088>/Constant'
                     *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                     *  Logic: '<S1054>/Logical1'
                     *  Logic: '<S1054>/Logical2'
                     *  Logic: '<S1054>/Logical3'
                     *  RelationalOperator: '<S1022>/Comparison4'
                     *  RelationalOperator: '<S1054>/Comparison1'
                     *  RelationalOperator: '<S1054>/Comparison6'
                     *  RelationalOperator: '<S1054>/Comparison7'
                     *  RelationalOperator: '<S1054>/Comparison8'
                     */
                    VeESSR_b_InitSpin_48VP2CoastDown = (((((((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMStrtAlgo) ||
                        (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                         CeESSR_e_ImplStrtAlgo)) || (((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo))
                        && (VeESSR_b_EMErlyExitLmp)) || ((((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_CltchStrtAlgo) &&
                        (VeESSR_b_ClthErlyExitLmp)));

                    /* Switch: '<S1022>/Switch5' */
                    rtb_Equal_d = VeESSR_b_InitSpin_48VP2CoastDown;

#endif

                    /* Switch: '<S1022>/Switch5' */
                    if (!VeESSR_b_StrtTypChngDisbl)
                    {
                        /* Switch: '<S1022>/Switch5' incorporates:
                         *  Constant: '<S1035>/Constant'
                         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                         *  Logic: '<S1022>/Logical Operator4'
                         *  Logic: '<S1022>/Logical Operator5'
                         *  RelationalOperator: '<S1022>/Comparison2'
                         *  RelationalOperator: '<S1022>/Comparison4'
                         */
                        rtb_Equal_d =
                            (((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B) ||
                              ((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d) &&
                               (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                CeESSR_e_KeyCrnkAlgo))) || (VeESSR_b_ErlyExitLmp));
                    }

                    /* Logic: '<S1022>/Logical Operator3' incorporates:
                     *  Constant: '<S1041>/Calib'
                     *  Constant: '<S1045>/Calib'
                     *  Constant: '<S1046>/Calib'
                     *  Constant: '<S1047>/Calib'
                     *  Constant: '<S1048>/Calib'
                     *  DataStoreRead: '<S1022>/Data Store Read18'
                     *  DataStoreRead: '<S1022>/Data Store Read19'
                     *  Logic: '<S1022>/Logical Operator2'
                     *  Logic: '<S1022>/Logical5'
                     *  Logic: '<S1022>/Logical8'
                     *  Logic: '<S1022>/Logical9'
                     *  RelationalOperator: '<S1022>/Greater  Than11'
                     *  RelationalOperator: '<S1022>/Greater  Than15'
                     */
                    VeESSR_b_InitSpin_CoastDownTrig = ((rtb_Equal_d ||
                        rtb_LogicalOperator_h) && ((((KeESSR_b_EnblFtrBackupStrt)
                        && (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
                            KeESSR_Cnt_BackupStrtMaxAttmpts)) ||
                        ((KeESSR_b_EnblFtrBumpStrt) &&
                         (VeESSR_Cnt_BumpStrtAttmptCntr_DS <
                          KeESSR_Cnt_BumpStrtMaxAttmpts))) ||
                        (HeESSR_b_LimphomeEnbl)));

                    /* If: '<S1022>/If1' */
                    if (rtb_LogicalOperator1_cd)
                    {
                        /* Outputs for IfAction SubSystem: '<S1022>/NormExit' incorporates:
                         *  ActionPort: '<S1052>/Action Port'
                         */
                        /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                         *  Constant: '<S1082>/Constant'
                         *  Merge: '<S1022>/Merge1'
                         *  SignalConversion generated from: '<S1052>/ESSTrig'
                         */
                        VeESSR_e_STMTrigger_DS = CeESSR_e_EngBrkawayAch;

                        /* End of Outputs for SubSystem: '<S1022>/NormExit' */
                    }
                    else if (VeESSR_b_InitSpin_CoastDownTrig)
                    {
                        /* Outputs for IfAction SubSystem: '<S1022>/If Action Subsystem' incorporates:
                         *  ActionPort: '<S1043>/Action Port'
                         */
                        /* Switch: '<S1043>/Switch' incorporates:
                         *  Constant: '<S1080>/Constant'
                         *  Constant: '<S1081>/Constant'
                         *  DataStoreRead: '<S1043>/Data Store Read5'
                         *  DataStoreWrite: '<S1043>/Dsw_StrtStpFailDTC'
                         */
                        if (VeESSR_b_BSGStrtFailed_DS)
                        {
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;
                        }
                        else
                        {
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
                        }

                        /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                         *  Constant: '<S1079>/Constant'
                         *  Merge: '<S1022>/Merge1'
                         *  SignalConversion generated from: '<S1043>/ESSTrig'
                         */
                        VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

                        /* End of Outputs for SubSystem: '<S1022>/If Action Subsystem' */
                    }
                    else
                    {
                        if (rtb_GreaterThan1_gb)
                        {
                            /* Outputs for IfAction SubSystem: '<S1022>/OffFail' incorporates:
                             *  ActionPort: '<S1053>/Action Port'
                             */
                            /* DataStoreWrite: '<S1053>/Dsw_StrtStpFailDTC' incorporates:
                             *  Constant: '<S1084>/Constant'
                             */
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;

                            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                             *  Constant: '<S1083>/Constant'
                             *  Merge: '<S1022>/Merge1'
                             *  SignalConversion generated from: '<S1053>/ESSTrig'
                             */
                            VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

                            /* End of Outputs for SubSystem: '<S1022>/OffFail' */
                        }
                    }

                    /* Switch: '<S1022>/Switch4' incorporates:
                     *  Constant: '<S1022>/Constant Value2'
                     *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType2'
                     *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType6'
                     *  DataStoreWrite: '<S1022>/Dsw_StrtStpFailDTC1'
                     *  Logic: '<S1022>/Logical21'
                     *  Logic: '<S1022>/Logical7'
                     *  RelationalOperator: '<S1022>/Comparison'
                     *  S-Function (sfix_bitop): '<S1022>/Bitwise Operator'
                     *  S-Function (sfix_bitop): '<S1028>/FixPt Bitwise Operator1'
                     */
                    if (((VeESSR_b_InitSpin_CoastDownTrig) ||
                            rtb_GreaterThan1_gb) &&
                            ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16U) > 0U))
                    {
                        VeESSR_g_StrtStpFailPhase_DS =
                            VeESSR_g_StrtStpFailPhase_DS | 16U;
                    }

                    /* Switch: '<S1071>/Switch1' incorporates:
                     *  Constant: '<S1072>/Calib'
                     *  DataStoreWrite: '<S1031>/Dsw_InitEngAng720'
                     *  RelationalOperator: '<S1031>/Equal1'
                     */
                    if (VeESSR_Cnt_InitSpnStepPt <= KeESSR_t_InitSpnInitAngTm)
                    {
                        VeESSR_phi_InitEngAng720_DS =
                            ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi;
                    }

                    /* Sum: '<S1032>/Subtract' incorporates:
                     *  Constant: '<S1074>/Calib'
                     *  DataStoreRead: '<S1032>/Dsr_NiProfGenNiDMax'
                     *  DataStoreWrite: '<S1032>/Data Store Write'
                     *  Product: '<S1032>/Product'
                     */
                    ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = rtb_MinMax_e[1] -
                        (VeESSR_dn_StrtTypNiDotMax_DS * KeESSR_r_NiDtoTiMargin);

                    /* DataStoreWrite: '<S1022>/Dsw_InputAcceltnProf1' */
                    VeESSR_dn_InputAcceltnProf_DS =
                        ESSR_ac_B.VariantMerge_For_Variant_Source;

                    /* RelationalOperator: '<S1022>/Equal1' incorporates:
                     *  Constant: '<S1022>/Constant Value'
                     *  DataStoreRead: '<S1022>/Data Store Read5'
                     *  DataStoreWrite: '<S1022>/Data Store Write5'
                     */
                    VeESSR_b_BSGStrtFailed_DS = (VeESSR_g_BSGStrtFailRsn_DS !=
                        0U);

                    /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqImmed' incorporates:
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitImmedTorq'
                     */
                    VeESSR_M_EngTrqReqImmed_DS =
                        VeESSR_M_StrtTypInitImmedTorq_DS;

                    /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqPrdtd1' incorporates:
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitPredTorq'
                     */
                    VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

                    /* Switch: '<S1078>/Switch3' */
                    if (rtb_NOT_i)
                    {
                        /* Update for UnitDelay: '<S1078>/Unit Delay' incorporates:
                         *  Constant: '<S1033>/Constant Value5'
                         */
                        ESSR_ac_DW.UnitDelay_DSTATE_iu = 0.0F;
                    }
                    else
                    {
                        /* Update for UnitDelay: '<S1078>/Unit Delay' */
                        ESSR_ac_DW.UnitDelay_DSTATE_iu = rtb_Switch3_bg;
                    }

                    /* End of Outputs for SubSystem: '<S559>/InitEngSpinDur' */
                }
                break;

              case ESSR_ac_IN_InitEngSpin_2:
                /* During 'InitEngSpin_2': '<S165>:6' */
                if ((((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngBrkawayAch) &&
                        (((uint32)(*Dsr_EngStrtType)) == CeESSR_e_LowPwrAlgo))
                {
                    (void)Rte_Read_VeESMR_P_BatEstdVoltMinLim_Value
                        (&rtb_Switch3_bg);

                    /* Transition: '<S165>:40' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_ColdCrank;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'ColdCrank': '<S165>:7' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                    /* Outputs for Function Call SubSystem: '<S557>/ESSC_ColdCrankEnt' */
                    /* DataStoreWrite: '<S929>/Dsw_InputTorqEstTmp' incorporates:
                     *  DataStoreRead: '<S929>/Dsr_InputTorqEst'
                     *  Inport: '<Root>/VeESMR_P_BatEstdVoltMinLim'
                     */
                    /* Event: '<S165>:90' */
                    VeESSR_M_EngTorqEstTmp_DS = VeESSR_M_EngTorqEst_DS;

                    /* DataStoreWrite: '<S929>/Dsw_DisableNc1DotLim' incorporates:
                     *  Constant: '<S929>/TRUE Constant'
                     */
                    VeESSR_b_DisableNc1DotLim_DS = true;

                    /* DataStoreWrite: '<S929>/Dsw_EngStartStopSt1' incorporates:
                     *  Constant: '<S1003>/Constant'
                     */
                    VeESSR_e_EngStartStopSt_DS = CeESSR_e_SpinUpLowPwrStrtSt;

                    /* DataStoreWrite: '<S929>/Data Store Write1' incorporates:
                     *  Constant: '<S929>/Constant Value2'
                     */
                    VeESSR_M_EngStrtTorq_DS = 0.0F;

                    /* DataStoreWrite: '<S929>/Dsw_TorqCancelDsrd1' incorporates:
                     *  Constant: '<S929>/Constant Value3'
                     */
                    VeESSR_k_TorqCancelGain_DS = 0.0F;

                    /* DataStoreWrite: '<S929>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
                     *  Constant: '<S1008>/Calib'
                     */
                    VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

                    /* DataStoreWrite: '<S929>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
                     *  Constant: '<S1009>/Calib'
                     */
                    VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

                    /* DataStoreWrite: '<S929>/Dsw_EngStrtStpMd2' incorporates:
                     *  Constant: '<S1007>/Constant'
                     */
                    VeESSR_e_EngStrtStpMd_DS = CeESSR_e_EngineTorqueStart;

                    /* DataStoreWrite: '<S929>/Dsw_EngStrtType1' incorporates:
                     *  Constant: '<S1006>/Constant'
                     */
                    VeESSR_e_TCM_StartStopType_DS = CeESSR_e_NoAction;

                    /* DataStoreWrite: '<S929>/Dsw_EngTrqRespType' incorporates:
                     *  DataStoreRead: '<S929>/VeESSR_e_StrtStpTypEngTorqRespType_DS'
                     */
                    VeESSR_e_EngTrqRespType_DS =
                        VeESSR_e_StrtStpTypEngTorqRespType_DS;

                    /* DataStoreWrite: '<S929>/Dsw_InhibitShiftToMode' incorporates:
                     *  Constant: '<S1010>/Calib'
                     */
                    VeESSR_b_InhibitShiftToMode_DS = KeESSR_b_ShftInhbtLowPwrSt;

                    /* DataStoreWrite: '<S929>/Dsw_InputSpeedProfile1' incorporates:
                     *  Constant: '<S1012>/Calib'
                     */
                    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

                    /* DataStoreWrite: '<S929>/Dsw_SpdCtlGainMod1' incorporates:
                     *  Constant: '<S1013>/Calib'
                     */
                    VeESSR_scl_SpdCtlGainMod_DS = KeESSR_scl_SpdCtrlColdCrnk;

                    /* DataStoreWrite: '<S929>/Dsw_StrtStpFailDTC' incorporates:
                     *  Constant: '<S1005>/Constant'
                     */
                    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

                    /* DataStoreWrite: '<S929>/Dsw_TransFldPmpSel' incorporates:
                     *  Constant: '<S1011>/Calib'
                     */
                    VeESSR_e_TransFldPmpSel_DS =
                        KeESSR_e_TransFldPmpSelSpinUpLowPwrStrtSt;

                    /* Sum: '<S1004>/Subtraction1' */
                    rtb_Abs_ogo = ESSR_ac_B.TmpSignalConversionAtVeESMR_P_B -
                        ESSR_ac_B.TmpSignalConversionAtVeABCR_P_H;

                    /* Outputs for Atomic SubSystem: '<S1004>/Limiter' */
                    /* Switch: '<S1019>/Switch1' incorporates:
                     *  Constant: '<S1016>/Calib'
                     *  RelationalOperator: '<S1019>/Relational Operator'
                     */
                    if (KeESSR_P_CCBatMaxDischrg < rtb_Abs_ogo)
                    {
                        /* Switch: '<S1020>/Switch1' */
                        rtb_Abs_ogo = KeESSR_P_CCBatMaxDischrg;
                    }

                    /* End of Switch: '<S1019>/Switch1' */

                    /* Switch: '<S1019>/Switch' incorporates:
                     *  Constant: '<S1018>/Calib'
                     *  RelationalOperator: '<S1019>/Relational Operator1'
                     */
                    if (rtb_Abs_ogo > KeESSR_P_CCBatMinDischrg)
                    {
                        /* Switch: '<S1019>/Switch' */
                        VeESSR_P_BatMaxLim = rtb_Abs_ogo;
                    }
                    else
                    {
                        /* Switch: '<S1019>/Switch' */
                        VeESSR_P_BatMaxLim = KeESSR_P_CCBatMinDischrg;
                    }

                    /* End of Switch: '<S1019>/Switch' */
                    /* End of Outputs for SubSystem: '<S1004>/Limiter' */

                    /* Sum: '<S1004>/Subtraction2' */
                    rtb_Switch3_bg -= ESSR_ac_B.TmpSignalConversionAtVeABCR_P_H;

                    /* Outputs for Atomic SubSystem: '<S1004>/Limiter1' */
                    /* Switch: '<S1020>/Switch1' incorporates:
                     *  Constant: '<S1017>/Calib'
                     *  Gain: '<S1004>/Gain'
                     *  RelationalOperator: '<S1020>/Relational Operator'
                     */
                    if ((-KeESSR_P_CCBatMinChrg) < rtb_Switch3_bg)
                    {
                        /* Switch: '<S1020>/Switch1' */
                        rtb_Abs_ogo = -KeESSR_P_CCBatMinChrg;
                    }
                    else
                    {
                        /* Switch: '<S1020>/Switch1' */
                        rtb_Abs_ogo = rtb_Switch3_bg;
                    }

                    /* End of Switch: '<S1020>/Switch1' */

                    /* Switch: '<S1020>/Switch' incorporates:
                     *  Constant: '<S1015>/Calib'
                     *  Gain: '<S1004>/Gain1'
                     *  RelationalOperator: '<S1020>/Relational Operator1'
                     */
                    if (rtb_Abs_ogo > (-KeESSR_P_CCBatMaxChrg))
                    {
                        /* Switch: '<S1020>/Switch' */
                        VeESSR_P_BatMinLim = rtb_Abs_ogo;
                    }
                    else
                    {
                        /* Switch: '<S1020>/Switch' */
                        VeESSR_P_BatMinLim = -KeESSR_P_CCBatMaxChrg;
                    }

                    /* End of Switch: '<S1020>/Switch' */
                    /* End of Outputs for SubSystem: '<S1004>/Limiter1' */
                    /* End of Outputs for SubSystem: '<S557>/ESSC_ColdCrankEnt' */
                }
                else if ((((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngBrkawayAch)
                         && (((uint32)(*Dsr_EngStrtType)) ==
                             CeESSR_e_KeyCrnkAlgo))
                {
                    /* Transition: '<S165>:34' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_SpinUpFireEng_CKS;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'SpinUpFireEng_CKS': '<S165>:3' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                    /* Outputs for Function Call SubSystem: '<S566>/SpinUp_CKS_Ent' */
                    /* DataStoreWrite: '<S1565>/Dsw_EngStartStopSt1' incorporates:
                     *  Constant: '<S1718>/Constant'
                     */
                    /* Event: '<S165>:84' */
                    VeESSR_e_EngStartStopSt_DS = CeESSR_e_SpinUpKeyStrtSt;

                    /* DataStoreWrite: '<S1565>/Dsw_TorqCancelDsrd1' incorporates:
                     *  Constant: '<S1565>/Constant Value3'
                     */
                    VeESSR_k_TorqCancelGain_DS = 0.0F;

                    /* DataStoreWrite: '<S1565>/Data Store Write1' incorporates:
                     *  Constant: '<S1565>/Constant Value4'
                     */
                    VeESSR_M_EngStrtTorq_DS = 0.0F;

                    /* DataStoreWrite: '<S1565>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
                     *  Constant: '<S1724>/Calib'
                     */
                    VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

                    /* DataStoreWrite: '<S1565>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
                     *  Constant: '<S1725>/Calib'
                     */
                    VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

                    /* DataStoreWrite: '<S1565>/Dsw_EngStrtStpMd2' incorporates:
                     *  Constant: '<S1721>/Constant'
                     */
                    VeESSR_e_EngStrtStpMd_DS = CeESSR_e_EngineTorqueStart;

                    /* DataStoreWrite: '<S1565>/Dsw_EngStrtType1' incorporates:
                     *  Constant: '<S1720>/Constant'
                     */
                    VeESSR_e_TCM_StartStopType_DS = CeESSR_e_NoAction;

                    /* Sum: '<S1565>/Subtraction' incorporates:
                     *  Constant: '<S1722>/Calib'
                     *  Constant: '<S1723>/Calib'
                     *  DataStoreWrite: '<S1565>/Dsw_EngTrqReqImmed'
                     */
                    VeESSR_M_EngTrqReqImmed_DS = KeESSR_M_CKSEngStartTorq -
                        KeESSR_M_CKSTiPrdtImmedDelta;

                    /* DataStoreWrite: '<S1565>/Dsw_EngTrqReqPrdtd' incorporates:
                     *  Constant: '<S1722>/Calib'
                     */
                    VeESSR_M_EngTrqReqPrdtd_DS = KeESSR_M_CKSEngStartTorq;

                    /* DataStoreWrite: '<S1565>/Dsw_EngTrqRespType' incorporates:
                     *  DataStoreRead: '<S1565>/VeESSR_e_StrtStpTypEngTorqRespType_DS'
                     */
                    VeESSR_e_EngTrqRespType_DS =
                        VeESSR_e_StrtStpTypEngTorqRespType_DS;

                    /* DataStoreWrite: '<S1565>/Dsw_InhibitShiftToMode' incorporates:
                     *  Constant: '<S1726>/Calib'
                     */
                    VeESSR_b_InhibitShiftToMode_DS =
                        KeESSR_b_ShftInhbtSpnUpKeySt;

                    /* DataStoreWrite: '<S1565>/Dsw_InputSpeedProfile1' incorporates:
                     *  Constant: '<S1728>/Calib'
                     */
                    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

                    /* DataStoreWrite: '<S1565>/Dsw_TransFldPmpSel' incorporates:
                     *  Constant: '<S1727>/Calib'
                     */
                    VeESSR_e_TransFldPmpSel_DS =
                        KeESSR_e_TransFldPmpSelSpinUpKeyStrtSt;

                    /* End of Outputs for SubSystem: '<S566>/SpinUp_CKS_Ent' */

                    /* Outputs for Function Call SubSystem: '<S566>/SpinUp_CKS_Dur' */
                    /* Event: '<S165>:85' */
                    ESSR_ac_SpinUp_CKS_Dur(VeESSR_n_TransInSpdFlt,
                                           VeESSR_M_SpnUpAddtlTorq,
                                           VeESSR_M_EngTrqAct_Lmtd,
                                           ESSR_ac_B.TmpSignalConversionAtVeESMR_P_d,
                                           ESSR_ac_B.TmpSignalConversionAtVeESMR_P_B,
                                           VeESSR_M_EngStrtTorqSnsd,
                                           ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                                           ESSR_ac_B.TmpSignalConversionAtVeENGR_t_E,
                                           ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                                           VeESSR_dn_NiDotMax,
                                           VeESSR_dn_NiDotMin,
                                           ESSR_ac_B.TmpSignalConversionAtVeABCR_P_H,
                                           &ESSR_ac_DW.SpinUp_CKS_Dur,
                                           &ESSR_ac_PrevZCX.SpinUp_CKS_Dur,
                                           &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                    /* End of Outputs for SubSystem: '<S566>/SpinUp_CKS_Dur' */
                }
                else
                {
                    /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinDur' */
                    /* RelationalOperator: '<S1022>/Equal2' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr'
                     */
                    /* Event: '<S165>:81' */
                    rtb_NOT_i = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

                    /* Switch: '<S1078>/Switch1' incorporates:
                     *  Constant: '<S1033>/Constant Value5'
                     *  UnitDelay: '<S1078>/Unit Delay'
                     */
                    if (rtb_NOT_i)
                    {
                        rtb_Multiplication1_cp = 0.0F;
                    }
                    else
                    {
                        rtb_Multiplication1_cp = ESSR_ac_DW.UnitDelay_DSTATE_iu;
                    }

                    /* Sum: '<S1033>/Sum' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitSpinScaler'
                     *  Product: '<S1022>/Product'
                     */
                    rtb_Switch3_bg = (HeESSR_t_MedTEB_dT *
                                      VeESSR_k_StrtTypInitSpinScaler_DS) +
                        rtb_Multiplication1_cp;

                    /* Outputs for Atomic SubSystem: '<S1033>/Limiter' */
                    /* Switch: '<S1077>/Switch1' incorporates:
                     *  DataStoreRead: '<S1033>/Dsr_StrtTypInitSpinEndPnt'
                     *  RelationalOperator: '<S1077>/Relational Operator'
                     */
                    if (VeESSR_Cnt_StrtTypInitSpinEndPnt_DS < rtb_Switch3_bg)
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;
                    }
                    else
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = rtb_Switch3_bg;
                    }

                    /* Switch: '<S1077>/Switch' incorporates:
                     *  Constant: '<S1033>/Constant Value1'
                     *  RelationalOperator: '<S1077>/Relational Operator1'
                     */
                    if (rtb_Gain_kd > 0.0F)
                    {
                        /* Switch: '<S1077>/Switch' */
                        VeESSR_Cnt_InitSpnStepPt = rtb_Gain_kd;
                    }
                    else
                    {
                        /* Switch: '<S1077>/Switch' */
                        VeESSR_Cnt_InitSpnStepPt = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1033>/Limiter' */

                    /* RelationalOperator: '<S1034>/Greater  Than2' incorporates:
                     *  DataStoreRead: '<S1034>/Dsr_StrtTypInitSpinEndPnt'
                     */
                    VeESSR_b_InitSpnTmrCmplt = (VeESSR_Cnt_InitSpnStepPt >=
                        VeESSR_Cnt_StrtTypInitSpinEndPnt_DS);

                    /* Outputs for Atomic SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */
                    /* Switch: '<S1058>/Switch' */
                    if (rtb_NOT_i)
                    {
                        /* Switch: '<S1058>/Switch' incorporates:
                         *  Constant: '<S1029>/Constant Value4'
                         */
                        rtb_Multiplication1_cp = 0.0F;
                    }
                    else
                    {
                        /* Switch: '<S1058>/Switch' incorporates:
                         *  Constant: '<S1029>/Cnvrt2Deg'
                         *  Constant: '<S1057>/Calib'
                         *  Product: '<S1058>/Division'
                         *  Product: '<S1058>/Multiplication'
                         *  Sum: '<S1058>/Sum//Sub'
                         *  UnitDelay: '<S1058>/Unit Delay'
                         */
                        rtb_Multiplication1_cp = ((HeESSR_t_MedTEB_dT /
                            0.166666672F) *
                            ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I) +
                            ESSR_ac_DW.UnitDelay_DSTATE_e;
                    }

                    /* Outputs for Atomic SubSystem: '<S1058>/Limiter' */
                    /* Switch: '<S1061>/Switch1' incorporates:
                     *  Constant: '<S1029>/Constant Value1'
                     *  RelationalOperator: '<S1061>/Relational Operator'
                     */
                    if (999.0F < rtb_Multiplication1_cp)
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = 999.0F;
                    }
                    else
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = rtb_Multiplication1_cp;
                    }

                    /* Switch: '<S1061>/Switch' incorporates:
                     *  Constant: '<S1029>/Constant Value'
                     *  RelationalOperator: '<S1061>/Relational Operator1'
                     */
                    if (rtb_Gain_kd <= 0.0F)
                    {
                        /* Switch: '<S1061>/Switch' */
                        rtb_Gain_kd = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1058>/Limiter' */

                    /* Update for UnitDelay: '<S1058>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_e = rtb_Gain_kd;

                    /* End of Outputs for SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */

                    /* Switch: '<S1070>/Switch1' incorporates:
                     *  Constant: '<S1029>/Constant Value3'
                     *  DataStoreRead: '<S1029>/Dsr_STMTmr3'
                     *  Product: '<S1060>/Division'
                     *  Sum: '<S1029>/Subtraction'
                     */
                    rtb_Multiplication1_cp =
                        (ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi -
                         VeESSR_phi_InitEngAng720_DS) / 720.0F;

                    /* Logic: '<S1029>/AND' incorporates:
                     *  Constant: '<S1029>/Constant Value3'
                     *  DataStoreRead: '<S1029>/Dsr_STMTmr1'
                     *  Product: '<S1060>/Multiplication'
                     *  RelationalOperator: '<S1029>/Greater  Than1'
                     *  RelationalOperator: '<S1029>/Greater  Than2'
                     *  Rounding: '<S1060>/Floor'
                     *  Sum: '<S1060>/Subtraction'
                     */
                    VeESSR_b_InitSpnEngMvmntDet = ((rtb_Gain_kd >
                        VeESSR_phi_StrtTypInitSpinBrkAng_DS) ||
                        (((rtb_Multiplication1_cp - roundf
                           (rtb_Multiplication1_cp)) * 720.0F) >
                         VeESSR_phi_StrtTypInitSpinBrkAng_DS));

                    /* Switch: '<S1044>/Switch1' incorporates:
                     *  Logic: '<S1022>/Logical'
                     */
                    rtb_LogicalOperator1_cd = ((VeESSR_b_InitSpnTmrCmplt) ||
                        (VeESSR_b_InitSpnEngMvmntDet));

                    /* RelationalOperator: '<S1022>/Greater  Than1' incorporates:
                     *  Constant: '<S1050>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr1'
                     */
                    rtb_GreaterThan1_gb = (VeESSR_t_STMTmr_DS >
                                           KeESSR_t_MaxStTmInitSpin);

                    /* Logic: '<S1022>/Logical Operator' incorporates:
                     *  Logic: '<S1022>/Logical Operator1'
                     */
                    rtb_LogicalOperator_h = ((!rtb_LogicalOperator1_cd) &&
                        rtb_GreaterThan1_gb);

                    /* Switch: '<S1022>/Switch3' incorporates:
                     *  DataStoreRead: '<S1022>/Data Store Read'
                     *  DataStoreRead: '<S1022>/Data Store Read1'
                     *  DataStoreWrite: '<S1022>/Data Store Write'
                     *  DataStoreWrite: '<S1022>/Data Store Write1'
                     *  S-Function (sfix_bitop): '<S1026>/FixPt Bitwise Operator1'
                     *  S-Function (sfix_bitop): '<S1027>/FixPt Bitwise Operator1'
                     *  Switch: '<S1022>/Switch1'
                     */
                    if (rtb_LogicalOperator_h)
                    {
                        ESSR_ac_DW.NeESSR_g_StrtStpFailRsn |= 4U;
                        VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS |
                            1U;
                    }

                    /* Outputs for Atomic SubSystem: '<S1030>/Protected Division' */
                    /* Switch: '<S1069>/Switch1' incorporates:
                     *  Constant: '<S1063>/Calib'
                     *  Constant: '<S1069>/Constant Value'
                     *  Constant: '<S1069>/Constant Value1'
                     *  Constant: '<S1069>/Constant Value2'
                     *  Constant: '<S1069>/Constant Value3'
                     *  DataStoreRead: '<S1030>/Dsr_STMTmr2'
                     *  Logic: '<S1069>/AND'
                     *  RelationalOperator: '<S1069>/Greater Than or Equal '
                     *  RelationalOperator: '<S1069>/Greater Than or Equal 1'
                     *  RelationalOperator: '<S1069>/Not Equal'
                     *  RelationalOperator: '<S1069>/Not Equal1'
                     *  Switch: '<S1069>/Switch2'
                     *  Switch: '<S1069>/Switch3'
                     */
                    if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT !=
                            0.0F))
                    {
                        /* Switch: '<S1069>/Switch1' incorporates:
                         *  Product: '<S1069>/Division'
                         */
                        rtb_Multiplication1_cp = VeESSR_t_STMTmr_DS /
                            HeESSR_t_MedTEB_dT;
                    }
                    else if (VeESSR_t_STMTmr_DS > 0.0F)
                    {
                        /* Switch: '<S1069>/Switch2' incorporates:
                         *  Constant: '<S1069>/MAXFLOAT'
                         *  Switch: '<S1069>/Switch1'
                         */
                        rtb_Multiplication1_cp = 3.402823466E+38F;
                    }
                    else if (VeESSR_t_STMTmr_DS < 0.0F)
                    {
                        /* Switch: '<S1069>/Switch3' incorporates:
                         *  Constant: '<S1069>/MINFLOAT'
                         *  Switch: '<S1069>/Switch1'
                         *  Switch: '<S1069>/Switch2'
                         */
                        rtb_Multiplication1_cp = -3.402823466E+38F;
                    }
                    else
                    {
                        /* Switch: '<S1069>/Switch1' incorporates:
                         *  Constant: '<S1069>/Constant Value4'
                         *  Switch: '<S1069>/Switch2'
                         *  Switch: '<S1069>/Switch3'
                         */
                        rtb_Multiplication1_cp = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1030>/Protected Division' */

                    /* Sum: '<S1030>/Summation2' incorporates:
                     *  Constant: '<S1030>/Constant Value'
                     *  Gain: '<S1030>/Gain'
                     *  Lookup_n-D: '<S1066>/Vector'
                     *  Lookup_n-D: '<S1068>/Vector'
                     *  MinMax: '<S1030>/MinMax'
                     *  Product: '<S1030>/Product1'
                     *  Switch: '<S1069>/Switch1'
                     */
                    VeESSR_M_InitSpinEngFricEngStrtTorq = (fmaxf
                        (-VeESSR_M_EngTrqAct_Lmtd, 0.0F) * look1_iflf_binlcapw
                        (rtb_Multiplication1_cp, ((const float32 *)
                        &(KxESSR_K_InitSpinEngStrtTorqGain[0])), ((const float32
                        *)&(KtESSR_K_InitSpinEngStrtTorqGain[0])), 4U)) +
                        look1_iflf_binlcapw(rtb_Multiplication1_cp, ((const
                        float32 *)&(KxESSR_M_InitSpinEngStrtTorqOffset[0])), ((
                        const float32 *)&(KtESSR_M_InitSpinEngStrtTorqOffset[0])),
                                            4U);

                    /* Abs: '<S1030>/Abs' */
                    VeESSR_M_InitSpinEngPulseEngStrtTorq = fabsf
                        (ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E);

                    /* Lookup_n-D: '<S1067>/Vector' incorporates:
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     */
                    VeESSR_M_InitSpinECTEngStrtTorq = look1_iflf_binlcapw
                        (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                           float32 *)&(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((
                           const float32 *)&(KtESSR_M_ECTAddtlEngStrtTorq[0])),
                         6U);

                    /* Sum: '<S1030>/Summation1' */
                    VeESSR_M_InitSpinEngStrtTorqRaw =
                        (VeESSR_M_InitSpinEngFricEngStrtTorq +
                         VeESSR_M_InitSpinEngPulseEngStrtTorq) +
                        VeESSR_M_InitSpinECTEngStrtTorq;

                    /* Outputs for Atomic SubSystem: '<S1030>/GradientLimiter' */
                    /* Product: '<S1032>/Product' incorporates:
                     *  UnitDelay: '<S1062>/Unit Delay'
                     */
                    rtb_Gain_kd = ESSR_ac_DW.UnitDelay_DSTATE_h;

                    /* Sum: '<S1062>/Sum2' */
                    rtb_Multiplication1_cp = VeESSR_M_InitSpinEngStrtTorqRaw -
                        rtb_Gain_kd;

                    /* Outputs for Atomic SubSystem: '<S1062>/Limiter' */
                    /* Switch: '<S1070>/Switch1' incorporates:
                     *  Constant: '<S1065>/Calib'
                     *  RelationalOperator: '<S1070>/Relational Operator'
                     */
                    if (KeESSR_dM_InitSpinEngStrtTorqLU < rtb_Multiplication1_cp)
                    {
                        /* Switch: '<S1070>/Switch1' */
                        rtb_Multiplication1_cp = KeESSR_dM_InitSpinEngStrtTorqLU;
                    }

                    /* Switch: '<S1070>/Switch' incorporates:
                     *  Constant: '<S1064>/Calib'
                     *  RelationalOperator: '<S1070>/Relational Operator1'
                     */
                    if (rtb_Multiplication1_cp <=
                            KeESSR_dM_InitSpinEngStrtTorqLD)
                    {
                        rtb_Multiplication1_cp = KeESSR_dM_InitSpinEngStrtTorqLD;
                    }

                    /* End of Outputs for SubSystem: '<S1062>/Limiter' */

                    /* Sum: '<S1062>/Sum3' */
                    VeESSR_M_InitSpinEngStrtTorqLmtd = rtb_Multiplication1_cp +
                        rtb_Gain_kd;

                    /* Update for UnitDelay: '<S1062>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_h =
                        VeESSR_M_InitSpinEngStrtTorqLmtd;

                    /* End of Outputs for SubSystem: '<S1030>/GradientLimiter' */

                    /* Switch: '<S1022>/Switch7' incorporates:
                     *  Constant: '<S1040>/Calib'
                     *  DataStoreWrite: '<S1022>/Data Store Write3'
                     */
                    if (!HeESSR_b_EngStrtTorq)
                    {
                        VeESSR_M_EngStrtTorq_DS =
                            VeESSR_M_InitSpinEngStrtTorqLmtd;
                    }

                    /* Logic: '<S1022>/Logical2' incorporates:
                     *  Constant: '<S1036>/Constant'
                     *  Constant: '<S1037>/Constant'
                     *  Constant: '<S1038>/Calib'
                     *  Constant: '<S1039>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                     *  Logic: '<S1022>/Logical1'
                     *  Logic: '<S1022>/Logical3'
                     *  Logic: '<S1022>/Logical6'
                     *  RelationalOperator: '<S1022>/Comparison1'
                     *  RelationalOperator: '<S1022>/Comparison4'
                     */
                    rtb_Logical2_dq = ((((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                        CeESSR_e_KeyCrnkAlgo) || (((uint32)
                                         VeESSR_e_EngStrtProfType_DS) ==
                                        CeESSR_e_LowPwrAlgo));
                    rtb_Logical2_dq = (((HeESSR_b_12vStrtrEquipped) ||
                                        ((HeESSR_b_BumpStrtEquipped) &&
                                         rtb_Logical2_dq)) && rtb_Logical2_dq);

                    /* MinMax: '<S1032>/MinMax' incorporates:
                     *  DataStoreRead: '<S1032>/Dsr_StrtTypInitSpinEndPnt'
                     *  SignalConversion generated from: '<S1075>/Vector'
                     */
                    rtb_MinMax_e[0] = VeESSR_Cnt_InitSpnStepPt;
                    rtb_MinMax_e[1] = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;

                    /* Sum: '<S1032>/Sum' */
                    rtb_Multiplication1_cp = VeESSR_M_EngTrqAct_Lmtd -
                        VeESSR_M_SpnUpAddtlTorq;
                    for (iU = 0; iU < 2; iU++)
                    {
                        rtb_MinMax_e[iU] = fmaxf(VeESSR_M_TiEstMin,
                            look1_iflf_binlcapw(rtb_MinMax_e[iU], ((const
                            float32 *)&(KxESSR_K_InitSpinTiProf[0])), ((const
                            float32 *)&(KtESSR_K_InitSpinTiProf[0])), 6U) *
                            rtb_Multiplication1_cp);
                    }

                    /* Switch: '<S1022>/Switch2' incorporates:
                     *  Constant: '<S1022>/Constant Value1'
                     *  DataStoreWrite: '<S1022>/Dsw_InputTorqEst'
                     *  Lookup_n-D: '<S1075>/Vector'
                     *  MinMax: '<S1032>/MinMax'
                     *  Product: '<S1032>/Product1'
                     */
                    if (rtb_Logical2_dq)
                    {
                        VeESSR_M_EngTorqEst_DS = 0.0F;
                    }
                    else
                    {
                        VeESSR_M_EngTorqEst_DS = rtb_MinMax_e[0];
                    }

                    /* DataStoreWrite: '<S1022>/Dsw_STMTmr' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr'
                     *  Sum: '<S1022>/Summation'
                     */
                    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

                    /* Switch: '<S1044>/Switch1' incorporates:
                     *  Constant: '<S1049>/Calib'
                     */
                    if (KeESSR_b_InitSpnTmrChkOnly)
                    {
                        /* Switch: '<S1044>/Switch1' */
                        rtb_LogicalOperator1_cd = VeESSR_b_InitSpnTmrCmplt;
                    }

                    /* SignalConversion generated from: '<S1022>/Variant Source' incorporates:
                     *  Logic: '<S1054>/Logical1'
                     *  Logic: '<S1054>/Logical2'
                     *  Logic: '<S1054>/Logical3'
                     *  Logic: '<S1054>/Logical4'
                     *  RelationalOperator: '<S1054>/Comparison1'
                     *  RelationalOperator: '<S1054>/Comparison6'
                     *  RelationalOperator: '<S1054>/Comparison7'
                     *  RelationalOperator: '<S1054>/Comparison8'
                     */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* Switch: '<S1022>/Switch5' incorporates:
                     *  Constant: '<S1022>/FALSE Constant1'
                     */
                    rtb_Equal_d = false;

#else

                    /* Logic: '<S1054>/Logical4' incorporates:
                     *  Constant: '<S1085>/Constant'
                     *  Constant: '<S1086>/Constant'
                     *  Constant: '<S1087>/Constant'
                     *  Constant: '<S1088>/Constant'
                     *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                     *  Logic: '<S1054>/Logical1'
                     *  Logic: '<S1054>/Logical2'
                     *  Logic: '<S1054>/Logical3'
                     *  RelationalOperator: '<S1022>/Comparison4'
                     *  RelationalOperator: '<S1054>/Comparison1'
                     *  RelationalOperator: '<S1054>/Comparison6'
                     *  RelationalOperator: '<S1054>/Comparison7'
                     *  RelationalOperator: '<S1054>/Comparison8'
                     */
                    VeESSR_b_InitSpin_48VP2CoastDown = (((((((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMStrtAlgo) ||
                        (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                         CeESSR_e_ImplStrtAlgo)) || (((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo))
                        && (VeESSR_b_EMErlyExitLmp)) || ((((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_CltchStrtAlgo) &&
                        (VeESSR_b_ClthErlyExitLmp)));

                    /* Switch: '<S1022>/Switch5' */
                    rtb_Equal_d = VeESSR_b_InitSpin_48VP2CoastDown;

#endif

                    /* Switch: '<S1022>/Switch5' */
                    if (!VeESSR_b_StrtTypChngDisbl)
                    {
                        /* Switch: '<S1022>/Switch5' incorporates:
                         *  Constant: '<S1035>/Constant'
                         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                         *  Logic: '<S1022>/Logical Operator4'
                         *  Logic: '<S1022>/Logical Operator5'
                         *  RelationalOperator: '<S1022>/Comparison2'
                         *  RelationalOperator: '<S1022>/Comparison4'
                         */
                        rtb_Equal_d =
                            (((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B) ||
                              ((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d) &&
                               (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                CeESSR_e_KeyCrnkAlgo))) || (VeESSR_b_ErlyExitLmp));
                    }

                    /* Logic: '<S1022>/Logical Operator3' incorporates:
                     *  Constant: '<S1041>/Calib'
                     *  Constant: '<S1045>/Calib'
                     *  Constant: '<S1046>/Calib'
                     *  Constant: '<S1047>/Calib'
                     *  Constant: '<S1048>/Calib'
                     *  DataStoreRead: '<S1022>/Data Store Read18'
                     *  DataStoreRead: '<S1022>/Data Store Read19'
                     *  Logic: '<S1022>/Logical Operator2'
                     *  Logic: '<S1022>/Logical5'
                     *  Logic: '<S1022>/Logical8'
                     *  Logic: '<S1022>/Logical9'
                     *  RelationalOperator: '<S1022>/Greater  Than11'
                     *  RelationalOperator: '<S1022>/Greater  Than15'
                     */
                    VeESSR_b_InitSpin_CoastDownTrig = ((rtb_Equal_d ||
                        rtb_LogicalOperator_h) && ((((KeESSR_b_EnblFtrBackupStrt)
                        && (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
                            KeESSR_Cnt_BackupStrtMaxAttmpts)) ||
                        ((KeESSR_b_EnblFtrBumpStrt) &&
                         (VeESSR_Cnt_BumpStrtAttmptCntr_DS <
                          KeESSR_Cnt_BumpStrtMaxAttmpts))) ||
                        (HeESSR_b_LimphomeEnbl)));

                    /* If: '<S1022>/If1' */
                    if (rtb_LogicalOperator1_cd)
                    {
                        /* Outputs for IfAction SubSystem: '<S1022>/NormExit' incorporates:
                         *  ActionPort: '<S1052>/Action Port'
                         */
                        /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                         *  Constant: '<S1082>/Constant'
                         *  Merge: '<S1022>/Merge1'
                         *  SignalConversion generated from: '<S1052>/ESSTrig'
                         */
                        VeESSR_e_STMTrigger_DS = CeESSR_e_EngBrkawayAch;

                        /* End of Outputs for SubSystem: '<S1022>/NormExit' */
                    }
                    else if (VeESSR_b_InitSpin_CoastDownTrig)
                    {
                        /* Outputs for IfAction SubSystem: '<S1022>/If Action Subsystem' incorporates:
                         *  ActionPort: '<S1043>/Action Port'
                         */
                        /* Switch: '<S1043>/Switch' incorporates:
                         *  Constant: '<S1080>/Constant'
                         *  Constant: '<S1081>/Constant'
                         *  DataStoreRead: '<S1043>/Data Store Read5'
                         *  DataStoreWrite: '<S1043>/Dsw_StrtStpFailDTC'
                         */
                        if (VeESSR_b_BSGStrtFailed_DS)
                        {
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;
                        }
                        else
                        {
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
                        }

                        /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                         *  Constant: '<S1079>/Constant'
                         *  Merge: '<S1022>/Merge1'
                         *  SignalConversion generated from: '<S1043>/ESSTrig'
                         */
                        VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

                        /* End of Outputs for SubSystem: '<S1022>/If Action Subsystem' */
                    }
                    else
                    {
                        if (rtb_GreaterThan1_gb)
                        {
                            /* Outputs for IfAction SubSystem: '<S1022>/OffFail' incorporates:
                             *  ActionPort: '<S1053>/Action Port'
                             */
                            /* DataStoreWrite: '<S1053>/Dsw_StrtStpFailDTC' incorporates:
                             *  Constant: '<S1084>/Constant'
                             */
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;

                            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                             *  Constant: '<S1083>/Constant'
                             *  Merge: '<S1022>/Merge1'
                             *  SignalConversion generated from: '<S1053>/ESSTrig'
                             */
                            VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

                            /* End of Outputs for SubSystem: '<S1022>/OffFail' */
                        }
                    }

                    /* Switch: '<S1022>/Switch4' incorporates:
                     *  Constant: '<S1022>/Constant Value2'
                     *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType2'
                     *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType6'
                     *  DataStoreWrite: '<S1022>/Dsw_StrtStpFailDTC1'
                     *  Logic: '<S1022>/Logical21'
                     *  Logic: '<S1022>/Logical7'
                     *  RelationalOperator: '<S1022>/Comparison'
                     *  S-Function (sfix_bitop): '<S1022>/Bitwise Operator'
                     *  S-Function (sfix_bitop): '<S1028>/FixPt Bitwise Operator1'
                     */
                    if (((VeESSR_b_InitSpin_CoastDownTrig) ||
                            rtb_GreaterThan1_gb) &&
                            ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16U) > 0U))
                    {
                        VeESSR_g_StrtStpFailPhase_DS =
                            VeESSR_g_StrtStpFailPhase_DS | 16U;
                    }

                    /* Switch: '<S1071>/Switch1' incorporates:
                     *  Constant: '<S1072>/Calib'
                     *  DataStoreWrite: '<S1031>/Dsw_InitEngAng720'
                     *  RelationalOperator: '<S1031>/Equal1'
                     */
                    if (VeESSR_Cnt_InitSpnStepPt <= KeESSR_t_InitSpnInitAngTm)
                    {
                        VeESSR_phi_InitEngAng720_DS =
                            ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi;
                    }

                    /* Sum: '<S1032>/Subtract' incorporates:
                     *  Constant: '<S1074>/Calib'
                     *  DataStoreRead: '<S1032>/Dsr_NiProfGenNiDMax'
                     *  DataStoreWrite: '<S1032>/Data Store Write'
                     *  Product: '<S1032>/Product'
                     */
                    ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = rtb_MinMax_e[1] -
                        (VeESSR_dn_StrtTypNiDotMax_DS * KeESSR_r_NiDtoTiMargin);

                    /* DataStoreWrite: '<S1022>/Dsw_InputAcceltnProf1' */
                    VeESSR_dn_InputAcceltnProf_DS =
                        ESSR_ac_B.VariantMerge_For_Variant_Source;

                    /* RelationalOperator: '<S1022>/Equal1' incorporates:
                     *  Constant: '<S1022>/Constant Value'
                     *  DataStoreRead: '<S1022>/Data Store Read5'
                     *  DataStoreWrite: '<S1022>/Data Store Write5'
                     */
                    VeESSR_b_BSGStrtFailed_DS = (VeESSR_g_BSGStrtFailRsn_DS !=
                        0U);

                    /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqImmed' incorporates:
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitImmedTorq'
                     */
                    VeESSR_M_EngTrqReqImmed_DS =
                        VeESSR_M_StrtTypInitImmedTorq_DS;

                    /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqPrdtd1' incorporates:
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitPredTorq'
                     */
                    VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

                    /* Switch: '<S1078>/Switch3' */
                    if (rtb_NOT_i)
                    {
                        /* Update for UnitDelay: '<S1078>/Unit Delay' incorporates:
                         *  Constant: '<S1033>/Constant Value5'
                         */
                        ESSR_ac_DW.UnitDelay_DSTATE_iu = 0.0F;
                    }
                    else
                    {
                        /* Update for UnitDelay: '<S1078>/Unit Delay' */
                        ESSR_ac_DW.UnitDelay_DSTATE_iu = rtb_Switch3_bg;
                    }

                    /* End of Outputs for SubSystem: '<S559>/InitEngSpinDur' */
                }
                break;

              case ESSR_ac_IN_InitEngSpin_3:
                /* During 'InitEngSpin_3': '<S165>:102' */
                if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngBrkawayAch)
                {
                    /* Transition: '<S165>:115' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_a_IN_SpinUpFireEng_12vStrt;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'SpinUpFireEng_12vStrt': '<S165>:105' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                    /* Outputs for Function Call SubSystem: '<S562>/SpnUp_12v_En' */
                    /* DataStoreWrite: '<S1242>/Dsw_InputSpeedProfile' */
                    /* Event: '<S165>:110' */
                    VeESSR_n_InputSpeedProfile_DS = VeESSR_n_TransInSpdFlt;

                    /* DataStoreWrite: '<S1242>/Dsw_EngStartStopSt' incorporates:
                     *  Constant: '<S1283>/Constant'
                     */
                    VeESSR_e_EngStartStopSt_DS = CeESSR_e_SpinUp12vStrtSt;

                    /* Switch: '<S1242>/Switch2' incorporates:
                     *  Constant: '<S1242>/Constant Value2'
                     *  Constant: '<S1285>/Constant'
                     *  Constant: '<S1286>/Constant'
                     *  Constant: '<S1289>/Calib'
                     *  DataStoreWrite: '<S1242>/Dsw_EngStrtType1'
                     *  DataStoreWrite: '<S1242>/Dsw_InputTorqEst'
                     *  Switch: '<S1242>/Switch'
                     */
                    if (HeESSR_b_12vBSGLowPwr)
                    {
                        VeESSR_e_TCM_StartStopType_DS = CeESSR_e_NormalStart;
                    }
                    else
                    {
                        VeESSR_e_TCM_StartStopType_DS = CeESSR_e_NoAction;
                        VeESSR_M_EngTorqEst_DS = 0.0F;
                    }

                    /* End of Switch: '<S1242>/Switch2' */

                    /* DataStoreWrite: '<S1242>/Dsw_TorqCancelGain' incorporates:
                     *  Constant: '<S1242>/Constant Value3'
                     */
                    VeESSR_k_TorqCancelGain_DS = 0.0F;

                    /* Switch: '<S1242>/Switch1' incorporates:
                     *  Constant: '<S1242>/Constant Value7'
                     *  Constant: '<S1290>/Calib'
                     *  DataStoreWrite: '<S1242>/Data Store Write1'
                     */
                    if (!HeESSR_b_EngStrtTorq)
                    {
                        VeESSR_M_EngStrtTorq_DS = 0.0F;
                    }

                    /* End of Switch: '<S1242>/Switch1' */

                    /* DataStoreWrite: '<S1242>/Dsw_EngTrqReqImmed' incorporates:
                     *  DataStoreRead: '<S1242>/Dsr_StrtTypInitImmedTorq'
                     */
                    VeESSR_M_EngTrqReqImmed_DS =
                        VeESSR_M_StrtTypInitImmedTorq_DS;

                    /* DataStoreWrite: '<S1242>/Dsw_EngTrqReqPrdtd1' incorporates:
                     *  DataStoreRead: '<S1242>/Dsr_StrtTypInitPredTorq'
                     */
                    VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

                    /* DataStoreWrite: '<S1242>/Dsw_AEMDMtrBGain' incorporates:
                     *  Constant: '<S1296>/Calib'
                     */
                    VeESSR_scl_AEMDMtrBGain_DS =
                        KeESSR_scl_AEMDMtrBGain_SpnUp12VStrtSt;

                    /* DataStoreWrite: '<S1242>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
                     *  Constant: '<S1291>/Calib'
                     */
                    VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

                    /* DataStoreWrite: '<S1242>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
                     *  Constant: '<S1292>/Calib'
                     */
                    VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

                    /* DataStoreWrite: '<S1242>/Dsw_EngStrtStpMd' incorporates:
                     *  Constant: '<S1287>/Constant'
                     */
                    VeESSR_e_EngStrtStpMd_DS = CeESSR_e_EngineTorqueStart;

                    /* DataStoreWrite: '<S1242>/Dsw_EngStrtType2' incorporates:
                     *  Constant: '<S1288>/Constant'
                     */
                    VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Cranking;

                    /* DataStoreWrite: '<S1242>/Dsw_EngTrqRespType' incorporates:
                     *  DataStoreRead: '<S1242>/VeESSR_e_StrtStpTypEngTorqRespType_DS'
                     */
                    VeESSR_e_EngTrqRespType_DS =
                        VeESSR_e_StrtStpTypEngTorqRespType_DS;

                    /* DataStoreWrite: '<S1242>/Dsw_InhibitShiftToMode' incorporates:
                     *  Constant: '<S1293>/Calib'
                     */
                    VeESSR_b_InhibitShiftToMode_DS =
                        KeESSR_b_ShftInhbtSpnUp12vStrtSt;

                    /* DataStoreWrite: '<S1242>/Dsw_InputSpeedProfile1' incorporates:
                     *  Constant: '<S1295>/Calib'
                     */
                    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

                    /* DataStoreWrite: '<S1242>/Dsw_TransFldPmpSel' incorporates:
                     *  Constant: '<S1294>/Calib'
                     */
                    VeESSR_e_TransFldPmpSel_DS =
                        KeESSR_e_TransFldPmpSelSpinUp12vStrtSt;

                    /* End of Outputs for SubSystem: '<S562>/SpnUp_12v_En' */

                    /* Outputs for Function Call SubSystem: '<S562>/SpnUp_12v_Du' */
                    /* Event: '<S165>:111' */
                    ESSR_ac_SpnUp_12v_Du(VeESSR_n_TransInSpdFlt,
                                         ESSR_ac_B.TmpSignalConversionAtVeHPMR_b_P,
                                         VeESSR_M_TiEstMin,
                                         ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                         &ESSR_ac_DW.SpnUp_12v_Du,
                                         &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                    /* End of Outputs for SubSystem: '<S562>/SpnUp_12v_Du' */
                }
                else
                {
                    /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinDur' */
                    /* RelationalOperator: '<S1022>/Equal2' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr'
                     */
                    /* Event: '<S165>:81' */
                    rtb_NOT_i = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

                    /* Switch: '<S1078>/Switch1' incorporates:
                     *  Constant: '<S1033>/Constant Value5'
                     *  UnitDelay: '<S1078>/Unit Delay'
                     */
                    if (rtb_NOT_i)
                    {
                        rtb_Multiplication1_cp = 0.0F;
                    }
                    else
                    {
                        rtb_Multiplication1_cp = ESSR_ac_DW.UnitDelay_DSTATE_iu;
                    }

                    /* Sum: '<S1033>/Sum' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitSpinScaler'
                     *  Product: '<S1022>/Product'
                     */
                    rtb_Switch3_bg = (HeESSR_t_MedTEB_dT *
                                      VeESSR_k_StrtTypInitSpinScaler_DS) +
                        rtb_Multiplication1_cp;

                    /* Outputs for Atomic SubSystem: '<S1033>/Limiter' */
                    /* Switch: '<S1077>/Switch1' incorporates:
                     *  DataStoreRead: '<S1033>/Dsr_StrtTypInitSpinEndPnt'
                     *  RelationalOperator: '<S1077>/Relational Operator'
                     */
                    if (VeESSR_Cnt_StrtTypInitSpinEndPnt_DS < rtb_Switch3_bg)
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;
                    }
                    else
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = rtb_Switch3_bg;
                    }

                    /* Switch: '<S1077>/Switch' incorporates:
                     *  Constant: '<S1033>/Constant Value1'
                     *  RelationalOperator: '<S1077>/Relational Operator1'
                     */
                    if (rtb_Gain_kd > 0.0F)
                    {
                        /* Switch: '<S1077>/Switch' */
                        VeESSR_Cnt_InitSpnStepPt = rtb_Gain_kd;
                    }
                    else
                    {
                        /* Switch: '<S1077>/Switch' */
                        VeESSR_Cnt_InitSpnStepPt = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1033>/Limiter' */

                    /* RelationalOperator: '<S1034>/Greater  Than2' incorporates:
                     *  DataStoreRead: '<S1034>/Dsr_StrtTypInitSpinEndPnt'
                     */
                    VeESSR_b_InitSpnTmrCmplt = (VeESSR_Cnt_InitSpnStepPt >=
                        VeESSR_Cnt_StrtTypInitSpinEndPnt_DS);

                    /* Outputs for Atomic SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */
                    /* Switch: '<S1058>/Switch' */
                    if (rtb_NOT_i)
                    {
                        /* Switch: '<S1058>/Switch' incorporates:
                         *  Constant: '<S1029>/Constant Value4'
                         */
                        rtb_Multiplication1_cp = 0.0F;
                    }
                    else
                    {
                        /* Switch: '<S1058>/Switch' incorporates:
                         *  Constant: '<S1029>/Cnvrt2Deg'
                         *  Constant: '<S1057>/Calib'
                         *  Product: '<S1058>/Division'
                         *  Product: '<S1058>/Multiplication'
                         *  Sum: '<S1058>/Sum//Sub'
                         *  UnitDelay: '<S1058>/Unit Delay'
                         */
                        rtb_Multiplication1_cp = ((HeESSR_t_MedTEB_dT /
                            0.166666672F) *
                            ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I) +
                            ESSR_ac_DW.UnitDelay_DSTATE_e;
                    }

                    /* Outputs for Atomic SubSystem: '<S1058>/Limiter' */
                    /* Switch: '<S1061>/Switch1' incorporates:
                     *  Constant: '<S1029>/Constant Value1'
                     *  RelationalOperator: '<S1061>/Relational Operator'
                     */
                    if (999.0F < rtb_Multiplication1_cp)
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = 999.0F;
                    }
                    else
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = rtb_Multiplication1_cp;
                    }

                    /* Switch: '<S1061>/Switch' incorporates:
                     *  Constant: '<S1029>/Constant Value'
                     *  RelationalOperator: '<S1061>/Relational Operator1'
                     */
                    if (rtb_Gain_kd <= 0.0F)
                    {
                        /* Switch: '<S1061>/Switch' */
                        rtb_Gain_kd = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1058>/Limiter' */

                    /* Update for UnitDelay: '<S1058>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_e = rtb_Gain_kd;

                    /* End of Outputs for SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */

                    /* Switch: '<S1070>/Switch1' incorporates:
                     *  Constant: '<S1029>/Constant Value3'
                     *  DataStoreRead: '<S1029>/Dsr_STMTmr3'
                     *  Product: '<S1060>/Division'
                     *  Sum: '<S1029>/Subtraction'
                     */
                    rtb_Multiplication1_cp =
                        (ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi -
                         VeESSR_phi_InitEngAng720_DS) / 720.0F;

                    /* Logic: '<S1029>/AND' incorporates:
                     *  Constant: '<S1029>/Constant Value3'
                     *  DataStoreRead: '<S1029>/Dsr_STMTmr1'
                     *  Product: '<S1060>/Multiplication'
                     *  RelationalOperator: '<S1029>/Greater  Than1'
                     *  RelationalOperator: '<S1029>/Greater  Than2'
                     *  Rounding: '<S1060>/Floor'
                     *  Sum: '<S1060>/Subtraction'
                     */
                    VeESSR_b_InitSpnEngMvmntDet = ((rtb_Gain_kd >
                        VeESSR_phi_StrtTypInitSpinBrkAng_DS) ||
                        (((rtb_Multiplication1_cp - roundf
                           (rtb_Multiplication1_cp)) * 720.0F) >
                         VeESSR_phi_StrtTypInitSpinBrkAng_DS));

                    /* Switch: '<S1044>/Switch1' incorporates:
                     *  Logic: '<S1022>/Logical'
                     */
                    rtb_LogicalOperator1_cd = ((VeESSR_b_InitSpnTmrCmplt) ||
                        (VeESSR_b_InitSpnEngMvmntDet));

                    /* RelationalOperator: '<S1022>/Greater  Than1' incorporates:
                     *  Constant: '<S1050>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr1'
                     */
                    rtb_GreaterThan1_gb = (VeESSR_t_STMTmr_DS >
                                           KeESSR_t_MaxStTmInitSpin);

                    /* Logic: '<S1022>/Logical Operator' incorporates:
                     *  Logic: '<S1022>/Logical Operator1'
                     */
                    rtb_LogicalOperator_h = ((!rtb_LogicalOperator1_cd) &&
                        rtb_GreaterThan1_gb);

                    /* Switch: '<S1022>/Switch3' incorporates:
                     *  DataStoreRead: '<S1022>/Data Store Read'
                     *  DataStoreRead: '<S1022>/Data Store Read1'
                     *  DataStoreWrite: '<S1022>/Data Store Write'
                     *  DataStoreWrite: '<S1022>/Data Store Write1'
                     *  S-Function (sfix_bitop): '<S1026>/FixPt Bitwise Operator1'
                     *  S-Function (sfix_bitop): '<S1027>/FixPt Bitwise Operator1'
                     *  Switch: '<S1022>/Switch1'
                     */
                    if (rtb_LogicalOperator_h)
                    {
                        ESSR_ac_DW.NeESSR_g_StrtStpFailRsn |= 4U;
                        VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS |
                            1U;
                    }

                    /* Outputs for Atomic SubSystem: '<S1030>/Protected Division' */
                    /* Switch: '<S1069>/Switch1' incorporates:
                     *  Constant: '<S1063>/Calib'
                     *  Constant: '<S1069>/Constant Value'
                     *  Constant: '<S1069>/Constant Value1'
                     *  Constant: '<S1069>/Constant Value2'
                     *  Constant: '<S1069>/Constant Value3'
                     *  DataStoreRead: '<S1030>/Dsr_STMTmr2'
                     *  Logic: '<S1069>/AND'
                     *  RelationalOperator: '<S1069>/Greater Than or Equal '
                     *  RelationalOperator: '<S1069>/Greater Than or Equal 1'
                     *  RelationalOperator: '<S1069>/Not Equal'
                     *  RelationalOperator: '<S1069>/Not Equal1'
                     *  Switch: '<S1069>/Switch2'
                     *  Switch: '<S1069>/Switch3'
                     */
                    if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT !=
                            0.0F))
                    {
                        /* Switch: '<S1069>/Switch1' incorporates:
                         *  Product: '<S1069>/Division'
                         */
                        rtb_Multiplication1_cp = VeESSR_t_STMTmr_DS /
                            HeESSR_t_MedTEB_dT;
                    }
                    else if (VeESSR_t_STMTmr_DS > 0.0F)
                    {
                        /* Switch: '<S1069>/Switch2' incorporates:
                         *  Constant: '<S1069>/MAXFLOAT'
                         *  Switch: '<S1069>/Switch1'
                         */
                        rtb_Multiplication1_cp = 3.402823466E+38F;
                    }
                    else if (VeESSR_t_STMTmr_DS < 0.0F)
                    {
                        /* Switch: '<S1069>/Switch3' incorporates:
                         *  Constant: '<S1069>/MINFLOAT'
                         *  Switch: '<S1069>/Switch1'
                         *  Switch: '<S1069>/Switch2'
                         */
                        rtb_Multiplication1_cp = -3.402823466E+38F;
                    }
                    else
                    {
                        /* Switch: '<S1069>/Switch1' incorporates:
                         *  Constant: '<S1069>/Constant Value4'
                         *  Switch: '<S1069>/Switch2'
                         *  Switch: '<S1069>/Switch3'
                         */
                        rtb_Multiplication1_cp = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1030>/Protected Division' */

                    /* Sum: '<S1030>/Summation2' incorporates:
                     *  Constant: '<S1030>/Constant Value'
                     *  Gain: '<S1030>/Gain'
                     *  Lookup_n-D: '<S1066>/Vector'
                     *  Lookup_n-D: '<S1068>/Vector'
                     *  MinMax: '<S1030>/MinMax'
                     *  Product: '<S1030>/Product1'
                     *  Switch: '<S1069>/Switch1'
                     */
                    VeESSR_M_InitSpinEngFricEngStrtTorq = (fmaxf
                        (-VeESSR_M_EngTrqAct_Lmtd, 0.0F) * look1_iflf_binlcapw
                        (rtb_Multiplication1_cp, ((const float32 *)
                        &(KxESSR_K_InitSpinEngStrtTorqGain[0])), ((const float32
                        *)&(KtESSR_K_InitSpinEngStrtTorqGain[0])), 4U)) +
                        look1_iflf_binlcapw(rtb_Multiplication1_cp, ((const
                        float32 *)&(KxESSR_M_InitSpinEngStrtTorqOffset[0])), ((
                        const float32 *)&(KtESSR_M_InitSpinEngStrtTorqOffset[0])),
                                            4U);

                    /* Abs: '<S1030>/Abs' */
                    VeESSR_M_InitSpinEngPulseEngStrtTorq = fabsf
                        (ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E);

                    /* Lookup_n-D: '<S1067>/Vector' incorporates:
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     */
                    VeESSR_M_InitSpinECTEngStrtTorq = look1_iflf_binlcapw
                        (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                           float32 *)&(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((
                           const float32 *)&(KtESSR_M_ECTAddtlEngStrtTorq[0])),
                         6U);

                    /* Sum: '<S1030>/Summation1' */
                    VeESSR_M_InitSpinEngStrtTorqRaw =
                        (VeESSR_M_InitSpinEngFricEngStrtTorq +
                         VeESSR_M_InitSpinEngPulseEngStrtTorq) +
                        VeESSR_M_InitSpinECTEngStrtTorq;

                    /* Outputs for Atomic SubSystem: '<S1030>/GradientLimiter' */
                    /* Product: '<S1032>/Product' incorporates:
                     *  UnitDelay: '<S1062>/Unit Delay'
                     */
                    rtb_Gain_kd = ESSR_ac_DW.UnitDelay_DSTATE_h;

                    /* Sum: '<S1062>/Sum2' */
                    rtb_Multiplication1_cp = VeESSR_M_InitSpinEngStrtTorqRaw -
                        rtb_Gain_kd;

                    /* Outputs for Atomic SubSystem: '<S1062>/Limiter' */
                    /* Switch: '<S1070>/Switch1' incorporates:
                     *  Constant: '<S1065>/Calib'
                     *  RelationalOperator: '<S1070>/Relational Operator'
                     */
                    if (KeESSR_dM_InitSpinEngStrtTorqLU < rtb_Multiplication1_cp)
                    {
                        /* Switch: '<S1070>/Switch1' */
                        rtb_Multiplication1_cp = KeESSR_dM_InitSpinEngStrtTorqLU;
                    }

                    /* Switch: '<S1070>/Switch' incorporates:
                     *  Constant: '<S1064>/Calib'
                     *  RelationalOperator: '<S1070>/Relational Operator1'
                     */
                    if (rtb_Multiplication1_cp <=
                            KeESSR_dM_InitSpinEngStrtTorqLD)
                    {
                        rtb_Multiplication1_cp = KeESSR_dM_InitSpinEngStrtTorqLD;
                    }

                    /* End of Outputs for SubSystem: '<S1062>/Limiter' */

                    /* Sum: '<S1062>/Sum3' */
                    VeESSR_M_InitSpinEngStrtTorqLmtd = rtb_Multiplication1_cp +
                        rtb_Gain_kd;

                    /* Update for UnitDelay: '<S1062>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_h =
                        VeESSR_M_InitSpinEngStrtTorqLmtd;

                    /* End of Outputs for SubSystem: '<S1030>/GradientLimiter' */

                    /* Switch: '<S1022>/Switch7' incorporates:
                     *  Constant: '<S1040>/Calib'
                     *  DataStoreWrite: '<S1022>/Data Store Write3'
                     */
                    if (!HeESSR_b_EngStrtTorq)
                    {
                        VeESSR_M_EngStrtTorq_DS =
                            VeESSR_M_InitSpinEngStrtTorqLmtd;
                    }

                    /* Logic: '<S1022>/Logical2' incorporates:
                     *  Constant: '<S1036>/Constant'
                     *  Constant: '<S1037>/Constant'
                     *  Constant: '<S1038>/Calib'
                     *  Constant: '<S1039>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                     *  Logic: '<S1022>/Logical1'
                     *  Logic: '<S1022>/Logical3'
                     *  Logic: '<S1022>/Logical6'
                     *  RelationalOperator: '<S1022>/Comparison1'
                     *  RelationalOperator: '<S1022>/Comparison4'
                     */
                    rtb_Logical2_dq = ((((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                        CeESSR_e_KeyCrnkAlgo) || (((uint32)
                                         VeESSR_e_EngStrtProfType_DS) ==
                                        CeESSR_e_LowPwrAlgo));
                    rtb_Logical2_dq = (((HeESSR_b_12vStrtrEquipped) ||
                                        ((HeESSR_b_BumpStrtEquipped) &&
                                         rtb_Logical2_dq)) && rtb_Logical2_dq);

                    /* MinMax: '<S1032>/MinMax' incorporates:
                     *  DataStoreRead: '<S1032>/Dsr_StrtTypInitSpinEndPnt'
                     *  SignalConversion generated from: '<S1075>/Vector'
                     */
                    rtb_MinMax_e[0] = VeESSR_Cnt_InitSpnStepPt;
                    rtb_MinMax_e[1] = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;

                    /* Sum: '<S1032>/Sum' */
                    rtb_Multiplication1_cp = VeESSR_M_EngTrqAct_Lmtd -
                        VeESSR_M_SpnUpAddtlTorq;
                    for (iU = 0; iU < 2; iU++)
                    {
                        rtb_MinMax_e[iU] = fmaxf(VeESSR_M_TiEstMin,
                            look1_iflf_binlcapw(rtb_MinMax_e[iU], ((const
                            float32 *)&(KxESSR_K_InitSpinTiProf[0])), ((const
                            float32 *)&(KtESSR_K_InitSpinTiProf[0])), 6U) *
                            rtb_Multiplication1_cp);
                    }

                    /* Switch: '<S1022>/Switch2' incorporates:
                     *  Constant: '<S1022>/Constant Value1'
                     *  DataStoreWrite: '<S1022>/Dsw_InputTorqEst'
                     *  Lookup_n-D: '<S1075>/Vector'
                     *  MinMax: '<S1032>/MinMax'
                     *  Product: '<S1032>/Product1'
                     */
                    if (rtb_Logical2_dq)
                    {
                        VeESSR_M_EngTorqEst_DS = 0.0F;
                    }
                    else
                    {
                        VeESSR_M_EngTorqEst_DS = rtb_MinMax_e[0];
                    }

                    /* DataStoreWrite: '<S1022>/Dsw_STMTmr' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr'
                     *  Sum: '<S1022>/Summation'
                     */
                    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

                    /* Switch: '<S1044>/Switch1' incorporates:
                     *  Constant: '<S1049>/Calib'
                     */
                    if (KeESSR_b_InitSpnTmrChkOnly)
                    {
                        /* Switch: '<S1044>/Switch1' */
                        rtb_LogicalOperator1_cd = VeESSR_b_InitSpnTmrCmplt;
                    }

                    /* SignalConversion generated from: '<S1022>/Variant Source' incorporates:
                     *  Logic: '<S1054>/Logical1'
                     *  Logic: '<S1054>/Logical2'
                     *  Logic: '<S1054>/Logical3'
                     *  Logic: '<S1054>/Logical4'
                     *  RelationalOperator: '<S1054>/Comparison1'
                     *  RelationalOperator: '<S1054>/Comparison6'
                     *  RelationalOperator: '<S1054>/Comparison7'
                     *  RelationalOperator: '<S1054>/Comparison8'
                     */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* Switch: '<S1022>/Switch5' incorporates:
                     *  Constant: '<S1022>/FALSE Constant1'
                     */
                    rtb_Equal_d = false;

#else

                    /* Logic: '<S1054>/Logical4' incorporates:
                     *  Constant: '<S1085>/Constant'
                     *  Constant: '<S1086>/Constant'
                     *  Constant: '<S1087>/Constant'
                     *  Constant: '<S1088>/Constant'
                     *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                     *  Logic: '<S1054>/Logical1'
                     *  Logic: '<S1054>/Logical2'
                     *  Logic: '<S1054>/Logical3'
                     *  RelationalOperator: '<S1022>/Comparison4'
                     *  RelationalOperator: '<S1054>/Comparison1'
                     *  RelationalOperator: '<S1054>/Comparison6'
                     *  RelationalOperator: '<S1054>/Comparison7'
                     *  RelationalOperator: '<S1054>/Comparison8'
                     */
                    VeESSR_b_InitSpin_48VP2CoastDown = (((((((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMStrtAlgo) ||
                        (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                         CeESSR_e_ImplStrtAlgo)) || (((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo))
                        && (VeESSR_b_EMErlyExitLmp)) || ((((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_CltchStrtAlgo) &&
                        (VeESSR_b_ClthErlyExitLmp)));

                    /* Switch: '<S1022>/Switch5' */
                    rtb_Equal_d = VeESSR_b_InitSpin_48VP2CoastDown;

#endif

                    /* Switch: '<S1022>/Switch5' */
                    if (!VeESSR_b_StrtTypChngDisbl)
                    {
                        /* Switch: '<S1022>/Switch5' incorporates:
                         *  Constant: '<S1035>/Constant'
                         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                         *  Logic: '<S1022>/Logical Operator4'
                         *  Logic: '<S1022>/Logical Operator5'
                         *  RelationalOperator: '<S1022>/Comparison2'
                         *  RelationalOperator: '<S1022>/Comparison4'
                         */
                        rtb_Equal_d =
                            (((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B) ||
                              ((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d) &&
                               (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                CeESSR_e_KeyCrnkAlgo))) || (VeESSR_b_ErlyExitLmp));
                    }

                    /* Logic: '<S1022>/Logical Operator3' incorporates:
                     *  Constant: '<S1041>/Calib'
                     *  Constant: '<S1045>/Calib'
                     *  Constant: '<S1046>/Calib'
                     *  Constant: '<S1047>/Calib'
                     *  Constant: '<S1048>/Calib'
                     *  DataStoreRead: '<S1022>/Data Store Read18'
                     *  DataStoreRead: '<S1022>/Data Store Read19'
                     *  Logic: '<S1022>/Logical Operator2'
                     *  Logic: '<S1022>/Logical5'
                     *  Logic: '<S1022>/Logical8'
                     *  Logic: '<S1022>/Logical9'
                     *  RelationalOperator: '<S1022>/Greater  Than11'
                     *  RelationalOperator: '<S1022>/Greater  Than15'
                     */
                    VeESSR_b_InitSpin_CoastDownTrig = ((rtb_Equal_d ||
                        rtb_LogicalOperator_h) && ((((KeESSR_b_EnblFtrBackupStrt)
                        && (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
                            KeESSR_Cnt_BackupStrtMaxAttmpts)) ||
                        ((KeESSR_b_EnblFtrBumpStrt) &&
                         (VeESSR_Cnt_BumpStrtAttmptCntr_DS <
                          KeESSR_Cnt_BumpStrtMaxAttmpts))) ||
                        (HeESSR_b_LimphomeEnbl)));

                    /* If: '<S1022>/If1' */
                    if (rtb_LogicalOperator1_cd)
                    {
                        /* Outputs for IfAction SubSystem: '<S1022>/NormExit' incorporates:
                         *  ActionPort: '<S1052>/Action Port'
                         */
                        /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                         *  Constant: '<S1082>/Constant'
                         *  Merge: '<S1022>/Merge1'
                         *  SignalConversion generated from: '<S1052>/ESSTrig'
                         */
                        VeESSR_e_STMTrigger_DS = CeESSR_e_EngBrkawayAch;

                        /* End of Outputs for SubSystem: '<S1022>/NormExit' */
                    }
                    else if (VeESSR_b_InitSpin_CoastDownTrig)
                    {
                        /* Outputs for IfAction SubSystem: '<S1022>/If Action Subsystem' incorporates:
                         *  ActionPort: '<S1043>/Action Port'
                         */
                        /* Switch: '<S1043>/Switch' incorporates:
                         *  Constant: '<S1080>/Constant'
                         *  Constant: '<S1081>/Constant'
                         *  DataStoreRead: '<S1043>/Data Store Read5'
                         *  DataStoreWrite: '<S1043>/Dsw_StrtStpFailDTC'
                         */
                        if (VeESSR_b_BSGStrtFailed_DS)
                        {
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;
                        }
                        else
                        {
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
                        }

                        /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                         *  Constant: '<S1079>/Constant'
                         *  Merge: '<S1022>/Merge1'
                         *  SignalConversion generated from: '<S1043>/ESSTrig'
                         */
                        VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

                        /* End of Outputs for SubSystem: '<S1022>/If Action Subsystem' */
                    }
                    else
                    {
                        if (rtb_GreaterThan1_gb)
                        {
                            /* Outputs for IfAction SubSystem: '<S1022>/OffFail' incorporates:
                             *  ActionPort: '<S1053>/Action Port'
                             */
                            /* DataStoreWrite: '<S1053>/Dsw_StrtStpFailDTC' incorporates:
                             *  Constant: '<S1084>/Constant'
                             */
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;

                            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                             *  Constant: '<S1083>/Constant'
                             *  Merge: '<S1022>/Merge1'
                             *  SignalConversion generated from: '<S1053>/ESSTrig'
                             */
                            VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

                            /* End of Outputs for SubSystem: '<S1022>/OffFail' */
                        }
                    }

                    /* Switch: '<S1022>/Switch4' incorporates:
                     *  Constant: '<S1022>/Constant Value2'
                     *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType2'
                     *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType6'
                     *  DataStoreWrite: '<S1022>/Dsw_StrtStpFailDTC1'
                     *  Logic: '<S1022>/Logical21'
                     *  Logic: '<S1022>/Logical7'
                     *  RelationalOperator: '<S1022>/Comparison'
                     *  S-Function (sfix_bitop): '<S1022>/Bitwise Operator'
                     *  S-Function (sfix_bitop): '<S1028>/FixPt Bitwise Operator1'
                     */
                    if (((VeESSR_b_InitSpin_CoastDownTrig) ||
                            rtb_GreaterThan1_gb) &&
                            ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16U) > 0U))
                    {
                        VeESSR_g_StrtStpFailPhase_DS =
                            VeESSR_g_StrtStpFailPhase_DS | 16U;
                    }

                    /* Switch: '<S1071>/Switch1' incorporates:
                     *  Constant: '<S1072>/Calib'
                     *  DataStoreWrite: '<S1031>/Dsw_InitEngAng720'
                     *  RelationalOperator: '<S1031>/Equal1'
                     */
                    if (VeESSR_Cnt_InitSpnStepPt <= KeESSR_t_InitSpnInitAngTm)
                    {
                        VeESSR_phi_InitEngAng720_DS =
                            ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi;
                    }

                    /* Sum: '<S1032>/Subtract' incorporates:
                     *  Constant: '<S1074>/Calib'
                     *  DataStoreRead: '<S1032>/Dsr_NiProfGenNiDMax'
                     *  DataStoreWrite: '<S1032>/Data Store Write'
                     *  Product: '<S1032>/Product'
                     */
                    ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = rtb_MinMax_e[1] -
                        (VeESSR_dn_StrtTypNiDotMax_DS * KeESSR_r_NiDtoTiMargin);

                    /* DataStoreWrite: '<S1022>/Dsw_InputAcceltnProf1' */
                    VeESSR_dn_InputAcceltnProf_DS =
                        ESSR_ac_B.VariantMerge_For_Variant_Source;

                    /* RelationalOperator: '<S1022>/Equal1' incorporates:
                     *  Constant: '<S1022>/Constant Value'
                     *  DataStoreRead: '<S1022>/Data Store Read5'
                     *  DataStoreWrite: '<S1022>/Data Store Write5'
                     */
                    VeESSR_b_BSGStrtFailed_DS = (VeESSR_g_BSGStrtFailRsn_DS !=
                        0U);

                    /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqImmed' incorporates:
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitImmedTorq'
                     */
                    VeESSR_M_EngTrqReqImmed_DS =
                        VeESSR_M_StrtTypInitImmedTorq_DS;

                    /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqPrdtd1' incorporates:
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitPredTorq'
                     */
                    VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

                    /* Switch: '<S1078>/Switch3' */
                    if (rtb_NOT_i)
                    {
                        /* Update for UnitDelay: '<S1078>/Unit Delay' incorporates:
                         *  Constant: '<S1033>/Constant Value5'
                         */
                        ESSR_ac_DW.UnitDelay_DSTATE_iu = 0.0F;
                    }
                    else
                    {
                        /* Update for UnitDelay: '<S1078>/Unit Delay' */
                        ESSR_ac_DW.UnitDelay_DSTATE_iu = rtb_Switch3_bg;
                    }

                    /* End of Outputs for SubSystem: '<S559>/InitEngSpinDur' */
                }
                break;

              case ESSR_ac_IN_InitEngSpin_4:
                /* During 'InitEngSpin_4': '<S165>:145' */
                if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngBrkawayAch)
                {
                    /* Transition: '<S165>:151' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR__IN_SpinUpFireEng_BumpStrt;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'SpinUpFireEng_BumpStrt': '<S165>:148' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Event: '<S165>:159' */
                    /* Event: '<S165>:160' */
#if Rte_SysCon_Variant_ESSR_P1P2Func

                    /* Outputs for Function Call SubSystem: '<S563>/SpnUpFreEng_Bmp_En' */
                    /* DataStoreWrite: '<S1300>/Dsw_InputSpeedProfile' */
                    VeESSR_n_InputSpeedProfile_DS = VeESSR_n_TransInSpdFlt;

                    /* DataStoreWrite: '<S1300>/Dsw_EngStartStopSt' incorporates:
                     *  Constant: '<S1352>/Constant'
                     */
                    VeESSR_e_EngStartStopSt_DS = CeESSR_e_SpinUpBumpStrtSt;

                    /* DataStoreWrite: '<S1300>/Dsw_InputTorqEst' incorporates:
                     *  Constant: '<S1300>/Constant Value2'
                     */
                    VeESSR_M_EngTorqEst_DS = 0.0F;

                    /* DataStoreWrite: '<S1300>/Dsw_TorqCancelGain' incorporates:
                     *  Constant: '<S1300>/Constant Value3'
                     */
                    VeESSR_k_TorqCancelGain_DS = 0.0F;

                    /* DataStoreWrite: '<S1300>/Dsw_EngTrqReqImmed' incorporates:
                     *  DataStoreRead: '<S1300>/Dsr_StrtTypInitImmedTorq'
                     */
                    VeESSR_M_EngTrqReqImmed_DS =
                        VeESSR_M_StrtTypInitImmedTorq_DS;

                    /* DataStoreWrite: '<S1300>/Dsw_EngTrqReqPrdtd1' incorporates:
                     *  DataStoreRead: '<S1300>/Dsr_StrtTypInitPredTorq'
                     */
                    VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

                    /* DataStoreWrite: '<S1300>/Dsw_EngStrtStpMd' incorporates:
                     *  Constant: '<S1354>/Constant'
                     */
                    VeESSR_e_EngStrtStpMd_DS = CeESSR_e_EngineTorqueStart;

                    /* DataStoreWrite: '<S1300>/Dsw_EngTrqRespType' incorporates:
                     *  DataStoreRead: '<S1300>/VeESSR_e_StrtStpTypEngTorqRespType_DS'
                     */
                    VeESSR_e_EngTrqRespType_DS =
                        VeESSR_e_StrtStpTypEngTorqRespType_DS;

                    /* DataStoreWrite: '<S1300>/Dsw_InhibitShiftToMode' incorporates:
                     *  Constant: '<S1355>/Calib'
                     */
                    VeESSR_b_InhibitShiftToMode_DS =
                        KeESSR_b_ShftInhbtSpnUpBumpStrtSt;

                    /* DataStoreWrite: '<S1300>/Dsw_StrtStpFailDTC' incorporates:
                     *  Constant: '<S1353>/Constant'
                     */
                    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

                    /* DataStoreWrite: '<S1300>/Dsw_TransFldPmpSel' incorporates:
                     *  Constant: '<S1356>/Calib'
                     */
                    VeESSR_e_TransFldPmpSel_DS =
                        KeESSR_e_TransFldPmpSelSpinUpBumpStrtSt;

                    /* End of Outputs for SubSystem: '<S563>/SpnUpFreEng_Bmp_En' */

                    /* Outputs for Function Call SubSystem: '<S563>/SpnUpFreEng_Bmp_Du' */
                    ESSR_ac_SpnUpFreEng_Bmp_Du(VeESSR_n_TransInSpdFlt,
                        VeESSR_M_EngTrqAct_Lmtd,
                        ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                        ESSR_ac_B.LeESSI_n_InputSpeedDsrdM2,
                        VeESSR_n_OptInputSpd_Local,
                        ESSR_ac_B.TmpSignalConversionAtVeESMR_P_B,
                        ESSR_ac_B.LeESSI_n_TransMinInputSpd,
                        ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R,
                        ESSR_ac_B.VariantMerge_For_Variant_Source,
                        ESSR_ac_B.LeESSI_d_TCMFailures,
                        ESSR_ac_B.TmpSignalConversionAtVeHPMR_b_P,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                        ESSR_ac_B.LeESSI_M_MtrB_TorqCmnd_ov,
                        ESSR_ac_B.LeESSI_M_OutputTorqReqImmedHTDR,
                        &ESSR_ac_DW.SpnUpFreEng_Bmp_Du,
                        &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                    /* End of Outputs for SubSystem: '<S563>/SpnUpFreEng_Bmp_Du' */
#endif

                }
                else
                {
                    /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinDur' */
                    /* RelationalOperator: '<S1022>/Equal2' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr'
                     */
                    /* Event: '<S165>:81' */
                    rtb_NOT_i = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

                    /* Switch: '<S1078>/Switch1' incorporates:
                     *  Constant: '<S1033>/Constant Value5'
                     *  UnitDelay: '<S1078>/Unit Delay'
                     */
                    if (rtb_NOT_i)
                    {
                        rtb_Multiplication1_cp = 0.0F;
                    }
                    else
                    {
                        rtb_Multiplication1_cp = ESSR_ac_DW.UnitDelay_DSTATE_iu;
                    }

                    /* Sum: '<S1033>/Sum' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitSpinScaler'
                     *  Product: '<S1022>/Product'
                     */
                    rtb_Switch3_bg = (HeESSR_t_MedTEB_dT *
                                      VeESSR_k_StrtTypInitSpinScaler_DS) +
                        rtb_Multiplication1_cp;

                    /* Outputs for Atomic SubSystem: '<S1033>/Limiter' */
                    /* Switch: '<S1077>/Switch1' incorporates:
                     *  DataStoreRead: '<S1033>/Dsr_StrtTypInitSpinEndPnt'
                     *  RelationalOperator: '<S1077>/Relational Operator'
                     */
                    if (VeESSR_Cnt_StrtTypInitSpinEndPnt_DS < rtb_Switch3_bg)
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;
                    }
                    else
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = rtb_Switch3_bg;
                    }

                    /* Switch: '<S1077>/Switch' incorporates:
                     *  Constant: '<S1033>/Constant Value1'
                     *  RelationalOperator: '<S1077>/Relational Operator1'
                     */
                    if (rtb_Gain_kd > 0.0F)
                    {
                        /* Switch: '<S1077>/Switch' */
                        VeESSR_Cnt_InitSpnStepPt = rtb_Gain_kd;
                    }
                    else
                    {
                        /* Switch: '<S1077>/Switch' */
                        VeESSR_Cnt_InitSpnStepPt = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1033>/Limiter' */

                    /* RelationalOperator: '<S1034>/Greater  Than2' incorporates:
                     *  DataStoreRead: '<S1034>/Dsr_StrtTypInitSpinEndPnt'
                     */
                    VeESSR_b_InitSpnTmrCmplt = (VeESSR_Cnt_InitSpnStepPt >=
                        VeESSR_Cnt_StrtTypInitSpinEndPnt_DS);

                    /* Outputs for Atomic SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */
                    /* Switch: '<S1058>/Switch' */
                    if (rtb_NOT_i)
                    {
                        /* Switch: '<S1058>/Switch' incorporates:
                         *  Constant: '<S1029>/Constant Value4'
                         */
                        rtb_Multiplication1_cp = 0.0F;
                    }
                    else
                    {
                        /* Switch: '<S1058>/Switch' incorporates:
                         *  Constant: '<S1029>/Cnvrt2Deg'
                         *  Constant: '<S1057>/Calib'
                         *  Product: '<S1058>/Division'
                         *  Product: '<S1058>/Multiplication'
                         *  Sum: '<S1058>/Sum//Sub'
                         *  UnitDelay: '<S1058>/Unit Delay'
                         */
                        rtb_Multiplication1_cp = ((HeESSR_t_MedTEB_dT /
                            0.166666672F) *
                            ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I) +
                            ESSR_ac_DW.UnitDelay_DSTATE_e;
                    }

                    /* Outputs for Atomic SubSystem: '<S1058>/Limiter' */
                    /* Switch: '<S1061>/Switch1' incorporates:
                     *  Constant: '<S1029>/Constant Value1'
                     *  RelationalOperator: '<S1061>/Relational Operator'
                     */
                    if (999.0F < rtb_Multiplication1_cp)
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = 999.0F;
                    }
                    else
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = rtb_Multiplication1_cp;
                    }

                    /* Switch: '<S1061>/Switch' incorporates:
                     *  Constant: '<S1029>/Constant Value'
                     *  RelationalOperator: '<S1061>/Relational Operator1'
                     */
                    if (rtb_Gain_kd <= 0.0F)
                    {
                        /* Switch: '<S1061>/Switch' */
                        rtb_Gain_kd = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1058>/Limiter' */

                    /* Update for UnitDelay: '<S1058>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_e = rtb_Gain_kd;

                    /* End of Outputs for SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */

                    /* Switch: '<S1070>/Switch1' incorporates:
                     *  Constant: '<S1029>/Constant Value3'
                     *  DataStoreRead: '<S1029>/Dsr_STMTmr3'
                     *  Product: '<S1060>/Division'
                     *  Sum: '<S1029>/Subtraction'
                     */
                    rtb_Multiplication1_cp =
                        (ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi -
                         VeESSR_phi_InitEngAng720_DS) / 720.0F;

                    /* Logic: '<S1029>/AND' incorporates:
                     *  Constant: '<S1029>/Constant Value3'
                     *  DataStoreRead: '<S1029>/Dsr_STMTmr1'
                     *  Product: '<S1060>/Multiplication'
                     *  RelationalOperator: '<S1029>/Greater  Than1'
                     *  RelationalOperator: '<S1029>/Greater  Than2'
                     *  Rounding: '<S1060>/Floor'
                     *  Sum: '<S1060>/Subtraction'
                     */
                    VeESSR_b_InitSpnEngMvmntDet = ((rtb_Gain_kd >
                        VeESSR_phi_StrtTypInitSpinBrkAng_DS) ||
                        (((rtb_Multiplication1_cp - roundf
                           (rtb_Multiplication1_cp)) * 720.0F) >
                         VeESSR_phi_StrtTypInitSpinBrkAng_DS));

                    /* Switch: '<S1044>/Switch1' incorporates:
                     *  Logic: '<S1022>/Logical'
                     */
                    rtb_LogicalOperator1_cd = ((VeESSR_b_InitSpnTmrCmplt) ||
                        (VeESSR_b_InitSpnEngMvmntDet));

                    /* RelationalOperator: '<S1022>/Greater  Than1' incorporates:
                     *  Constant: '<S1050>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr1'
                     */
                    rtb_GreaterThan1_gb = (VeESSR_t_STMTmr_DS >
                                           KeESSR_t_MaxStTmInitSpin);

                    /* Logic: '<S1022>/Logical Operator' incorporates:
                     *  Logic: '<S1022>/Logical Operator1'
                     */
                    rtb_LogicalOperator_h = ((!rtb_LogicalOperator1_cd) &&
                        rtb_GreaterThan1_gb);

                    /* Switch: '<S1022>/Switch3' incorporates:
                     *  DataStoreRead: '<S1022>/Data Store Read'
                     *  DataStoreRead: '<S1022>/Data Store Read1'
                     *  DataStoreWrite: '<S1022>/Data Store Write'
                     *  DataStoreWrite: '<S1022>/Data Store Write1'
                     *  S-Function (sfix_bitop): '<S1026>/FixPt Bitwise Operator1'
                     *  S-Function (sfix_bitop): '<S1027>/FixPt Bitwise Operator1'
                     *  Switch: '<S1022>/Switch1'
                     */
                    if (rtb_LogicalOperator_h)
                    {
                        ESSR_ac_DW.NeESSR_g_StrtStpFailRsn |= 4U;
                        VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS |
                            1U;
                    }

                    /* Outputs for Atomic SubSystem: '<S1030>/Protected Division' */
                    /* Switch: '<S1069>/Switch1' incorporates:
                     *  Constant: '<S1063>/Calib'
                     *  Constant: '<S1069>/Constant Value'
                     *  Constant: '<S1069>/Constant Value1'
                     *  Constant: '<S1069>/Constant Value2'
                     *  Constant: '<S1069>/Constant Value3'
                     *  DataStoreRead: '<S1030>/Dsr_STMTmr2'
                     *  Logic: '<S1069>/AND'
                     *  RelationalOperator: '<S1069>/Greater Than or Equal '
                     *  RelationalOperator: '<S1069>/Greater Than or Equal 1'
                     *  RelationalOperator: '<S1069>/Not Equal'
                     *  RelationalOperator: '<S1069>/Not Equal1'
                     *  Switch: '<S1069>/Switch2'
                     *  Switch: '<S1069>/Switch3'
                     */
                    if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT !=
                            0.0F))
                    {
                        /* Switch: '<S1069>/Switch1' incorporates:
                         *  Product: '<S1069>/Division'
                         */
                        rtb_Multiplication1_cp = VeESSR_t_STMTmr_DS /
                            HeESSR_t_MedTEB_dT;
                    }
                    else if (VeESSR_t_STMTmr_DS > 0.0F)
                    {
                        /* Switch: '<S1069>/Switch2' incorporates:
                         *  Constant: '<S1069>/MAXFLOAT'
                         *  Switch: '<S1069>/Switch1'
                         */
                        rtb_Multiplication1_cp = 3.402823466E+38F;
                    }
                    else if (VeESSR_t_STMTmr_DS < 0.0F)
                    {
                        /* Switch: '<S1069>/Switch3' incorporates:
                         *  Constant: '<S1069>/MINFLOAT'
                         *  Switch: '<S1069>/Switch1'
                         *  Switch: '<S1069>/Switch2'
                         */
                        rtb_Multiplication1_cp = -3.402823466E+38F;
                    }
                    else
                    {
                        /* Switch: '<S1069>/Switch1' incorporates:
                         *  Constant: '<S1069>/Constant Value4'
                         *  Switch: '<S1069>/Switch2'
                         *  Switch: '<S1069>/Switch3'
                         */
                        rtb_Multiplication1_cp = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1030>/Protected Division' */

                    /* Sum: '<S1030>/Summation2' incorporates:
                     *  Constant: '<S1030>/Constant Value'
                     *  Gain: '<S1030>/Gain'
                     *  Lookup_n-D: '<S1066>/Vector'
                     *  Lookup_n-D: '<S1068>/Vector'
                     *  MinMax: '<S1030>/MinMax'
                     *  Product: '<S1030>/Product1'
                     *  Switch: '<S1069>/Switch1'
                     */
                    VeESSR_M_InitSpinEngFricEngStrtTorq = (fmaxf
                        (-VeESSR_M_EngTrqAct_Lmtd, 0.0F) * look1_iflf_binlcapw
                        (rtb_Multiplication1_cp, ((const float32 *)
                        &(KxESSR_K_InitSpinEngStrtTorqGain[0])), ((const float32
                        *)&(KtESSR_K_InitSpinEngStrtTorqGain[0])), 4U)) +
                        look1_iflf_binlcapw(rtb_Multiplication1_cp, ((const
                        float32 *)&(KxESSR_M_InitSpinEngStrtTorqOffset[0])), ((
                        const float32 *)&(KtESSR_M_InitSpinEngStrtTorqOffset[0])),
                                            4U);

                    /* Abs: '<S1030>/Abs' */
                    VeESSR_M_InitSpinEngPulseEngStrtTorq = fabsf
                        (ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E);

                    /* Lookup_n-D: '<S1067>/Vector' incorporates:
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     */
                    VeESSR_M_InitSpinECTEngStrtTorq = look1_iflf_binlcapw
                        (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                           float32 *)&(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((
                           const float32 *)&(KtESSR_M_ECTAddtlEngStrtTorq[0])),
                         6U);

                    /* Sum: '<S1030>/Summation1' */
                    VeESSR_M_InitSpinEngStrtTorqRaw =
                        (VeESSR_M_InitSpinEngFricEngStrtTorq +
                         VeESSR_M_InitSpinEngPulseEngStrtTorq) +
                        VeESSR_M_InitSpinECTEngStrtTorq;

                    /* Outputs for Atomic SubSystem: '<S1030>/GradientLimiter' */
                    /* Product: '<S1032>/Product' incorporates:
                     *  UnitDelay: '<S1062>/Unit Delay'
                     */
                    rtb_Gain_kd = ESSR_ac_DW.UnitDelay_DSTATE_h;

                    /* Sum: '<S1062>/Sum2' */
                    rtb_Multiplication1_cp = VeESSR_M_InitSpinEngStrtTorqRaw -
                        rtb_Gain_kd;

                    /* Outputs for Atomic SubSystem: '<S1062>/Limiter' */
                    /* Switch: '<S1070>/Switch1' incorporates:
                     *  Constant: '<S1065>/Calib'
                     *  RelationalOperator: '<S1070>/Relational Operator'
                     */
                    if (KeESSR_dM_InitSpinEngStrtTorqLU < rtb_Multiplication1_cp)
                    {
                        /* Switch: '<S1070>/Switch1' */
                        rtb_Multiplication1_cp = KeESSR_dM_InitSpinEngStrtTorqLU;
                    }

                    /* Switch: '<S1070>/Switch' incorporates:
                     *  Constant: '<S1064>/Calib'
                     *  RelationalOperator: '<S1070>/Relational Operator1'
                     */
                    if (rtb_Multiplication1_cp <=
                            KeESSR_dM_InitSpinEngStrtTorqLD)
                    {
                        rtb_Multiplication1_cp = KeESSR_dM_InitSpinEngStrtTorqLD;
                    }

                    /* End of Outputs for SubSystem: '<S1062>/Limiter' */

                    /* Sum: '<S1062>/Sum3' */
                    VeESSR_M_InitSpinEngStrtTorqLmtd = rtb_Multiplication1_cp +
                        rtb_Gain_kd;

                    /* Update for UnitDelay: '<S1062>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_h =
                        VeESSR_M_InitSpinEngStrtTorqLmtd;

                    /* End of Outputs for SubSystem: '<S1030>/GradientLimiter' */

                    /* Switch: '<S1022>/Switch7' incorporates:
                     *  Constant: '<S1040>/Calib'
                     *  DataStoreWrite: '<S1022>/Data Store Write3'
                     */
                    if (!HeESSR_b_EngStrtTorq)
                    {
                        VeESSR_M_EngStrtTorq_DS =
                            VeESSR_M_InitSpinEngStrtTorqLmtd;
                    }

                    /* Logic: '<S1022>/Logical2' incorporates:
                     *  Constant: '<S1036>/Constant'
                     *  Constant: '<S1037>/Constant'
                     *  Constant: '<S1038>/Calib'
                     *  Constant: '<S1039>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                     *  Logic: '<S1022>/Logical1'
                     *  Logic: '<S1022>/Logical3'
                     *  Logic: '<S1022>/Logical6'
                     *  RelationalOperator: '<S1022>/Comparison1'
                     *  RelationalOperator: '<S1022>/Comparison4'
                     */
                    rtb_Logical2_dq = ((((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                        CeESSR_e_KeyCrnkAlgo) || (((uint32)
                                         VeESSR_e_EngStrtProfType_DS) ==
                                        CeESSR_e_LowPwrAlgo));
                    rtb_Logical2_dq = (((HeESSR_b_12vStrtrEquipped) ||
                                        ((HeESSR_b_BumpStrtEquipped) &&
                                         rtb_Logical2_dq)) && rtb_Logical2_dq);

                    /* MinMax: '<S1032>/MinMax' incorporates:
                     *  DataStoreRead: '<S1032>/Dsr_StrtTypInitSpinEndPnt'
                     *  SignalConversion generated from: '<S1075>/Vector'
                     */
                    rtb_MinMax_e[0] = VeESSR_Cnt_InitSpnStepPt;
                    rtb_MinMax_e[1] = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;

                    /* Sum: '<S1032>/Sum' */
                    rtb_Multiplication1_cp = VeESSR_M_EngTrqAct_Lmtd -
                        VeESSR_M_SpnUpAddtlTorq;
                    for (iU = 0; iU < 2; iU++)
                    {
                        rtb_MinMax_e[iU] = fmaxf(VeESSR_M_TiEstMin,
                            look1_iflf_binlcapw(rtb_MinMax_e[iU], ((const
                            float32 *)&(KxESSR_K_InitSpinTiProf[0])), ((const
                            float32 *)&(KtESSR_K_InitSpinTiProf[0])), 6U) *
                            rtb_Multiplication1_cp);
                    }

                    /* Switch: '<S1022>/Switch2' incorporates:
                     *  Constant: '<S1022>/Constant Value1'
                     *  DataStoreWrite: '<S1022>/Dsw_InputTorqEst'
                     *  Lookup_n-D: '<S1075>/Vector'
                     *  MinMax: '<S1032>/MinMax'
                     *  Product: '<S1032>/Product1'
                     */
                    if (rtb_Logical2_dq)
                    {
                        VeESSR_M_EngTorqEst_DS = 0.0F;
                    }
                    else
                    {
                        VeESSR_M_EngTorqEst_DS = rtb_MinMax_e[0];
                    }

                    /* DataStoreWrite: '<S1022>/Dsw_STMTmr' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr'
                     *  Sum: '<S1022>/Summation'
                     */
                    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

                    /* Switch: '<S1044>/Switch1' incorporates:
                     *  Constant: '<S1049>/Calib'
                     */
                    if (KeESSR_b_InitSpnTmrChkOnly)
                    {
                        /* Switch: '<S1044>/Switch1' */
                        rtb_LogicalOperator1_cd = VeESSR_b_InitSpnTmrCmplt;
                    }

                    /* SignalConversion generated from: '<S1022>/Variant Source' incorporates:
                     *  Logic: '<S1054>/Logical1'
                     *  Logic: '<S1054>/Logical2'
                     *  Logic: '<S1054>/Logical3'
                     *  Logic: '<S1054>/Logical4'
                     *  RelationalOperator: '<S1054>/Comparison1'
                     *  RelationalOperator: '<S1054>/Comparison6'
                     *  RelationalOperator: '<S1054>/Comparison7'
                     *  RelationalOperator: '<S1054>/Comparison8'
                     */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* Switch: '<S1022>/Switch5' incorporates:
                     *  Constant: '<S1022>/FALSE Constant1'
                     */
                    rtb_Equal_d = false;

#else

                    /* Logic: '<S1054>/Logical4' incorporates:
                     *  Constant: '<S1085>/Constant'
                     *  Constant: '<S1086>/Constant'
                     *  Constant: '<S1087>/Constant'
                     *  Constant: '<S1088>/Constant'
                     *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                     *  Logic: '<S1054>/Logical1'
                     *  Logic: '<S1054>/Logical2'
                     *  Logic: '<S1054>/Logical3'
                     *  RelationalOperator: '<S1022>/Comparison4'
                     *  RelationalOperator: '<S1054>/Comparison1'
                     *  RelationalOperator: '<S1054>/Comparison6'
                     *  RelationalOperator: '<S1054>/Comparison7'
                     *  RelationalOperator: '<S1054>/Comparison8'
                     */
                    VeESSR_b_InitSpin_48VP2CoastDown = (((((((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMStrtAlgo) ||
                        (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                         CeESSR_e_ImplStrtAlgo)) || (((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo))
                        && (VeESSR_b_EMErlyExitLmp)) || ((((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_CltchStrtAlgo) &&
                        (VeESSR_b_ClthErlyExitLmp)));

                    /* Switch: '<S1022>/Switch5' */
                    rtb_Equal_d = VeESSR_b_InitSpin_48VP2CoastDown;

#endif

                    /* Switch: '<S1022>/Switch5' */
                    if (!VeESSR_b_StrtTypChngDisbl)
                    {
                        /* Switch: '<S1022>/Switch5' incorporates:
                         *  Constant: '<S1035>/Constant'
                         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                         *  Logic: '<S1022>/Logical Operator4'
                         *  Logic: '<S1022>/Logical Operator5'
                         *  RelationalOperator: '<S1022>/Comparison2'
                         *  RelationalOperator: '<S1022>/Comparison4'
                         */
                        rtb_Equal_d =
                            (((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B) ||
                              ((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d) &&
                               (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                CeESSR_e_KeyCrnkAlgo))) || (VeESSR_b_ErlyExitLmp));
                    }

                    /* Logic: '<S1022>/Logical Operator3' incorporates:
                     *  Constant: '<S1041>/Calib'
                     *  Constant: '<S1045>/Calib'
                     *  Constant: '<S1046>/Calib'
                     *  Constant: '<S1047>/Calib'
                     *  Constant: '<S1048>/Calib'
                     *  DataStoreRead: '<S1022>/Data Store Read18'
                     *  DataStoreRead: '<S1022>/Data Store Read19'
                     *  Logic: '<S1022>/Logical Operator2'
                     *  Logic: '<S1022>/Logical5'
                     *  Logic: '<S1022>/Logical8'
                     *  Logic: '<S1022>/Logical9'
                     *  RelationalOperator: '<S1022>/Greater  Than11'
                     *  RelationalOperator: '<S1022>/Greater  Than15'
                     */
                    VeESSR_b_InitSpin_CoastDownTrig = ((rtb_Equal_d ||
                        rtb_LogicalOperator_h) && ((((KeESSR_b_EnblFtrBackupStrt)
                        && (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
                            KeESSR_Cnt_BackupStrtMaxAttmpts)) ||
                        ((KeESSR_b_EnblFtrBumpStrt) &&
                         (VeESSR_Cnt_BumpStrtAttmptCntr_DS <
                          KeESSR_Cnt_BumpStrtMaxAttmpts))) ||
                        (HeESSR_b_LimphomeEnbl)));

                    /* If: '<S1022>/If1' */
                    if (rtb_LogicalOperator1_cd)
                    {
                        /* Outputs for IfAction SubSystem: '<S1022>/NormExit' incorporates:
                         *  ActionPort: '<S1052>/Action Port'
                         */
                        /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                         *  Constant: '<S1082>/Constant'
                         *  Merge: '<S1022>/Merge1'
                         *  SignalConversion generated from: '<S1052>/ESSTrig'
                         */
                        VeESSR_e_STMTrigger_DS = CeESSR_e_EngBrkawayAch;

                        /* End of Outputs for SubSystem: '<S1022>/NormExit' */
                    }
                    else if (VeESSR_b_InitSpin_CoastDownTrig)
                    {
                        /* Outputs for IfAction SubSystem: '<S1022>/If Action Subsystem' incorporates:
                         *  ActionPort: '<S1043>/Action Port'
                         */
                        /* Switch: '<S1043>/Switch' incorporates:
                         *  Constant: '<S1080>/Constant'
                         *  Constant: '<S1081>/Constant'
                         *  DataStoreRead: '<S1043>/Data Store Read5'
                         *  DataStoreWrite: '<S1043>/Dsw_StrtStpFailDTC'
                         */
                        if (VeESSR_b_BSGStrtFailed_DS)
                        {
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;
                        }
                        else
                        {
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
                        }

                        /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                         *  Constant: '<S1079>/Constant'
                         *  Merge: '<S1022>/Merge1'
                         *  SignalConversion generated from: '<S1043>/ESSTrig'
                         */
                        VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

                        /* End of Outputs for SubSystem: '<S1022>/If Action Subsystem' */
                    }
                    else
                    {
                        if (rtb_GreaterThan1_gb)
                        {
                            /* Outputs for IfAction SubSystem: '<S1022>/OffFail' incorporates:
                             *  ActionPort: '<S1053>/Action Port'
                             */
                            /* DataStoreWrite: '<S1053>/Dsw_StrtStpFailDTC' incorporates:
                             *  Constant: '<S1084>/Constant'
                             */
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;

                            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                             *  Constant: '<S1083>/Constant'
                             *  Merge: '<S1022>/Merge1'
                             *  SignalConversion generated from: '<S1053>/ESSTrig'
                             */
                            VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

                            /* End of Outputs for SubSystem: '<S1022>/OffFail' */
                        }
                    }

                    /* Switch: '<S1022>/Switch4' incorporates:
                     *  Constant: '<S1022>/Constant Value2'
                     *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType2'
                     *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType6'
                     *  DataStoreWrite: '<S1022>/Dsw_StrtStpFailDTC1'
                     *  Logic: '<S1022>/Logical21'
                     *  Logic: '<S1022>/Logical7'
                     *  RelationalOperator: '<S1022>/Comparison'
                     *  S-Function (sfix_bitop): '<S1022>/Bitwise Operator'
                     *  S-Function (sfix_bitop): '<S1028>/FixPt Bitwise Operator1'
                     */
                    if (((VeESSR_b_InitSpin_CoastDownTrig) ||
                            rtb_GreaterThan1_gb) &&
                            ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16U) > 0U))
                    {
                        VeESSR_g_StrtStpFailPhase_DS =
                            VeESSR_g_StrtStpFailPhase_DS | 16U;
                    }

                    /* Switch: '<S1071>/Switch1' incorporates:
                     *  Constant: '<S1072>/Calib'
                     *  DataStoreWrite: '<S1031>/Dsw_InitEngAng720'
                     *  RelationalOperator: '<S1031>/Equal1'
                     */
                    if (VeESSR_Cnt_InitSpnStepPt <= KeESSR_t_InitSpnInitAngTm)
                    {
                        VeESSR_phi_InitEngAng720_DS =
                            ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi;
                    }

                    /* Sum: '<S1032>/Subtract' incorporates:
                     *  Constant: '<S1074>/Calib'
                     *  DataStoreRead: '<S1032>/Dsr_NiProfGenNiDMax'
                     *  DataStoreWrite: '<S1032>/Data Store Write'
                     *  Product: '<S1032>/Product'
                     */
                    ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = rtb_MinMax_e[1] -
                        (VeESSR_dn_StrtTypNiDotMax_DS * KeESSR_r_NiDtoTiMargin);

                    /* DataStoreWrite: '<S1022>/Dsw_InputAcceltnProf1' */
                    VeESSR_dn_InputAcceltnProf_DS =
                        ESSR_ac_B.VariantMerge_For_Variant_Source;

                    /* RelationalOperator: '<S1022>/Equal1' incorporates:
                     *  Constant: '<S1022>/Constant Value'
                     *  DataStoreRead: '<S1022>/Data Store Read5'
                     *  DataStoreWrite: '<S1022>/Data Store Write5'
                     */
                    VeESSR_b_BSGStrtFailed_DS = (VeESSR_g_BSGStrtFailRsn_DS !=
                        0U);

                    /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqImmed' incorporates:
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitImmedTorq'
                     */
                    VeESSR_M_EngTrqReqImmed_DS =
                        VeESSR_M_StrtTypInitImmedTorq_DS;

                    /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqPrdtd1' incorporates:
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitPredTorq'
                     */
                    VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

                    /* Switch: '<S1078>/Switch3' */
                    if (rtb_NOT_i)
                    {
                        /* Update for UnitDelay: '<S1078>/Unit Delay' incorporates:
                         *  Constant: '<S1033>/Constant Value5'
                         */
                        ESSR_ac_DW.UnitDelay_DSTATE_iu = 0.0F;
                    }
                    else
                    {
                        /* Update for UnitDelay: '<S1078>/Unit Delay' */
                        ESSR_ac_DW.UnitDelay_DSTATE_iu = rtb_Switch3_bg;
                    }

                    /* End of Outputs for SubSystem: '<S559>/InitEngSpinDur' */
                }
                break;

              case ESSR_ac_IN_InitEngSpin_5:
                /* During 'InitEngSpin_5': '<S165>:182' */
                if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngBrkawayAch)
                {
                    /* Transition: '<S165>:186' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_ESSC_SpinUp_CS;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'ESSC_SpinUp_CS': '<S165>:184' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Event: '<S165>:190' */
                    /* Event: '<S165>:191' */
#if Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* Outputs for Function Call SubSystem: '<S567>/SpinUp_CS_Ent' */
                    /* DataStoreWrite: '<S1732>/Dsw_EngStartStopSt' incorporates:
                     *  Constant: '<S1759>/Constant'
                     */
                    VeESSR_e_EngStartStopSt_DS = CeESSR_e_SpinUpClStrtSt;

                    /* DataStoreWrite: '<S1732>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
                     *  Constant: '<S1732>/Constant Value3'
                     */
                    VeESSR_M_MtrA_MaxTorq_DS = 0.0F;

                    /* DataStoreWrite: '<S1732>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
                     *  Constant: '<S1732>/Constant Value3'
                     */
                    VeESSR_M_MtrA_MinTorq_DS = 0.0F;

                    /* DataStoreWrite: '<S1732>/Dsw_AEMDMtrBGain' incorporates:
                     *  Constant: '<S1764>/Calib'
                     */
                    VeESSR_scl_AEMDMtrBGain_DS =
                        KeESSR_scl_AEMDMtrBGain_SpnUpClSt;

                    /* DataStoreWrite: '<S1732>/Dsw_AStrtPBatBoostReq' incorporates:
                     *  Constant: '<S1732>/FALSE Constant'
                     */
                    VeESSR_b_AStrtPBatBoostReq_DS = false;

                    /* DataStoreWrite: '<S1732>/Dsw_InhibitShiftToMode' incorporates:
                     *  Constant: '<S1732>/FALSE Constant'
                     */
                    VeESSR_b_InhibitShiftToMode_DS = false;

                    /* DataStoreWrite: '<S1732>/Dsw_EngStrtStpMd2' incorporates:
                     *  Constant: '<S1763>/Constant'
                     */
                    VeESSR_e_EngStrtStpMd_DS = CeESSR_e_StartPending;

                    /* DataStoreWrite: '<S1732>/Dsw_EngStrtType1' incorporates:
                     *  Constant: '<S1761>/Constant'
                     */
                    VeESSR_e_TCM_StartStopType_DS = CeESSR_e_CltchStrt;

                    /* DataStoreWrite: '<S1732>/Dsw_EngStrtType2' incorporates:
                     *  Constant: '<S1762>/Constant'
                     */
                    VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Cranking;

                    /* DataStoreWrite: '<S1732>/Dsw_EngTrqRespType' incorporates:
                     *  DataStoreRead: '<S1732>/VeESSR_e_StrtStpTypEngTorqRespType_DS'
                     */
                    VeESSR_e_EngTrqRespType_DS =
                        VeESSR_e_StrtStpTypEngTorqRespType_DS;

                    /* DataStoreWrite: '<S1732>/Dsw_StrtStpFailDTC' incorporates:
                     *  Constant: '<S1760>/Constant'
                     */
                    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

                    /* End of Outputs for SubSystem: '<S567>/SpinUp_CS_Ent' */

                    /* Outputs for Function Call SubSystem: '<S567>/SpinUp_CS_Dur' */
                    ESSR_ac_SpinUp_CS_Dur(VeESSR_M_EngTrqAct_Lmtd,
                                          VeESSR_M_SpnUpAddtlTorq,
                                          VeESSR_n_TransInSpdFlt,
                                          ESSR_ac_B.TmpSignalConversionAtVeESSR__no,
                                          ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                          ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p,
                                          ESSR_ac_B.TmpSignalConversionAtEngineLoss,
                                          ESSR_ac_B.TmpSignalConversionAtVeENGR_p_E,
                                          VeESSR_b_ClthLwrThresLmp,
                                          VeESSR_b_ClthErlyExitLmp,
                                          &ESSR_ac_DW.SpinUp_CS_Dur,
                                          &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                    /* End of Outputs for SubSystem: '<S567>/SpinUp_CS_Dur' */
#endif

                }
                else
                {
                    /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinDur' */
                    /* RelationalOperator: '<S1022>/Equal2' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr'
                     */
                    /* Event: '<S165>:81' */
                    rtb_NOT_i = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

                    /* Switch: '<S1078>/Switch1' incorporates:
                     *  Constant: '<S1033>/Constant Value5'
                     *  UnitDelay: '<S1078>/Unit Delay'
                     */
                    if (rtb_NOT_i)
                    {
                        rtb_Multiplication1_cp = 0.0F;
                    }
                    else
                    {
                        rtb_Multiplication1_cp = ESSR_ac_DW.UnitDelay_DSTATE_iu;
                    }

                    /* Sum: '<S1033>/Sum' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitSpinScaler'
                     *  Product: '<S1022>/Product'
                     */
                    rtb_Switch3_bg = (HeESSR_t_MedTEB_dT *
                                      VeESSR_k_StrtTypInitSpinScaler_DS) +
                        rtb_Multiplication1_cp;

                    /* Outputs for Atomic SubSystem: '<S1033>/Limiter' */
                    /* Switch: '<S1077>/Switch1' incorporates:
                     *  DataStoreRead: '<S1033>/Dsr_StrtTypInitSpinEndPnt'
                     *  RelationalOperator: '<S1077>/Relational Operator'
                     */
                    if (VeESSR_Cnt_StrtTypInitSpinEndPnt_DS < rtb_Switch3_bg)
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;
                    }
                    else
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = rtb_Switch3_bg;
                    }

                    /* Switch: '<S1077>/Switch' incorporates:
                     *  Constant: '<S1033>/Constant Value1'
                     *  RelationalOperator: '<S1077>/Relational Operator1'
                     */
                    if (rtb_Gain_kd > 0.0F)
                    {
                        /* Switch: '<S1077>/Switch' */
                        VeESSR_Cnt_InitSpnStepPt = rtb_Gain_kd;
                    }
                    else
                    {
                        /* Switch: '<S1077>/Switch' */
                        VeESSR_Cnt_InitSpnStepPt = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1033>/Limiter' */

                    /* RelationalOperator: '<S1034>/Greater  Than2' incorporates:
                     *  DataStoreRead: '<S1034>/Dsr_StrtTypInitSpinEndPnt'
                     */
                    VeESSR_b_InitSpnTmrCmplt = (VeESSR_Cnt_InitSpnStepPt >=
                        VeESSR_Cnt_StrtTypInitSpinEndPnt_DS);

                    /* Outputs for Atomic SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */
                    /* Switch: '<S1058>/Switch' */
                    if (rtb_NOT_i)
                    {
                        /* Switch: '<S1058>/Switch' incorporates:
                         *  Constant: '<S1029>/Constant Value4'
                         */
                        rtb_Multiplication1_cp = 0.0F;
                    }
                    else
                    {
                        /* Switch: '<S1058>/Switch' incorporates:
                         *  Constant: '<S1029>/Cnvrt2Deg'
                         *  Constant: '<S1057>/Calib'
                         *  Product: '<S1058>/Division'
                         *  Product: '<S1058>/Multiplication'
                         *  Sum: '<S1058>/Sum//Sub'
                         *  UnitDelay: '<S1058>/Unit Delay'
                         */
                        rtb_Multiplication1_cp = ((HeESSR_t_MedTEB_dT /
                            0.166666672F) *
                            ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I) +
                            ESSR_ac_DW.UnitDelay_DSTATE_e;
                    }

                    /* Outputs for Atomic SubSystem: '<S1058>/Limiter' */
                    /* Switch: '<S1061>/Switch1' incorporates:
                     *  Constant: '<S1029>/Constant Value1'
                     *  RelationalOperator: '<S1061>/Relational Operator'
                     */
                    if (999.0F < rtb_Multiplication1_cp)
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = 999.0F;
                    }
                    else
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = rtb_Multiplication1_cp;
                    }

                    /* Switch: '<S1061>/Switch' incorporates:
                     *  Constant: '<S1029>/Constant Value'
                     *  RelationalOperator: '<S1061>/Relational Operator1'
                     */
                    if (rtb_Gain_kd <= 0.0F)
                    {
                        /* Switch: '<S1061>/Switch' */
                        rtb_Gain_kd = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1058>/Limiter' */

                    /* Update for UnitDelay: '<S1058>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_e = rtb_Gain_kd;

                    /* End of Outputs for SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */

                    /* Switch: '<S1070>/Switch1' incorporates:
                     *  Constant: '<S1029>/Constant Value3'
                     *  DataStoreRead: '<S1029>/Dsr_STMTmr3'
                     *  Product: '<S1060>/Division'
                     *  Sum: '<S1029>/Subtraction'
                     */
                    rtb_Multiplication1_cp =
                        (ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi -
                         VeESSR_phi_InitEngAng720_DS) / 720.0F;

                    /* Logic: '<S1029>/AND' incorporates:
                     *  Constant: '<S1029>/Constant Value3'
                     *  DataStoreRead: '<S1029>/Dsr_STMTmr1'
                     *  Product: '<S1060>/Multiplication'
                     *  RelationalOperator: '<S1029>/Greater  Than1'
                     *  RelationalOperator: '<S1029>/Greater  Than2'
                     *  Rounding: '<S1060>/Floor'
                     *  Sum: '<S1060>/Subtraction'
                     */
                    VeESSR_b_InitSpnEngMvmntDet = ((rtb_Gain_kd >
                        VeESSR_phi_StrtTypInitSpinBrkAng_DS) ||
                        (((rtb_Multiplication1_cp - roundf
                           (rtb_Multiplication1_cp)) * 720.0F) >
                         VeESSR_phi_StrtTypInitSpinBrkAng_DS));

                    /* Switch: '<S1044>/Switch1' incorporates:
                     *  Logic: '<S1022>/Logical'
                     */
                    rtb_LogicalOperator1_cd = ((VeESSR_b_InitSpnTmrCmplt) ||
                        (VeESSR_b_InitSpnEngMvmntDet));

                    /* RelationalOperator: '<S1022>/Greater  Than1' incorporates:
                     *  Constant: '<S1050>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr1'
                     */
                    rtb_GreaterThan1_gb = (VeESSR_t_STMTmr_DS >
                                           KeESSR_t_MaxStTmInitSpin);

                    /* Logic: '<S1022>/Logical Operator' incorporates:
                     *  Logic: '<S1022>/Logical Operator1'
                     */
                    rtb_LogicalOperator_h = ((!rtb_LogicalOperator1_cd) &&
                        rtb_GreaterThan1_gb);

                    /* Switch: '<S1022>/Switch3' incorporates:
                     *  DataStoreRead: '<S1022>/Data Store Read'
                     *  DataStoreRead: '<S1022>/Data Store Read1'
                     *  DataStoreWrite: '<S1022>/Data Store Write'
                     *  DataStoreWrite: '<S1022>/Data Store Write1'
                     *  S-Function (sfix_bitop): '<S1026>/FixPt Bitwise Operator1'
                     *  S-Function (sfix_bitop): '<S1027>/FixPt Bitwise Operator1'
                     *  Switch: '<S1022>/Switch1'
                     */
                    if (rtb_LogicalOperator_h)
                    {
                        ESSR_ac_DW.NeESSR_g_StrtStpFailRsn |= 4U;
                        VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS |
                            1U;
                    }

                    /* Outputs for Atomic SubSystem: '<S1030>/Protected Division' */
                    /* Switch: '<S1069>/Switch1' incorporates:
                     *  Constant: '<S1063>/Calib'
                     *  Constant: '<S1069>/Constant Value'
                     *  Constant: '<S1069>/Constant Value1'
                     *  Constant: '<S1069>/Constant Value2'
                     *  Constant: '<S1069>/Constant Value3'
                     *  DataStoreRead: '<S1030>/Dsr_STMTmr2'
                     *  Logic: '<S1069>/AND'
                     *  RelationalOperator: '<S1069>/Greater Than or Equal '
                     *  RelationalOperator: '<S1069>/Greater Than or Equal 1'
                     *  RelationalOperator: '<S1069>/Not Equal'
                     *  RelationalOperator: '<S1069>/Not Equal1'
                     *  Switch: '<S1069>/Switch2'
                     *  Switch: '<S1069>/Switch3'
                     */
                    if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT !=
                            0.0F))
                    {
                        /* Switch: '<S1069>/Switch1' incorporates:
                         *  Product: '<S1069>/Division'
                         */
                        rtb_Multiplication1_cp = VeESSR_t_STMTmr_DS /
                            HeESSR_t_MedTEB_dT;
                    }
                    else if (VeESSR_t_STMTmr_DS > 0.0F)
                    {
                        /* Switch: '<S1069>/Switch2' incorporates:
                         *  Constant: '<S1069>/MAXFLOAT'
                         *  Switch: '<S1069>/Switch1'
                         */
                        rtb_Multiplication1_cp = 3.402823466E+38F;
                    }
                    else if (VeESSR_t_STMTmr_DS < 0.0F)
                    {
                        /* Switch: '<S1069>/Switch3' incorporates:
                         *  Constant: '<S1069>/MINFLOAT'
                         *  Switch: '<S1069>/Switch1'
                         *  Switch: '<S1069>/Switch2'
                         */
                        rtb_Multiplication1_cp = -3.402823466E+38F;
                    }
                    else
                    {
                        /* Switch: '<S1069>/Switch1' incorporates:
                         *  Constant: '<S1069>/Constant Value4'
                         *  Switch: '<S1069>/Switch2'
                         *  Switch: '<S1069>/Switch3'
                         */
                        rtb_Multiplication1_cp = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1030>/Protected Division' */

                    /* Sum: '<S1030>/Summation2' incorporates:
                     *  Constant: '<S1030>/Constant Value'
                     *  Gain: '<S1030>/Gain'
                     *  Lookup_n-D: '<S1066>/Vector'
                     *  Lookup_n-D: '<S1068>/Vector'
                     *  MinMax: '<S1030>/MinMax'
                     *  Product: '<S1030>/Product1'
                     *  Switch: '<S1069>/Switch1'
                     */
                    VeESSR_M_InitSpinEngFricEngStrtTorq = (fmaxf
                        (-VeESSR_M_EngTrqAct_Lmtd, 0.0F) * look1_iflf_binlcapw
                        (rtb_Multiplication1_cp, ((const float32 *)
                        &(KxESSR_K_InitSpinEngStrtTorqGain[0])), ((const float32
                        *)&(KtESSR_K_InitSpinEngStrtTorqGain[0])), 4U)) +
                        look1_iflf_binlcapw(rtb_Multiplication1_cp, ((const
                        float32 *)&(KxESSR_M_InitSpinEngStrtTorqOffset[0])), ((
                        const float32 *)&(KtESSR_M_InitSpinEngStrtTorqOffset[0])),
                                            4U);

                    /* Abs: '<S1030>/Abs' */
                    VeESSR_M_InitSpinEngPulseEngStrtTorq = fabsf
                        (ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E);

                    /* Lookup_n-D: '<S1067>/Vector' incorporates:
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     */
                    VeESSR_M_InitSpinECTEngStrtTorq = look1_iflf_binlcapw
                        (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                           float32 *)&(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((
                           const float32 *)&(KtESSR_M_ECTAddtlEngStrtTorq[0])),
                         6U);

                    /* Sum: '<S1030>/Summation1' */
                    VeESSR_M_InitSpinEngStrtTorqRaw =
                        (VeESSR_M_InitSpinEngFricEngStrtTorq +
                         VeESSR_M_InitSpinEngPulseEngStrtTorq) +
                        VeESSR_M_InitSpinECTEngStrtTorq;

                    /* Outputs for Atomic SubSystem: '<S1030>/GradientLimiter' */
                    /* Product: '<S1032>/Product' incorporates:
                     *  UnitDelay: '<S1062>/Unit Delay'
                     */
                    rtb_Gain_kd = ESSR_ac_DW.UnitDelay_DSTATE_h;

                    /* Sum: '<S1062>/Sum2' */
                    rtb_Multiplication1_cp = VeESSR_M_InitSpinEngStrtTorqRaw -
                        rtb_Gain_kd;

                    /* Outputs for Atomic SubSystem: '<S1062>/Limiter' */
                    /* Switch: '<S1070>/Switch1' incorporates:
                     *  Constant: '<S1065>/Calib'
                     *  RelationalOperator: '<S1070>/Relational Operator'
                     */
                    if (KeESSR_dM_InitSpinEngStrtTorqLU < rtb_Multiplication1_cp)
                    {
                        /* Switch: '<S1070>/Switch1' */
                        rtb_Multiplication1_cp = KeESSR_dM_InitSpinEngStrtTorqLU;
                    }

                    /* Switch: '<S1070>/Switch' incorporates:
                     *  Constant: '<S1064>/Calib'
                     *  RelationalOperator: '<S1070>/Relational Operator1'
                     */
                    if (rtb_Multiplication1_cp <=
                            KeESSR_dM_InitSpinEngStrtTorqLD)
                    {
                        rtb_Multiplication1_cp = KeESSR_dM_InitSpinEngStrtTorqLD;
                    }

                    /* End of Outputs for SubSystem: '<S1062>/Limiter' */

                    /* Sum: '<S1062>/Sum3' */
                    VeESSR_M_InitSpinEngStrtTorqLmtd = rtb_Multiplication1_cp +
                        rtb_Gain_kd;

                    /* Update for UnitDelay: '<S1062>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_h =
                        VeESSR_M_InitSpinEngStrtTorqLmtd;

                    /* End of Outputs for SubSystem: '<S1030>/GradientLimiter' */

                    /* Switch: '<S1022>/Switch7' incorporates:
                     *  Constant: '<S1040>/Calib'
                     *  DataStoreWrite: '<S1022>/Data Store Write3'
                     */
                    if (!HeESSR_b_EngStrtTorq)
                    {
                        VeESSR_M_EngStrtTorq_DS =
                            VeESSR_M_InitSpinEngStrtTorqLmtd;
                    }

                    /* Logic: '<S1022>/Logical2' incorporates:
                     *  Constant: '<S1036>/Constant'
                     *  Constant: '<S1037>/Constant'
                     *  Constant: '<S1038>/Calib'
                     *  Constant: '<S1039>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                     *  Logic: '<S1022>/Logical1'
                     *  Logic: '<S1022>/Logical3'
                     *  Logic: '<S1022>/Logical6'
                     *  RelationalOperator: '<S1022>/Comparison1'
                     *  RelationalOperator: '<S1022>/Comparison4'
                     */
                    rtb_Logical2_dq = ((((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                        CeESSR_e_KeyCrnkAlgo) || (((uint32)
                                         VeESSR_e_EngStrtProfType_DS) ==
                                        CeESSR_e_LowPwrAlgo));
                    rtb_Logical2_dq = (((HeESSR_b_12vStrtrEquipped) ||
                                        ((HeESSR_b_BumpStrtEquipped) &&
                                         rtb_Logical2_dq)) && rtb_Logical2_dq);

                    /* MinMax: '<S1032>/MinMax' incorporates:
                     *  DataStoreRead: '<S1032>/Dsr_StrtTypInitSpinEndPnt'
                     *  SignalConversion generated from: '<S1075>/Vector'
                     */
                    rtb_MinMax_e[0] = VeESSR_Cnt_InitSpnStepPt;
                    rtb_MinMax_e[1] = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;

                    /* Sum: '<S1032>/Sum' */
                    rtb_Multiplication1_cp = VeESSR_M_EngTrqAct_Lmtd -
                        VeESSR_M_SpnUpAddtlTorq;
                    for (iU = 0; iU < 2; iU++)
                    {
                        rtb_MinMax_e[iU] = fmaxf(VeESSR_M_TiEstMin,
                            look1_iflf_binlcapw(rtb_MinMax_e[iU], ((const
                            float32 *)&(KxESSR_K_InitSpinTiProf[0])), ((const
                            float32 *)&(KtESSR_K_InitSpinTiProf[0])), 6U) *
                            rtb_Multiplication1_cp);
                    }

                    /* Switch: '<S1022>/Switch2' incorporates:
                     *  Constant: '<S1022>/Constant Value1'
                     *  DataStoreWrite: '<S1022>/Dsw_InputTorqEst'
                     *  Lookup_n-D: '<S1075>/Vector'
                     *  MinMax: '<S1032>/MinMax'
                     *  Product: '<S1032>/Product1'
                     */
                    if (rtb_Logical2_dq)
                    {
                        VeESSR_M_EngTorqEst_DS = 0.0F;
                    }
                    else
                    {
                        VeESSR_M_EngTorqEst_DS = rtb_MinMax_e[0];
                    }

                    /* DataStoreWrite: '<S1022>/Dsw_STMTmr' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr'
                     *  Sum: '<S1022>/Summation'
                     */
                    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

                    /* Switch: '<S1044>/Switch1' incorporates:
                     *  Constant: '<S1049>/Calib'
                     */
                    if (KeESSR_b_InitSpnTmrChkOnly)
                    {
                        /* Switch: '<S1044>/Switch1' */
                        rtb_LogicalOperator1_cd = VeESSR_b_InitSpnTmrCmplt;
                    }

                    /* SignalConversion generated from: '<S1022>/Variant Source' incorporates:
                     *  Logic: '<S1054>/Logical1'
                     *  Logic: '<S1054>/Logical2'
                     *  Logic: '<S1054>/Logical3'
                     *  Logic: '<S1054>/Logical4'
                     *  RelationalOperator: '<S1054>/Comparison1'
                     *  RelationalOperator: '<S1054>/Comparison6'
                     *  RelationalOperator: '<S1054>/Comparison7'
                     *  RelationalOperator: '<S1054>/Comparison8'
                     */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* Switch: '<S1022>/Switch5' incorporates:
                     *  Constant: '<S1022>/FALSE Constant1'
                     */
                    rtb_Equal_d = false;

#else

                    /* Logic: '<S1054>/Logical4' incorporates:
                     *  Constant: '<S1085>/Constant'
                     *  Constant: '<S1086>/Constant'
                     *  Constant: '<S1087>/Constant'
                     *  Constant: '<S1088>/Constant'
                     *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                     *  Logic: '<S1054>/Logical1'
                     *  Logic: '<S1054>/Logical2'
                     *  Logic: '<S1054>/Logical3'
                     *  RelationalOperator: '<S1022>/Comparison4'
                     *  RelationalOperator: '<S1054>/Comparison1'
                     *  RelationalOperator: '<S1054>/Comparison6'
                     *  RelationalOperator: '<S1054>/Comparison7'
                     *  RelationalOperator: '<S1054>/Comparison8'
                     */
                    VeESSR_b_InitSpin_48VP2CoastDown = (((((((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMStrtAlgo) ||
                        (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                         CeESSR_e_ImplStrtAlgo)) || (((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo))
                        && (VeESSR_b_EMErlyExitLmp)) || ((((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_CltchStrtAlgo) &&
                        (VeESSR_b_ClthErlyExitLmp)));

                    /* Switch: '<S1022>/Switch5' */
                    rtb_Equal_d = VeESSR_b_InitSpin_48VP2CoastDown;

#endif

                    /* Switch: '<S1022>/Switch5' */
                    if (!VeESSR_b_StrtTypChngDisbl)
                    {
                        /* Switch: '<S1022>/Switch5' incorporates:
                         *  Constant: '<S1035>/Constant'
                         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                         *  Logic: '<S1022>/Logical Operator4'
                         *  Logic: '<S1022>/Logical Operator5'
                         *  RelationalOperator: '<S1022>/Comparison2'
                         *  RelationalOperator: '<S1022>/Comparison4'
                         */
                        rtb_Equal_d =
                            (((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B) ||
                              ((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d) &&
                               (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                CeESSR_e_KeyCrnkAlgo))) || (VeESSR_b_ErlyExitLmp));
                    }

                    /* Logic: '<S1022>/Logical Operator3' incorporates:
                     *  Constant: '<S1041>/Calib'
                     *  Constant: '<S1045>/Calib'
                     *  Constant: '<S1046>/Calib'
                     *  Constant: '<S1047>/Calib'
                     *  Constant: '<S1048>/Calib'
                     *  DataStoreRead: '<S1022>/Data Store Read18'
                     *  DataStoreRead: '<S1022>/Data Store Read19'
                     *  Logic: '<S1022>/Logical Operator2'
                     *  Logic: '<S1022>/Logical5'
                     *  Logic: '<S1022>/Logical8'
                     *  Logic: '<S1022>/Logical9'
                     *  RelationalOperator: '<S1022>/Greater  Than11'
                     *  RelationalOperator: '<S1022>/Greater  Than15'
                     */
                    VeESSR_b_InitSpin_CoastDownTrig = ((rtb_Equal_d ||
                        rtb_LogicalOperator_h) && ((((KeESSR_b_EnblFtrBackupStrt)
                        && (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
                            KeESSR_Cnt_BackupStrtMaxAttmpts)) ||
                        ((KeESSR_b_EnblFtrBumpStrt) &&
                         (VeESSR_Cnt_BumpStrtAttmptCntr_DS <
                          KeESSR_Cnt_BumpStrtMaxAttmpts))) ||
                        (HeESSR_b_LimphomeEnbl)));

                    /* If: '<S1022>/If1' */
                    if (rtb_LogicalOperator1_cd)
                    {
                        /* Outputs for IfAction SubSystem: '<S1022>/NormExit' incorporates:
                         *  ActionPort: '<S1052>/Action Port'
                         */
                        /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                         *  Constant: '<S1082>/Constant'
                         *  Merge: '<S1022>/Merge1'
                         *  SignalConversion generated from: '<S1052>/ESSTrig'
                         */
                        VeESSR_e_STMTrigger_DS = CeESSR_e_EngBrkawayAch;

                        /* End of Outputs for SubSystem: '<S1022>/NormExit' */
                    }
                    else if (VeESSR_b_InitSpin_CoastDownTrig)
                    {
                        /* Outputs for IfAction SubSystem: '<S1022>/If Action Subsystem' incorporates:
                         *  ActionPort: '<S1043>/Action Port'
                         */
                        /* Switch: '<S1043>/Switch' incorporates:
                         *  Constant: '<S1080>/Constant'
                         *  Constant: '<S1081>/Constant'
                         *  DataStoreRead: '<S1043>/Data Store Read5'
                         *  DataStoreWrite: '<S1043>/Dsw_StrtStpFailDTC'
                         */
                        if (VeESSR_b_BSGStrtFailed_DS)
                        {
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;
                        }
                        else
                        {
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
                        }

                        /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                         *  Constant: '<S1079>/Constant'
                         *  Merge: '<S1022>/Merge1'
                         *  SignalConversion generated from: '<S1043>/ESSTrig'
                         */
                        VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

                        /* End of Outputs for SubSystem: '<S1022>/If Action Subsystem' */
                    }
                    else
                    {
                        if (rtb_GreaterThan1_gb)
                        {
                            /* Outputs for IfAction SubSystem: '<S1022>/OffFail' incorporates:
                             *  ActionPort: '<S1053>/Action Port'
                             */
                            /* DataStoreWrite: '<S1053>/Dsw_StrtStpFailDTC' incorporates:
                             *  Constant: '<S1084>/Constant'
                             */
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;

                            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                             *  Constant: '<S1083>/Constant'
                             *  Merge: '<S1022>/Merge1'
                             *  SignalConversion generated from: '<S1053>/ESSTrig'
                             */
                            VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

                            /* End of Outputs for SubSystem: '<S1022>/OffFail' */
                        }
                    }

                    /* Switch: '<S1022>/Switch4' incorporates:
                     *  Constant: '<S1022>/Constant Value2'
                     *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType2'
                     *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType6'
                     *  DataStoreWrite: '<S1022>/Dsw_StrtStpFailDTC1'
                     *  Logic: '<S1022>/Logical21'
                     *  Logic: '<S1022>/Logical7'
                     *  RelationalOperator: '<S1022>/Comparison'
                     *  S-Function (sfix_bitop): '<S1022>/Bitwise Operator'
                     *  S-Function (sfix_bitop): '<S1028>/FixPt Bitwise Operator1'
                     */
                    if (((VeESSR_b_InitSpin_CoastDownTrig) ||
                            rtb_GreaterThan1_gb) &&
                            ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16U) > 0U))
                    {
                        VeESSR_g_StrtStpFailPhase_DS =
                            VeESSR_g_StrtStpFailPhase_DS | 16U;
                    }

                    /* Switch: '<S1071>/Switch1' incorporates:
                     *  Constant: '<S1072>/Calib'
                     *  DataStoreWrite: '<S1031>/Dsw_InitEngAng720'
                     *  RelationalOperator: '<S1031>/Equal1'
                     */
                    if (VeESSR_Cnt_InitSpnStepPt <= KeESSR_t_InitSpnInitAngTm)
                    {
                        VeESSR_phi_InitEngAng720_DS =
                            ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi;
                    }

                    /* Sum: '<S1032>/Subtract' incorporates:
                     *  Constant: '<S1074>/Calib'
                     *  DataStoreRead: '<S1032>/Dsr_NiProfGenNiDMax'
                     *  DataStoreWrite: '<S1032>/Data Store Write'
                     *  Product: '<S1032>/Product'
                     */
                    ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = rtb_MinMax_e[1] -
                        (VeESSR_dn_StrtTypNiDotMax_DS * KeESSR_r_NiDtoTiMargin);

                    /* DataStoreWrite: '<S1022>/Dsw_InputAcceltnProf1' */
                    VeESSR_dn_InputAcceltnProf_DS =
                        ESSR_ac_B.VariantMerge_For_Variant_Source;

                    /* RelationalOperator: '<S1022>/Equal1' incorporates:
                     *  Constant: '<S1022>/Constant Value'
                     *  DataStoreRead: '<S1022>/Data Store Read5'
                     *  DataStoreWrite: '<S1022>/Data Store Write5'
                     */
                    VeESSR_b_BSGStrtFailed_DS = (VeESSR_g_BSGStrtFailRsn_DS !=
                        0U);

                    /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqImmed' incorporates:
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitImmedTorq'
                     */
                    VeESSR_M_EngTrqReqImmed_DS =
                        VeESSR_M_StrtTypInitImmedTorq_DS;

                    /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqPrdtd1' incorporates:
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitPredTorq'
                     */
                    VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

                    /* Switch: '<S1078>/Switch3' */
                    if (rtb_NOT_i)
                    {
                        /* Update for UnitDelay: '<S1078>/Unit Delay' incorporates:
                         *  Constant: '<S1033>/Constant Value5'
                         */
                        ESSR_ac_DW.UnitDelay_DSTATE_iu = 0.0F;
                    }
                    else
                    {
                        /* Update for UnitDelay: '<S1078>/Unit Delay' */
                        ESSR_ac_DW.UnitDelay_DSTATE_iu = rtb_Switch3_bg;
                    }

                    /* End of Outputs for SubSystem: '<S559>/InitEngSpinDur' */
                }
                break;

              case ESSR_ac_IN_InitEngSpin_6:
                /* During 'InitEngSpin_6': '<S165>:195' */
                if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngBrkawayAch)
                {
                    /* Transition: '<S165>:204' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_ESSC_SpinUp_EM;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'ESSC_SpinUp_EM': '<S165>:197' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Event: '<S165>:208' */
                    /* Event: '<S165>:209' */
#if Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* Outputs for Function Call SubSystem: '<S568>/ESSC_SpinUp_EM_Ent' */
                    /* DataStoreWrite: '<S1766>/Dsw_EngStartStopSt' incorporates:
                     *  Constant: '<S1847>/Constant'
                     */
                    VeESSR_e_EngStartStopSt_DS = CeESSR_e_SpinUpEMStrtSt;

                    /* DataStoreWrite: '<S1766>/Dsw_DsblNiClsdLoopCntrl3' incorporates:
                     *  Constant: '<S1766>/Constant Value1'
                     */
                    VeESSR_M_MtrA_MaxTorq_DS = 0.0F;

                    /* DataStoreWrite: '<S1766>/Dsw_DsblNiClsdLoopCntrl4' incorporates:
                     *  Constant: '<S1766>/Constant Value1'
                     */
                    VeESSR_M_MtrA_MinTorq_DS = 0.0F;

                    /* Switch: '<S1766>/Switch1' incorporates:
                     *  Constant: '<S1766>/Constant Value3'
                     *  Constant: '<S1853>/Calib'
                     *  DataStoreWrite: '<S1766>/Data Store Write1'
                     */
                    if (!HeESSR_b_EngStrtTorq)
                    {
                        VeESSR_M_EngStrtTorq_DS = 0.0F;
                    }

                    /* End of Switch: '<S1766>/Switch1' */

                    /* DataStoreWrite: '<S1766>/Dsw_EngCntrlMode_DS' incorporates:
                     *  Constant: '<S1850>/Constant'
                     */
                    VeESSR_e_EngCntrlMode_DS = CeTRAR_e_SpeedMode;

                    /* DataStoreWrite: '<S1766>/Dsw_EngStrtStpMd2' incorporates:
                     *  Constant: '<S1852>/Constant'
                     */
                    VeESSR_e_EngStrtStpMd_DS = CeESSR_e_StartPending;

                    /* DataStoreWrite: '<S1766>/Dsw_EngStrtType1' incorporates:
                     *  Constant: '<S1849>/Constant'
                     */
                    VeESSR_e_TCM_StartStopType_DS = CeESSR_e_EMStrt;

                    /* DataStoreWrite: '<S1766>/Dsw_EngStrtType2' incorporates:
                     *  Constant: '<S1851>/Constant'
                     */
                    VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Cranking;

                    /* DataStoreWrite: '<S1766>/Dsw_EngTrqRespType' incorporates:
                     *  DataStoreRead: '<S1766>/VeESSR_e_StrtStpTypEngTorqRespType_DS'
                     */
                    VeESSR_e_EngTrqRespType_DS =
                        VeESSR_e_StrtStpTypEngTorqRespType_DS;

                    /* DataStoreWrite: '<S1766>/Dsw_InhibitShiftToMode' incorporates:
                     *  Constant: '<S1766>/FALSE Constant'
                     */
                    VeESSR_b_InhibitShiftToMode_DS = false;

                    /* DataStoreWrite: '<S1766>/Dsw_StrtStpFailDTC' incorporates:
                     *  Constant: '<S1848>/Constant'
                     */
                    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

                    /* End of Outputs for SubSystem: '<S568>/ESSC_SpinUp_EM_Ent' */

                    /* Outputs for Function Call SubSystem: '<S568>/ESSC_SpinUp_EM_Dur' */
                    ESSR_ac_ESSC_SpinUp_EM_Dur(VeESSR_M_EngTrqAct_Lmtd,
                        VeESSR_M_SpnUpAddtlTorq, VeESSR_n_TransInSpdFlt,
                        ESSR_ac_B.TmpSignalConversionAtVeESSR__no,
                        ESSR_ac_B.TmpSignalConversionAtVeHVTR_U_H,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                        ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p,
                        ESSR_ac_B.TmpSignalConversionAtEngineLoss,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_p_E,
                        ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I,
                        ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                        VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                        VeESSR_b_EMErlyExitLmp, VeESSR_M_TiEstMin,
                        &ESSR_ac_DW.ESSC_SpinUp_EM_Dur,
                        &ESSR_ac_PrevZCX.ESSC_SpinUp_EM_Dur,
                        &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                    /* End of Outputs for SubSystem: '<S568>/ESSC_SpinUp_EM_Dur' */
#endif

                }
                else
                {
                    /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinDur' */
                    /* RelationalOperator: '<S1022>/Equal2' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr'
                     */
                    /* Event: '<S165>:81' */
                    rtb_NOT_i = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

                    /* Switch: '<S1078>/Switch1' incorporates:
                     *  Constant: '<S1033>/Constant Value5'
                     *  UnitDelay: '<S1078>/Unit Delay'
                     */
                    if (rtb_NOT_i)
                    {
                        rtb_Multiplication1_cp = 0.0F;
                    }
                    else
                    {
                        rtb_Multiplication1_cp = ESSR_ac_DW.UnitDelay_DSTATE_iu;
                    }

                    /* Sum: '<S1033>/Sum' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitSpinScaler'
                     *  Product: '<S1022>/Product'
                     */
                    rtb_Switch3_bg = (HeESSR_t_MedTEB_dT *
                                      VeESSR_k_StrtTypInitSpinScaler_DS) +
                        rtb_Multiplication1_cp;

                    /* Outputs for Atomic SubSystem: '<S1033>/Limiter' */
                    /* Switch: '<S1077>/Switch1' incorporates:
                     *  DataStoreRead: '<S1033>/Dsr_StrtTypInitSpinEndPnt'
                     *  RelationalOperator: '<S1077>/Relational Operator'
                     */
                    if (VeESSR_Cnt_StrtTypInitSpinEndPnt_DS < rtb_Switch3_bg)
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;
                    }
                    else
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = rtb_Switch3_bg;
                    }

                    /* Switch: '<S1077>/Switch' incorporates:
                     *  Constant: '<S1033>/Constant Value1'
                     *  RelationalOperator: '<S1077>/Relational Operator1'
                     */
                    if (rtb_Gain_kd > 0.0F)
                    {
                        /* Switch: '<S1077>/Switch' */
                        VeESSR_Cnt_InitSpnStepPt = rtb_Gain_kd;
                    }
                    else
                    {
                        /* Switch: '<S1077>/Switch' */
                        VeESSR_Cnt_InitSpnStepPt = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1033>/Limiter' */

                    /* RelationalOperator: '<S1034>/Greater  Than2' incorporates:
                     *  DataStoreRead: '<S1034>/Dsr_StrtTypInitSpinEndPnt'
                     */
                    VeESSR_b_InitSpnTmrCmplt = (VeESSR_Cnt_InitSpnStepPt >=
                        VeESSR_Cnt_StrtTypInitSpinEndPnt_DS);

                    /* Outputs for Atomic SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */
                    /* Switch: '<S1058>/Switch' */
                    if (rtb_NOT_i)
                    {
                        /* Switch: '<S1058>/Switch' incorporates:
                         *  Constant: '<S1029>/Constant Value4'
                         */
                        rtb_Multiplication1_cp = 0.0F;
                    }
                    else
                    {
                        /* Switch: '<S1058>/Switch' incorporates:
                         *  Constant: '<S1029>/Cnvrt2Deg'
                         *  Constant: '<S1057>/Calib'
                         *  Product: '<S1058>/Division'
                         *  Product: '<S1058>/Multiplication'
                         *  Sum: '<S1058>/Sum//Sub'
                         *  UnitDelay: '<S1058>/Unit Delay'
                         */
                        rtb_Multiplication1_cp = ((HeESSR_t_MedTEB_dT /
                            0.166666672F) *
                            ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I) +
                            ESSR_ac_DW.UnitDelay_DSTATE_e;
                    }

                    /* Outputs for Atomic SubSystem: '<S1058>/Limiter' */
                    /* Switch: '<S1061>/Switch1' incorporates:
                     *  Constant: '<S1029>/Constant Value1'
                     *  RelationalOperator: '<S1061>/Relational Operator'
                     */
                    if (999.0F < rtb_Multiplication1_cp)
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = 999.0F;
                    }
                    else
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = rtb_Multiplication1_cp;
                    }

                    /* Switch: '<S1061>/Switch' incorporates:
                     *  Constant: '<S1029>/Constant Value'
                     *  RelationalOperator: '<S1061>/Relational Operator1'
                     */
                    if (rtb_Gain_kd <= 0.0F)
                    {
                        /* Switch: '<S1061>/Switch' */
                        rtb_Gain_kd = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1058>/Limiter' */

                    /* Update for UnitDelay: '<S1058>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_e = rtb_Gain_kd;

                    /* End of Outputs for SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */

                    /* Switch: '<S1070>/Switch1' incorporates:
                     *  Constant: '<S1029>/Constant Value3'
                     *  DataStoreRead: '<S1029>/Dsr_STMTmr3'
                     *  Product: '<S1060>/Division'
                     *  Sum: '<S1029>/Subtraction'
                     */
                    rtb_Multiplication1_cp =
                        (ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi -
                         VeESSR_phi_InitEngAng720_DS) / 720.0F;

                    /* Logic: '<S1029>/AND' incorporates:
                     *  Constant: '<S1029>/Constant Value3'
                     *  DataStoreRead: '<S1029>/Dsr_STMTmr1'
                     *  Product: '<S1060>/Multiplication'
                     *  RelationalOperator: '<S1029>/Greater  Than1'
                     *  RelationalOperator: '<S1029>/Greater  Than2'
                     *  Rounding: '<S1060>/Floor'
                     *  Sum: '<S1060>/Subtraction'
                     */
                    VeESSR_b_InitSpnEngMvmntDet = ((rtb_Gain_kd >
                        VeESSR_phi_StrtTypInitSpinBrkAng_DS) ||
                        (((rtb_Multiplication1_cp - roundf
                           (rtb_Multiplication1_cp)) * 720.0F) >
                         VeESSR_phi_StrtTypInitSpinBrkAng_DS));

                    /* Switch: '<S1044>/Switch1' incorporates:
                     *  Logic: '<S1022>/Logical'
                     */
                    rtb_LogicalOperator1_cd = ((VeESSR_b_InitSpnTmrCmplt) ||
                        (VeESSR_b_InitSpnEngMvmntDet));

                    /* RelationalOperator: '<S1022>/Greater  Than1' incorporates:
                     *  Constant: '<S1050>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr1'
                     */
                    rtb_GreaterThan1_gb = (VeESSR_t_STMTmr_DS >
                                           KeESSR_t_MaxStTmInitSpin);

                    /* Logic: '<S1022>/Logical Operator' incorporates:
                     *  Logic: '<S1022>/Logical Operator1'
                     */
                    rtb_LogicalOperator_h = ((!rtb_LogicalOperator1_cd) &&
                        rtb_GreaterThan1_gb);

                    /* Switch: '<S1022>/Switch3' incorporates:
                     *  DataStoreRead: '<S1022>/Data Store Read'
                     *  DataStoreRead: '<S1022>/Data Store Read1'
                     *  DataStoreWrite: '<S1022>/Data Store Write'
                     *  DataStoreWrite: '<S1022>/Data Store Write1'
                     *  S-Function (sfix_bitop): '<S1026>/FixPt Bitwise Operator1'
                     *  S-Function (sfix_bitop): '<S1027>/FixPt Bitwise Operator1'
                     *  Switch: '<S1022>/Switch1'
                     */
                    if (rtb_LogicalOperator_h)
                    {
                        ESSR_ac_DW.NeESSR_g_StrtStpFailRsn |= 4U;
                        VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS |
                            1U;
                    }

                    /* Outputs for Atomic SubSystem: '<S1030>/Protected Division' */
                    /* Switch: '<S1069>/Switch1' incorporates:
                     *  Constant: '<S1063>/Calib'
                     *  Constant: '<S1069>/Constant Value'
                     *  Constant: '<S1069>/Constant Value1'
                     *  Constant: '<S1069>/Constant Value2'
                     *  Constant: '<S1069>/Constant Value3'
                     *  DataStoreRead: '<S1030>/Dsr_STMTmr2'
                     *  Logic: '<S1069>/AND'
                     *  RelationalOperator: '<S1069>/Greater Than or Equal '
                     *  RelationalOperator: '<S1069>/Greater Than or Equal 1'
                     *  RelationalOperator: '<S1069>/Not Equal'
                     *  RelationalOperator: '<S1069>/Not Equal1'
                     *  Switch: '<S1069>/Switch2'
                     *  Switch: '<S1069>/Switch3'
                     */
                    if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT !=
                            0.0F))
                    {
                        /* Switch: '<S1069>/Switch1' incorporates:
                         *  Product: '<S1069>/Division'
                         */
                        rtb_Multiplication1_cp = VeESSR_t_STMTmr_DS /
                            HeESSR_t_MedTEB_dT;
                    }
                    else if (VeESSR_t_STMTmr_DS > 0.0F)
                    {
                        /* Switch: '<S1069>/Switch2' incorporates:
                         *  Constant: '<S1069>/MAXFLOAT'
                         *  Switch: '<S1069>/Switch1'
                         */
                        rtb_Multiplication1_cp = 3.402823466E+38F;
                    }
                    else if (VeESSR_t_STMTmr_DS < 0.0F)
                    {
                        /* Switch: '<S1069>/Switch3' incorporates:
                         *  Constant: '<S1069>/MINFLOAT'
                         *  Switch: '<S1069>/Switch1'
                         *  Switch: '<S1069>/Switch2'
                         */
                        rtb_Multiplication1_cp = -3.402823466E+38F;
                    }
                    else
                    {
                        /* Switch: '<S1069>/Switch1' incorporates:
                         *  Constant: '<S1069>/Constant Value4'
                         *  Switch: '<S1069>/Switch2'
                         *  Switch: '<S1069>/Switch3'
                         */
                        rtb_Multiplication1_cp = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1030>/Protected Division' */

                    /* Sum: '<S1030>/Summation2' incorporates:
                     *  Constant: '<S1030>/Constant Value'
                     *  Gain: '<S1030>/Gain'
                     *  Lookup_n-D: '<S1066>/Vector'
                     *  Lookup_n-D: '<S1068>/Vector'
                     *  MinMax: '<S1030>/MinMax'
                     *  Product: '<S1030>/Product1'
                     *  Switch: '<S1069>/Switch1'
                     */
                    VeESSR_M_InitSpinEngFricEngStrtTorq = (fmaxf
                        (-VeESSR_M_EngTrqAct_Lmtd, 0.0F) * look1_iflf_binlcapw
                        (rtb_Multiplication1_cp, ((const float32 *)
                        &(KxESSR_K_InitSpinEngStrtTorqGain[0])), ((const float32
                        *)&(KtESSR_K_InitSpinEngStrtTorqGain[0])), 4U)) +
                        look1_iflf_binlcapw(rtb_Multiplication1_cp, ((const
                        float32 *)&(KxESSR_M_InitSpinEngStrtTorqOffset[0])), ((
                        const float32 *)&(KtESSR_M_InitSpinEngStrtTorqOffset[0])),
                                            4U);

                    /* Abs: '<S1030>/Abs' */
                    VeESSR_M_InitSpinEngPulseEngStrtTorq = fabsf
                        (ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E);

                    /* Lookup_n-D: '<S1067>/Vector' incorporates:
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     */
                    VeESSR_M_InitSpinECTEngStrtTorq = look1_iflf_binlcapw
                        (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                           float32 *)&(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((
                           const float32 *)&(KtESSR_M_ECTAddtlEngStrtTorq[0])),
                         6U);

                    /* Sum: '<S1030>/Summation1' */
                    VeESSR_M_InitSpinEngStrtTorqRaw =
                        (VeESSR_M_InitSpinEngFricEngStrtTorq +
                         VeESSR_M_InitSpinEngPulseEngStrtTorq) +
                        VeESSR_M_InitSpinECTEngStrtTorq;

                    /* Outputs for Atomic SubSystem: '<S1030>/GradientLimiter' */
                    /* Product: '<S1032>/Product' incorporates:
                     *  UnitDelay: '<S1062>/Unit Delay'
                     */
                    rtb_Gain_kd = ESSR_ac_DW.UnitDelay_DSTATE_h;

                    /* Sum: '<S1062>/Sum2' */
                    rtb_Multiplication1_cp = VeESSR_M_InitSpinEngStrtTorqRaw -
                        rtb_Gain_kd;

                    /* Outputs for Atomic SubSystem: '<S1062>/Limiter' */
                    /* Switch: '<S1070>/Switch1' incorporates:
                     *  Constant: '<S1065>/Calib'
                     *  RelationalOperator: '<S1070>/Relational Operator'
                     */
                    if (KeESSR_dM_InitSpinEngStrtTorqLU < rtb_Multiplication1_cp)
                    {
                        /* Switch: '<S1070>/Switch1' */
                        rtb_Multiplication1_cp = KeESSR_dM_InitSpinEngStrtTorqLU;
                    }

                    /* Switch: '<S1070>/Switch' incorporates:
                     *  Constant: '<S1064>/Calib'
                     *  RelationalOperator: '<S1070>/Relational Operator1'
                     */
                    if (rtb_Multiplication1_cp <=
                            KeESSR_dM_InitSpinEngStrtTorqLD)
                    {
                        rtb_Multiplication1_cp = KeESSR_dM_InitSpinEngStrtTorqLD;
                    }

                    /* End of Outputs for SubSystem: '<S1062>/Limiter' */

                    /* Sum: '<S1062>/Sum3' */
                    VeESSR_M_InitSpinEngStrtTorqLmtd = rtb_Multiplication1_cp +
                        rtb_Gain_kd;

                    /* Update for UnitDelay: '<S1062>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_h =
                        VeESSR_M_InitSpinEngStrtTorqLmtd;

                    /* End of Outputs for SubSystem: '<S1030>/GradientLimiter' */

                    /* Switch: '<S1022>/Switch7' incorporates:
                     *  Constant: '<S1040>/Calib'
                     *  DataStoreWrite: '<S1022>/Data Store Write3'
                     */
                    if (!HeESSR_b_EngStrtTorq)
                    {
                        VeESSR_M_EngStrtTorq_DS =
                            VeESSR_M_InitSpinEngStrtTorqLmtd;
                    }

                    /* Logic: '<S1022>/Logical2' incorporates:
                     *  Constant: '<S1036>/Constant'
                     *  Constant: '<S1037>/Constant'
                     *  Constant: '<S1038>/Calib'
                     *  Constant: '<S1039>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                     *  Logic: '<S1022>/Logical1'
                     *  Logic: '<S1022>/Logical3'
                     *  Logic: '<S1022>/Logical6'
                     *  RelationalOperator: '<S1022>/Comparison1'
                     *  RelationalOperator: '<S1022>/Comparison4'
                     */
                    rtb_Logical2_dq = ((((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                        CeESSR_e_KeyCrnkAlgo) || (((uint32)
                                         VeESSR_e_EngStrtProfType_DS) ==
                                        CeESSR_e_LowPwrAlgo));
                    rtb_Logical2_dq = (((HeESSR_b_12vStrtrEquipped) ||
                                        ((HeESSR_b_BumpStrtEquipped) &&
                                         rtb_Logical2_dq)) && rtb_Logical2_dq);

                    /* MinMax: '<S1032>/MinMax' incorporates:
                     *  DataStoreRead: '<S1032>/Dsr_StrtTypInitSpinEndPnt'
                     *  SignalConversion generated from: '<S1075>/Vector'
                     */
                    rtb_MinMax_e[0] = VeESSR_Cnt_InitSpnStepPt;
                    rtb_MinMax_e[1] = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;

                    /* Sum: '<S1032>/Sum' */
                    rtb_Multiplication1_cp = VeESSR_M_EngTrqAct_Lmtd -
                        VeESSR_M_SpnUpAddtlTorq;
                    for (iU = 0; iU < 2; iU++)
                    {
                        rtb_MinMax_e[iU] = fmaxf(VeESSR_M_TiEstMin,
                            look1_iflf_binlcapw(rtb_MinMax_e[iU], ((const
                            float32 *)&(KxESSR_K_InitSpinTiProf[0])), ((const
                            float32 *)&(KtESSR_K_InitSpinTiProf[0])), 6U) *
                            rtb_Multiplication1_cp);
                    }

                    /* Switch: '<S1022>/Switch2' incorporates:
                     *  Constant: '<S1022>/Constant Value1'
                     *  DataStoreWrite: '<S1022>/Dsw_InputTorqEst'
                     *  Lookup_n-D: '<S1075>/Vector'
                     *  MinMax: '<S1032>/MinMax'
                     *  Product: '<S1032>/Product1'
                     */
                    if (rtb_Logical2_dq)
                    {
                        VeESSR_M_EngTorqEst_DS = 0.0F;
                    }
                    else
                    {
                        VeESSR_M_EngTorqEst_DS = rtb_MinMax_e[0];
                    }

                    /* DataStoreWrite: '<S1022>/Dsw_STMTmr' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr'
                     *  Sum: '<S1022>/Summation'
                     */
                    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

                    /* Switch: '<S1044>/Switch1' incorporates:
                     *  Constant: '<S1049>/Calib'
                     */
                    if (KeESSR_b_InitSpnTmrChkOnly)
                    {
                        /* Switch: '<S1044>/Switch1' */
                        rtb_LogicalOperator1_cd = VeESSR_b_InitSpnTmrCmplt;
                    }

                    /* SignalConversion generated from: '<S1022>/Variant Source' incorporates:
                     *  Logic: '<S1054>/Logical1'
                     *  Logic: '<S1054>/Logical2'
                     *  Logic: '<S1054>/Logical3'
                     *  Logic: '<S1054>/Logical4'
                     *  RelationalOperator: '<S1054>/Comparison1'
                     *  RelationalOperator: '<S1054>/Comparison6'
                     *  RelationalOperator: '<S1054>/Comparison7'
                     *  RelationalOperator: '<S1054>/Comparison8'
                     */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* Switch: '<S1022>/Switch5' incorporates:
                     *  Constant: '<S1022>/FALSE Constant1'
                     */
                    rtb_Equal_d = false;

#else

                    /* Logic: '<S1054>/Logical4' incorporates:
                     *  Constant: '<S1085>/Constant'
                     *  Constant: '<S1086>/Constant'
                     *  Constant: '<S1087>/Constant'
                     *  Constant: '<S1088>/Constant'
                     *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                     *  Logic: '<S1054>/Logical1'
                     *  Logic: '<S1054>/Logical2'
                     *  Logic: '<S1054>/Logical3'
                     *  RelationalOperator: '<S1022>/Comparison4'
                     *  RelationalOperator: '<S1054>/Comparison1'
                     *  RelationalOperator: '<S1054>/Comparison6'
                     *  RelationalOperator: '<S1054>/Comparison7'
                     *  RelationalOperator: '<S1054>/Comparison8'
                     */
                    VeESSR_b_InitSpin_48VP2CoastDown = (((((((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMStrtAlgo) ||
                        (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                         CeESSR_e_ImplStrtAlgo)) || (((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo))
                        && (VeESSR_b_EMErlyExitLmp)) || ((((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_CltchStrtAlgo) &&
                        (VeESSR_b_ClthErlyExitLmp)));

                    /* Switch: '<S1022>/Switch5' */
                    rtb_Equal_d = VeESSR_b_InitSpin_48VP2CoastDown;

#endif

                    /* Switch: '<S1022>/Switch5' */
                    if (!VeESSR_b_StrtTypChngDisbl)
                    {
                        /* Switch: '<S1022>/Switch5' incorporates:
                         *  Constant: '<S1035>/Constant'
                         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                         *  Logic: '<S1022>/Logical Operator4'
                         *  Logic: '<S1022>/Logical Operator5'
                         *  RelationalOperator: '<S1022>/Comparison2'
                         *  RelationalOperator: '<S1022>/Comparison4'
                         */
                        rtb_Equal_d =
                            (((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B) ||
                              ((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d) &&
                               (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                CeESSR_e_KeyCrnkAlgo))) || (VeESSR_b_ErlyExitLmp));
                    }

                    /* Logic: '<S1022>/Logical Operator3' incorporates:
                     *  Constant: '<S1041>/Calib'
                     *  Constant: '<S1045>/Calib'
                     *  Constant: '<S1046>/Calib'
                     *  Constant: '<S1047>/Calib'
                     *  Constant: '<S1048>/Calib'
                     *  DataStoreRead: '<S1022>/Data Store Read18'
                     *  DataStoreRead: '<S1022>/Data Store Read19'
                     *  Logic: '<S1022>/Logical Operator2'
                     *  Logic: '<S1022>/Logical5'
                     *  Logic: '<S1022>/Logical8'
                     *  Logic: '<S1022>/Logical9'
                     *  RelationalOperator: '<S1022>/Greater  Than11'
                     *  RelationalOperator: '<S1022>/Greater  Than15'
                     */
                    VeESSR_b_InitSpin_CoastDownTrig = ((rtb_Equal_d ||
                        rtb_LogicalOperator_h) && ((((KeESSR_b_EnblFtrBackupStrt)
                        && (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
                            KeESSR_Cnt_BackupStrtMaxAttmpts)) ||
                        ((KeESSR_b_EnblFtrBumpStrt) &&
                         (VeESSR_Cnt_BumpStrtAttmptCntr_DS <
                          KeESSR_Cnt_BumpStrtMaxAttmpts))) ||
                        (HeESSR_b_LimphomeEnbl)));

                    /* If: '<S1022>/If1' */
                    if (rtb_LogicalOperator1_cd)
                    {
                        /* Outputs for IfAction SubSystem: '<S1022>/NormExit' incorporates:
                         *  ActionPort: '<S1052>/Action Port'
                         */
                        /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                         *  Constant: '<S1082>/Constant'
                         *  Merge: '<S1022>/Merge1'
                         *  SignalConversion generated from: '<S1052>/ESSTrig'
                         */
                        VeESSR_e_STMTrigger_DS = CeESSR_e_EngBrkawayAch;

                        /* End of Outputs for SubSystem: '<S1022>/NormExit' */
                    }
                    else if (VeESSR_b_InitSpin_CoastDownTrig)
                    {
                        /* Outputs for IfAction SubSystem: '<S1022>/If Action Subsystem' incorporates:
                         *  ActionPort: '<S1043>/Action Port'
                         */
                        /* Switch: '<S1043>/Switch' incorporates:
                         *  Constant: '<S1080>/Constant'
                         *  Constant: '<S1081>/Constant'
                         *  DataStoreRead: '<S1043>/Data Store Read5'
                         *  DataStoreWrite: '<S1043>/Dsw_StrtStpFailDTC'
                         */
                        if (VeESSR_b_BSGStrtFailed_DS)
                        {
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;
                        }
                        else
                        {
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
                        }

                        /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                         *  Constant: '<S1079>/Constant'
                         *  Merge: '<S1022>/Merge1'
                         *  SignalConversion generated from: '<S1043>/ESSTrig'
                         */
                        VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

                        /* End of Outputs for SubSystem: '<S1022>/If Action Subsystem' */
                    }
                    else
                    {
                        if (rtb_GreaterThan1_gb)
                        {
                            /* Outputs for IfAction SubSystem: '<S1022>/OffFail' incorporates:
                             *  ActionPort: '<S1053>/Action Port'
                             */
                            /* DataStoreWrite: '<S1053>/Dsw_StrtStpFailDTC' incorporates:
                             *  Constant: '<S1084>/Constant'
                             */
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;

                            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                             *  Constant: '<S1083>/Constant'
                             *  Merge: '<S1022>/Merge1'
                             *  SignalConversion generated from: '<S1053>/ESSTrig'
                             */
                            VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

                            /* End of Outputs for SubSystem: '<S1022>/OffFail' */
                        }
                    }

                    /* Switch: '<S1022>/Switch4' incorporates:
                     *  Constant: '<S1022>/Constant Value2'
                     *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType2'
                     *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType6'
                     *  DataStoreWrite: '<S1022>/Dsw_StrtStpFailDTC1'
                     *  Logic: '<S1022>/Logical21'
                     *  Logic: '<S1022>/Logical7'
                     *  RelationalOperator: '<S1022>/Comparison'
                     *  S-Function (sfix_bitop): '<S1022>/Bitwise Operator'
                     *  S-Function (sfix_bitop): '<S1028>/FixPt Bitwise Operator1'
                     */
                    if (((VeESSR_b_InitSpin_CoastDownTrig) ||
                            rtb_GreaterThan1_gb) &&
                            ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16U) > 0U))
                    {
                        VeESSR_g_StrtStpFailPhase_DS =
                            VeESSR_g_StrtStpFailPhase_DS | 16U;
                    }

                    /* Switch: '<S1071>/Switch1' incorporates:
                     *  Constant: '<S1072>/Calib'
                     *  DataStoreWrite: '<S1031>/Dsw_InitEngAng720'
                     *  RelationalOperator: '<S1031>/Equal1'
                     */
                    if (VeESSR_Cnt_InitSpnStepPt <= KeESSR_t_InitSpnInitAngTm)
                    {
                        VeESSR_phi_InitEngAng720_DS =
                            ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi;
                    }

                    /* Sum: '<S1032>/Subtract' incorporates:
                     *  Constant: '<S1074>/Calib'
                     *  DataStoreRead: '<S1032>/Dsr_NiProfGenNiDMax'
                     *  DataStoreWrite: '<S1032>/Data Store Write'
                     *  Product: '<S1032>/Product'
                     */
                    ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = rtb_MinMax_e[1] -
                        (VeESSR_dn_StrtTypNiDotMax_DS * KeESSR_r_NiDtoTiMargin);

                    /* DataStoreWrite: '<S1022>/Dsw_InputAcceltnProf1' */
                    VeESSR_dn_InputAcceltnProf_DS =
                        ESSR_ac_B.VariantMerge_For_Variant_Source;

                    /* RelationalOperator: '<S1022>/Equal1' incorporates:
                     *  Constant: '<S1022>/Constant Value'
                     *  DataStoreRead: '<S1022>/Data Store Read5'
                     *  DataStoreWrite: '<S1022>/Data Store Write5'
                     */
                    VeESSR_b_BSGStrtFailed_DS = (VeESSR_g_BSGStrtFailRsn_DS !=
                        0U);

                    /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqImmed' incorporates:
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitImmedTorq'
                     */
                    VeESSR_M_EngTrqReqImmed_DS =
                        VeESSR_M_StrtTypInitImmedTorq_DS;

                    /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqPrdtd1' incorporates:
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitPredTorq'
                     */
                    VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

                    /* Switch: '<S1078>/Switch3' */
                    if (rtb_NOT_i)
                    {
                        /* Update for UnitDelay: '<S1078>/Unit Delay' incorporates:
                         *  Constant: '<S1033>/Constant Value5'
                         */
                        ESSR_ac_DW.UnitDelay_DSTATE_iu = 0.0F;
                    }
                    else
                    {
                        /* Update for UnitDelay: '<S1078>/Unit Delay' */
                        ESSR_ac_DW.UnitDelay_DSTATE_iu = rtb_Switch3_bg;
                    }

                    /* End of Outputs for SubSystem: '<S559>/InitEngSpinDur' */
                }
                break;

              case ESSR_ac_IN_InitEngSpin_7:
                /* During 'InitEngSpin_7': '<S165>:225' */
                if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngBrkawayAch)
                {
                    /* Transition: '<S165>:227' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_ESSC_SpinUp_EMLowPwr;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'ESSC_SpinUp_EMLowPwr': '<S165>:226' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Event: '<S165>:231' */
                    /* Event: '<S165>:232' */
#if Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* Outputs for Function Call SubSystem: '<S564>/SpinUp_EMLowPwr_En' */
                    /* DataStoreWrite: '<S1360>/Dsw_InputSpeedProfile' */
                    VeESSR_n_InputSpeedProfile_DS = VeESSR_n_TransInSpdFlt;

                    /* DataStoreWrite: '<S1360>/Dsw_EngStartStopSt' incorporates:
                     *  Constant: '<S1400>/Constant'
                     */
                    VeESSR_e_EngStartStopSt_DS = CeESSR_e_SpinUpEMLPSSt;

                    /* DataStoreWrite: '<S1360>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
                     *  Constant: '<S1360>/Constant Value1'
                     */
                    VeESSR_M_MtrA_MaxTorq_DS = 0.0F;

                    /* DataStoreWrite: '<S1360>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
                     *  Constant: '<S1360>/Constant Value1'
                     */
                    VeESSR_M_MtrA_MinTorq_DS = 0.0F;

                    /* Switch: '<S1360>/Switch' incorporates:
                     *  Constant: '<S1360>/Constant Value2'
                     *  Constant: '<S1405>/Calib'
                     *  DataStoreWrite: '<S1360>/Dsw_InputTorqEst'
                     */
                    if (!HeESSR_b_12vBSGLowPwr)
                    {
                        VeESSR_M_EngTorqEst_DS = 0.0F;
                    }

                    /* End of Switch: '<S1360>/Switch' */

                    /* DataStoreWrite: '<S1360>/Dsw_TorqCancelGain' incorporates:
                     *  Constant: '<S1360>/Constant Value3'
                     */
                    VeESSR_k_TorqCancelGain_DS = 0.0F;

                    /* DataStoreWrite: '<S1360>/Dsw_InputAcceltnProf' incorporates:
                     *  Constant: '<S1360>/Constant Value4'
                     */
                    VeESSR_dn_InputAcceltnProf_DS = 0.0F;

                    /* Switch: '<S1360>/Switch1' incorporates:
                     *  Constant: '<S1360>/Constant Value7'
                     *  Constant: '<S1406>/Calib'
                     *  DataStoreWrite: '<S1360>/Data Store Write1'
                     */
                    if (!HeESSR_b_EngStrtTorq)
                    {
                        VeESSR_M_EngStrtTorq_DS = 0.0F;
                    }

                    /* End of Switch: '<S1360>/Switch1' */

                    /* DataStoreWrite: '<S1360>/Dsw_EngStrtStpMd' incorporates:
                     *  Constant: '<S1403>/Constant'
                     */
                    VeESSR_e_EngStrtStpMd_DS = CeESSR_e_EngineTorqueStart;

                    /* DataStoreWrite: '<S1360>/Dsw_EngStrtType1' incorporates:
                     *  Constant: '<S1402>/Constant'
                     */
                    VeESSR_e_TCM_StartStopType_DS = CeESSR_e_EMStrt;

                    /* DataStoreWrite: '<S1360>/Dsw_EngStrtType2' incorporates:
                     *  Constant: '<S1404>/Constant'
                     */
                    VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Cranking;

                    /* DataStoreWrite: '<S1360>/Dsw_EngTrqReqImmed' incorporates:
                     *  Constant: '<S1407>/Calib'
                     */
                    VeESSR_M_EngTrqReqImmed_DS = KeESSR_M_EngTrqReqImmed_EMLPS;

                    /* DataStoreWrite: '<S1360>/Dsw_EngTrqReqPrdtd1' incorporates:
                     *  Constant: '<S1408>/Calib'
                     */
                    VeESSR_M_EngTrqReqPrdtd_DS = KeESSR_M_EngTrqReqPrdtd_EMLPS;

                    /* DataStoreWrite: '<S1360>/Dsw_EngTrqRespType' incorporates:
                     *  Constant: '<S1409>/Calib'
                     */
                    VeESSR_e_EngTrqRespType_DS = KeESSR_e_EngTrqRespTyp_EMLPS;

                    /* DataStoreWrite: '<S1360>/Dsw_InhibitShiftToMode1' incorporates:
                     *  Constant: '<S1360>/FALSE Constant'
                     */
                    VeESSR_b_InhibitShiftToMode_DS = false;

                    /* DataStoreWrite: '<S1360>/Dsw_InputSpeedProfile1' incorporates:
                     *  Constant: '<S1410>/Calib'
                     */
                    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

                    /* DataStoreWrite: '<S1360>/Dsw_StrtStpFailDTC' incorporates:
                     *  Constant: '<S1401>/Constant'
                     */
                    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

                    /* End of Outputs for SubSystem: '<S564>/SpinUp_EMLowPwr_En' */

                    /* Outputs for Function Call SubSystem: '<S564>/SpinUp_EMLowPwr_Du' */
                    ESSR_ac_SpinUp_EMLowPwr_Du(VeESSR_n_TransInSpdFlt,
                        ESSR_ac_B.LeESSI_M_MtrB_TorqCmnd_o,
                        ESSR_ac_B.TmpSignalConversionAtVeOHSR_n_I,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                        VeESSR_M_TiEstMin,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                        &ESSR_ac_DW.SpinUp_EMLowPwr_Du,
                        &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                    /* End of Outputs for SubSystem: '<S564>/SpinUp_EMLowPwr_Du' */
#endif

                }
                else
                {
                    /* Outputs for Function Call SubSystem: '<S559>/InitEngSpinDur' */
                    /* RelationalOperator: '<S1022>/Equal2' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr'
                     */
                    /* Event: '<S165>:81' */
                    rtb_NOT_i = (HeESSR_t_MedTEB_dT > VeESSR_t_STMTmr_DS);

                    /* Switch: '<S1078>/Switch1' incorporates:
                     *  Constant: '<S1033>/Constant Value5'
                     *  UnitDelay: '<S1078>/Unit Delay'
                     */
                    if (rtb_NOT_i)
                    {
                        rtb_Multiplication1_cp = 0.0F;
                    }
                    else
                    {
                        rtb_Multiplication1_cp = ESSR_ac_DW.UnitDelay_DSTATE_iu;
                    }

                    /* Sum: '<S1033>/Sum' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitSpinScaler'
                     *  Product: '<S1022>/Product'
                     */
                    rtb_Switch3_bg = (HeESSR_t_MedTEB_dT *
                                      VeESSR_k_StrtTypInitSpinScaler_DS) +
                        rtb_Multiplication1_cp;

                    /* Outputs for Atomic SubSystem: '<S1033>/Limiter' */
                    /* Switch: '<S1077>/Switch1' incorporates:
                     *  DataStoreRead: '<S1033>/Dsr_StrtTypInitSpinEndPnt'
                     *  RelationalOperator: '<S1077>/Relational Operator'
                     */
                    if (VeESSR_Cnt_StrtTypInitSpinEndPnt_DS < rtb_Switch3_bg)
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;
                    }
                    else
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = rtb_Switch3_bg;
                    }

                    /* Switch: '<S1077>/Switch' incorporates:
                     *  Constant: '<S1033>/Constant Value1'
                     *  RelationalOperator: '<S1077>/Relational Operator1'
                     */
                    if (rtb_Gain_kd > 0.0F)
                    {
                        /* Switch: '<S1077>/Switch' */
                        VeESSR_Cnt_InitSpnStepPt = rtb_Gain_kd;
                    }
                    else
                    {
                        /* Switch: '<S1077>/Switch' */
                        VeESSR_Cnt_InitSpnStepPt = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1033>/Limiter' */

                    /* RelationalOperator: '<S1034>/Greater  Than2' incorporates:
                     *  DataStoreRead: '<S1034>/Dsr_StrtTypInitSpinEndPnt'
                     */
                    VeESSR_b_InitSpnTmrCmplt = (VeESSR_Cnt_InitSpnStepPt >=
                        VeESSR_Cnt_StrtTypInitSpinEndPnt_DS);

                    /* Outputs for Atomic SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */
                    /* Switch: '<S1058>/Switch' */
                    if (rtb_NOT_i)
                    {
                        /* Switch: '<S1058>/Switch' incorporates:
                         *  Constant: '<S1029>/Constant Value4'
                         */
                        rtb_Multiplication1_cp = 0.0F;
                    }
                    else
                    {
                        /* Switch: '<S1058>/Switch' incorporates:
                         *  Constant: '<S1029>/Cnvrt2Deg'
                         *  Constant: '<S1057>/Calib'
                         *  Product: '<S1058>/Division'
                         *  Product: '<S1058>/Multiplication'
                         *  Sum: '<S1058>/Sum//Sub'
                         *  UnitDelay: '<S1058>/Unit Delay'
                         */
                        rtb_Multiplication1_cp = ((HeESSR_t_MedTEB_dT /
                            0.166666672F) *
                            ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I) +
                            ESSR_ac_DW.UnitDelay_DSTATE_e;
                    }

                    /* Outputs for Atomic SubSystem: '<S1058>/Limiter' */
                    /* Switch: '<S1061>/Switch1' incorporates:
                     *  Constant: '<S1029>/Constant Value1'
                     *  RelationalOperator: '<S1061>/Relational Operator'
                     */
                    if (999.0F < rtb_Multiplication1_cp)
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = 999.0F;
                    }
                    else
                    {
                        /* Product: '<S1032>/Product' */
                        rtb_Gain_kd = rtb_Multiplication1_cp;
                    }

                    /* Switch: '<S1061>/Switch' incorporates:
                     *  Constant: '<S1029>/Constant Value'
                     *  RelationalOperator: '<S1061>/Relational Operator1'
                     */
                    if (rtb_Gain_kd <= 0.0F)
                    {
                        /* Switch: '<S1061>/Switch' */
                        rtb_Gain_kd = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1058>/Limiter' */

                    /* Update for UnitDelay: '<S1058>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_e = rtb_Gain_kd;

                    /* End of Outputs for SubSystem: '<S1029>/IntegratorT Reset Enabled Limited' */

                    /* Switch: '<S1070>/Switch1' incorporates:
                     *  Constant: '<S1029>/Constant Value3'
                     *  DataStoreRead: '<S1029>/Dsr_STMTmr3'
                     *  Product: '<S1060>/Division'
                     *  Sum: '<S1029>/Subtraction'
                     */
                    rtb_Multiplication1_cp =
                        (ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi -
                         VeESSR_phi_InitEngAng720_DS) / 720.0F;

                    /* Logic: '<S1029>/AND' incorporates:
                     *  Constant: '<S1029>/Constant Value3'
                     *  DataStoreRead: '<S1029>/Dsr_STMTmr1'
                     *  Product: '<S1060>/Multiplication'
                     *  RelationalOperator: '<S1029>/Greater  Than1'
                     *  RelationalOperator: '<S1029>/Greater  Than2'
                     *  Rounding: '<S1060>/Floor'
                     *  Sum: '<S1060>/Subtraction'
                     */
                    VeESSR_b_InitSpnEngMvmntDet = ((rtb_Gain_kd >
                        VeESSR_phi_StrtTypInitSpinBrkAng_DS) ||
                        (((rtb_Multiplication1_cp - roundf
                           (rtb_Multiplication1_cp)) * 720.0F) >
                         VeESSR_phi_StrtTypInitSpinBrkAng_DS));

                    /* Switch: '<S1044>/Switch1' incorporates:
                     *  Logic: '<S1022>/Logical'
                     */
                    rtb_LogicalOperator1_cd = ((VeESSR_b_InitSpnTmrCmplt) ||
                        (VeESSR_b_InitSpnEngMvmntDet));

                    /* RelationalOperator: '<S1022>/Greater  Than1' incorporates:
                     *  Constant: '<S1050>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr1'
                     */
                    rtb_GreaterThan1_gb = (VeESSR_t_STMTmr_DS >
                                           KeESSR_t_MaxStTmInitSpin);

                    /* Logic: '<S1022>/Logical Operator' incorporates:
                     *  Logic: '<S1022>/Logical Operator1'
                     */
                    rtb_LogicalOperator_h = ((!rtb_LogicalOperator1_cd) &&
                        rtb_GreaterThan1_gb);

                    /* Switch: '<S1022>/Switch3' incorporates:
                     *  DataStoreRead: '<S1022>/Data Store Read'
                     *  DataStoreRead: '<S1022>/Data Store Read1'
                     *  DataStoreWrite: '<S1022>/Data Store Write'
                     *  DataStoreWrite: '<S1022>/Data Store Write1'
                     *  S-Function (sfix_bitop): '<S1026>/FixPt Bitwise Operator1'
                     *  S-Function (sfix_bitop): '<S1027>/FixPt Bitwise Operator1'
                     *  Switch: '<S1022>/Switch1'
                     */
                    if (rtb_LogicalOperator_h)
                    {
                        ESSR_ac_DW.NeESSR_g_StrtStpFailRsn |= 4U;
                        VeESSR_g_BSGStrtFailRsn_DS = VeESSR_g_BSGStrtFailRsn_DS |
                            1U;
                    }

                    /* Outputs for Atomic SubSystem: '<S1030>/Protected Division' */
                    /* Switch: '<S1069>/Switch1' incorporates:
                     *  Constant: '<S1063>/Calib'
                     *  Constant: '<S1069>/Constant Value'
                     *  Constant: '<S1069>/Constant Value1'
                     *  Constant: '<S1069>/Constant Value2'
                     *  Constant: '<S1069>/Constant Value3'
                     *  DataStoreRead: '<S1030>/Dsr_STMTmr2'
                     *  Logic: '<S1069>/AND'
                     *  RelationalOperator: '<S1069>/Greater Than or Equal '
                     *  RelationalOperator: '<S1069>/Greater Than or Equal 1'
                     *  RelationalOperator: '<S1069>/Not Equal'
                     *  RelationalOperator: '<S1069>/Not Equal1'
                     *  Switch: '<S1069>/Switch2'
                     *  Switch: '<S1069>/Switch3'
                     */
                    if ((VeESSR_t_STMTmr_DS != 0.0F) && (HeESSR_t_MedTEB_dT !=
                            0.0F))
                    {
                        /* Switch: '<S1069>/Switch1' incorporates:
                         *  Product: '<S1069>/Division'
                         */
                        rtb_Multiplication1_cp = VeESSR_t_STMTmr_DS /
                            HeESSR_t_MedTEB_dT;
                    }
                    else if (VeESSR_t_STMTmr_DS > 0.0F)
                    {
                        /* Switch: '<S1069>/Switch2' incorporates:
                         *  Constant: '<S1069>/MAXFLOAT'
                         *  Switch: '<S1069>/Switch1'
                         */
                        rtb_Multiplication1_cp = 3.402823466E+38F;
                    }
                    else if (VeESSR_t_STMTmr_DS < 0.0F)
                    {
                        /* Switch: '<S1069>/Switch3' incorporates:
                         *  Constant: '<S1069>/MINFLOAT'
                         *  Switch: '<S1069>/Switch1'
                         *  Switch: '<S1069>/Switch2'
                         */
                        rtb_Multiplication1_cp = -3.402823466E+38F;
                    }
                    else
                    {
                        /* Switch: '<S1069>/Switch1' incorporates:
                         *  Constant: '<S1069>/Constant Value4'
                         *  Switch: '<S1069>/Switch2'
                         *  Switch: '<S1069>/Switch3'
                         */
                        rtb_Multiplication1_cp = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S1030>/Protected Division' */

                    /* Sum: '<S1030>/Summation2' incorporates:
                     *  Constant: '<S1030>/Constant Value'
                     *  Gain: '<S1030>/Gain'
                     *  Lookup_n-D: '<S1066>/Vector'
                     *  Lookup_n-D: '<S1068>/Vector'
                     *  MinMax: '<S1030>/MinMax'
                     *  Product: '<S1030>/Product1'
                     *  Switch: '<S1069>/Switch1'
                     */
                    VeESSR_M_InitSpinEngFricEngStrtTorq = (fmaxf
                        (-VeESSR_M_EngTrqAct_Lmtd, 0.0F) * look1_iflf_binlcapw
                        (rtb_Multiplication1_cp, ((const float32 *)
                        &(KxESSR_K_InitSpinEngStrtTorqGain[0])), ((const float32
                        *)&(KtESSR_K_InitSpinEngStrtTorqGain[0])), 4U)) +
                        look1_iflf_binlcapw(rtb_Multiplication1_cp, ((const
                        float32 *)&(KxESSR_M_InitSpinEngStrtTorqOffset[0])), ((
                        const float32 *)&(KtESSR_M_InitSpinEngStrtTorqOffset[0])),
                                            4U);

                    /* Abs: '<S1030>/Abs' */
                    VeESSR_M_InitSpinEngPulseEngStrtTorq = fabsf
                        (ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E);

                    /* Lookup_n-D: '<S1067>/Vector' incorporates:
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     */
                    VeESSR_M_InitSpinECTEngStrtTorq = look1_iflf_binlcapw
                        (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                           float32 *)&(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((
                           const float32 *)&(KtESSR_M_ECTAddtlEngStrtTorq[0])),
                         6U);

                    /* Sum: '<S1030>/Summation1' */
                    VeESSR_M_InitSpinEngStrtTorqRaw =
                        (VeESSR_M_InitSpinEngFricEngStrtTorq +
                         VeESSR_M_InitSpinEngPulseEngStrtTorq) +
                        VeESSR_M_InitSpinECTEngStrtTorq;

                    /* Outputs for Atomic SubSystem: '<S1030>/GradientLimiter' */
                    /* Product: '<S1032>/Product' incorporates:
                     *  UnitDelay: '<S1062>/Unit Delay'
                     */
                    rtb_Gain_kd = ESSR_ac_DW.UnitDelay_DSTATE_h;

                    /* Sum: '<S1062>/Sum2' */
                    rtb_Multiplication1_cp = VeESSR_M_InitSpinEngStrtTorqRaw -
                        rtb_Gain_kd;

                    /* Outputs for Atomic SubSystem: '<S1062>/Limiter' */
                    /* Switch: '<S1070>/Switch1' incorporates:
                     *  Constant: '<S1065>/Calib'
                     *  RelationalOperator: '<S1070>/Relational Operator'
                     */
                    if (KeESSR_dM_InitSpinEngStrtTorqLU < rtb_Multiplication1_cp)
                    {
                        /* Switch: '<S1070>/Switch1' */
                        rtb_Multiplication1_cp = KeESSR_dM_InitSpinEngStrtTorqLU;
                    }

                    /* Switch: '<S1070>/Switch' incorporates:
                     *  Constant: '<S1064>/Calib'
                     *  RelationalOperator: '<S1070>/Relational Operator1'
                     */
                    if (rtb_Multiplication1_cp <=
                            KeESSR_dM_InitSpinEngStrtTorqLD)
                    {
                        rtb_Multiplication1_cp = KeESSR_dM_InitSpinEngStrtTorqLD;
                    }

                    /* End of Outputs for SubSystem: '<S1062>/Limiter' */

                    /* Sum: '<S1062>/Sum3' */
                    VeESSR_M_InitSpinEngStrtTorqLmtd = rtb_Multiplication1_cp +
                        rtb_Gain_kd;

                    /* Update for UnitDelay: '<S1062>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_h =
                        VeESSR_M_InitSpinEngStrtTorqLmtd;

                    /* End of Outputs for SubSystem: '<S1030>/GradientLimiter' */

                    /* Switch: '<S1022>/Switch7' incorporates:
                     *  Constant: '<S1040>/Calib'
                     *  DataStoreWrite: '<S1022>/Data Store Write3'
                     */
                    if (!HeESSR_b_EngStrtTorq)
                    {
                        VeESSR_M_EngStrtTorq_DS =
                            VeESSR_M_InitSpinEngStrtTorqLmtd;
                    }

                    /* Logic: '<S1022>/Logical2' incorporates:
                     *  Constant: '<S1036>/Constant'
                     *  Constant: '<S1037>/Constant'
                     *  Constant: '<S1038>/Calib'
                     *  Constant: '<S1039>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                     *  Logic: '<S1022>/Logical1'
                     *  Logic: '<S1022>/Logical3'
                     *  Logic: '<S1022>/Logical6'
                     *  RelationalOperator: '<S1022>/Comparison1'
                     *  RelationalOperator: '<S1022>/Comparison4'
                     */
                    rtb_Logical2_dq = ((((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                        CeESSR_e_KeyCrnkAlgo) || (((uint32)
                                         VeESSR_e_EngStrtProfType_DS) ==
                                        CeESSR_e_LowPwrAlgo));
                    rtb_Logical2_dq = (((HeESSR_b_12vStrtrEquipped) ||
                                        ((HeESSR_b_BumpStrtEquipped) &&
                                         rtb_Logical2_dq)) && rtb_Logical2_dq);

                    /* MinMax: '<S1032>/MinMax' incorporates:
                     *  DataStoreRead: '<S1032>/Dsr_StrtTypInitSpinEndPnt'
                     *  SignalConversion generated from: '<S1075>/Vector'
                     */
                    rtb_MinMax_e[0] = VeESSR_Cnt_InitSpnStepPt;
                    rtb_MinMax_e[1] = VeESSR_Cnt_StrtTypInitSpinEndPnt_DS;

                    /* Sum: '<S1032>/Sum' */
                    rtb_Multiplication1_cp = VeESSR_M_EngTrqAct_Lmtd -
                        VeESSR_M_SpnUpAddtlTorq;
                    for (iU = 0; iU < 2; iU++)
                    {
                        rtb_MinMax_e[iU] = fmaxf(VeESSR_M_TiEstMin,
                            look1_iflf_binlcapw(rtb_MinMax_e[iU], ((const
                            float32 *)&(KxESSR_K_InitSpinTiProf[0])), ((const
                            float32 *)&(KtESSR_K_InitSpinTiProf[0])), 6U) *
                            rtb_Multiplication1_cp);
                    }

                    /* Switch: '<S1022>/Switch2' incorporates:
                     *  Constant: '<S1022>/Constant Value1'
                     *  DataStoreWrite: '<S1022>/Dsw_InputTorqEst'
                     *  Lookup_n-D: '<S1075>/Vector'
                     *  MinMax: '<S1032>/MinMax'
                     *  Product: '<S1032>/Product1'
                     */
                    if (rtb_Logical2_dq)
                    {
                        VeESSR_M_EngTorqEst_DS = 0.0F;
                    }
                    else
                    {
                        VeESSR_M_EngTorqEst_DS = rtb_MinMax_e[0];
                    }

                    /* DataStoreWrite: '<S1022>/Dsw_STMTmr' incorporates:
                     *  Constant: '<S1042>/Calib'
                     *  DataStoreRead: '<S1022>/Dsr_STMTmr'
                     *  Sum: '<S1022>/Summation'
                     */
                    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

                    /* Switch: '<S1044>/Switch1' incorporates:
                     *  Constant: '<S1049>/Calib'
                     */
                    if (KeESSR_b_InitSpnTmrChkOnly)
                    {
                        /* Switch: '<S1044>/Switch1' */
                        rtb_LogicalOperator1_cd = VeESSR_b_InitSpnTmrCmplt;
                    }

                    /* SignalConversion generated from: '<S1022>/Variant Source' incorporates:
                     *  Logic: '<S1054>/Logical1'
                     *  Logic: '<S1054>/Logical2'
                     *  Logic: '<S1054>/Logical3'
                     *  Logic: '<S1054>/Logical4'
                     *  RelationalOperator: '<S1054>/Comparison1'
                     *  RelationalOperator: '<S1054>/Comparison6'
                     *  RelationalOperator: '<S1054>/Comparison7'
                     *  RelationalOperator: '<S1054>/Comparison8'
                     */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* Switch: '<S1022>/Switch5' incorporates:
                     *  Constant: '<S1022>/FALSE Constant1'
                     */
                    rtb_Equal_d = false;

#else

                    /* Logic: '<S1054>/Logical4' incorporates:
                     *  Constant: '<S1085>/Constant'
                     *  Constant: '<S1086>/Constant'
                     *  Constant: '<S1087>/Constant'
                     *  Constant: '<S1088>/Constant'
                     *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                     *  Logic: '<S1054>/Logical1'
                     *  Logic: '<S1054>/Logical2'
                     *  Logic: '<S1054>/Logical3'
                     *  RelationalOperator: '<S1022>/Comparison4'
                     *  RelationalOperator: '<S1054>/Comparison1'
                     *  RelationalOperator: '<S1054>/Comparison6'
                     *  RelationalOperator: '<S1054>/Comparison7'
                     *  RelationalOperator: '<S1054>/Comparison8'
                     */
                    VeESSR_b_InitSpin_48VP2CoastDown = (((((((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMStrtAlgo) ||
                        (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                         CeESSR_e_ImplStrtAlgo)) || (((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo))
                        && (VeESSR_b_EMErlyExitLmp)) || ((((uint32)
                        VeESSR_e_EngStrtProfType_DS) == CeESSR_e_CltchStrtAlgo) &&
                        (VeESSR_b_ClthErlyExitLmp)));

                    /* Switch: '<S1022>/Switch5' */
                    rtb_Equal_d = VeESSR_b_InitSpin_48VP2CoastDown;

#endif

                    /* Switch: '<S1022>/Switch5' */
                    if (!VeESSR_b_StrtTypChngDisbl)
                    {
                        /* Switch: '<S1022>/Switch5' incorporates:
                         *  Constant: '<S1035>/Constant'
                         *  DataStoreRead: '<S1022>/Dsr_EngStrtType'
                         *  Logic: '<S1022>/Logical Operator4'
                         *  Logic: '<S1022>/Logical Operator5'
                         *  RelationalOperator: '<S1022>/Comparison2'
                         *  RelationalOperator: '<S1022>/Comparison4'
                         */
                        rtb_Equal_d =
                            (((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B) ||
                              ((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d) &&
                               (((uint32)VeESSR_e_EngStrtProfType_DS) ==
                                CeESSR_e_KeyCrnkAlgo))) || (VeESSR_b_ErlyExitLmp));
                    }

                    /* Logic: '<S1022>/Logical Operator3' incorporates:
                     *  Constant: '<S1041>/Calib'
                     *  Constant: '<S1045>/Calib'
                     *  Constant: '<S1046>/Calib'
                     *  Constant: '<S1047>/Calib'
                     *  Constant: '<S1048>/Calib'
                     *  DataStoreRead: '<S1022>/Data Store Read18'
                     *  DataStoreRead: '<S1022>/Data Store Read19'
                     *  Logic: '<S1022>/Logical Operator2'
                     *  Logic: '<S1022>/Logical5'
                     *  Logic: '<S1022>/Logical8'
                     *  Logic: '<S1022>/Logical9'
                     *  RelationalOperator: '<S1022>/Greater  Than11'
                     *  RelationalOperator: '<S1022>/Greater  Than15'
                     */
                    VeESSR_b_InitSpin_CoastDownTrig = ((rtb_Equal_d ||
                        rtb_LogicalOperator_h) && ((((KeESSR_b_EnblFtrBackupStrt)
                        && (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
                            KeESSR_Cnt_BackupStrtMaxAttmpts)) ||
                        ((KeESSR_b_EnblFtrBumpStrt) &&
                         (VeESSR_Cnt_BumpStrtAttmptCntr_DS <
                          KeESSR_Cnt_BumpStrtMaxAttmpts))) ||
                        (HeESSR_b_LimphomeEnbl)));

                    /* If: '<S1022>/If1' */
                    if (rtb_LogicalOperator1_cd)
                    {
                        /* Outputs for IfAction SubSystem: '<S1022>/NormExit' incorporates:
                         *  ActionPort: '<S1052>/Action Port'
                         */
                        /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                         *  Constant: '<S1082>/Constant'
                         *  Merge: '<S1022>/Merge1'
                         *  SignalConversion generated from: '<S1052>/ESSTrig'
                         */
                        VeESSR_e_STMTrigger_DS = CeESSR_e_EngBrkawayAch;

                        /* End of Outputs for SubSystem: '<S1022>/NormExit' */
                    }
                    else if (VeESSR_b_InitSpin_CoastDownTrig)
                    {
                        /* Outputs for IfAction SubSystem: '<S1022>/If Action Subsystem' incorporates:
                         *  ActionPort: '<S1043>/Action Port'
                         */
                        /* Switch: '<S1043>/Switch' incorporates:
                         *  Constant: '<S1080>/Constant'
                         *  Constant: '<S1081>/Constant'
                         *  DataStoreRead: '<S1043>/Data Store Read5'
                         *  DataStoreWrite: '<S1043>/Dsw_StrtStpFailDTC'
                         */
                        if (VeESSR_b_BSGStrtFailed_DS)
                        {
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;
                        }
                        else
                        {
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
                        }

                        /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                         *  Constant: '<S1079>/Constant'
                         *  Merge: '<S1022>/Merge1'
                         *  SignalConversion generated from: '<S1043>/ESSTrig'
                         */
                        VeESSR_e_STMTrigger_DS = CeESSR_e_CoastDown;

                        /* End of Outputs for SubSystem: '<S1022>/If Action Subsystem' */
                    }
                    else
                    {
                        if (rtb_GreaterThan1_gb)
                        {
                            /* Outputs for IfAction SubSystem: '<S1022>/OffFail' incorporates:
                             *  ActionPort: '<S1053>/Action Port'
                             */
                            /* DataStoreWrite: '<S1053>/Dsw_StrtStpFailDTC' incorporates:
                             *  Constant: '<S1084>/Constant'
                             */
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_P1C65;

                            /* DataStoreWrite: '<S1022>/Dsw_STMTrigger1' incorporates:
                             *  Constant: '<S1083>/Constant'
                             *  Merge: '<S1022>/Merge1'
                             *  SignalConversion generated from: '<S1053>/ESSTrig'
                             */
                            VeESSR_e_STMTrigger_DS = CeESSR_e_EngFail;

                            /* End of Outputs for SubSystem: '<S1022>/OffFail' */
                        }
                    }

                    /* Switch: '<S1022>/Switch4' incorporates:
                     *  Constant: '<S1022>/Constant Value2'
                     *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType2'
                     *  DataStoreRead: '<S1022>/Dsr_EngTrqRespType6'
                     *  DataStoreWrite: '<S1022>/Dsw_StrtStpFailDTC1'
                     *  Logic: '<S1022>/Logical21'
                     *  Logic: '<S1022>/Logical7'
                     *  RelationalOperator: '<S1022>/Comparison'
                     *  S-Function (sfix_bitop): '<S1022>/Bitwise Operator'
                     *  S-Function (sfix_bitop): '<S1028>/FixPt Bitwise Operator1'
                     */
                    if (((VeESSR_b_InitSpin_CoastDownTrig) ||
                            rtb_GreaterThan1_gb) &&
                            ((VeESSR_g_StrtStpFailPhaseSelect_DS & 16U) > 0U))
                    {
                        VeESSR_g_StrtStpFailPhase_DS =
                            VeESSR_g_StrtStpFailPhase_DS | 16U;
                    }

                    /* Switch: '<S1071>/Switch1' incorporates:
                     *  Constant: '<S1072>/Calib'
                     *  DataStoreWrite: '<S1031>/Dsw_InitEngAng720'
                     *  RelationalOperator: '<S1031>/Equal1'
                     */
                    if (VeESSR_Cnt_InitSpnStepPt <= KeESSR_t_InitSpnInitAngTm)
                    {
                        VeESSR_phi_InitEngAng720_DS =
                            ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi;
                    }

                    /* Sum: '<S1032>/Subtract' incorporates:
                     *  Constant: '<S1074>/Calib'
                     *  DataStoreRead: '<S1032>/Dsr_NiProfGenNiDMax'
                     *  DataStoreWrite: '<S1032>/Data Store Write'
                     *  Product: '<S1032>/Product'
                     */
                    ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = rtb_MinMax_e[1] -
                        (VeESSR_dn_StrtTypNiDotMax_DS * KeESSR_r_NiDtoTiMargin);

                    /* DataStoreWrite: '<S1022>/Dsw_InputAcceltnProf1' */
                    VeESSR_dn_InputAcceltnProf_DS =
                        ESSR_ac_B.VariantMerge_For_Variant_Source;

                    /* RelationalOperator: '<S1022>/Equal1' incorporates:
                     *  Constant: '<S1022>/Constant Value'
                     *  DataStoreRead: '<S1022>/Data Store Read5'
                     *  DataStoreWrite: '<S1022>/Data Store Write5'
                     */
                    VeESSR_b_BSGStrtFailed_DS = (VeESSR_g_BSGStrtFailRsn_DS !=
                        0U);

                    /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqImmed' incorporates:
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitImmedTorq'
                     */
                    VeESSR_M_EngTrqReqImmed_DS =
                        VeESSR_M_StrtTypInitImmedTorq_DS;

                    /* DataStoreWrite: '<S1022>/Dsw_EngTrqReqPrdtd1' incorporates:
                     *  DataStoreRead: '<S1022>/Dsr_StrtTypInitPredTorq'
                     */
                    VeESSR_M_EngTrqReqPrdtd_DS = VeESSR_M_StrtTypInitPredTorq_DS;

                    /* Switch: '<S1078>/Switch3' */
                    if (rtb_NOT_i)
                    {
                        /* Update for UnitDelay: '<S1078>/Unit Delay' incorporates:
                         *  Constant: '<S1033>/Constant Value5'
                         */
                        ESSR_ac_DW.UnitDelay_DSTATE_iu = 0.0F;
                    }
                    else
                    {
                        /* Update for UnitDelay: '<S1078>/Unit Delay' */
                        ESSR_ac_DW.UnitDelay_DSTATE_iu = rtb_Switch3_bg;
                    }

                    /* End of Outputs for SubSystem: '<S559>/InitEngSpinDur' */
                }
                break;

              case ESSR_ac_IN_RestartPrep:
                /* During 'RestartPrep': '<S165>:17' */
                if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngSpdTgtAch)
                {
                    /* Transition: '<S165>:43' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_SpinUpEng_SFS;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'SpinUpEng_SFS': '<S165>:11' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                    /* Outputs for Function Call SubSystem: '<S565>/SpinUpEng_SFS_Ent' */
                    /* Event: '<S165>:82' */
                    ESSR_ac_SpinUpEng_SFS_Ent();

                    /* End of Outputs for SubSystem: '<S565>/SpinUpEng_SFS_Ent' */

                    /* Outputs for Function Call SubSystem: '<S565>/SpinUpEng_SFS_Dur' */
                    /* Event: '<S165>:83' */
                    ESSR_ac_SpinUpEng_SFS_Dur(VeESSR_M_EngTrqAct_Lmtd,
                        VeESSR_M_SpnUpAddtlTorq, VeESSR_n_TransInSpdFlt,
                        VeESSR_n_OptInputSpd_Local,
                        ESSR_ac_B.TmpSignalConversionAtVeESSR__no,
                        ESSR_ac_B.TmpSignalConversionAtVeVSDR_n_P,
                        rtb_Multiplication1_cp,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_e_g,
                        ESSR_ac_B.TmpSignalConversionAtVeHVTR_U_H,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                        ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p,
                        ESSR_ac_B.TmpSignalConversionAtEngineLoss,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_p_E,
                        ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I,
                        ESSR_ac_B.TmpSignalConversionAtVeBPDR_b_P,
                        ESSR_ac_B.TmpSignalConversionAtVeBCPR_b_P,
                        ESSR_ac_B.TmpSignalConversionAtVeTISR_n_N,
                        ESSR_ac_B.TmpSignalConversionAtVeOHSR_n_I,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d,
                        ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                        VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_e,
                        VeESSR_b_ErlyExitLmp, VeESSR_b_LwrThresLmp,
                        VeESSR_M_TiEstMin,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_E,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_b_P,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_P,
                        ESSR_ac_B.TmpSignalConversionAtVeOITR_M_I,
                        rtb_LogicalOperator1_cd, &ESSR_ac_DW.SpinUpEng_SFS_Dur,
                        &ESSR_ac_PrevZCX.SpinUpEng_SFS_Dur,
                        &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn,
                        &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn2,
                        &ESSR_ac_DW.VeESSR_t_StrtTypGasFlwActrDlyTm);

                    /* End of Outputs for SubSystem: '<S565>/SpinUpEng_SFS_Dur' */
                }
                else
                {
                    /* Outputs for Function Call SubSystem: '<S561>/RestartPrepDur' */
                    /* Event: '<S165>:79' */
                    ESSR_ac_RestartPrepDur(VeESSR_n_OptInputSpd_Local,
                                           VeESSR_M_EngTrqAct_Lmtd,
                                           VeESSR_M_SpnUpAddtlTorq,
                                           ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                                           VeESSR_dn_NiDotMax,
                                           VeESSR_dn_NiDotMin, VeESSR_M_TiEstMin,
                                           &ESSR_ac_DW.RestartPrepDur,
                                           &ESSR_ac_PrevZCX.RestartPrepDur);

                    /* End of Outputs for SubSystem: '<S561>/RestartPrepDur' */
                }
                break;

              case ESSR_ac_IN_SpinUpEng_SFS:
                /* During 'SpinUpEng_SFS': '<S165>:11' */
                if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngSpdTgtAch)
                {
                    /* Transition: '<S165>:24' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_StartEng;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'StartEng': '<S165>:8' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                    /* Outputs for Function Call SubSystem: '<S569>/ESSC_StartEngEnt' */
                    /* MinMax: '<S1856>/MinMax1' incorporates:
                     *  DataStoreRead: '<S1856>/Dsr_InputSpeedProfile2'
                     *  DataStoreRead: '<S1856>/Dsr_StrtTypInitImmedTorq'
                     *  Lookup_n-D: '<S2073>/Vector'
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     *  Sum: '<S1856>/Sum1'
                     *  Sum: '<S1856>/Sum2'
                     */
                    /* Event: '<S165>:86' */
                    ESSR_ac_B.MinMax1 = fminf
                        (ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o +
                         VeESSR_M_MinImmedExitTorqDelta_DS,
                         VeESSR_M_StrtTypInitImmedTorq_DS - look1_iflf_binlcapw
                         (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                            float32 *)&(KxESSR_M_InitImmedTorq_ECT[0])), ((const
                            float32 *)&(KtESSR_M_InitImmedTorq_ECT[0])), 2U));

                    /* DataStoreWrite: '<S1856>/Dsw_EngTrqReqImmed' */
                    VeESSR_M_EngTrqReqImmed_DS = ESSR_ac_B.MinMax1;

                    /* DataStoreWrite: '<S1856>/Dsw_InputAcceltnProf' incorporates:
                     *  Constant: '<S1856>/Constant Value1'
                     */
                    VeESSR_phi_CombstDelay_DS = 0.0F;

                    /* Switch: '<S1856>/Switch1' incorporates:
                     *  Constant: '<S1856>/Constant Value3'
                     *  Constant: '<S2066>/Calib'
                     *  DataStoreWrite: '<S1856>/Data Store Write1'
                     */
                    if (!HeESSR_b_EngStrtTorq)
                    {
                        VeESSR_M_EngStrtTorq_DS = 0.0F;
                    }

                    /* End of Switch: '<S1856>/Switch1' */

                    /* Switch: '<S1856>/Switch2' incorporates:
                     *  Constant: '<S2065>/Calib'
                     *  Constant: '<S2072>/Calib'
                     *  DataStoreWrite: '<S1856>/Dsw_AEMDMtrBGain'
                     */
                    if (HeESSR_b_AEMDMtrBGain)
                    {
                        VeESSR_scl_AEMDMtrBGain_DS =
                            KeESSR_scl_AEMDMtrBGain_StrtEngAutoSt;
                    }

                    /* End of Switch: '<S1856>/Switch2' */

                    /* Switch: '<S1856>/Switch' incorporates:
                     *  Constant: '<S2063>/Constant'
                     *  Constant: '<S2067>/Calib'
                     *  DataStoreWrite: '<S1856>/Dsw_EngCntrlMode_DS'
                     */
                    if (HeESSR_b_StrtEngSpeedMdECM)
                    {
                        VeESSR_e_EngCntrlMode_DS = CeTRAR_e_SpeedMode;
                    }

                    /* End of Switch: '<S1856>/Switch' */

                    /* DataStoreWrite: '<S1856>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
                     *  Constant: '<S2068>/Calib'
                     */
                    VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

                    /* DataStoreWrite: '<S1856>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
                     *  Constant: '<S2069>/Calib'
                     */
                    VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

                    /* DataStoreWrite: '<S1856>/Dsw_EngStartStopSt' incorporates:
                     *  Constant: '<S2060>/Constant'
                     */
                    VeESSR_e_EngStartStopSt_DS = CeESSR_e_StartEngSt;

                    /* DataStoreWrite: '<S1856>/Dsw_EngStrtStpMd2' incorporates:
                     *  Constant: '<S2064>/Constant'
                     */
                    VeESSR_e_EngStrtStpMd_DS = CeESSR_e_EnableFuel;

                    /* DataStoreWrite: '<S1856>/Dsw_EngStrtType1' incorporates:
                     *  Constant: '<S2062>/Constant'
                     */
                    VeESSR_e_TCM_StartStopType_DS = CeESSR_e_NormalStart;

                    /* DataStoreWrite: '<S1856>/Dsw_EngTrqRespType' incorporates:
                     *  DataStoreRead: '<S1856>/VeESSR_e_StrtStpTypEngTorqRespType_DS'
                     */
                    VeESSR_e_EngTrqRespType_DS =
                        VeESSR_e_StrtStpTypEngTorqRespType_DS;

                    /* DataStoreWrite: '<S1856>/Dsw_InputSpeedProfile1' incorporates:
                     *  Constant: '<S2071>/Calib'
                     */
                    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

                    /* DataStoreWrite: '<S1856>/Dsw_TransFldPmpSel' incorporates:
                     *  Constant: '<S2070>/Calib'
                     */
                    VeESSR_e_TransFldPmpSel_DS =
                        KeESSR_e_TransFldPmpSelStartEngSt;

                    /* End of Outputs for SubSystem: '<S569>/ESSC_StartEngEnt' */

                    /* Outputs for Function Call SubSystem: '<S569>/ESSC_StartEngDur' */
                    /* Event: '<S165>:87' */
                    ESSR_ac_ESSC_StartEngDur(VeESSR_n_OptInputSpd_Local,
                        VeESSR_M_EngTrqAct_Lmtd, VeESSR_M_EngStrtTorqSnsd,
                        ESSR_ac_B.TmpSignalConversionAtVeVSDR_n_P,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                        ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I,
                        ESSR_ac_B.TmpSignalConversionAtVeESSR_M_d,
                        ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                        ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p,
                        ESSR_ac_B.TmpSignalConversionAtEngineLoss,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_e_E,
                        VeESSR_n_TransInSpdFlt,
                        ESSR_ac_B.TmpSignalConversionAtVeOHSR_n_I,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                        ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                        VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d,
                        VeESSR_b_ErlyExitLmp, VeESSR_b_LwrThresLmp,
                        VeESSR_M_TiEstMin,
                        ESSR_ac_B.TmpSignalConversionAtVeBPDR_b_P,
                        ESSR_ac_B.TmpSignalConversionAtVeBCPR_b_P,
                        ESSR_ac_B.TmpSignalConversionAtVeTISR_n_N,
                        ESSR_ac_B.TmpSignalConversionAtVeESSR__no,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_b_P,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_P,
                        ESSR_ac_B.TmpSignalConversionAtVeOITR_M_I,
                        ESSR_ac_B.MinMax1,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_E,
                        &ESSR_ac_DW.ESSC_StartEngDur,
                        &ESSR_ac_PrevZCX.ESSC_StartEngDur,
                        &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                    /* End of Outputs for SubSystem: '<S569>/ESSC_StartEngDur' */
                }
                else
                {
                    /* Outputs for Function Call SubSystem: '<S565>/SpinUpEng_SFS_Dur' */
                    /* Event: '<S165>:83' */
                    ESSR_ac_SpinUpEng_SFS_Dur(VeESSR_M_EngTrqAct_Lmtd,
                        VeESSR_M_SpnUpAddtlTorq, VeESSR_n_TransInSpdFlt,
                        VeESSR_n_OptInputSpd_Local,
                        ESSR_ac_B.TmpSignalConversionAtVeESSR__no,
                        ESSR_ac_B.TmpSignalConversionAtVeVSDR_n_P,
                        rtb_Multiplication1_cp,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_e_g,
                        ESSR_ac_B.TmpSignalConversionAtVeHVTR_U_H,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                        ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p,
                        ESSR_ac_B.TmpSignalConversionAtEngineLoss,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_p_E,
                        ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I,
                        ESSR_ac_B.TmpSignalConversionAtVeBPDR_b_P,
                        ESSR_ac_B.TmpSignalConversionAtVeBCPR_b_P,
                        ESSR_ac_B.TmpSignalConversionAtVeTISR_n_N,
                        ESSR_ac_B.TmpSignalConversionAtVeOHSR_n_I,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d,
                        ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                        VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_e,
                        VeESSR_b_ErlyExitLmp, VeESSR_b_LwrThresLmp,
                        VeESSR_M_TiEstMin,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_E,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_b_P,
                        ESSR_ac_B.TmpSignalConversionAtVeETQR_M_P,
                        ESSR_ac_B.TmpSignalConversionAtVeOITR_M_I,
                        rtb_LogicalOperator1_cd, &ESSR_ac_DW.SpinUpEng_SFS_Dur,
                        &ESSR_ac_PrevZCX.SpinUpEng_SFS_Dur,
                        &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn,
                        &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn2,
                        &ESSR_ac_DW.VeESSR_t_StrtTypGasFlwActrDlyTm);

                    /* End of Outputs for SubSystem: '<S565>/SpinUpEng_SFS_Dur' */
                }
                break;

              case ESSR_a_IN_SpinUpFireEng_12vStrt:
                /* During 'SpinUpFireEng_12vStrt': '<S165>:105' */
                if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngSpdTgtAch)
                {
                    /* Transition: '<S165>:116' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_AchEngIdle_12vStrt;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'AchEngIdle_12vStrt': '<S165>:107' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                    /* Outputs for Function Call SubSystem: '<S555>/AchIdle_12vStrt_En' */
                    /* Event: '<S165>:112' */
                    ESSR_ac_AchIdle_12vStrt_En
                        (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_F, tmpRead);

                    /* End of Outputs for SubSystem: '<S555>/AchIdle_12vStrt_En' */

                    /* Outputs for Function Call SubSystem: '<S555>/AchIdle_12vStrt_Du' */
                    /* Event: '<S165>:113' */
                    ESSR_ac_AchIdle_12vStrt_Du
                        (ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                         VeESSR_n_OptInputSpd_Local, VeESSR_M_EngTrqAct_Lmtd,
                         ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                         VeESSR_e_IdleCtrlrSelect_12vStrt,
                         ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                         VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                         &ESSR_ac_DW.AchIdle_12vStrt_Du,
                         &ESSR_ac_PrevZCX.AchIdle_12vStrt_Du);

                    /* End of Outputs for SubSystem: '<S555>/AchIdle_12vStrt_Du' */
                }
                else
                {
                    /* Outputs for Function Call SubSystem: '<S562>/SpnUp_12v_Du' */
                    /* Event: '<S165>:111' */
                    ESSR_ac_SpnUp_12v_Du(VeESSR_n_TransInSpdFlt,
                                         ESSR_ac_B.TmpSignalConversionAtVeHPMR_b_P,
                                         VeESSR_M_TiEstMin,
                                         ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                         &ESSR_ac_DW.SpnUp_12v_Du,
                                         &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                    /* End of Outputs for SubSystem: '<S562>/SpnUp_12v_Du' */
                }
                break;

              case ESSR__IN_SpinUpFireEng_BumpStrt:
                /* During 'SpinUpFireEng_BumpStrt': '<S165>:148' */
                if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngSpdTgtAch)
                {
                    /* Transition: '<S165>:153' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_AchEngIdle_BumpStrt;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'AchEngIdle_BumpStrt': '<S165>:150' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Event: '<S165>:161' */
                    /* Event: '<S165>:162' */
#if Rte_SysCon_Variant_ESSR_P1P2Func

                    /* Outputs for Function Call SubSystem: '<S556>/AchIdle_BmpStrt_En' */
                    /* Switch: '<S839>/Switch' incorporates:
                     *  Constant: '<S839>/Constant Value2'
                     *  Constant: '<S922>/Calib'
                     */
                    if (KeESSR_b_EnblTo4TiEstBmpStrt)
                    {
                        rtb_Multiplication1_cp =
                            ESSR_ac_B.LeESSI_M_OutputTorqReqImmedHTDR;
                    }
                    else
                    {
                        rtb_Multiplication1_cp = 0.0F;
                    }

                    /* End of Switch: '<S839>/Switch' */

                    /* Sum: '<S839>/Sum1' incorporates:
                     *  DataStoreRead: '<S839>/Data Store Read'
                     *  DataStoreWrite: '<S839>/Dsw_InputTorqEst'
                     */
                    VeESSR_M_EngTorqEst_DS = rtb_Multiplication1_cp -
                        VeESSR_M_MtrBTorqCmndPrev_DS;

                    /* DataStoreWrite: '<S839>/Dsw_EngStartStopSt' incorporates:
                     *  Constant: '<S920>/Constant'
                     */
                    VeESSR_e_EngStartStopSt_DS = CeESSR_e_AchEngIdleBumpStrtSt;

                    /* DataStoreWrite: '<S839>/Dsw_Ni1stFlt' incorporates:
                     *  DataStoreRead: '<S839>/Dsr_InputSpeedProfile1'
                     */
                    VeESSR_n_Ni1stFlt_DS = VeESSR_n_InputSpeedProfile_DS;

                    /* DataStoreWrite: '<S839>/Dsw_EngStrtStpMd2' incorporates:
                     *  Constant: '<S925>/Calib'
                     */
                    VeESSR_e_EngStrtStpMd_DS = KeESSR_e_MdInAchEngIdleBumpStrtSt;

                    /* DataStoreWrite: '<S839>/Dsw_EngTrqRespType' incorporates:
                     *  Constant: '<S924>/Calib'
                     */
                    VeESSR_e_EngTrqRespType_DS =
                        KeESSR_e_AchEngIdleBumpStrtRespType;

                    /* DataStoreWrite: '<S839>/Dsw_InhibitShiftToMode' incorporates:
                     *  Constant: '<S923>/Calib'
                     */
                    VeESSR_b_InhibitShiftToMode_DS =
                        KeESSR_b_ShftInhbtAchIdleBumpStrtSt;

                    /* DataStoreWrite: '<S839>/Dsw_StrtStpFailDTC' incorporates:
                     *  Constant: '<S921>/Constant'
                     */
                    VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

                    /* DataStoreWrite: '<S839>/Dsw_TransFldPmpSel' incorporates:
                     *  Constant: '<S926>/Calib'
                     */
                    VeESSR_e_TransFldPmpSel_DS =
                        KeESSR_e_TransFldPmpSelAchEngIdleBumpStrtSt;

                    /* End of Outputs for SubSystem: '<S556>/AchIdle_BmpStrt_En' */

                    /* Outputs for Function Call SubSystem: '<S556>/AchIdle_BmpStrt_Du' */
                    ESSR_ac_AchIdle_BmpStrt_Du
                        (ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                         VeESSR_M_EngTrqAct_Lmtd,
                         ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                         ESSR_ac_B.LeESSI_M_MtrA_MaxTorq,
                         ESSR_ac_B.LeESSI_M_MtrA_MinTorq,
                         ESSR_ac_B.LeESSI_n_InputSpeedDsrdM2,
                         ESSR_ac_B.TmpSignalConversionAtVeESSR_M_d,
                         ESSR_ac_B.TmpSignalConversionAtVeESMR_P_B,
                         ESSR_ac_B.LeESSI_n_TransMinInputSpd,
                         VeESSR_n_TransInSpdFlt, ESSR_ac_B.LeESSI_n_MtrB_Spd_i,
                         ESSR_ac_B.TmpSignalConversionAtVeETQR_M_e,
                         ESSR_ac_B.LeESSI_e_VldtdTransRngSt,
                         ESSR_ac_B.LeESSI_M_OutputTorqReqImmedHTDR,
                         ESSR_ac_B.LeESSI_M_InputTorqMaxTact_p,
                         &ESSR_ac_B.AchIdle_BmpStrt_Du,
                         &ESSR_ac_DW.AchIdle_BmpStrt_Du);

                    /* End of Outputs for SubSystem: '<S556>/AchIdle_BmpStrt_Du' */
#endif

                }
                else
                {
                    /* Event: '<S165>:160' */
#if Rte_SysCon_Variant_ESSR_P1P2Func

                    /* Outputs for Function Call SubSystem: '<S563>/SpnUpFreEng_Bmp_Du' */
                    ESSR_ac_SpnUpFreEng_Bmp_Du(VeESSR_n_TransInSpdFlt,
                        VeESSR_M_EngTrqAct_Lmtd,
                        ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                        ESSR_ac_B.LeESSI_n_InputSpeedDsrdM2,
                        VeESSR_n_OptInputSpd_Local,
                        ESSR_ac_B.TmpSignalConversionAtVeESMR_P_B,
                        ESSR_ac_B.LeESSI_n_TransMinInputSpd,
                        ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R,
                        ESSR_ac_B.VariantMerge_For_Variant_Source,
                        ESSR_ac_B.LeESSI_d_TCMFailures,
                        ESSR_ac_B.TmpSignalConversionAtVeHPMR_b_P,
                        ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                        ESSR_ac_B.LeESSI_M_MtrB_TorqCmnd_ov,
                        ESSR_ac_B.LeESSI_M_OutputTorqReqImmedHTDR,
                        &ESSR_ac_DW.SpnUpFreEng_Bmp_Du,
                        &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                    /* End of Outputs for SubSystem: '<S563>/SpnUpFreEng_Bmp_Du' */
#endif

                }
                break;

              case ESSR_ac_IN_SpinUpFireEng_CKS:
                /* During 'SpinUpFireEng_CKS': '<S165>:3' */
                if (((uint32)(*Dsr_STMTrigger)) == CeESSR_e_EngSpdTgtAch)
                {
                    /* Transition: '<S165>:23' */
                    ESSR_ac_DW.is_EngStartCtrl = ESSR_ac_IN_AchEngIdle;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'AchEngIdle': '<S165>:2' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                    /* Outputs for Function Call SubSystem: '<S554>/ESSC_AchEngIdleEnt' */
                    /* Event: '<S165>:88' */
                    ESSR_ac_ESSC_AchEngIdleEnt();

                    /* End of Outputs for SubSystem: '<S554>/ESSC_AchEngIdleEnt' */

                    /* Outputs for Function Call SubSystem: '<S554>/ESSC_AchEngIdleDur' */
                    /* Event: '<S165>:89' */
                    ESSR_ac_ESSC_AchEngIdleDur
                        (ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                         VeESSR_n_OptInputSpd_Local, VeESSR_M_EngTrqAct_Lmtd,
                         ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                         ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                         VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                         &ESSR_ac_DW.ESSC_AchEngIdleDur,
                         &ESSR_ac_PrevZCX.ESSC_AchEngIdleDur);

                    /* End of Outputs for SubSystem: '<S554>/ESSC_AchEngIdleDur' */
                }
                else
                {
                    /* Outputs for Function Call SubSystem: '<S566>/SpinUp_CKS_Dur' */
                    /* Event: '<S165>:85' */
                    ESSR_ac_SpinUp_CKS_Dur(VeESSR_n_TransInSpdFlt,
                                           VeESSR_M_SpnUpAddtlTorq,
                                           VeESSR_M_EngTrqAct_Lmtd,
                                           ESSR_ac_B.TmpSignalConversionAtVeESMR_P_d,
                                           ESSR_ac_B.TmpSignalConversionAtVeESMR_P_B,
                                           VeESSR_M_EngStrtTorqSnsd,
                                           ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                                           ESSR_ac_B.TmpSignalConversionAtVeENGR_t_E,
                                           ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                                           VeESSR_dn_NiDotMax,
                                           VeESSR_dn_NiDotMin,
                                           ESSR_ac_B.TmpSignalConversionAtVeABCR_P_H,
                                           &ESSR_ac_DW.SpinUp_CKS_Dur,
                                           &ESSR_ac_PrevZCX.SpinUp_CKS_Dur,
                                           &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                    /* End of Outputs for SubSystem: '<S566>/SpinUp_CKS_Dur' */
                }
                break;

              case ESSR_ac_IN_StartEng:
                /* Outputs for Function Call SubSystem: '<S569>/ESSC_StartEngDur' */
                /* During 'StartEng': '<S165>:8' */
                /* Event: '<S165>:87' */
                ESSR_ac_ESSC_StartEngDur(VeESSR_n_OptInputSpd_Local,
                    VeESSR_M_EngTrqAct_Lmtd, VeESSR_M_EngStrtTorqSnsd,
                    ESSR_ac_B.TmpSignalConversionAtVeVSDR_n_P,
                    ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                    ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                    ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I,
                    ESSR_ac_B.TmpSignalConversionAtVeESSR_M_d,
                    ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                    ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p,
                    ESSR_ac_B.TmpSignalConversionAtEngineLoss,
                    ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B,
                    ESSR_ac_B.TmpSignalConversionAtVeENGR_e_E,
                    VeESSR_n_TransInSpdFlt,
                    ESSR_ac_B.TmpSignalConversionAtVeOHSR_n_I,
                    ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E,
                    ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                    VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                    ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d,
                    VeESSR_b_ErlyExitLmp, VeESSR_b_LwrThresLmp,
                    VeESSR_M_TiEstMin, ESSR_ac_B.TmpSignalConversionAtVeBPDR_b_P,
                    ESSR_ac_B.TmpSignalConversionAtVeBCPR_b_P,
                    ESSR_ac_B.TmpSignalConversionAtVeTISR_n_N,
                    ESSR_ac_B.TmpSignalConversionAtVeESSR__no,
                    ESSR_ac_B.TmpSignalConversionAtVeENGR_b_P,
                    ESSR_ac_B.TmpSignalConversionAtVeETQR_M_P,
                    ESSR_ac_B.TmpSignalConversionAtVeOITR_M_I, ESSR_ac_B.MinMax1,
                    ESSR_ac_B.TmpSignalConversionAtVeETQR_M_E,
                    &ESSR_ac_DW.ESSC_StartEngDur,
                    &ESSR_ac_PrevZCX.ESSC_StartEngDur,
                    &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                /* End of Outputs for SubSystem: '<S569>/ESSC_StartEngDur' */
                break;

              case ESSR_ac_IN_StartEngP1fLmt:
                /* During 'StartEngP1fLmt': '<S165>:216' */
                /* Event: '<S165>:219' */
#if Rte_SysCon_Variant_ESSR_Limphome

                /* Outputs for Function Call SubSystem: '<S553>/StartEngP1fLmt_Dur' */
                ESSR_ac_StartEngP1fLmt_Dur(VeESSR_M_EngStrtTorqSnsd,
                    ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                    ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                    ESSR_ac_B.TmpSignalConversionAtVeESSR_M_d,
                    ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                    ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p,
                    ESSR_ac_B.TmpSignalConversionAtEngineLoss,
                    ESSR_ac_B.TmpSignalConversionAtVeENGR_e_E,
                    VeESSR_n_TransInSpdFlt,
                    ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I,
                    VeESSR_b_ErlyExitLmp, VeESSR_b_LwrThresLmp,
                    VeESSR_M_TiEstMin, &ESSR_ac_DW.StartEngP1fLmt_Dur,
                    &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                /* End of Outputs for SubSystem: '<S553>/StartEngP1fLmt_Dur' */
#endif

                break;

              default:
                (void)Rte_Read_VeBPCR_T_BatModTmp_Value(&rtb_Switch3_bg);

                /* Outputs for Function Call SubSystem: '<S570>/StartEngPFS_Dur' */
                /* During 'StartEngPFS': '<S165>:138' */
                /* Event: '<S165>:142' */
                ESSR_ac_StartEngPFS_Dur
                    (ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                     VeESSR_n_OptInputSpd_Local, VeESSR_M_EngTrqAct_Lmtd,
                     VeESSR_M_EngStrtTorqSnsd,
                     ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                     ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                     ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I, rtb_Switch3_bg,
                     ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B,
                     ESSR_ac_B.TmpSignalConversionAtVeENGR_e_E,
                     VeESSR_n_TransInSpdFlt,
                     ESSR_ac_B.TmpSignalConversionAtVeOHSR_n_I,
                     ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                     VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin, VeESSR_M_TiEstMin,
                     ESSR_ac_B.TmpSignalConversionAtVeENGR_b_P,
                     ESSR_ac_B.TmpSignalConversionAtVeETQR_M_P,
                     ESSR_ac_B.TmpSignalConversionAtVeOITR_M_I,
                     &ESSR_ac_DW.StartEngPFS_Dur,
                     &ESSR_ac_PrevZCX.StartEngPFS_Dur,
                     &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                /* End of Outputs for SubSystem: '<S570>/StartEngPFS_Dur' */
                break;
            }
            break;
        }
    }

    /* End of DataStoreRead: '<S13>/Dsr_STMTrigger' */
}

#endif

/* Model step function for TID1 */
#if Rte_SysCon_Variant_ESSR_Func

FUNC(void, ESSR_CODE) ESSR_FastTEF(void) /* Explicit Task: FastTEF */
{

#if Rte_SysCon_Variant_ESSR_Func

    float32 Multiplication5;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 Multiplication2;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    /* RootInportFunctionCallGenerator generated from: '<Root>/FastTEF' */
    /* Inport: '<Root>/VeEPCR_M_MtrBCancelTorqRaw' */
    (void)Rte_Read_VeEPCR_M_MtrBCancelTorqRaw_Value(&Multiplication2);

    /* Inport: '<Root>/VeEPCR_M_MtrACancelTorqRaw' */
    (void)Rte_Read_VeEPCR_M_MtrACancelTorqRaw_Value(&Multiplication5);

    /* Outputs for Function Call SubSystem: '<Root>/ESSR_FastTEF' */
    /* S-Function (fcgen): '<S1>/FcnCallGen' incorporates:
     *  SubSystem: '<S1>/ESSC_WrtOut_FastTEF'
     */

    /* Product: '<S7>/Multiplication2' incorporates:
     *  DataStoreRead: '<S7>/Dsr_TorqCancelDsrd3'
     */
    Multiplication2 *= VeESSR_k_TorqCancelGain_DS;

    /* Product: '<S7>/Multiplication5' incorporates:
     *  DataStoreRead: '<S7>/Dsr_TorqCancelDsrd3'
     */
    Multiplication5 *= VeESSR_k_TorqCancelGain_DS;

    /* End of Outputs for S-Function (fcgen): '<S1>/FcnCallGen' */

    /* Outport: '<Root>/VeESSR_M_MtrAPulseCancelTrq' incorporates:
     *  SignalConversion generated from: '<S1>/VeESSR_M_MtrAPulseCancelTrq'
     */
    (void)Rte_Write_VeESSR_M_MtrAPulseCancelTrq_Value(Multiplication5);

    /* Outport: '<Root>/VeESSR_M_MtrBPulseCancelTrq' incorporates:
     *  SignalConversion generated from: '<S1>/VeESSR_M_MtrBPulseCancelTrq'
     */
    (void)Rte_Write_VeESSR_M_MtrBPulseCancelTrq_Value(Multiplication2);

    /* End of Outputs for SubSystem: '<Root>/ESSR_FastTEF' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/FastTEF' */
#endif

}

#endif

/* Model step function for TID2 */
FUNC(void, ESSR_CODE) ESSR_MedTEB(void) /* Explicit Task: MedTEB */
{
    /* local block i/o variables */
#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_TmpSignalConversionAtVeHSER;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_TmpSignalConversionAtVeHS_j;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    TeENGR_e_EngDFSO_St tmpRead;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean tmpRead_0;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    TeENGR_e_EngDFSO_St tmpRead_1;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    TeINVR_e_MtrInvrtrSt tmpRead_2;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean tmpRead_3;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean tmpRead_4;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    uint32 tmpRead_5;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean tmpRead_6;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    TeHCCR_e_ClutchStatus tmpRead_7;

#endif

    float32 rtb_LeESSI_M_InputTorqMaxTact;
    float32 rtb_LeESSI_M_MtrB_TorqCmnd;

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_TmpSignalConversionAtVeOHSR;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    uint32 rtb_LeESSI_b_ImmedStop;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    uint32 rtb_LeESSI_b_ImmedStop_p;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_LogicalOperator_e;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_Vector_di;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_Switch1_ac;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_Logical3_nsq;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_Logical6_pl;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_Logical1_j;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_AND_cz;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_AND_f4;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_TmpSignalConversionAtVeATRR;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_Switch1_ca;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_LeESSI_n_InputSpeedProfile;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_VeESSR_n_TransInSpdFlt;

#endif

#if (!Rte_SysCon_Variant_ESSR_P1P2Func && !Rte_SysCon_Variant_ESSR_P1P2p5Func && Rte_SysCon_Variant_ESSR_Func) || (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func) || (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func)

    float32 rtb_LeESSI_n_MtrB_Spd;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_TmpSignalConversionAtVeDFIR;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_AND_dr;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_UnitDelay2;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_UnitDelay7;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_OR1_ay;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_AND_hz;

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

    float32 rtb_Switch_fwy;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_TmpSignalConversionAtVeVSDR;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_Product1_j3;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_MinMax5;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_Switch13;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_UnitDelay_k0;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_LogicalOperator_h;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_UnitDelay_gl;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    uint8 rtb_Switch1_jm;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_Merge_k5;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_Switch1_cy;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_UnitDelay_op;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_Abs_bj;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_Gain_fa;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean rtb_Logical_e;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_Sum2_fr;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_TmpSignalConversionAtVeAPSR;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_LaESSI_r_HSERNidotConstrn[114];

#endif

#if Rte_SysCon_Variant_ESSR_Func

    TeHSER_e_SpdPrflrMd rtb_TmpSignalConversionAtVeHS_p;

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

    float32 rtb_Selector1[19];

#endif

#if Rte_SysCon_Variant_ESSR_Func

    TeSTRR_e_EngStrtStopType rtb_LeESSI_e_StrtTyp2TCM;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_TmpSignalConversionAtVaTSXR[114];

#endif

#if Rte_SysCon_Variant_ESSR_Func

    TeESSR_e_STMTrigger Dsr_STMTrigger;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 tmp[19];

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 tmp_0[19];

#endif

#if Rte_SysCon_Variant_ESSR_Func

    TeESSR_e_StrtType Dsr_EngStrtType;

#endif

#if Rte_SysCon_Variant_ESSR_NF

    TeESSR_e_HybEngSysActv tmp_1;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    sint32 VeESSR_k_StrtTypFrstOrdLwPassT_;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    TeSTRR_e_EngStrtStopType rtb_DataTypeConversion_tmp;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    TeSTRR_e_HybStrtrSt rtb_UnitDelay_h_tmp;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    TeESSR_e_EngineState rtb_TmpSignalConversionAtVeDF_0;

#endif

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTEB' incorporates:
     *  SubSystem: '<Root>/ESSR_MedTEB'
     */
    /* SignalConversion generated from: '<S2>/VeATRR_M_OutputTorqReqImmed' incorporates:
     *  SignalConversion generated from: '<S2>/VaTSXR_r_HTDRTacTiConstrn'
     *  SignalConversion generated from: '<S2>/VeDFIR_b_PostCodeClrDiagDsbl'
     *  SignalConversion generated from: '<S2>/VeHSER_M_Nc1TbMax'
     *  SignalConversion generated from: '<S2>/VeHSER_M_Nc1TbMin'
     *  SignalConversion generated from: '<S2>/VeTISR_n_InputSpeedRaw'
     *  SignalConversion generated from: '<S2>/VeVSDR_dn_PrimNodot'
     *  SignalConversion generated from: '<S2>/VeVSDR_n_PrimNoSgndFltrd'
     */
#if Rte_SysCon_Variant_ESSR_Func

    /* SignalConversion generated from: '<S2>/VeATRR_M_OutputTorqReqImmed' incorporates:
     *  Inport: '<Root>/VeATRR_M_OutputTorqReqImmedHTDR'
     */
    (void)Rte_Read_VeATRR_M_OutputTorqReqImmedHTDR_Value
        (&rtb_TmpSignalConversionAtVeATRR);

    /* SignalConversion generated from: '<S2>/VeVSDR_n_PrimNoSgndFltrd' incorporates:
     *  Inport: '<Root>/VeVSDR_n_PrimNoSgndFltrd'
     */
    (void)Rte_Read_VeVSDR_n_PrimNoSgndFltrd_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeVSDR_n_P);

    /* SignalConversion generated from: '<S2>/VeVSDR_dn_PrimNodot' incorporates:
     *  Inport: '<Root>/VeVSDR_dn_PrimNodot'
     */
    (void)Rte_Read_VeVSDR_dn_PrimNodot_Value(&rtb_TmpSignalConversionAtVeVSDR);

    /* SignalConversion generated from: '<S2>/VaTSXR_r_HTDRTacTiConstrn' incorporates:
     *  Inport: '<Root>/VaTSXR_r_HTDRTacTiConstrn'
     */
    (void)Rte_Read_VaTSXR_r_HTDRTacTiConstrn_Value
        (rtb_TmpSignalConversionAtVaTSXR);

    /* SignalConversion generated from: '<S2>/VeTISR_n_InputSpeedRaw' incorporates:
     *  Inport: '<Root>/VeTISR_n_InputSpeedRaw'
     */
    (void)Rte_Read_VeTISR_n_InputSpeedRaw_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I);

    /* SignalConversion generated from: '<S2>/VeHSER_M_Nc1TbMax' incorporates:
     *  Inport: '<Root>/VeHSER_M_Nc1TbMax'
     */
    (void)Rte_Read_VeHSER_M_Nc1TbMax_Value(&rtb_TmpSignalConversionAtVeHSER);

    /* SignalConversion generated from: '<S2>/VeHSER_M_Nc1TbMin' incorporates:
     *  Inport: '<Root>/VeHSER_M_Nc1TbMin'
     */
    (void)Rte_Read_VeHSER_M_Nc1TbMin_Value(&rtb_TmpSignalConversionAtVeHS_j);

    /* SignalConversion generated from: '<S2>/VeDFIR_b_PostCodeClrDiagDsbl' incorporates:
     *  Inport: '<Root>/VeDFIR_b_PostCodeClrDiagDsbl'
     */
    (void)Rte_Read_VeDFIR_b_PostCodeClrDiagDsbl_Value
        (&rtb_TmpSignalConversionAtVeDFIR);

#endif

    /* End of SignalConversion generated from: '<S2>/VeATRR_M_OutputTorqReqImmed' */

    /* SignalConversion generated from: '<S2>/VeSTRR_e_HybStrtrSt' */
#if Rte_SysCon_Variant_ESSR_Func || Rte_SysCon_Variant_ESSR_NF

    /* SignalConversion generated from: '<S2>/VeSTRR_e_HybStrtrSt' incorporates:
     *  Inport: '<Root>/VeSTRR_e_HybStrtrSt'
     */
    (void)Rte_Read_VeSTRR_e_HybStrtrSt_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_H);

#endif

    /* End of SignalConversion generated from: '<S2>/VeSTRR_e_HybStrtrSt' */

    /* SignalConversion generated from: '<S2>/VeSTRR_e_EngStrtStopType' incorporates:
     *  SignalConversion generated from: '<S2>/VeABCR_P_HV_AccPwr'
     *  SignalConversion generated from: '<S2>/VeAPSR_Pct_AccelPedalEffPosition'
     *  SignalConversion generated from: '<S2>/VeCSVR_v_VehSpdSigned'
     *  SignalConversion generated from: '<S2>/VeSTRR_b_BackupStrtEngOn'
     *  SignalConversion generated from: '<S2>/VeSTRR_b_BumpStrtEngOn'
     */
#if Rte_SysCon_Variant_ESSR_Func

    /* SignalConversion generated from: '<S2>/VeSTRR_e_EngStrtStopType' incorporates:
     *  Inport: '<Root>/VeSTRR_e_EngStrtStopType'
     */
    (void)Rte_Read_VeSTRR_e_EngStrtStopType_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_E);

    /* SignalConversion generated from: '<S2>/VeCSVR_v_VehSpdSigned' incorporates:
     *  Inport: '<Root>/VeCSVR_v_VehSpdSigned'
     */
    (void)Rte_Read_VeCSVR_v_VehSpdSigned_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeCSVR_v_V);

    /* SignalConversion generated from: '<S2>/VeAPSR_Pct_AccelPedalEffPosition' incorporates:
     *  Inport: '<Root>/VeAPSR_Pct_AccelPedalEffPosition'
     */
    (void)Rte_Read_VeAPSR_Pct_AccelPedalEffPosition_Value
        (&rtb_TmpSignalConversionAtVeAPSR);

    /* SignalConversion generated from: '<S2>/VeSTRR_b_BackupStrtEngOn' incorporates:
     *  Inport: '<Root>/VeSTRR_b_BackupStrtEngOn'
     */
    (void)Rte_Read_VeSTRR_b_BackupStrtEngOn_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B);

    /* SignalConversion generated from: '<S2>/VeSTRR_b_BumpStrtEngOn' incorporates:
     *  Inport: '<Root>/VeSTRR_b_BumpStrtEngOn'
     */
    (void)Rte_Read_VeSTRR_b_BumpStrtEngOn_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d);

    /* SignalConversion generated from: '<S2>/VeABCR_P_HV_AccPwr' incorporates:
     *  Inport: '<Root>/VeABCR_P_HV_AccPwr'
     */
    (void)Rte_Read_VeABCR_P_HV_AccPwr_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeABCR_P_H);

#endif

    /* End of SignalConversion generated from: '<S2>/VeSTRR_e_EngStrtStopType' */

    /* SignalConversion generated from: '<S2>/BusCreator35' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S2>/BusCreator35' incorporates:
     *  Inport: '<Root>/VeATRR_M_OutputTorqReqImmed'
     */
    (void)Rte_Read_VeATRR_M_OutputTorqReqImmed_Value
        (&ESSR_ac_B.LeESSI_M_OutputTorqReqImmedHTDR);

#elif !Rte_SysCon_Variant_ESSR_Func || !Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S2>/BusCreator35' incorporates:
     *  SignalConversion generated from: '<S2>/BusCreator35'
     */
    ESSR_ac_B.LeESSI_M_OutputTorqReqImmedHTDR = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S2>/BusCreator35' */

    /* SignalConversion generated from: '<S2>/VeBCPR_b_PosSlipDetected' incorporates:
     *  SignalConversion generated from: '<S2>/VeBPDR_b_PosSlipDetectedLtchForSTRR'
     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
     *  SignalConversion generated from: '<S2>/VeENGR_b_EngCombustionCmnd'
     *  SignalConversion generated from: '<S2>/VeENGR_b_PnLimitActvFlg'
     *  SignalConversion generated from: '<S2>/VeENGR_e_Cam_Phsr_Stat'
     *  SignalConversion generated from: '<S2>/VeENGR_e_CylinderDeacMode'
     *  SignalConversion generated from: '<S2>/VeENGR_e_ETRQ_Mode'
     *  SignalConversion generated from: '<S2>/VeENGR_p_EngManfldAbsPrs'
     *  SignalConversion generated from: '<S2>/VeENGR_t_EngOffTime'
     *  SignalConversion generated from: '<S2>/VeEPCR_M_EngPulseTorqEst'
     *  SignalConversion generated from: '<S2>/VeEPCR_phi_EngAngle720Est'
     *  SignalConversion generated from: '<S2>/VeESMR_P_BatEstdVoltMaxLim'
     *  SignalConversion generated from: '<S2>/VeESMR_P_BatSTMaxLim'
     *  SignalConversion generated from: '<S2>/VeESPR_b_EngAngle720SyncFA'
     *  SignalConversion generated from: '<S2>/VeESPR_b_EngAngle720SyncLrn'
     *  SignalConversion generated from: '<S2>/VeESPR_phi_EngAngle720Sync'
     *  SignalConversion generated from: '<S2>/VeETQR_M_EngCapacityMinOff'
     *  SignalConversion generated from: '<S2>/VeETQR_M_EngTrqActual'
     *  SignalConversion generated from: '<S2>/VeETQR_M_EngTrqAirflow'
     *  SignalConversion generated from: '<S2>/VeETQR_M_PnLimitMaxEngTrqCap'
     *  SignalConversion generated from: '<S2>/VeHPMR_b_PropSysActv'
     */
#if Rte_SysCon_Variant_ESSR_Func

    /* SignalConversion generated from: '<S2>/VeBCPR_b_PosSlipDetected' incorporates:
     *  Inport: '<Root>/VeBCPR_b_PosSlipDetected'
     */
    (void)Rte_Read_VeBCPR_b_PosSlipDetected_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeBCPR_b_P);

    /* SignalConversion generated from: '<S2>/VeBPDR_b_PosSlipDetectedLtchForSTRR' incorporates:
     *  Inport: '<Root>/VeBPDR_b_PosSlipDetectedLtchForSTRR'
     */
    (void)Rte_Read_VeBPDR_b_PosSlipDetectedLtchForSTRR_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeBPDR_b_P);

    /* SignalConversion generated from: '<S2>/VeENGR_b_PnLimitActvFlg' incorporates:
     *  Inport: '<Root>/VeENGR_b_PnLimitActvFlg'
     */
    (void)Rte_Read_VeENGR_b_PnLimitActvFlg_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeENGR_b_P);

    /* SignalConversion generated from: '<S2>/VeENGR_e_ETRQ_Mode' incorporates:
     *  Inport: '<Root>/VeENGR_e_ETRQ_Mode'
     */
    (void)Rte_Read_VeENGR_e_ETRQ_Mode_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeENGR_e_E);

    /* SignalConversion generated from: '<S2>/VeENGR_e_Cam_Phsr_Stat' incorporates:
     *  Inport: '<Root>/VeENGR_e_Cam_Phsr_Stat'
     */
    (void)Rte_Read_VeENGR_e_Cam_Phsr_Stat_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeENGR_e_g);

    /* SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp' incorporates:
     *  Inport: '<Root>/VeENGR_T_EngCoolantTemp'
     */
    (void)Rte_Read_VeENGR_T_EngCoolantTemp_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E);

    /* SignalConversion generated from: '<S2>/VeENGR_p_EngManfldAbsPrs' incorporates:
     *  Inport: '<Root>/VeENGR_p_EngManfldAbsPrs'
     */
    (void)Rte_Read_VeENGR_p_EngManfldAbsPrs_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeENGR_p_E);

    /* SignalConversion generated from: '<S2>/VeENGR_b_EngCombustionCmnd' incorporates:
     *  Inport: '<Root>/VeENGR_b_EngCombustionCmnd'
     */
    (void)Rte_Read_VeENGR_b_EngCombustionCmnd_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E);

    /* SignalConversion generated from: '<S2>/VeENGR_e_CylinderDeacMode' incorporates:
     *  Inport: '<Root>/VeENGR_e_CylinderDeacMode'
     */
    (void)Rte_Read_VeENGR_e_CylinderDeacMode_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeENGR_e_C);

    /* SignalConversion generated from: '<S2>/VeENGR_t_EngOffTime' incorporates:
     *  Inport: '<Root>/VeENGR_t_EngOffTime'
     */
    (void)Rte_Read_VeENGR_t_EngOffTime_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeENGR_t_E);

    /* SignalConversion generated from: '<S2>/VeEPCR_phi_EngAngle720Est' incorporates:
     *  Inport: '<Root>/VeEPCR_phi_EngAngle720Est'
     */
    (void)Rte_Read_VeEPCR_phi_EngAngle720Est_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi);

    /* SignalConversion generated from: '<S2>/VeEPCR_M_EngPulseTorqEst' incorporates:
     *  Inport: '<Root>/VeEPCR_M_EngPulseTorqEst'
     */
    (void)Rte_Read_VeEPCR_M_EngPulseTorqEst_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeEPCR_M_E);

    /* SignalConversion generated from: '<S2>/VeESMR_P_BatEstdVoltMaxLim' incorporates:
     *  Inport: '<Root>/VeESMR_P_BatEstdVoltMaxLim'
     */
    (void)Rte_Read_VeESMR_P_BatEstdVoltMaxLim_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeESMR_P_B);

    /* SignalConversion generated from: '<S2>/VeESMR_P_BatSTMaxLim' incorporates:
     *  Inport: '<Root>/VeESMR_P_BatSTMaxLim'
     */
    (void)Rte_Read_VeESMR_P_BatSTMaxLim_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeESMR_P_d);

    /* SignalConversion generated from: '<S2>/VeESPR_b_EngAngle720SyncLrn' incorporates:
     *  Inport: '<Root>/VeESPR_b_EngAngle720SyncLrn'
     */
    (void)Rte_Read_VeESPR_b_EngAngle720SyncLrn_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeESPR_b_E);

    /* SignalConversion generated from: '<S2>/VeESPR_b_EngAngle720SyncFA' incorporates:
     *  Inport: '<Root>/VeESPR_b_EngAngle720SyncFA'
     */
    (void)Rte_Read_VeESPR_b_EngAngle720SyncFA_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeESPR_b_h);

    /* SignalConversion generated from: '<S2>/VeESPR_phi_EngAngle720Sync' incorporates:
     *  Inport: '<Root>/VeESPR_phi_EngAngle720Sync'
     */
    (void)Rte_Read_VeESPR_phi_EngAngle720Sync_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeESPR_phi);

    /* SignalConversion generated from: '<S2>/VeETQR_M_PnLimitMaxEngTrqCap' incorporates:
     *  Inport: '<Root>/VeETQR_M_PnLimitMaxEngTrqCap'
     */
    (void)Rte_Read_VeETQR_M_PnLimitMaxEngTrqCap_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeETQR_M_P);

    /* SignalConversion generated from: '<S2>/VeETQR_M_EngTrqAirflow' incorporates:
     *  Inport: '<Root>/VeETQR_M_EngTrqAirflow'
     */
    (void)Rte_Read_VeETQR_M_EngTrqAirflow_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeETQR_M_E);

    /* SignalConversion generated from: '<S2>/VeETQR_M_EngTrqActual' incorporates:
     *  Inport: '<Root>/VeETQR_M_EngTrqActual'
     */
    (void)Rte_Read_VeETQR_M_EngTrqActual_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o);

    /* SignalConversion generated from: '<S2>/VeETQR_M_EngCapacityMinOff' incorporates:
     *  Inport: '<Root>/VeETQR_M_EngCapacityMinOff'
     */
    (void)Rte_Read_VeETQR_M_EngCapacityMinOff_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeETQR_M_e);

    /* SignalConversion generated from: '<S2>/VeHPMR_b_PropSysActv' incorporates:
     *  Inport: '<Root>/VeHPMR_b_PropSysActv'
     */
    (void)Rte_Read_VeHPMR_b_PropSysActv_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeHPMR_b_P);

#endif

    /* End of SignalConversion generated from: '<S2>/VeBCPR_b_PosSlipDetected' */

    /* SignalConversion generated from: '<S2>/BusCreator46' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* VariantMerge generated from: '<S2>/BusCreator46' incorporates:
     *  Inport: '<Root>/VeHSER_M_Clch1_TorqEst'
     */
    (void)Rte_Read_VeHSER_M_Clch1_TorqEst_Value
        (&ESSR_ac_B.LeESSI_M_Clch1_TrqEst_In);

#elif !Rte_SysCon_Variant_ESSR_Func || !Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* VariantMerge generated from: '<S2>/BusCreator46' incorporates:
     *  SignalConversion generated from: '<S2>/BusCreator46'
     */
    ESSR_ac_B.LeESSI_M_Clch1_TrqEst_In = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S2>/BusCreator46' */

    /* SignalConversion generated from: '<S2>/VeHSER_n_NiMax' */
#if Rte_SysCon_Variant_ESSR_Func

    /* SignalConversion generated from: '<S2>/VeHSER_n_NiMax' incorporates:
     *  Inport: '<Root>/VeHSER_n_NiMax'
     */
    (void)Rte_Read_VeHSER_n_NiMax_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N);

#endif

    /* End of SignalConversion generated from: '<S2>/VeHSER_n_NiMax' */

    /* SignalConversion generated from: '<S2>/BusCreator46' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* VariantMerge generated from: '<S2>/BusCreator46' incorporates:
     *  Inport: '<Root>/VeHSER_M_Clch3_TorqEst'
     */
    (void)Rte_Read_VeHSER_M_Clch3_TorqEst_Value
        (&ESSR_ac_B.LeESSI_M_Clch3_TrqEst_In);

    /* VariantMerge generated from: '<S2>/BusCreator46' incorporates:
     *  Inport: '<Root>/VeHSER_e_RngSt'
     */
    (void)Rte_Read_VeHSER_e_RngSt_Value(&ESSR_ac_B.LeESSI_e_RngSt);

#elif !Rte_SysCon_Variant_ESSR_Func || !Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* VariantMerge generated from: '<S2>/BusCreator46' incorporates:
     *  SignalConversion generated from: '<S2>/BusCreator46'
     */
    ESSR_ac_B.LeESSI_M_Clch3_TrqEst_In = 0.0F;

    /* VariantMerge generated from: '<S2>/BusCreator46' incorporates:
     *  SignalConversion generated from: '<S2>/BusCreator46'
     */
    ESSR_ac_B.LeESSI_e_RngSt = CeHSER_e_Init;

#endif

    /* End of SignalConversion generated from: '<S2>/BusCreator46' */

    /* SignalConversion generated from: '<S2>/VeHSER_e_RngEqnSel' incorporates:
     *  SignalConversion generated from: '<S2>/VeHSER_dn_InputAccelProfile'
     *  SignalConversion generated from: '<S2>/VeHSER_n_InputSpeedProfile'
     */
#if Rte_SysCon_Variant_ESSR_Func

    /* SignalConversion generated from: '<S2>/VeHSER_e_RngEqnSel' incorporates:
     *  Inport: '<Root>/VeHSER_e_RngEqnSel'
     */
    (void)Rte_Read_VeHSER_e_RngEqnSel_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R);

    /* SignalConversion generated from: '<S2>/VeHSER_dn_InputAccelProfile' incorporates:
     *  Inport: '<Root>/VeHSER_dn_InputAccelProfile'
     */
    (void)Rte_Read_VeHSER_dn_InputAccelProfile_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeHSER_dn_);

    /* SignalConversion generated from: '<S2>/VeHSER_n_InputSpeedProfile' incorporates:
     *  Inport: '<Root>/VeHSER_n_InputSpeedProfile'
     */
    (void)Rte_Read_VeHSER_n_InputSpeedProfile_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeHSER_n_I);

#endif

    /* End of SignalConversion generated from: '<S2>/VeHSER_e_RngEqnSel' */

    /* SignalConversion generated from: '<S2>/BusCreator47' */
#if (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func) || (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func)

    /* VariantMerge generated from: '<S2>/BusCreator47' incorporates:
     *  Inport: '<Root>/VeHTDR_M_MtrB_TorqCmnd'
     */
    (void)Rte_Read_VeHTDR_M_MtrB_TorqCmnd_Value(&rtb_LeESSI_M_MtrB_TorqCmnd);

#elif !Rte_SysCon_Variant_ESSR_Func || (!Rte_SysCon_Variant_ESSR_P1P2Func && !Rte_SysCon_Variant_ESSR_P1P2p5Func)

    /* VariantMerge generated from: '<S2>/BusCreator47' incorporates:
     *  SignalConversion generated from: '<S2>/BusCreator47'
     */
    rtb_LeESSI_M_MtrB_TorqCmnd = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S2>/BusCreator47' */

    /* SignalConversion generated from: '<S2>/VeHVTR_U_HV_BatVoltModMinArb' incorporates:
     *  SignalConversion generated from: '<S2>/VeOITR_M_InputTorqMinTact_Slw'
     */
#if Rte_SysCon_Variant_ESSR_Func

    /* SignalConversion generated from: '<S2>/VeHVTR_U_HV_BatVoltModMinArb' incorporates:
     *  Inport: '<Root>/VeHVTR_U_HV_BatVoltModMinArb'
     */
    (void)Rte_Read_VeHVTR_U_HV_BatVoltModMinArb_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeHVTR_U_H);

    /* SignalConversion generated from: '<S2>/VeOITR_M_InputTorqMinTact_Slw' incorporates:
     *  Inport: '<Root>/VeOITR_M_InputTorqMinTact_Slw'
     */
    (void)Rte_Read_VeOITR_M_InputTorqMinTact_Slw_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeOITR_M_I);

#endif

    /* End of SignalConversion generated from: '<S2>/VeHVTR_U_HV_BatVoltModMinArb' */

    /* SignalConversion generated from: '<S2>/BusCreator51' */
#if (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func) || (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func)

    /* VariantMerge generated from: '<S2>/BusCreator51' incorporates:
     *  Inport: '<Root>/VeOITR_M_InputTorqMaxTact_Slw'
     */
    (void)Rte_Read_VeOITR_M_InputTorqMaxTact_Slw_Value
        (&rtb_LeESSI_M_InputTorqMaxTact);

#elif !Rte_SysCon_Variant_ESSR_Func || (!Rte_SysCon_Variant_ESSR_P1P2Func && !Rte_SysCon_Variant_ESSR_P1P2p5Func)

    /* VariantMerge generated from: '<S2>/BusCreator51' incorporates:
     *  SignalConversion generated from: '<S2>/BusCreator51'
     */
    rtb_LeESSI_M_InputTorqMaxTact = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S2>/BusCreator51' */

    /* SignalConversion generated from: '<S2>/VeOHSR_n_IdleSpdBlended' incorporates:
     *  SignalConversion generated from: '<S2>/VeOHSR_n_InputSpeedDsrdM2'
     */
#if Rte_SysCon_Variant_ESSR_Func

    /* SignalConversion generated from: '<S2>/VeOHSR_n_IdleSpdBlended' incorporates:
     *  Inport: '<Root>/VeOHSR_n_IdleSpdBlended'
     */
    (void)Rte_Read_VeOHSR_n_IdleSpdBlended_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeOHSR_n_I);

    /* SignalConversion generated from: '<S2>/VeOHSR_n_InputSpeedDsrdM2' incorporates:
     *  Inport: '<Root>/VeOHSR_n_InputSpeedDsrdM2'
     */
    (void)Rte_Read_VeOHSR_n_InputSpeedDsrdM2_Value
        (&rtb_TmpSignalConversionAtVeOHSR);

#endif

    /* End of SignalConversion generated from: '<S2>/VeOHSR_n_IdleSpdBlended' */

    /* SignalConversion generated from: '<S2>/BusCreator52' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S2>/BusCreator52' */
    ESSR_ac_B.LeESSI_n_InputSpeedDsrdM2 = rtb_TmpSignalConversionAtVeOHSR;

#elif !Rte_SysCon_Variant_ESSR_Func || !Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S2>/BusCreator52' incorporates:
     *  SignalConversion generated from: '<S2>/BusCreator52'
     */
    ESSR_ac_B.LeESSI_n_InputSpeedDsrdM2 = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S2>/BusCreator52' */

    /* SignalConversion generated from: '<S2>/VeRTMR_b_InPlantMode' incorporates:
     *  SignalConversion generated from: '<S2>/VeSTRR_b_BumpStrtInhbt'
     *  SignalConversion generated from: '<S2>/VeSTRR_b_CltchStrtRsrvAvail_Raw'
     *  SignalConversion generated from: '<S2>/VeSTRR_b_EngOnReq'
     *  SignalConversion generated from: '<S2>/VeSTRR_b_FirstStartActv'
     *  SignalConversion generated from: '<S2>/VeSTRR_b_InCltchStrtZn'
     *  SignalConversion generated from: '<S2>/VeTISR_n_NiFromMtr'
     */
#if Rte_SysCon_Variant_ESSR_Func

    /* SignalConversion generated from: '<S2>/VeRTMR_b_InPlantMode' incorporates:
     *  Inport: '<Root>/VeRTMR_b_InPlantMode'
     */
    (void)Rte_Read_VeRTMR_b_InPlantMode_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeRTMR_b_I);

    /* SignalConversion generated from: '<S2>/VeSTRR_b_CltchStrtRsrvAvail_Raw' incorporates:
     *  Inport: '<Root>/VeSTRR_b_CltchStrtRsrvAvail_Raw'
     */
    (void)Rte_Read_VeSTRR_b_CltchStrtRsrvAvail_Raw_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_C);

    /* SignalConversion generated from: '<S2>/VeSTRR_b_InCltchStrtZn' incorporates:
     *  Inport: '<Root>/VeSTRR_b_InCltchStrtZn'
     */
    (void)Rte_Read_VeSTRR_b_InCltchStrtZn_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_I);

    /* SignalConversion generated from: '<S2>/VeSTRR_b_BumpStrtInhbt' incorporates:
     *  Inport: '<Root>/VeSTRR_b_BumpStrtInhbt'
     */
    (void)Rte_Read_VeSTRR_b_BumpStrtInhbt_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_e);

    /* SignalConversion generated from: '<S2>/VeSTRR_b_EngOnReq' incorporates:
     *  Inport: '<Root>/VeSTRR_b_EngOnReq'
     */
    (void)Rte_Read_VeSTRR_b_EngOnReq_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E);

    /* SignalConversion generated from: '<S2>/VeSTRR_b_FirstStartActv' incorporates:
     *  Inport: '<Root>/VeSTRR_b_FirstStartActv'
     */
    (void)Rte_Read_VeSTRR_b_FirstStartActv_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_F);

    /* SignalConversion generated from: '<S2>/VeTISR_n_NiFromMtr' incorporates:
     *  Inport: '<Root>/VeTISR_n_NiFromMtr'
     */
    (void)Rte_Read_VeTISR_n_NiFromMtr_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeTISR_n_N);

#endif

    /* End of SignalConversion generated from: '<S2>/VeRTMR_b_InPlantMode' */

    /* SignalConversion generated from: '<S2>/BusCreator60' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S2>/BusCreator60' incorporates:
     *  Inport: '<Root>/VeTISR_n_TransMinInputSpd'
     */
    (void)Rte_Read_VeTISR_n_TransMinInputSpd_Value
        (&ESSR_ac_B.LeESSI_n_TransMinInputSpd);

#elif !Rte_SysCon_Variant_ESSR_Func || !Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S2>/BusCreator60' incorporates:
     *  SignalConversion generated from: '<S2>/BusCreator60'
     */
    ESSR_ac_B.LeESSI_n_TransMinInputSpd = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S2>/BusCreator60' */

    /* SignalConversion generated from: '<S2>/VeTRAR_M_EngTorqCmndImmed' incorporates:
     *  Inport: '<Root>/VeHSER_dn_NiDotMaxLm'
     *  Inport: '<Root>/VeHSER_dn_NiDotMinLm'
     *  Inport: '<Root>/VeHVTR_U_HV_Volt'
     *  Inport: '<Root>/VeICSR_M_EngCL'
     *  Inport: '<Root>/VeSTRR_b_ImmedStop'
     *  SignalConversion generated from: '<S2>/EngineLosses_Read'
     *  SignalConversion generated from: '<S2>/VeESSR_M_EngCapacityMinRunImmed_Read'
     *  SignalConversion generated from: '<S2>/VeESSR_M_MaxSparkAuthority_Read'
     *  SignalConversion generated from: '<S2>/VeESSR_M_OptEngTrqReqPred_Read'
     *  SignalConversion generated from: '<S2>/VeESSR_M_OptEngTrqReq_Read'
     *  SignalConversion generated from: '<S2>/VeHSER_e_ProfTypeSelect'
     *  SignalConversion generated from: '<S2>/VeTRAR_e_HybCmndEngTorqRespTyp'
     *  SignalConversion generated from: '<S2>/VeTRNR_e_ActualGear'
     */
#if Rte_SysCon_Variant_ESSR_Func

    /* S-Function (fcgen): '<S2>/FcnCallGen' */
    /* SignalConversion generated from: '<S2>/VeTRAR_M_EngTorqCmndImmed' incorporates:
     *  Inport: '<Root>/VeTRAR_M_EngTorqCmndImmed'
     */
    (void)Rte_Read_VeTRAR_M_EngTorqCmndImmed_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeTRAR_M_E);

    /* SignalConversion generated from: '<S2>/VeTRAR_e_HybCmndEngTorqRespTyp' incorporates:
     *  Inport: '<Root>/VeTRAR_e_HybCmndEngTorqRespTyp'
     */
    (void)Rte_Read_VeTRAR_e_HybCmndEngTorqRespTyp_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeTRAR_e_H);

    /* SignalConversion generated from: '<S2>/VeTRNR_e_ActualGear' incorporates:
     *  Inport: '<Root>/VeTRNR_e_ActualGear'
     */
    (void)Rte_Read_VeTRNR_e_ActualGear_Value
        (&ESSR_ac_B.TmpSignalConversionAtVeTRNR_e_A);

    /* SignalConversion generated from: '<S2>/VeESSR_M_OptEngTrqReq_Read' incorporates:
     *  SignalConversion generated from: '<S3>/VeESSR_M_OptEngTrqReq_write'
     */
    ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k =
        Rte_IrvRead_ESSR_MedTEB_VeESSR_M_OptEngTrqReq_write_IRV();

    /* SignalConversion generated from: '<S2>/VeESSR_M_OptEngTrqReqPred_Read' incorporates:
     *  SignalConversion generated from: '<S3>/VeESSR_M_OptEngTrqReqPred_write'
     */
    ESSR_ac_B.TmpSignalConversionAtVeESSR_M_d =
        Rte_IrvRead_ESSR_MedTEB_VeESSR_M_OptEngTrqReqPred_write_IRV();

    /* SignalConversion generated from: '<S2>/VeESSR_M_EngCapacityMinRunImmed_Read' incorporates:
     *  SignalConversion generated from: '<S3>/VeESSR_M_EngCapacityMinRunImmed_write'
     */
    ESSR_ac_B.TmpSignalConversionAtVeESSR__no =
        Rte_IrvRead_ESSR_MedTEB_VeESSR_M_EngCapacityMinRunImmed_write_IRV();

    /* SignalConversion generated from: '<S2>/VeESSR_M_MaxSparkAuthority_Read' incorporates:
     *  SignalConversion generated from: '<S3>/VeESSR_M_MaxSparkAuthority_write'
     */
    ESSR_ac_B.TmpSignalConversionAtVeESSR_M_p =
        Rte_IrvRead_ESSR_MedTEB_VeESSR_M_MaxSparkAuthority_write_IRV();

    /* SignalConversion generated from: '<S2>/EngineLosses_Read' incorporates:
     *  SignalConversion generated from: '<S3>/VeESSR_M_EngineLosses_write'
     */
    ESSR_ac_B.TmpSignalConversionAtEngineLoss =
        Rte_IrvRead_ESSR_MedTEB_VeESSR_M_EngineLosses_write_IRV();

    /* SignalConversion generated from: '<S2>/VeHSER_e_ProfTypeSelect' incorporates:
     *  Inport: '<Root>/VeHSER_e_ProfTypeSelect'
     */
    (void)Rte_Read_VeHSER_e_ProfTypeSelect_Value
        (&rtb_TmpSignalConversionAtVeHS_p);

    /* Outputs for Function Call SubSystem: '<S2>/ESSC_DtrmnFaults' */
    /* SignalConversion generated from: '<S11>/VeSTRR_g_FltReg1' incorporates:
     *  SignalConversion generated from: '<S11>/VeSTRR_g_FltReg2'
     * */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_Limphome

    /* VariantMerge generated from: '<S11>/VeSTRR_g_FltReg1' incorporates:
     *  Inport: '<Root>/VeSTRR_g_FltReg1'
     */
    (void)Rte_Read_VeSTRR_g_FltReg1_Value(&rtb_LeESSI_b_ImmedStop);

    /* VariantMerge generated from: '<S11>/VeSTRR_g_FltReg2' incorporates:
     *  Inport: '<Root>/VeSTRR_g_FltReg2'
     */
    (void)Rte_Read_VeSTRR_g_FltReg2_Value(&rtb_LeESSI_b_ImmedStop_p);

#elif !Rte_SysCon_Variant_ESSR_Func || !Rte_SysCon_Variant_ESSR_Limphome

    /* VariantMerge generated from: '<S11>/VeSTRR_g_FltReg1' incorporates:
     *  SignalConversion generated from: '<S11>/VeSTRR_g_FltReg1'
     */
    rtb_LeESSI_b_ImmedStop = 0U;

    /* VariantMerge generated from: '<S11>/VeSTRR_g_FltReg2' incorporates:
     *  SignalConversion generated from: '<S11>/VeSTRR_g_FltReg2'
     */
    rtb_LeESSI_b_ImmedStop_p = 0U;

#endif

    /* End of SignalConversion generated from: '<S11>/VeSTRR_g_FltReg1' */

    /* Outputs for Atomic SubSystem: '<S11>/LimphomeFlags' */
#if Rte_SysCon_Variant_ESSR_Limphome

    /* Outputs for Atomic SubSystem: '<S113>/LimphomeEnbl' */
    /* VariantMerge generated from: '<S113>/VeESSR_b_AStopEngCOMLmp' incorporates:
     *  Constant: '<S120>/Constant'
     *  Constant: '<S121>/Constant'
     *  Constant: '<S128>/Calib'
     *  Constant: '<S129>/Calib'
     *  Logic: '<S116>/Logical1'
     *  RelationalOperator: '<S120>/Compare'
     *  RelationalOperator: '<S121>/Compare'
     *  S-Function (sfix_bitop): '<S116>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S116>/Bitwise Operator1'
     */
    VeESSR_b_AStopEngCOMLmp = (((rtb_LeESSI_b_ImmedStop &
        HeESSR_g_AStopEngCOMEnbl1) > 0U) || ((rtb_LeESSI_b_ImmedStop_p &
        HeESSR_g_AStopEngCOMEnbl2) > 0U));

    /* VariantMerge generated from: '<S113>/VeESSR_b_AStopReStrtPrepLmp' incorporates:
     *  Constant: '<S122>/Constant'
     *  Constant: '<S123>/Constant'
     *  Constant: '<S130>/Calib'
     *  Constant: '<S131>/Calib'
     *  Logic: '<S116>/Logical2'
     *  RelationalOperator: '<S122>/Compare'
     *  RelationalOperator: '<S123>/Compare'
     *  S-Function (sfix_bitop): '<S116>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S116>/Bitwise Operator3'
     */
    VeESSR_b_AStopReStrtPrepLmp = (((rtb_LeESSI_b_ImmedStop &
        HeESSR_g_AStopReStrtPrepEnbl1) > 0U) || ((rtb_LeESSI_b_ImmedStop_p &
        HeESSR_g_AStopReStrtPrepEnbl2) > 0U));

    /* VariantMerge generated from: '<S113>/VeESSR_b_AStopCoastDwnLmp' incorporates:
     *  Constant: '<S124>/Constant'
     *  Constant: '<S125>/Constant'
     *  Constant: '<S126>/Calib'
     *  Constant: '<S127>/Calib'
     *  Logic: '<S116>/Logical3'
     *  RelationalOperator: '<S124>/Compare'
     *  RelationalOperator: '<S125>/Compare'
     *  S-Function (sfix_bitop): '<S116>/Bitwise Operator4'
     *  S-Function (sfix_bitop): '<S116>/Bitwise Operator5'
     */
    VeESSR_b_AStopCoastDwnLmp = (((rtb_LeESSI_b_ImmedStop &
        HeESSR_g_AStopCoastDwnEnbl1) > 0U) || ((rtb_LeESSI_b_ImmedStop_p &
        HeESSR_g_AStopCoastDwnEnbl2) > 0U));

    /* VariantMerge generated from: '<S113>/VeESSR_b_ErlyExitLmp' incorporates:
     *  Constant: '<S132>/Constant'
     *  Constant: '<S133>/Constant'
     *  Constant: '<S136>/Calib'
     *  Constant: '<S137>/Calib'
     *  Logic: '<S117>/Logical1'
     *  RelationalOperator: '<S132>/Compare'
     *  RelationalOperator: '<S133>/Compare'
     *  S-Function (sfix_bitop): '<S117>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S117>/Bitwise Operator1'
     */
    VeESSR_b_ErlyExitLmp = (((rtb_LeESSI_b_ImmedStop & HeESSR_g_ErlyExitEnbl1) >
        0U) || ((rtb_LeESSI_b_ImmedStop_p & HeESSR_g_ErlyExitEnbl2) > 0U));

    /* VariantMerge generated from: '<S113>/VeESSR_b_LwrThresLmp' incorporates:
     *  Constant: '<S134>/Constant'
     *  Constant: '<S135>/Constant'
     *  Constant: '<S138>/Calib'
     *  Constant: '<S139>/Calib'
     *  Logic: '<S117>/Logical2'
     *  RelationalOperator: '<S134>/Compare'
     *  RelationalOperator: '<S135>/Compare'
     *  S-Function (sfix_bitop): '<S117>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S117>/Bitwise Operator3'
     */
    VeESSR_b_LwrThresLmp = (((rtb_LeESSI_b_ImmedStop & HeESSR_g_LwrThresEnbl1) >
        0U) || ((rtb_LeESSI_b_ImmedStop_p & HeESSR_g_LwrThresEnbl2) > 0U));

    /* VariantMerge generated from: '<S113>/VeESSR_b_ClthLwrThresLmp' incorporates:
     *  Constant: '<S142>/Constant'
     *  Constant: '<S143>/Constant'
     *  Constant: '<S148>/Calib'
     *  Constant: '<S149>/Calib'
     *  Logic: '<S118>/Logical2'
     *  RelationalOperator: '<S142>/Compare'
     *  RelationalOperator: '<S143>/Compare'
     *  S-Function (sfix_bitop): '<S118>/Bitwise Operator2'
     *  S-Function (sfix_bitop): '<S118>/Bitwise Operator3'
     */
    ESSR_ac_B.VariantMergeForOutportVeESSR__o = (((rtb_LeESSI_b_ImmedStop_p &
        HeESSR_g_ClthLwrThresEnbl2) > 0U) || ((rtb_LeESSI_b_ImmedStop &
        HeESSR_g_ClthLwrThresEnbl1) > 0U));

    /* VariantMerge generated from: '<S113>/VeESSR_b_ClthErlyExitLmp' incorporates:
     *  Constant: '<S118>/Constant Value'
     *  Constant: '<S118>/Constant Value1'
     *  Constant: '<S140>/Constant'
     *  Constant: '<S141>/Constant'
     *  Constant: '<S144>/Constant'
     *  Constant: '<S145>/Constant'
     *  Constant: '<S146>/Calib'
     *  Constant: '<S147>/Calib'
     *  Logic: '<S118>/Logical1'
     *  Logic: '<S118>/Logical3'
     *  RelationalOperator: '<S140>/Compare'
     *  RelationalOperator: '<S141>/Compare'
     *  RelationalOperator: '<S144>/Compare'
     *  RelationalOperator: '<S145>/Compare'
     *  S-Function (sfix_bitop): '<S118>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S118>/Bitwise Operator1'
     *  S-Function (sfix_bitop): '<S118>/Bitwise Operator4'
     *  S-Function (sfix_bitop): '<S118>/Bitwise Operator5'
     */
    ESSR_ac_B.VariantMergeForOutportVeESSR_b_ = (((((rtb_LeESSI_b_ImmedStop_p &
        8U) > 0U) && ((rtb_LeESSI_b_ImmedStop_p & 32U) > 0U)) ||
        ((rtb_LeESSI_b_ImmedStop & HeESSR_g_ClthErlyExitEnbl1) > 0U)) ||
        ((rtb_LeESSI_b_ImmedStop_p & HeESSR_g_ClthErlyExitEnbl2) > 0U));

    /* VariantMerge generated from: '<S113>/VeESSR_b_EMErlyExitLmp' incorporates:
     *  Constant: '<S150>/Constant'
     *  Constant: '<S151>/Constant'
     *  Constant: '<S152>/Calib'
     *  Constant: '<S153>/Calib'
     *  Logic: '<S119>/Logical1'
     *  RelationalOperator: '<S150>/Compare'
     *  RelationalOperator: '<S151>/Compare'
     *  S-Function (sfix_bitop): '<S119>/Bitwise Operator'
     *  S-Function (sfix_bitop): '<S119>/Bitwise Operator1'
     */
    ESSR_ac_B.VariantMergeForOutportVeESSR__g = (((rtb_LeESSI_b_ImmedStop &
        HeESSR_g_EMErlyExitEnbl1) > 0U) || ((rtb_LeESSI_b_ImmedStop_p &
        HeESSR_g_EMErlyExitEnbl2) > 0U));

    /* End of Outputs for SubSystem: '<S113>/LimphomeEnbl' */
#else

    /* Outputs for Atomic SubSystem: '<S113>/LimphomeNF' */
    /* VariantMerge generated from: '<S113>/VeESSR_b_ErlyExitLmp' incorporates:
     *  Constant: '<S115>/FALSE Constant'
     */
    VeESSR_b_ErlyExitLmp = false;

    /* VariantMerge generated from: '<S113>/VeESSR_b_LwrThresLmp' incorporates:
     *  Constant: '<S115>/FALSE Constant1'
     */
    VeESSR_b_LwrThresLmp = false;

    /* VariantMerge generated from: '<S113>/VeESSR_b_ClthErlyExitLmp' incorporates:
     *  Constant: '<S115>/FALSE Constant2'
     */
    ESSR_ac_B.VariantMergeForOutportVeESSR_b_ = false;

    /* VariantMerge generated from: '<S113>/VeESSR_b_ClthLwrThresLmp' incorporates:
     *  Constant: '<S115>/FALSE Constant3'
     */
    ESSR_ac_B.VariantMergeForOutportVeESSR__o = false;

    /* VariantMerge generated from: '<S113>/VeESSR_b_EMErlyExitLmp' incorporates:
     *  Constant: '<S115>/FALSE Constant4'
     */
    ESSR_ac_B.VariantMergeForOutportVeESSR__g = false;

    /* VariantMerge generated from: '<S113>/VeESSR_b_AStopEngCOMLmp' incorporates:
     *  Constant: '<S115>/FALSE Constant6'
     */
    VeESSR_b_AStopEngCOMLmp = false;

    /* VariantMerge generated from: '<S113>/VeESSR_b_AStopReStrtPrepLmp' incorporates:
     *  Constant: '<S115>/FALSE Constant7'
     */
    VeESSR_b_AStopReStrtPrepLmp = false;

    /* VariantMerge generated from: '<S113>/VeESSR_b_AStopCoastDwnLmp' incorporates:
     *  Constant: '<S115>/FALSE Constant8'
     */
    VeESSR_b_AStopCoastDwnLmp = false;

    /* End of Outputs for SubSystem: '<S113>/LimphomeNF' */
#endif

    /* End of Outputs for SubSystem: '<S11>/LimphomeFlags' */
    /* End of Outputs for SubSystem: '<S2>/ESSC_DtrmnFaults' */

    /* Outputs for Function Call SubSystem: '<S2>/ESSC_CalcTransInSpd' */

    /* Selector: '<S9>/Selector1' incorporates:
     *  Constant: '<S26>/Calib'
     *  DataTypeConversion: '<S9>/Data Type Conversion'
     *  SignalConversion generated from: '<S2>/VeHSER_e_RngEqnSel'
     */
    VeESSR_i_OptInputSpdIndx = KaESSR_i_OptInputSpdSelect
        [(ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R)];

    /* MultiPortSwitch: '<S9>/Multiport_Switch' */
    switch (VeESSR_i_OptInputSpdIndx)
    {
      case 0:
        /* MultiPortSwitch: '<S9>/Multiport_Switch' incorporates:
         *  Inport: '<Root>/VeOHSR_n_InputSpeedDsrdN'
         */
        (void)Rte_Read_VeOHSR_n_InputSpeedDsrdN_Value
            ((&(VeESSR_n_OptInputSpd_Local)));
        break;

      case 1:
        /* MultiPortSwitch: '<S9>/Multiport_Switch' incorporates:
         *  Inport: '<Root>/VeOHSR_n_InputSpeedDsrdM1'
         */
        (void)Rte_Read_VeOHSR_n_InputSpeedDsrdM1_Value
            ((&(VeESSR_n_OptInputSpd_Local)));
        break;

      case 2:
        /* MultiPortSwitch: '<S9>/Multiport_Switch' */
        VeESSR_n_OptInputSpd_Local = rtb_TmpSignalConversionAtVeOHSR;
        break;

      case 3:
        /* MultiPortSwitch: '<S9>/Multiport_Switch' incorporates:
         *  Inport: '<Root>/VeOHSR_n_InputSpeedDsrdM3'
         */
        (void)Rte_Read_VeOHSR_n_InputSpeedDsrdM3_Value
            ((&(VeESSR_n_OptInputSpd_Local)));
        break;

      default:
        /* MultiPortSwitch: '<S9>/Multiport_Switch' incorporates:
         *  Constant: '<S29>/Calib'
         */
        VeESSR_n_OptInputSpd_Local = KeESSR_n_OptInputSpdDflt;
        break;
    }

    /* End of MultiPortSwitch: '<S9>/Multiport_Switch' */

    /* Outputs for Atomic SubSystem: '<S9>/Digital Lowpass Reset Enabled' */
    /* Switch: '<S23>/Switch2' incorporates:
     *  Constant: '<S25>/Constant'
     *  Constant: '<S28>/Calib'
     *  DataStoreWrite: '<S9>/Data Store Write'
     *  Logic: '<S9>/Logical Operator'
     *  RelationalOperator: '<S9>/Relational Operator'
     *  SignalConversion generated from: '<S2>/VeENGR_e_ETRQ_Mode'
     *  Sum: '<S9>/Add'
     *  Switch: '<S23>/Switch1'
     */
    if (((uint32)ESSR_ac_B.TmpSignalConversionAtVeENGR_e_E) != CeENGR_e_Idle)
    {
        VeESSR_n_NiPred_DS = ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I +
            KeESSR_n_ActNiDeltaLQIR;
    }
    else
    {
        /* DataStoreWrite: '<S9>/Data Store Write' incorporates:
         *  DataStoreRead: '<S9>/Data Store Read'
         *  Product: '<S23>/Multiplication'
         *  Sum: '<S23>/Subtraction'
         *  Sum: '<S23>/Summation'
         *  Switch: '<S23>/Switch2'
         *  UnitDelay: '<S23>/Unit Delay'
         */
        VeESSR_n_NiPred_DS = ((VeESSR_n_OptInputSpd_Local -
                               ESSR_ac_DW.UnitDelay_DSTATE_m) *
                              ESSR_ac_DW.VeESSR_k_StrtTypNiPredFilter_DS) +
            ESSR_ac_DW.UnitDelay_DSTATE_m;
    }

    /* End of Switch: '<S23>/Switch2' */

    /* Update for UnitDelay: '<S23>/Unit Delay' incorporates:
     *  DataStoreWrite: '<S9>/Data Store Write'
     */
    ESSR_ac_DW.UnitDelay_DSTATE_m = VeESSR_n_NiPred_DS;

    /* End of Outputs for SubSystem: '<S9>/Digital Lowpass Reset Enabled' */

    /* DataStoreWrite: '<S9>/Data Store Write1' */
    VeESSR_n_OptInputSpd_DS = VeESSR_n_OptInputSpd_Local;

    /* UnitDelay: '<S9>/Unit Delay' */
    rtb_TmpSignalConversionAtVeOHSR = ESSR_ac_DW.UnitDelay_DSTATE_f;

    /* Sum: '<S22>/Subtraction1' incorporates:
     *  Constant: '<S27>/Calib'
     *  Product: '<S22>/Multiplication'
     *  Sum: '<S22>/Subtraction'
     */
    VeESSR_n_TransInSpdFlt = ((ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I -
        rtb_TmpSignalConversionAtVeOHSR) * KeESSR_K_TransInSpdFiltCoef) +
        rtb_TmpSignalConversionAtVeOHSR;

    /* DataStoreWrite: '<S9>/Data Store Write2' */
    VeESSR_n_TransInSpdFlt_DS = VeESSR_n_TransInSpdFlt;

    /* Update for UnitDelay: '<S9>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_f = VeESSR_n_TransInSpdFlt;

    /* End of Outputs for SubSystem: '<S2>/ESSC_CalcTransInSpd' */

    /* Outputs for Function Call SubSystem: '<S2>/ESSC_DtrmnNiDLimits' */

    /* Switch: '<S12>/Switch' incorporates:
     *  DataStoreWrite: '<S12>/Dsw_InputAcceltnProf'
     *  DataStoreWrite: '<S12>/Dsw_InputSpeedProfile'
     *  Switch: '<S12>/Switch1'
     *  UnitDelay: '<S12>/Unit Delay'
     */
    if (ESSR_ac_DW.UnitDelay_DSTATE_d0)
    {
        VeESSR_dn_InputAcceltnProf_DS =
            ESSR_ac_B.TmpSignalConversionAtVeHSER_dn_;
        VeESSR_n_InputSpeedProfile_DS =
            ESSR_ac_B.TmpSignalConversionAtVeHSER_n_I;
    }

    /* End of Switch: '<S12>/Switch' */
    /* End of Outputs for SubSystem: '<S2>/ESSC_DtrmnNiDLimits' */
    (void)Rte_Read_VeHSER_dn_NiDotMaxLm_Value(&rtb_UnitDelay_gl);
    (void)Rte_Read_VeHSER_dn_NiDotMinLm_Value(&rtb_Switch1_cy);

    /* Outputs for Function Call SubSystem: '<S2>/ESSC_DtrmnNiDLimits' */
    /* Switch: '<S157>/Switch1' incorporates:
     *  Constant: '<S160>/Calib'
     *  Inport: '<Root>/VeHSER_dn_NiDotMaxLm'
     *  Inport: '<Root>/VeHSER_dn_NiDotMinLm'
     */
    if (KeESSR_b_NiDotMinOvrrd)
    {
        /* Switch: '<S157>/Switch1' incorporates:
         *  Constant: '<S162>/Calib'
         */
        VeESSR_dn_NiDotMin = KeESSR_dn_NiDotMinVal;
    }
    else
    {
        /* Switch: '<S157>/Switch1' */
        VeESSR_dn_NiDotMin = rtb_Switch1_cy;
    }

    /* End of Switch: '<S157>/Switch1' */

    /* Switch: '<S158>/Switch1' incorporates:
     *  Constant: '<S159>/Calib'
     */
    if (KeESSR_b_NiDotMaxOvrrd)
    {
        /* Switch: '<S158>/Switch1' incorporates:
         *  Constant: '<S161>/Calib'
         */
        VeESSR_dn_NiDotMax = KeESSR_dn_NiDotMaxVal;
    }
    else
    {
        /* Switch: '<S158>/Switch1' */
        VeESSR_dn_NiDotMax = rtb_UnitDelay_gl;
    }

    /* End of Switch: '<S158>/Switch1' */

    /* Logic: '<S12>/Logical Operator' incorporates:
     *  Constant: '<S154>/Constant'
     *  Constant: '<S155>/Constant'
     *  RelationalOperator: '<S12>/Relational Operator'
     *  RelationalOperator: '<S12>/Relational Operator1'
     */
    rtb_LogicalOperator_e = ((CeHSER_e_Prof_EngOff != ((uint32)
        rtb_TmpSignalConversionAtVeHS_p)) && (((uint32)
        rtb_TmpSignalConversionAtVeHS_p) != CeHSER_e_Prof_EngStartStop));

    /* Update for UnitDelay: '<S12>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_d0 = rtb_LogicalOperator_e;

    /* End of Outputs for SubSystem: '<S2>/ESSC_DtrmnNiDLimits' */

    /* Outputs for Function Call SubSystem: '<S2>/ESSC_EngStrtDetect' */

    /* Outputs for Atomic SubSystem: '<S2987>/Digital Lowpass Reset Enabled' */
    /* UnitDelay: '<S2992>/Unit Delay' */
    rtb_UnitDelay_gl = ESSR_ac_DW.UnitDelay_DSTATE_c;

    /* Outputs for Atomic SubSystem: '<S2987>/ClosedInterval' */
    /* Switch: '<S2992>/Switch2' incorporates:
     *  Constant: '<S2990>/Constant'
     *  Constant: '<S2991>/Constant'
     *  DataStoreRead: '<S14>/Dsr_EngStartStopSt'
     *  Inport: '<Root>/VeTITR_M_SnsdEng_Flt'
     *  Logic: '<S2987>/NOT'
     *  Logic: '<S2989>/Logical Operator'
     *  RelationalOperator: '<S2989>/Relatonal Operator'
     *  RelationalOperator: '<S2989>/Relatonal Operator1'
     *  Switch: '<S2992>/Switch1'
     */
    if ((((uint32)VeESSR_e_EngStartStopSt_DS) < CeESSR_e_RestartPrepSt) ||
            (((uint32)VeESSR_e_EngStartStopSt_DS) > CeESSR_e_StrtEngOnlyChngMind))
    {
        /* Switch: '<S2992>/Switch1' incorporates:
         *  Constant: '<S2994>/Calib'
         */
        VeESSR_M_EngStrtTorqSnsd = KeESSR_M_EngStrtTrigInitTorq;
    }
    else
    {
        (void)Rte_Read_VeTITR_M_SnsdEng_Flt_Value(&rtb_Vector_di);

        /* Switch: '<S2992>/Switch1' incorporates:
         *  Constant: '<S2993>/Calib'
         *  Inport: '<Root>/VeTITR_M_SnsdEng_Flt'
         *  Product: '<S2992>/Multiplication'
         *  Sum: '<S2992>/Subtraction'
         *  Sum: '<S2992>/Summation'
         *  Switch: '<S2992>/Switch2'
         */
        VeESSR_M_EngStrtTorqSnsd = ((rtb_Vector_di - rtb_UnitDelay_gl) *
            KeESSR_K_EngStrtTrigFiltCoef) + rtb_UnitDelay_gl;
    }

    /* End of Switch: '<S2992>/Switch2' */
    /* End of Outputs for SubSystem: '<S2987>/ClosedInterval' */

    /* Update for UnitDelay: '<S2992>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_c = VeESSR_M_EngStrtTorqSnsd;

    /* End of Outputs for SubSystem: '<S2987>/Digital Lowpass Reset Enabled' */

    /* End of Outputs for SubSystem: '<S2>/ESSC_EngStrtDetect' */

    /* Outputs for Function Call SubSystem: '<S2>/ESSC_DtrmnEngDragTorqEst' */

    /* Logic: '<S31>/Logical2' incorporates:
     *  Constant: '<S41>/Constant'
     *  Constant: '<S42>/Constant'
     *  DataStoreRead: '<S10>/Dsr_EngStartStopSt1'
     *  RelationalOperator: '<S31>/Comparison5'
     *  RelationalOperator: '<S31>/Comparison6'
     */
    VeESSR_b_AdptSpnDwnTrg = ((CeESSR_e_RampDownSt == ((uint32)
        VeESSR_e_EngStartStopSt_DS)) || (((uint32)VeESSR_e_EngStartStopSt_DS) ==
        CeESSR_e_ImmedStopSt));

    /* Logic: '<S31>/Logical1' incorporates:
     *  Constant: '<S40>/Constant'
     *  Constant: '<S43>/Constant'
     *  DataStoreRead: '<S10>/Dsr_EngStartStopSt1'
     *  RelationalOperator: '<S31>/Comparison3'
     *  RelationalOperator: '<S31>/Comparison4'
     */
    VeESSR_b_AdptSpnUpTrg = ((CeESSR_e_SpinUpAutoStrtSt == ((uint32)
        VeESSR_e_EngStartStopSt_DS)) || (((uint32)VeESSR_e_EngStartStopSt_DS) ==
        CeESSR_e_SpinUpKeyStrtSt));

    /* Logic: '<S31>/Logical3' */
    VeESSR_b_AdptTrg = ((VeESSR_b_AdptSpnDwnTrg) || (VeESSR_b_AdptSpnUpTrg));

    /* Switch: '<S31>/Switch3' incorporates:
     *  Switch: '<S31>/Switch2'
     */
    if (VeESSR_b_AdptTrg)
    {
        /* Switch: '<S31>/Switch3' incorporates:
         *  DataStoreRead: '<S10>/Dsr_InputSpeedProfile1'
         */
        VeESSR_M_AdptEngEstTrq = VeESSR_M_EngTorqEst_DS;

        /* Switch: '<S31>/Switch2' */
        VeESSR_M_AdptEngActTrq = ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o;
    }
    else
    {
        /* Switch: '<S31>/Switch3' incorporates:
         *  Constant: '<S31>/Constant Value5'
         */
        VeESSR_M_AdptEngEstTrq = 0.0F;

        /* Switch: '<S31>/Switch2' incorporates:
         *  Constant: '<S31>/Constant Value5'
         */
        VeESSR_M_AdptEngActTrq = 0.0F;
    }

    /* End of Switch: '<S31>/Switch3' */

    /* Lookup_n-D: '<S34>/Vector' incorporates:
     *  Abs: '<S57>/Abs'
     *  Sum: '<S57>/Sum1'
     */
    rtb_Vector_di = fabsf(VeESSR_M_AdptEngEstTrq - VeESSR_M_AdptEngActTrq);

    /* Switch: '<S31>/Switch' incorporates:
     *  Switch: '<S31>/Switch1'
     */
    if (VeESSR_b_AdptSpnUpTrg)
    {
        /* Switch: '<S31>/Switch' incorporates:
         *  Constant: '<S51>/Calib'
         */
        VeESSR_M_AdptTiMaxErr = KeESSR_M_SpnUpTiMaxError;
    }
    else if (VeESSR_b_AdptSpnDwnTrg)
    {
        /* Switch: '<S31>/Switch1' incorporates:
         *  Constant: '<S49>/Calib'
         *  Switch: '<S31>/Switch'
         */
        VeESSR_M_AdptTiMaxErr = KeESSR_M_SpnDwnTiMaxError;
    }
    else
    {
        /* Switch: '<S31>/Switch' incorporates:
         *  Constant: '<S31>/Constant Value'
         *  Switch: '<S31>/Switch1'
         */
        VeESSR_M_AdptTiMaxErr = 0.0F;
    }

    /* End of Switch: '<S31>/Switch' */
    /* End of Outputs for SubSystem: '<S2>/ESSC_DtrmnEngDragTorqEst' */
    (void)Rte_Read_VeICSR_M_EngCL_Value(&rtb_UnitDelay2);

    /* Outputs for Function Call SubSystem: '<S2>/ESSC_DtrmnEngDragTorqEst' */
    /* RelationalOperator: '<S57>/Comparison2' incorporates:
     *  Inport: '<Root>/VeICSR_M_EngCL'
     */
    rtb_LogicalOperator_e = (rtb_Vector_di < VeESSR_M_AdptTiMaxErr);

    /* Switch: '<S31>/Switch10' */
    if (VeESSR_b_AdptTrg)
    {
        /* Switch: '<S31>/Switch10' */
        VeESSR_M_AdptEngCLTrq = rtb_UnitDelay2;
    }
    else
    {
        /* Switch: '<S31>/Switch10' incorporates:
         *  Constant: '<S31>/Constant Value5'
         */
        VeESSR_M_AdptEngCLTrq = 0.0F;
    }

    /* End of Switch: '<S31>/Switch10' */

    /* Outputs for Atomic SubSystem: '<S57>/EdgeRising1' */
    /* Logic: '<S62>/AND' incorporates:
     *  Logic: '<S62>/OR1'
     *  UnitDelay: '<S62>/Unit Delay'
     */
    rtb_AND_dr = (rtb_LogicalOperator_e && (!ESSR_ac_DW.UnitDelay_DSTATE_mh));

    /* Update for UnitDelay: '<S62>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_mh = rtb_LogicalOperator_e;

    /* End of Outputs for SubSystem: '<S57>/EdgeRising1' */

    /* UnitDelay: '<S77>/Unit Delay2' */
    rtb_UnitDelay2 = ESSR_ac_DW.UnitDelay2_DSTATE;

    /* Switch: '<S57>/Switch' */
    if (rtb_AND_dr)
    {
        /* Switch: '<S57>/Switch' */
        rtb_UnitDelay_gl = VeESSR_M_AdptEngCLTrq;
    }
    else
    {
        /* Switch: '<S57>/Switch' */
        rtb_UnitDelay_gl = rtb_UnitDelay2;
    }

    /* End of Switch: '<S57>/Switch' */

    /* Switch: '<S31>/Switch6' incorporates:
     *  Switch: '<S31>/Switch7'
     */
    if (VeESSR_b_AdptSpnUpTrg)
    {
        /* Switch: '<S31>/Switch6' incorporates:
         *  Constant: '<S50>/Calib'
         */
        VeESSR_M_AdptEngCLDeltaThrsh = KeESSR_M_SpnUpEngCLDeltaThres;
    }
    else if (VeESSR_b_AdptSpnDwnTrg)
    {
        /* Switch: '<S31>/Switch7' incorporates:
         *  Constant: '<S48>/Calib'
         *  Switch: '<S31>/Switch6'
         */
        VeESSR_M_AdptEngCLDeltaThrsh = KeESSR_M_SpnDwnEngCLDeltaThres;
    }
    else
    {
        /* Switch: '<S31>/Switch6' incorporates:
         *  Constant: '<S31>/Constant Value1'
         *  Switch: '<S31>/Switch7'
         */
        VeESSR_M_AdptEngCLDeltaThrsh = 0.0F;
    }

    /* End of Switch: '<S31>/Switch6' */

    /* Outputs for Atomic SubSystem: '<S57>/Hysteresis2' */
    /* Switch: '<S63>/Switch1' incorporates:
     *  RelationalOperator: '<S63>/Greater  Than'
     *  Sum: '<S57>/Sum'
     */
    if (VeESSR_M_AdptEngCLTrq > (rtb_UnitDelay_gl + VeESSR_M_AdptEngCLDeltaThrsh))
    {
        /* Switch: '<S63>/Switch1' incorporates:
         *  Constant: '<S63>/Constant Value'
         */
        rtb_Switch1_ac = true;
    }
    else
    {
        /* Switch: '<S63>/Switch1' incorporates:
         *  RelationalOperator: '<S63>/Greater  Than1'
         *  UnitDelay: '<S63>/Unit Delay'
         */
        rtb_Switch1_ac = ((VeESSR_M_AdptEngCLTrq > rtb_UnitDelay_gl) &&
                          (ESSR_ac_DW.UnitDelay_DSTATE_n));
    }

    /* End of Switch: '<S63>/Switch1' */

    /* Update for UnitDelay: '<S63>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_n = rtb_Switch1_ac;

    /* End of Outputs for SubSystem: '<S57>/Hysteresis2' */

    /* Logic: '<S57>/Logical3' */
    rtb_Logical3_nsq = (rtb_LogicalOperator_e && rtb_Switch1_ac);

    /* UnitDelay: '<S33>/Unit Delay7' */
    rtb_UnitDelay7 = ESSR_ac_DW.UnitDelay7_DSTATE;

    /* Outputs for Atomic SubSystem: '<S58>/EdgeRising1' */
    /* Logic: '<S66>/OR1' incorporates:
     *  UnitDelay: '<S66>/Unit Delay'
     */
    rtb_OR1_ay = !ESSR_ac_DW.UnitDelay_DSTATE_lp;

    /* Update for UnitDelay: '<S66>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_lp = rtb_UnitDelay7;

    /* End of Outputs for SubSystem: '<S58>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S33>/EdgeRising1' */
    /* Logic: '<S55>/AND' incorporates:
     *  Logic: '<S55>/OR1'
     *  UnitDelay: '<S55>/Unit Delay'
     */
    rtb_AND_hz = ((VeESSR_b_AdptTrg) && (!ESSR_ac_DW.UnitDelay_DSTATE_o));

    /* Update for UnitDelay: '<S55>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_o = VeESSR_b_AdptTrg;

    /* End of Outputs for SubSystem: '<S33>/EdgeRising1' */

    /* Outputs for Atomic SubSystem: '<S57>/Signal Latch On With Reset' */
    /* Outputs for Atomic SubSystem: '<S58>/Signal Latch On With Reset' */
    /* Logic: '<S67>/NOT' incorporates:
     *  Logic: '<S65>/NOT'
     */
    rtb_AND_hz = !rtb_AND_hz;

    /* End of Outputs for SubSystem: '<S57>/Signal Latch On With Reset' */

    /* Outputs for Atomic SubSystem: '<S58>/EdgeRising1' */
    /* Logic: '<S67>/OR1' incorporates:
     *  Logic: '<S66>/AND'
     *  Logic: '<S67>/NOT'
     *  Logic: '<S67>/OR'
     *  UnitDelay: '<S67>/Unit Delay'
     */
    rtb_OR1_ay = ((rtb_UnitDelay7 && rtb_OR1_ay) || (rtb_AND_hz &&
                   (ESSR_ac_DW.UnitDelay_DSTATE_cu)));

    /* End of Outputs for SubSystem: '<S58>/EdgeRising1' */

    /* Update for UnitDelay: '<S67>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_cu = rtb_OR1_ay;

    /* End of Outputs for SubSystem: '<S58>/Signal Latch On With Reset' */

    /* UnitDelay: '<S75>/Unit Delay2' */
    rtb_UnitDelay7 = ESSR_ac_DW.UnitDelay2_DSTATE_n;

    /* Logic: '<S57>/Logical6' incorporates:
     *  Switch: '<S58>/Switch3'
     */
    rtb_Logical6_pl = ((!rtb_OR1_ay) && rtb_UnitDelay7);

    /* RelationalOperator: '<S31>/Comparison9' incorporates:
     *  Constant: '<S45>/Constant'
     *  DataStoreRead: '<S10>/Dsr_EngStartStopSt1'
     */
    VeESSR_b_AdptSpnUpUpdtRaw = (((uint32)VeESSR_e_EngStartStopSt_DS) ==
        CeESSR_e_EngRunning);

    /* RelationalOperator: '<S31>/Comparison1' incorporates:
     *  Constant: '<S31>/Constant Value4'
     *  Constant: '<S53>/Calib'
     *  DataStoreRead: '<S10>/Dsr_EngTrqRespType6'
     *  S-Function (sfix_bitop): '<S31>/Bitwise Logical Operator'
     */
    VeESSR_b_AdptSpnUpESSRFails = ((KeESSR_g_SpnUpAdptESSRFailSel &
        VeESSR_g_StrtStpFailPhase_DS) > 0U);

    /* Logic: '<S31>/Logical4' incorporates:
     *  Logic: '<S31>/Logical6'
     */
    VeESSR_b_AdptStrtUpdtTrg = ((VeESSR_b_AdptSpnUpUpdtRaw) &&
        (!VeESSR_b_AdptSpnUpESSRFails));

    /* RelationalOperator: '<S31>/Comparison2' incorporates:
     *  Constant: '<S44>/Constant'
     *  DataStoreRead: '<S10>/Dsr_EngStartStopSt1'
     */
    VeESSR_b_AdptSpnDwnUpdtRaw = (CeESSR_e_EngOff == ((uint32)
        VeESSR_e_EngStartStopSt_DS));

    /* RelationalOperator: '<S31>/Comparison7' incorporates:
     *  Constant: '<S31>/Constant Value4'
     *  Constant: '<S52>/Calib'
     *  DataStoreRead: '<S10>/Dsr_EngTrqRespType6'
     *  S-Function (sfix_bitop): '<S31>/Bitwise Logical Operator1'
     */
    VeESSR_b_AdptSpnDwnESSRFails = ((VeESSR_g_StrtStpFailPhase_DS &
        KeESSR_g_SpnDwnAdptESSRFailSel) > 0U);

    /* Logic: '<S31>/Logical5' incorporates:
     *  Logic: '<S31>/Logical7'
     */
    VeESSR_b_AdptStpUpdtTrg = ((VeESSR_b_AdptSpnDwnUpdtRaw) &&
        (!VeESSR_b_AdptSpnDwnESSRFails));

    /* Logic: '<S31>/Logical8' */
    VeESSR_b_AdptUpdtTrg = ((VeESSR_b_AdptStrtUpdtTrg) ||
                            (VeESSR_b_AdptStpUpdtTrg));

    /* Logic: '<S33>/Logical3' */
    VeESSR_b_AdptUpdtActv = (rtb_Logical6_pl && (VeESSR_b_AdptUpdtTrg));

    /* Logic: '<S33>/Logical4' incorporates:
     *  Logic: '<S33>/Logical5'
     */
    rtb_OR1_ay = ((!rtb_Logical6_pl) && (!VeESSR_b_AdptUpdtActv));

    /* Switch: '<S72>/Switch23' */
    if (VeESSR_b_AdptTrg)
    {
        /* Switch: '<S72>/Switch23' */
        VeESSR_b_AdptEngCLRaise = rtb_Logical3_nsq;
    }
    else
    {
        /* Switch: '<S72>/Switch23' incorporates:
         *  Switch: '<S72>/Switch22'
         *  UnitDelay: '<S72>/Unit Delay2'
         */
        VeESSR_b_AdptEngCLRaise = ((!rtb_OR1_ay) &&
            (ESSR_ac_DW.UnitDelay2_DSTATE_g));
    }

    /* End of Switch: '<S72>/Switch23' */

    /* Outputs for Atomic SubSystem: '<S57>/Hysteresis3' */
    /* Switch: '<S64>/Switch1' incorporates:
     *  RelationalOperator: '<S64>/Greater  Than'
     */
    if (VeESSR_M_AdptEngCLTrq >= rtb_UnitDelay_gl)
    {
        /* Switch: '<S64>/Switch1' incorporates:
         *  Constant: '<S64>/Constant Value'
         */
        rtb_Logical6_pl = true;
    }
    else
    {
        /* Switch: '<S64>/Switch1' incorporates:
         *  RelationalOperator: '<S64>/Greater  Than1'
         *  Sum: '<S57>/Sum2'
         *  UnitDelay: '<S64>/Unit Delay'
         */
        rtb_Logical6_pl = ((VeESSR_M_AdptEngCLTrq >= (rtb_UnitDelay_gl -
                             VeESSR_M_AdptEngCLDeltaThrsh)) &&
                           (ESSR_ac_DW.UnitDelay_DSTATE_ma));
    }

    /* End of Switch: '<S64>/Switch1' */

    /* Update for UnitDelay: '<S64>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_ma = rtb_Logical6_pl;

    /* End of Outputs for SubSystem: '<S57>/Hysteresis3' */

    /* Logic: '<S57>/Logical6' */
    rtb_Logical6_pl = !rtb_Logical6_pl;

    /* Logic: '<S57>/Logical1' */
    rtb_Logical1_j = (rtb_LogicalOperator_e && rtb_Logical6_pl);

    /* Switch: '<S73>/Switch23' */
    if (VeESSR_b_AdptTrg)
    {
        /* Switch: '<S73>/Switch23' */
        VeESSR_b_AdptEngCLFall = rtb_Logical1_j;
    }
    else
    {
        /* Switch: '<S73>/Switch23' incorporates:
         *  Switch: '<S73>/Switch22'
         *  UnitDelay: '<S73>/Unit Delay2'
         */
        VeESSR_b_AdptEngCLFall = ((!rtb_OR1_ay) &&
            (ESSR_ac_DW.UnitDelay2_DSTATE_d));
    }

    /* End of Switch: '<S73>/Switch23' */

    /* Switch: '<S31>/Switch8' incorporates:
     *  Switch: '<S31>/Switch4'
     *  Switch: '<S31>/Switch5'
     *  Switch: '<S31>/Switch9'
     */
    if (VeESSR_b_AdptStrtUpdtTrg)
    {
        /* Switch: '<S31>/Switch8' incorporates:
         *  DataStoreRead: '<S31>/Dsr_NeESSR_M_SpinUpAddtlOffset1'
         */
        VeESSR_M_AdptNVRamVal = ESSR_ac_DW.NeESSR_M_SpinUpAddtlOffset;

        /* Switch: '<S31>/Switch4' incorporates:
         *  Constant: '<S47>/Calib'
         */
        VeESSR_M_AdptOffsetInc = KeESSR_M_SpinUpOffstInc;
    }
    else if (VeESSR_b_AdptStpUpdtTrg)
    {
        /* Switch: '<S31>/Switch8' incorporates:
         *  DataStoreRead: '<S31>/Dsr_SpinDwnAddtlOffset'
         *  Switch: '<S31>/Switch9'
         */
        VeESSR_M_AdptNVRamVal = ESSR_ac_DW.NeESSR_M_SpinDwnAddtlOffset;

        /* Switch: '<S31>/Switch5' incorporates:
         *  Constant: '<S46>/Calib'
         *  Switch: '<S31>/Switch4'
         */
        VeESSR_M_AdptOffsetInc = KeESSR_M_SpinDwnOffstInc;
    }
    else
    {
        /* Switch: '<S31>/Switch8' incorporates:
         *  Constant: '<S31>/Constant Value3'
         *  Switch: '<S31>/Switch9'
         */
        VeESSR_M_AdptNVRamVal = 0.0F;

        /* Switch: '<S31>/Switch4' incorporates:
         *  Constant: '<S31>/Constant Value2'
         *  Switch: '<S31>/Switch5'
         */
        VeESSR_M_AdptOffsetInc = 0.0F;
    }

    /* End of Switch: '<S31>/Switch8' */

    /* Outputs for Atomic SubSystem: '<S33>/AdjustTqOffsetAdpt' */
    /* Switch: '<S54>/Switch21' incorporates:
     *  Logic: '<S54>/Logical'
     *  Logic: '<S54>/Logical1'
     *  Logic: '<S54>/Logical3'
     *  Switch: '<S54>/Switch1'
     *  Switch: '<S54>/Switch2'
     */
    if (!VeESSR_b_AdptUpdtActv)
    {
        /* Switch: '<S54>/Switch21' */
        VeESSR_M_AdptTrqOffset = VeESSR_M_AdptNVRamVal;
    }
    else
    {
        if ((VeESSR_b_AdptEngCLRaise) && (VeESSR_b_AdptUpdtActv))
        {
            /* Switch: '<S54>/Switch1' */
            rtb_TmpSignalConversionAtVeOHSR = VeESSR_M_AdptOffsetInc;
        }
        else if ((VeESSR_b_AdptUpdtActv) && (VeESSR_b_AdptEngCLFall))
        {
            /* Switch: '<S54>/Switch2' incorporates:
             *  Gain: '<S54>/Gain'
             *  Switch: '<S54>/Switch1'
             */
            rtb_TmpSignalConversionAtVeOHSR = -VeESSR_M_AdptOffsetInc;
        }
        else
        {
            /* Switch: '<S54>/Switch1' incorporates:
             *  Constant: '<S54>/Constant Value'
             *  Switch: '<S54>/Switch2'
             */
            rtb_TmpSignalConversionAtVeOHSR = 0.0F;
        }

        /* Switch: '<S54>/Switch21' incorporates:
         *  Logic: '<S54>/Logical1'
         *  Sum: '<S54>/Sum'
         *  Switch: '<S54>/Switch1'
         *  Switch: '<S54>/Switch2'
         */
        VeESSR_M_AdptTrqOffset = VeESSR_M_AdptNVRamVal +
            rtb_TmpSignalConversionAtVeOHSR;
    }

    /* End of Switch: '<S54>/Switch21' */
    /* End of Outputs for SubSystem: '<S33>/AdjustTqOffsetAdpt' */

    /* Logic: '<S10>/Logical9' */
    VeESSR_b_AdptSpnDwnUpdtAllwd = ((VeESSR_b_AdptUpdtActv) &&
        (VeESSR_b_AdptStpUpdtTrg));

    /* Switch: '<S10>/Switch1' */
    if (VeESSR_b_AdptSpnDwnUpdtAllwd)
    {
        /* Switch: '<S10>/Switch1' */
        VeESSR_M_SpnDwnAddtlOffset = VeESSR_M_AdptTrqOffset;
    }
    else
    {
        /* Switch: '<S10>/Switch1' incorporates:
         *  DataStoreRead: '<S10>/Dsr_SpinDwnAddtlOffset'
         */
        VeESSR_M_SpnDwnAddtlOffset = ESSR_ac_DW.NeESSR_M_SpinDwnAddtlOffset;
    }

    /* End of Switch: '<S10>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S38>/Limiter' */
    /* Switch: '<S102>/Switch1' incorporates:
     *  Constant: '<S99>/Calib'
     *  RelationalOperator: '<S102>/Relational Operator'
     */
    if (KeESSR_M_SpinDwnMaxOffst < VeESSR_M_SpnDwnAddtlOffset)
    {
        /* Merge: '<S36>/Merge' */
        rtb_Switch1_cy = KeESSR_M_SpinDwnMaxOffst;
    }
    else
    {
        /* Merge: '<S36>/Merge' */
        rtb_Switch1_cy = VeESSR_M_SpnDwnAddtlOffset;
    }

    /* End of Switch: '<S102>/Switch1' */

    /* Switch: '<S102>/Switch' incorporates:
     *  Constant: '<S101>/Calib'
     *  DataStoreWrite: '<S38>/Dsw_SpinDwnAddtlOffset'
     *  RelationalOperator: '<S102>/Relational Operator1'
     */
    if (rtb_Switch1_cy > KeESSR_M_SpinDwnMinOffst)
    {
        ESSR_ac_DW.NeESSR_M_SpinDwnAddtlOffset = rtb_Switch1_cy;
    }
    else
    {
        ESSR_ac_DW.NeESSR_M_SpinDwnAddtlOffset = KeESSR_M_SpinDwnMinOffst;
    }

    /* End of Switch: '<S102>/Switch' */
    /* End of Outputs for SubSystem: '<S38>/Limiter' */

    /* Sum: '<S38>/Sum1' incorporates:
     *  Constant: '<S97>/Calib'
     *  DataStoreWrite: '<S38>/Dsw_SpinDwnAddtlOffset'
     *  Product: '<S38>/Product'
     */
    rtb_Switch1_cy = (VeESSR_n_TransInSpdFlt * KeESSR_K_SpinDwnAddtlTorq) +
        ESSR_ac_DW.NeESSR_M_SpinDwnAddtlOffset;

    /* Outputs for Atomic SubSystem: '<S38>/Limiter1' */
    /* Switch: '<S103>/Switch1' incorporates:
     *  Constant: '<S98>/Calib'
     *  RelationalOperator: '<S103>/Relational Operator'
     */
    if (KeESSR_M_SpinDwnMaxAddtl < rtb_Switch1_cy)
    {
        /* Merge: '<S36>/Merge' */
        rtb_Switch1_cy = KeESSR_M_SpinDwnMaxAddtl;
    }

    /* End of Switch: '<S103>/Switch1' */

    /* Switch: '<S103>/Switch' incorporates:
     *  Constant: '<S100>/Calib'
     *  RelationalOperator: '<S103>/Relational Operator1'
     */
    if (rtb_Switch1_cy > KeESSR_M_SpinDwnMinAddtl)
    {
        /* Switch: '<S103>/Switch' */
        VeESSR_M_SpnDwnAddtlTorqRaw = rtb_Switch1_cy;
    }
    else
    {
        /* Switch: '<S103>/Switch' */
        VeESSR_M_SpnDwnAddtlTorqRaw = KeESSR_M_SpinDwnMinAddtl;
    }

    /* End of Switch: '<S103>/Switch' */
    /* End of Outputs for SubSystem: '<S38>/Limiter1' */

    /* Logic: '<S10>/Logical8' */
    VeESSR_b_AdptSpnUpUpdtAllwd = ((VeESSR_b_AdptUpdtActv) &&
        (VeESSR_b_AdptStrtUpdtTrg));

    /* Switch: '<S10>/Switch' */
    if (VeESSR_b_AdptSpnUpUpdtAllwd)
    {
        /* Switch: '<S10>/Switch' */
        VeESSR_M_SpnUpAddtlOffset = VeESSR_M_AdptTrqOffset;
    }
    else
    {
        /* Switch: '<S10>/Switch' incorporates:
         *  DataStoreRead: '<S10>/Dsr_NeESSR_M_SpinUpAddtlOffset1'
         */
        VeESSR_M_SpnUpAddtlOffset = ESSR_ac_DW.NeESSR_M_SpinUpAddtlOffset;
    }

    /* End of Switch: '<S10>/Switch' */

    /* Outputs for Atomic SubSystem: '<S39>/Limiter' */
    /* Switch: '<S110>/Switch1' incorporates:
     *  Constant: '<S107>/Calib'
     *  RelationalOperator: '<S110>/Relational Operator'
     */
    if (KeESSR_M_SpinUpMaxOffst < VeESSR_M_SpnUpAddtlOffset)
    {
        /* Merge: '<S36>/Merge' */
        rtb_Switch1_cy = KeESSR_M_SpinUpMaxOffst;
    }
    else
    {
        /* Merge: '<S36>/Merge' */
        rtb_Switch1_cy = VeESSR_M_SpnUpAddtlOffset;
    }

    /* End of Switch: '<S110>/Switch1' */

    /* Switch: '<S110>/Switch' incorporates:
     *  Constant: '<S109>/Calib'
     *  DataStoreWrite: '<S39>/Dsw_SpinUpAddtlOffset'
     *  RelationalOperator: '<S110>/Relational Operator1'
     */
    if (rtb_Switch1_cy > KeESSR_M_SpinUpMinOffst)
    {
        ESSR_ac_DW.NeESSR_M_SpinUpAddtlOffset = rtb_Switch1_cy;
    }
    else
    {
        ESSR_ac_DW.NeESSR_M_SpinUpAddtlOffset = KeESSR_M_SpinUpMinOffst;
    }

    /* End of Switch: '<S110>/Switch' */
    /* End of Outputs for SubSystem: '<S39>/Limiter' */

    /* Sum: '<S39>/Sum1' incorporates:
     *  Constant: '<S105>/Calib'
     *  DataStoreWrite: '<S39>/Dsw_SpinUpAddtlOffset'
     *  Product: '<S39>/Product'
     */
    rtb_Switch1_cy = (VeESSR_n_TransInSpdFlt * KeESSR_K_SpinUpAddtlTorq) +
        ESSR_ac_DW.NeESSR_M_SpinUpAddtlOffset;

    /* Outputs for Atomic SubSystem: '<S39>/Limiter1' */
    /* Switch: '<S111>/Switch1' incorporates:
     *  Constant: '<S106>/Calib'
     *  RelationalOperator: '<S111>/Relational Operator'
     */
    if (KeESSR_M_SpinUpMaxAddtl < rtb_Switch1_cy)
    {
        /* Merge: '<S36>/Merge' */
        rtb_Switch1_cy = KeESSR_M_SpinUpMaxAddtl;
    }

    /* End of Switch: '<S111>/Switch1' */

    /* Switch: '<S111>/Switch' incorporates:
     *  Constant: '<S108>/Calib'
     *  RelationalOperator: '<S111>/Relational Operator1'
     */
    if (rtb_Switch1_cy > KeESSR_M_SpinUpMinAddtl)
    {
        /* Switch: '<S111>/Switch' */
        VeESSR_M_SpnUpAddtlTorqRaw = rtb_Switch1_cy;
    }
    else
    {
        /* Switch: '<S111>/Switch' */
        VeESSR_M_SpnUpAddtlTorqRaw = KeESSR_M_SpinUpMinAddtl;
    }

    /* End of Switch: '<S111>/Switch' */
    /* End of Outputs for SubSystem: '<S39>/Limiter1' */

    /* Outputs for Atomic SubSystem: '<S57>/EdgeFalling' */
    /* Logic: '<S60>/AND' incorporates:
     *  Logic: '<S60>/OR1'
     *  UnitDelay: '<S60>/Unit Delay'
     */
    rtb_AND_f4 = ((!rtb_Logical1_j) && (ESSR_ac_DW.UnitDelay_DSTATE_fl));

    /* Update for UnitDelay: '<S60>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_fl = rtb_Logical1_j;

    /* End of Outputs for SubSystem: '<S57>/EdgeFalling' */

    /* Outputs for Atomic SubSystem: '<S57>/EdgeFalling1' */
    /* Logic: '<S61>/AND' incorporates:
     *  Logic: '<S61>/OR1'
     *  UnitDelay: '<S61>/Unit Delay'
     */
    rtb_AND_cz = ((!rtb_Logical3_nsq) && (ESSR_ac_DW.UnitDelay_DSTATE_fs));

    /* Update for UnitDelay: '<S61>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_fs = rtb_Logical3_nsq;

    /* End of Outputs for SubSystem: '<S57>/EdgeFalling1' */

    /* Outputs for Atomic SubSystem: '<S57>/Signal Latch On With Reset' */
    /* Logic: '<S65>/OR1' incorporates:
     *  Logic: '<S57>/Logical7'
     *  Logic: '<S65>/OR'
     *  UnitDelay: '<S65>/Unit Delay'
     */
    rtb_AND_hz = ((rtb_AND_cz || rtb_AND_f4) || (rtb_AND_hz &&
                   (ESSR_ac_DW.UnitDelay_DSTATE_hs)));

    /* Update for UnitDelay: '<S65>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_hs = rtb_AND_hz;

    /* End of Outputs for SubSystem: '<S57>/Signal Latch On With Reset' */

    /* Switch: '<S68>/Switch23' incorporates:
     *  Switch: '<S68>/Switch22'
     *  Switch: '<S69>/Switch23'
     *  Switch: '<S70>/Switch23'
     *  Switch: '<S71>/Switch23'
     *  Switch: '<S74>/Switch23'
     *  Switch: '<S75>/Switch23'
     *  Switch: '<S76>/Switch23'
     *  Switch: '<S77>/Switch23'
     */
    if (VeESSR_b_AdptTrg)
    {
        /* Switch: '<S68>/Switch23' */
        VeESSR_b_AdptLrnErrRaw = rtb_LogicalOperator_e;

        /* Switch: '<S69>/Switch23' */
        VeESSR_b_AdptLrnErrRaise = rtb_AND_dr;

        /* Switch: '<S70>/Switch23' */
        VeESSR_b_AdptEngCLRaiseRaw = rtb_Switch1_ac;

        /* Switch: '<S71>/Switch23' */
        VeESSR_b_AdptEngCLFallRaw = rtb_Logical6_pl;

        /* Switch: '<S74>/Switch23' */
        VeESSR_b_AdptAbrt = rtb_AND_hz;

        /* Switch: '<S75>/Switch23' incorporates:
         *  Logic: '<S57>/Logical2'
         *  Logic: '<S57>/Logical4'
         *  Logic: '<S57>/Logical5'
         */
        VeESSR_b_AdptActv = ((rtb_Logical3_nsq || rtb_Logical1_j) &&
                             (!rtb_AND_hz));

        /* Switch: '<S76>/Switch23' */
        VeESSR_M_AdptFrctTrqErr = rtb_Vector_di;

        /* Switch: '<S77>/Switch23' */
        VeESSR_M_AdptEngCLTrqLtch = rtb_UnitDelay_gl;
    }
    else
    {
        rtb_LogicalOperator_e = !rtb_OR1_ay;

        /* Switch: '<S68>/Switch23' incorporates:
         *  Switch: '<S68>/Switch22'
         *  UnitDelay: '<S68>/Unit Delay2'
         */
        VeESSR_b_AdptLrnErrRaw = (rtb_LogicalOperator_e &&
            (ESSR_ac_DW.UnitDelay2_DSTATE_e));

        /* Switch: '<S69>/Switch23' incorporates:
         *  UnitDelay: '<S69>/Unit Delay2'
         */
        VeESSR_b_AdptLrnErrRaise = (rtb_LogicalOperator_e &&
            (ESSR_ac_DW.UnitDelay2_DSTATE_fg));

        /* Switch: '<S70>/Switch23' incorporates:
         *  UnitDelay: '<S70>/Unit Delay2'
         */
        VeESSR_b_AdptEngCLRaiseRaw = (rtb_LogicalOperator_e &&
            (ESSR_ac_DW.UnitDelay2_DSTATE_k));

        /* Switch: '<S71>/Switch23' incorporates:
         *  UnitDelay: '<S71>/Unit Delay2'
         */
        VeESSR_b_AdptEngCLFallRaw = (rtb_LogicalOperator_e &&
            (ESSR_ac_DW.UnitDelay2_DSTATE_m));

        /* Switch: '<S74>/Switch23' incorporates:
         *  UnitDelay: '<S74>/Unit Delay2'
         */
        VeESSR_b_AdptAbrt = (rtb_LogicalOperator_e &&
                             (ESSR_ac_DW.UnitDelay2_DSTATE_m5));

        /* Switch: '<S75>/Switch23' incorporates:
         *  Switch: '<S75>/Switch22'
         */
        VeESSR_b_AdptActv = (rtb_LogicalOperator_e && rtb_UnitDelay7);

        /* Switch: '<S76>/Switch22' incorporates:
         *  Switch: '<S77>/Switch22'
         */
        if (rtb_OR1_ay)
        {
            /* Switch: '<S76>/Switch23' incorporates:
             *  Constant: '<S76>/Constant Value1'
             */
            VeESSR_M_AdptFrctTrqErr = 0.0F;

            /* Switch: '<S77>/Switch23' incorporates:
             *  Constant: '<S77>/Constant Value1'
             */
            VeESSR_M_AdptEngCLTrqLtch = 0.0F;
        }
        else
        {
            /* Switch: '<S76>/Switch23' incorporates:
             *  UnitDelay: '<S76>/Unit Delay2'
             */
            VeESSR_M_AdptFrctTrqErr = ESSR_ac_DW.UnitDelay2_DSTATE_f;

            /* Switch: '<S77>/Switch23' */
            VeESSR_M_AdptEngCLTrqLtch = rtb_UnitDelay2;
        }

        /* End of Switch: '<S76>/Switch22' */
    }

    /* End of Switch: '<S68>/Switch23' */

    /* Logic: '<S78>/Logical1' incorporates:
     *  Constant: '<S86>/Constant'
     *  Constant: '<S87>/Constant'
     *  DataStoreRead: '<S78>/Dsr_EngStartStopSt'
     *  RelationalOperator: '<S78>/Comparison1'
     *  RelationalOperator: '<S78>/Comparison4'
     */
    rtb_LogicalOperator_e = ((((uint32)VeESSR_e_EngStartStopSt_DS) >=
        CeESSR_e_RestartPrepSt) && (((uint32)VeESSR_e_EngStartStopSt_DS) <=
        CeESSR_e_StrtEngEMStrtSt));

    /* Logic: '<S79>/Logical1' incorporates:
     *  Constant: '<S89>/Constant'
     *  Constant: '<S90>/Constant'
     *  DataStoreRead: '<S79>/Dsr_EngStrtStpMd'
     *  RelationalOperator: '<S79>/Comparison1'
     *  RelationalOperator: '<S79>/Comparison4'
     */
    rtb_AND_dr = ((CeESSR_e_ProducingTorque == ((uint32)VeESSR_e_EngStrtStpMd_DS))
                  || (((uint32)VeESSR_e_EngStrtStpMd_DS) == CeESSR_e_EnableFuel));

    /* If: '<S36>/If' */
    if ((!rtb_AND_dr) && rtb_LogicalOperator_e)
    {
        /* Outputs for IfAction SubSystem: '<S36>/Limitation_FuelDisabled_SpinUp' incorporates:
         *  ActionPort: '<S82>/Action Port'
         */
        /* Merge: '<S36>/Merge' incorporates:
         *  Constant: '<S82>/Constant Value'
         *  MinMax: '<S82>/MinMax'
         */
        rtb_Switch1_cy = fminf(0.0F, ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o);

        /* End of Outputs for SubSystem: '<S36>/Limitation_FuelDisabled_SpinUp' */
    }
    else if (rtb_AND_dr && rtb_LogicalOperator_e)
    {
        /* Outputs for IfAction SubSystem: '<S36>/Limitation_FuelEnabled_SpinUp' incorporates:
         *  ActionPort: '<S83>/Action Port'
         */
        /* Switch: '<S93>/Switch1' incorporates:
         *  Constant: '<S95>/Calib'
         *  RelationalOperator: '<S83>/Comparison'
         */
        if (VeESSR_n_TransInSpdFlt > KeESSR_n_EngSpd_EngTrqLmtSwtch)
        {
            /* Switch: '<S94>/Switch1' incorporates:
             *  Constant: '<S92>/Constant'
             *  DataStoreRead: '<S83>/Dsr_EngTrqReqImmed'
             *  DataStoreRead: '<S83>/Dsr_EngTrqReqPrdtd'
             *  DataStoreRead: '<S83>/Dsr_EngTrqRespType'
             *  RelationalOperator: '<S83>/Comparison1'
             */
            if (((uint32)VeESSR_e_EngTrqRespType_DS) ==
                    CePTAR_e_PleasibilityLimited)
            {
                rtb_TmpSignalConversionAtVeOHSR = VeESSR_M_EngTrqReqImmed_DS;
            }
            else
            {
                rtb_TmpSignalConversionAtVeOHSR = VeESSR_M_EngTrqReqPrdtd_DS;
            }

            /* End of Switch: '<S94>/Switch1' */

            /* Merge: '<S36>/Merge' incorporates:
             *  MinMax: '<S83>/MinMax'
             */
            rtb_Switch1_cy = fminf(rtb_TmpSignalConversionAtVeOHSR,
                                   ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o);
        }
        else
        {
            /* Merge: '<S36>/Merge' incorporates:
             *  Constant: '<S83>/Constant Value'
             *  MinMax: '<S83>/MinMax1'
             */
            rtb_Switch1_cy = fminf(0.0F,
                                   ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o);
        }

        /* End of Switch: '<S93>/Switch1' */
        /* End of Outputs for SubSystem: '<S36>/Limitation_FuelEnabled_SpinUp' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S36>/No_Limitation' incorporates:
         *  ActionPort: '<S85>/Action Port'
         */
        /* Merge: '<S36>/Merge' incorporates:
         *  Inport: '<S85>/EngTrqAct'
         */
        rtb_Switch1_cy = ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o;

        /* End of Outputs for SubSystem: '<S36>/No_Limitation' */
    }

    /* End of If: '<S36>/If' */

    /* Switch: '<S80>/Switch1' incorporates:
     *  Constant: '<S81>/Calib'
     */
    if (KeESSR_b_LmtEngTrqAct_Enbl)
    {
        /* Switch: '<S80>/Switch1' */
        VeESSR_M_EngTrqAct_Lmtd = rtb_Switch1_cy;
    }
    else
    {
        /* Switch: '<S80>/Switch1' */
        VeESSR_M_EngTrqAct_Lmtd = ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o;
    }

    /* End of Switch: '<S80>/Switch1' */

    /* Sum: '<S10>/Sum' incorporates:
     *  Lookup_n-D: '<S35>/Vector'
     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
     */
    VeESSR_M_SpnUpAddtlTorq = VeESSR_M_SpnUpAddtlTorqRaw + look1_iflf_binlcapw
        (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const float32 *)
          &(KxESSR_M_AddtlDragTorq_SpinUp[0])), ((const float32 *)
          &(KtESSR_M_AddtlDragTorq_SpinUp[0])), 8U);

    /* Sum: '<S10>/Sum1' incorporates:
     *  Lookup_n-D: '<S34>/Vector'
     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
     */
    VeESSR_M_SpnDwnAddtlTorq = look1_iflf_binlcapw
        (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const float32 *)
          &(KxESSR_M_AddtlDragTorq_SpinDwn[0])), ((const float32 *)
          &(KtESSR_M_AddtlDragTorq_SpinDwn[0])), 2U) +
        VeESSR_M_SpnDwnAddtlTorqRaw;

    /* Update for UnitDelay: '<S77>/Unit Delay2' */
    ESSR_ac_DW.UnitDelay2_DSTATE = VeESSR_M_AdptEngCLTrqLtch;

    /* Update for UnitDelay: '<S33>/Unit Delay7' */
    ESSR_ac_DW.UnitDelay7_DSTATE = VeESSR_b_AdptUpdtActv;

    /* Update for UnitDelay: '<S75>/Unit Delay2' */
    ESSR_ac_DW.UnitDelay2_DSTATE_n = VeESSR_b_AdptActv;

    /* Update for UnitDelay: '<S72>/Unit Delay2' */
    ESSR_ac_DW.UnitDelay2_DSTATE_g = VeESSR_b_AdptEngCLRaise;

    /* Update for UnitDelay: '<S73>/Unit Delay2' */
    ESSR_ac_DW.UnitDelay2_DSTATE_d = VeESSR_b_AdptEngCLFall;

    /* Update for UnitDelay: '<S68>/Unit Delay2' */
    ESSR_ac_DW.UnitDelay2_DSTATE_e = VeESSR_b_AdptLrnErrRaw;

    /* Update for UnitDelay: '<S69>/Unit Delay2' */
    ESSR_ac_DW.UnitDelay2_DSTATE_fg = VeESSR_b_AdptLrnErrRaise;

    /* Update for UnitDelay: '<S70>/Unit Delay2' */
    ESSR_ac_DW.UnitDelay2_DSTATE_k = VeESSR_b_AdptEngCLRaiseRaw;

    /* Update for UnitDelay: '<S71>/Unit Delay2' */
    ESSR_ac_DW.UnitDelay2_DSTATE_m = VeESSR_b_AdptEngCLFallRaw;

    /* Update for UnitDelay: '<S74>/Unit Delay2' */
    ESSR_ac_DW.UnitDelay2_DSTATE_m5 = VeESSR_b_AdptAbrt;

    /* Update for UnitDelay: '<S76>/Unit Delay2' */
    ESSR_ac_DW.UnitDelay2_DSTATE_f = VeESSR_M_AdptFrctTrqErr;

    /* End of Outputs for SubSystem: '<S2>/ESSC_DtrmnEngDragTorqEst' */

    /* Outputs for Function Call SubSystem: '<S2>/ESSC_StartProfileSelector' */

    /* Outputs for Atomic SubSystem: '<S3004>/SelectNewCals' */
    /* DataTypeConversion: '<S3009>/Data Type Conversion' incorporates:
     *  SignalConversion generated from: '<S2>/VeSTRR_e_EngStrtStopType'
     */
    rtb_DataTypeConversion_tmp = ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_E;

    /* If: '<S3011>/If' incorporates:
     *  DataTypeConversion: '<S3009>/Data Type Conversion'
     */
    if ((((sint32)rtb_DataTypeConversion_tmp) == 1) || (((sint32)
            rtb_DataTypeConversion_tmp) == 10))
    {
        /* Outputs for IfAction SubSystem: '<S3011>/KCrankNormal_iCalLoader_One' incorporates:
         *  ActionPort: '<S3107>/Action Port'
         */
        /* Merge: '<S3011>/Merge3' incorporates:
         *  Constant: '<S3107>/Constant Value'
         *  SignalConversion generated from: '<S3107>/i_CalLoader'
         */
        VeESSR_i_CalLoader_Local = 1U;

        /* Merge: '<S3011>/Merge1' incorporates:
         *  Constant: '<S3107>/TRUE Constant'
         *  SignalConversion generated from: '<S3107>/b_KeyType'
         */
        VeESSR_b_KeyType = true;

        /* Merge: '<S3011>/Merge2' incorporates:
         *  Constant: '<S3107>/Constant Value1'
         *  SignalConversion generated from: '<S3107>/Interp'
         */
        VeESSR_b_ParamInterp = false;

        /* End of Outputs for SubSystem: '<S3011>/KCrankNormal_iCalLoader_One' */
    }
    else if (((sint32)rtb_DataTypeConversion_tmp) == 2)
    {
        /* Outputs for IfAction SubSystem: '<S3011>/KCrankLowPwr_iCalLoader_Two' incorporates:
         *  ActionPort: '<S3106>/Action Port'
         */
        /* DataStoreWrite: '<S3106>/Dsw_i_DsrdCrkSpd' incorporates:
         *  Constant: '<S3106>/Constant Value1'
         */
        VeESSR_i_DsrdCrkSpd_DS = 0.0F;

        /* Merge: '<S3011>/Merge3' incorporates:
         *  Constant: '<S3106>/Constant Value'
         *  SignalConversion generated from: '<S3106>/i_CalLoader'
         */
        VeESSR_i_CalLoader_Local = 2U;

        /* Merge: '<S3011>/Merge1' incorporates:
         *  Constant: '<S3106>/TRUE Constant'
         *  SignalConversion generated from: '<S3106>/b_KeyType'
         */
        VeESSR_b_KeyType = true;

        /* Merge: '<S3011>/Merge2' incorporates:
         *  Constant: '<S3106>/Constant Value2'
         *  SignalConversion generated from: '<S3106>/Interp'
         */
        VeESSR_b_ParamInterp = false;

        /* End of Outputs for SubSystem: '<S3011>/KCrankLowPwr_iCalLoader_Two' */
    }
    else if (((sint32)rtb_DataTypeConversion_tmp) == 3)
    {
        /* Outputs for IfAction SubSystem: '<S3011>/KCrankLowPwrB_iCalLoader_TwoOrSeven' incorporates:
         *  ActionPort: '<S3105>/Action Port'
         */
        /* DataStoreWrite: '<S3105>/Dsw_i_DsrdCrkSpd' incorporates:
         *  Constant: '<S3105>/Constant Value1'
         */
        VeESSR_i_DsrdCrkSpd_DS = 1.0F;

        /* Switch: '<S3105>/Switch' incorporates:
         *  Constant: '<S3111>/Calib'
         */
        if (KeESSR_b_LowPwrBUseLowPwrCals)
        {
            /* Merge: '<S3011>/Merge3' incorporates:
             *  Constant: '<S3105>/Constant Value2'
             */
            VeESSR_i_CalLoader_Local = 7U;
        }
        else
        {
            /* Merge: '<S3011>/Merge3' incorporates:
             *  Constant: '<S3105>/Constant Value'
             */
            VeESSR_i_CalLoader_Local = 2U;
        }

        /* End of Switch: '<S3105>/Switch' */

        /* Merge: '<S3011>/Merge1' incorporates:
         *  Constant: '<S3105>/TRUE Constant'
         *  SignalConversion generated from: '<S3105>/b_KeyType'
         */
        VeESSR_b_KeyType = true;

        /* Merge: '<S3011>/Merge2' incorporates:
         *  Constant: '<S3105>/Constant Value3'
         *  SignalConversion generated from: '<S3105>/Interp'
         */
        VeESSR_b_ParamInterp = false;

        /* End of Outputs for SubSystem: '<S3011>/KCrankLowPwrB_iCalLoader_TwoOrSeven' */
    }
    else if (((sint32)rtb_DataTypeConversion_tmp) == 13)
    {
        /* Outputs for IfAction SubSystem: '<S3011>/AStrtReverse_iCalLoader_Three' incorporates:
         *  ActionPort: '<S3085>/Action Port'
         */
        /* Merge: '<S3011>/Merge3' incorporates:
         *  Constant: '<S3085>/Constant Value'
         *  SignalConversion generated from: '<S3085>/i_CalLoader'
         */
        VeESSR_i_CalLoader_Local = 3U;

        /* Merge: '<S3011>/Merge1' incorporates:
         *  Constant: '<S3085>/TRUE Constant'
         *  SignalConversion generated from: '<S3085>/b_KeyType'
         */
        VeESSR_b_KeyType = true;

        /* Merge: '<S3011>/Merge2' incorporates:
         *  Constant: '<S3085>/Constant Value1'
         *  SignalConversion generated from: '<S3085>/Interp'
         */
        VeESSR_b_ParamInterp = true;

        /* End of Outputs for SubSystem: '<S3011>/AStrtReverse_iCalLoader_Three' */
    }
    else if (((sint32)rtb_DataTypeConversion_tmp) == 4)
    {
        /* Outputs for IfAction SubSystem: '<S3011>/KCrankGeneric_iCalLoader_Seven' incorporates:
         *  ActionPort: '<S3104>/Action Port'
         */
        /* DataStoreWrite: '<S3104>/Dsw_i_DsrdCrkSpd' incorporates:
         *  Constant: '<S3104>/Constant Value1'
         */
        VeESSR_i_DsrdCrkSpd_DS = 2.0F;

        /* Merge: '<S3011>/Merge3' incorporates:
         *  Constant: '<S3104>/Constant Value'
         *  SignalConversion generated from: '<S3104>/i_CalLoader'
         */
        VeESSR_i_CalLoader_Local = 7U;

        /* Merge: '<S3011>/Merge1' incorporates:
         *  Constant: '<S3104>/TRUE Constant'
         *  SignalConversion generated from: '<S3104>/b_KeyType'
         */
        VeESSR_b_KeyType = true;

        /* Merge: '<S3011>/Merge2' incorporates:
         *  Constant: '<S3104>/Constant Value2'
         *  SignalConversion generated from: '<S3104>/Interp'
         */
        VeESSR_b_ParamInterp = false;

        /* End of Outputs for SubSystem: '<S3011>/KCrankGeneric_iCalLoader_Seven' */
    }
    else if (((sint32)rtb_DataTypeConversion_tmp) == 5)
    {
        /* Outputs for IfAction SubSystem: '<S3011>/AStrtSmooth_iCalLoader_Four' incorporates:
         *  ActionPort: '<S3086>/Action Port'
         */
        ESS_AStrtSmooth_iCalLoader_Four((&(VeESSR_i_CalLoader_Local)),
            (&(VeESSR_b_KeyType)), (&(VeESSR_b_ParamInterp)));

        /* End of Outputs for SubSystem: '<S3011>/AStrtSmooth_iCalLoader_Four' */
    }
    else if (((sint32)rtb_DataTypeConversion_tmp) == 6)
    {
        /* Outputs for IfAction SubSystem: '<S3011>/AStrtNormal_iCalLoader_Five' incorporates:
         *  ActionPort: '<S3084>/Action Port'
         */
        /* Merge: '<S3011>/Merge3' incorporates:
         *  Constant: '<S3084>/Constant Value'
         *  SignalConversion generated from: '<S3084>/i_CalLoader'
         */
        VeESSR_i_CalLoader_Local = 5U;

        /* Merge: '<S3011>/Merge1' incorporates:
         *  Constant: '<S3084>/FALSE Constant'
         *  SignalConversion generated from: '<S3084>/b_KeyType'
         */
        VeESSR_b_KeyType = false;

        /* Merge: '<S3011>/Merge2' incorporates:
         *  Constant: '<S3110>/Calib'
         *  SignalConversion generated from: '<S3084>/Le_ESSR_b_Interp'
         */
        VeESSR_b_ParamInterp = KeESSR_b_FtrAStrtNormalInterp;

        /* End of Outputs for SubSystem: '<S3011>/AStrtNormal_iCalLoader_Five' */
    }
    else if (((sint32)rtb_DataTypeConversion_tmp) == 7)
    {
        /* Outputs for IfAction SubSystem: '<S3011>/AStrtAggrsv_iCalLoader_Six' incorporates:
         *  ActionPort: '<S3079>/Action Port'
         */
        /* Merge: '<S3011>/Merge3' incorporates:
         *  Constant: '<S3079>/Constant Value'
         *  SignalConversion generated from: '<S3079>/i_CalLoader'
         */
        VeESSR_i_CalLoader_Local = 6U;

        /* Merge: '<S3011>/Merge1' incorporates:
         *  Constant: '<S3079>/FALSE Constant'
         *  SignalConversion generated from: '<S3079>/b_KeyType'
         */
        VeESSR_b_KeyType = false;

        /* Merge: '<S3011>/Merge2' incorporates:
         *  Constant: '<S3079>/Constant Value1'
         *  SignalConversion generated from: '<S3079>/Interp'
         */
        VeESSR_b_ParamInterp = false;

        /* End of Outputs for SubSystem: '<S3011>/AStrtAggrsv_iCalLoader_Six' */
    }
    else if (((sint32)rtb_DataTypeConversion_tmp) == 8)
    {
        /* Outputs for IfAction SubSystem: '<S3011>/AStrtGeneric_iCalLoader_Seven' incorporates:
         *  ActionPort: '<S3082>/Action Port'
         */
        /* Merge: '<S3011>/Merge3' incorporates:
         *  Constant: '<S3082>/Constant Value'
         *  SignalConversion generated from: '<S3082>/i_CalLoader'
         */
        VeESSR_i_CalLoader_Local = 7U;

        /* Merge: '<S3011>/Merge1' incorporates:
         *  Constant: '<S3082>/FALSE Constant'
         *  SignalConversion generated from: '<S3082>/b_KeyType'
         */
        VeESSR_b_KeyType = false;

        /* Merge: '<S3011>/Merge2' incorporates:
         *  Constant: '<S3082>/Constant Value1'
         *  SignalConversion generated from: '<S3082>/Interp'
         */
        VeESSR_b_ParamInterp = false;

        /* End of Outputs for SubSystem: '<S3011>/AStrtGeneric_iCalLoader_Seven' */
    }
    else if (((sint32)rtb_DataTypeConversion_tmp) == 9)
    {
        /* Outputs for IfAction SubSystem: '<S3011>/CompressTst_iCalLoader_Four' incorporates:
         *  ActionPort: '<S3087>/Action Port'
         */
        ESS_AStrtSmooth_iCalLoader_Four((&(VeESSR_i_CalLoader_Local)),
            (&(VeESSR_b_KeyType)), (&(VeESSR_b_ParamInterp)));

        /* End of Outputs for SubSystem: '<S3011>/CompressTst_iCalLoader_Four' */
    }
    else if (((sint32)rtb_DataTypeConversion_tmp) == 14)
    {
        /* Outputs for IfAction SubSystem: '<S3011>/AStrtCltchStrt_iCalLoader_Eight' incorporates:
         *  ActionPort: '<S3080>/Action Port'
         */
        /* Merge: '<S3011>/Merge3' incorporates:
         *  Constant: '<S3080>/Constant Value'
         *  SignalConversion generated from: '<S3080>/i_CalLoader'
         */
        VeESSR_i_CalLoader_Local = 8U;

        /* Merge: '<S3011>/Merge1' incorporates:
         *  Constant: '<S3080>/TRUE Constant'
         *  SignalConversion generated from: '<S3080>/b_KeyType'
         */
        VeESSR_b_KeyType = true;

        /* Merge: '<S3011>/Merge2' incorporates:
         *  Constant: '<S3080>/Constant Value1'
         *  SignalConversion generated from: '<S3080>/Interp'
         */
        VeESSR_b_ParamInterp = false;

        /* End of Outputs for SubSystem: '<S3011>/AStrtCltchStrt_iCalLoader_Eight' */
    }
    else if (((sint32)rtb_DataTypeConversion_tmp) == 15)
    {
        /* Outputs for IfAction SubSystem: '<S3011>/AStrtImpStrt_iCalLoader_Nine' incorporates:
         *  ActionPort: '<S3083>/Action Port'
         */
        /* Merge: '<S3011>/Merge3' incorporates:
         *  Constant: '<S3083>/Constant Value'
         *  SignalConversion generated from: '<S3083>/i_CalLoader'
         */
        VeESSR_i_CalLoader_Local = 9U;

        /* Merge: '<S3011>/Merge1' incorporates:
         *  Constant: '<S3083>/TRUE Constant'
         *  SignalConversion generated from: '<S3083>/b_KeyType'
         */
        VeESSR_b_KeyType = true;

        /* Merge: '<S3011>/Merge2' incorporates:
         *  Constant: '<S3083>/Constant Value1'
         *  SignalConversion generated from: '<S3083>/Interp'
         */
        VeESSR_b_ParamInterp = false;

        /* End of Outputs for SubSystem: '<S3011>/AStrtImpStrt_iCalLoader_Nine' */
    }
    else if ((((sint32)rtb_DataTypeConversion_tmp) == 16) || (((sint32)
               rtb_DataTypeConversion_tmp) == 17))
    {
        /* Outputs for IfAction SubSystem: '<S3011>/AStrtEMStrt_iCalLoader_Ten' incorporates:
         *  ActionPort: '<S3081>/Action Port'
         */
        /* Merge: '<S3011>/Merge3' incorporates:
         *  Constant: '<S3081>/Constant Value'
         *  SignalConversion generated from: '<S3081>/i_CalLoader'
         */
        VeESSR_i_CalLoader_Local = 10U;

        /* Merge: '<S3011>/Merge1' incorporates:
         *  Constant: '<S3081>/TRUE Constant'
         *  SignalConversion generated from: '<S3081>/b_KeyType'
         */
        VeESSR_b_KeyType = true;

        /* Merge: '<S3011>/Merge2' incorporates:
         *  Constant: '<S3081>/Constant Value1'
         *  SignalConversion generated from: '<S3081>/Interp'
         */
        VeESSR_b_ParamInterp = false;

        /* End of Outputs for SubSystem: '<S3011>/AStrtEMStrt_iCalLoader_Ten' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S3011>/Default_iCalLoader_Four' incorporates:
         *  ActionPort: '<S3088>/Action Port'
         */
        ESS_AStrtSmooth_iCalLoader_Four((&(VeESSR_i_CalLoader_Local)),
            (&(VeESSR_b_KeyType)), (&(VeESSR_b_ParamInterp)));

        /* End of Outputs for SubSystem: '<S3011>/Default_iCalLoader_Four' */
    }

    /* End of If: '<S3011>/If' */

    /* DataStoreWrite: '<S3011>/Data Store Write' */
    VeESSR_i_CalLoader_DS = VeESSR_i_CalLoader_Local;

    /* If: '<S3009>/If' */
    if (VeESSR_b_ParamInterp)
    {
        /* Outputs for IfAction SubSystem: '<S3009>/AStrtNormalInterp' incorporates:
         *  ActionPort: '<S3010>/Action Port'
         */
        /* Lookup_n-D: '<S3048>/Vector' incorporates:
         *  Abs: '<S3010>/Abs'
         */
        rtb_Vector_di = fabsf(rtb_TmpSignalConversionAtVeATRR);

        /* Abs: '<S3010>/Abs1' incorporates:
         *  Abs: '<S3010>/Abs2'
         */
        rtb_UnitDelay2 = fabsf(ESSR_ac_B.TmpSignalConversionAtVeCSVR_v_V);

        /* Sum: '<S3010>/Sum1' incorporates:
         *  Abs: '<S3010>/Abs1'
         *  Constant: '<S3010>/Constant Value2'
         *  Lookup_n-D: '<S3048>/Vector'
         *  Lookup_n-D: '<S3049>/Vector'
         *  Lookup_n-D: '<S3051>/Vector'
         *  MinMax: '<S3010>/MinMax1'
         *  SignalConversion generated from: '<S2>/VeAPSR_Pct_AccelPedalEffPosition'
         */
        VeESSR_k_AStrtNormalInterpRev = 1.0F - fmaxf(look2_iflf_binlcapw
            (rtb_TmpSignalConversionAtVeAPSR, rtb_UnitDelay2, ((const float32 *)
            &(KxESSR_k_AStrtNormalInterpPedalPstnMultRv[0])), ((const float32 *)
            &(KyESSR_k_AStrtNormalInterpPedalPstnMultRv[0])), ((const float32 *)
            &(KtESSR_k_AStrtNormalInterpPedalPstnMultRv[0])),
             ESSR_ac_ConstP.pooled28, 7U), look2_iflf_binlcapw(rtb_Vector_di,
            rtb_UnitDelay2, ((const float32 *)
                             &(KxESSR_k_AStrtNormalInterpMultRv[0])), ((const
            float32 *)&(KyESSR_k_AStrtNormalInterpMultRv[0])), ((const float32 *)
            &(KtESSR_k_AStrtNormalInterpMultRv[0])), ESSR_ac_ConstP.pooled28, 7U));

        /* Lookup_n-D: '<S3048>/Vector' incorporates:
         *  Abs: '<S3010>/Abs1'
         */
        rtb_Vector_di = look2_iflf_binlcapw(rtb_Vector_di, rtb_UnitDelay2, ((
            const float32 *)&(KxESSR_k_AStrtNormalInterpMult[0])), ((const
            float32 *)&(KyESSR_k_AStrtNormalInterpMult[0])), ((const float32 *)
            &(KtESSR_k_AStrtNormalInterpMult[0])), ESSR_ac_ConstP.pooled28, 7U);

        /* MinMax: '<S3010>/MinMax2' incorporates:
         *  Lookup_n-D: '<S3050>/Vector'
         *  SignalConversion generated from: '<S2>/VeAPSR_Pct_AccelPedalEffPosition'
         */
        VeESSR_k_AStrtNormalInterpFwd = fmaxf(look2_iflf_binlcapw
            (rtb_TmpSignalConversionAtVeAPSR, rtb_UnitDelay2, ((const float32 *)
            &(KxESSR_k_AStrtNormalInterpPedalPstnMult[0])), ((const float32 *)
            &(KyESSR_k_AStrtNormalInterpPedalPstnMult[0])), ((const float32 *)
            &(KtESSR_k_AStrtNormalInterpPedalPstnMult[0])),
             ESSR_ac_ConstP.pooled28, 7U), rtb_Vector_di);

        /* Switch: '<S3020>/Switch1' incorporates:
         *  DataTypeConversion: '<S3009>/Data Type Conversion'
         *  RelationalOperator: '<S3010>/Comparison4'
         *  Switch: '<S3021>/Switch1'
         */
        if (((sint32)rtb_DataTypeConversion_tmp) == 13)
        {
            /* Switch: '<S3020>/Switch1' */
            VeESSR_k_AStrtNormalInterp = VeESSR_k_AStrtNormalInterpRev;

            /* Switch: '<S3021>/Switch1' incorporates:
             *  Constant: '<S3010>/Constant Value1'
             *  Sum: '<S3010>/Sum'
             */
            rtb_Switch1_jm = (uint8)(((uint32)VeESSR_i_CalLoader_Local) + 1U);
        }
        else
        {
            /* Switch: '<S3020>/Switch1' */
            VeESSR_k_AStrtNormalInterp = VeESSR_k_AStrtNormalInterpFwd;

            /* Switch: '<S3021>/Switch1' */
            rtb_Switch1_jm = VeESSR_i_CalLoader_Local;
        }

        /* End of Switch: '<S3020>/Switch1' */

        /* Selector: '<S3053>/Selector1' incorporates:
         *  Constant: '<S3035>/Calib'
         *  Constant: '<S3053>/Constant Value1'
         *  Selector: '<S3054>/Selector1'
         *  Selector: '<S3055>/Selector1'
         *  Selector: '<S3056>/Selector1'
         *  Selector: '<S3057>/Selector1'
         *  Selector: '<S3058>/Selector1'
         *  Selector: '<S3059>/Selector1'
         *  Selector: '<S3060>/Selector1'
         *  Selector: '<S3061>/Selector1'
         *  Selector: '<S3062>/Selector1'
         *  Selector: '<S3063>/Selector1'
         *  Selector: '<S3064>/Selector1'
         *  Selector: '<S3065>/Selector1'
         *  Selector: '<S3066>/Selector1'
         *  Selector: '<S3067>/Selector1'
         *  Selector: '<S3068>/Selector1'
         *  Selector: '<S3069>/Selector1'
         *  Selector: '<S3070>/Selector1'
         *  Selector: '<S3071>/Selector1'
         *  Selector: '<S3072>/Selector1'
         *  Selector: '<S3073>/Selector1'
         *  Selector: '<S3074>/Selector1'
         *  Selector: '<S3075>/Selector1'
         *  Selector: '<S3076>/Selector1'
         *  Selector: '<S3077>/Selector1'
         *  Selector: '<S3078>/Selector1'
         *  Sum: '<S3053>/Sum2'
         */
        VeESSR_k_StrtTypFrstOrdLwPassT_ = ((sint32)((float32)(((float32)
            rtb_Switch1_jm) - 1.0F))) - 1;
        rtb_TmpSignalConversionAtVeAPSR = KaESSR_k_StrtTypFrstOrdLwPassT
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenT1Gain1' incorporates:
         *  Constant: '<S3035>/Calib'
         *  Merge: '<S3009>/Merge24'
         *  Product: '<S3053>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3053>/Selector1'
         *  Sum: '<S3053>/Sum'
         *  Sum: '<S3053>/Sum1'
         */
        VeESSR_k_StrtTypFrstOrdLwPassT_DS = ((KaESSR_k_StrtTypFrstOrdLwPassT
            [((sint32)rtb_Switch1_jm) - 1] - rtb_TmpSignalConversionAtVeAPSR) *
            VeESSR_k_AStrtNormalInterp) + rtb_TmpSignalConversionAtVeAPSR;

        /* Selector: '<S3054>/Selector1' incorporates:
         *  Constant: '<S3037>/Calib'
         */
        rtb_TmpSignalConversionAtVeAPSR = KaESSR_k_StrtTypScndOrdLwPassT
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenT1Gain2' incorporates:
         *  Constant: '<S3037>/Calib'
         *  Merge: '<S3009>/Merge25'
         *  Product: '<S3054>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3054>/Selector'
         *  Selector: '<S3054>/Selector1'
         *  Sum: '<S3054>/Sum'
         *  Sum: '<S3054>/Sum1'
         */
        VeESSR_k_StrtTypScndOrdLwPassT_DS = ((KaESSR_k_StrtTypScndOrdLwPassT
            [((sint32)rtb_Switch1_jm) - 1] - rtb_TmpSignalConversionAtVeAPSR) *
            VeESSR_k_AStrtNormalInterp) + rtb_TmpSignalConversionAtVeAPSR;

        /* Selector: '<S3055>/Selector1' incorporates:
         *  Constant: '<S3038>/Calib'
         */
        rtb_TmpSignalConversionAtVeAPSR = KaESSR_n_StrtTypAStrtSpinUpExtSpd
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_StrtTypAStrtSpinUpExtSpd' incorporates:
         *  Constant: '<S3038>/Calib'
         *  Merge: '<S3009>/Merge7'
         *  Product: '<S3055>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3055>/Selector'
         *  Selector: '<S3055>/Selector1'
         *  Sum: '<S3055>/Sum'
         *  Sum: '<S3055>/Sum1'
         */
        VeESSR_n_StrtTypAStrtSpinUpExtSpd_DS =
            ((KaESSR_n_StrtTypAStrtSpinUpExtSpd[((sint32)rtb_Switch1_jm) - 1] -
              rtb_TmpSignalConversionAtVeAPSR) * VeESSR_k_AStrtNormalInterp) +
            rtb_TmpSignalConversionAtVeAPSR;

        /* Selector: '<S3056>/Selector1' incorporates:
         *  Constant: '<S3042>/Calib'
         */
        rtb_TmpSignalConversionAtVeAPSR = KaESSR_scl_StrtTypPulseCnclTorqScaler
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim5' incorporates:
         *  Constant: '<S3042>/Calib'
         *  Merge: '<S3009>/Merge8'
         *  Product: '<S3056>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3056>/Selector'
         *  Selector: '<S3056>/Selector1'
         *  Sum: '<S3056>/Sum'
         *  Sum: '<S3056>/Sum1'
         */
        VeESSR_scl_StrtTypPulseCnclTorqScaler_DS =
            ((KaESSR_scl_StrtTypPulseCnclTorqScaler[((sint32)rtb_Switch1_jm) - 1]
              - rtb_TmpSignalConversionAtVeAPSR) * VeESSR_k_AStrtNormalInterp) +
            rtb_TmpSignalConversionAtVeAPSR;

        /* Selector: '<S3057>/Selector1' incorporates:
         *  Constant: '<S3041>/Calib'
         */
        rtb_TmpSignalConversionAtVeAPSR = KaESSR_phi_StrtTypInitSpinBrkAng
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim6' incorporates:
         *  Constant: '<S3041>/Calib'
         *  Merge: '<S3009>/Merge9'
         *  Product: '<S3057>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3057>/Selector'
         *  Selector: '<S3057>/Selector1'
         *  Sum: '<S3057>/Sum'
         *  Sum: '<S3057>/Sum1'
         */
        VeESSR_phi_StrtTypInitSpinBrkAng_DS =
            ((KaESSR_phi_StrtTypInitSpinBrkAng[((sint32)rtb_Switch1_jm) - 1] -
              rtb_TmpSignalConversionAtVeAPSR) * VeESSR_k_AStrtNormalInterp) +
            rtb_TmpSignalConversionAtVeAPSR;

        /* Selector: '<S3058>/Selector1' incorporates:
         *  Constant: '<S3036>/Calib'
         */
        rtb_TmpSignalConversionAtVeAPSR = KaESSR_k_StrtTypInitSpinScaler
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim7' incorporates:
         *  Constant: '<S3036>/Calib'
         *  Merge: '<S3009>/Merge11'
         *  Product: '<S3058>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3058>/Selector'
         *  Selector: '<S3058>/Selector1'
         *  Sum: '<S3058>/Sum'
         *  Sum: '<S3058>/Sum1'
         */
        VeESSR_k_StrtTypInitSpinScaler_DS = ((KaESSR_k_StrtTypInitSpinScaler
            [((sint32)rtb_Switch1_jm) - 1] - rtb_TmpSignalConversionAtVeAPSR) *
            VeESSR_k_AStrtNormalInterp) + rtb_TmpSignalConversionAtVeAPSR;

        /* Selector: '<S3059>/Selector1' incorporates:
         *  Constant: '<S3022>/Calib'
         */
        rtb_TmpSignalConversionAtVeAPSR = KaESSR_Cnt_StrtTypInitSpinEndPnt
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim8' incorporates:
         *  Constant: '<S3022>/Calib'
         *  Merge: '<S3009>/Merge10'
         *  Product: '<S3059>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3059>/Selector'
         *  Selector: '<S3059>/Selector1'
         *  Sum: '<S3059>/Sum'
         *  Sum: '<S3059>/Sum1'
         */
        VeESSR_Cnt_StrtTypInitSpinEndPnt_DS =
            ((KaESSR_Cnt_StrtTypInitSpinEndPnt[((sint32)rtb_Switch1_jm) - 1] -
              rtb_TmpSignalConversionAtVeAPSR) * VeESSR_k_AStrtNormalInterp) +
            rtb_TmpSignalConversionAtVeAPSR;

        /* Selector: '<S3060>/Selector1' incorporates:
         *  Constant: '<S3024>/Calib'
         */
        rtb_TmpSignalConversionAtVeAPSR = KaESSR_M_StrtTypInitPredTorq
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim9' incorporates:
         *  Constant: '<S3024>/Calib'
         *  Merge: '<S3009>/Merge6'
         *  Product: '<S3060>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3060>/Selector'
         *  Selector: '<S3060>/Selector1'
         *  Sum: '<S3060>/Sum'
         *  Sum: '<S3060>/Sum1'
         */
        VeESSR_M_StrtTypInitPredTorq_DS = ((KaESSR_M_StrtTypInitPredTorq
            [((sint32)rtb_Switch1_jm) - 1] - rtb_TmpSignalConversionAtVeAPSR) *
            VeESSR_k_AStrtNormalInterp) + rtb_TmpSignalConversionAtVeAPSR;

        /* Selector: '<S3061>/Selector1' incorporates:
         *  Constant: '<S3023>/Calib'
         */
        rtb_TmpSignalConversionAtVeAPSR = KaESSR_M_StrtTypInitImmedTorq
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim10' incorporates:
         *  Constant: '<S3023>/Calib'
         *  Merge: '<S3009>/Merge5'
         *  Product: '<S3061>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3061>/Selector'
         *  Selector: '<S3061>/Selector1'
         *  Sum: '<S3061>/Sum'
         *  Sum: '<S3061>/Sum1'
         */
        VeESSR_M_StrtTypInitImmedTorq_DS = ((KaESSR_M_StrtTypInitImmedTorq
            [((sint32)rtb_Switch1_jm) - 1] - rtb_TmpSignalConversionAtVeAPSR) *
            VeESSR_k_AStrtNormalInterp) + rtb_TmpSignalConversionAtVeAPSR;

        /* Selector: '<S3062>/Selector1' incorporates:
         *  Constant: '<S3033>/Calib'
         */
        rtb_TmpSignalConversionAtVeAPSR = KaESSR_k_StrtTypEngTorqReqFltT
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim12' incorporates:
         *  Constant: '<S3033>/Calib'
         *  Merge: '<S3009>/Merge4'
         *  Product: '<S3062>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3062>/Selector'
         *  Selector: '<S3062>/Selector1'
         *  Sum: '<S3062>/Sum'
         *  Sum: '<S3062>/Sum1'
         */
        VeESSR_k_StrtTypEngTorqReqFltT_DS = ((KaESSR_k_StrtTypEngTorqReqFltT
            [((sint32)rtb_Switch1_jm) - 1] - rtb_TmpSignalConversionAtVeAPSR) *
            VeESSR_k_AStrtNormalInterp) + rtb_TmpSignalConversionAtVeAPSR;

        /* Selector: '<S3063>/Selector1' incorporates:
         *  Constant: '<S3034>/Calib'
         */
        rtb_TmpSignalConversionAtVeAPSR = KaESSR_k_StrtTypEngTorqReqImmedFltD
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim13' incorporates:
         *  Constant: '<S3034>/Calib'
         *  Merge: '<S3009>/Merge3'
         *  Product: '<S3063>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3063>/Selector'
         *  Selector: '<S3063>/Selector1'
         *  Sum: '<S3063>/Sum'
         *  Sum: '<S3063>/Sum1'
         */
        VeESSR_k_StrtTypEngTorqReqImmedFltD_DS =
            ((KaESSR_k_StrtTypEngTorqReqImmedFltD[((sint32)rtb_Switch1_jm) - 1]
              - rtb_TmpSignalConversionAtVeAPSR) * VeESSR_k_AStrtNormalInterp) +
            rtb_TmpSignalConversionAtVeAPSR;

        /* Selector: '<S3064>/Selector1' incorporates:
         *  Constant: '<S3028>/Calib'
         */
        rtb_TmpSignalConversionAtVeAPSR = KaESSR_dn_StrtTypJerkMin
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim1' incorporates:
         *  Constant: '<S3028>/Calib'
         *  Merge: '<S3009>/Merge16'
         *  Product: '<S3064>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3064>/Selector'
         *  Selector: '<S3064>/Selector1'
         *  Sum: '<S3064>/Sum'
         *  Sum: '<S3064>/Sum1'
         */
        VeESSR_dn_StrtTypJerkMin_DS = ((KaESSR_dn_StrtTypJerkMin[((sint32)
            rtb_Switch1_jm) - 1] - rtb_TmpSignalConversionAtVeAPSR) *
            VeESSR_k_AStrtNormalInterp) + rtb_TmpSignalConversionAtVeAPSR;

        /* Selector: '<S3065>/Selector1' incorporates:
         *  Constant: '<S3030>/Calib'
         */
        rtb_TmpSignalConversionAtVeAPSR = KaESSR_dn_StrtTypNiDotMax
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* Merge: '<S3009>/Merge18' incorporates:
         *  Constant: '<S3030>/Calib'
         *  Product: '<S3065>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3065>/Selector'
         *  Selector: '<S3065>/Selector1'
         *  Sum: '<S3065>/Sum'
         *  Sum: '<S3065>/Sum1'
         */
        rtb_TmpSignalConversionAtVeAPSR += (KaESSR_dn_StrtTypNiDotMax[((sint32)
            rtb_Switch1_jm) - 1] - rtb_TmpSignalConversionAtVeAPSR) *
            VeESSR_k_AStrtNormalInterp;

        /* Selector: '<S3066>/Selector1' incorporates:
         *  Constant: '<S3031>/Calib'
         */
        rtb_Vector_di = KaESSR_dn_StrtTypNiDotMax_EngStrt
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* Merge: '<S3009>/Merge2' incorporates:
         *  Constant: '<S3031>/Calib'
         *  Product: '<S3066>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3066>/Selector'
         *  Selector: '<S3066>/Selector1'
         *  Sum: '<S3066>/Sum'
         *  Sum: '<S3066>/Sum1'
         */
        rtb_Vector_di += (KaESSR_dn_StrtTypNiDotMax_EngStrt[((sint32)
                           rtb_Switch1_jm) - 1] - rtb_Vector_di) *
            VeESSR_k_AStrtNormalInterp;

        /* Selector: '<S3067>/Selector1' incorporates:
         *  Constant: '<S3029>/Calib'
         */
        rtb_UnitDelay2 = KaESSR_dn_StrtTypJerkMinStartEng
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim16' incorporates:
         *  Constant: '<S3029>/Calib'
         *  Merge: '<S3009>/Merge22'
         *  Product: '<S3067>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3067>/Selector'
         *  Selector: '<S3067>/Selector1'
         *  Sum: '<S3067>/Sum'
         *  Sum: '<S3067>/Sum1'
         */
        VeESSR_dn_StrtTypJerkMinStartEng_DS =
            ((KaESSR_dn_StrtTypJerkMinStartEng[((sint32)rtb_Switch1_jm) - 1] -
              rtb_UnitDelay2) * VeESSR_k_AStrtNormalInterp) + rtb_UnitDelay2;

        /* Selector: '<S3068>/Selector1' incorporates:
         *  Constant: '<S3040>/Calib'
         */
        rtb_UnitDelay2 = KaESSR_p_StrtTypMaxManPrs
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_StrtTypAStrtSpinUpManPrs' incorporates:
         *  Constant: '<S3040>/Calib'
         *  Merge: '<S3009>/Merge23'
         *  Product: '<S3068>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3068>/Selector'
         *  Selector: '<S3068>/Selector1'
         *  Sum: '<S3068>/Sum'
         *  Sum: '<S3068>/Sum1'
         */
        VeESSR_p_StrtTypAStrtSpinUpManPrs_DS = ((KaESSR_p_StrtTypMaxManPrs
            [((sint32)rtb_Switch1_jm) - 1] - rtb_UnitDelay2) *
            VeESSR_k_AStrtNormalInterp) + rtb_UnitDelay2;

        /* Selector: '<S3069>/Selector1' incorporates:
         *  Constant: '<S3045>/Calib'
         */
        rtb_UnitDelay2 = KaESSR_t_StrtTypManPrsTm
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_StrtTypAStrtSpinUpManPrs1' incorporates:
         *  Constant: '<S3045>/Calib'
         *  Merge: '<S3009>/Merge26'
         *  Product: '<S3069>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3069>/Selector'
         *  Selector: '<S3069>/Selector1'
         *  Sum: '<S3069>/Sum'
         *  Sum: '<S3069>/Sum1'
         */
        VeESSR_t_StrtTypManPrsMaxTm_DS = ((KaESSR_t_StrtTypManPrsTm[((sint32)
            rtb_Switch1_jm) - 1] - rtb_UnitDelay2) * VeESSR_k_AStrtNormalInterp)
            + rtb_UnitDelay2;

        /* Selector: '<S3070>/Selector1' incorporates:
         *  Constant: '<S3044>/Calib'
         */
        rtb_UnitDelay2 = KaESSR_t_StrtTypGasFlwActrDlyTm
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Data Store Write11' incorporates:
         *  Constant: '<S3044>/Calib'
         *  Merge: '<S3009>/Merge27'
         *  Product: '<S3070>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3070>/Selector'
         *  Selector: '<S3070>/Selector1'
         *  Sum: '<S3070>/Sum'
         *  Sum: '<S3070>/Sum1'
         */
        ESSR_ac_DW.VeESSR_t_StrtTypGasFlwActrDlyTm =
            ((KaESSR_t_StrtTypGasFlwActrDlyTm[((sint32)rtb_Switch1_jm) - 1] -
              rtb_UnitDelay2) * VeESSR_k_AStrtNormalInterp) + rtb_UnitDelay2;

        /* Selector: '<S3071>/Selector1' incorporates:
         *  Constant: '<S3046>/Calib'
         */
        rtb_UnitDelay2 = KaESSR_t_StrtTypNiPredFilter
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Data Store Write1' incorporates:
         *  Constant: '<S3046>/Calib'
         *  Merge: '<S3009>/Merge28'
         *  Product: '<S3071>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3071>/Selector'
         *  Selector: '<S3071>/Selector1'
         *  Sum: '<S3071>/Sum'
         *  Sum: '<S3071>/Sum1'
         */
        ESSR_ac_DW.VeESSR_k_StrtTypNiPredFilter_DS =
            ((KaESSR_t_StrtTypNiPredFilter[((sint32)rtb_Switch1_jm) - 1] -
              rtb_UnitDelay2) * VeESSR_k_AStrtNormalInterp) + rtb_UnitDelay2;

        /* Selector: '<S3072>/Selector1' incorporates:
         *  Constant: '<S3032>/Calib'
         */
        rtb_UnitDelay2 = KaESSR_dn_StrtTypNiDotMin
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* Merge: '<S3009>/Merge19' incorporates:
         *  Constant: '<S3032>/Calib'
         *  Product: '<S3072>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3072>/Selector'
         *  Selector: '<S3072>/Selector1'
         *  Sum: '<S3072>/Sum'
         *  Sum: '<S3072>/Sum1'
         */
        rtb_UnitDelay2 += (KaESSR_dn_StrtTypNiDotMin[((sint32)rtb_Switch1_jm) -
                           1] - rtb_UnitDelay2) * VeESSR_k_AStrtNormalInterp;

        /* Selector: '<S3073>/Selector1' incorporates:
         *  Constant: '<S3026>/Calib'
         */
        rtb_UnitDelay_gl = KaESSR_dn_StrtTypJerkMax
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim11' incorporates:
         *  Constant: '<S3026>/Calib'
         *  Merge: '<S3009>/Merge20'
         *  Product: '<S3073>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3073>/Selector'
         *  Selector: '<S3073>/Selector1'
         *  Sum: '<S3073>/Sum'
         *  Sum: '<S3073>/Sum1'
         */
        VeESSR_dn_StrtTypJerkMax_DS = ((KaESSR_dn_StrtTypJerkMax[((sint32)
            rtb_Switch1_jm) - 1] - rtb_UnitDelay_gl) *
            VeESSR_k_AStrtNormalInterp) + rtb_UnitDelay_gl;

        /* Selector: '<S3074>/Selector1' incorporates:
         *  Constant: '<S3047>/Calib'
         */
        rtb_UnitDelay_gl = KaESSR_t_StrtTypPhaserDelayTm
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim4' incorporates:
         *  Constant: '<S3047>/Calib'
         *  Merge: '<S3009>/Merge21'
         *  Product: '<S3074>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3074>/Selector'
         *  Selector: '<S3074>/Selector1'
         *  Sum: '<S3074>/Sum'
         *  Sum: '<S3074>/Sum1'
         */
        VeESSR_t_StrtTypPhaserDelayTm_DS = ((KaESSR_t_StrtTypPhaserDelayTm
            [((sint32)rtb_Switch1_jm) - 1] - rtb_UnitDelay_gl) *
            VeESSR_k_AStrtNormalInterp) + rtb_UnitDelay_gl;

        /* Selector: '<S3075>/Selector1' incorporates:
         *  Constant: '<S3025>/Calib'
         */
        rtb_UnitDelay_gl = KaESSR_M_StrtTypMinImmedExitTorqDelta
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_MinImmedExitTorqDelta' incorporates:
         *  Constant: '<S3025>/Calib'
         *  Merge: '<S3009>/Merge13'
         *  Product: '<S3075>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3075>/Selector'
         *  Selector: '<S3075>/Selector1'
         *  Sum: '<S3075>/Sum'
         *  Sum: '<S3075>/Sum1'
         */
        VeESSR_M_MinImmedExitTorqDelta_DS =
            ((KaESSR_M_StrtTypMinImmedExitTorqDelta[((sint32)rtb_Switch1_jm) - 1]
              - rtb_UnitDelay_gl) * VeESSR_k_AStrtNormalInterp) +
            rtb_UnitDelay_gl;

        /* Selector: '<S3076>/Selector1' incorporates:
         *  Constant: '<S3027>/Calib'
         */
        rtb_UnitDelay_gl = KaESSR_dn_StrtTypJerkMaxStartEng
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim15' incorporates:
         *  Constant: '<S3027>/Calib'
         *  Merge: '<S3009>/Merge15'
         *  Product: '<S3076>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3076>/Selector'
         *  Selector: '<S3076>/Selector1'
         *  Sum: '<S3076>/Sum'
         *  Sum: '<S3076>/Sum1'
         */
        VeESSR_dn_StrtTypJerkMaxStartEng_DS =
            ((KaESSR_dn_StrtTypJerkMaxStartEng[((sint32)rtb_Switch1_jm) - 1] -
              rtb_UnitDelay_gl) * VeESSR_k_AStrtNormalInterp) + rtb_UnitDelay_gl;

        /* Selector: '<S3077>/Selector1' incorporates:
         *  Constant: '<S3043>/Calib'
         */
        rtb_UnitDelay_gl = KaESSR_t_StrtTypAirflowTrqMaxTm
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim2' incorporates:
         *  Constant: '<S3043>/Calib'
         *  Merge: '<S3009>/Merge14'
         *  Product: '<S3077>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3077>/Selector'
         *  Selector: '<S3077>/Selector1'
         *  Sum: '<S3077>/Sum'
         *  Sum: '<S3077>/Sum1'
         */
        VeESSR_t_StrtTypAirflowTrqMaxTm_DS = ((KaESSR_t_StrtTypAirflowTrqMaxTm
            [((sint32)rtb_Switch1_jm) - 1] - rtb_UnitDelay_gl) *
            VeESSR_k_AStrtNormalInterp) + rtb_UnitDelay_gl;

        /* Selector: '<S3078>/Selector1' incorporates:
         *  Constant: '<S3039>/Calib'
         */
        rtb_UnitDelay_gl = KaESSR_n_StrtTypMaxStrtNiNoFuel
            [(VeESSR_k_StrtTypFrstOrdLwPassT_)];

        /* DataStoreWrite: '<S17>/Dsw_StrtTypMaxStrtNiNoFuel' incorporates:
         *  Constant: '<S3039>/Calib'
         *  Merge: '<S3009>/Merge17'
         *  Product: '<S3078>/Product'
         *  Selector: '<S3053>/Selector'
         *  Selector: '<S3078>/Selector'
         *  Selector: '<S3078>/Selector1'
         *  Sum: '<S3078>/Sum'
         *  Sum: '<S3078>/Sum1'
         */
        VeESSR_n_StrtTypMaxStrtNiNoFuel_DS = ((KaESSR_n_StrtTypMaxStrtNiNoFuel
            [((sint32)rtb_Switch1_jm) - 1] - rtb_UnitDelay_gl) *
            VeESSR_k_AStrtNormalInterp) + rtb_UnitDelay_gl;

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim3' incorporates:
         *  Constant: '<S3010>/Constant Value3'
         *  Merge: '<S3009>/Merge12'
         *  SignalConversion generated from: '<S3010>/EngSnsdTorqAchvd'
         */
        VeESSR_M_StrtTypEngSnsdTorqAchvd_DS = 0.0F;

        /* DataStoreWrite: '<S17>/Dsw_UseECMTorqForStartEngInit' incorporates:
         *  Constant: '<S3010>/FALSE Constant5'
         *  Merge: '<S3009>/Merge1'
         *  SignalConversion generated from: '<S3010>/UseECMTorqForStartEngInit'
         */
        VeESSR_b_UseECMTorqForStartEngInit_DS = false;

        /* End of Outputs for SubSystem: '<S3009>/AStrtNormalInterp' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S3009>/NoInterp' incorporates:
         *  ActionPort: '<S3017>/Action Port'
         */
        /* DataStoreWrite: '<S17>/Dsw_NiProfGenT1Gain1' incorporates:
         *  Constant: '<S3125>/Calib'
         *  Merge: '<S3009>/Merge24'
         *  Selector: '<S3017>/Selector'
         */
        VeESSR_k_StrtTypFrstOrdLwPassT_DS = KaESSR_k_StrtTypFrstOrdLwPassT
            [((sint32)VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenT1Gain2' incorporates:
         *  Constant: '<S3127>/Calib'
         *  Merge: '<S3009>/Merge25'
         *  Selector: '<S3017>/Selector1'
         */
        VeESSR_k_StrtTypScndOrdLwPassT_DS = KaESSR_k_StrtTypScndOrdLwPassT
            [((sint32)VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim6' incorporates:
         *  Constant: '<S3131>/Calib'
         *  Merge: '<S3009>/Merge9'
         *  Selector: '<S3017>/Selector10'
         */
        VeESSR_phi_StrtTypInitSpinBrkAng_DS = KaESSR_phi_StrtTypInitSpinBrkAng
            [((sint32)VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim7' incorporates:
         *  Constant: '<S3126>/Calib'
         *  Merge: '<S3009>/Merge11'
         *  Selector: '<S3017>/Selector10'
         *  Selector: '<S3017>/Selector11'
         */
        VeESSR_k_StrtTypInitSpinScaler_DS = KaESSR_k_StrtTypInitSpinScaler
            [((sint32)VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim8' incorporates:
         *  Constant: '<S3112>/Calib'
         *  Merge: '<S3009>/Merge10'
         *  Selector: '<S3017>/Selector12'
         */
        VeESSR_Cnt_StrtTypInitSpinEndPnt_DS = KaESSR_Cnt_StrtTypInitSpinEndPnt
            [((sint32)VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim2' incorporates:
         *  Constant: '<S3133>/Calib'
         *  Merge: '<S3009>/Merge14'
         *  Selector: '<S3017>/Selector13'
         */
        VeESSR_t_StrtTypAirflowTrqMaxTm_DS = KaESSR_t_StrtTypAirflowTrqMaxTm
            [((sint32)VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim9' incorporates:
         *  Constant: '<S3114>/Calib'
         *  Merge: '<S3009>/Merge6'
         *  Selector: '<S3017>/Selector14'
         */
        VeESSR_M_StrtTypInitPredTorq_DS = KaESSR_M_StrtTypInitPredTorq[((sint32)
            VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim10' incorporates:
         *  Constant: '<S3113>/Calib'
         *  Merge: '<S3009>/Merge5'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector15'
         */
        VeESSR_M_StrtTypInitImmedTorq_DS = KaESSR_M_StrtTypInitImmedTorq
            [((sint32)VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim12' incorporates:
         *  Constant: '<S3123>/Calib'
         *  Merge: '<S3009>/Merge4'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector16'
         */
        VeESSR_k_StrtTypEngTorqReqFltT_DS = KaESSR_k_StrtTypEngTorqReqFltT
            [((sint32)VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim13' incorporates:
         *  Constant: '<S3124>/Calib'
         *  Merge: '<S3009>/Merge3'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector17'
         */
        VeESSR_k_StrtTypEngTorqReqImmedFltD_DS =
            KaESSR_k_StrtTypEngTorqReqImmedFltD[((sint32)
            VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_StrtTypMaxStrtNiNoFuel' incorporates:
         *  Constant: '<S3129>/Calib'
         *  Merge: '<S3009>/Merge17'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector18'
         */
        VeESSR_n_StrtTypMaxStrtNiNoFuel_DS = KaESSR_n_StrtTypMaxStrtNiNoFuel
            [((sint32)VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_StrtTypAStrtSpinUpExtSpd' incorporates:
         *  Constant: '<S3128>/Calib'
         *  Merge: '<S3009>/Merge7'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector19'
         */
        VeESSR_n_StrtTypAStrtSpinUpExtSpd_DS =
            KaESSR_n_StrtTypAStrtSpinUpExtSpd[((sint32)VeESSR_i_CalLoader_Local)
            - 1];

        /* Merge: '<S3009>/Merge18' incorporates:
         *  Constant: '<S3120>/Calib'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector2'
         */
        rtb_TmpSignalConversionAtVeAPSR = KaESSR_dn_StrtTypNiDotMax[((sint32)
            VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim16' incorporates:
         *  Constant: '<S3119>/Calib'
         *  Merge: '<S3009>/Merge22'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector20'
         */
        VeESSR_dn_StrtTypJerkMinStartEng_DS = KaESSR_dn_StrtTypJerkMinStartEng
            [((sint32)VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim15' incorporates:
         *  Constant: '<S3117>/Calib'
         *  Merge: '<S3009>/Merge15'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector21'
         */
        VeESSR_dn_StrtTypJerkMaxStartEng_DS = KaESSR_dn_StrtTypJerkMaxStartEng
            [((sint32)VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_StrtTypAStrtSpinUpManPrs' incorporates:
         *  Constant: '<S3130>/Calib'
         *  Merge: '<S3009>/Merge23'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector22'
         */
        VeESSR_p_StrtTypAStrtSpinUpManPrs_DS = KaESSR_p_StrtTypMaxManPrs
            [((sint32)VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_StrtTypAStrtSpinUpManPrs1' incorporates:
         *  Constant: '<S3135>/Calib'
         *  Merge: '<S3009>/Merge26'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector23'
         */
        VeESSR_t_StrtTypManPrsMaxTm_DS = KaESSR_t_StrtTypManPrsTm[((sint32)
            VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Data Store Write11' incorporates:
         *  Constant: '<S3134>/Calib'
         *  Merge: '<S3009>/Merge27'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector24'
         */
        ESSR_ac_DW.VeESSR_t_StrtTypGasFlwActrDlyTm =
            KaESSR_t_StrtTypGasFlwActrDlyTm[((sint32)VeESSR_i_CalLoader_Local) -
            1];

        /* DataStoreWrite: '<S17>/Data Store Write1' incorporates:
         *  Constant: '<S3136>/Calib'
         *  Merge: '<S3009>/Merge28'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector25'
         */
        ESSR_ac_DW.VeESSR_k_StrtTypNiPredFilter_DS =
            KaESSR_t_StrtTypNiPredFilter[((sint32)VeESSR_i_CalLoader_Local) - 1];

        /* Merge: '<S3009>/Merge19' incorporates:
         *  Constant: '<S3122>/Calib'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector3'
         */
        rtb_UnitDelay2 = KaESSR_dn_StrtTypNiDotMin[((sint32)
            VeESSR_i_CalLoader_Local) - 1];

        /* Merge: '<S3009>/Merge2' incorporates:
         *  Constant: '<S3121>/Calib'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector4'
         */
        rtb_Vector_di = KaESSR_dn_StrtTypNiDotMax_EngStrt[((sint32)
            VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim11' incorporates:
         *  Constant: '<S3116>/Calib'
         *  Merge: '<S3009>/Merge20'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector5'
         */
        VeESSR_dn_StrtTypJerkMax_DS = KaESSR_dn_StrtTypJerkMax[((sint32)
            VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim4' incorporates:
         *  Constant: '<S3137>/Calib'
         *  Merge: '<S3009>/Merge21'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector6'
         */
        VeESSR_t_StrtTypPhaserDelayTm_DS = KaESSR_t_StrtTypPhaserDelayTm
            [((sint32)VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_MinImmedExitTorqDelta' incorporates:
         *  Constant: '<S3115>/Calib'
         *  Merge: '<S3009>/Merge13'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector7'
         */
        VeESSR_M_MinImmedExitTorqDelta_DS =
            KaESSR_M_StrtTypMinImmedExitTorqDelta[((sint32)
            VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim1' incorporates:
         *  Constant: '<S3118>/Calib'
         *  Merge: '<S3009>/Merge16'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector8'
         */
        VeESSR_dn_StrtTypJerkMin_DS = KaESSR_dn_StrtTypJerkMin[((sint32)
            VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim5' incorporates:
         *  Constant: '<S3132>/Calib'
         *  Merge: '<S3009>/Merge8'
         *  Selector: '<S3017>/Selector14'
         *  Selector: '<S3017>/Selector9'
         */
        VeESSR_scl_StrtTypPulseCnclTorqScaler_DS =
            KaESSR_scl_StrtTypPulseCnclTorqScaler[((sint32)
            VeESSR_i_CalLoader_Local) - 1];

        /* DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim3' incorporates:
         *  Constant: '<S3017>/Constant Value3'
         *  Merge: '<S3009>/Merge12'
         *  SignalConversion generated from: '<S3017>/EngSnsdTorqAchvd'
         */
        VeESSR_M_StrtTypEngSnsdTorqAchvd_DS = 0.0F;

        /* DataStoreWrite: '<S17>/Dsw_UseECMTorqForStartEngInit' incorporates:
         *  Constant: '<S3017>/FALSE Constant5'
         *  Merge: '<S3009>/Merge1'
         *  SignalConversion generated from: '<S3017>/UseECMTorqForStartEngInit'
         */
        VeESSR_b_UseECMTorqForStartEngInit_DS = false;

        /* End of Outputs for SubSystem: '<S3009>/NoInterp' */
    }

    /* End of If: '<S3009>/If' */

    /* Switch: '<S3013>/Switch1' incorporates:
     *  Constant: '<S3012>/Constant'
     *  Constant: '<S3015>/Calib'
     *  DataStoreWrite: '<S17>/Dsw_EngStrtProfType'
     *  DataTypeConversion: '<S3009>/Data Type Conversion'
     *  Selector: '<S3009>/Selector4'
     */
    if (VeESSR_b_KeyType)
    {
        VeESSR_e_EngStrtProfType_DS = KaESSR_e_StrtTypeProfMap
            [(rtb_DataTypeConversion_tmp)];
    }
    else
    {
        VeESSR_e_EngStrtProfType_DS = CeESSR_e_AStrtAlgo;
    }

    /* End of Switch: '<S3013>/Switch1' */
    /* End of Outputs for SubSystem: '<S3004>/SelectNewCals' */
    /* End of Outputs for SubSystem: '<S2>/ESSC_StartProfileSelector' */
    (void)Rte_Read_VeHVTR_U_HV_Volt_Value(&rtb_MinMax5);

    /* Outputs for Function Call SubSystem: '<S2>/ESSC_StartProfileSelector' */
    /* Outputs for Atomic SubSystem: '<S3004>/SelectNewCals' */
    /* Selector: '<S3009>/Selector20' incorporates:
     *  Constant: '<S3014>/Calib'
     *  DataStoreWrite: '<S17>/Dsw_NiProfGenDNiDLim14'
     *  DataTypeConversion: '<S3009>/Data Type Conversion'
     *  Inport: '<Root>/VeHVTR_U_HV_Volt'
     */
    VeESSR_e_StrtStpTypEngTorqRespType_DS = KaESSR_e_StrtStpType_TrqRspTypMap
        [(rtb_DataTypeConversion_tmp)];

    /* If: '<S3018>/If' incorporates:
     *  DataStoreWrite: '<S17>/Dsw_KeyStrtEngModing'
     *  DataTypeConversion: '<S3009>/Data Type Conversion'
     */
    VeESSR_b_KeyStrtEngModing_DS = ((((sint32)rtb_DataTypeConversion_tmp) == 1) ||
        (((sint32)rtb_DataTypeConversion_tmp) == 2));

    /* End of Outputs for SubSystem: '<S3004>/SelectNewCals' */

    /* MinMax: '<S3006>/MinMax' incorporates:
     *  DataStoreWrite: '<S3006>/Dsw_NiProfGenNiDMax1'
     */
    VeESSR_dn_StrtTypNiDotMax_DS = fminf(VeESSR_dn_NiDotMax,
        rtb_TmpSignalConversionAtVeAPSR);

    /* MinMax: '<S3006>/MinMax3' incorporates:
     *  DataStoreWrite: '<S3006>/Dsw_StrtTypNiDotMax_EngStrt'
     *  Inport: '<Root>/VeHVTR_U_HV_Volt'
     *  Lookup_n-D: '<S3144>/Vector'
     */
    VeESSR_dn_StrtTypNiDotMax_EngStrt_DS = fminf(fminf(VeESSR_dn_NiDotMax,
        rtb_Vector_di), look1_iflf_binlcapw(rtb_MinMax5, ((const float32 *)
        &(KxESSR_dn_NiDotMax_EngStrt_VoltDep[0])), ((const float32 *)
        &(KtESSR_dn_NiDotMax_EngStrt_VoltDep[0])), 4U));

    /* MinMax: '<S3006>/MinMax1' incorporates:
     *  DataStoreWrite: '<S3006>/Dsw_NiProfGenNiDMin1'
     */
    VeESSR_dn_StrtTypNiDotMin_DS = fmaxf(rtb_UnitDelay2, VeESSR_dn_NiDotMin);

    /* End of Outputs for SubSystem: '<S2>/ESSC_StartProfileSelector' */

    /* Outputs for Function Call SubSystem: '<S2>/NiDot_TiEst_limits' */

    /* SignalConversion generated from: '<S21>/VaTSXR_r_HSERNidotConstrn' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S21>/VaTSXR_r_HSERNidotConstrn' incorporates:
     *  Inport: '<Root>/VaTSXR_r_HSERNidotConstrn'
     */
    (void)Rte_Read_VaTSXR_r_HSERNidotConstrn_Value(rtb_LaESSI_r_HSERNidotConstrn);

#elif !Rte_SysCon_Variant_ESSR_Func || !Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S21>/VaTSXR_r_HSERNidotConstrn' incorporates:
     *  SignalConversion generated from: '<S21>/VaTSXR_r_HSERNidotConstrn'
     */
    memset(&rtb_LaESSI_r_HSERNidotConstrn[0], 0, 114U * (sizeof(float32)));

#endif

    /* End of SignalConversion generated from: '<S21>/VaTSXR_r_HSERNidotConstrn' */

    /* Selector: '<S3222>/Selector1' incorporates:
     *  Constant: '<S3231>/Calib'
     *  Switch: '<S3222>/Switch'
     */
#if Rte_SysCon_Variant_ESSR_P1P2Func

    /* Selector: '<S3222>/Selector1' incorporates:
     *  Constant: '<S3236>/Calib'
     *  VariantMerge generated from: '<S21>/VaTSXR_r_HSERNidotConstrn'
     */
    for (VeESSR_k_StrtTypFrstOrdLwPassT_ = 0; VeESSR_k_StrtTypFrstOrdLwPassT_ <
            19; VeESSR_k_StrtTypFrstOrdLwPassT_++)
    {
        rtb_Selector1[VeESSR_k_StrtTypFrstOrdLwPassT_] =
            rtb_LaESSI_r_HSERNidotConstrn[((6 * VeESSR_k_StrtTypFrstOrdLwPassT_)
            + ((sint32)KeESSR_k_NidotCalcConstrnIdx)) - 1];
    }

    if (KeESSR_b_NidotCalc_TiEnbl)
    {
        /* Switch: '<S3222>/Switch' incorporates:
         *  Constant: '<S3227>/Calib'
         */
        rtb_Switch_fwy = KeESSR_M_NidotCalc_TiOvrrd;
    }
    else
    {
        /* Switch: '<S3222>/Switch' incorporates:
         *  DataStoreRead: '<S21>/Dsr_InputTorqOverride1'
         */
        rtb_Switch_fwy = VeESSR_M_EngTorqEst_DS;
    }

#endif

    /* End of Selector: '<S3222>/Selector1' */

    /* SignalConversion generated from: '<S21>/VeATRR_M_OutputTorqReqImmed' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

    /* Switch: '<S3222>/Switch1' */
    rtb_Switch1_ca = rtb_TmpSignalConversionAtVeATRR;

#elif !Rte_SysCon_Variant_ESSR_Func || !Rte_SysCon_Variant_ESSR_P1P2Func

    /* Switch: '<S3222>/Switch1' incorporates:
     *  SignalConversion generated from: '<S21>/VeATRR_M_OutputTorqReqImmed'
     */
    rtb_Switch1_ca = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S21>/VeATRR_M_OutputTorqReqImmed' */

    /* Switch: '<S3222>/Switch1' incorporates:
     *  Constant: '<S3232>/Calib'
     */
#if Rte_SysCon_Variant_ESSR_P1P2Func

    if (KeESSR_b_NidotCalc_ToEnbl)
    {
        /* Switch: '<S3222>/Switch1' incorporates:
         *  Constant: '<S3228>/Calib'
         */
        rtb_Switch1_ca = KeESSR_M_NidotCalc_ToOvrrd;
    }

#endif

    /* End of Switch: '<S3222>/Switch1' */

    /* SignalConversion generated from: '<S21>/VeHSER_M_Clch2_TorqEst' incorporates:
     *  SignalConversion generated from: '<S21>/VeESSR_n_TransInSpdFlt'
     * */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S21>/VeHSER_M_Clch2_TorqEst' incorporates:
     *  Inport: '<Root>/VeHSER_M_Clch2_TorqEst'
     */
    (void)Rte_Read_VeHSER_M_Clch2_TorqEst_Value(&rtb_LeESSI_n_InputSpeedProfile);

    /* VariantMerge generated from: '<S21>/VeESSR_n_TransInSpdFlt' */
    rtb_VeESSR_n_TransInSpdFlt = VeESSR_n_TransInSpdFlt;

#elif !Rte_SysCon_Variant_ESSR_Func || !Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S21>/VeHSER_M_Clch2_TorqEst' incorporates:
     *  SignalConversion generated from: '<S21>/VeHSER_M_Clch2_TorqEst'
     */
    rtb_LeESSI_n_InputSpeedProfile = 0.0F;

    /* VariantMerge generated from: '<S21>/VeESSR_n_TransInSpdFlt' incorporates:
     *  SignalConversion generated from: '<S21>/VeESSR_n_TransInSpdFlt'
     */
    rtb_VeESSR_n_TransInSpdFlt = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S21>/VeHSER_M_Clch2_TorqEst' */

    /* Switch: '<S3222>/Switch2' incorporates:
     *  Constant: '<S3222>/Nc1'
     *  Constant: '<S3222>/Nc1dot'
     *  Constant: '<S3222>/Nidot'
     *  Constant: '<S3222>/Ta'
     *  Constant: '<S3222>/Tb'
     *  Constant: '<S3222>/Tc'
     *  Constant: '<S3222>/Tc1'
     *  Constant: '<S3222>/Tc3'
     *  Constant: '<S3222>/Tc4'
     *  Constant: '<S3222>/Timp'
     *  Constant: '<S3222>/Tlf'
     *  Constant: '<S3222>/Tof'
     *  Constant: '<S3222>/Tor'
     *  Constant: '<S3229>/Calib'
     *  Constant: '<S3230>/Calib'
     *  Constant: '<S3235>/Calib'
     *  Constant: '<S3237>/Calib'
     *  Product: '<S3222>/Product'
     *  Selector: '<S3222>/Selector1'
     *  SignalConversion generated from: '<S3222>/Product'
     *  Switch: '<S3222>/Switch3'
     */
#if Rte_SysCon_Variant_ESSR_P1P2Func

    /* Outputs for Atomic SubSystem: '<S3222>/Limiter' */
    tmp[0] = 0.0F;
    tmp[1] = 0.0F;
    tmp[2] = 0.0F;
    tmp[3] = rtb_Switch_fwy;
    tmp[4] = rtb_Switch1_ca;
    tmp[5] = 0.0F;
    tmp[6] = 0.0F;
    tmp[7] = 0.0F;
    tmp[8] = 0.0F;
    tmp[9] = 0.0F;
    tmp[10] = rtb_LeESSI_n_InputSpeedProfile;
    tmp[11] = 0.0F;
    tmp[12] = 0.0F;
    tmp[13] = rtb_VeESSR_n_TransInSpdFlt;
    tmp[14] = 0.0F;
    if (KeESSR_b_NidotCalc_NoEnbl)
    {
        tmp[15] = KeESSR_n_NidotCalc_NoOvrrd;
    }
    else
    {
        tmp[15] = ESSR_ac_B.TmpSignalConversionAtVeVSDR_n_P;
    }

    if (KeESSR_b_NidotCalc_NodotEnbl)
    {
        tmp[16] = KeESSR_dn_NidotCalc_NodotOvrrd;
    }
    else
    {
        tmp[16] = rtb_TmpSignalConversionAtVeVSDR;
    }

    tmp[17] = 0.0F;
    tmp[18] = 0.0F;
    rtb_TmpSignalConversionAtVeATRR = 0.0F;
    for (VeESSR_k_StrtTypFrstOrdLwPassT_ = 0; VeESSR_k_StrtTypFrstOrdLwPassT_ <
            19; VeESSR_k_StrtTypFrstOrdLwPassT_++)
    {
        rtb_TmpSignalConversionAtVeATRR +=
            rtb_Selector1[VeESSR_k_StrtTypFrstOrdLwPassT_] *
            tmp[VeESSR_k_StrtTypFrstOrdLwPassT_];
    }

    /* Switch: '<S3238>/Switch1' incorporates:
     *  Constant: '<S3222>/Nc1'
     *  Constant: '<S3222>/Nc1dot'
     *  Constant: '<S3222>/Nidot'
     *  Constant: '<S3222>/Ta'
     *  Constant: '<S3222>/Tb'
     *  Constant: '<S3222>/Tc'
     *  Constant: '<S3222>/Tc1'
     *  Constant: '<S3222>/Tc3'
     *  Constant: '<S3222>/Tc4'
     *  Constant: '<S3222>/Timp'
     *  Constant: '<S3222>/Tlf'
     *  Constant: '<S3222>/Tof'
     *  Constant: '<S3222>/Tor'
     *  Constant: '<S3229>/Calib'
     *  Constant: '<S3230>/Calib'
     *  Constant: '<S3233>/Calib'
     *  Constant: '<S3235>/Calib'
     *  Constant: '<S3237>/Calib'
     *  RelationalOperator: '<S3238>/Relational Operator'
     *  Selector: '<S3222>/Selector1'
     */
    if (KeESSR_dn_MaxNidotCalc < rtb_TmpSignalConversionAtVeATRR)
    {
        /* Switch: '<S3238>/Switch1' */
        rtb_TmpSignalConversionAtVeATRR = KeESSR_dn_MaxNidotCalc;
    }

    /* End of Switch: '<S3238>/Switch1' */

    /* Switch: '<S3238>/Switch' incorporates:
     *  Constant: '<S3234>/Calib'
     *  RelationalOperator: '<S3238>/Relational Operator1'
     */
    if (rtb_TmpSignalConversionAtVeATRR > KeESSR_dn_MinNidotCalc)
    {
        /* Switch: '<S3238>/Switch' */
        VeESSR_dn_DtrmnNidot = rtb_TmpSignalConversionAtVeATRR;
    }
    else
    {
        /* Switch: '<S3238>/Switch' */
        VeESSR_dn_DtrmnNidot = KeESSR_dn_MinNidotCalc;
    }

    /* End of Switch: '<S3238>/Switch' */
    /* End of Outputs for SubSystem: '<S3222>/Limiter' */
#endif

    /* End of Switch: '<S3222>/Switch2' */

    /* If: '<S21>/If' incorporates:
     *  Constant: '<S3225>/Constant'
     *  Constant: '<S3226>/Constant'
     *  DataStoreRead: '<S21>/Data Store Read'
     *  Inport: '<Root>/VeHTDR_M_TiMin'
     *  Logic: '<S21>/Logical1'
     *  RelationalOperator: '<S21>/Relational Operator'
     *  RelationalOperator: '<S21>/Relational Operator1'
     */
    if ((CeESSR_e_EMStrtAlgo == ((uint32)VeESSR_e_EngStrtProfType_DS)) ||
            (((uint32)VeESSR_e_EngStrtProfType_DS) == CeESSR_e_EMLwPwrStrtAlgo))
    {
        /* Outputs for IfAction SubSystem: '<S21>/ESSC_DtrmnTiMinMaxEM' incorporates:
         *  ActionPort: '<S3224>/Action Port'
         */
        /* SignalConversion generated from: '<S3224>/Product' incorporates:
         *  Constant: '<S3224>/Nx'
         *  Constant: '<S3224>/NxD'
         *  Constant: '<S3224>/TC1'
         *  Constant: '<S3224>/TC2'
         *  Constant: '<S3224>/TC3'
         *  Constant: '<S3224>/TC4'
         *  Constant: '<S3224>/Ta'
         *  Constant: '<S3224>/Tb'
         *  Constant: '<S3224>/Tc'
         *  Constant: '<S3224>/Ti'
         *  Constant: '<S3224>/Timp'
         *  Constant: '<S3224>/Tlf'
         *  Constant: '<S3224>/To'
         *  Constant: '<S3224>/Tof'
         *  Constant: '<S3224>/Tor'
         *  DataStoreRead: '<S3224>/Dsr_InputAcceltnProf'
         */
        tmp[0] = 0.0F;
        tmp[1] = 0.0F;
        tmp[2] = 0.0F;
        tmp[3] = 0.0F;
        tmp[4] = 0.0F;
        tmp[5] = 0.0F;
        tmp[6] = 0.0F;
        tmp[7] = 0.0F;
        tmp[8] = 0.0F;
        tmp[9] = 0.0F;
        tmp[10] = 0.0F;
        tmp[11] = 0.0F;
        tmp[12] = 0.0F;
        tmp[13] = ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I;
        tmp[14] = VeESSR_dn_InputAcceltnProf_DS;
        tmp[15] = ESSR_ac_B.TmpSignalConversionAtVeVSDR_n_P;
        tmp[16] = rtb_TmpSignalConversionAtVeVSDR;
        tmp[17] = 0.0F;
        tmp[18] = 0.0F;

        /* Product: '<S3224>/Product' incorporates:
         *  Selector: '<S3224>/Selector3'
         *  SignalConversion generated from: '<S2>/VaTSXR_r_HTDRTacTiConstrn'
         */
        rtb_TmpSignalConversionAtVeATRR = 0.0F;
        for (VeESSR_k_StrtTypFrstOrdLwPassT_ = 0;
                VeESSR_k_StrtTypFrstOrdLwPassT_ < 19;
                VeESSR_k_StrtTypFrstOrdLwPassT_++)
        {
            rtb_TmpSignalConversionAtVeATRR += rtb_TmpSignalConversionAtVaTSXR
                [(6 * VeESSR_k_StrtTypFrstOrdLwPassT_) + 1] *
                tmp[VeESSR_k_StrtTypFrstOrdLwPassT_];
        }

        /* If: '<S3243>/If' incorporates:
         *  Abs: '<S3243>/Abs1'
         *  Constant: '<S3241>/Calib'
         *  Constant: '<S3256>/Calib'
         *  Inport: '<Root>/VeTCPR_M_Clch1_TorqEstMax'
         *  Inport: '<Root>/VeTCPR_M_Clch1_TorqEstMin'
         *  RelationalOperator: '<S3243>/Greater Than or Equal '
         */
        if (fabsf((float32)Rte_Prm_KeTSXR_r_P2p5_KeTSXR_r_P2p5()) >= ((float32)
                Rte_Prm_KeOPTR_k_NonZeroCoeffThrshld_Pos_KeOPTR_k_NonZeroCoeffThrshld_Pos
                ()))
        {
            (void)Rte_Read_VeTCPR_M_Clch1_TorqEstMin_Value(&rtb_Product1_j3);

            /* Outputs for IfAction SubSystem: '<S3243>/KNEQ0' incorporates:
             *  ActionPort: '<S3255>/Action Port'
             */
            /* Sum: '<S3255>/Sum6' incorporates:
             *  Inport: '<Root>/VeTCPR_M_Clch1_TorqEstMin'
             *  Product: '<S3224>/Product'
             */
            rtb_Product1_j3 -= rtb_TmpSignalConversionAtVeATRR;

            /* Outputs for Atomic SubSystem: '<S3255>/Protected Division' */
            /* Switch: '<S3260>/Switch1' incorporates:
             *  Constant: '<S3260>/Constant Value'
             *  Constant: '<S3260>/Constant Value1'
             *  Constant: '<S3260>/Constant Value2'
             *  Constant: '<S3260>/Constant Value3'
             *  Logic: '<S3260>/AND'
             *  RelationalOperator: '<S3260>/Greater Than or Equal '
             *  RelationalOperator: '<S3260>/Greater Than or Equal 1'
             *  RelationalOperator: '<S3260>/Not Equal'
             *  RelationalOperator: '<S3260>/Not Equal1'
             *  Switch: '<S3260>/Switch2'
             *  Switch: '<S3260>/Switch3'
             */
            if ((rtb_Product1_j3 != 0.0F) && (((float32)
                    Rte_Prm_KeTSXR_r_P2p5_KeTSXR_r_P2p5()) != 0.0F))
            {
                /* Switch: '<S3260>/Switch1' incorporates:
                 *  Product: '<S3260>/Division'
                 */
                rtb_Product1_j3 /= (float32)Rte_Prm_KeTSXR_r_P2p5_KeTSXR_r_P2p5();
            }
            else if (rtb_Product1_j3 > 0.0F)
            {
                /* Switch: '<S3260>/Switch2' incorporates:
                 *  Constant: '<S3260>/MAXFLOAT'
                 *  Switch: '<S3260>/Switch1'
                 */
                rtb_Product1_j3 = 3.402823466E+38F;
            }
            else if (rtb_Product1_j3 < 0.0F)
            {
                /* Switch: '<S3260>/Switch3' incorporates:
                 *  Constant: '<S3260>/MINFLOAT'
                 *  Switch: '<S3260>/Switch1'
                 *  Switch: '<S3260>/Switch2'
                 */
                rtb_Product1_j3 = -3.402823466E+38F;
            }
            else
            {
                /* Switch: '<S3260>/Switch1' incorporates:
                 *  Constant: '<S3260>/Constant Value4'
                 *  Switch: '<S3260>/Switch2'
                 *  Switch: '<S3260>/Switch3'
                 */
                rtb_Product1_j3 = 0.0F;
            }

            /* End of Switch: '<S3260>/Switch1' */
            /* End of Outputs for SubSystem: '<S3255>/Protected Division' */
            /* End of Outputs for SubSystem: '<S3243>/KNEQ0' */
            (void)Rte_Read_VeTCPR_M_Clch1_TorqEstMax_Value(&rtb_Merge_k5);

            /* Outputs for IfAction SubSystem: '<S3243>/KNEQ0' incorporates:
             *  ActionPort: '<S3255>/Action Port'
             */
            /* Sum: '<S3255>/Sum1' incorporates:
             *  Inport: '<Root>/VeTCPR_M_Clch1_TorqEstMax'
             *  Product: '<S3224>/Product'
             */
            rtb_Merge_k5 -= rtb_TmpSignalConversionAtVeATRR;

            /* Outputs for Atomic SubSystem: '<S3255>/Protected Division1' */
            /* Switch: '<S3261>/Switch1' incorporates:
             *  Constant: '<S3261>/Constant Value'
             *  Constant: '<S3261>/Constant Value1'
             *  Constant: '<S3261>/Constant Value2'
             *  Constant: '<S3261>/Constant Value3'
             *  Logic: '<S3261>/AND'
             *  RelationalOperator: '<S3261>/Greater Than or Equal '
             *  RelationalOperator: '<S3261>/Greater Than or Equal 1'
             *  RelationalOperator: '<S3261>/Not Equal'
             *  RelationalOperator: '<S3261>/Not Equal1'
             *  Switch: '<S3261>/Switch2'
             *  Switch: '<S3261>/Switch3'
             */
            if ((rtb_Merge_k5 != 0.0F) && (((float32)
                    Rte_Prm_KeTSXR_r_P2p5_KeTSXR_r_P2p5()) != 0.0F))
            {
                /* Switch: '<S3261>/Switch1' incorporates:
                 *  Product: '<S3261>/Division'
                 */
                rtb_TmpSignalConversionAtVeATRR = rtb_Merge_k5 / ((float32)
                    Rte_Prm_KeTSXR_r_P2p5_KeTSXR_r_P2p5());
            }
            else if (rtb_Merge_k5 > 0.0F)
            {
                /* Switch: '<S3261>/Switch2' incorporates:
                 *  Constant: '<S3261>/MAXFLOAT'
                 *  Switch: '<S3261>/Switch1'
                 */
                rtb_TmpSignalConversionAtVeATRR = 3.402823466E+38F;
            }
            else if (rtb_Merge_k5 < 0.0F)
            {
                /* Switch: '<S3261>/Switch3' incorporates:
                 *  Constant: '<S3261>/MINFLOAT'
                 *  Switch: '<S3261>/Switch1'
                 *  Switch: '<S3261>/Switch2'
                 */
                rtb_TmpSignalConversionAtVeATRR = -3.402823466E+38F;
            }
            else
            {
                /* Switch: '<S3261>/Switch1' incorporates:
                 *  Constant: '<S3261>/Constant Value4'
                 *  Switch: '<S3261>/Switch2'
                 *  Switch: '<S3261>/Switch3'
                 */
                rtb_TmpSignalConversionAtVeATRR = 0.0F;
            }

            /* End of Switch: '<S3261>/Switch1' */
            /* End of Outputs for SubSystem: '<S3255>/Protected Division1' */

            /* Merge: '<S3243>/Merge' incorporates:
             *  MinMax: '<S3255>/MinMax'
             */
            rtb_Merge_k5 = fminf(rtb_Product1_j3,
                                 rtb_TmpSignalConversionAtVeATRR);

            /* Product: '<S3224>/Product1' incorporates:
             *  MinMax: '<S3255>/MinMax1'
             */
            rtb_Product1_j3 = fmaxf(rtb_Product1_j3,
                                    rtb_TmpSignalConversionAtVeATRR);

            /* End of Outputs for SubSystem: '<S3243>/KNEQ0' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S3243>/KEQ0' incorporates:
             *  ActionPort: '<S3254>/Action Port'
             */
            /* Merge: '<S3243>/Merge' incorporates:
             *  Constant: '<S3259>/Calib'
             *  SignalConversion generated from: '<S3254>/Tm_min'
             */
            rtb_Merge_k5 =
                Rte_Prm_KeOPTR_M_ExtremeMinTorque_KeOPTR_M_ExtremeMinTorque();

            /* Product: '<S3224>/Product1' incorporates:
             *  Constant: '<S3258>/Calib'
             *  SignalConversion generated from: '<S3254>/Tm_max'
             */
            rtb_Product1_j3 =
                Rte_Prm_KeOPTR_M_ExtremeMaxTorque_KeOPTR_M_ExtremeMaxTorque();

            /* End of Outputs for SubSystem: '<S3243>/KEQ0' */
        }

        /* End of If: '<S3243>/If' */

        /* MinMax: '<S3242>/MinMax4' */
        rtb_TmpSignalConversionAtVeATRR = fmaxf(rtb_TmpSignalConversionAtVeHS_j,
            rtb_Merge_k5);

        /* MinMax: '<S3242>/MinMax5' */
        rtb_MinMax5 = fminf(rtb_TmpSignalConversionAtVeHSER, rtb_Product1_j3);

        /* If: '<S3242>/If1' */
        if (rtb_TmpSignalConversionAtVeATRR > rtb_MinMax5)
        {
            /* Outputs for IfAction SubSystem: '<S3242>/NoIntersection' incorporates:
             *  ActionPort: '<S3245>/Action Port'
             */
            /* If: '<S3245>/If' */
            if (rtb_TmpSignalConversionAtVeHS_j > rtb_Merge_k5)
            {
                /* Outputs for IfAction SubSystem: '<S3245>/TkFrstPtMin' incorporates:
                 *  ActionPort: '<S3251>/Action Port'
                 */
                ESSR_ac_TkFrstPtMin(rtb_TmpSignalConversionAtVeHS_j,
                                    &rtb_Merge_k5);

                /* End of Outputs for SubSystem: '<S3245>/TkFrstPtMin' */
            }
            else
            {
                /* Outputs for IfAction SubSystem: '<S3245>/TkFirstPtMax' incorporates:
                 *  ActionPort: '<S3250>/Action Port'
                 */
                ESSR_ac_TkFrstPtMin(rtb_TmpSignalConversionAtVeHSER,
                                    &rtb_Merge_k5);

                /* End of Outputs for SubSystem: '<S3245>/TkFirstPtMax' */
            }

            /* End of If: '<S3245>/If' */

            /* SignalConversion generated from: '<S3224>/Product1' incorporates:
             *  Gain: '<S3248>/Gain'
             *  Product: '<S3224>/Product1'
             */
            tmp_0[1] = rtb_Merge_k5;

            /* End of Outputs for SubSystem: '<S3242>/NoIntersection' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S3242>/Intersection' incorporates:
             *  ActionPort: '<S3244>/Action Port'
             */
            /* SignalConversion generated from: '<S3224>/Product1' incorporates:
             *  Gain: '<S3246>/Gain'
             *  Product: '<S3224>/Product1'
             */
            tmp_0[1] = rtb_TmpSignalConversionAtVeATRR;

            /* Product: '<S3224>/Product2' incorporates:
             *  Gain: '<S3247>/Gain'
             */
            rtb_Merge_k5 = rtb_MinMax5;

            /* End of Outputs for SubSystem: '<S3242>/Intersection' */
        }

        /* End of If: '<S3242>/If1' */

        /* SignalConversion generated from: '<S3224>/Product1' incorporates:
         *  Constant: '<S3224>/Nx1'
         *  Constant: '<S3224>/NxD1'
         *  Constant: '<S3224>/TC1_TiMin'
         *  Constant: '<S3224>/TC2_TiMin'
         *  Constant: '<S3224>/TC3_TiMin'
         *  Constant: '<S3224>/TC4_TiMin'
         *  Constant: '<S3224>/Ta1'
         *  Constant: '<S3224>/Tc1'
         *  Constant: '<S3224>/Ti1'
         *  Constant: '<S3224>/Timp1'
         *  Constant: '<S3224>/Tlf1'
         *  Constant: '<S3224>/To1'
         *  Constant: '<S3224>/Tof1'
         *  Constant: '<S3224>/Tor1'
         *  DataStoreRead: '<S3224>/Dsr_InputAcceltnProf'
         */
        tmp_0[0] = 0.0F;
        tmp_0[2] = 0.0F;
        tmp_0[3] = 0.0F;
        tmp_0[4] = 0.0F;
        tmp_0[5] = 0.0F;
        tmp_0[6] = 0.0F;
        tmp_0[7] = 0.0F;
        tmp_0[8] = 0.0F;
        tmp_0[9] = 0.0F;
        tmp_0[10] = 0.0F;
        tmp_0[11] = 0.0F;
        tmp_0[12] = 0.0F;
        tmp_0[13] = ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I;
        tmp_0[14] = VeESSR_dn_InputAcceltnProf_DS;
        tmp_0[15] = ESSR_ac_B.TmpSignalConversionAtVeVSDR_n_P;
        tmp_0[16] = rtb_TmpSignalConversionAtVeVSDR;
        tmp_0[17] = 0.0F;
        tmp_0[18] = 0.0F;

        /* Product: '<S3224>/Product1' */
        rtb_TmpSignalConversionAtVeATRR = 0.0F;

        /* SignalConversion generated from: '<S3224>/Product2' incorporates:
         *  Constant: '<S3224>/Nx2'
         *  Constant: '<S3224>/NxD2'
         *  Constant: '<S3224>/TC1_01'
         *  Constant: '<S3224>/TC2_02'
         *  Constant: '<S3224>/TC3_03'
         *  Constant: '<S3224>/TC4_04'
         *  Constant: '<S3224>/Ta2'
         *  Constant: '<S3224>/Tc2'
         *  Constant: '<S3224>/Ti2'
         *  Constant: '<S3224>/Timp2'
         *  Constant: '<S3224>/Tlf2'
         *  Constant: '<S3224>/To2'
         *  Constant: '<S3224>/Tof2'
         *  Constant: '<S3224>/Tor2'
         *  DataStoreRead: '<S3224>/Dsr_InputAcceltnProf'
         */
        tmp[0] = 0.0F;
        tmp[1] = rtb_Merge_k5;
        tmp[2] = 0.0F;
        tmp[3] = 0.0F;
        tmp[4] = 0.0F;
        tmp[5] = 0.0F;
        tmp[6] = 0.0F;
        tmp[7] = 0.0F;
        tmp[8] = 0.0F;
        tmp[9] = 0.0F;
        tmp[10] = 0.0F;
        tmp[11] = 0.0F;
        tmp[12] = 0.0F;
        tmp[13] = ESSR_ac_B.TmpSignalConversionAtVeTISR_n_I;
        tmp[14] = VeESSR_dn_InputAcceltnProf_DS;
        tmp[15] = ESSR_ac_B.TmpSignalConversionAtVeVSDR_n_P;
        tmp[16] = rtb_TmpSignalConversionAtVeVSDR;
        tmp[17] = 0.0F;
        tmp[18] = 0.0F;

        /* Product: '<S3224>/Product2' */
        rtb_TmpSignalConversionAtVeVSDR = 0.0F;
        for (VeESSR_k_StrtTypFrstOrdLwPassT_ = 0;
                VeESSR_k_StrtTypFrstOrdLwPassT_ < 19;
                VeESSR_k_StrtTypFrstOrdLwPassT_++)
        {
            /* Product: '<S3224>/Product1' incorporates:
             *  Product: '<S3224>/Product2'
             *  Selector: '<S3224>/Selector1'
             *  Selector: '<S3224>/Selector2'
             *  SignalConversion generated from: '<S2>/VaTSXR_r_HTDRTacTiConstrn'
             */
            rtb_Product1_j3 = rtb_TmpSignalConversionAtVaTSXR[6 *
                VeESSR_k_StrtTypFrstOrdLwPassT_];
            rtb_TmpSignalConversionAtVeATRR += rtb_Product1_j3 *
                tmp_0[VeESSR_k_StrtTypFrstOrdLwPassT_];

            /* Product: '<S3224>/Product2' incorporates:
             *  Selector: '<S3224>/Selector2'
             */
            rtb_TmpSignalConversionAtVeVSDR += rtb_Product1_j3 *
                tmp[VeESSR_k_StrtTypFrstOrdLwPassT_];
        }

        /* Merge: '<S21>/Merge' incorporates:
         *  MinMax: '<S3224>/MinMax'
         *  Product: '<S3224>/Product1'
         *  Product: '<S3224>/Product2'
         */
        VeESSR_M_TiEstMin = fminf(rtb_TmpSignalConversionAtVeATRR,
            rtb_TmpSignalConversionAtVeVSDR);

        /* End of Outputs for SubSystem: '<S21>/ESSC_DtrmnTiMinMaxEM' */
    }
    else
    {
        (void)Rte_Read_VeHTDR_M_TiMin_Value(&rtb_Product1_j3);

        /* Outputs for IfAction SubSystem: '<S21>/ESSC_DtrmnTiMinMaxAutoStarts' incorporates:
         *  ActionPort: '<S3223>/Action Port'
         */
        /* Switch: '<S3223>/Switch' incorporates:
         *  Constant: '<S3240>/Calib'
         *  Inport: '<Root>/VeHTDR_M_TiMin'
         */
        if (KeESSR_b_TiEstMinLimEna)
        {
            /* Merge: '<S21>/Merge' incorporates:
             *  Constant: '<S3239>/Calib'
             */
            VeESSR_M_TiEstMin = KeESSR_M_TiEstMinLimVal;
        }
        else
        {
            /* Merge: '<S21>/Merge' */
            VeESSR_M_TiEstMin = rtb_Product1_j3;
        }

        /* End of Switch: '<S3223>/Switch' */
        /* End of Outputs for SubSystem: '<S21>/ESSC_DtrmnTiMinMaxAutoStarts' */
    }

    /* End of If: '<S21>/If' */

    /* SignalConversion generated from: '<S21>/Variant Source' */
#if !Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S21>/Variant Source' incorporates:
     *  Constant: '<S21>/Constant Value'
     */
    ESSR_ac_B.VariantMerge_For_Variant_Source = 0.0F;

#else

    /* VariantMerge generated from: '<S21>/Variant Source' incorporates:
     *  SignalConversion generated from: '<S21>/Variant Source'
     */
    ESSR_ac_B.VariantMerge_For_Variant_Source = VeESSR_dn_DtrmnNidot;

#endif

    /* End of SignalConversion generated from: '<S21>/Variant Source' */

    /* End of Outputs for SubSystem: '<S2>/NiDot_TiEst_limits' */

    /* Outputs for Function Call SubSystem: '<S2>/ESSC_EngStartStopCtrl' */

    /* SignalConversion generated from: '<S13>/MSPR' */
#if (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func) || (Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func)

    /* VariantMerge generated from: '<S13>/MSPR' incorporates:
     *  Inport: '<Root>/VeMSPR_n_MtrB_Spd'
     */
    (void)Rte_Read_VeMSPR_n_MtrB_Spd_Value(&rtb_LeESSI_n_MtrB_Spd);

#elif !Rte_SysCon_Variant_ESSR_Func || (!Rte_SysCon_Variant_ESSR_P1P2Func && !Rte_SysCon_Variant_ESSR_P1P2p5Func)

    /* VariantMerge generated from: '<S13>/MSPR' incorporates:
     *  SignalConversion generated from: '<S13>/MSPR'
     */
    rtb_LeESSI_n_MtrB_Spd = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S13>/MSPR' */

    /* SignalConversion generated from: '<S13>/MTQR' incorporates:
     *  SignalConversion generated from: '<S13>/TINR'
     */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S13>/MTQR' incorporates:
     *  Inport: '<Root>/VeMTQR_M_MtrA_MaxTorq_ST'
     */
    (void)Rte_Read_VeMTQR_M_MtrA_MaxTorq_ST_Value
        (&ESSR_ac_B.LeESSI_M_MtrA_MaxTorq);

    /* VariantMerge generated from: '<S13>/MTQR' incorporates:
     *  Inport: '<Root>/VeMTQR_M_MtrA_MinTorq_ST'
     */
    (void)Rte_Read_VeMTQR_M_MtrA_MinTorq_ST_Value
        (&ESSR_ac_B.LeESSI_M_MtrA_MinTorq);

    /* VariantMerge generated from: '<S13>/TINR' incorporates:
     *  Inport: '<Root>/VeTINR_d_TCMFailures'
     */
    (void)Rte_Read_VeTINR_d_TCMFailures_Value(&ESSR_ac_B.LeESSI_d_TCMFailures);

#elif !Rte_SysCon_Variant_ESSR_Func || !Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S13>/MTQR' incorporates:
     *  SignalConversion generated from: '<S13>/MTQR'
     */
    ESSR_ac_B.LeESSI_M_MtrA_MaxTorq = 0.0F;

    /* VariantMerge generated from: '<S13>/MTQR' incorporates:
     *  SignalConversion generated from: '<S13>/MTQR'
     */
    ESSR_ac_B.LeESSI_M_MtrA_MinTorq = 0.0F;

#endif

    /* End of SignalConversion generated from: '<S13>/MTQR' */

    /* SignalConversion generated from: '<S13>/TRGR' incorporates:
     *  SignalConversion generated from: '<S13>/TINR'
     */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S13>/TRGR' incorporates:
     *  Inport: '<Root>/VeTRGR_e_VldtdTransRngSt'
     */
    (void)Rte_Read_VeTRGR_e_VldtdTransRngSt_Value
        (&ESSR_ac_B.LeESSI_e_VldtdTransRngSt);

#elif !Rte_SysCon_Variant_ESSR_Func || !Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S13>/TINR' incorporates:
     *  SignalConversion generated from: '<S13>/TINR'
     */
    ESSR_ac_B.LeESSI_d_TCMFailures = 0U;

    /* VariantMerge generated from: '<S13>/TRGR' incorporates:
     *  SignalConversion generated from: '<S13>/TRGR'
     */
    ESSR_ac_B.LeESSI_e_VldtdTransRngSt = CeTRGR_e_NoSelectionAvailable;

#endif

    /* End of SignalConversion generated from: '<S13>/TRGR' */

    /* SignalConversion generated from: '<S13>/ClthErlyExitLmp' incorporates:
     *  SignalConversion generated from: '<S13>/ClthLwrThresLmp'
     */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* VariantMerge generated from: '<S13>/ClthErlyExitLmp' */
    VeESSR_b_ClthErlyExitLmp = ESSR_ac_B.VariantMergeForOutportVeESSR_b_;

    /* VariantMerge generated from: '<S13>/ClthLwrThresLmp' */
    VeESSR_b_ClthLwrThresLmp = ESSR_ac_B.VariantMergeForOutportVeESSR__o;

#elif !Rte_SysCon_Variant_ESSR_Func || !Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* VariantMerge generated from: '<S13>/ClthErlyExitLmp' incorporates:
     *  SignalConversion generated from: '<S13>/ClthErlyExitLmp'
     */
    VeESSR_b_ClthErlyExitLmp = false;

#endif

    /* End of SignalConversion generated from: '<S13>/ClthErlyExitLmp' */

    /* SignalConversion generated from: '<S13>/EMErlyExitLmp' incorporates:
     *  SignalConversion generated from: '<S13>/ClthLwrThresLmp'
     */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* VariantMerge generated from: '<S13>/EMErlyExitLmp' */
    VeESSR_b_EMErlyExitLmp = ESSR_ac_B.VariantMergeForOutportVeESSR__g;

#elif !Rte_SysCon_Variant_ESSR_Func || !Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* VariantMerge generated from: '<S13>/ClthLwrThresLmp' incorporates:
     *  SignalConversion generated from: '<S13>/ClthLwrThresLmp'
     */
    VeESSR_b_ClthLwrThresLmp = false;

    /* VariantMerge generated from: '<S13>/EMErlyExitLmp' incorporates:
     *  SignalConversion generated from: '<S13>/EMErlyExitLmp'
     */
    VeESSR_b_EMErlyExitLmp = false;

#endif

    /* End of SignalConversion generated from: '<S13>/EMErlyExitLmp' */

    /* DataStoreRead: '<S13>/Dsr_STMTrigger' */
    Dsr_STMTrigger = VeESSR_e_STMTrigger_DS;

    /* DataStoreRead: '<S13>/Dsr_EngStrtType' */
    Dsr_EngStrtType = VeESSR_e_EngStrtProfType_DS;

    /* DataStoreRead: '<S13>/Dsr_EngRestartReq' */
    rtb_LogicalOperator_e = VeESSR_b_EngRestartReq_DS;

    /* DataStoreRead: '<S13>/Dsr_PFSRunReq' */
    rtb_AND_dr = VeESSR_b_PFSRunReq_DS;

    /* DataStoreRead: '<S13>/Dsr_DsblFuelReq' */
    rtb_Switch1_ac = VeESSR_b_DsblFuelReq_DS;

    /* DataStoreRead: '<S13>/Dsr_RmpDwnReq' */
    rtb_Logical3_nsq = VeESSR_b_RmpDwnReq_DS;

    /* DataStoreRead: '<S13>/BmpStrtFailed' */
    rtb_AND_hz = VeESSR_b_BumpStrtFailed_DS;

    /* DataStoreRead: '<S13>/Dsr_PFSRunReq1' */
    rtb_UnitDelay7 = VeESSR_b_LmtP1fRestartReq_DS;

    /* SignalConversion generated from: '<S572>/Ff_InputTorqReq7' */
#if Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* VariantMerge generated from: '<S572>/Ff_InputTorqReq7' */
    ESSR_ac_B.LeESSI_n_MtrB_Spd = rtb_LeESSI_n_MtrB_Spd;

    /* VariantMerge generated from: '<S572>/Ff_InputTorqReq11' */
    ESSR_ac_B.LeESSI_M_InputTorqMaxTact = rtb_LeESSI_M_InputTorqMaxTact;

    /* VariantMerge generated from: '<S572>/Ff_InputTorqReq8' */
    ESSR_ac_B.LeESSI_M_MtrB_TorqCmnd = rtb_LeESSI_M_MtrB_TorqCmnd;

    /* VariantMerge generated from: '<S564>/Ff_InputTorqReq8' */
    ESSR_ac_B.LeESSI_M_MtrB_TorqCmnd_o = rtb_LeESSI_M_MtrB_TorqCmnd;

#endif

    /* SignalConversion generated from: '<S563>/Ff_InputTorqReq8' */
#if Rte_SysCon_Variant_ESSR_P1P2Func

    /* VariantMerge generated from: '<S563>/Ff_InputTorqReq8' */
    ESSR_ac_B.LeESSI_M_MtrB_TorqCmnd_ov = rtb_LeESSI_M_MtrB_TorqCmnd;

    /* VariantMerge generated from: '<S556>/Ff_InputTorqReq7' */
    ESSR_ac_B.LeESSI_n_MtrB_Spd_i = rtb_LeESSI_n_MtrB_Spd;

    /* VariantMerge generated from: '<S556>/Ff_InputTorqReq11' */
    ESSR_ac_B.LeESSI_M_InputTorqMaxTact_p = rtb_LeESSI_M_InputTorqMaxTact;

#endif

    /* End of Outputs for SubSystem: '<S2>/ESSC_EngStartStopCtrl' */
    /* Gateway: ESSR_MedTEB/ESSC_EngStartStopCtrl/ESSC_EngStartStopSTM */
    /* During: ESSR_MedTEB/ESSC_EngStartStopCtrl/ESSC_EngStartStopSTM */
    (void)Rte_Read_VeSTRR_b_ImmedStop_Value(&rtb_Logical_e);

    /* Outputs for Function Call SubSystem: '<S2>/ESSC_EngStartStopCtrl' */
    /* Chart: '<S13>/ESSC_EngStartStopSTM' incorporates:
     *  DataStoreRead: '<S13>/Dsr_STMTrigger'
     *  Inport: '<Root>/VeAATR_T_EstAmbAirTemp'
     *  Inport: '<Root>/VeENGR_b_EngTLCLearnReq'
     *  Inport: '<Root>/VeENGR_b_EngineStallDetected'
     *  Inport: '<Root>/VeENGR_e_EngDFSO_Req'
     *  Inport: '<Root>/VeENGR_e_EngDFSO_St'
     *  Inport: '<Root>/VeETQR_M_EngCapacityMinRun'
     *  Inport: '<Root>/VeINVR_e_MtrA_InvrtrSt'
     *  Inport: '<Root>/VePMDR_b_StrtCntrlStOn'
     *  Inport: '<Root>/VeSRAR_b_MtrBZeroTrqActv'
     *  Inport: '<Root>/VeSTRR_b_ImmedStop'
     *  Inport: '<Root>/VeSTRR_g_AStpInhbtRsn2'
     *  Inport: '<Root>/VeTAPR_b_AuxPumpRunning'
     *  Inport: '<Root>/VeTFTR_T_TransOilTemp'
     *  Inport: '<Root>/VeTRNR_e_ILEStat'
     */
    if (((uint32)ESSR_ac_DW.is_active_c1_ESSR_ac) == 0U)
    {
        /* Entry: ESSR_MedTEB/ESSC_EngStartStopCtrl/ESSC_EngStartStopSTM */
        ESSR_ac_DW.is_active_c1_ESSR_ac = 1U;

        /* Entry Internal: ESSR_MedTEB/ESSC_EngStartStopCtrl/ESSC_EngStartStopSTM */
        /* Transition: '<S165>:28' */
        ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_EngOff;

        /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
        /* Entry 'EngOff': '<S165>:1' */
        /* Event: '<S165>:101' */
        ESSR_ac_ESSC_ResetVars();

        /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

        /* Outputs for Function Call SubSystem: '<S173>/ESSC_EngOffEnt' */
        /* Event: '<S165>:65' */
        ESSR_ac_ESSC_EngOffEnt(ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_H);

        /* End of Outputs for SubSystem: '<S173>/ESSC_EngOffEnt' */

        /* Outputs for Function Call SubSystem: '<S173>/ESSC_EngOffDur' */
        /* Switch: '<S242>/Switch' incorporates:
         *  Constant: '<S256>/Calib'
         *  Constant: '<S269>/Calib'
         *  Constant: '<S270>/Calib'
         *  Logic: '<S242>/AND2'
         */
        /* Event: '<S165>:66' */
        if ((HeESSR_b_CltchStrtEquipped) &&
                (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_C))
        {
            rtb_TmpSignalConversionAtVeOHSR = KeESSR_t_MinTmEngOffCltchStrt;
        }
        else
        {
            rtb_TmpSignalConversionAtVeOHSR = KeESSR_t_MinTmEngOff;
        }

        /* Switch: '<S260>/Switch1' incorporates:
         *  Constant: '<S242>/TRUE Constant'
         *  Constant: '<S249>/Constant'
         *  Constant: '<S250>/Constant'
         *  Constant: '<S261>/Calib'
         *  Logic: '<S242>/AND1'
         *  RelationalOperator: '<S242>/Comparison1'
         *  RelationalOperator: '<S242>/Comparison4'
         *  SignalConversion generated from: '<S2>/VeHSER_e_RngEqnSel'
         */
        if (KeESSR_b_CheckGearForStart)
        {
            rtb_UnitDelay_op = ((CeHSER_e_UseM1Eqn == ((uint32)
                                  ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R)) ||
                                (((uint32)
                                  ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R) ==
                                 CeHSER_e_UseM2Eqn));
        }
        else
        {
            rtb_UnitDelay_op = true;
        }

        /* Switch: '<S259>/Switch1' incorporates:
         *  Constant: '<S245>/Constant'
         *  DataStoreRead: '<S242>/Dsr_STMTmr1'
         *  DataStoreWrite: '<S242>/Dsw_STMTrigger'
         *  Logic: '<S242>/AND'
         *  Logic: '<S242>/Logical2'
         *  RelationalOperator: '<S242>/Greater  Than'
         */
        if ((((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_F) || (VeESSR_t_STMTmr_DS
               > rtb_TmpSignalConversionAtVeOHSR)) &&
                (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E)) && rtb_UnitDelay_op)
        {
            VeESSR_e_STMTrigger_DS = CeESSR_e_StartReq;
        }

        /* RelationalOperator: '<S242>/Comparison3' incorporates:
         *  RelationalOperator: '<S242>/Comparison2'
         *  RelationalOperator: '<S242>/Comparison5'
         *  SignalConversion generated from: '<S2>/VeSTRR_e_HybStrtrSt'
         *  Switch: '<S242>/Switch4'
         */
        rtb_UnitDelay_h_tmp = ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_H;

        /* UnitDelay: '<S287>/Unit Delay' incorporates:
         *  Constant: '<S252>/Constant'
         *  RelationalOperator: '<S242>/Comparison3'
         */
        rtb_UnitDelay_op = (((uint32)rtb_UnitDelay_h_tmp) ==
                            CeSTRR_e_EngStoppingSt);

        /* Switch: '<S242>/Switch4' */
        if (!rtb_UnitDelay_op)
        {
            /* Switch: '<S242>/Switch3' incorporates:
             *  Constant: '<S253>/Constant'
             *  Constant: '<S254>/Constant'
             *  Constant: '<S255>/Constant'
             *  DataStoreWrite: '<S242>/Data Store Write'
             *  RelationalOperator: '<S242>/Comparison5'
             *  Switch: '<S242>/Switch4'
             */
            if (((uint32)rtb_UnitDelay_h_tmp) == CeSTRR_e_KeyOffSt)
            {
                VeESSR_e_HybEngSysActv_DS = CeESSR_e_HybEngDisabled;
            }
            else
            {
                VeESSR_e_HybEngSysActv_DS = CeESSR_e_HybEngEnabledOff;
            }
        }

        /* UnitDelay: '<S287>/Unit Delay' incorporates:
         *  DataStoreRead: '<S242>/Data Store Read1'
         *  Logic: '<S242>/Logical1'
         */
        rtb_UnitDelay_op = ((VeESSR_b_NbTgtReq_DS) && rtb_UnitDelay_op);

        /* Switch: '<S242>/Switch1' incorporates:
         *  DataStoreWrite: '<S242>/Dsw_InhibitShiftToMode2'
         */
        VeESSR_b_NbTgtReq_DS = rtb_UnitDelay_op;

        /* Switch: '<S242>/Switch2' incorporates:
         *  Constant: '<S242>/Constant Value'
         *  Constant: '<S264>/Calib'
         *  DataStoreWrite: '<S242>/Dsw_InputSpeedProfile1'
         */
        if (rtb_UnitDelay_op)
        {
            VeESSR_n_NbTgt_DS = 0.0F;
        }
        else
        {
            VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;
        }

        /* DataStoreWrite: '<S242>/Dsw_STMTmr' incorporates:
         *  Constant: '<S257>/Calib'
         *  DataStoreRead: '<S242>/Dsr_STMTmr'
         *  Sum: '<S242>/Summation'
         */
        VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

        /* DataStoreWrite: '<S242>/Dsw_STMTmr1' incorporates:
         *  Constant: '<S257>/Calib'
         *  DataStoreRead: '<S242>/Dsr_STMTmr4'
         *  Sum: '<S242>/Summation2'
         */
        VeESSR_t_MainSTMTmr_DS = VeESSR_t_MainSTMTmr_DS + HeESSR_t_MedTEB_dT;

        /* Abs: '<S248>/Abs' incorporates:
         *  Constant: '<S257>/Calib'
         *  Constant: '<S262>/Calib'
         *  Product: '<S248>/Multiplication'
         */
        rtb_Abs_bj = fabsf(KeESSR_dscl_RampDownRate * HeESSR_t_MedTEB_dT);

        /* Gain: '<S248>/Gain' */
        rtb_Gain_fa = -rtb_Abs_bj;

        /* Sum: '<S248>/Sum' incorporates:
         *  Constant: '<S267>/Calib'
         *  DataStoreRead: '<S242>/Dsr_SpdCtlGainMod1'
         */
        rtb_TmpSignalConversionAtVeVSDR = KeESSR_scl_SpdCtrlEngOff -
            VeESSR_scl_SpdCtlGainMod_DS;

        /* Outputs for Atomic SubSystem: '<S248>/Limiter1' */
        /* Switch: '<S282>/Switch1' incorporates:
         *  RelationalOperator: '<S282>/Relational Operator'
         */
        if (rtb_Abs_bj >= rtb_TmpSignalConversionAtVeVSDR)
        {
            /* UnitDelay: '<S274>/Unit Delay' */
            rtb_Abs_bj = rtb_TmpSignalConversionAtVeVSDR;
        }

        /* Switch: '<S282>/Switch' incorporates:
         *  RelationalOperator: '<S282>/Relational Operator1'
         */
        if (rtb_Abs_bj > rtb_Gain_fa)
        {
            rtb_Gain_fa = rtb_Abs_bj;
        }

        /* End of Outputs for SubSystem: '<S248>/Limiter1' */

        /* Sum: '<S248>/Sum1' incorporates:
         *  DataStoreRead: '<S242>/Dsr_SpdCtlGainMod1'
         */
        rtb_Gain_fa += VeESSR_scl_SpdCtlGainMod_DS;

        /* Outputs for Atomic SubSystem: '<S248>/Limiter2' */
        /* Switch: '<S283>/Switch1' incorporates:
         *  Constant: '<S242>/Constant Value7'
         *  RelationalOperator: '<S283>/Relational Operator'
         */
        if (2.0F < rtb_Gain_fa)
        {
            /* UnitDelay: '<S274>/Unit Delay' */
            rtb_Abs_bj = 2.0F;
        }
        else
        {
            /* UnitDelay: '<S274>/Unit Delay' */
            rtb_Abs_bj = rtb_Gain_fa;
        }

        /* Switch: '<S283>/Switch' incorporates:
         *  Constant: '<S242>/Constant Value6'
         *  DataStoreWrite: '<S242>/Dsw_SpdCtlGainMod1'
         *  RelationalOperator: '<S283>/Relational Operator1'
         */
        if (rtb_Abs_bj > 0.0F)
        {
            VeESSR_scl_SpdCtlGainMod_DS = rtb_Abs_bj;
        }
        else
        {
            VeESSR_scl_SpdCtlGainMod_DS = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S248>/Limiter2' */

        /* Abs: '<S247>/Abs' incorporates:
         *  Constant: '<S257>/Calib'
         *  Constant: '<S263>/Calib'
         *  Product: '<S247>/Multiplication'
         */
        rtb_Abs_bj = fabsf(KeESSR_dscl_TorqCancelRampOutRt * HeESSR_t_MedTEB_dT);

        /* Gain: '<S247>/Gain' */
        rtb_Gain_fa = -rtb_Abs_bj;

        /* Outputs for Atomic SubSystem: '<S247>/Limiter1' */
        /* Switch: '<S280>/Switch1' incorporates:
         *  Constant: '<S242>/Constant Value5'
         *  DataStoreRead: '<S242>/Dsr_TorqCancelDsrd'
         *  RelationalOperator: '<S280>/Relational Operator'
         *  Sum: '<S247>/Sum'
         */
        if (rtb_Abs_bj >= (0.0F - VeESSR_k_TorqCancelGain_DS))
        {
            /* UnitDelay: '<S274>/Unit Delay' */
            rtb_Abs_bj = 0.0F - VeESSR_k_TorqCancelGain_DS;
        }

        /* Switch: '<S280>/Switch' incorporates:
         *  RelationalOperator: '<S280>/Relational Operator1'
         */
        if (rtb_Abs_bj > rtb_Gain_fa)
        {
            rtb_Gain_fa = rtb_Abs_bj;
        }

        /* End of Outputs for SubSystem: '<S247>/Limiter1' */

        /* Sum: '<S247>/Sum1' incorporates:
         *  DataStoreRead: '<S242>/Dsr_TorqCancelDsrd'
         */
        rtb_Gain_fa += VeESSR_k_TorqCancelGain_DS;

        /* Outputs for Atomic SubSystem: '<S247>/Limiter2' */
        /* Switch: '<S281>/Switch1' incorporates:
         *  Constant: '<S242>/Constant Value4'
         *  RelationalOperator: '<S281>/Relational Operator'
         */
        if (2.0F < rtb_Gain_fa)
        {
            /* UnitDelay: '<S274>/Unit Delay' */
            rtb_Abs_bj = 2.0F;
        }
        else
        {
            /* UnitDelay: '<S274>/Unit Delay' */
            rtb_Abs_bj = rtb_Gain_fa;
        }

        /* Switch: '<S281>/Switch' incorporates:
         *  Constant: '<S242>/Constant Value3'
         *  DataStoreWrite: '<S242>/Dsw_TorqCancelDsrd'
         *  RelationalOperator: '<S281>/Relational Operator1'
         */
        if (rtb_Abs_bj > 0.0F)
        {
            VeESSR_k_TorqCancelGain_DS = rtb_Abs_bj;
        }
        else
        {
            VeESSR_k_TorqCancelGain_DS = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S247>/Limiter2' */

        /* SignalConversion generated from: '<S246>/Variant Source' incorporates:
         *  Gain: '<S246>/Gain'
         *  Lookup_n-D: '<S278>/Vector'
         *  MinMax: '<S246>/MinMax'
         *  Sum: '<S246>/Summation1'
         */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

        /* VariantMerge generated from: '<S246>/Variant Source' incorporates:
         *  Constant: '<S246>/Constant Value1'
         */
        rtb_Sum2_fr = 0.0F;

#else

        /* Outputs for Atomic SubSystem: '<S246>/GradientLimiter' */
        /* MinMax: '<S246>/MinMax' incorporates:
         *  Constant: '<S246>/Constant Value'
         *  Gain: '<S246>/Gain'
         */
        VeESSR_M_EngOffEngFricEngStrtTorq = fmaxf(-VeESSR_M_EngTrqAct_Lmtd, 0.0F);

        /* Lookup_n-D: '<S278>/Vector' incorporates:
         *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
         */
        VeESSR_M_EngOffECTEngStrtTorq = look1_iflf_binlcapw
            (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const float32 *)
              &(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((const float32 *)
              &(KtESSR_M_ECTAddtlEngStrtTorq[0])), 6U);

        /* Sum: '<S246>/Summation1' incorporates:
         *  Constant: '<S275>/Calib'
         */
        VeESSR_M_EngOffEngStrtTorqRaw = (VeESSR_M_EngOffEngFricEngStrtTorq +
            KeESSR_M_EngOffEngPulseEngStrtTorq) + VeESSR_M_EngOffECTEngStrtTorq;

        /* Sum: '<S274>/Sum2' incorporates:
         *  UnitDelay: '<S274>/Unit Delay'
         */
        rtb_Sum2_fr = VeESSR_M_EngOffEngStrtTorqRaw -
            ESSR_ac_DW.UnitDelay_DSTATE_ie;

        /* Outputs for Atomic SubSystem: '<S274>/Limiter' */
        /* Switch: '<S279>/Switch1' incorporates:
         *  Constant: '<S277>/Calib'
         *  RelationalOperator: '<S279>/Relational Operator'
         */
        if (KeESSR_dM_EngOffEngStrtTorqLU < rtb_Sum2_fr)
        {
            /* Switch: '<S279>/Switch1' */
            rtb_Sum2_fr = KeESSR_dM_EngOffEngStrtTorqLU;
        }

        /* Switch: '<S279>/Switch' incorporates:
         *  Constant: '<S276>/Calib'
         *  RelationalOperator: '<S279>/Relational Operator1'
         */
        if (rtb_Sum2_fr <= KeESSR_dM_EngOffEngStrtTorqLD)
        {
            rtb_Sum2_fr = KeESSR_dM_EngOffEngStrtTorqLD;
        }

        /* End of Outputs for SubSystem: '<S274>/Limiter' */

        /* Sum: '<S274>/Sum3' incorporates:
         *  UnitDelay: '<S274>/Unit Delay'
         */
        rtb_Sum2_fr += ESSR_ac_DW.UnitDelay_DSTATE_ie;

        /* Update for UnitDelay: '<S274>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_ie = rtb_Sum2_fr;

        /* End of Outputs for SubSystem: '<S246>/GradientLimiter' */
#endif

        /* SignalConversion generated from: '<S246>/Variant Source' */
        VeESSR_M_EngOffEngStrtTorqLmtd = rtb_Sum2_fr;

        /* DataStoreWrite: '<S242>/Data Store Write2' */
        VeESSR_M_EngStrtTorq_DS = VeESSR_M_EngOffEngStrtTorqLmtd;

        /* DataStoreWrite: '<S242>/Data Store Write1' incorporates:
         *  Constant: '<S242>/Constant'
         */
        ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = 0.0F;

        /* DataStoreWrite: '<S242>/Dsw_AEMDMtrAGain' incorporates:
         *  Constant: '<S265>/Calib'
         */
        VeESSR_scl_AEMDMtrAGain_DS = KeESSR_scl_AEMDMtrAGain_EngOff;

        /* DataStoreWrite: '<S242>/Dsw_AEMDMtrBGain' incorporates:
         *  Constant: '<S266>/Calib'
         */
        VeESSR_scl_AEMDMtrBGain_DS = KeESSR_scl_AEMDMtrBGain_EngOff;

        /* Logic: '<S242>/Logical' incorporates:
         *  Constant: '<S251>/Constant'
         *  RelationalOperator: '<S242>/Comparison2'
         */
        rtb_Logical_e = (rtb_Logical_e && (((uint32)rtb_UnitDelay_h_tmp) ==
                          CeSTRR_e_EngOffSt));

        /* Outputs for Atomic SubSystem: '<S242>/Turn Off Delay Time' */
        /* Outputs for Atomic SubSystem: '<S273>/EdgeFalling1' */
        /* Logic: '<S287>/AND' incorporates:
         *  Logic: '<S287>/OR1'
         *  UnitDelay: '<S287>/Unit Delay'
         */
        rtb_UnitDelay_op = ((!rtb_Logical_e) && (ESSR_ac_DW.UnitDelay_DSTATE_hx));

        /* Update for UnitDelay: '<S287>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_hx = rtb_Logical_e;

        /* End of Outputs for SubSystem: '<S273>/EdgeFalling1' */

        /* Switch: '<S273>/Switch' */
        if (rtb_UnitDelay_op)
        {
            /* Switch: '<S273>/Switch' incorporates:
             *  Constant: '<S268>/Calib'
             */
            rtb_Sum2_fr = KeESSR_t_ImmedStopMdHoldDelay;
        }
        else
        {
            /* Switch: '<S273>/Switch' incorporates:
             *  Constant: '<S257>/Calib'
             *  Constant: '<S273>/Constant Value1'
             *  MinMax: '<S273>/Minimum'
             *  Sum: '<S273>/Summation'
             *  UnitDelay: '<S273>/Unit Delay'
             */
            rtb_Sum2_fr = fmaxf(ESSR_ac_DW.UnitDelay_DSTATE_dg -
                                HeESSR_t_MedTEB_dT, 0.0F);
        }

        /* Update for UnitDelay: '<S273>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_dg = rtb_Sum2_fr;

        /* If: '<S242>/If' incorporates:
         *  Constant: '<S271>/Calib'
         *  Constant: '<S273>/Constant Value2'
         *  DataStoreRead: '<S242>/Dsr_STMTmr2'
         *  Logic: '<S273>/AND'
         *  RelationalOperator: '<S242>/Greater  Than1'
         *  RelationalOperator: '<S273>/Greater  Than'
         */
        if (rtb_Logical_e || (rtb_Sum2_fr > 0.0F))
        {
            /* Outputs for IfAction SubSystem: '<S242>/If Action Subsystem' incorporates:
             *  ActionPort: '<S258>/Action Port'
             */
            /* DataStoreWrite: '<S258>/Dsw_EngStrtStpMd2' incorporates:
             *  Constant: '<S284>/Constant'
             */
            VeESSR_e_EngStrtStpMd_DS = CeESSR_e_ImmediateStop;

            /* End of Outputs for SubSystem: '<S242>/If Action Subsystem' */
        }
        else
        {
            if (VeESSR_t_STMTmr_DS > KeESSR_t_ResetFailTm)
            {
                /* Outputs for IfAction SubSystem: '<S242>/ResetFailed' incorporates:
                 *  ActionPort: '<S272>/Action Port'
                 */
                /* DataStoreWrite: '<S272>/Data Store Write1' incorporates:
                 *  Constant: '<S272>/FALSE Constant2'
                 */
                VeESSR_b_BumpStrtFailed_DS = false;

                /* DataStoreWrite: '<S272>/Dsw_EngStartAbort' incorporates:
                 *  Constant: '<S272>/FALSE Constant1'
                 */
                VeESSR_b_EngStartAbort_DS = false;

                /* DataStoreWrite: '<S272>/Dsw_EngStartAbort1' incorporates:
                 *  Constant: '<S286>/Calib'
                 */
                VeESSR_b_AStrtFailed_DS = KeESSR_b_ResetAStrtFailed;

                /* DataStoreWrite: '<S272>/Dsw_EngStrtStpMd' incorporates:
                 *  Constant: '<S285>/Constant'
                 */
                VeESSR_e_EngStrtStpMd_DS = CeESSR_e_Stop;

                /* DataStoreWrite: '<S272>/Dsw_StrtStopFail' incorporates:
                 *  Constant: '<S272>/FALSE Constant'
                 */
                VeESSR_b_StrtStopFail_DS = false;

                /* End of Outputs for SubSystem: '<S242>/ResetFailed' */
            }
        }

        /* End of Outputs for SubSystem: '<S242>/Turn Off Delay Time' */
        /* End of Outputs for SubSystem: '<S173>/ESSC_EngOffDur' */
    }
    else
    {
        (void)Rte_Read_VeENGR_b_EngineStallDetected_Value(&rtb_UnitDelay_op);
        (void)Rte_Read_VePMDR_b_StrtCntrlStOn_Value(&tmpRead_3);
        (void)Rte_Read_VeSRAR_b_MtrBZeroTrqActv_Value(&tmpRead_4);
        (void)Rte_Read_VeSTRR_g_AStpInhbtRsn2_Value(&tmpRead_5);
        (void)Rte_Read_VeTRNR_e_ILEStat_Value(&tmpRead_7);
        switch (ESSR_ac_DW.is_c1_ESSR_ac)
        {
          case ESSR_ac_IN_CoastDown:
            /* During 'CoastDown': '<S165>:126' */
            if ((((uint32)VeESSR_e_STMTrigger_DS) == CeESSR_e_ImmedStopReq) ||
                    (((uint32)VeESSR_e_STMTrigger_DS) == CeESSR_e_EngFail))
            {
                /* Outputs for Function Call SubSystem: '<S171>/ESSC_CoastDownExit' */
                /* Transition: '<S165>:127' */
                /* Exit 'CoastDown': '<S165>:126' */
                /* Event: '<S165>:135' */
                ESSR_ac_ESSC_CoastDownExit
                    (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                     ESSR_ac_B.TmpSignalConversionAtVeHPMR_b_P);

                /* End of Outputs for SubSystem: '<S171>/ESSC_CoastDownExit' */
                ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_ImmedStop;

                /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                /* Entry 'ImmedStop': '<S165>:5' */
                /* Event: '<S165>:101' */
                ESSR_ac_ESSC_ResetVars();

                /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                /* Outputs for Function Call SubSystem: '<S175>/ESSC_ImmedStopEnt' */
                /* Event: '<S165>:75' */
                ESSR_ac_ESSC_ImmedStopEnt(VeESSR_n_TransInSpdFlt,
                    ESSR_ac_B.TmpSignalConversionAtVeTRAR_e_H,
                    ESSR_ac_B.TmpSignalConversionAtVeTRAR_M_E);

                /* End of Outputs for SubSystem: '<S175>/ESSC_ImmedStopEnt' */

                /* Outputs for Function Call SubSystem: '<S175>/ESSC_ImmedStopDur' */
                /* Event: '<S165>:76' */
                ESSR_ac_ESSC_ImmedStopDur(VeESSR_n_TransInSpdFlt,
                    VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                    ESSR_ac_B.TmpSignalConversionAtVeENGR_e_C,
                    ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                    VeESSR_M_SpnDwnAddtlTorq,
                    ESSR_ac_B.TmpSignalConversionAtVeHPMR_b_P, tmpRead_3,
                    ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                    &ESSR_ac_DW.ESSC_ImmedStopDur,
                    &ESSR_ac_PrevZCX.ESSC_ImmedStopDur,
                    &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                /* End of Outputs for SubSystem: '<S175>/ESSC_ImmedStopDur' */
            }
            else
            {
                switch (VeESSR_e_STMTrigger_DS)
                {
                  case CeESSR_e_EngStop:
                    /* Outputs for Function Call SubSystem: '<S171>/ESSC_CoastDownExit' */
                    /* Transition: '<S165>:166' */
                    /* Exit 'CoastDown': '<S165>:126' */
                    /* Event: '<S165>:135' */
                    ESSR_ac_ESSC_CoastDownExit
                        (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                         ESSR_ac_B.TmpSignalConversionAtVeHPMR_b_P);

                    /* End of Outputs for SubSystem: '<S171>/ESSC_CoastDownExit' */
                    ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_EngOff;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'EngOff': '<S165>:1' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                    /* Outputs for Function Call SubSystem: '<S173>/ESSC_EngOffEnt' */
                    /* Event: '<S165>:65' */
                    ESSR_ac_ESSC_EngOffEnt
                        (ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_H);

                    /* End of Outputs for SubSystem: '<S173>/ESSC_EngOffEnt' */

                    /* Outputs for Function Call SubSystem: '<S173>/ESSC_EngOffDur' */
                    /* Switch: '<S242>/Switch' incorporates:
                     *  Constant: '<S256>/Calib'
                     *  Constant: '<S269>/Calib'
                     *  Constant: '<S270>/Calib'
                     *  Logic: '<S242>/AND2'
                     */
                    /* Event: '<S165>:66' */
                    if ((HeESSR_b_CltchStrtEquipped) &&
                            (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_C))
                    {
                        rtb_TmpSignalConversionAtVeOHSR =
                            KeESSR_t_MinTmEngOffCltchStrt;
                    }
                    else
                    {
                        rtb_TmpSignalConversionAtVeOHSR = KeESSR_t_MinTmEngOff;
                    }

                    /* Switch: '<S260>/Switch1' incorporates:
                     *  Constant: '<S242>/TRUE Constant'
                     *  Constant: '<S249>/Constant'
                     *  Constant: '<S250>/Constant'
                     *  Constant: '<S261>/Calib'
                     *  Logic: '<S242>/AND1'
                     *  RelationalOperator: '<S242>/Comparison1'
                     *  RelationalOperator: '<S242>/Comparison4'
                     *  SignalConversion generated from: '<S2>/VeHSER_e_RngEqnSel'
                     */
                    if (KeESSR_b_CheckGearForStart)
                    {
                        rtb_UnitDelay_op = ((CeHSER_e_UseM1Eqn == ((uint32)
                                              ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R))
                                            || (((uint32)
                                              ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R)
                                                == CeHSER_e_UseM2Eqn));
                    }
                    else
                    {
                        rtb_UnitDelay_op = true;
                    }

                    /* Switch: '<S259>/Switch1' incorporates:
                     *  Constant: '<S245>/Constant'
                     *  DataStoreRead: '<S242>/Dsr_STMTmr1'
                     *  DataStoreWrite: '<S242>/Dsw_STMTrigger'
                     *  Logic: '<S242>/AND'
                     *  Logic: '<S242>/Logical2'
                     *  RelationalOperator: '<S242>/Greater  Than'
                     */
                    if ((((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_F) ||
                            (VeESSR_t_STMTmr_DS >
                             rtb_TmpSignalConversionAtVeOHSR)) &&
                            (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E)) &&
                            rtb_UnitDelay_op)
                    {
                        VeESSR_e_STMTrigger_DS = CeESSR_e_StartReq;
                    }

                    /* RelationalOperator: '<S242>/Comparison3' incorporates:
                     *  RelationalOperator: '<S242>/Comparison2'
                     *  RelationalOperator: '<S242>/Comparison5'
                     *  SignalConversion generated from: '<S2>/VeSTRR_e_HybStrtrSt'
                     *  Switch: '<S242>/Switch4'
                     */
                    rtb_UnitDelay_h_tmp =
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_H;

                    /* UnitDelay: '<S287>/Unit Delay' incorporates:
                     *  Constant: '<S252>/Constant'
                     *  RelationalOperator: '<S242>/Comparison3'
                     */
                    rtb_UnitDelay_op = (((uint32)rtb_UnitDelay_h_tmp) ==
                                        CeSTRR_e_EngStoppingSt);

                    /* Switch: '<S242>/Switch4' */
                    if (!rtb_UnitDelay_op)
                    {
                        /* Switch: '<S242>/Switch3' incorporates:
                         *  Constant: '<S253>/Constant'
                         *  Constant: '<S254>/Constant'
                         *  Constant: '<S255>/Constant'
                         *  DataStoreWrite: '<S242>/Data Store Write'
                         *  RelationalOperator: '<S242>/Comparison5'
                         *  Switch: '<S242>/Switch4'
                         */
                        if (((uint32)rtb_UnitDelay_h_tmp) == CeSTRR_e_KeyOffSt)
                        {
                            VeESSR_e_HybEngSysActv_DS = CeESSR_e_HybEngDisabled;
                        }
                        else
                        {
                            VeESSR_e_HybEngSysActv_DS =
                                CeESSR_e_HybEngEnabledOff;
                        }
                    }

                    /* UnitDelay: '<S287>/Unit Delay' incorporates:
                     *  DataStoreRead: '<S242>/Data Store Read1'
                     *  Logic: '<S242>/Logical1'
                     */
                    rtb_UnitDelay_op = ((VeESSR_b_NbTgtReq_DS) &&
                                        rtb_UnitDelay_op);

                    /* Switch: '<S242>/Switch1' incorporates:
                     *  DataStoreWrite: '<S242>/Dsw_InhibitShiftToMode2'
                     */
                    VeESSR_b_NbTgtReq_DS = rtb_UnitDelay_op;

                    /* Switch: '<S242>/Switch2' incorporates:
                     *  Constant: '<S242>/Constant Value'
                     *  Constant: '<S264>/Calib'
                     *  DataStoreWrite: '<S242>/Dsw_InputSpeedProfile1'
                     */
                    if (rtb_UnitDelay_op)
                    {
                        VeESSR_n_NbTgt_DS = 0.0F;
                    }
                    else
                    {
                        VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;
                    }

                    /* DataStoreWrite: '<S242>/Dsw_STMTmr' incorporates:
                     *  Constant: '<S257>/Calib'
                     *  DataStoreRead: '<S242>/Dsr_STMTmr'
                     *  Sum: '<S242>/Summation'
                     */
                    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

                    /* DataStoreWrite: '<S242>/Dsw_STMTmr1' incorporates:
                     *  Constant: '<S257>/Calib'
                     *  DataStoreRead: '<S242>/Dsr_STMTmr4'
                     *  Sum: '<S242>/Summation2'
                     */
                    VeESSR_t_MainSTMTmr_DS = VeESSR_t_MainSTMTmr_DS +
                        HeESSR_t_MedTEB_dT;

                    /* Abs: '<S248>/Abs' incorporates:
                     *  Constant: '<S257>/Calib'
                     *  Constant: '<S262>/Calib'
                     *  Product: '<S248>/Multiplication'
                     */
                    rtb_Abs_bj = fabsf(KeESSR_dscl_RampDownRate *
                                       HeESSR_t_MedTEB_dT);

                    /* Gain: '<S248>/Gain' */
                    rtb_Gain_fa = -rtb_Abs_bj;

                    /* Sum: '<S248>/Sum' incorporates:
                     *  Constant: '<S267>/Calib'
                     *  DataStoreRead: '<S242>/Dsr_SpdCtlGainMod1'
                     */
                    rtb_TmpSignalConversionAtVeVSDR = KeESSR_scl_SpdCtrlEngOff -
                        VeESSR_scl_SpdCtlGainMod_DS;

                    /* Outputs for Atomic SubSystem: '<S248>/Limiter1' */
                    /* Switch: '<S282>/Switch1' incorporates:
                     *  RelationalOperator: '<S282>/Relational Operator'
                     */
                    if (rtb_Abs_bj >= rtb_TmpSignalConversionAtVeVSDR)
                    {
                        /* UnitDelay: '<S274>/Unit Delay' */
                        rtb_Abs_bj = rtb_TmpSignalConversionAtVeVSDR;
                    }

                    /* Switch: '<S282>/Switch' incorporates:
                     *  RelationalOperator: '<S282>/Relational Operator1'
                     */
                    if (rtb_Abs_bj > rtb_Gain_fa)
                    {
                        rtb_Gain_fa = rtb_Abs_bj;
                    }

                    /* End of Outputs for SubSystem: '<S248>/Limiter1' */

                    /* Sum: '<S248>/Sum1' incorporates:
                     *  DataStoreRead: '<S242>/Dsr_SpdCtlGainMod1'
                     */
                    rtb_Gain_fa += VeESSR_scl_SpdCtlGainMod_DS;

                    /* Outputs for Atomic SubSystem: '<S248>/Limiter2' */
                    /* Switch: '<S283>/Switch1' incorporates:
                     *  Constant: '<S242>/Constant Value7'
                     *  RelationalOperator: '<S283>/Relational Operator'
                     */
                    if (2.0F < rtb_Gain_fa)
                    {
                        /* UnitDelay: '<S274>/Unit Delay' */
                        rtb_Abs_bj = 2.0F;
                    }
                    else
                    {
                        /* UnitDelay: '<S274>/Unit Delay' */
                        rtb_Abs_bj = rtb_Gain_fa;
                    }

                    /* Switch: '<S283>/Switch' incorporates:
                     *  Constant: '<S242>/Constant Value6'
                     *  DataStoreWrite: '<S242>/Dsw_SpdCtlGainMod1'
                     *  RelationalOperator: '<S283>/Relational Operator1'
                     */
                    if (rtb_Abs_bj > 0.0F)
                    {
                        VeESSR_scl_SpdCtlGainMod_DS = rtb_Abs_bj;
                    }
                    else
                    {
                        VeESSR_scl_SpdCtlGainMod_DS = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S248>/Limiter2' */

                    /* Abs: '<S247>/Abs' incorporates:
                     *  Constant: '<S257>/Calib'
                     *  Constant: '<S263>/Calib'
                     *  Product: '<S247>/Multiplication'
                     */
                    rtb_Abs_bj = fabsf(KeESSR_dscl_TorqCancelRampOutRt *
                                       HeESSR_t_MedTEB_dT);

                    /* Gain: '<S247>/Gain' */
                    rtb_Gain_fa = -rtb_Abs_bj;

                    /* Outputs for Atomic SubSystem: '<S247>/Limiter1' */
                    /* Switch: '<S280>/Switch1' incorporates:
                     *  Constant: '<S242>/Constant Value5'
                     *  DataStoreRead: '<S242>/Dsr_TorqCancelDsrd'
                     *  RelationalOperator: '<S280>/Relational Operator'
                     *  Sum: '<S247>/Sum'
                     */
                    if (rtb_Abs_bj >= (0.0F - VeESSR_k_TorqCancelGain_DS))
                    {
                        /* UnitDelay: '<S274>/Unit Delay' */
                        rtb_Abs_bj = 0.0F - VeESSR_k_TorqCancelGain_DS;
                    }

                    /* Switch: '<S280>/Switch' incorporates:
                     *  RelationalOperator: '<S280>/Relational Operator1'
                     */
                    if (rtb_Abs_bj > rtb_Gain_fa)
                    {
                        rtb_Gain_fa = rtb_Abs_bj;
                    }

                    /* End of Outputs for SubSystem: '<S247>/Limiter1' */

                    /* Sum: '<S247>/Sum1' incorporates:
                     *  DataStoreRead: '<S242>/Dsr_TorqCancelDsrd'
                     */
                    rtb_Gain_fa += VeESSR_k_TorqCancelGain_DS;

                    /* Outputs for Atomic SubSystem: '<S247>/Limiter2' */
                    /* Switch: '<S281>/Switch1' incorporates:
                     *  Constant: '<S242>/Constant Value4'
                     *  RelationalOperator: '<S281>/Relational Operator'
                     */
                    if (2.0F < rtb_Gain_fa)
                    {
                        /* UnitDelay: '<S274>/Unit Delay' */
                        rtb_Abs_bj = 2.0F;
                    }
                    else
                    {
                        /* UnitDelay: '<S274>/Unit Delay' */
                        rtb_Abs_bj = rtb_Gain_fa;
                    }

                    /* Switch: '<S281>/Switch' incorporates:
                     *  Constant: '<S242>/Constant Value3'
                     *  DataStoreWrite: '<S242>/Dsw_TorqCancelDsrd'
                     *  RelationalOperator: '<S281>/Relational Operator1'
                     */
                    if (rtb_Abs_bj > 0.0F)
                    {
                        VeESSR_k_TorqCancelGain_DS = rtb_Abs_bj;
                    }
                    else
                    {
                        VeESSR_k_TorqCancelGain_DS = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S247>/Limiter2' */

                    /* SignalConversion generated from: '<S246>/Variant Source' incorporates:
                     *  Gain: '<S246>/Gain'
                     *  Lookup_n-D: '<S278>/Vector'
                     *  MinMax: '<S246>/MinMax'
                     *  Sum: '<S246>/Summation1'
                     */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* VariantMerge generated from: '<S246>/Variant Source' incorporates:
                     *  Constant: '<S246>/Constant Value1'
                     */
                    rtb_Sum2_fr = 0.0F;

#else

                    /* Outputs for Atomic SubSystem: '<S246>/GradientLimiter' */
                    /* MinMax: '<S246>/MinMax' incorporates:
                     *  Constant: '<S246>/Constant Value'
                     *  Gain: '<S246>/Gain'
                     */
                    VeESSR_M_EngOffEngFricEngStrtTorq = fmaxf
                        (-VeESSR_M_EngTrqAct_Lmtd, 0.0F);

                    /* Lookup_n-D: '<S278>/Vector' incorporates:
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     */
                    VeESSR_M_EngOffECTEngStrtTorq = look1_iflf_binlcapw
                        (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                           float32 *)&(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((
                           const float32 *)&(KtESSR_M_ECTAddtlEngStrtTorq[0])),
                         6U);

                    /* Sum: '<S246>/Summation1' incorporates:
                     *  Constant: '<S275>/Calib'
                     */
                    VeESSR_M_EngOffEngStrtTorqRaw =
                        (VeESSR_M_EngOffEngFricEngStrtTorq +
                         KeESSR_M_EngOffEngPulseEngStrtTorq) +
                        VeESSR_M_EngOffECTEngStrtTorq;

                    /* Sum: '<S274>/Sum2' incorporates:
                     *  UnitDelay: '<S274>/Unit Delay'
                     */
                    rtb_Sum2_fr = VeESSR_M_EngOffEngStrtTorqRaw -
                        ESSR_ac_DW.UnitDelay_DSTATE_ie;

                    /* Outputs for Atomic SubSystem: '<S274>/Limiter' */
                    /* Switch: '<S279>/Switch1' incorporates:
                     *  Constant: '<S277>/Calib'
                     *  RelationalOperator: '<S279>/Relational Operator'
                     */
                    if (KeESSR_dM_EngOffEngStrtTorqLU < rtb_Sum2_fr)
                    {
                        /* Switch: '<S279>/Switch1' */
                        rtb_Sum2_fr = KeESSR_dM_EngOffEngStrtTorqLU;
                    }

                    /* Switch: '<S279>/Switch' incorporates:
                     *  Constant: '<S276>/Calib'
                     *  RelationalOperator: '<S279>/Relational Operator1'
                     */
                    if (rtb_Sum2_fr <= KeESSR_dM_EngOffEngStrtTorqLD)
                    {
                        rtb_Sum2_fr = KeESSR_dM_EngOffEngStrtTorqLD;
                    }

                    /* End of Outputs for SubSystem: '<S274>/Limiter' */

                    /* Sum: '<S274>/Sum3' incorporates:
                     *  UnitDelay: '<S274>/Unit Delay'
                     */
                    rtb_Sum2_fr += ESSR_ac_DW.UnitDelay_DSTATE_ie;

                    /* Update for UnitDelay: '<S274>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_ie = rtb_Sum2_fr;

                    /* End of Outputs for SubSystem: '<S246>/GradientLimiter' */
#endif

                    /* SignalConversion generated from: '<S246>/Variant Source' */
                    VeESSR_M_EngOffEngStrtTorqLmtd = rtb_Sum2_fr;

                    /* DataStoreWrite: '<S242>/Data Store Write2' */
                    VeESSR_M_EngStrtTorq_DS = VeESSR_M_EngOffEngStrtTorqLmtd;

                    /* DataStoreWrite: '<S242>/Data Store Write1' incorporates:
                     *  Constant: '<S242>/Constant'
                     */
                    ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = 0.0F;

                    /* DataStoreWrite: '<S242>/Dsw_AEMDMtrAGain' incorporates:
                     *  Constant: '<S265>/Calib'
                     */
                    VeESSR_scl_AEMDMtrAGain_DS = KeESSR_scl_AEMDMtrAGain_EngOff;

                    /* DataStoreWrite: '<S242>/Dsw_AEMDMtrBGain' incorporates:
                     *  Constant: '<S266>/Calib'
                     */
                    VeESSR_scl_AEMDMtrBGain_DS = KeESSR_scl_AEMDMtrBGain_EngOff;

                    /* Logic: '<S242>/Logical' incorporates:
                     *  Constant: '<S251>/Constant'
                     *  RelationalOperator: '<S242>/Comparison2'
                     */
                    rtb_Logical_e = (rtb_Logical_e && (((uint32)
                                       rtb_UnitDelay_h_tmp) == CeSTRR_e_EngOffSt));

                    /* Outputs for Atomic SubSystem: '<S242>/Turn Off Delay Time' */
                    /* Outputs for Atomic SubSystem: '<S273>/EdgeFalling1' */
                    /* Logic: '<S287>/AND' incorporates:
                     *  Logic: '<S287>/OR1'
                     *  UnitDelay: '<S287>/Unit Delay'
                     */
                    rtb_UnitDelay_op = ((!rtb_Logical_e) &&
                                        (ESSR_ac_DW.UnitDelay_DSTATE_hx));

                    /* Update for UnitDelay: '<S287>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_hx = rtb_Logical_e;

                    /* End of Outputs for SubSystem: '<S273>/EdgeFalling1' */

                    /* Switch: '<S273>/Switch' */
                    if (rtb_UnitDelay_op)
                    {
                        /* Switch: '<S273>/Switch' incorporates:
                         *  Constant: '<S268>/Calib'
                         */
                        rtb_Sum2_fr = KeESSR_t_ImmedStopMdHoldDelay;
                    }
                    else
                    {
                        /* Switch: '<S273>/Switch' incorporates:
                         *  Constant: '<S257>/Calib'
                         *  Constant: '<S273>/Constant Value1'
                         *  MinMax: '<S273>/Minimum'
                         *  Sum: '<S273>/Summation'
                         *  UnitDelay: '<S273>/Unit Delay'
                         */
                        rtb_Sum2_fr = fmaxf(ESSR_ac_DW.UnitDelay_DSTATE_dg -
                                            HeESSR_t_MedTEB_dT, 0.0F);
                    }

                    /* Update for UnitDelay: '<S273>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_dg = rtb_Sum2_fr;

                    /* If: '<S242>/If' incorporates:
                     *  Constant: '<S271>/Calib'
                     *  Constant: '<S273>/Constant Value2'
                     *  DataStoreRead: '<S242>/Dsr_STMTmr2'
                     *  Logic: '<S273>/AND'
                     *  RelationalOperator: '<S242>/Greater  Than1'
                     *  RelationalOperator: '<S273>/Greater  Than'
                     */
                    if (rtb_Logical_e || (rtb_Sum2_fr > 0.0F))
                    {
                        /* Outputs for IfAction SubSystem: '<S242>/If Action Subsystem' incorporates:
                         *  ActionPort: '<S258>/Action Port'
                         */
                        /* DataStoreWrite: '<S258>/Dsw_EngStrtStpMd2' incorporates:
                         *  Constant: '<S284>/Constant'
                         */
                        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_ImmediateStop;

                        /* End of Outputs for SubSystem: '<S242>/If Action Subsystem' */
                    }
                    else
                    {
                        if (VeESSR_t_STMTmr_DS > KeESSR_t_ResetFailTm)
                        {
                            /* Outputs for IfAction SubSystem: '<S242>/ResetFailed' incorporates:
                             *  ActionPort: '<S272>/Action Port'
                             */
                            /* DataStoreWrite: '<S272>/Data Store Write1' incorporates:
                             *  Constant: '<S272>/FALSE Constant2'
                             */
                            VeESSR_b_BumpStrtFailed_DS = false;

                            /* DataStoreWrite: '<S272>/Dsw_EngStartAbort' incorporates:
                             *  Constant: '<S272>/FALSE Constant1'
                             */
                            VeESSR_b_EngStartAbort_DS = false;

                            /* DataStoreWrite: '<S272>/Dsw_EngStartAbort1' incorporates:
                             *  Constant: '<S286>/Calib'
                             */
                            VeESSR_b_AStrtFailed_DS = KeESSR_b_ResetAStrtFailed;

                            /* DataStoreWrite: '<S272>/Dsw_EngStrtStpMd' incorporates:
                             *  Constant: '<S285>/Constant'
                             */
                            VeESSR_e_EngStrtStpMd_DS = CeESSR_e_Stop;

                            /* DataStoreWrite: '<S272>/Dsw_StrtStopFail' incorporates:
                             *  Constant: '<S272>/FALSE Constant'
                             */
                            VeESSR_b_StrtStopFail_DS = false;

                            /* End of Outputs for SubSystem: '<S242>/ResetFailed' */
                        }
                    }

                    /* End of Outputs for SubSystem: '<S242>/Turn Off Delay Time' */
                    /* End of Outputs for SubSystem: '<S173>/ESSC_EngOffDur' */
                    break;

                  case CeESSR_e_StartReq:
                    /* Outputs for Function Call SubSystem: '<S171>/ESSC_CoastDownExit' */
                    /* Transition: '<S165>:129' */
                    /* Exit 'CoastDown': '<S165>:126' */
                    /* Event: '<S165>:135' */
                    ESSR_ac_ESSC_CoastDownExit
                        (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                         ESSR_ac_B.TmpSignalConversionAtVeHPMR_b_P);

                    /* End of Outputs for SubSystem: '<S171>/ESSC_CoastDownExit' */
                    ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_EngStartCtrl;

                    /* Outputs for Function Call SubSystem: '<S176>/MainEngStartEntry' */
                    /* Entry 'EngStartCtrl': '<S165>:4' */
                    /* Event: '<S165>:69' */
                    ESSR_ac_MainEngStartEntry
                        (ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_E,
                         ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E);

                    /* End of Outputs for SubSystem: '<S176>/MainEngStartEntry' */
                    ESS_enter_internal_EngStartCtrl(&rtb_LogicalOperator_e,
                        &rtb_AND_dr, &rtb_AND_hz, &rtb_UnitDelay7,
                        &Dsr_EngStrtType);
                    break;

                  default:
                    /* Outputs for Function Call SubSystem: '<S171>/ESSC_CoastDownDur' */
                    /* Event: '<S165>:134' */
                    ESSR_ac_ESSC_CoastDownDur(VeESSR_n_TransInSpdFlt,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_E,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E, tmpRead_4,
                        tmpRead_5, ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_e,
                        ESSR_ac_B.TmpSignalConversionAtVeTRNR_e_A, tmpRead_7);

                    /* End of Outputs for SubSystem: '<S171>/ESSC_CoastDownDur' */
                    break;
                }
            }
            break;

          case ESSR_ac_IN_EngOff:
            /* During 'EngOff': '<S165>:1' */
            if (((uint32)VeESSR_e_STMTrigger_DS) == CeESSR_e_StartReq)
            {
                /* Outputs for Function Call SubSystem: '<S173>/ESSC_EngOffExit' */
                /* Switch: '<S305>/Switch1' incorporates:
                 *  Constant: '<S307>/Calib'
                 *  Constant: '<S309>/Calib'
                 *  DataStoreRead: '<S244>/Data Store Read4'
                 *  Logic: '<S244>/Logical Operator3'
                 *  RelationalOperator: '<S244>/Greater  Than2'
                 */
                /* Transition: '<S165>:20' */
                /* Exit 'EngOff': '<S165>:1' */
                /* Event: '<S165>:176' */
                if ((((ESSR_ac_B.TmpSignalConversionAtVeHPMR_b_P) &&
                        (KeESSR_b_EnblFtrBackupStrt)) &&
                        (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B)) &&
                        (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
                         KeESSR_Cnt_BackupStrtMaxAttmpts))
                {
                    /* Sum: '<S244>/Summation1' incorporates:
                     *  Constant: '<S244>/Constant Value1'
                     *  DataStoreRead: '<S244>/Data Store Read1'
                     */
                    VeESSR_k_StrtTypFrstOrdLwPassT_ = (sint32)((uint32)(((uint32)
                        VeESSR_Cnt_BackupStrtAttmptCntr_DS) + 1U));
                    if ((((uint32)VeESSR_Cnt_BackupStrtAttmptCntr_DS) + 1U) >
                            255U)
                    {
                        VeESSR_k_StrtTypFrstOrdLwPassT_ = 255;
                    }

                    /* DataStoreWrite: '<S244>/Data Store Write' incorporates:
                     *  Sum: '<S244>/Summation1'
                     *  Switch: '<S306>/Switch1'
                     */
                    VeESSR_Cnt_BackupStrtAttmptCntr_DS = (uint8)
                        VeESSR_k_StrtTypFrstOrdLwPassT_;
                }

                /* End of Switch: '<S305>/Switch1' */

                /* Switch: '<S306>/Switch1' incorporates:
                 *  Constant: '<S308>/Calib'
                 *  Constant: '<S310>/Calib'
                 *  DataStoreRead: '<S244>/Data Store Read2'
                 *  Logic: '<S244>/Logical Operator1'
                 *  RelationalOperator: '<S244>/Greater  Than3'
                 */
                if ((((ESSR_ac_B.TmpSignalConversionAtVeHPMR_b_P) &&
                        (KeESSR_b_EnblFtrBumpStrt)) &&
                        (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d)) &&
                        (VeESSR_Cnt_BumpStrtAttmptCntr_DS <
                         KeESSR_Cnt_BumpStrtMaxAttmpts))
                {
                    /* Sum: '<S244>/Summation3' incorporates:
                     *  Constant: '<S244>/Constant Value2'
                     *  DataStoreRead: '<S244>/Data Store Read3'
                     */
                    VeESSR_k_StrtTypFrstOrdLwPassT_ = (sint32)((uint32)(((uint32)
                        VeESSR_Cnt_BumpStrtAttmptCntr_DS) + 1U));
                    if ((((uint32)VeESSR_Cnt_BumpStrtAttmptCntr_DS) + 1U) > 255U)
                    {
                        VeESSR_k_StrtTypFrstOrdLwPassT_ = 255;
                    }

                    /* DataStoreWrite: '<S244>/Data Store Write1' incorporates:
                     *  Sum: '<S244>/Summation3'
                     *  Switch: '<S306>/Switch1'
                     */
                    VeESSR_Cnt_BumpStrtAttmptCntr_DS = (uint8)
                        VeESSR_k_StrtTypFrstOrdLwPassT_;
                }

                /* End of Switch: '<S306>/Switch1' */
                /* End of Outputs for SubSystem: '<S173>/ESSC_EngOffExit' */
                ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_EngStartCtrl;

                /* Outputs for Function Call SubSystem: '<S176>/MainEngStartEntry' */
                /* Entry 'EngStartCtrl': '<S165>:4' */
                /* Event: '<S165>:69' */
                ESSR_ac_MainEngStartEntry
                    (ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_E,
                     ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E);

                /* End of Outputs for SubSystem: '<S176>/MainEngStartEntry' */
                ESS_enter_internal_EngStartCtrl(&rtb_LogicalOperator_e,
                    &rtb_AND_dr, &rtb_AND_hz, &rtb_UnitDelay7, &Dsr_EngStrtType);
            }
            else
            {
                /* Outputs for Function Call SubSystem: '<S173>/ESSC_EngOffDur' */
                /* Switch: '<S242>/Switch' incorporates:
                 *  Constant: '<S256>/Calib'
                 *  Constant: '<S269>/Calib'
                 *  Constant: '<S270>/Calib'
                 *  Logic: '<S242>/AND2'
                 */
                /* Event: '<S165>:66' */
                if ((HeESSR_b_CltchStrtEquipped) &&
                        (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_C))
                {
                    rtb_TmpSignalConversionAtVeOHSR =
                        KeESSR_t_MinTmEngOffCltchStrt;
                }
                else
                {
                    rtb_TmpSignalConversionAtVeOHSR = KeESSR_t_MinTmEngOff;
                }

                /* Switch: '<S260>/Switch1' incorporates:
                 *  Constant: '<S242>/TRUE Constant'
                 *  Constant: '<S249>/Constant'
                 *  Constant: '<S250>/Constant'
                 *  Constant: '<S261>/Calib'
                 *  Logic: '<S242>/AND1'
                 *  RelationalOperator: '<S242>/Comparison1'
                 *  RelationalOperator: '<S242>/Comparison4'
                 *  SignalConversion generated from: '<S2>/VeHSER_e_RngEqnSel'
                 */
                if (KeESSR_b_CheckGearForStart)
                {
                    rtb_UnitDelay_op = ((CeHSER_e_UseM1Eqn == ((uint32)
                                          ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R))
                                        || (((uint32)
                                          ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R)
                                            == CeHSER_e_UseM2Eqn));
                }
                else
                {
                    rtb_UnitDelay_op = true;
                }

                /* Switch: '<S259>/Switch1' incorporates:
                 *  Constant: '<S245>/Constant'
                 *  DataStoreRead: '<S242>/Dsr_STMTmr1'
                 *  DataStoreWrite: '<S242>/Dsw_STMTrigger'
                 *  Logic: '<S242>/AND'
                 *  Logic: '<S242>/Logical2'
                 *  RelationalOperator: '<S242>/Greater  Than'
                 */
                if ((((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_F) ||
                        (VeESSR_t_STMTmr_DS > rtb_TmpSignalConversionAtVeOHSR)) &&
                     (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E)) &&
                        rtb_UnitDelay_op)
                {
                    VeESSR_e_STMTrigger_DS = CeESSR_e_StartReq;
                }

                /* RelationalOperator: '<S242>/Comparison3' incorporates:
                 *  RelationalOperator: '<S242>/Comparison2'
                 *  RelationalOperator: '<S242>/Comparison5'
                 *  SignalConversion generated from: '<S2>/VeSTRR_e_HybStrtrSt'
                 *  Switch: '<S242>/Switch4'
                 */
                rtb_UnitDelay_h_tmp = ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_H;

                /* UnitDelay: '<S287>/Unit Delay' incorporates:
                 *  Constant: '<S252>/Constant'
                 *  RelationalOperator: '<S242>/Comparison3'
                 */
                rtb_UnitDelay_op = (((uint32)rtb_UnitDelay_h_tmp) ==
                                    CeSTRR_e_EngStoppingSt);

                /* Switch: '<S242>/Switch4' */
                if (!rtb_UnitDelay_op)
                {
                    /* Switch: '<S242>/Switch3' incorporates:
                     *  Constant: '<S253>/Constant'
                     *  Constant: '<S254>/Constant'
                     *  Constant: '<S255>/Constant'
                     *  DataStoreWrite: '<S242>/Data Store Write'
                     *  RelationalOperator: '<S242>/Comparison5'
                     *  Switch: '<S242>/Switch4'
                     */
                    if (((uint32)rtb_UnitDelay_h_tmp) == CeSTRR_e_KeyOffSt)
                    {
                        VeESSR_e_HybEngSysActv_DS = CeESSR_e_HybEngDisabled;
                    }
                    else
                    {
                        VeESSR_e_HybEngSysActv_DS = CeESSR_e_HybEngEnabledOff;
                    }
                }

                /* UnitDelay: '<S287>/Unit Delay' incorporates:
                 *  DataStoreRead: '<S242>/Data Store Read1'
                 *  Logic: '<S242>/Logical1'
                 */
                rtb_UnitDelay_op = ((VeESSR_b_NbTgtReq_DS) && rtb_UnitDelay_op);

                /* Switch: '<S242>/Switch1' incorporates:
                 *  DataStoreWrite: '<S242>/Dsw_InhibitShiftToMode2'
                 */
                VeESSR_b_NbTgtReq_DS = rtb_UnitDelay_op;

                /* Switch: '<S242>/Switch2' incorporates:
                 *  Constant: '<S242>/Constant Value'
                 *  Constant: '<S264>/Calib'
                 *  DataStoreWrite: '<S242>/Dsw_InputSpeedProfile1'
                 */
                if (rtb_UnitDelay_op)
                {
                    VeESSR_n_NbTgt_DS = 0.0F;
                }
                else
                {
                    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;
                }

                /* DataStoreWrite: '<S242>/Dsw_STMTmr' incorporates:
                 *  Constant: '<S257>/Calib'
                 *  DataStoreRead: '<S242>/Dsr_STMTmr'
                 *  Sum: '<S242>/Summation'
                 */
                VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

                /* DataStoreWrite: '<S242>/Dsw_STMTmr1' incorporates:
                 *  Constant: '<S257>/Calib'
                 *  DataStoreRead: '<S242>/Dsr_STMTmr4'
                 *  Sum: '<S242>/Summation2'
                 */
                VeESSR_t_MainSTMTmr_DS = VeESSR_t_MainSTMTmr_DS +
                    HeESSR_t_MedTEB_dT;

                /* Abs: '<S248>/Abs' incorporates:
                 *  Constant: '<S257>/Calib'
                 *  Constant: '<S262>/Calib'
                 *  Product: '<S248>/Multiplication'
                 */
                rtb_Abs_bj = fabsf(KeESSR_dscl_RampDownRate * HeESSR_t_MedTEB_dT);

                /* Gain: '<S248>/Gain' */
                rtb_Gain_fa = -rtb_Abs_bj;

                /* Sum: '<S248>/Sum' incorporates:
                 *  Constant: '<S267>/Calib'
                 *  DataStoreRead: '<S242>/Dsr_SpdCtlGainMod1'
                 */
                rtb_TmpSignalConversionAtVeVSDR = KeESSR_scl_SpdCtrlEngOff -
                    VeESSR_scl_SpdCtlGainMod_DS;

                /* Outputs for Atomic SubSystem: '<S248>/Limiter1' */
                /* Switch: '<S282>/Switch1' incorporates:
                 *  RelationalOperator: '<S282>/Relational Operator'
                 */
                if (rtb_Abs_bj >= rtb_TmpSignalConversionAtVeVSDR)
                {
                    /* UnitDelay: '<S274>/Unit Delay' */
                    rtb_Abs_bj = rtb_TmpSignalConversionAtVeVSDR;
                }

                /* Switch: '<S282>/Switch' incorporates:
                 *  RelationalOperator: '<S282>/Relational Operator1'
                 */
                if (rtb_Abs_bj > rtb_Gain_fa)
                {
                    rtb_Gain_fa = rtb_Abs_bj;
                }

                /* End of Outputs for SubSystem: '<S248>/Limiter1' */

                /* Sum: '<S248>/Sum1' incorporates:
                 *  DataStoreRead: '<S242>/Dsr_SpdCtlGainMod1'
                 */
                rtb_Gain_fa += VeESSR_scl_SpdCtlGainMod_DS;

                /* Outputs for Atomic SubSystem: '<S248>/Limiter2' */
                /* Switch: '<S283>/Switch1' incorporates:
                 *  Constant: '<S242>/Constant Value7'
                 *  RelationalOperator: '<S283>/Relational Operator'
                 */
                if (2.0F < rtb_Gain_fa)
                {
                    /* UnitDelay: '<S274>/Unit Delay' */
                    rtb_Abs_bj = 2.0F;
                }
                else
                {
                    /* UnitDelay: '<S274>/Unit Delay' */
                    rtb_Abs_bj = rtb_Gain_fa;
                }

                /* Switch: '<S283>/Switch' incorporates:
                 *  Constant: '<S242>/Constant Value6'
                 *  DataStoreWrite: '<S242>/Dsw_SpdCtlGainMod1'
                 *  RelationalOperator: '<S283>/Relational Operator1'
                 */
                if (rtb_Abs_bj > 0.0F)
                {
                    VeESSR_scl_SpdCtlGainMod_DS = rtb_Abs_bj;
                }
                else
                {
                    VeESSR_scl_SpdCtlGainMod_DS = 0.0F;
                }

                /* End of Outputs for SubSystem: '<S248>/Limiter2' */

                /* Abs: '<S247>/Abs' incorporates:
                 *  Constant: '<S257>/Calib'
                 *  Constant: '<S263>/Calib'
                 *  Product: '<S247>/Multiplication'
                 */
                rtb_Abs_bj = fabsf(KeESSR_dscl_TorqCancelRampOutRt *
                                   HeESSR_t_MedTEB_dT);

                /* Gain: '<S247>/Gain' */
                rtb_Gain_fa = -rtb_Abs_bj;

                /* Outputs for Atomic SubSystem: '<S247>/Limiter1' */
                /* Switch: '<S280>/Switch1' incorporates:
                 *  Constant: '<S242>/Constant Value5'
                 *  DataStoreRead: '<S242>/Dsr_TorqCancelDsrd'
                 *  RelationalOperator: '<S280>/Relational Operator'
                 *  Sum: '<S247>/Sum'
                 */
                if (rtb_Abs_bj >= (0.0F - VeESSR_k_TorqCancelGain_DS))
                {
                    /* UnitDelay: '<S274>/Unit Delay' */
                    rtb_Abs_bj = 0.0F - VeESSR_k_TorqCancelGain_DS;
                }

                /* Switch: '<S280>/Switch' incorporates:
                 *  RelationalOperator: '<S280>/Relational Operator1'
                 */
                if (rtb_Abs_bj > rtb_Gain_fa)
                {
                    rtb_Gain_fa = rtb_Abs_bj;
                }

                /* End of Outputs for SubSystem: '<S247>/Limiter1' */

                /* Sum: '<S247>/Sum1' incorporates:
                 *  DataStoreRead: '<S242>/Dsr_TorqCancelDsrd'
                 */
                rtb_Gain_fa += VeESSR_k_TorqCancelGain_DS;

                /* Outputs for Atomic SubSystem: '<S247>/Limiter2' */
                /* Switch: '<S281>/Switch1' incorporates:
                 *  Constant: '<S242>/Constant Value4'
                 *  RelationalOperator: '<S281>/Relational Operator'
                 */
                if (2.0F < rtb_Gain_fa)
                {
                    /* UnitDelay: '<S274>/Unit Delay' */
                    rtb_Abs_bj = 2.0F;
                }
                else
                {
                    /* UnitDelay: '<S274>/Unit Delay' */
                    rtb_Abs_bj = rtb_Gain_fa;
                }

                /* Switch: '<S281>/Switch' incorporates:
                 *  Constant: '<S242>/Constant Value3'
                 *  DataStoreWrite: '<S242>/Dsw_TorqCancelDsrd'
                 *  RelationalOperator: '<S281>/Relational Operator1'
                 */
                if (rtb_Abs_bj > 0.0F)
                {
                    VeESSR_k_TorqCancelGain_DS = rtb_Abs_bj;
                }
                else
                {
                    VeESSR_k_TorqCancelGain_DS = 0.0F;
                }

                /* End of Outputs for SubSystem: '<S247>/Limiter2' */

                /* SignalConversion generated from: '<S246>/Variant Source' incorporates:
                 *  Gain: '<S246>/Gain'
                 *  Lookup_n-D: '<S278>/Vector'
                 *  MinMax: '<S246>/MinMax'
                 *  Sum: '<S246>/Summation1'
                 */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

                /* VariantMerge generated from: '<S246>/Variant Source' incorporates:
                 *  Constant: '<S246>/Constant Value1'
                 */
                rtb_Sum2_fr = 0.0F;

#else

                /* Outputs for Atomic SubSystem: '<S246>/GradientLimiter' */
                /* MinMax: '<S246>/MinMax' incorporates:
                 *  Constant: '<S246>/Constant Value'
                 *  Gain: '<S246>/Gain'
                 */
                VeESSR_M_EngOffEngFricEngStrtTorq = fmaxf
                    (-VeESSR_M_EngTrqAct_Lmtd, 0.0F);

                /* Lookup_n-D: '<S278>/Vector' incorporates:
                 *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                 */
                VeESSR_M_EngOffECTEngStrtTorq = look1_iflf_binlcapw
                    (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const float32 *)
                      &(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((const float32 *)
                      &(KtESSR_M_ECTAddtlEngStrtTorq[0])), 6U);

                /* Sum: '<S246>/Summation1' incorporates:
                 *  Constant: '<S275>/Calib'
                 */
                VeESSR_M_EngOffEngStrtTorqRaw =
                    (VeESSR_M_EngOffEngFricEngStrtTorq +
                     KeESSR_M_EngOffEngPulseEngStrtTorq) +
                    VeESSR_M_EngOffECTEngStrtTorq;

                /* Sum: '<S274>/Sum2' incorporates:
                 *  UnitDelay: '<S274>/Unit Delay'
                 */
                rtb_Sum2_fr = VeESSR_M_EngOffEngStrtTorqRaw -
                    ESSR_ac_DW.UnitDelay_DSTATE_ie;

                /* Outputs for Atomic SubSystem: '<S274>/Limiter' */
                /* Switch: '<S279>/Switch1' incorporates:
                 *  Constant: '<S277>/Calib'
                 *  RelationalOperator: '<S279>/Relational Operator'
                 */
                if (KeESSR_dM_EngOffEngStrtTorqLU < rtb_Sum2_fr)
                {
                    /* Switch: '<S279>/Switch1' */
                    rtb_Sum2_fr = KeESSR_dM_EngOffEngStrtTorqLU;
                }

                /* Switch: '<S279>/Switch' incorporates:
                 *  Constant: '<S276>/Calib'
                 *  RelationalOperator: '<S279>/Relational Operator1'
                 */
                if (rtb_Sum2_fr <= KeESSR_dM_EngOffEngStrtTorqLD)
                {
                    rtb_Sum2_fr = KeESSR_dM_EngOffEngStrtTorqLD;
                }

                /* End of Outputs for SubSystem: '<S274>/Limiter' */

                /* Sum: '<S274>/Sum3' incorporates:
                 *  UnitDelay: '<S274>/Unit Delay'
                 */
                rtb_Sum2_fr += ESSR_ac_DW.UnitDelay_DSTATE_ie;

                /* Update for UnitDelay: '<S274>/Unit Delay' */
                ESSR_ac_DW.UnitDelay_DSTATE_ie = rtb_Sum2_fr;

                /* End of Outputs for SubSystem: '<S246>/GradientLimiter' */
#endif

                /* SignalConversion generated from: '<S246>/Variant Source' */
                VeESSR_M_EngOffEngStrtTorqLmtd = rtb_Sum2_fr;

                /* DataStoreWrite: '<S242>/Data Store Write2' */
                VeESSR_M_EngStrtTorq_DS = VeESSR_M_EngOffEngStrtTorqLmtd;

                /* DataStoreWrite: '<S242>/Data Store Write1' incorporates:
                 *  Constant: '<S242>/Constant'
                 */
                ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = 0.0F;

                /* DataStoreWrite: '<S242>/Dsw_AEMDMtrAGain' incorporates:
                 *  Constant: '<S265>/Calib'
                 */
                VeESSR_scl_AEMDMtrAGain_DS = KeESSR_scl_AEMDMtrAGain_EngOff;

                /* DataStoreWrite: '<S242>/Dsw_AEMDMtrBGain' incorporates:
                 *  Constant: '<S266>/Calib'
                 */
                VeESSR_scl_AEMDMtrBGain_DS = KeESSR_scl_AEMDMtrBGain_EngOff;

                /* Logic: '<S242>/Logical' incorporates:
                 *  Constant: '<S251>/Constant'
                 *  RelationalOperator: '<S242>/Comparison2'
                 */
                rtb_Logical_e = (rtb_Logical_e && (((uint32)rtb_UnitDelay_h_tmp)
                                  == CeSTRR_e_EngOffSt));

                /* Outputs for Atomic SubSystem: '<S242>/Turn Off Delay Time' */
                /* Outputs for Atomic SubSystem: '<S273>/EdgeFalling1' */
                /* Logic: '<S287>/AND' incorporates:
                 *  Logic: '<S287>/OR1'
                 *  UnitDelay: '<S287>/Unit Delay'
                 */
                rtb_UnitDelay_op = ((!rtb_Logical_e) &&
                                    (ESSR_ac_DW.UnitDelay_DSTATE_hx));

                /* Update for UnitDelay: '<S287>/Unit Delay' */
                ESSR_ac_DW.UnitDelay_DSTATE_hx = rtb_Logical_e;

                /* End of Outputs for SubSystem: '<S273>/EdgeFalling1' */

                /* Switch: '<S273>/Switch' */
                if (rtb_UnitDelay_op)
                {
                    /* Switch: '<S273>/Switch' incorporates:
                     *  Constant: '<S268>/Calib'
                     */
                    rtb_Sum2_fr = KeESSR_t_ImmedStopMdHoldDelay;
                }
                else
                {
                    /* Switch: '<S273>/Switch' incorporates:
                     *  Constant: '<S257>/Calib'
                     *  Constant: '<S273>/Constant Value1'
                     *  MinMax: '<S273>/Minimum'
                     *  Sum: '<S273>/Summation'
                     *  UnitDelay: '<S273>/Unit Delay'
                     */
                    rtb_Sum2_fr = fmaxf(ESSR_ac_DW.UnitDelay_DSTATE_dg -
                                        HeESSR_t_MedTEB_dT, 0.0F);
                }

                /* Update for UnitDelay: '<S273>/Unit Delay' */
                ESSR_ac_DW.UnitDelay_DSTATE_dg = rtb_Sum2_fr;

                /* If: '<S242>/If' incorporates:
                 *  Constant: '<S271>/Calib'
                 *  Constant: '<S273>/Constant Value2'
                 *  DataStoreRead: '<S242>/Dsr_STMTmr2'
                 *  Logic: '<S273>/AND'
                 *  RelationalOperator: '<S242>/Greater  Than1'
                 *  RelationalOperator: '<S273>/Greater  Than'
                 */
                if (rtb_Logical_e || (rtb_Sum2_fr > 0.0F))
                {
                    /* Outputs for IfAction SubSystem: '<S242>/If Action Subsystem' incorporates:
                     *  ActionPort: '<S258>/Action Port'
                     */
                    /* DataStoreWrite: '<S258>/Dsw_EngStrtStpMd2' incorporates:
                     *  Constant: '<S284>/Constant'
                     */
                    VeESSR_e_EngStrtStpMd_DS = CeESSR_e_ImmediateStop;

                    /* End of Outputs for SubSystem: '<S242>/If Action Subsystem' */
                }
                else
                {
                    if (VeESSR_t_STMTmr_DS > KeESSR_t_ResetFailTm)
                    {
                        /* Outputs for IfAction SubSystem: '<S242>/ResetFailed' incorporates:
                         *  ActionPort: '<S272>/Action Port'
                         */
                        /* DataStoreWrite: '<S272>/Data Store Write1' incorporates:
                         *  Constant: '<S272>/FALSE Constant2'
                         */
                        VeESSR_b_BumpStrtFailed_DS = false;

                        /* DataStoreWrite: '<S272>/Dsw_EngStartAbort' incorporates:
                         *  Constant: '<S272>/FALSE Constant1'
                         */
                        VeESSR_b_EngStartAbort_DS = false;

                        /* DataStoreWrite: '<S272>/Dsw_EngStartAbort1' incorporates:
                         *  Constant: '<S286>/Calib'
                         */
                        VeESSR_b_AStrtFailed_DS = KeESSR_b_ResetAStrtFailed;

                        /* DataStoreWrite: '<S272>/Dsw_EngStrtStpMd' incorporates:
                         *  Constant: '<S285>/Constant'
                         */
                        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_Stop;

                        /* DataStoreWrite: '<S272>/Dsw_StrtStopFail' incorporates:
                         *  Constant: '<S272>/FALSE Constant'
                         */
                        VeESSR_b_StrtStopFail_DS = false;

                        /* End of Outputs for SubSystem: '<S242>/ResetFailed' */
                    }
                }

                /* End of Outputs for SubSystem: '<S242>/Turn Off Delay Time' */
                /* End of Outputs for SubSystem: '<S173>/ESSC_EngOffDur' */
            }
            break;

          case ESSR_ac_IN_EngRunning:
            /* During 'EngRunning': '<S165>:12' */
            if (((uint32)VeESSR_e_STMTrigger_DS) == CeESSR_e_StopReq)
            {
                /* Transition: '<S165>:26' */
                ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_EngStopCtrl;

                /* Outputs for Function Call SubSystem: '<S177>/MainEngStopEntry' */
                /* Entry 'EngStopCtrl': '<S165>:13' */
                /* Event: '<S165>:72' */
                ESSR_ac_MainEngStopEntry();

                /* End of Outputs for SubSystem: '<S177>/MainEngStopEntry' */
                ESSR_enter_internal_EngStopCtrl(&rtb_Switch1_ac,
                    &rtb_Logical3_nsq);
            }
            else if ((((uint32)VeESSR_e_STMTrigger_DS) == CeESSR_e_ImmedStopReq)
                     || (((uint32)VeESSR_e_STMTrigger_DS) == CeESSR_e_EngFail))
            {
                /* Transition: '<S165>:31' */
                ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_ImmedStop;

                /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                /* Entry 'ImmedStop': '<S165>:5' */
                /* Event: '<S165>:101' */
                ESSR_ac_ESSC_ResetVars();

                /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                /* Outputs for Function Call SubSystem: '<S175>/ESSC_ImmedStopEnt' */
                /* Event: '<S165>:75' */
                ESSR_ac_ESSC_ImmedStopEnt(VeESSR_n_TransInSpdFlt,
                    ESSR_ac_B.TmpSignalConversionAtVeTRAR_e_H,
                    ESSR_ac_B.TmpSignalConversionAtVeTRAR_M_E);

                /* End of Outputs for SubSystem: '<S175>/ESSC_ImmedStopEnt' */

                /* Outputs for Function Call SubSystem: '<S175>/ESSC_ImmedStopDur' */
                /* Event: '<S165>:76' */
                ESSR_ac_ESSC_ImmedStopDur(VeESSR_n_TransInSpdFlt,
                    VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                    ESSR_ac_B.TmpSignalConversionAtVeENGR_e_C,
                    ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                    VeESSR_M_SpnDwnAddtlTorq,
                    ESSR_ac_B.TmpSignalConversionAtVeHPMR_b_P, tmpRead_3,
                    ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                    &ESSR_ac_DW.ESSC_ImmedStopDur,
                    &ESSR_ac_PrevZCX.ESSC_ImmedStopDur,
                    &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                /* End of Outputs for SubSystem: '<S175>/ESSC_ImmedStopDur' */
            }
            else if (((uint32)VeESSR_e_STMTrigger_DS) == CeESSR_e_CoastDown)
            {
                /* Transition: '<S165>:220' */
                ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_CoastDown;

                /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                /* Entry 'CoastDown': '<S165>:126' */
                /* Event: '<S165>:101' */
                ESSR_ac_ESSC_ResetVars();

                /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                /* Outputs for Function Call SubSystem: '<S171>/ESSC_CoastDownEnt' */
                /* Event: '<S165>:133' */
                ESSR_ac_ESSC_CoastDownEnt
                    (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E);

                /* End of Outputs for SubSystem: '<S171>/ESSC_CoastDownEnt' */

                /* Outputs for Function Call SubSystem: '<S171>/ESSC_CoastDownDur' */
                /* Event: '<S165>:134' */
                ESSR_ac_ESSC_CoastDownDur(VeESSR_n_TransInSpdFlt,
                    ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_E,
                    ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E, tmpRead_4,
                    tmpRead_5, ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d,
                    ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_e,
                    ESSR_ac_B.TmpSignalConversionAtVeTRNR_e_A, tmpRead_7);

                /* End of Outputs for SubSystem: '<S171>/ESSC_CoastDownDur' */
            }
            else
            {
                /* Outputs for Function Call SubSystem: '<S174>/ESSC_EngRunDur' */
                /* Event: '<S165>:68' */
                ESSR_ac_ESSC_EngRunDur(ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                                       VeESSR_n_TransInSpdFlt,
                                       ESSR_ac_B.TmpSignalConversionAtVeHSER_dn_,
                                       ESSR_ac_B.TmpSignalConversionAtVeHSER_n_I,
                                       ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_E,
                                       ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                       rtb_UnitDelay_op,
                                       ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R,
                                       &ESSR_ac_DW.ESSC_EngRunDur,
                                       &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn,
                                       &ESSR_ac_DW.VeESSR_M_BCTiMargin_DS);

                /* End of Outputs for SubSystem: '<S174>/ESSC_EngRunDur' */
            }
            break;

          case ESSR_ac_IN_EngStartCtrl:
            ESSR_ac_EngStartCtrl(&rtb_Switch1_ac, &rtb_Logical3_nsq,
                                 &Dsr_STMTrigger, &Dsr_EngStrtType);
            break;

          case ESSR_ac_IN_EngStopCtrl:
            /* During 'EngStopCtrl': '<S165>:13' */
            if ((((uint32)VeESSR_e_STMTrigger_DS) == CeESSR_e_ImmedStopReq) ||
                    (((uint32)VeESSR_e_STMTrigger_DS) == CeESSR_e_EngFail))
            {
                /* Transition: '<S165>:38' */
                /* Exit Internal 'EngStopCtrl': '<S165>:13' */
                ESSR_ac_DW.is_EngStopCtrl = ESSR_ac_IN_NO_ACTIVE_CHILD;

                /* Outputs for Function Call SubSystem: '<S177>/MainEngStopExit' */
                /* Exit 'EngStopCtrl': '<S165>:13' */
                /* Event: '<S165>:74' */
                ESSR_ac_MainEngStopExit();

                /* End of Outputs for SubSystem: '<S177>/MainEngStopExit' */
                ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_ImmedStop;

                /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                /* Entry 'ImmedStop': '<S165>:5' */
                /* Event: '<S165>:101' */
                ESSR_ac_ESSC_ResetVars();

                /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                /* Outputs for Function Call SubSystem: '<S175>/ESSC_ImmedStopEnt' */
                /* Event: '<S165>:75' */
                ESSR_ac_ESSC_ImmedStopEnt(VeESSR_n_TransInSpdFlt,
                    ESSR_ac_B.TmpSignalConversionAtVeTRAR_e_H,
                    ESSR_ac_B.TmpSignalConversionAtVeTRAR_M_E);

                /* End of Outputs for SubSystem: '<S175>/ESSC_ImmedStopEnt' */

                /* Outputs for Function Call SubSystem: '<S175>/ESSC_ImmedStopDur' */
                /* Event: '<S165>:76' */
                ESSR_ac_ESSC_ImmedStopDur(VeESSR_n_TransInSpdFlt,
                    VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                    ESSR_ac_B.TmpSignalConversionAtVeENGR_e_C,
                    ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                    VeESSR_M_SpnDwnAddtlTorq,
                    ESSR_ac_B.TmpSignalConversionAtVeHPMR_b_P, tmpRead_3,
                    ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                    &ESSR_ac_DW.ESSC_ImmedStopDur,
                    &ESSR_ac_PrevZCX.ESSC_ImmedStopDur,
                    &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                /* End of Outputs for SubSystem: '<S175>/ESSC_ImmedStopDur' */
            }
            else
            {
                switch (VeESSR_e_STMTrigger_DS)
                {
                  case CeESSR_e_EngRun:
                    /* Transition: '<S165>:39' */
                    /* Exit Internal 'EngStopCtrl': '<S165>:13' */
                    ESSR_ac_DW.is_EngStopCtrl = ESSR_ac_IN_NO_ACTIVE_CHILD;

                    /* Outputs for Function Call SubSystem: '<S177>/MainEngStopExit' */
                    /* Exit 'EngStopCtrl': '<S165>:13' */
                    /* Event: '<S165>:74' */
                    ESSR_ac_MainEngStopExit();

                    /* End of Outputs for SubSystem: '<S177>/MainEngStopExit' */
                    ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_EngRunning;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'EngRunning': '<S165>:12' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                    /* Outputs for Function Call SubSystem: '<S174>/ESSC_EngRunEnt' */
                    /* Event: '<S165>:67' */
                    ESSR_ac_ESSC_EngRunEnt();

                    /* End of Outputs for SubSystem: '<S174>/ESSC_EngRunEnt' */

                    /* Outputs for Function Call SubSystem: '<S174>/ESSC_EngRunDur' */
                    /* Event: '<S165>:68' */
                    ESSR_ac_ESSC_EngRunDur
                        (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                         VeESSR_n_TransInSpdFlt,
                         ESSR_ac_B.TmpSignalConversionAtVeHSER_dn_,
                         ESSR_ac_B.TmpSignalConversionAtVeHSER_n_I,
                         ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_E,
                         ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                         rtb_UnitDelay_op,
                         ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R,
                         &ESSR_ac_DW.ESSC_EngRunDur,
                         &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn,
                         &ESSR_ac_DW.VeESSR_M_BCTiMargin_DS);

                    /* End of Outputs for SubSystem: '<S174>/ESSC_EngRunDur' */
                    break;

                  case CeESSR_e_CoastDown:
                    /* Transition: '<S165>:132' */
                    /* Exit Internal 'EngStopCtrl': '<S165>:13' */
                    ESSR_ac_DW.is_EngStopCtrl = ESSR_ac_IN_NO_ACTIVE_CHILD;

                    /* Outputs for Function Call SubSystem: '<S177>/MainEngStopExit' */
                    /* Exit 'EngStopCtrl': '<S165>:13' */
                    /* Event: '<S165>:74' */
                    ESSR_ac_MainEngStopExit();

                    /* End of Outputs for SubSystem: '<S177>/MainEngStopExit' */
                    ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_CoastDown;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'CoastDown': '<S165>:126' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                    /* Outputs for Function Call SubSystem: '<S171>/ESSC_CoastDownEnt' */
                    /* Event: '<S165>:133' */
                    ESSR_ac_ESSC_CoastDownEnt
                        (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E);

                    /* End of Outputs for SubSystem: '<S171>/ESSC_CoastDownEnt' */

                    /* Outputs for Function Call SubSystem: '<S171>/ESSC_CoastDownDur' */
                    /* Event: '<S165>:134' */
                    ESSR_ac_ESSC_CoastDownDur(VeESSR_n_TransInSpdFlt,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_E,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E, tmpRead_4,
                        tmpRead_5, ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d,
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_e,
                        ESSR_ac_B.TmpSignalConversionAtVeTRNR_e_A, tmpRead_7);

                    /* End of Outputs for SubSystem: '<S171>/ESSC_CoastDownDur' */
                    break;

                  case CeESSR_e_StartReq:
                    /* Transition: '<S165>:41' */
                    /* Exit Internal 'EngStopCtrl': '<S165>:13' */
                    ESSR_ac_DW.is_EngStopCtrl = ESSR_ac_IN_NO_ACTIVE_CHILD;

                    /* Outputs for Function Call SubSystem: '<S177>/MainEngStopExit' */
                    /* Exit 'EngStopCtrl': '<S165>:13' */
                    /* Event: '<S165>:74' */
                    ESSR_ac_MainEngStopExit();

                    /* End of Outputs for SubSystem: '<S177>/MainEngStopExit' */
                    ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_EngStartCtrl;

                    /* Outputs for Function Call SubSystem: '<S176>/MainEngStartEntry' */
                    /* Entry 'EngStartCtrl': '<S165>:4' */
                    /* Event: '<S165>:69' */
                    ESSR_ac_MainEngStartEntry
                        (ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_E,
                         ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E);

                    /* End of Outputs for SubSystem: '<S176>/MainEngStartEntry' */
                    ESS_enter_internal_EngStartCtrl(&rtb_LogicalOperator_e,
                        &rtb_AND_dr, &rtb_AND_hz, &rtb_UnitDelay7,
                        &Dsr_EngStrtType);
                    break;

                  case CeESSR_e_EngStop:
                    /* Transition: '<S165>:25' */
                    /* Exit Internal 'EngStopCtrl': '<S165>:13' */
                    ESSR_ac_DW.is_EngStopCtrl = ESSR_ac_IN_NO_ACTIVE_CHILD;

                    /* Outputs for Function Call SubSystem: '<S177>/MainEngStopExit' */
                    /* Exit 'EngStopCtrl': '<S165>:13' */
                    /* Event: '<S165>:74' */
                    ESSR_ac_MainEngStopExit();

                    /* End of Outputs for SubSystem: '<S177>/MainEngStopExit' */
                    ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_EngOff;

                    /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                    /* Entry 'EngOff': '<S165>:1' */
                    /* Event: '<S165>:101' */
                    ESSR_ac_ESSC_ResetVars();

                    /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                    /* Outputs for Function Call SubSystem: '<S173>/ESSC_EngOffEnt' */
                    /* Event: '<S165>:65' */
                    ESSR_ac_ESSC_EngOffEnt
                        (ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_H);

                    /* End of Outputs for SubSystem: '<S173>/ESSC_EngOffEnt' */

                    /* Outputs for Function Call SubSystem: '<S173>/ESSC_EngOffDur' */
                    /* Switch: '<S242>/Switch' incorporates:
                     *  Constant: '<S256>/Calib'
                     *  Constant: '<S269>/Calib'
                     *  Constant: '<S270>/Calib'
                     *  Logic: '<S242>/AND2'
                     */
                    /* Event: '<S165>:66' */
                    if ((HeESSR_b_CltchStrtEquipped) &&
                            (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_C))
                    {
                        rtb_TmpSignalConversionAtVeOHSR =
                            KeESSR_t_MinTmEngOffCltchStrt;
                    }
                    else
                    {
                        rtb_TmpSignalConversionAtVeOHSR = KeESSR_t_MinTmEngOff;
                    }

                    /* Switch: '<S260>/Switch1' incorporates:
                     *  Constant: '<S242>/TRUE Constant'
                     *  Constant: '<S249>/Constant'
                     *  Constant: '<S250>/Constant'
                     *  Constant: '<S261>/Calib'
                     *  Logic: '<S242>/AND1'
                     *  RelationalOperator: '<S242>/Comparison1'
                     *  RelationalOperator: '<S242>/Comparison4'
                     *  SignalConversion generated from: '<S2>/VeHSER_e_RngEqnSel'
                     */
                    if (KeESSR_b_CheckGearForStart)
                    {
                        rtb_UnitDelay_op = ((CeHSER_e_UseM1Eqn == ((uint32)
                                              ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R))
                                            || (((uint32)
                                              ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R)
                                                == CeHSER_e_UseM2Eqn));
                    }
                    else
                    {
                        rtb_UnitDelay_op = true;
                    }

                    /* Switch: '<S259>/Switch1' incorporates:
                     *  Constant: '<S245>/Constant'
                     *  DataStoreRead: '<S242>/Dsr_STMTmr1'
                     *  DataStoreWrite: '<S242>/Dsw_STMTrigger'
                     *  Logic: '<S242>/AND'
                     *  Logic: '<S242>/Logical2'
                     *  RelationalOperator: '<S242>/Greater  Than'
                     */
                    if ((((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_F) ||
                            (VeESSR_t_STMTmr_DS >
                             rtb_TmpSignalConversionAtVeOHSR)) &&
                            (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E)) &&
                            rtb_UnitDelay_op)
                    {
                        VeESSR_e_STMTrigger_DS = CeESSR_e_StartReq;
                    }

                    /* RelationalOperator: '<S242>/Comparison3' incorporates:
                     *  RelationalOperator: '<S242>/Comparison2'
                     *  RelationalOperator: '<S242>/Comparison5'
                     *  SignalConversion generated from: '<S2>/VeSTRR_e_HybStrtrSt'
                     *  Switch: '<S242>/Switch4'
                     */
                    rtb_UnitDelay_h_tmp =
                        ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_H;

                    /* UnitDelay: '<S287>/Unit Delay' incorporates:
                     *  Constant: '<S252>/Constant'
                     *  RelationalOperator: '<S242>/Comparison3'
                     */
                    rtb_UnitDelay_op = (((uint32)rtb_UnitDelay_h_tmp) ==
                                        CeSTRR_e_EngStoppingSt);

                    /* Switch: '<S242>/Switch4' */
                    if (!rtb_UnitDelay_op)
                    {
                        /* Switch: '<S242>/Switch3' incorporates:
                         *  Constant: '<S253>/Constant'
                         *  Constant: '<S254>/Constant'
                         *  Constant: '<S255>/Constant'
                         *  DataStoreWrite: '<S242>/Data Store Write'
                         *  RelationalOperator: '<S242>/Comparison5'
                         *  Switch: '<S242>/Switch4'
                         */
                        if (((uint32)rtb_UnitDelay_h_tmp) == CeSTRR_e_KeyOffSt)
                        {
                            VeESSR_e_HybEngSysActv_DS = CeESSR_e_HybEngDisabled;
                        }
                        else
                        {
                            VeESSR_e_HybEngSysActv_DS =
                                CeESSR_e_HybEngEnabledOff;
                        }
                    }

                    /* UnitDelay: '<S287>/Unit Delay' incorporates:
                     *  DataStoreRead: '<S242>/Data Store Read1'
                     *  Logic: '<S242>/Logical1'
                     */
                    rtb_UnitDelay_op = ((VeESSR_b_NbTgtReq_DS) &&
                                        rtb_UnitDelay_op);

                    /* Switch: '<S242>/Switch1' incorporates:
                     *  DataStoreWrite: '<S242>/Dsw_InhibitShiftToMode2'
                     */
                    VeESSR_b_NbTgtReq_DS = rtb_UnitDelay_op;

                    /* Switch: '<S242>/Switch2' incorporates:
                     *  Constant: '<S242>/Constant Value'
                     *  Constant: '<S264>/Calib'
                     *  DataStoreWrite: '<S242>/Dsw_InputSpeedProfile1'
                     */
                    if (rtb_UnitDelay_op)
                    {
                        VeESSR_n_NbTgt_DS = 0.0F;
                    }
                    else
                    {
                        VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;
                    }

                    /* DataStoreWrite: '<S242>/Dsw_STMTmr' incorporates:
                     *  Constant: '<S257>/Calib'
                     *  DataStoreRead: '<S242>/Dsr_STMTmr'
                     *  Sum: '<S242>/Summation'
                     */
                    VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

                    /* DataStoreWrite: '<S242>/Dsw_STMTmr1' incorporates:
                     *  Constant: '<S257>/Calib'
                     *  DataStoreRead: '<S242>/Dsr_STMTmr4'
                     *  Sum: '<S242>/Summation2'
                     */
                    VeESSR_t_MainSTMTmr_DS = VeESSR_t_MainSTMTmr_DS +
                        HeESSR_t_MedTEB_dT;

                    /* Abs: '<S248>/Abs' incorporates:
                     *  Constant: '<S257>/Calib'
                     *  Constant: '<S262>/Calib'
                     *  Product: '<S248>/Multiplication'
                     */
                    rtb_Abs_bj = fabsf(KeESSR_dscl_RampDownRate *
                                       HeESSR_t_MedTEB_dT);

                    /* Gain: '<S248>/Gain' */
                    rtb_Gain_fa = -rtb_Abs_bj;

                    /* Sum: '<S248>/Sum' incorporates:
                     *  Constant: '<S267>/Calib'
                     *  DataStoreRead: '<S242>/Dsr_SpdCtlGainMod1'
                     */
                    rtb_TmpSignalConversionAtVeVSDR = KeESSR_scl_SpdCtrlEngOff -
                        VeESSR_scl_SpdCtlGainMod_DS;

                    /* Outputs for Atomic SubSystem: '<S248>/Limiter1' */
                    /* Switch: '<S282>/Switch1' incorporates:
                     *  RelationalOperator: '<S282>/Relational Operator'
                     */
                    if (rtb_Abs_bj >= rtb_TmpSignalConversionAtVeVSDR)
                    {
                        /* UnitDelay: '<S274>/Unit Delay' */
                        rtb_Abs_bj = rtb_TmpSignalConversionAtVeVSDR;
                    }

                    /* Switch: '<S282>/Switch' incorporates:
                     *  RelationalOperator: '<S282>/Relational Operator1'
                     */
                    if (rtb_Abs_bj > rtb_Gain_fa)
                    {
                        rtb_Gain_fa = rtb_Abs_bj;
                    }

                    /* End of Outputs for SubSystem: '<S248>/Limiter1' */

                    /* Sum: '<S248>/Sum1' incorporates:
                     *  DataStoreRead: '<S242>/Dsr_SpdCtlGainMod1'
                     */
                    rtb_Gain_fa += VeESSR_scl_SpdCtlGainMod_DS;

                    /* Outputs for Atomic SubSystem: '<S248>/Limiter2' */
                    /* Switch: '<S283>/Switch1' incorporates:
                     *  Constant: '<S242>/Constant Value7'
                     *  RelationalOperator: '<S283>/Relational Operator'
                     */
                    if (2.0F < rtb_Gain_fa)
                    {
                        /* UnitDelay: '<S274>/Unit Delay' */
                        rtb_Abs_bj = 2.0F;
                    }
                    else
                    {
                        /* UnitDelay: '<S274>/Unit Delay' */
                        rtb_Abs_bj = rtb_Gain_fa;
                    }

                    /* Switch: '<S283>/Switch' incorporates:
                     *  Constant: '<S242>/Constant Value6'
                     *  DataStoreWrite: '<S242>/Dsw_SpdCtlGainMod1'
                     *  RelationalOperator: '<S283>/Relational Operator1'
                     */
                    if (rtb_Abs_bj > 0.0F)
                    {
                        VeESSR_scl_SpdCtlGainMod_DS = rtb_Abs_bj;
                    }
                    else
                    {
                        VeESSR_scl_SpdCtlGainMod_DS = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S248>/Limiter2' */

                    /* Abs: '<S247>/Abs' incorporates:
                     *  Constant: '<S257>/Calib'
                     *  Constant: '<S263>/Calib'
                     *  Product: '<S247>/Multiplication'
                     */
                    rtb_Abs_bj = fabsf(KeESSR_dscl_TorqCancelRampOutRt *
                                       HeESSR_t_MedTEB_dT);

                    /* Gain: '<S247>/Gain' */
                    rtb_Gain_fa = -rtb_Abs_bj;

                    /* Outputs for Atomic SubSystem: '<S247>/Limiter1' */
                    /* Switch: '<S280>/Switch1' incorporates:
                     *  Constant: '<S242>/Constant Value5'
                     *  DataStoreRead: '<S242>/Dsr_TorqCancelDsrd'
                     *  RelationalOperator: '<S280>/Relational Operator'
                     *  Sum: '<S247>/Sum'
                     */
                    if (rtb_Abs_bj >= (0.0F - VeESSR_k_TorqCancelGain_DS))
                    {
                        /* UnitDelay: '<S274>/Unit Delay' */
                        rtb_Abs_bj = 0.0F - VeESSR_k_TorqCancelGain_DS;
                    }

                    /* Switch: '<S280>/Switch' incorporates:
                     *  RelationalOperator: '<S280>/Relational Operator1'
                     */
                    if (rtb_Abs_bj > rtb_Gain_fa)
                    {
                        rtb_Gain_fa = rtb_Abs_bj;
                    }

                    /* End of Outputs for SubSystem: '<S247>/Limiter1' */

                    /* Sum: '<S247>/Sum1' incorporates:
                     *  DataStoreRead: '<S242>/Dsr_TorqCancelDsrd'
                     */
                    rtb_Gain_fa += VeESSR_k_TorqCancelGain_DS;

                    /* Outputs for Atomic SubSystem: '<S247>/Limiter2' */
                    /* Switch: '<S281>/Switch1' incorporates:
                     *  Constant: '<S242>/Constant Value4'
                     *  RelationalOperator: '<S281>/Relational Operator'
                     */
                    if (2.0F < rtb_Gain_fa)
                    {
                        /* UnitDelay: '<S274>/Unit Delay' */
                        rtb_Abs_bj = 2.0F;
                    }
                    else
                    {
                        /* UnitDelay: '<S274>/Unit Delay' */
                        rtb_Abs_bj = rtb_Gain_fa;
                    }

                    /* Switch: '<S281>/Switch' incorporates:
                     *  Constant: '<S242>/Constant Value3'
                     *  DataStoreWrite: '<S242>/Dsw_TorqCancelDsrd'
                     *  RelationalOperator: '<S281>/Relational Operator1'
                     */
                    if (rtb_Abs_bj > 0.0F)
                    {
                        VeESSR_k_TorqCancelGain_DS = rtb_Abs_bj;
                    }
                    else
                    {
                        VeESSR_k_TorqCancelGain_DS = 0.0F;
                    }

                    /* End of Outputs for SubSystem: '<S247>/Limiter2' */

                    /* SignalConversion generated from: '<S246>/Variant Source' incorporates:
                     *  Gain: '<S246>/Gain'
                     *  Lookup_n-D: '<S278>/Vector'
                     *  MinMax: '<S246>/MinMax'
                     *  Sum: '<S246>/Summation1'
                     */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

                    /* VariantMerge generated from: '<S246>/Variant Source' incorporates:
                     *  Constant: '<S246>/Constant Value1'
                     */
                    rtb_Sum2_fr = 0.0F;

#else

                    /* Outputs for Atomic SubSystem: '<S246>/GradientLimiter' */
                    /* MinMax: '<S246>/MinMax' incorporates:
                     *  Constant: '<S246>/Constant Value'
                     *  Gain: '<S246>/Gain'
                     */
                    VeESSR_M_EngOffEngFricEngStrtTorq = fmaxf
                        (-VeESSR_M_EngTrqAct_Lmtd, 0.0F);

                    /* Lookup_n-D: '<S278>/Vector' incorporates:
                     *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                     */
                    VeESSR_M_EngOffECTEngStrtTorq = look1_iflf_binlcapw
                        (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const
                           float32 *)&(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((
                           const float32 *)&(KtESSR_M_ECTAddtlEngStrtTorq[0])),
                         6U);

                    /* Sum: '<S246>/Summation1' incorporates:
                     *  Constant: '<S275>/Calib'
                     */
                    VeESSR_M_EngOffEngStrtTorqRaw =
                        (VeESSR_M_EngOffEngFricEngStrtTorq +
                         KeESSR_M_EngOffEngPulseEngStrtTorq) +
                        VeESSR_M_EngOffECTEngStrtTorq;

                    /* Sum: '<S274>/Sum2' incorporates:
                     *  UnitDelay: '<S274>/Unit Delay'
                     */
                    rtb_Sum2_fr = VeESSR_M_EngOffEngStrtTorqRaw -
                        ESSR_ac_DW.UnitDelay_DSTATE_ie;

                    /* Outputs for Atomic SubSystem: '<S274>/Limiter' */
                    /* Switch: '<S279>/Switch1' incorporates:
                     *  Constant: '<S277>/Calib'
                     *  RelationalOperator: '<S279>/Relational Operator'
                     */
                    if (KeESSR_dM_EngOffEngStrtTorqLU < rtb_Sum2_fr)
                    {
                        /* Switch: '<S279>/Switch1' */
                        rtb_Sum2_fr = KeESSR_dM_EngOffEngStrtTorqLU;
                    }

                    /* Switch: '<S279>/Switch' incorporates:
                     *  Constant: '<S276>/Calib'
                     *  RelationalOperator: '<S279>/Relational Operator1'
                     */
                    if (rtb_Sum2_fr <= KeESSR_dM_EngOffEngStrtTorqLD)
                    {
                        rtb_Sum2_fr = KeESSR_dM_EngOffEngStrtTorqLD;
                    }

                    /* End of Outputs for SubSystem: '<S274>/Limiter' */

                    /* Sum: '<S274>/Sum3' incorporates:
                     *  UnitDelay: '<S274>/Unit Delay'
                     */
                    rtb_Sum2_fr += ESSR_ac_DW.UnitDelay_DSTATE_ie;

                    /* Update for UnitDelay: '<S274>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_ie = rtb_Sum2_fr;

                    /* End of Outputs for SubSystem: '<S246>/GradientLimiter' */
#endif

                    /* SignalConversion generated from: '<S246>/Variant Source' */
                    VeESSR_M_EngOffEngStrtTorqLmtd = rtb_Sum2_fr;

                    /* DataStoreWrite: '<S242>/Data Store Write2' */
                    VeESSR_M_EngStrtTorq_DS = VeESSR_M_EngOffEngStrtTorqLmtd;

                    /* DataStoreWrite: '<S242>/Data Store Write1' incorporates:
                     *  Constant: '<S242>/Constant'
                     */
                    ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = 0.0F;

                    /* DataStoreWrite: '<S242>/Dsw_AEMDMtrAGain' incorporates:
                     *  Constant: '<S265>/Calib'
                     */
                    VeESSR_scl_AEMDMtrAGain_DS = KeESSR_scl_AEMDMtrAGain_EngOff;

                    /* DataStoreWrite: '<S242>/Dsw_AEMDMtrBGain' incorporates:
                     *  Constant: '<S266>/Calib'
                     */
                    VeESSR_scl_AEMDMtrBGain_DS = KeESSR_scl_AEMDMtrBGain_EngOff;

                    /* Logic: '<S242>/Logical' incorporates:
                     *  Constant: '<S251>/Constant'
                     *  RelationalOperator: '<S242>/Comparison2'
                     */
                    rtb_Logical_e = (rtb_Logical_e && (((uint32)
                                       rtb_UnitDelay_h_tmp) == CeSTRR_e_EngOffSt));

                    /* Outputs for Atomic SubSystem: '<S242>/Turn Off Delay Time' */
                    /* Outputs for Atomic SubSystem: '<S273>/EdgeFalling1' */
                    /* Logic: '<S287>/AND' incorporates:
                     *  Logic: '<S287>/OR1'
                     *  UnitDelay: '<S287>/Unit Delay'
                     */
                    rtb_UnitDelay_op = ((!rtb_Logical_e) &&
                                        (ESSR_ac_DW.UnitDelay_DSTATE_hx));

                    /* Update for UnitDelay: '<S287>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_hx = rtb_Logical_e;

                    /* End of Outputs for SubSystem: '<S273>/EdgeFalling1' */

                    /* Switch: '<S273>/Switch' */
                    if (rtb_UnitDelay_op)
                    {
                        /* Switch: '<S273>/Switch' incorporates:
                         *  Constant: '<S268>/Calib'
                         */
                        rtb_Sum2_fr = KeESSR_t_ImmedStopMdHoldDelay;
                    }
                    else
                    {
                        /* Switch: '<S273>/Switch' incorporates:
                         *  Constant: '<S257>/Calib'
                         *  Constant: '<S273>/Constant Value1'
                         *  MinMax: '<S273>/Minimum'
                         *  Sum: '<S273>/Summation'
                         *  UnitDelay: '<S273>/Unit Delay'
                         */
                        rtb_Sum2_fr = fmaxf(ESSR_ac_DW.UnitDelay_DSTATE_dg -
                                            HeESSR_t_MedTEB_dT, 0.0F);
                    }

                    /* Update for UnitDelay: '<S273>/Unit Delay' */
                    ESSR_ac_DW.UnitDelay_DSTATE_dg = rtb_Sum2_fr;

                    /* If: '<S242>/If' incorporates:
                     *  Constant: '<S271>/Calib'
                     *  Constant: '<S273>/Constant Value2'
                     *  DataStoreRead: '<S242>/Dsr_STMTmr2'
                     *  Logic: '<S273>/AND'
                     *  RelationalOperator: '<S242>/Greater  Than1'
                     *  RelationalOperator: '<S273>/Greater  Than'
                     */
                    if (rtb_Logical_e || (rtb_Sum2_fr > 0.0F))
                    {
                        /* Outputs for IfAction SubSystem: '<S242>/If Action Subsystem' incorporates:
                         *  ActionPort: '<S258>/Action Port'
                         */
                        /* DataStoreWrite: '<S258>/Dsw_EngStrtStpMd2' incorporates:
                         *  Constant: '<S284>/Constant'
                         */
                        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_ImmediateStop;

                        /* End of Outputs for SubSystem: '<S242>/If Action Subsystem' */
                    }
                    else
                    {
                        if (VeESSR_t_STMTmr_DS > KeESSR_t_ResetFailTm)
                        {
                            /* Outputs for IfAction SubSystem: '<S242>/ResetFailed' incorporates:
                             *  ActionPort: '<S272>/Action Port'
                             */
                            /* DataStoreWrite: '<S272>/Data Store Write1' incorporates:
                             *  Constant: '<S272>/FALSE Constant2'
                             */
                            VeESSR_b_BumpStrtFailed_DS = false;

                            /* DataStoreWrite: '<S272>/Dsw_EngStartAbort' incorporates:
                             *  Constant: '<S272>/FALSE Constant1'
                             */
                            VeESSR_b_EngStartAbort_DS = false;

                            /* DataStoreWrite: '<S272>/Dsw_EngStartAbort1' incorporates:
                             *  Constant: '<S286>/Calib'
                             */
                            VeESSR_b_AStrtFailed_DS = KeESSR_b_ResetAStrtFailed;

                            /* DataStoreWrite: '<S272>/Dsw_EngStrtStpMd' incorporates:
                             *  Constant: '<S285>/Constant'
                             */
                            VeESSR_e_EngStrtStpMd_DS = CeESSR_e_Stop;

                            /* DataStoreWrite: '<S272>/Dsw_StrtStopFail' incorporates:
                             *  Constant: '<S272>/FALSE Constant'
                             */
                            VeESSR_b_StrtStopFail_DS = false;

                            /* End of Outputs for SubSystem: '<S242>/ResetFailed' */
                        }
                    }

                    /* End of Outputs for SubSystem: '<S242>/Turn Off Delay Time' */
                    /* End of Outputs for SubSystem: '<S173>/ESSC_EngOffDur' */
                    break;

                  default:
                    /* Outputs for Function Call SubSystem: '<S177>/MainEngStopDur' */
                    /* Switch: '<S518>/Switch1' incorporates:
                     *  Constant: '<S512>/Constant'
                     *  Constant: '<S513>/Constant'
                     *  DataStoreWrite: '<S509>/Dsw_STMTrigger'
                     *  Logic: '<S509>/AND'
                     *  Logic: '<S509>/NOT'
                     *  RelationalOperator: '<S509>/Equal'
                     *  SignalConversion generated from: '<S2>/VeSTRR_e_EngStrtStopType'
                     */
                    /* Event: '<S165>:73' */
                    if ((((uint32)ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_E) ==
                            CeSTRR_e_StopImmed) &&
                            (!ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E))
                    {
                        VeESSR_e_STMTrigger_DS = CeESSR_e_ImmedStopReq;
                    }

                    /* End of Switch: '<S518>/Switch1' */

                    /* Switch: '<S519>/Switch1' incorporates:
                     *  Constant: '<S520>/Calib'
                     *  Constant: '<S521>/Calib'
                     *  Constant: '<S522>/Calib'
                     *  Constant: '<S523>/Calib'
                     *  DataStoreRead: '<S509>/Data Store Read4'
                     *  DataStoreRead: '<S509>/Data Store Read6'
                     *  DataStoreWrite: '<S509>/Data Store Write'
                     *  Logic: '<S509>/Logical Operator1'
                     *  Logic: '<S509>/Logical Operator3'
                     *  Logic: '<S509>/NOT4'
                     *  RelationalOperator: '<S509>/Greater  Than2'
                     *  RelationalOperator: '<S509>/Greater  Than3'
                     */
                    VeESSR_b_CoastDownTrigger_DS =
                        (((((KeESSR_b_EnblFtrBackupStrt) &&
                            (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B)) &&
                           (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
                            KeESSR_Cnt_BackupStrtMaxAttmpts)) ||
                          (((KeESSR_b_EnblFtrBumpStrt) &&
                            (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d)) &&
                           (VeESSR_Cnt_BumpStrtAttmptCntr_DS <
                            KeESSR_Cnt_BumpStrtMaxAttmpts))) ||
                         (VeESSR_b_AStopCoastDwnLmp));

                    /* If: '<S509>/If' incorporates:
                     *  Constant: '<S516>/Constant'
                     *  Constant: '<S524>/Calib'
                     *  DataStoreRead: '<S509>/Dsr_EngStartStopSt'
                     *  DataStoreRead: '<S509>/Dsr_InputSpeedProfile'
                     *  Logic: '<S509>/NOT1'
                     *  RelationalOperator: '<S509>/Comparison1'
                     *  RelationalOperator: '<S509>/Equal1'
                     */
                    if ((VeESSR_n_InputSpeedProfile_DS >
                            KeESSR_n_AStpMaxCancelRPM) || (((uint32)
                            VeESSR_e_EngStartStopSt_DS) == CeESSR_e_FinishStopSt))
                    {
                        /* Outputs for IfAction SubSystem: '<S509>/DmprOpenNoPC' incorporates:
                         *  ActionPort: '<S514>/Action Port'
                         */
                        /* Abs: '<S527>/Abs' incorporates:
                         *  Constant: '<S528>/Calib'
                         *  Constant: '<S529>/Calib'
                         *  Product: '<S527>/Multiplication'
                         */
                        rtb_LeESSI_M_MtrB_TorqCmnd = fabsf
                            (KeESSR_dscl_TorqCancelRampOutRt *
                             HeESSR_t_MedTEB_dT);

                        /* Gain: '<S527>/Gain' */
                        rtb_TmpSignalConversionAtVeVSDR =
                            -rtb_LeESSI_M_MtrB_TorqCmnd;

                        /* Outputs for Atomic SubSystem: '<S527>/Limiter1' */
                        /* Switch: '<S530>/Switch1' incorporates:
                         *  Constant: '<S514>/Constant Value1'
                         *  DataStoreRead: '<S514>/Dsr_TorqCancelDsrd1'
                         *  RelationalOperator: '<S530>/Relational Operator'
                         *  Sum: '<S527>/Sum'
                         */
                        if (rtb_LeESSI_M_MtrB_TorqCmnd >= (0.0F -
                                VeESSR_k_TorqCancelGain_DS))
                        {
                            /* Switch: '<S531>/Switch1' */
                            rtb_LeESSI_M_MtrB_TorqCmnd = 0.0F -
                                VeESSR_k_TorqCancelGain_DS;
                        }

                        /* End of Switch: '<S530>/Switch1' */

                        /* Switch: '<S530>/Switch' incorporates:
                         *  RelationalOperator: '<S530>/Relational Operator1'
                         */
                        if (rtb_LeESSI_M_MtrB_TorqCmnd >
                                rtb_TmpSignalConversionAtVeVSDR)
                        {
                            rtb_TmpSignalConversionAtVeVSDR =
                                rtb_LeESSI_M_MtrB_TorqCmnd;
                        }

                        /* End of Switch: '<S530>/Switch' */
                        /* End of Outputs for SubSystem: '<S527>/Limiter1' */

                        /* Sum: '<S527>/Sum1' incorporates:
                         *  DataStoreRead: '<S514>/Dsr_TorqCancelDsrd1'
                         */
                        rtb_TmpSignalConversionAtVeVSDR +=
                            VeESSR_k_TorqCancelGain_DS;

                        /* Outputs for Atomic SubSystem: '<S527>/Limiter2' */
                        /* Switch: '<S531>/Switch1' incorporates:
                         *  Constant: '<S514>/Constant Value5'
                         *  RelationalOperator: '<S531>/Relational Operator'
                         */
                        if (2.0F < rtb_TmpSignalConversionAtVeVSDR)
                        {
                            /* Switch: '<S531>/Switch1' */
                            rtb_LeESSI_M_MtrB_TorqCmnd = 2.0F;
                        }
                        else
                        {
                            /* Switch: '<S531>/Switch1' */
                            rtb_LeESSI_M_MtrB_TorqCmnd =
                                rtb_TmpSignalConversionAtVeVSDR;
                        }

                        /* End of Switch: '<S531>/Switch1' */

                        /* Switch: '<S531>/Switch' incorporates:
                         *  Constant: '<S514>/Constant Value4'
                         *  RelationalOperator: '<S531>/Relational Operator1'
                         */
                        if (rtb_LeESSI_M_MtrB_TorqCmnd > -2.0F)
                        {
                            /* Merge: '<S509>/Merge' */
                            rtb_TmpSignalConversionAtVeVSDR =
                                rtb_LeESSI_M_MtrB_TorqCmnd;
                        }
                        else
                        {
                            /* Merge: '<S509>/Merge' */
                            rtb_TmpSignalConversionAtVeVSDR = -2.0F;
                        }

                        /* End of Switch: '<S531>/Switch' */
                        /* End of Outputs for SubSystem: '<S527>/Limiter2' */
                        /* End of Outputs for SubSystem: '<S509>/DmprOpenNoPC' */
                    }
                    else
                    {
                        /* Outputs for IfAction SubSystem: '<S509>/DmprOpenPC' incorporates:
                         *  ActionPort: '<S515>/Action Port'
                         */
                        /* Abs: '<S532>/Abs' incorporates:
                         *  Constant: '<S533>/Calib'
                         *  Constant: '<S535>/Calib'
                         *  Product: '<S532>/Multiplication'
                         */
                        rtb_LeESSI_M_MtrB_TorqCmnd = fabsf
                            (KeESSR_dscl_TorqCancelRampInRt * HeESSR_t_MedTEB_dT);

                        /* Gain: '<S532>/Gain' */
                        rtb_TmpSignalConversionAtVeVSDR =
                            -rtb_LeESSI_M_MtrB_TorqCmnd;

                        /* Sum: '<S532>/Sum' incorporates:
                         *  Constant: '<S534>/Calib'
                         *  DataStoreRead: '<S515>/Dsr_TorqCancelDsrd1'
                         */
                        rtb_LeESSI_M_InputTorqMaxTact =
                            KeESSR_K_AStopTorqCancelGain -
                            VeESSR_k_TorqCancelGain_DS;

                        /* Outputs for Atomic SubSystem: '<S532>/Limiter1' */
                        /* Switch: '<S536>/Switch1' incorporates:
                         *  RelationalOperator: '<S536>/Relational Operator'
                         */
                        if (rtb_LeESSI_M_MtrB_TorqCmnd >=
                                rtb_LeESSI_M_InputTorqMaxTact)
                        {
                            /* Switch: '<S537>/Switch1' */
                            rtb_LeESSI_M_MtrB_TorqCmnd =
                                rtb_LeESSI_M_InputTorqMaxTact;
                        }

                        /* End of Switch: '<S536>/Switch1' */

                        /* Switch: '<S536>/Switch' incorporates:
                         *  RelationalOperator: '<S536>/Relational Operator1'
                         */
                        if (rtb_LeESSI_M_MtrB_TorqCmnd >
                                rtb_TmpSignalConversionAtVeVSDR)
                        {
                            rtb_TmpSignalConversionAtVeVSDR =
                                rtb_LeESSI_M_MtrB_TorqCmnd;
                        }

                        /* End of Switch: '<S536>/Switch' */
                        /* End of Outputs for SubSystem: '<S532>/Limiter1' */

                        /* Sum: '<S532>/Sum1' incorporates:
                         *  DataStoreRead: '<S515>/Dsr_TorqCancelDsrd1'
                         */
                        rtb_TmpSignalConversionAtVeVSDR +=
                            VeESSR_k_TorqCancelGain_DS;

                        /* Outputs for Atomic SubSystem: '<S532>/Limiter2' */
                        /* Switch: '<S537>/Switch1' incorporates:
                         *  Constant: '<S515>/Constant Value5'
                         *  RelationalOperator: '<S537>/Relational Operator'
                         */
                        if (2.0F < rtb_TmpSignalConversionAtVeVSDR)
                        {
                            /* Switch: '<S537>/Switch1' */
                            rtb_LeESSI_M_MtrB_TorqCmnd = 2.0F;
                        }
                        else
                        {
                            /* Switch: '<S537>/Switch1' */
                            rtb_LeESSI_M_MtrB_TorqCmnd =
                                rtb_TmpSignalConversionAtVeVSDR;
                        }

                        /* End of Switch: '<S537>/Switch1' */

                        /* Switch: '<S537>/Switch' incorporates:
                         *  Constant: '<S515>/Constant Value4'
                         *  RelationalOperator: '<S537>/Relational Operator1'
                         */
                        if (rtb_LeESSI_M_MtrB_TorqCmnd > -2.0F)
                        {
                            /* Merge: '<S509>/Merge' */
                            rtb_TmpSignalConversionAtVeVSDR =
                                rtb_LeESSI_M_MtrB_TorqCmnd;
                        }
                        else
                        {
                            /* Merge: '<S509>/Merge' */
                            rtb_TmpSignalConversionAtVeVSDR = -2.0F;
                        }

                        /* End of Switch: '<S537>/Switch' */
                        /* End of Outputs for SubSystem: '<S532>/Limiter2' */
                        /* End of Outputs for SubSystem: '<S509>/DmprOpenPC' */
                    }

                    /* End of If: '<S509>/If' */

                    /* DataStoreWrite: '<S509>/Dsw_TorqCancelDsrd2' */
                    VeESSR_k_TorqCancelGain_DS = rtb_TmpSignalConversionAtVeVSDR;

                    /* DataStoreWrite: '<S509>/Dsw_STMTmr1' incorporates:
                     *  Constant: '<S517>/Calib'
                     *  DataStoreRead: '<S509>/Dsr_STMTmr4'
                     *  Sum: '<S509>/Summation2'
                     */
                    VeESSR_t_MainSTMTmr_DS = VeESSR_t_MainSTMTmr_DS +
                        HeESSR_t_MedTEB_dT;

                    /* DataStoreWrite: '<S509>/Dsw_AEMDMtrAGain' incorporates:
                     *  Constant: '<S525>/Calib'
                     */
                    VeESSR_scl_AEMDMtrAGain_DS =
                        KeESSR_scl_AEMDMtrAGain_MainStop;

                    /* DataStoreWrite: '<S509>/Dsw_AEMDMtrBGain' incorporates:
                     *  Constant: '<S526>/Calib'
                     */
                    VeESSR_scl_AEMDMtrBGain_DS =
                        KeESSR_scl_AEMDMtrBGain_MainStop;

                    /* End of Outputs for SubSystem: '<S177>/MainEngStopDur' */
                    (void)Rte_Read_VeENGR_e_EngDFSO_Req_Value(&tmpRead);
                    (void)Rte_Read_VeENGR_b_EngTLCLearnReq_Value(&tmpRead_0);
                    switch (ESSR_ac_DW.is_EngStopCtrl)
                    {
                      case ESSR_ac_IN_DisableFuel:
                        /* During 'DisableFuel': '<S165>:15' */
                        if (((uint32)Dsr_STMTrigger) == CeESSR_e_DamperLocked)
                        {
                            /* Transition: '<S165>:36' */
                            ESSR_ac_DW.is_EngStopCtrl = ESSR_ac_IN_RampDown;

                            /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                            /* Entry 'RampDown': '<S165>:16' */
                            /* Event: '<S165>:101' */
                            ESSR_ac_ESSC_ResetVars();

                            /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                            /* Outputs for Function Call SubSystem: '<S2450>/ESSC_RampDownEnt' */
                            /* Event: '<S165>:97' */
                            ESSR_ac_ESSC_RampDownEnt
                                (ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                                 ESSR_ac_B.TmpSignalConversionAtVeETQR_M_e,
                                 &ESSR_ac_B.ESSC_RampDownEnt,
                                 &ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt,
                                 &ESSR_ac_DW.NeESSR_k_EngStpProfNiDotGainAda);

                            /* End of Outputs for SubSystem: '<S2450>/ESSC_RampDownEnt' */

                            /* Outputs for Function Call SubSystem: '<S2450>/ESSC_RampDownDur' */
                            /* Event: '<S165>:98' */
                            ESSR_ac_ESSC_RampDownDur
                                (ESSR_ac_B.ESSC_RampDownEnt.Dsr_InputSpeedProfile1,
                                 VeESSR_n_TransInSpdFlt,
                                 ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                 VeESSR_M_SpnDwnAddtlTorq,
                                 ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                                 ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                                 ESSR_ac_B.TmpSignalConversionAtVeCSVR_v_V,
                                 VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                                 ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                                 ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_I,
                                 ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_C,
                                 VeESSR_b_AStopEngCOMLmp,
                                 VeESSR_b_AStopReStrtPrepLmp,
                                 &ESSR_ac_B.ESSC_RampDownDur,
                                 &ESSR_ac_DW.ESSC_RampDownDur,
                                 &ESSR_ac_PrevZCX.ESSC_RampDownDur,
                                 &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn,
                                 &ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt,
                                 &ESSR_ac_DW.NeESSR_k_EngStpProfNiDotGainAda);

                            /* End of Outputs for SubSystem: '<S2450>/ESSC_RampDownDur' */
                        }
                        else
                        {
                            /* Outputs for Function Call SubSystem: '<S2447>/DisableFuelDur' */
                            /* Event: '<S165>:96' */
                            ESSR_ac_DisableFuelDur
                                (ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                 ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                                 ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                                 ESSR_ac_B.TmpSignalConversionAtVeENGR_e_g,
                                 tmpRead, tmpRead_0,
                                 ESSR_ac_B.TmpSignalConversionAtVeESSR__no,
                                 ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                                 VeESSR_n_TransInSpdFlt,
                                 ESSR_ac_B.TmpSignalConversionAtVeETQR_M_e,
                                 ESSR_ac_B.TmpSignalConversionAtVeESPR_phi,
                                 ESSR_ac_B.TmpSignalConversionAtVeESPR_b_h,
                                 ESSR_ac_B.TmpSignalConversionAtVeESPR_b_E,
                                 VeESSR_b_AStopEngCOMLmp,
                                 &ESSR_ac_DW.DisableFuelDur,
                                 &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn,
                                 &ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt);

                            /* End of Outputs for SubSystem: '<S2447>/DisableFuelDur' */
                        }
                        break;

                      case ESSR_ac_IN_FinishStop:
                        /* Outputs for Function Call SubSystem: '<S2448>/ESSC_FinishStopDur' */
                        /* During 'FinishStop': '<S165>:9' */
                        /* Event: '<S165>:100' */
                        ESSR_ac_ESSC_FinishStopDur(VeESSR_n_TransInSpdFlt,
                            ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                            ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                            ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                            VeESSR_M_SpnDwnAddtlTorq,
                            ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_C,
                            ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_I,
                            VeESSR_b_AStopEngCOMLmp, VeESSR_b_AStopReStrtPrepLmp,
                            &ESSR_ac_DW.ESSC_FinishStopDur,
                            &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                        /* End of Outputs for SubSystem: '<S2448>/ESSC_FinishStopDur' */
                        break;

                      case ESSR_ac_IN_PrepForStop:
                        /* During 'PrepForStop': '<S165>:14' */
                        if (((uint32)Dsr_STMTrigger) == CeESSR_e_IdlePumpDwnAch)
                        {
                            /* Transition: '<S165>:35' */
                            ESSR_ac_DW.is_EngStopCtrl = ESSR_ac_IN_DisableFuel;

                            /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                            /* Entry 'DisableFuel': '<S165>:15' */
                            /* Event: '<S165>:101' */
                            ESSR_ac_ESSC_ResetVars();

                            /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                            /* Outputs for Function Call SubSystem: '<S2447>/DisableFuelEnt' */
                            /* Event: '<S165>:95' */
                            ESSR_ac_DisableFuelEnt();

                            /* End of Outputs for SubSystem: '<S2447>/DisableFuelEnt' */

                            /* Outputs for Function Call SubSystem: '<S2447>/DisableFuelDur' */
                            /* Event: '<S165>:96' */
                            ESSR_ac_DisableFuelDur
                                (ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                 ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                                 ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                                 ESSR_ac_B.TmpSignalConversionAtVeENGR_e_g,
                                 tmpRead, tmpRead_0,
                                 ESSR_ac_B.TmpSignalConversionAtVeESSR__no,
                                 ESSR_ac_B.TmpSignalConversionAtVeENGR_b_E,
                                 VeESSR_n_TransInSpdFlt,
                                 ESSR_ac_B.TmpSignalConversionAtVeETQR_M_e,
                                 ESSR_ac_B.TmpSignalConversionAtVeESPR_phi,
                                 ESSR_ac_B.TmpSignalConversionAtVeESPR_b_h,
                                 ESSR_ac_B.TmpSignalConversionAtVeESPR_b_E,
                                 VeESSR_b_AStopEngCOMLmp,
                                 &ESSR_ac_DW.DisableFuelDur,
                                 &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn,
                                 &ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt);

                            /* End of Outputs for SubSystem: '<S2447>/DisableFuelDur' */
                        }
                        else
                        {
                            (void)Rte_Read_VeETQR_M_EngCapacityMinRun_Value
                                (&rtb_Sum2_fr);
                            (void)Rte_Read_VeTFTR_T_TransOilTemp_Value
                                (&rtb_Gain_fa);
                            (void)Rte_Read_VeTAPR_b_AuxPumpRunning_Value
                                (&tmpRead_6);
                            (void)Rte_Read_VeINVR_e_MtrA_InvrtrSt_Value
                                (&tmpRead_2);
                            (void)Rte_Read_VeENGR_e_EngDFSO_St_Value(&tmpRead_1);
                            (void)Rte_Read_VeAATR_T_EstAmbAirTemp_Value
                                (&rtb_Abs_bj);

                            /* Outputs for Function Call SubSystem: '<S2449>/PrepForStopDur' */
                            /* Event: '<S165>:94' */
                            ESSR_ac_PrepForStopDur(VeESSR_n_TransInSpdFlt,
                                                   VeESSR_dn_NiDotMax,
                                                   VeESSR_dn_NiDotMin,
                                                   ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                                   rtb_Sum2_fr,
                                                   ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                                                   ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                                                   ESSR_ac_B.TmpSignalConversionAtVeENGR_e_C,
                                                   tmpRead_6, rtb_Abs_bj,
                                                   rtb_Gain_fa,
                                                   ESSR_ac_B.TmpSignalConversionAtVeESSR__no,
                                                   ESSR_ac_B.TmpSignalConversionAtVeESSR_M_k,
                                                   ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                                                   ESSR_ac_B.TmpSignalConversionAtVeESPR_b_h,
                                                   ESSR_ac_B.TmpSignalConversionAtVeESPR_b_E,
                                                   VeESSR_b_AStopEngCOMLmp,
                                                   ESSR_ac_B.TmpSignalConversionAtVeETQR_M_e,
                                                   tmpRead_1, tmpRead_2,
                                                   &ESSR_ac_DW.PrepForStopDur,
                                                   &ESSR_ac_PrevZCX.PrepForStopDur,
                                                   &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn,
                                                   &ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt);

                            /* End of Outputs for SubSystem: '<S2449>/PrepForStopDur' */
                        }
                        break;

                      default:
                        /* During 'RampDown': '<S165>:16' */
                        if (((uint32)Dsr_STMTrigger) == CeESSR_e_EngSpdTgtAch)
                        {
                            /* Transition: '<S165>:37' */
                            ESSR_ac_DW.is_EngStopCtrl = ESSR_ac_IN_FinishStop;

                            /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                            /* Entry 'FinishStop': '<S165>:9' */
                            /* Event: '<S165>:101' */
                            ESSR_ac_ESSC_ResetVars();

                            /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                            /* Outputs for Function Call SubSystem: '<S2448>/ESSC_FinishStopEnt' */
                            /* Switch: '<S2565>/Switch3' incorporates:
                             *  Constant: '<S2565>/Constant Value1'
                             *  Constant: '<S2627>/Calib'
                             *  DataStoreWrite: '<S2565>/Data Store Write1'
                             */
                            /* Event: '<S165>:99' */
                            if (!HeESSR_b_EngStrtTorq)
                            {
                                VeESSR_M_EngStrtTorq_DS = 0.0F;
                            }

                            /* End of Switch: '<S2565>/Switch3' */

                            /* Switch: '<S2565>/Switch2' incorporates:
                             *  Constant: '<S2626>/Calib'
                             *  DataStoreWrite: '<S2565>/Dsw_Dsbl_ICSRFor12vStart'
                             */
                            VeESSR_b_DsblNiClsdLoopCntrl_DS =
                                ((!HeESSR_b_EngStpEnbNiTrqMd) &&
                                 (VeESSR_b_DsblNiClsdLoopCntrl_DS));

                            /* DataStoreWrite: '<S2565>/Dsw_DsblNiClsdLoopCntrl1' incorporates:
                             *  Constant: '<S2628>/Calib'
                             */
                            VeESSR_M_MtrA_MaxTorq_DS = KeESSR_M_MtrAMax_Default;

                            /* DataStoreWrite: '<S2565>/Dsw_DsblNiClsdLoopCntrl2' incorporates:
                             *  Constant: '<S2629>/Calib'
                             */
                            VeESSR_M_MtrA_MinTorq_DS = KeESSR_M_MtrAMin_Default;

                            /* DataStoreWrite: '<S2565>/Dsw_EngStartStopSt' incorporates:
                             *  Constant: '<S2622>/Constant'
                             */
                            VeESSR_e_EngStartStopSt_DS = CeESSR_e_FinishStopSt;

                            /* DataStoreWrite: '<S2565>/Dsw_EngStrtStpMd2' incorporates:
                             *  Constant: '<S2625>/Constant'
                             */
                            VeESSR_e_EngStrtStpMd_DS = CeESSR_e_DisableFuel;

                            /* DataStoreWrite: '<S2565>/Dsw_EngStrtType1' incorporates:
                             *  Constant: '<S2631>/Calib'
                             */
                            VeESSR_e_TCM_StartStopType_DS =
                                KeESSR_e_TCM_StartStopType_FinishStop;

                            /* DataStoreWrite: '<S2565>/Dsw_EngStrtType2' incorporates:
                             *  Constant: '<S2624>/Constant'
                             */
                            VeESSR_e_TCM_TransitionStatus_DS = CeESSR_e_Stopng;

                            /* DataStoreWrite: '<S2565>/Dsw_InhibitShiftToMode' incorporates:
                             *  Constant: '<S2630>/Calib'
                             */
                            VeESSR_b_InhibitShiftToMode_DS =
                                KeESSR_b_ShftInhbtFinStopSt;

                            /* DataStoreWrite: '<S2565>/Dsw_InputSpeedProfile1' incorporates:
                             *  Constant: '<S2633>/Calib'
                             */
                            VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;

                            /* DataStoreWrite: '<S2565>/Dsw_StrtStpFailDTC' incorporates:
                             *  Constant: '<S2623>/Constant'
                             */
                            VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;

                            /* DataStoreWrite: '<S2565>/Dsw_TransFldPmpSel' incorporates:
                             *  Constant: '<S2632>/Calib'
                             */
                            VeESSR_e_TransFldPmpSel_DS =
                                KeESSR_e_TransFldPmpSelFinishStopSt;

                            /* End of Outputs for SubSystem: '<S2448>/ESSC_FinishStopEnt' */

                            /* Outputs for Function Call SubSystem: '<S2448>/ESSC_FinishStopDur' */
                            /* Event: '<S165>:100' */
                            ESSR_ac_ESSC_FinishStopDur(VeESSR_n_TransInSpdFlt,
                                ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                                ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                                ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                VeESSR_M_SpnDwnAddtlTorq,
                                ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_C,
                                ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_I,
                                VeESSR_b_AStopEngCOMLmp,
                                VeESSR_b_AStopReStrtPrepLmp,
                                &ESSR_ac_DW.ESSC_FinishStopDur,
                                &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                            /* End of Outputs for SubSystem: '<S2448>/ESSC_FinishStopDur' */
                        }
                        else
                        {
                            /* Outputs for Function Call SubSystem: '<S2450>/ESSC_RampDownDur' */
                            /* Event: '<S165>:98' */
                            ESSR_ac_ESSC_RampDownDur
                                (ESSR_ac_B.ESSC_RampDownEnt.Dsr_InputSpeedProfile1,
                                 VeESSR_n_TransInSpdFlt,
                                 ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                                 VeESSR_M_SpnDwnAddtlTorq,
                                 ESSR_ac_B.TmpSignalConversionAtVeEPCR_phi,
                                 ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E,
                                 ESSR_ac_B.TmpSignalConversionAtVeCSVR_v_V,
                                 VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                                 ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                                 ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_I,
                                 ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_C,
                                 VeESSR_b_AStopEngCOMLmp,
                                 VeESSR_b_AStopReStrtPrepLmp,
                                 &ESSR_ac_B.ESSC_RampDownDur,
                                 &ESSR_ac_DW.ESSC_RampDownDur,
                                 &ESSR_ac_PrevZCX.ESSC_RampDownDur,
                                 &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn,
                                 &ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt,
                                 &ESSR_ac_DW.NeESSR_k_EngStpProfNiDotGainAda);

                            /* End of Outputs for SubSystem: '<S2450>/ESSC_RampDownDur' */
                        }
                        break;
                    }
                    break;
                }
            }
            break;

          default:
            /* During 'ImmedStop': '<S165>:5' */
            if ((((uint32)VeESSR_e_STMTrigger_DS) == CeESSR_e_EngStop) ||
                    (((uint32)VeESSR_e_STMTrigger_DS) == CeESSR_e_EngFail))
            {
                /* Transition: '<S165>:33' */
                ESSR_ac_DW.is_c1_ESSR_ac = ESSR_ac_IN_EngOff;

                /* Outputs for Function Call SubSystem: '<S13>/ESSC_ResetVars' */
                /* Entry 'EngOff': '<S165>:1' */
                /* Event: '<S165>:101' */
                ESSR_ac_ESSC_ResetVars();

                /* End of Outputs for SubSystem: '<S13>/ESSC_ResetVars' */

                /* Outputs for Function Call SubSystem: '<S173>/ESSC_EngOffEnt' */
                /* Event: '<S165>:65' */
                ESSR_ac_ESSC_EngOffEnt(ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_H);

                /* End of Outputs for SubSystem: '<S173>/ESSC_EngOffEnt' */

                /* Outputs for Function Call SubSystem: '<S173>/ESSC_EngOffDur' */
                /* Switch: '<S242>/Switch' incorporates:
                 *  Constant: '<S256>/Calib'
                 *  Constant: '<S269>/Calib'
                 *  Constant: '<S270>/Calib'
                 *  Logic: '<S242>/AND2'
                 */
                /* Event: '<S165>:66' */
                if ((HeESSR_b_CltchStrtEquipped) &&
                        (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_C))
                {
                    rtb_TmpSignalConversionAtVeOHSR =
                        KeESSR_t_MinTmEngOffCltchStrt;
                }
                else
                {
                    rtb_TmpSignalConversionAtVeOHSR = KeESSR_t_MinTmEngOff;
                }

                /* Switch: '<S260>/Switch1' incorporates:
                 *  Constant: '<S242>/TRUE Constant'
                 *  Constant: '<S249>/Constant'
                 *  Constant: '<S250>/Constant'
                 *  Constant: '<S261>/Calib'
                 *  Logic: '<S242>/AND1'
                 *  RelationalOperator: '<S242>/Comparison1'
                 *  RelationalOperator: '<S242>/Comparison4'
                 *  SignalConversion generated from: '<S2>/VeHSER_e_RngEqnSel'
                 */
                if (KeESSR_b_CheckGearForStart)
                {
                    rtb_UnitDelay_op = ((CeHSER_e_UseM1Eqn == ((uint32)
                                          ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R))
                                        || (((uint32)
                                          ESSR_ac_B.TmpSignalConversionAtVeHSER_e_R)
                                            == CeHSER_e_UseM2Eqn));
                }
                else
                {
                    rtb_UnitDelay_op = true;
                }

                /* Switch: '<S259>/Switch1' incorporates:
                 *  Constant: '<S245>/Constant'
                 *  DataStoreRead: '<S242>/Dsr_STMTmr1'
                 *  DataStoreWrite: '<S242>/Dsw_STMTrigger'
                 *  Logic: '<S242>/AND'
                 *  Logic: '<S242>/Logical2'
                 *  RelationalOperator: '<S242>/Greater  Than'
                 */
                if ((((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_F) ||
                        (VeESSR_t_STMTmr_DS > rtb_TmpSignalConversionAtVeOHSR)) &&
                     (ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_E)) &&
                        rtb_UnitDelay_op)
                {
                    VeESSR_e_STMTrigger_DS = CeESSR_e_StartReq;
                }

                /* RelationalOperator: '<S242>/Comparison3' incorporates:
                 *  RelationalOperator: '<S242>/Comparison2'
                 *  RelationalOperator: '<S242>/Comparison5'
                 *  SignalConversion generated from: '<S2>/VeSTRR_e_HybStrtrSt'
                 *  Switch: '<S242>/Switch4'
                 */
                rtb_UnitDelay_h_tmp = ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_H;

                /* UnitDelay: '<S287>/Unit Delay' incorporates:
                 *  Constant: '<S252>/Constant'
                 *  RelationalOperator: '<S242>/Comparison3'
                 */
                rtb_UnitDelay_op = (((uint32)rtb_UnitDelay_h_tmp) ==
                                    CeSTRR_e_EngStoppingSt);

                /* Switch: '<S242>/Switch4' */
                if (!rtb_UnitDelay_op)
                {
                    /* Switch: '<S242>/Switch3' incorporates:
                     *  Constant: '<S253>/Constant'
                     *  Constant: '<S254>/Constant'
                     *  Constant: '<S255>/Constant'
                     *  DataStoreWrite: '<S242>/Data Store Write'
                     *  RelationalOperator: '<S242>/Comparison5'
                     *  Switch: '<S242>/Switch4'
                     */
                    if (((uint32)rtb_UnitDelay_h_tmp) == CeSTRR_e_KeyOffSt)
                    {
                        VeESSR_e_HybEngSysActv_DS = CeESSR_e_HybEngDisabled;
                    }
                    else
                    {
                        VeESSR_e_HybEngSysActv_DS = CeESSR_e_HybEngEnabledOff;
                    }
                }

                /* UnitDelay: '<S287>/Unit Delay' incorporates:
                 *  DataStoreRead: '<S242>/Data Store Read1'
                 *  Logic: '<S242>/Logical1'
                 */
                rtb_UnitDelay_op = ((VeESSR_b_NbTgtReq_DS) && rtb_UnitDelay_op);

                /* Switch: '<S242>/Switch1' incorporates:
                 *  DataStoreWrite: '<S242>/Dsw_InhibitShiftToMode2'
                 */
                VeESSR_b_NbTgtReq_DS = rtb_UnitDelay_op;

                /* Switch: '<S242>/Switch2' incorporates:
                 *  Constant: '<S242>/Constant Value'
                 *  Constant: '<S264>/Calib'
                 *  DataStoreWrite: '<S242>/Dsw_InputSpeedProfile1'
                 */
                if (rtb_UnitDelay_op)
                {
                    VeESSR_n_NbTgt_DS = 0.0F;
                }
                else
                {
                    VeESSR_n_NbTgt_DS = KeESSR_n_NbTgt_Default;
                }

                /* DataStoreWrite: '<S242>/Dsw_STMTmr' incorporates:
                 *  Constant: '<S257>/Calib'
                 *  DataStoreRead: '<S242>/Dsr_STMTmr'
                 *  Sum: '<S242>/Summation'
                 */
                VeESSR_t_STMTmr_DS = VeESSR_t_STMTmr_DS + HeESSR_t_MedTEB_dT;

                /* DataStoreWrite: '<S242>/Dsw_STMTmr1' incorporates:
                 *  Constant: '<S257>/Calib'
                 *  DataStoreRead: '<S242>/Dsr_STMTmr4'
                 *  Sum: '<S242>/Summation2'
                 */
                VeESSR_t_MainSTMTmr_DS = VeESSR_t_MainSTMTmr_DS +
                    HeESSR_t_MedTEB_dT;

                /* Abs: '<S248>/Abs' incorporates:
                 *  Constant: '<S257>/Calib'
                 *  Constant: '<S262>/Calib'
                 *  Product: '<S248>/Multiplication'
                 */
                rtb_Abs_bj = fabsf(KeESSR_dscl_RampDownRate * HeESSR_t_MedTEB_dT);

                /* Gain: '<S248>/Gain' */
                rtb_Gain_fa = -rtb_Abs_bj;

                /* Sum: '<S248>/Sum' incorporates:
                 *  Constant: '<S267>/Calib'
                 *  DataStoreRead: '<S242>/Dsr_SpdCtlGainMod1'
                 */
                rtb_TmpSignalConversionAtVeVSDR = KeESSR_scl_SpdCtrlEngOff -
                    VeESSR_scl_SpdCtlGainMod_DS;

                /* Outputs for Atomic SubSystem: '<S248>/Limiter1' */
                /* Switch: '<S282>/Switch1' incorporates:
                 *  RelationalOperator: '<S282>/Relational Operator'
                 */
                if (rtb_Abs_bj >= rtb_TmpSignalConversionAtVeVSDR)
                {
                    /* UnitDelay: '<S274>/Unit Delay' */
                    rtb_Abs_bj = rtb_TmpSignalConversionAtVeVSDR;
                }

                /* Switch: '<S282>/Switch' incorporates:
                 *  RelationalOperator: '<S282>/Relational Operator1'
                 */
                if (rtb_Abs_bj > rtb_Gain_fa)
                {
                    rtb_Gain_fa = rtb_Abs_bj;
                }

                /* End of Outputs for SubSystem: '<S248>/Limiter1' */

                /* Sum: '<S248>/Sum1' incorporates:
                 *  DataStoreRead: '<S242>/Dsr_SpdCtlGainMod1'
                 */
                rtb_Gain_fa += VeESSR_scl_SpdCtlGainMod_DS;

                /* Outputs for Atomic SubSystem: '<S248>/Limiter2' */
                /* Switch: '<S283>/Switch1' incorporates:
                 *  Constant: '<S242>/Constant Value7'
                 *  RelationalOperator: '<S283>/Relational Operator'
                 */
                if (2.0F < rtb_Gain_fa)
                {
                    /* UnitDelay: '<S274>/Unit Delay' */
                    rtb_Abs_bj = 2.0F;
                }
                else
                {
                    /* UnitDelay: '<S274>/Unit Delay' */
                    rtb_Abs_bj = rtb_Gain_fa;
                }

                /* Switch: '<S283>/Switch' incorporates:
                 *  Constant: '<S242>/Constant Value6'
                 *  DataStoreWrite: '<S242>/Dsw_SpdCtlGainMod1'
                 *  RelationalOperator: '<S283>/Relational Operator1'
                 */
                if (rtb_Abs_bj > 0.0F)
                {
                    VeESSR_scl_SpdCtlGainMod_DS = rtb_Abs_bj;
                }
                else
                {
                    VeESSR_scl_SpdCtlGainMod_DS = 0.0F;
                }

                /* End of Outputs for SubSystem: '<S248>/Limiter2' */

                /* Abs: '<S247>/Abs' incorporates:
                 *  Constant: '<S257>/Calib'
                 *  Constant: '<S263>/Calib'
                 *  Product: '<S247>/Multiplication'
                 */
                rtb_Abs_bj = fabsf(KeESSR_dscl_TorqCancelRampOutRt *
                                   HeESSR_t_MedTEB_dT);

                /* Gain: '<S247>/Gain' */
                rtb_Gain_fa = -rtb_Abs_bj;

                /* Outputs for Atomic SubSystem: '<S247>/Limiter1' */
                /* Switch: '<S280>/Switch1' incorporates:
                 *  Constant: '<S242>/Constant Value5'
                 *  DataStoreRead: '<S242>/Dsr_TorqCancelDsrd'
                 *  RelationalOperator: '<S280>/Relational Operator'
                 *  Sum: '<S247>/Sum'
                 */
                if (rtb_Abs_bj >= (0.0F - VeESSR_k_TorqCancelGain_DS))
                {
                    /* UnitDelay: '<S274>/Unit Delay' */
                    rtb_Abs_bj = 0.0F - VeESSR_k_TorqCancelGain_DS;
                }

                /* Switch: '<S280>/Switch' incorporates:
                 *  RelationalOperator: '<S280>/Relational Operator1'
                 */
                if (rtb_Abs_bj > rtb_Gain_fa)
                {
                    rtb_Gain_fa = rtb_Abs_bj;
                }

                /* End of Outputs for SubSystem: '<S247>/Limiter1' */

                /* Sum: '<S247>/Sum1' incorporates:
                 *  DataStoreRead: '<S242>/Dsr_TorqCancelDsrd'
                 */
                rtb_Gain_fa += VeESSR_k_TorqCancelGain_DS;

                /* Outputs for Atomic SubSystem: '<S247>/Limiter2' */
                /* Switch: '<S281>/Switch1' incorporates:
                 *  Constant: '<S242>/Constant Value4'
                 *  RelationalOperator: '<S281>/Relational Operator'
                 */
                if (2.0F < rtb_Gain_fa)
                {
                    /* UnitDelay: '<S274>/Unit Delay' */
                    rtb_Abs_bj = 2.0F;
                }
                else
                {
                    /* UnitDelay: '<S274>/Unit Delay' */
                    rtb_Abs_bj = rtb_Gain_fa;
                }

                /* Switch: '<S281>/Switch' incorporates:
                 *  Constant: '<S242>/Constant Value3'
                 *  DataStoreWrite: '<S242>/Dsw_TorqCancelDsrd'
                 *  RelationalOperator: '<S281>/Relational Operator1'
                 */
                if (rtb_Abs_bj > 0.0F)
                {
                    VeESSR_k_TorqCancelGain_DS = rtb_Abs_bj;
                }
                else
                {
                    VeESSR_k_TorqCancelGain_DS = 0.0F;
                }

                /* End of Outputs for SubSystem: '<S247>/Limiter2' */

                /* SignalConversion generated from: '<S246>/Variant Source' incorporates:
                 *  Gain: '<S246>/Gain'
                 *  Lookup_n-D: '<S278>/Vector'
                 *  MinMax: '<S246>/MinMax'
                 *  Sum: '<S246>/Summation1'
                 */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

                /* VariantMerge generated from: '<S246>/Variant Source' incorporates:
                 *  Constant: '<S246>/Constant Value1'
                 */
                rtb_Sum2_fr = 0.0F;

#else

                /* Outputs for Atomic SubSystem: '<S246>/GradientLimiter' */
                /* MinMax: '<S246>/MinMax' incorporates:
                 *  Constant: '<S246>/Constant Value'
                 *  Gain: '<S246>/Gain'
                 */
                VeESSR_M_EngOffEngFricEngStrtTorq = fmaxf
                    (-VeESSR_M_EngTrqAct_Lmtd, 0.0F);

                /* Lookup_n-D: '<S278>/Vector' incorporates:
                 *  SignalConversion generated from: '<S2>/VeENGR_T_EngCoolantTemp'
                 */
                VeESSR_M_EngOffECTEngStrtTorq = look1_iflf_binlcapw
                    (ESSR_ac_B.TmpSignalConversionAtVeENGR_T_E, ((const float32 *)
                      &(KxESSR_M_ECTAddtlEngStrtTorq[0])), ((const float32 *)
                      &(KtESSR_M_ECTAddtlEngStrtTorq[0])), 6U);

                /* Sum: '<S246>/Summation1' incorporates:
                 *  Constant: '<S275>/Calib'
                 */
                VeESSR_M_EngOffEngStrtTorqRaw =
                    (VeESSR_M_EngOffEngFricEngStrtTorq +
                     KeESSR_M_EngOffEngPulseEngStrtTorq) +
                    VeESSR_M_EngOffECTEngStrtTorq;

                /* Sum: '<S274>/Sum2' incorporates:
                 *  UnitDelay: '<S274>/Unit Delay'
                 */
                rtb_Sum2_fr = VeESSR_M_EngOffEngStrtTorqRaw -
                    ESSR_ac_DW.UnitDelay_DSTATE_ie;

                /* Outputs for Atomic SubSystem: '<S274>/Limiter' */
                /* Switch: '<S279>/Switch1' incorporates:
                 *  Constant: '<S277>/Calib'
                 *  RelationalOperator: '<S279>/Relational Operator'
                 */
                if (KeESSR_dM_EngOffEngStrtTorqLU < rtb_Sum2_fr)
                {
                    /* Switch: '<S279>/Switch1' */
                    rtb_Sum2_fr = KeESSR_dM_EngOffEngStrtTorqLU;
                }

                /* Switch: '<S279>/Switch' incorporates:
                 *  Constant: '<S276>/Calib'
                 *  RelationalOperator: '<S279>/Relational Operator1'
                 */
                if (rtb_Sum2_fr <= KeESSR_dM_EngOffEngStrtTorqLD)
                {
                    rtb_Sum2_fr = KeESSR_dM_EngOffEngStrtTorqLD;
                }

                /* End of Outputs for SubSystem: '<S274>/Limiter' */

                /* Sum: '<S274>/Sum3' incorporates:
                 *  UnitDelay: '<S274>/Unit Delay'
                 */
                rtb_Sum2_fr += ESSR_ac_DW.UnitDelay_DSTATE_ie;

                /* Update for UnitDelay: '<S274>/Unit Delay' */
                ESSR_ac_DW.UnitDelay_DSTATE_ie = rtb_Sum2_fr;

                /* End of Outputs for SubSystem: '<S246>/GradientLimiter' */
#endif

                /* SignalConversion generated from: '<S246>/Variant Source' */
                VeESSR_M_EngOffEngStrtTorqLmtd = rtb_Sum2_fr;

                /* DataStoreWrite: '<S242>/Data Store Write2' */
                VeESSR_M_EngStrtTorq_DS = VeESSR_M_EngOffEngStrtTorqLmtd;

                /* DataStoreWrite: '<S242>/Data Store Write1' incorporates:
                 *  Constant: '<S242>/Constant'
                 */
                ESSR_ac_DW.VeESSR_M_BCTiMargin_DS = 0.0F;

                /* DataStoreWrite: '<S242>/Dsw_AEMDMtrAGain' incorporates:
                 *  Constant: '<S265>/Calib'
                 */
                VeESSR_scl_AEMDMtrAGain_DS = KeESSR_scl_AEMDMtrAGain_EngOff;

                /* DataStoreWrite: '<S242>/Dsw_AEMDMtrBGain' incorporates:
                 *  Constant: '<S266>/Calib'
                 */
                VeESSR_scl_AEMDMtrBGain_DS = KeESSR_scl_AEMDMtrBGain_EngOff;

                /* Logic: '<S242>/Logical' incorporates:
                 *  Constant: '<S251>/Constant'
                 *  RelationalOperator: '<S242>/Comparison2'
                 */
                rtb_Logical_e = (rtb_Logical_e && (((uint32)rtb_UnitDelay_h_tmp)
                                  == CeSTRR_e_EngOffSt));

                /* Outputs for Atomic SubSystem: '<S242>/Turn Off Delay Time' */
                /* Outputs for Atomic SubSystem: '<S273>/EdgeFalling1' */
                /* Logic: '<S287>/AND' incorporates:
                 *  Logic: '<S287>/OR1'
                 *  UnitDelay: '<S287>/Unit Delay'
                 */
                rtb_UnitDelay_op = ((!rtb_Logical_e) &&
                                    (ESSR_ac_DW.UnitDelay_DSTATE_hx));

                /* Update for UnitDelay: '<S287>/Unit Delay' */
                ESSR_ac_DW.UnitDelay_DSTATE_hx = rtb_Logical_e;

                /* End of Outputs for SubSystem: '<S273>/EdgeFalling1' */

                /* Switch: '<S273>/Switch' */
                if (rtb_UnitDelay_op)
                {
                    /* Switch: '<S273>/Switch' incorporates:
                     *  Constant: '<S268>/Calib'
                     */
                    rtb_Sum2_fr = KeESSR_t_ImmedStopMdHoldDelay;
                }
                else
                {
                    /* Switch: '<S273>/Switch' incorporates:
                     *  Constant: '<S257>/Calib'
                     *  Constant: '<S273>/Constant Value1'
                     *  MinMax: '<S273>/Minimum'
                     *  Sum: '<S273>/Summation'
                     *  UnitDelay: '<S273>/Unit Delay'
                     */
                    rtb_Sum2_fr = fmaxf(ESSR_ac_DW.UnitDelay_DSTATE_dg -
                                        HeESSR_t_MedTEB_dT, 0.0F);
                }

                /* Update for UnitDelay: '<S273>/Unit Delay' */
                ESSR_ac_DW.UnitDelay_DSTATE_dg = rtb_Sum2_fr;

                /* If: '<S242>/If' incorporates:
                 *  Constant: '<S271>/Calib'
                 *  Constant: '<S273>/Constant Value2'
                 *  DataStoreRead: '<S242>/Dsr_STMTmr2'
                 *  Logic: '<S273>/AND'
                 *  RelationalOperator: '<S242>/Greater  Than1'
                 *  RelationalOperator: '<S273>/Greater  Than'
                 */
                if (rtb_Logical_e || (rtb_Sum2_fr > 0.0F))
                {
                    /* Outputs for IfAction SubSystem: '<S242>/If Action Subsystem' incorporates:
                     *  ActionPort: '<S258>/Action Port'
                     */
                    /* DataStoreWrite: '<S258>/Dsw_EngStrtStpMd2' incorporates:
                     *  Constant: '<S284>/Constant'
                     */
                    VeESSR_e_EngStrtStpMd_DS = CeESSR_e_ImmediateStop;

                    /* End of Outputs for SubSystem: '<S242>/If Action Subsystem' */
                }
                else
                {
                    if (VeESSR_t_STMTmr_DS > KeESSR_t_ResetFailTm)
                    {
                        /* Outputs for IfAction SubSystem: '<S242>/ResetFailed' incorporates:
                         *  ActionPort: '<S272>/Action Port'
                         */
                        /* DataStoreWrite: '<S272>/Data Store Write1' incorporates:
                         *  Constant: '<S272>/FALSE Constant2'
                         */
                        VeESSR_b_BumpStrtFailed_DS = false;

                        /* DataStoreWrite: '<S272>/Dsw_EngStartAbort' incorporates:
                         *  Constant: '<S272>/FALSE Constant1'
                         */
                        VeESSR_b_EngStartAbort_DS = false;

                        /* DataStoreWrite: '<S272>/Dsw_EngStartAbort1' incorporates:
                         *  Constant: '<S286>/Calib'
                         */
                        VeESSR_b_AStrtFailed_DS = KeESSR_b_ResetAStrtFailed;

                        /* DataStoreWrite: '<S272>/Dsw_EngStrtStpMd' incorporates:
                         *  Constant: '<S285>/Constant'
                         */
                        VeESSR_e_EngStrtStpMd_DS = CeESSR_e_Stop;

                        /* DataStoreWrite: '<S272>/Dsw_StrtStopFail' incorporates:
                         *  Constant: '<S272>/FALSE Constant'
                         */
                        VeESSR_b_StrtStopFail_DS = false;

                        /* End of Outputs for SubSystem: '<S242>/ResetFailed' */
                    }
                }

                /* End of Outputs for SubSystem: '<S242>/Turn Off Delay Time' */
                /* End of Outputs for SubSystem: '<S173>/ESSC_EngOffDur' */
            }
            else
            {
                /* Outputs for Function Call SubSystem: '<S175>/ESSC_ImmedStopDur' */
                /* Event: '<S165>:76' */
                ESSR_ac_ESSC_ImmedStopDur(VeESSR_n_TransInSpdFlt,
                    VeESSR_dn_NiDotMax, VeESSR_dn_NiDotMin,
                    ESSR_ac_B.TmpSignalConversionAtVeENGR_e_C,
                    ESSR_ac_B.TmpSignalConversionAtVeETQR_M_o,
                    VeESSR_M_SpnDwnAddtlTorq,
                    ESSR_ac_B.TmpSignalConversionAtVeHPMR_b_P, tmpRead_3,
                    ESSR_ac_B.TmpSignalConversionAtVeHSER_n_N,
                    &ESSR_ac_DW.ESSC_ImmedStopDur,
                    &ESSR_ac_PrevZCX.ESSC_ImmedStopDur,
                    &ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

                /* End of Outputs for SubSystem: '<S175>/ESSC_ImmedStopDur' */
            }
            break;
        }
    }

    /* End of Chart: '<S13>/ESSC_EngStartStopSTM' */

    /* End of Outputs for SubSystem: '<S2>/ESSC_EngStartStopCtrl' */

    /* Outputs for Function Call SubSystem: '<S2>/ESSC_Misc' */

    /* Gain: '<S2999>/Gain' */
    VeESSR_b_BackupStrtEngOn = ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_B;

    /* Switch: '<S15>/Switch' incorporates:
     *  Constant: '<S15>/FALSE Constant'
     *  Constant: '<S2996>/Constant'
     *  Constant: '<S2997>/Calib'
     *  DataStoreRead: '<S15>/Dsr_BSGStrtFailed'
     *  DataStoreRead: '<S15>/Dsr_EngStrtType1'
     *  DataStoreWrite: '<S15>/Data Store Write'
     *  Gain: '<S3000>/Gain'
     *  Logic: '<S15>/Logical Operator4'
     *  Logic: '<S15>/Logical1'
     *  RelationalOperator: '<S15>/Comparison2'
     */
    if (KeESSR_b_RstHybStpStrtFault)
    {
        VeESSR_b_HCP_StopStart_Fault_DS = false;
    }
    else
    {
        VeESSR_b_HCP_StopStart_Fault_DS = (((VeESSR_b_BackupStrtEngOn) ||
            ((ESSR_ac_B.TmpSignalConversionAtVeSTRR_b_d) && (((uint32)
            VeESSR_e_EngStrtProfType_DS) == CeESSR_e_KeyCrnkAlgo))) ||
            (VeESSR_b_BSGStrtFailed_DS));
    }

    /* End of Switch: '<S15>/Switch' */

    /* DataStoreWrite: '<S15>/Data Store Write1' incorporates:
     *  Constant: '<S2998>/Calib'
     */
    VeESSR_g_StrtStpFailPhaseSelect_DS = KeESSR_g_StrtStpFailPhaseSelect;

    /* End of Outputs for SubSystem: '<S2>/ESSC_Misc' */

    /* Outputs for Function Call SubSystem: '<S2>/ESSD' */
    /* Logic: '<S3201>/AND' incorporates:
     *  Constant: '<S19>/FALSE Constant'
     */
    ESSR_ac_B.AND_p = false;

    /* Logic: '<S3202>/AND' incorporates:
     *  Constant: '<S19>/FALSE Constant1'
     */
    ESSR_ac_B.AND_n = false;

    /* Logic: '<S3203>/AND' incorporates:
     *  Constant: '<S19>/FALSE Constant2'
     */
    ESSR_ac_B.AND_nb = false;

    /* If: '<S19>/If' incorporates:
     *  Constant: '<S3205>/Calib'
     *  Inport: '<Root>/VeDFIR_b_DiagSystemDsbl'
     *  Inport: '<Root>/VeDFIR_b_DsblDiagFailSafe'
     *  Switch: '<S3204>/Switch9'
     */
    if (KeESSD_b_StrtStopDiagEnbl)
    {
        (void)Rte_Read_VeDFIR_b_DiagSystemDsbl_Value(&rtb_Switch13);
        (void)Rte_Read_VeDFIR_b_DsblDiagFailSafe_Value(&rtb_UnitDelay_k0);

        /* Outputs for IfAction SubSystem: '<S19>/ESSD_StartStopFail' incorporates:
         *  ActionPort: '<S3204>/Action Port'
         */
        /* Logic: '<S3204>/Logical1' incorporates:
         *  Constant: '<S3204>/Constant Value1'
         *  DataStoreRead: '<S3204>/Data Store Read'
         *  DataStoreRead: '<S3204>/Dsr_EngStartStopFail'
         *  DataStoreRead: '<S3204>/Dsr_EngStartStopFail1'
         *  DataStoreRead: '<S3204>/Dsr_EngStartStopFail2'
         *  DataStoreRead: '<S3204>/Dsr_EngTrqRespType6'
         *  Inport: '<Root>/VeDFIR_b_DiagSystemDsbl'
         *  Inport: '<Root>/VeDFIR_b_DsblDiagFailSafe'
         *  RelationalOperator: '<S3204>/Comparison14'
         */
        rtb_Logical_e = (((((VeESSR_g_StrtStpFailPhase_DS != 0U) ||
                            (VeESSR_b_BSGStrtFailed_DS)) ||
                           (VeESSR_b_StrtStopFail_DS)) ||
                          (VeESSR_b_CltchStckOn_DS)) || (VeESSR_b_AStrtFailed_DS));

        /* Outputs for Atomic SubSystem: '<S3204>/Signal Latch On1' */
        /* Logic: '<S3218>/OR2' incorporates:
         *  Constant: '<S3211>/Constant'
         *  DataStoreRead: '<S3204>/Dsr_EngStartStopSt3'
         *  RelationalOperator: '<S3204>/Comparison13'
         *  UnitDelay: '<S3218>/Unit Delay'
         */
        rtb_UnitDelay_op = ((((uint32)VeESSR_e_EngStartStopSt_DS) ==
                             CeESSR_e_StartEngSt) ||
                            (ESSR_ac_DW.UnitDelay_DSTATE_dj));

        /* Update for UnitDelay: '<S3218>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_dj = rtb_UnitDelay_op;

        /* End of Outputs for SubSystem: '<S3204>/Signal Latch On1' */

        /* Logic: '<S3204>/Logical11' incorporates:
         *  Logic: '<S3204>/Logical33'
         *  Switch: '<S3204>/Switch13'
         */
        tmpRead_3 = !rtb_Logical_e;

        /* Switch: '<S3204>/Switch10' incorporates:
         *  Constant: '<S3213>/Constant'
         *  DataStoreRead: '<S3204>/Dsr_EngStartStopSt'
         *  Logic: '<S3204>/Logical'
         *  Logic: '<S3204>/Logical11'
         *  Logic: '<S3204>/Logical35'
         *  RelationalOperator: '<S3204>/Comparison10'
         */
        rtb_UnitDelay_op = (tmpRead_3 && (rtb_UnitDelay_op && (((uint32)
                               VeESSR_e_EngStartStopSt_DS) ==
                              CeESSR_e_EngRunning)));

        /* Switch: '<S3204>/Switch13' incorporates:
         *  Logic: '<S3204>/Logical12'
         */
        rtb_Switch13 = ((rtb_TmpSignalConversionAtVeDFIR || rtb_UnitDelay_k0) ||
                        rtb_Switch13);

        /* Switch: '<S3204>/Switch' incorporates:
         *  Constant: '<S3204>/FALSE Constant'
         *  Constant: '<S3208>/Constant'
         *  DataStoreRead: '<S3204>/Dsr_StrtStpFailDTC'
         *  Logic: '<S3204>/Logical3'
         *  RelationalOperator: '<S3204>/Comparison1'
         */
        if (rtb_Switch13)
        {
            rtb_UnitDelay_k0 = false;
        }
        else
        {
            rtb_UnitDelay_k0 = (rtb_Logical_e && (((uint32)
                                  VeESSR_e_StrtStpFailDTC) == CeESSR_e_P1C64));
        }

        /* End of Switch: '<S3204>/Switch' */

        /* Logic: '<S3204>/Logical13' incorporates:
         *  Constant: '<S3214>/Calib'
         */
        ESSR_ac_B.Logical13 = ((KeESSR_b_EnblP1C64Diag) && rtb_UnitDelay_k0);

        /* Switch: '<S3204>/Switch1' incorporates:
         *  Constant: '<S3204>/FALSE Constant1'
         *  Constant: '<S3207>/Constant'
         *  DataStoreRead: '<S3204>/Dsr_StrtStpFailDTC1'
         *  Logic: '<S3204>/Logical2'
         *  RelationalOperator: '<S3204>/Comparison2'
         */
        if (rtb_Switch13)
        {
            rtb_UnitDelay_k0 = false;
        }
        else
        {
            rtb_UnitDelay_k0 = (rtb_Logical_e && (((uint32)
                                  VeESSR_e_StrtStpFailDTC) == CeESSR_e_P1C65));
        }

        /* End of Switch: '<S3204>/Switch1' */

        /* Logic: '<S3204>/Logical14' incorporates:
         *  Constant: '<S3215>/Calib'
         */
        ESSR_ac_B.Logical14 = ((KeESSR_b_EnblP1C65Diag) && rtb_UnitDelay_k0);

        /* Switch: '<S3204>/Switch4' incorporates:
         *  Constant: '<S3204>/FALSE Constant4'
         *  Constant: '<S3212>/Constant'
         *  DataStoreRead: '<S3204>/Dsr_StrtStpFailDTC4'
         *  Logic: '<S3204>/Logical6'
         *  RelationalOperator: '<S3204>/Comparison5'
         */
        if (rtb_Switch13)
        {
            rtb_UnitDelay_k0 = false;
        }
        else
        {
            rtb_UnitDelay_k0 = (rtb_Logical_e && (((uint32)
                                  VeESSR_e_StrtStpFailDTC) == CeESSR_e_P1C68));
        }

        /* End of Switch: '<S3204>/Switch4' */

        /* Logic: '<S3204>/Logical17' incorporates:
         *  Constant: '<S3216>/Calib'
         */
        ESSR_ac_B.Logical17 = ((KeESSR_b_EnblP1C68Diag) && rtb_UnitDelay_k0);
        rtb_Logical_e = ((!rtb_Switch13) && rtb_UnitDelay_op);

        /* Logic: '<S3204>/Logical22' incorporates:
         *  Constant: '<S3214>/Calib'
         *  Switch: '<S3204>/Switch9'
         */
        ESSR_ac_B.Logical22 = ((KeESSR_b_EnblP1C64Diag) && rtb_Logical_e);

        /* Logic: '<S3204>/Logical23' incorporates:
         *  Constant: '<S3215>/Calib'
         */
        ESSR_ac_B.Logical23 = ((KeESSR_b_EnblP1C65Diag) && rtb_Logical_e);

        /* Outputs for Atomic SubSystem: '<S3204>/Signal Latch On' */
        /* Logic: '<S3217>/OR2' incorporates:
         *  Constant: '<S3210>/Constant'
         *  DataStoreRead: '<S3204>/Dsr_EngStartStopSt2'
         *  RelationalOperator: '<S3204>/Comparison12'
         *  UnitDelay: '<S3217>/Unit Delay'
         */
        rtb_UnitDelay_k0 = ((((uint32)VeESSR_e_EngStartStopSt_DS) ==
                             CeESSR_e_FinishStopSt) ||
                            (ESSR_ac_DW.UnitDelay_DSTATE_hg));

        /* Update for UnitDelay: '<S3217>/Unit Delay' */
        ESSR_ac_DW.UnitDelay_DSTATE_hg = rtb_UnitDelay_k0;

        /* End of Outputs for SubSystem: '<S3204>/Signal Latch On' */

        /* Switch: '<S3204>/Switch13' */
        if (rtb_Switch13)
        {
            /* Switch: '<S3204>/Switch13' incorporates:
             *  Constant: '<S3204>/FALSE Constant13'
             */
            rtb_Switch13 = false;
        }
        else
        {
            /* Switch: '<S3204>/Switch13' incorporates:
             *  Constant: '<S3209>/Constant'
             *  DataStoreRead: '<S3204>/Dsr_EngStartStopSt2'
             *  Logic: '<S3204>/Logical32'
             *  Logic: '<S3204>/Logical34'
             *  RelationalOperator: '<S3204>/Comparison11'
             *  RelationalOperator: '<S3204>/Comparison12'
             */
            rtb_Switch13 = (tmpRead_3 && (rtb_UnitDelay_k0 && (((uint32)
                               VeESSR_e_EngStartStopSt_DS) == CeESSR_e_EngOff)));
        }

        /* Logic: '<S3204>/Logical26' incorporates:
         *  Constant: '<S3216>/Calib'
         */
        ESSR_ac_B.Logical26 = ((KeESSR_b_EnblP1C68Diag) && rtb_Switch13);

        /* End of Outputs for SubSystem: '<S19>/ESSD_StartStopFail' */
    }

    /* End of If: '<S19>/If' */
    /* End of Outputs for SubSystem: '<S2>/ESSD' */

    /* Outputs for Function Call SubSystem: '<S2>/ESSC_ResetNVMVars' */
    /* Switch: '<S16>/Switch' incorporates:
     *  Constant: '<S16>/Constant Value'
     *  Constant: '<S16>/Constant Value1'
     *  Constant: '<S3001>/Constant'
     *  Constant: '<S3002>/Calib'
     *  DataStoreWrite: '<S16>/Data Store Write'
     *  DataStoreWrite: '<S16>/Dsw_StrtStpFailDTC'
     *  DataStoreWrite: '<S16>/Dsw_StrtStpFailDTC1'
     *  Logic: '<S16>/Logical5'
     *  Switch: '<S16>/Switch1'
     *  Switch: '<S16>/Switch2'
     */
    if (rtb_TmpSignalConversionAtVeDFIR || (KeESSR_b_StrtStpFailRsnReset))
    {
        ESSR_ac_DW.NeESSR_g_StrtStpFailRsn = 0U;
        VeESSR_e_StrtStpFailDTC = CeESSR_e_NoFault;
        VeESSR_g_StrtStpFailPhase_DS = 0U;
    }

    /* End of Switch: '<S16>/Switch' */
    /* End of Outputs for SubSystem: '<S2>/ESSC_ResetNVMVars' */

    /* Outputs for Function Call SubSystem: '<S2>/ESSC_WrtOut_MedTEB' */

    /* Outputs for Atomic SubSystem: '<S3145>/Digital Lowpass Reset Enabled' */
    /* UnitDelay: '<S3167>/Unit Delay' */
    rtb_Sum2_fr = ESSR_ac_DW.UnitDelay_DSTATE_k;

    /* Switch: '<S3167>/Switch1' incorporates:
     *  Constant: '<S3164>/Constant'
     *  Constant: '<S3165>/Constant'
     *  Constant: '<S3166>/Constant'
     *  Constant: '<S3169>/Calib'
     *  DataStoreRead: '<S18>/Dsr_EngStartStopSt'
     *  Logic: '<S3145>/Logical Operator1'
     *  RelationalOperator: '<S3145>/Not Equal1'
     *  RelationalOperator: '<S3145>/Not Equal2'
     *  RelationalOperator: '<S3145>/Not Equal3'
     *  RelationalOperator: '<S3145>/Relational Operator'
     *  Switch: '<S3167>/Switch2'
     */
    if (((((uint32)VeESSR_e_EngStartStopSt_DS) == CeESSR_e_InitEngSpinSt) ||
            (((uint32)VeESSR_e_EngStartStopSt_DS) == CeESSR_e_EngRunning)) ||
            (((uint32)VeESSR_e_EngStartStopSt_DS) == CeESSR_e_EngOff))
    {
        /* Switch: '<S3167>/Switch1' incorporates:
         *  DataStoreRead: '<S3145>/Data Store Read'
         */
        ESSR_ac_B.Switch1 = ESSR_ac_DW.VeESSR_M_BCTiMargin_DS;
    }
    else if (VeESSR_n_TransInSpdFlt >= KeESSR_n_TiMarginToZero)
    {
        /* Switch: '<S3167>/Switch2' incorporates:
         *  Constant: '<S3145>/Constant'
         *  Constant: '<S3168>/Calib'
         *  Product: '<S3167>/Multiplication'
         *  Sum: '<S3167>/Subtraction'
         *  Sum: '<S3167>/Summation'
         *  Switch: '<S3167>/Switch1'
         */
        ESSR_ac_B.Switch1 = ((0.0F - rtb_Sum2_fr) *
                             KeESSR_k_BCTiMarginRampOutFlt) + rtb_Sum2_fr;
    }
    else
    {
        /* Switch: '<S3167>/Switch1' incorporates:
         *  Switch: '<S3167>/Switch2'
         */
        ESSR_ac_B.Switch1 = rtb_Sum2_fr;
    }

    /* End of Switch: '<S3167>/Switch1' */

    /* Update for UnitDelay: '<S3167>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_k = ESSR_ac_B.Switch1;

    /* End of Outputs for SubSystem: '<S3145>/Digital Lowpass Reset Enabled' */

    /* Switch: '<S3151>/Switch' incorporates:
     *  Constant: '<S3183>/Calib'
     */
    if (HeESSR_b_NiPrfOptSpd)
    {
        /* Outputs for Atomic SubSystem: '<S3151>/ClosedInterval' */
        /* Switch: '<S3151>/Switch1' incorporates:
         *  Constant: '<S3178>/Constant'
         *  Constant: '<S3179>/Constant'
         *  DataStoreRead: '<S18>/Dsr_EngStartStopSt'
         *  Logic: '<S3176>/Logical Operator'
         *  RelationalOperator: '<S3176>/Relatonal Operator'
         *  RelationalOperator: '<S3176>/Relatonal Operator1'
         */
        if ((((uint32)VeESSR_e_EngStartStopSt_DS) >= CeESSR_e_RestartPrepSt) &&
                (((uint32)VeESSR_e_EngStartStopSt_DS) <=
                 CeESSR_e_StrtEngOnlyChngMind))
        {
            /* Switch: '<S3151>/Switch' incorporates:
             *  DataStoreRead: '<S3151>/Dsr_EngTrqRespType7'
             *  Switch: '<S3151>/Switch1'
             */
            ESSR_ac_B.Switch = VeESSR_n_OptInputSpd_DS;
        }
        else
        {
            /* Switch: '<S3151>/Switch' incorporates:
             *  DataStoreRead: '<S3151>/Dsr_InputSpeedProfile'
             *  Switch: '<S3151>/Switch1'
             */
            ESSR_ac_B.Switch = VeESSR_n_InputSpeedProfile_DS;
        }

        /* End of Switch: '<S3151>/Switch1' */
        /* End of Outputs for SubSystem: '<S3151>/ClosedInterval' */
    }
    else
    {
        /* Switch: '<S3151>/Switch' incorporates:
         *  DataStoreRead: '<S3151>/Dsr_InputSpeedProfile'
         */
        ESSR_ac_B.Switch = VeESSR_n_InputSpeedProfile_DS;
    }

    /* End of Switch: '<S3151>/Switch' */

    /* Switch: '<S3151>/Switch3' incorporates:
     *  Constant: '<S3182>/Calib'
     */
    if (HeESSR_b_InputAccelOverride)
    {
        /* Outputs for Atomic SubSystem: '<S3151>/ClosedInterval1' */
        /* Switch: '<S3151>/Switch4' incorporates:
         *  Constant: '<S3180>/Constant'
         *  Constant: '<S3181>/Constant'
         *  DataStoreRead: '<S18>/Dsr_EngStartStopSt'
         *  Logic: '<S3177>/Logical Operator'
         *  RelationalOperator: '<S3177>/Relatonal Operator'
         *  RelationalOperator: '<S3177>/Relatonal Operator1'
         */
        if ((((uint32)VeESSR_e_EngStartStopSt_DS) >= CeESSR_e_RestartPrepSt) &&
                (((uint32)VeESSR_e_EngStartStopSt_DS) <=
                 CeESSR_e_StrtEngOnlyChngMind))
        {
            /* Switch: '<S3151>/Switch3' incorporates:
             *  Constant: '<S3151>/Constant Value'
             */
            ESSR_ac_B.Switch3 = 0.0F;
        }
        else
        {
            /* Switch: '<S3151>/Switch3' incorporates:
             *  DataStoreRead: '<S3151>/Dsr_InputAcceltnProf'
             */
            ESSR_ac_B.Switch3 = VeESSR_dn_InputAcceltnProf_DS;
        }

        /* End of Switch: '<S3151>/Switch4' */
        /* End of Outputs for SubSystem: '<S3151>/ClosedInterval1' */
    }
    else
    {
        /* Switch: '<S3151>/Switch3' incorporates:
         *  DataStoreRead: '<S3151>/Dsr_InputAcceltnProf'
         */
        ESSR_ac_B.Switch3 = VeESSR_dn_InputAcceltnProf_DS;
    }

    /* End of Switch: '<S3151>/Switch3' */

    /* DataTypeConversion: '<S3152>/DataTypeConversion' incorporates:
     *  DataStoreRead: '<S18>/Dsr_EngStartStopSt'
     */
    ESSR_ac_B.DataTypeConversion_f = VeESSR_e_EngStartStopSt_DS;

    /* RelationalOperator: '<S18>/Not Equal1' incorporates:
     *  Constant: '<S3147>/Constant'
     *  DataStoreRead: '<S18>/Dsr_EngStartStopSt'
     */
    ESSR_ac_B.NotEqual1 = (((uint32)VeESSR_e_EngStartStopSt_DS) !=
                           CeESSR_e_EngRunning);

#if Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* Outputs for Atomic SubSystem: '<S3161>/ClosedInterval' */
    /* Logic: '<S3184>/Logical Operator' incorporates:
     *  Constant: '<S3185>/Calib'
     *  Constant: '<S3186>/Calib'
     *  DataStoreRead: '<S18>/Dsr_EngStartStopSt'
     *  RelationalOperator: '<S3184>/Relatonal Operator'
     *  RelationalOperator: '<S3184>/Relatonal Operator1'
     */
    rtb_LogicalOperator_h = ((VeESSR_e_EngStartStopSt_DS >=
        HeESSR_e_StrtStpSt_TCMmin) && (VeESSR_e_EngStartStopSt_DS <=
        HeESSR_e_StrtStpSt_TCMmax));

    /* End of Outputs for SubSystem: '<S3161>/ClosedInterval' */
#endif

    /* SignalConversion generated from: '<S18>/VeSTRR_e_StrtTyp2TCM' */
#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* VariantMerge generated from: '<S18>/VeSTRR_e_StrtTyp2TCM' incorporates:
     *  Inport: '<Root>/VeSTRR_e_StrtTyp2TCM'
     */
    (void)Rte_Read_VeSTRR_e_StrtTyp2TCM_Value(&rtb_LeESSI_e_StrtTyp2TCM);

#elif !Rte_SysCon_Variant_ESSR_Func || !Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* VariantMerge generated from: '<S18>/VeSTRR_e_StrtTyp2TCM' incorporates:
     *  SignalConversion generated from: '<S18>/VeSTRR_e_StrtTyp2TCM'
     */
    rtb_LeESSI_e_StrtTyp2TCM = CeSTRR_e_NoAction;

#endif

    /* End of SignalConversion generated from: '<S18>/VeSTRR_e_StrtTyp2TCM' */

    /* DataStoreRead: '<S3161>/Dsr_EngTrqRespType1' incorporates:
     *  Switch: '<S3161>/Switch1'
     */
#if !Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* VariantMerge generated from: '<S3161>/Variant Source' */
    ESSR_ac_B.VariantMerge_For_Variant_Sour_h = VeESSR_e_TCM_StartStopType_DS;

#else

    /* Switch: '<S3161>/Switch1' */
    if (rtb_LogicalOperator_h)
    {
        /* VariantMerge generated from: '<S3161>/Variant Source' incorporates:
         *  DataStoreRead: '<S3161>/Dsr_EngTrqRespType2'
         */
        ESSR_ac_B.VariantMerge_For_Variant_Sour_h =
            VeESSR_e_TCM_StartStopType_DS;
    }
    else
    {
        /* VariantMerge generated from: '<S3161>/Variant Source' incorporates:
         *  Constant: '<S3187>/Calib'
         *  DataTypeConversion: '<S3161>/Data Type Conversion'
         *  Selector: '<S3161>/Selector'
         *  VariantMerge generated from: '<S18>/VeSTRR_e_StrtTyp2TCM'
         */
        ESSR_ac_B.VariantMerge_For_Variant_Sour_h =
            KaESSR_e_TCM_StartStopTypeMap[(rtb_LeESSI_e_StrtTyp2TCM)];
    }

#endif

    /* End of DataStoreRead: '<S3161>/Dsr_EngTrqRespType1' */

    /* RelationalOperator: '<S3163>/NoPstnMntrMd' incorporates:
     *  Constant: '<S3197>/Calib'
     *  DataStoreRead: '<S18>/Dsr_EngStartStopSt'
     *  DataTypeConversion: '<S3163>/Data Type Conversion'
     *  Selector: '<S3163>/Selector1'
     *  Switch: '<S3163>/Switch1'
     *  Switch: '<S3163>/Switch3'
     */
    rtb_TmpSignalConversionAtVeDF_0 = KaESSR_e_eTPU_TargetSyncStatus
        [(VeESSR_e_EngStartStopSt_DS)];

    /* RelationalOperator: '<S3163>/NoPstnMntrMd' incorporates:
     *  Constant: '<S3193>/Constant'
     */
    rtb_TmpSignalConversionAtVeDFIR = (((uint32)rtb_TmpSignalConversionAtVeDF_0)
        == CeESSR_e_NoPstnMntr);

    /* Outputs for Atomic SubSystem: '<S3163>/TurnOffDelayTime' */
    /* Outputs for Atomic SubSystem: '<S3199>/EdgeFalling1' */
    /* Logic: '<S3200>/AND' incorporates:
     *  Logic: '<S3200>/OR1'
     *  UnitDelay: '<S3200>/Unit Delay'
     */
    rtb_LogicalOperator_h = ((!rtb_TmpSignalConversionAtVeDFIR) &&
        (ESSR_ac_DW.UnitDelay_DSTATE_l));

    /* Update for UnitDelay: '<S3200>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_l = rtb_TmpSignalConversionAtVeDFIR;

    /* End of Outputs for SubSystem: '<S3199>/EdgeFalling1' */

    /* Switch: '<S3199>/Switch' */
    if (rtb_LogicalOperator_h)
    {
        /* Switch: '<S3199>/Switch' incorporates:
         *  Constant: '<S3198>/Calib'
         */
        rtb_Sum2_fr = KeESSR_t_PstnMntrExtndTm;
    }
    else
    {
        /* Switch: '<S3199>/Switch' incorporates:
         *  Constant: '<S3196>/Calib'
         *  Constant: '<S3199>/Constant Value1'
         *  MinMax: '<S3199>/Minimum'
         *  Sum: '<S3199>/Summation'
         *  UnitDelay: '<S3199>/Unit Delay'
         */
        rtb_Sum2_fr = fmaxf(ESSR_ac_DW.UnitDelay_DSTATE_d - HeESSR_t_MedTEB_dT,
                            0.0F);
    }

    /* End of Switch: '<S3199>/Switch' */

    /* Update for UnitDelay: '<S3199>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_d = rtb_Sum2_fr;

    /* End of Outputs for SubSystem: '<S3163>/TurnOffDelayTime' */

    /* Switch: '<S3163>/Switch3' incorporates:
     *  Constant: '<S3195>/Constant'
     *  Constant: '<S3199>/Constant Value2'
     *  Logic: '<S3199>/AND'
     *  RelationalOperator: '<S3163>/KeyOff_Check'
     *  RelationalOperator: '<S3199>/Greater  Than'
     *  SignalConversion generated from: '<S2>/VeSTRR_e_HybStrtrSt'
     *  Switch: '<S3163>/Switch1'
     */
    if (((uint32)ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_H) == CeSTRR_e_KeyOffSt)
    {
        /* Switch: '<S3163>/Switch3' incorporates:
         *  Constant: '<S3194>/Constant'
         */
        ESSR_ac_B.Switch3_p = CeESSR_e_NoPstnMntr;
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S3163>/TurnOffDelayTime' */
        if (rtb_TmpSignalConversionAtVeDFIR || (rtb_Sum2_fr > 0.0F))
        {
            /* Switch: '<S3163>/Switch1' incorporates:
             *  Constant: '<S3194>/Constant'
             *  Switch: '<S3163>/Switch3'
             */
            ESSR_ac_B.Switch3_p = CeESSR_e_NoPstnMntr;
        }
        else
        {
            /* Switch: '<S3163>/Switch3' */
            ESSR_ac_B.Switch3_p = rtb_TmpSignalConversionAtVeDF_0;
        }

        /* End of Outputs for SubSystem: '<S3163>/TurnOffDelayTime' */
    }

    /* DataStoreRead: '<S18>/Dsr_EngStrtType' */
    ESSR_ac_B.Dsr_EngStrtType_b = VeESSR_e_EngStrtType_DS;

    /* Switch: '<S3175>/Switch1' incorporates:
     *  Constant: '<S3171>/Constant'
     *  DataStoreRead: '<S18>/Dsr_EngStrtStpMd'
     *  DataStoreRead: '<S3150>/Data Store Read'
     *  Logic: '<S3150>/Logical'
     *  RelationalOperator: '<S3150>/Comparison4'
     */
    if ((((uint32)VeESSR_e_EngStrtStpMd_DS) == CeESSR_e_ProducingTorque) &&
            (VeESSR_b_MinRun2StpTm_DS))
    {
        /* Switch: '<S3175>/Switch1' incorporates:
         *  Inport: '<Root>/VeSTRR_b_EngOffAllwdECM'
         */
        (void)Rte_Read_VeSTRR_b_EngOffAllwdECM_Value(&ESSR_ac_B.Switch1_p);
    }
    else
    {
        /* Outputs for Atomic SubSystem: '<S3150>/ClosedInterval' */
        /* Switch: '<S3175>/Switch1' incorporates:
         *  Constant: '<S3172>/Constant'
         *  Constant: '<S3173>/Constant'
         *  Constant: '<S3174>/Constant'
         *  Logic: '<S3150>/Logical1'
         *  Logic: '<S3170>/Logical Operator'
         *  RelationalOperator: '<S3150>/Comparison1'
         *  RelationalOperator: '<S3170>/Relatonal Operator'
         *  RelationalOperator: '<S3170>/Relatonal Operator1'
         */
        ESSR_ac_B.Switch1_p = (((((uint32)VeESSR_e_EngStrtStpMd_DS) <
            CeESSR_e_StartPending) || (((uint32)VeESSR_e_EngStrtStpMd_DS) >
            CeESSR_e_ProducingTorque)) && (((uint32)VeESSR_e_EngStrtStpMd_DS) !=
                                CeESSR_e_CompressionTest));

        /* End of Outputs for SubSystem: '<S3150>/ClosedInterval' */
    }

    /* End of Switch: '<S3175>/Switch1' */

    /* DataTypeConversion: '<S3153>/DataTypeConversion' incorporates:
     *  DataStoreRead: '<S18>/Dsr_EngStrtStpMd'
     */
    ESSR_ac_B.DataTypeConversion = VeESSR_e_EngStrtStpMd_DS;

    /* Selector: '<S3162>/Selector' incorporates:
     *  Constant: '<S3191>/Calib'
     *  DataStoreRead: '<S18>/Dsr_EngStrtStpMd'
     *  RelationalOperator: '<S3150>/Comparison4'
     */
    ESSR_ac_B.Selector = HaESSR_b_OptimdEngOnOffCmd[(VeESSR_e_EngStrtStpMd_DS)];

    /* Selector: '<S3162>/Selector1' incorporates:
     *  Constant: '<S3189>/Calib'
     *  DataStoreRead: '<S18>/Dsr_EngStrtStpMd'
     *  RelationalOperator: '<S3150>/Comparison4'
     */
    ESSR_ac_B.Selector1 = HaESSR_b_HCPFuelDisable[(VeESSR_e_EngStrtStpMd_DS)];

    /* Selector: '<S3162>/Selector2' incorporates:
     *  Constant: '<S3190>/Calib'
     *  DataStoreRead: '<S18>/Dsr_EngStrtStpMd'
     *  RelationalOperator: '<S3150>/Comparison4'
     */
    ESSR_ac_B.Selector2 = HaESSR_b_HybProducingTorque[(VeESSR_e_EngStrtStpMd_DS)];

    /* Selector: '<S3162>/Selector4' incorporates:
     *  Constant: '<S3192>/Calib'
     *  DataStoreRead: '<S18>/Dsr_EngStrtStpMd'
     *  RelationalOperator: '<S3150>/Comparison4'
     */
    ESSR_ac_B.Selector4 = HaESSR_e_OptimdEngStrtStpType
        [(VeESSR_e_EngStrtStpMd_DS)];

    /* DataTypeConversion: '<S3188>/DataTypeConversion' incorporates:
     *  DataStoreRead: '<S3162>/Data Store Read'
     */
    ESSR_ac_B.DataTypeConversion_k = VeESSR_e_EngStrtActuatorTyp;

    /* DataStoreRead: '<S18>/Dsr_StrtStopFail' */
    ESSR_ac_B.Dsr_StrtStopFail = VeESSR_b_StrtStopFail_DS;

    /* DataStoreRead: '<S18>/Dsr_InhibitShiftToMode' */
    ESSR_ac_B.Dsr_InhibitShiftToMode = VeESSR_b_InhibitShiftToMode_DS;

    /* DataStoreRead: '<S18>/Dsr_InputTorqOverride' */
    ESSR_ac_B.Dsr_InputTorqOverride = VeESSR_b_InputTorqOverride_DS;

    /* DataStoreRead: '<S18>/Dsr_InputTorqOverride1' */
    ESSR_ac_B.Dsr_InputTorqOverride1 = VeESSR_M_EngTorqEst_DS;

    /* DataStoreRead: '<S18>/Dsr_TransFldPmpSel' */
    ESSR_ac_B.Dsr_TransFldPmpSel = VeESSR_e_TransFldPmpSel_DS;

    /* DataStoreRead: '<S18>/Dsr_SpdCtlGainMod' */
    ESSR_ac_B.Dsr_SpdCtlGainMod = VeESSR_scl_SpdCtlGainMod_DS;

    /* DataStoreRead: '<S18>/Dsr_EngTrqRespType' */
    ESSR_ac_B.Dsr_EngTrqRespType = VeESSR_e_EngTrqRespType_DS;

    /* DataStoreRead: '<S18>/Dsr_EngTrqReqImmed' */
    ESSR_ac_B.Dsr_EngTrqReqImmed = VeESSR_M_EngTrqReqImmed_DS;

    /* DataStoreRead: '<S18>/Dsr_EngTrqReqPrdtd' */
    ESSR_ac_B.Dsr_EngTrqReqPrdtd = VeESSR_M_EngTrqReqPrdtd_DS;

    /* Outputs for Atomic SubSystem: '<S18>/ClosedInterval' */
    /* Logic: '<S3146>/Logical Operator' incorporates:
     *  Constant: '<S3148>/Constant'
     *  Constant: '<S3149>/Constant'
     *  DataStoreRead: '<S18>/Dsr_EngStartStopSt'
     *  DataTypeConversion: '<S3163>/Data Type Conversion'
     *  RelationalOperator: '<S3146>/Relatonal Operator'
     *  RelationalOperator: '<S3146>/Relatonal Operator1'
     *  Selector: '<S3163>/Selector1'
     */
    ESSR_ac_B.LogicalOperator = ((((uint32)VeESSR_e_EngStartStopSt_DS) >=
        CeESSR_e_PrepForStopSt) && (((uint32)VeESSR_e_EngStartStopSt_DS) <=
        CeESSR_e_ImmedStopSt));

    /* End of Outputs for SubSystem: '<S18>/ClosedInterval' */

    /* DataStoreRead: '<S18>/Dsr_EngStartAbort' */
    ESSR_ac_B.Dsr_EngStartAbort = VeESSR_b_EngStartAbort_DS;

    /* DataStoreRead: '<S18>/Dsr_AStrtPBatBoostReq' */
    ESSR_ac_B.Dsr_AStrtPBatBoostReq = VeESSR_b_AStrtPBatBoostReq_DS;

    /* DataStoreRead: '<S18>/Dsr_DisableNc1DotLim' */
    ESSR_ac_B.Dsr_DisableNc1DotLim = VeESSR_b_DisableNc1DotLim_DS;

    /* DataStoreRead: '<S18>/Dsr_CltchStckOn' */
    ESSR_ac_B.Dsr_CltchStckOn = VeESSR_b_CltchStckOn_DS;

    /* DataStoreRead: '<S18>/Dsr_DsblNiClsdLoopCntrl' */
    ESSR_ac_B.Dsr_DsblNiClsdLoopCntrl = VeESSR_b_DsblNiClsdLoopCntrl_DS;

    /* DataStoreRead: '<S18>/Dsr_EngCntrlMode' */
    ESSR_ac_B.Dsr_EngCntrlMode = VeESSR_e_EngCntrlMode_DS;

    /* DataStoreRead: '<S18>/Dsr_AStrtFailed' */
    ESSR_ac_B.Dsr_AStrtFailed = VeESSR_b_AStrtFailed_DS;

    /* DataStoreRead: '<S18>/Dsr_AStrtFailed1' */
    ESSR_ac_B.Dsr_AStrtFailed1 = VeESSR_b_HCP_StopStart_Fault_DS;

    /* DataStoreRead: '<S18>/Dsr_SpdCtlGainMod1' */
    ESSR_ac_B.Dsr_SpdCtlGainMod1 = VeESSR_scl_AEMDMtrAGain_DS;

    /* DataStoreRead: '<S18>/Dsr_SpdCtlGainMod2' */
    ESSR_ac_B.Dsr_SpdCtlGainMod2 = VeESSR_scl_AEMDMtrBGain_DS;

    /* Logic: '<S18>/Logical2' incorporates:
     *  Constant: '<S3154>/Constant'
     *  DataStoreRead: '<S18>/Dsr_EngStrtStpMd1'
     *  DataStoreRead: '<S18>/Dsr_SE_EngFuelOn'
     *  RelationalOperator: '<S18>/Not Equal2'
     */
    ESSR_ac_B.Logical2 = ((VeESSR_b_SE_EngFuelOn_DS) || (((uint32)
                            VeESSR_e_EngStrtStpMd_DS) ==
                           CeESSR_e_ProducingTorque));

    /* DataStoreRead: '<S18>/Dsr_EngTrqRespType2' */
    ESSR_ac_B.Dsr_EngTrqRespType2 = VeESSR_M_MtrA_MaxTorq_DS;

    /* DataStoreRead: '<S18>/Dsr_EngTrqRespType3' */
    ESSR_ac_B.Dsr_EngTrqRespType3 = VeESSR_M_MtrA_MinTorq_DS;

    /* DataStoreRead: '<S18>/Dsr_EngTrqRespType4' */
    ESSR_ac_B.Dsr_EngTrqRespType4 = VeESSR_M_EngStrtTorq_DS;

    /* DataStoreRead: '<S18>/Dsr_EngTrqRespType5' */
    ESSR_ac_B.Dsr_EngTrqRespType5 = VeESSR_n_NbTgt_DS;

    /* RelationalOperator: '<S18>/Greater  Than1' incorporates:
     *  Constant: '<S3158>/Calib'
     *  DataStoreRead: '<S18>/Data Store Read1'
     */
    ESSR_ac_B.GreaterThan1 = (VeESSR_Cnt_BumpStrtAttmptCntr_DS <
        KeESSR_Cnt_BumpStrtMaxAttmpts);

    /* DataStoreRead: '<S18>/Dsr_EngTrqRespType6' */
    ESSR_ac_B.Dsr_EngTrqRespType6 = VeESSR_g_StrtStpFailPhase_DS;

    /* DataStoreRead: '<S18>/Dsr_AStrtFailed2' */
    ESSR_ac_B.Dsr_AStrtFailed2 = VeESSR_b_AStrtReattmptAllowed_DS;

    /* DataStoreRead: '<S18>/Dsr_EngTrqRespType9' */
    ESSR_ac_B.Dsr_EngTrqRespType9 = VeESSR_n_StrtTypAStrtSpinUpExtSpd_DS;

    /* DataStoreRead: '<S18>/Dsr_EngTrqRespType10' */
    ESSR_ac_B.Dsr_EngTrqRespType10 = VeESSR_i_CalLoader_DS;

    /* DataStoreRead: '<S18>/TCMOpenDiscCltch' */
    ESSR_ac_B.TCMOpenDiscCltch = VeESSR_b_TCMOpenDisconnctCltch_DS;

    /* DataStoreRead: '<S18>/Dsr_STMTmr7' */
    ESSR_ac_B.Dsr_STMTmr7 = VeESSR_e_TCM_TransitionStatus_DS;

    /* DataStoreRead: '<S18>/TCMOpenDiscCltch1' */
    ESSR_ac_B.TCMOpenDiscCltch1 = VeESSR_b_BackUpStartEng_DS;

    /* DataStoreRead: '<S18>/TCMOpenDiscCltch3' */
    ESSR_ac_B.TCMOpenDiscCltch3 = VeESSR_M_MtrB_MaxTorq_DS;

    /* DataStoreRead: '<S18>/TCMOpenDiscCltch4' */
    ESSR_ac_B.TCMOpenDiscCltch4 = VeESSR_M_MtrB_MinTorq_DS;

    /* DataStoreRead: '<S18>/TCMOpenDiscCltch5' */
    ESSR_ac_B.TCMOpenDiscCltch5 = VeESSR_b_DsblNc1ClsdLoopCntrl_DS;

    /* SignalConversion generated from: '<S18>/VeESSR_M_Clch5_TorqCmd' */
    ESSR_ac_B.OutportBufferForVeESSR_M_Clch_o = 0.0F;

    /* DataStoreRead: '<S18>/Data Store Read3' */
    ESSR_ac_B.DataStoreRead3 = VeESSR_M_MtrC_MaxTorq_DS;

    /* DataStoreRead: '<S18>/Data Store Read5' */
    ESSR_ac_B.DataStoreRead5 = VeESSR_M_MtrC_MinTorq_DS;

    /* Outport: '<Root>/VeESSR_e_HybEngSysActv' incorporates:
     *  DataStoreRead: '<S18>/Data Store Read'
     */
    (void)Rte_Write_VeESSR_e_HybEngSysActv_Value(VeESSR_e_HybEngSysActv_DS);

    /* DataStoreRead: '<S18>/TCMOpenDiscCltch8' */
    ESSR_ac_B.TCMOpenDiscCltch8 = VeESSR_b_NbTgtReq_DS;

    /* Switch: '<S18>/Switch1' incorporates:
     *  Constant: '<S3156>/Calib'
     */
    if (HeESSR_b_EngStallReAttmpts)
    {
        /* Switch: '<S18>/Switch1' incorporates:
         *  Constant: '<S3159>/Calib'
         *  DataStoreRead: '<S18>/Data Store Read2'
         *  Logic: '<S18>/Logical Operator'
         *  RelationalOperator: '<S18>/Greater  Than3'
         */
        ESSR_ac_B.Switch1_a = (VeESSR_Cnt_EngStallReattmptCntr_DS <=
                               KeESSR_Cnt_EngStallMaxReAttmpts);
    }
    else
    {
        /* Switch: '<S18>/Switch1' incorporates:
         *  Constant: '<S18>/TRUE Constant'
         */
        ESSR_ac_B.Switch1_a = true;
    }

    /* End of Switch: '<S18>/Switch1' */

    /* DataStoreRead: '<S18>/Dsr_BSGStrtFailed' */
    ESSR_ac_B.Dsr_BSGStrtFailed = VeESSR_b_BSGStrtFailed_DS;

    /* RelationalOperator: '<S18>/Greater  Than2' incorporates:
     *  Constant: '<S3157>/Calib'
     *  DataStoreRead: '<S18>/Data Store Read4'
     */
    ESSR_ac_B.GreaterThan2 = (VeESSR_Cnt_BackupStrtAttmptCntr_DS <
        KeESSR_Cnt_BackupStrtMaxAttmpts);

    /* DataStoreRead: '<S18>/TCMOpenDiscCltch6' */
    ESSR_ac_B.TCMOpenDiscCltch6 = VeESSR_Cnt_CSSpinupAttmptCntr_DS;

    /* DataStoreRead: '<S18>/TCMOpenDiscCltch7' */
    ESSR_ac_B.TCMOpenDiscCltch7 = VeESSR_Cnt_EMSpinupAttmptCntr_DS;

    /* DataStoreRead: '<S18>/TCMOpenDiscCltch2' */
    ESSR_ac_B.TCMOpenDiscCltch2 = VeESSR_e_EngStrtProfType_DS;

    /* DataStoreRead: '<S18>/Dsr_EngTrqRespType7' */
    ESSR_ac_B.Dsr_EngTrqRespType7 = VeESSR_n_OptInputSpd_DS;

    /* DataStoreRead: '<S18>/Dsr_EngTrqRespType8' */
    ESSR_ac_B.Dsr_EngTrqRespType8 = VeESSR_n_TgtIdleSpd_DS;

    /* DataStoreRead: '<S18>/Data Store Read8' */
    ESSR_ac_B.DataStoreRead8 = VeESSR_M_MaxSparkAuthority_DS;

    /* DataStoreRead: '<S18>/Data Store Read7' */
    ESSR_ac_B.DataStoreRead7 = VeESSR_M_EngineLosses_DS;

    /* DataStoreRead: '<S18>/Data Store Read6' */
    ESSR_ac_B.DataStoreRead6 = VeESSR_n_NiPred_DS;

    /* Selector: '<S18>/Selector' incorporates:
     *  Constant: '<S3155>/Calib'
     *  DataStoreRead: '<S18>/Dsr_EngStartStopSt'
     *  DataTypeConversion: '<S3163>/Data Type Conversion'
     *  Selector: '<S3163>/Selector1'
     */
    ESSR_ac_B.Selector_g = HaESSR_b_DisableMtrA[(VeESSR_e_EngStartStopSt_DS)];

    /* DataStoreRead: '<S18>/NeESSR_g_StrtStpFailRsn' */
    ESSR_ac_B.NeESSR_g_StrtStpFailRsn = ESSR_ac_DW.NeESSR_g_StrtStpFailRsn;

    /* End of Outputs for SubSystem: '<S2>/ESSC_WrtOut_MedTEB' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen' */
#endif

    /* End of SignalConversion generated from: '<S2>/VeTRAR_M_EngTorqCmndImmed' */
#if Rte_SysCon_Variant_ESSR_NF

    /* S-Function (fcgen): '<S2>/FcnCallGen1' */
    /* Outputs for Function Call SubSystem: '<S2>/HybEngSysActv' */
    /* Switch: '<S20>/Switch' incorporates:
     *  Constant: '<S3219>/Constant'
     *  Constant: '<S3220>/Constant'
     *  Constant: '<S3221>/Constant'
     *  RelationalOperator: '<S20>/Comparison4'
     *  SignalConversion generated from: '<S2>/VeSTRR_e_HybStrtrSt'
     */
    if (((uint32)ESSR_ac_B.TmpSignalConversionAtVeSTRR_e_H) == CeSTRR_e_KeyOffSt)
    {
        tmp_1 = CeESSR_e_HybEngDisabled;
    }
    else
    {
        tmp_1 = CeESSR_e_HybEngEnabledOff;
    }

    /* Outport: '<Root>/VeESSR_e_HybEngSysActv' incorporates:
     *  Switch: '<S20>/Switch'
     */
    (void)Rte_Write_VeESSR_e_HybEngSysActv_Value(tmp_1);

    /* End of Outputs for SubSystem: '<S2>/HybEngSysActv' */
    /* End of Outputs for S-Function (fcgen): '<S2>/FcnCallGen1' */
#endif

    /* SignalConversion generated from: '<S2>/ESSC_WrtOut_12p5__VeESSR_n_OptInputSpd' incorporates:
     *  SignalConversion generated from: '<S2>/VeESSD_b_IUMPR_P1C64Fail'
     *  SignalConversion generated from: '<S2>/VeESSD_b_IUMPR_P1C65Fail'
     *  SignalConversion generated from: '<S2>/VeESSD_b_IUMPR_P1C68Fail'
     *  SignalConversion generated from: '<S2>/VeESSR_Cnt_CSSpinupAttmptCntr'
     *  SignalConversion generated from: '<S2>/VeESSR_Cnt_EMSpinupAttmptCntr'
     *  SignalConversion generated from: '<S2>/VeESSR_M_BCTiMargin'
     *  SignalConversion generated from: '<S2>/VeESSR_M_Clch5_TorqCmd'
     *  SignalConversion generated from: '<S2>/VeESSR_M_EngStrtTorq'
     *  SignalConversion generated from: '<S2>/VeESSR_M_EngTorqEst'
     *  SignalConversion generated from: '<S2>/VeESSR_M_EngTrqReqImmed'
     *  SignalConversion generated from: '<S2>/VeESSR_M_EngTrqReqPrdtd'
     *  SignalConversion generated from: '<S2>/VeESSR_M_EngineLosses'
     *  SignalConversion generated from: '<S2>/VeESSR_M_MtrA_MaxTorq'
     *  SignalConversion generated from: '<S2>/VeESSR_M_MtrA_MinTorq'
     *  SignalConversion generated from: '<S2>/VeESSR_M_MtrB_MaxTorq'
     *  SignalConversion generated from: '<S2>/VeESSR_M_MtrB_MinTorq'
     *  SignalConversion generated from: '<S2>/VeESSR_M_MtrC_MaxTorq'
     *  SignalConversion generated from: '<S2>/VeESSR_M_MtrC_MinTorq'
     *  SignalConversion generated from: '<S2>/VeESSR_b_AStrtFailed'
     *  SignalConversion generated from: '<S2>/VeESSR_b_AStrtPBatBoostReq'
     *  SignalConversion generated from: '<S2>/VeESSR_b_AStrtReattmptAllowed'
     *  SignalConversion generated from: '<S2>/VeESSR_b_BSGStrtFailed'
     *  SignalConversion generated from: '<S2>/VeESSR_b_BackUpStartEng'
     *  SignalConversion generated from: '<S2>/VeESSR_b_BkupStrtsAllwd'
     *  SignalConversion generated from: '<S2>/VeESSR_b_BumpStrtsAllwd'
     *  SignalConversion generated from: '<S2>/VeESSR_b_CltchStckOn'
     *  SignalConversion generated from: '<S2>/VeESSR_b_DisableMtrA'
     *  SignalConversion generated from: '<S2>/VeESSR_b_DisableNc1DotLim'
     *  SignalConversion generated from: '<S2>/VeESSR_b_DsblNc1ClsdLoopCntrl'
     *  SignalConversion generated from: '<S2>/VeESSR_b_DsblNiClsdLoopCntrl'
     *  SignalConversion generated from: '<S2>/VeESSR_b_EngDFCOOffHoldReq'
     *  SignalConversion generated from: '<S2>/VeESSR_b_EngOffAllwdECM'
     *  SignalConversion generated from: '<S2>/VeESSR_b_EngProdTrq_TCM'
     *  SignalConversion generated from: '<S2>/VeESSR_b_EngStallReattmpAllwd'
     *  SignalConversion generated from: '<S2>/VeESSR_b_EngStartAbort'
     *  SignalConversion generated from: '<S2>/VeESSR_b_EngStrtStpActive'
     *  SignalConversion generated from: '<S2>/VeESSR_b_HCPFuelDisable'
     *  SignalConversion generated from: '<S2>/VeESSR_b_HCP_StopStart_Fault'
     *  SignalConversion generated from: '<S2>/VeESSR_b_Hyb_ProducingTorque'
     *  SignalConversion generated from: '<S2>/VeESSR_b_InhibitShiftToMode'
     *  SignalConversion generated from: '<S2>/VeESSR_b_InputTorqOverride'
     *  SignalConversion generated from: '<S2>/VeESSR_b_NbTgtReq'
     *  SignalConversion generated from: '<S2>/VeESSR_b_OptimdEngOnOffCmd'
     *  SignalConversion generated from: '<S2>/VeESSR_b_P1C64_Failed'
     *  SignalConversion generated from: '<S2>/VeESSR_b_P1C64_Passed'
     *  SignalConversion generated from: '<S2>/VeESSR_b_P1C65_Failed'
     *  SignalConversion generated from: '<S2>/VeESSR_b_P1C65_Passed'
     *  SignalConversion generated from: '<S2>/VeESSR_b_P1C68_Failed'
     *  SignalConversion generated from: '<S2>/VeESSR_b_P1C68_Passed'
     *  SignalConversion generated from: '<S2>/VeESSR_b_StrtStopFail'
     *  SignalConversion generated from: '<S2>/VeESSR_b_TCMOpenDisconnctCltch'
     *  SignalConversion generated from: '<S2>/VeESSR_dn_InputAcceltnProf'
     *  SignalConversion generated from: '<S2>/VeESSR_e_EngCntrlMode'
     *  SignalConversion generated from: '<S2>/VeESSR_e_EngStartStopSt'
     *  SignalConversion generated from: '<S2>/VeESSR_e_EngState_eTPUTgtSyncSt'
     *  SignalConversion generated from: '<S2>/VeESSR_e_EngStrtProfType'
     *  SignalConversion generated from: '<S2>/VeESSR_e_EngStrtStpMd'
     *  SignalConversion generated from: '<S2>/VeESSR_e_EngStrtType'
     *  SignalConversion generated from: '<S2>/VeESSR_e_EngTrqRespType'
     *  SignalConversion generated from: '<S2>/VeESSR_e_OptimdEngStrtStpType'
     *  SignalConversion generated from: '<S2>/VeESSR_e_OptimdStrtReqdActr'
     *  SignalConversion generated from: '<S2>/VeESSR_e_TCM_StartStopType'
     *  SignalConversion generated from: '<S2>/VeESSR_e_TCM_TransitionStatus'
     *  SignalConversion generated from: '<S2>/VeESSR_e_TransFldPmpCmd'
     *  SignalConversion generated from: '<S2>/VeESSR_g_StrtStpFailPhase'
     *  SignalConversion generated from: '<S2>/VeESSR_g_StrtStpFailRsn'
     *  SignalConversion generated from: '<S2>/VeESSR_i_CalLoader'
     *  SignalConversion generated from: '<S2>/VeESSR_n_InputSpeedProfile'
     *  SignalConversion generated from: '<S2>/VeESSR_n_NbTgt'
     *  SignalConversion generated from: '<S2>/VeESSR_n_NiPred'
     *  SignalConversion generated from: '<S2>/VeESSR_n_StrtTypAStrtSpinUpExtSpd'
     *  SignalConversion generated from: '<S2>/VeESSR_n_TgtIdleSpd'
     *  SignalConversion generated from: '<S2>/VeESSR_r_MaxSparkAuthority'
     *  SignalConversion generated from: '<S2>/VeESSR_scl_AEMDMtrAGain'
     *  SignalConversion generated from: '<S2>/VeESSR_scl_AEMDMtrBGain'
     *  SignalConversion generated from: '<S2>/VeESSR_scl_SpdCtlGainMod'
     */
#if Rte_SysCon_Variant_ESSR_Func

    /* Outport: '<Root>/VeESSR_n_OptInputSpd' */
    (void)Rte_Write_VeESSR_n_OptInputSpd_Value(ESSR_ac_B.Dsr_EngTrqRespType7);

    /* Outport: '<Root>/VeESSR_b_IUMPR_P1C64Fail' */
    (void)Rte_Write_VeESSR_b_IUMPR_P1C64Fail_Value(ESSR_ac_B.AND_p);

    /* Outport: '<Root>/VeESSR_b_IUMPR_P1C65Fail' */
    (void)Rte_Write_VeESSR_b_IUMPR_P1C65Fail_Value(ESSR_ac_B.AND_n);

    /* Outport: '<Root>/VeESSR_b_IUMPR_P1C68Fail' */
    (void)Rte_Write_VeESSR_b_IUMPR_P1C68Fail_Value(ESSR_ac_B.AND_nb);

    /* Outport: '<Root>/VeESSR_Cnt_CSSpinupAttmptCntr' */
    (void)Rte_Write_VeESSR_Cnt_CSSpinupAttmptCntr_Value
        (ESSR_ac_B.TCMOpenDiscCltch6);

    /* Outport: '<Root>/VeESSR_Cnt_EMSpinupAttmptCntr' */
    (void)Rte_Write_VeESSR_Cnt_EMSpinupAttmptCntr_Value
        (ESSR_ac_B.TCMOpenDiscCltch7);

    /* Outport: '<Root>/VeESSR_M_BCTiMargin' */
    (void)Rte_Write_VeESSR_M_BCTiMargin_Value(ESSR_ac_B.Switch1);

    /* Outport: '<Root>/VeESSR_M_Clch5_TorqCmd' */
    (void)Rte_Write_VeESSR_M_Clch5_TorqCmd_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_Clch_o);

    /* Outport: '<Root>/VeESSR_M_EngStrtTorq' */
    (void)Rte_Write_VeESSR_M_EngStrtTorq_Value(ESSR_ac_B.Dsr_EngTrqRespType4);

    /* Outport: '<Root>/VeESSR_M_EngTorqEst' */
    (void)Rte_Write_VeESSR_M_EngTorqEst_Value(ESSR_ac_B.Dsr_InputTorqOverride1);

    /* Outport: '<Root>/VeESSR_M_EngTrqReqImmed' */
    (void)Rte_Write_VeESSR_M_EngTrqReqImmed_Value(ESSR_ac_B.Dsr_EngTrqReqImmed);

    /* Outport: '<Root>/VeESSR_M_EngTrqReqPrdtd' */
    (void)Rte_Write_VeESSR_M_EngTrqReqPrdtd_Value(ESSR_ac_B.Dsr_EngTrqReqPrdtd);

    /* Outport: '<Root>/VeESSR_M_EngineLosses' */
    (void)Rte_Write_VeESSR_M_EngineLosses_Value(ESSR_ac_B.DataStoreRead7);

    /* Outport: '<Root>/VeESSR_M_MtrA_MaxTorq' */
    (void)Rte_Write_VeESSR_M_MtrA_MaxTorq_Value(ESSR_ac_B.Dsr_EngTrqRespType2);

    /* Outport: '<Root>/VeESSR_M_MtrA_MinTorq' */
    (void)Rte_Write_VeESSR_M_MtrA_MinTorq_Value(ESSR_ac_B.Dsr_EngTrqRespType3);

    /* Outport: '<Root>/VeESSR_M_MtrB_MaxTorq' */
    (void)Rte_Write_VeESSR_M_MtrB_MaxTorq_Value(ESSR_ac_B.TCMOpenDiscCltch3);

    /* Outport: '<Root>/VeESSR_M_MtrB_MinTorq' */
    (void)Rte_Write_VeESSR_M_MtrB_MinTorq_Value(ESSR_ac_B.TCMOpenDiscCltch4);

    /* Outport: '<Root>/VeESSR_M_MtrC_MaxTorq' */
    (void)Rte_Write_VeESSR_M_MtrC_MaxTorq_Value(ESSR_ac_B.DataStoreRead3);

    /* Outport: '<Root>/VeESSR_M_MtrC_MinTorq' */
    (void)Rte_Write_VeESSR_M_MtrC_MinTorq_Value(ESSR_ac_B.DataStoreRead5);

    /* Outport: '<Root>/VeESSR_b_AStrtFailed' */
    (void)Rte_Write_VeESSR_b_AStrtFailed_Value(ESSR_ac_B.Dsr_AStrtFailed);

    /* Outport: '<Root>/VeESSR_b_AStrtPBatBoostReq' */
    (void)Rte_Write_VeESSR_b_AStrtPBatBoostReq_Value
        (ESSR_ac_B.Dsr_AStrtPBatBoostReq);

    /* Outport: '<Root>/VeESSR_b_AStrtReattmptAllowed' */
    (void)Rte_Write_VeESSR_b_AStrtReattmptAllowed_Value
        (ESSR_ac_B.Dsr_AStrtFailed2);

    /* Outport: '<Root>/VeESSR_b_BSGStrtFailed' */
    (void)Rte_Write_VeESSR_b_BSGStrtFailed_Value(ESSR_ac_B.Dsr_BSGStrtFailed);

    /* Outport: '<Root>/VeESSR_b_BackUpStartEng' */
    (void)Rte_Write_VeESSR_b_BackUpStartEng_Value(ESSR_ac_B.TCMOpenDiscCltch1);

    /* Outport: '<Root>/VeESSR_b_BkupStrtsAllwd' */
    (void)Rte_Write_VeESSR_b_BkupStrtsAllwd_Value(ESSR_ac_B.GreaterThan2);

    /* Outport: '<Root>/VeESSR_b_BumpStrtsAllwd' */
    (void)Rte_Write_VeESSR_b_BumpStrtsAllwd_Value(ESSR_ac_B.GreaterThan1);

    /* Outport: '<Root>/VeESSR_b_CltchStckOn' */
    (void)Rte_Write_VeESSR_b_CltchStckOn_Value(ESSR_ac_B.Dsr_CltchStckOn);

    /* Outport: '<Root>/VeESSR_b_DisableMtrA' */
    (void)Rte_Write_VeESSR_b_DisableMtrA_Value(ESSR_ac_B.Selector_g);

    /* Outport: '<Root>/VeESSR_b_DisableNc1DotLim' */
    (void)Rte_Write_VeESSR_b_DisableNc1DotLim_Value
        (ESSR_ac_B.Dsr_DisableNc1DotLim);

    /* Outport: '<Root>/VeESSR_b_DsblNc1ClsdLoopCntrl' */
    (void)Rte_Write_VeESSR_b_DsblNc1ClsdLoopCntrl_Value
        (ESSR_ac_B.TCMOpenDiscCltch5);

    /* Outport: '<Root>/VeESSR_b_DsblNiClsdLoopCntrl' */
    (void)Rte_Write_VeESSR_b_DsblNiClsdLoopCntrl_Value
        (ESSR_ac_B.Dsr_DsblNiClsdLoopCntrl);

    /* Outport: '<Root>/VeESSR_b_EngDFCOOffHoldReq' */
    (void)Rte_Write_VeESSR_b_EngDFCOOffHoldReq_Value(ESSR_ac_B.LogicalOperator);

    /* Outport: '<Root>/VeESSR_b_EngOffAllwdECM' */
    (void)Rte_Write_VeESSR_b_EngOffAllwdECM_Value(ESSR_ac_B.Switch1_p);

    /* Outport: '<Root>/VeESSR_b_EngProdTrq_TCM' */
    (void)Rte_Write_VeESSR_b_EngProdTrq_TCM_Value(ESSR_ac_B.Logical2);

    /* Outport: '<Root>/VeESSR_b_EngStallReattmpAllwd' */
    (void)Rte_Write_VeESSR_b_EngStallReattmpAllwd_Value(ESSR_ac_B.Switch1_a);

    /* Outport: '<Root>/VeESSR_b_EngStartAbort' */
    (void)Rte_Write_VeESSR_b_EngStartAbort_Value(ESSR_ac_B.Dsr_EngStartAbort);

    /* Outport: '<Root>/VeESSR_b_EngStrtStpActive' */
    (void)Rte_Write_VeESSR_b_EngStrtStpActive_Value(ESSR_ac_B.NotEqual1);

    /* Outport: '<Root>/VeESSR_b_HCPFuelDisable' */
    (void)Rte_Write_VeESSR_b_HCPFuelDisable_Value(ESSR_ac_B.Selector1);

    /* Outport: '<Root>/VeESSR_b_HCP_StopStart_Fault' */
    (void)Rte_Write_VeESSR_b_HCP_StopStart_Fault_Value
        (ESSR_ac_B.Dsr_AStrtFailed1);

    /* Outport: '<Root>/VeESSR_b_Hyb_ProducingTorque' */
    (void)Rte_Write_VeESSR_b_Hyb_ProducingTorque_Value(ESSR_ac_B.Selector2);

    /* Outport: '<Root>/VeESSR_b_InhibitShiftToMode' */
    (void)Rte_Write_VeESSR_b_InhibitShiftToMode_Value
        (ESSR_ac_B.Dsr_InhibitShiftToMode);

    /* Outport: '<Root>/VeESSR_b_InputTorqOverride' */
    (void)Rte_Write_VeESSR_b_InputTorqOverride_Value
        (ESSR_ac_B.Dsr_InputTorqOverride);

    /* Outport: '<Root>/VeESSR_b_NbTgtReq' */
    (void)Rte_Write_VeESSR_b_NbTgtReq_Value(ESSR_ac_B.TCMOpenDiscCltch8);

    /* Outport: '<Root>/VeESSR_b_OptimdEngOnOffCmd' */
    (void)Rte_Write_VeESSR_b_OptimdEngOnOffCmd_Value(ESSR_ac_B.Selector);

    /* Outport: '<Root>/VeESSR_b_P1C64_Failed' */
    (void)Rte_Write_VeESSR_b_P1C64_Failed_Value(ESSR_ac_B.Logical13);

    /* Outport: '<Root>/VeESSR_b_P1C64_Passed' */
    (void)Rte_Write_VeESSR_b_P1C64_Passed_Value(ESSR_ac_B.Logical22);

    /* Outport: '<Root>/VeESSR_b_P1C65_Failed' */
    (void)Rte_Write_VeESSR_b_P1C65_Failed_Value(ESSR_ac_B.Logical14);

    /* Outport: '<Root>/VeESSR_b_P1C65_Passed' */
    (void)Rte_Write_VeESSR_b_P1C65_Passed_Value(ESSR_ac_B.Logical23);

    /* Outport: '<Root>/VeESSR_b_P1C68_Failed' */
    (void)Rte_Write_VeESSR_b_P1C68_Failed_Value(ESSR_ac_B.Logical17);

    /* Outport: '<Root>/VeESSR_b_P1C68_Passed' */
    (void)Rte_Write_VeESSR_b_P1C68_Passed_Value(ESSR_ac_B.Logical26);

    /* Outport: '<Root>/VeESSR_b_StrtStopFail' */
    (void)Rte_Write_VeESSR_b_StrtStopFail_Value(ESSR_ac_B.Dsr_StrtStopFail);

    /* Outport: '<Root>/VeESSR_b_TCMOpenDisconnctCltch' */
    (void)Rte_Write_VeESSR_b_TCMOpenDisconnctCltch_Value
        (ESSR_ac_B.TCMOpenDiscCltch);

    /* Outport: '<Root>/VeESSR_dn_InputAcceltnProf' */
    (void)Rte_Write_VeESSR_dn_InputAcceltnProf_Value(ESSR_ac_B.Switch3);

    /* Outport: '<Root>/VeESSR_e_EngCntrlMode' incorporates:
     *  DataStoreRead: '<S18>/Dsr_EngCntrlMode'
     */
    (void)Rte_Write_VeESSR_e_EngCntrlMode_Value(ESSR_ac_B.Dsr_EngCntrlMode);

    /* Outport: '<Root>/VeESSR_e_EngStartStopSt' incorporates:
     *  DataTypeConversion: '<S3152>/DataTypeConversion'
     */
    (void)Rte_Write_VeESSR_e_EngStartStopSt_Value(ESSR_ac_B.DataTypeConversion_f);

    /* Outport: '<Root>/VeESSR_e_EngState_eTPUTgtSyncSt' incorporates:
     *  Switch: '<S3163>/Switch3'
     */
    (void)Rte_Write_VeESSR_e_EngState_eTPUTgtSyncSt_Value(ESSR_ac_B.Switch3_p);

    /* Outport: '<Root>/VeESSR_e_EngStrtProfType' incorporates:
     *  DataStoreRead: '<S18>/TCMOpenDiscCltch2'
     */
    (void)Rte_Write_VeESSR_e_EngStrtProfType_Value(ESSR_ac_B.TCMOpenDiscCltch2);

    /* Outport: '<Root>/VeESSR_e_EngStrtStpMd' incorporates:
     *  DataTypeConversion: '<S3153>/DataTypeConversion'
     */
    (void)Rte_Write_VeESSR_e_EngStrtStpMd_Value(ESSR_ac_B.DataTypeConversion);

    /* Outport: '<Root>/VeESSR_e_EngStrtType' incorporates:
     *  DataStoreRead: '<S18>/Dsr_EngStrtType'
     */
    (void)Rte_Write_VeESSR_e_EngStrtType_Value(ESSR_ac_B.Dsr_EngStrtType_b);

    /* Outport: '<Root>/VeESSR_e_EngTrqRespType' incorporates:
     *  DataStoreRead: '<S18>/Dsr_EngTrqRespType'
     */
    (void)Rte_Write_VeESSR_e_EngTrqRespType_Value(ESSR_ac_B.Dsr_EngTrqRespType);

    /* Outport: '<Root>/VeESSR_e_OptimdEngStrtStpType' incorporates:
     *  Selector: '<S3162>/Selector4'
     */
    (void)Rte_Write_VeESSR_e_OptimdEngStrtStpType_Value(ESSR_ac_B.Selector4);

    /* Outport: '<Root>/VeESSR_e_OptimdStrtReqdActr' incorporates:
     *  DataTypeConversion: '<S3188>/DataTypeConversion'
     */
    (void)Rte_Write_VeESSR_e_OptimdStrtReqdActr_Value
        (ESSR_ac_B.DataTypeConversion_k);

    /* Outport: '<Root>/VeESSR_e_TCM_StartStopType' incorporates:
     *  VariantMerge generated from: '<S3161>/Variant Source'
     */
    (void)Rte_Write_VeESSR_e_TCM_StartStopType_Value
        (ESSR_ac_B.VariantMerge_For_Variant_Sour_h);

    /* Outport: '<Root>/VeESSR_e_TCM_TransitionStatus' incorporates:
     *  DataStoreRead: '<S18>/Dsr_STMTmr7'
     */
    (void)Rte_Write_VeESSR_e_TCM_TransitionStatus_Value(ESSR_ac_B.Dsr_STMTmr7);

    /* Outport: '<Root>/VeESSR_e_TransFldPmpCmd' incorporates:
     *  DataStoreRead: '<S18>/Dsr_TransFldPmpSel'
     */
    (void)Rte_Write_VeESSR_e_TransFldPmpCmd_Value(ESSR_ac_B.Dsr_TransFldPmpSel);

    /* Outport: '<Root>/VeESSR_g_StrtStpFailPhase' */
    (void)Rte_Write_VeESSR_g_StrtStpFailPhase_Value
        (ESSR_ac_B.Dsr_EngTrqRespType6);

    /* Outport: '<Root>/VeESSR_g_StrtStpFailRsn' */
    (void)Rte_Write_VeESSR_g_StrtStpFailRsn_Value
        (ESSR_ac_B.NeESSR_g_StrtStpFailRsn);

    /* Outport: '<Root>/VeESSR_i_CalLoader' */
    (void)Rte_Write_VeESSR_i_CalLoader_Value(ESSR_ac_B.Dsr_EngTrqRespType10);

    /* Outport: '<Root>/VeESSR_n_InputSpeedProfile' */
    (void)Rte_Write_VeESSR_n_InputSpeedProfile_Value(ESSR_ac_B.Switch);

    /* Outport: '<Root>/VeESSR_n_NbTgt' */
    (void)Rte_Write_VeESSR_n_NbTgt_Value(ESSR_ac_B.Dsr_EngTrqRespType5);

    /* Outport: '<Root>/VeESSR_n_NiPred' */
    (void)Rte_Write_VeESSR_n_NiPred_Value(ESSR_ac_B.DataStoreRead6);

    /* Outport: '<Root>/VeESSR_n_StrtTypAStrtSpinUpExtSpd' */
    (void)Rte_Write_VeESSR_n_StrtTypAStrtSpinUpExtSpd_Value
        (ESSR_ac_B.Dsr_EngTrqRespType9);

    /* Outport: '<Root>/VeESSR_n_TgtIdleSpd' */
    (void)Rte_Write_VeESSR_n_TgtIdleSpd_Value(ESSR_ac_B.Dsr_EngTrqRespType8);

    /* Outport: '<Root>/VeESSR_r_MaxSparkAuthority' */
    (void)Rte_Write_VeESSR_r_MaxSparkAuthority_Value(ESSR_ac_B.DataStoreRead8);

    /* Outport: '<Root>/VeESSR_scl_AEMDMtrAGain' */
    (void)Rte_Write_VeESSR_scl_AEMDMtrAGain_Value(ESSR_ac_B.Dsr_SpdCtlGainMod1);

    /* Outport: '<Root>/VeESSR_scl_AEMDMtrBGain' */
    (void)Rte_Write_VeESSR_scl_AEMDMtrBGain_Value(ESSR_ac_B.Dsr_SpdCtlGainMod2);

    /* Outport: '<Root>/VeESSR_scl_SpdCtlGainMod' */
    (void)Rte_Write_VeESSR_scl_SpdCtlGainMod_Value(ESSR_ac_B.Dsr_SpdCtlGainMod);

#endif

    /* End of SignalConversion generated from: '<S2>/ESSC_WrtOut_12p5__VeESSR_n_OptInputSpd' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTEB' */
}

/* Model step function for TID3 */
#if Rte_SysCon_Variant_ESSR_Func

FUNC(void, ESSR_CODE) ESSR_MedTED(void) /* Explicit Task: MedTED */
{

#if Rte_SysCon_Variant_ESSR_Func

    float32 tmpRead;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 tmpRead_0;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 tmpRead_1;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    boolean tmpRead_2;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 tmpRead_3;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_Switch1_ic;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_TmpSignalConversionAtVeTITR;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_Sum2_o1;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_MinMax1;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_Sum;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_TmpSignalConversionAtVeTRAR;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    float32 rtb_Sum2_ppe;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    /* RootInportFunctionCallGenerator generated from: '<Root>/MedTED' */
    /* Inport: '<Root>/VeETQR_M_EngCapacityMinRunImmedNom' */
    (void)Rte_Read_VeETQR_M_EngCapacityMinRunImmedNom_Value(&rtb_Sum2_ppe);

    /* Inport: '<Root>/VeETQR_b_EngCapacityMinRunImmedRedAvail' */
    (void)Rte_Read_VeETQR_b_EngCapacityMinRunImmedRedAvail_Value(&tmpRead_2);

    /* Inport: '<Root>/VeETQR_M_EngCapacityMinRunImmedRed' */
    (void)Rte_Read_VeETQR_M_EngCapacityMinRunImmedRed_Value(&tmpRead_1);

    /* Inport: '<Root>/VeETQR_M_EngTorqACC4Capability' */
    (void)Rte_Read_VeETQR_M_EngTorqACC4Capability_Value(&rtb_Switch1_ic);

    /* Inport: '<Root>/VeETQR_M_EngTrqAirflow' */
    (void)Rte_Read_VeETQR_M_EngTrqAirflow_Value(&rtb_Sum2_o1);

    /* Inport: '<Root>/VeETQR_M_EngCapacityMinOff' */
    (void)Rte_Read_VeETQR_M_EngCapacityMinOff_Value(&tmpRead);

    /* Outputs for Function Call SubSystem: '<Root>/ESSR_MedTED' */
    /* SignalConversion generated from: '<S3>/VeTRAR_M_TeMax' incorporates:
     *  Inport: '<Root>/VeTRAR_M_TeMax'
     */
    (void)Rte_Read_VeTRAR_M_TeMax_Value(&rtb_TmpSignalConversionAtVeTRAR);

    /* SignalConversion generated from: '<S3>/VeTITR_M_PumpTorq' incorporates:
     *  Inport: '<Root>/VeTITR_M_PumpTorq'
     */
    (void)Rte_Read_VeTITR_M_PumpTorq_Value(&rtb_TmpSignalConversionAtVeTITR);

    /* S-Function (fcgen): '<S3>/FcnCallGen' incorporates:
     *  SubSystem: '<S3>/ESSC_ProcInputs'
     */

    /* Sum: '<S3262>/Sum3' incorporates:
     *  Abs: '<S3262>/Abs'
     *  Abs: '<S3262>/Abs1'
     */
    ESSR_ac_B.Sum3 = fabsf(rtb_Switch1_ic) + fabsf(tmpRead);

    /* DataStoreWrite: '<S3262>/Data Store Write' */
    VeESSR_M_EngineLosses_DS = ESSR_ac_B.Sum3;

    /* Sum: '<S3262>/Sum2' */
    rtb_Sum2_o1 += ESSR_ac_B.Sum3;

    /* Outputs for Atomic SubSystem: '<S3262>/GradientLimiter' */
    /* Switch: '<S3269>/Switch1' incorporates:
     *  UnitDelay: '<S3265>/Unit Delay'
     */
    rtb_Switch1_ic = ESSR_ac_DW.UnitDelay_DSTATE_j;

    /* End of Outputs for SubSystem: '<S3262>/GradientLimiter' */

    /* Switch: '<S3262>/Switch1' */
    if (tmpRead_2)
    {
        rtb_Sum2_ppe = tmpRead_1;
    }

    /* End of Switch: '<S3262>/Switch1' */

    /* Outputs for Atomic SubSystem: '<S3262>/GradientLimiter' */
    /* Sum: '<S3265>/Sum2' */
    rtb_Sum2_ppe -= rtb_Switch1_ic;

    /* Outputs for Atomic SubSystem: '<S3265>/Limiter' */
    /* Switch: '<S3272>/Switch1' incorporates:
     *  Constant: '<S3268>/Calib'
     *  RelationalOperator: '<S3272>/Relational Operator'
     */
    if (KeESSR_dM_EngCapMinRunImmedLU < rtb_Sum2_ppe)
    {
        /* Switch: '<S3272>/Switch1' */
        rtb_Sum2_ppe = KeESSR_dM_EngCapMinRunImmedLU;
    }

    /* End of Switch: '<S3272>/Switch1' */

    /* Switch: '<S3272>/Switch' incorporates:
     *  Constant: '<S3267>/Calib'
     *  RelationalOperator: '<S3272>/Relational Operator1'
     */
    if (rtb_Sum2_ppe <= KeESSR_dM_EngCapMinRunImmedLD)
    {
        rtb_Sum2_ppe = KeESSR_dM_EngCapMinRunImmedLD;
    }

    /* End of Switch: '<S3272>/Switch' */
    /* End of Outputs for SubSystem: '<S3265>/Limiter' */

    /* Sum: '<S3265>/Sum3' */
    VeESSR_M_EngCapacityMinRunImmed = rtb_Sum2_ppe + rtb_Switch1_ic;

    /* Update for UnitDelay: '<S3265>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE_j = VeESSR_M_EngCapacityMinRunImmed;

    /* End of Outputs for SubSystem: '<S3262>/GradientLimiter' */

    /* Sum: '<S3262>/Sum4' */
    rtb_Switch1_ic = ESSR_ac_B.Sum3 + VeESSR_M_EngCapacityMinRunImmed;

    /* Outputs for Atomic SubSystem: '<S3262>/Protected Division' */
    /* Switch: '<S3271>/Switch1' incorporates:
     *  Constant: '<S3271>/Constant Value'
     *  Constant: '<S3271>/Constant Value1'
     *  Constant: '<S3271>/Constant Value2'
     *  Constant: '<S3271>/Constant Value3'
     *  Logic: '<S3271>/AND'
     *  RelationalOperator: '<S3271>/Greater Than or Equal '
     *  RelationalOperator: '<S3271>/Greater Than or Equal 1'
     *  RelationalOperator: '<S3271>/Not Equal'
     *  RelationalOperator: '<S3271>/Not Equal1'
     *  Switch: '<S3271>/Switch2'
     *  Switch: '<S3271>/Switch3'
     */
    if ((rtb_Sum2_o1 != 0.0F) && (rtb_Switch1_ic != 0.0F))
    {
        /* Switch: '<S3271>/Switch1' incorporates:
         *  Product: '<S3271>/Division'
         */
        rtb_Switch1_ic = rtb_Sum2_o1 / rtb_Switch1_ic;
    }
    else if (rtb_Sum2_o1 > 0.0F)
    {
        /* Switch: '<S3271>/Switch2' incorporates:
         *  Constant: '<S3271>/MAXFLOAT'
         *  Switch: '<S3271>/Switch1'
         */
        rtb_Switch1_ic = 3.402823466E+38F;
    }
    else if (rtb_Sum2_o1 < 0.0F)
    {
        /* Switch: '<S3271>/Switch3' incorporates:
         *  Constant: '<S3271>/MINFLOAT'
         *  Switch: '<S3271>/Switch1'
         *  Switch: '<S3271>/Switch2'
         */
        rtb_Switch1_ic = -3.402823466E+38F;
    }
    else
    {
        /* Switch: '<S3271>/Switch1' incorporates:
         *  Constant: '<S3271>/Constant Value4'
         *  Switch: '<S3271>/Switch2'
         *  Switch: '<S3271>/Switch3'
         */
        rtb_Switch1_ic = 0.0F;
    }

    /* End of Switch: '<S3271>/Switch1' */
    /* End of Outputs for SubSystem: '<S3262>/Protected Division' */
    /* End of Outputs for S-Function (fcgen): '<S3>/FcnCallGen' */
    /* End of Outputs for SubSystem: '<Root>/ESSR_MedTED' */

    /* Inport: '<Root>/VeTRAR_M_TeMin' */
    (void)Rte_Read_VeTRAR_M_TeMin_Value(&rtb_MinMax1);

    /* Inport: '<Root>/VeOITR_M_OptInputTorq' */
    (void)Rte_Read_VeOITR_M_OptInputTorq_Value(&rtb_Sum);

    /* Inport: '<Root>/VeOITR_M_TiPredicted' */
    (void)Rte_Read_VeOITR_M_TiPredicted_Value(&tmpRead_3);

    /* Inport: '<Root>/VeETQR_M_MinAirFlowMinSparkCapacity' */
    (void)Rte_Read_VeETQR_M_MinAirFlowMinSparkCapacity_Value(&tmpRead_0);

    /* Outputs for Function Call SubSystem: '<Root>/ESSR_MedTED' */
    /* S-Function (fcgen): '<S3>/FcnCallGen' incorporates:
     *  SubSystem: '<S3>/ESSC_ProcInputs'
     */
    /* MinMax: '<S3262>/MinMax' incorporates:
     *  Constant: '<S3262>/Constant Value'
     */
    ESSR_ac_B.MinMax = fmaxf(rtb_Switch1_ic, 1.0F);

    /* DataStoreWrite: '<S3262>/Data Store Write1' */
    VeESSR_M_MaxSparkAuthority_DS = ESSR_ac_B.MinMax;

    /* MinMax: '<S3262>/MinMax1' incorporates:
     *  MinMax: '<S3262>/MinMax2'
     */
    rtb_MinMax1 = fmaxf(rtb_MinMax1, fminf(tmpRead_0,
                         VeESSR_M_EngCapacityMinRunImmed));

    /* Sum: '<S3262>/Sum' */
    rtb_Sum += rtb_TmpSignalConversionAtVeTITR;

    /* Outputs for Atomic SubSystem: '<S3262>/Limiter' */
    /* Switch: '<S3269>/Switch1' incorporates:
     *  RelationalOperator: '<S3269>/Relational Operator'
     */
    if (rtb_TmpSignalConversionAtVeTRAR < rtb_Sum)
    {
        /* Switch: '<S3269>/Switch1' */
        rtb_Switch1_ic = rtb_TmpSignalConversionAtVeTRAR;
    }
    else
    {
        /* Switch: '<S3269>/Switch1' */
        rtb_Switch1_ic = rtb_Sum;
    }

    /* End of Switch: '<S3269>/Switch1' */
    /* End of Outputs for SubSystem: '<S3262>/Limiter' */

    /* UnitDelay: '<S3262>/Unit Delay' */
    rtb_TmpSignalConversionAtVeTRAR = ESSR_ac_DW.UnitDelay_DSTATE;

    /* Outputs for Atomic SubSystem: '<S3262>/Limiter' */
    /* Switch: '<S3269>/Switch' incorporates:
     *  RelationalOperator: '<S3269>/Relational Operator1'
     */
    if (rtb_Switch1_ic > rtb_MinMax1)
    {
        rtb_MinMax1 = rtb_Switch1_ic;
    }

    /* End of Switch: '<S3269>/Switch' */
    /* End of Outputs for SubSystem: '<S3262>/Limiter' */

    /* Sum: '<S3263>/Subtraction1' incorporates:
     *  Constant: '<S3266>/Calib'
     *  Product: '<S3263>/Multiplication'
     *  Sum: '<S3263>/Subtraction'
     */
    VeESSR_M_OptEngTrqReq = ((rtb_MinMax1 - rtb_TmpSignalConversionAtVeTRAR) *
        KeESSR_K_EngStartTargetTi) + rtb_TmpSignalConversionAtVeTRAR;

    /* Sum: '<S3262>/Sum1' */
    VeESSR_M_OptEngTrqReqPred = tmpRead_3 + rtb_TmpSignalConversionAtVeTITR;

    /* SignalConversion: '<S3262>/Signal Conversion' */
    ESSR_ac_B.SignalConversion = VeESSR_M_OptEngTrqReqPred;

    /* Update for UnitDelay: '<S3262>/Unit Delay' */
    ESSR_ac_DW.UnitDelay_DSTATE = VeESSR_M_OptEngTrqReq;

    /* End of Outputs for S-Function (fcgen): '<S3>/FcnCallGen' */

    /* SignalConversion generated from: '<S3>/VeESSR_M_EngCapacityMinRunImmed_write' */
    Rte_IrvWrite_ESSR_MedTED_VeESSR_M_EngCapacityMinRunImmed_write_IRV
        (VeESSR_M_EngCapacityMinRunImmed);

    /* SignalConversion generated from: '<S3>/VeESSR_M_EngineLosses_write' */
    Rte_IrvWrite_ESSR_MedTED_VeESSR_M_EngineLosses_write_IRV(ESSR_ac_B.Sum3);

    /* SignalConversion generated from: '<S3>/VeESSR_M_MaxSparkAuthority_write' */
    Rte_IrvWrite_ESSR_MedTED_VeESSR_M_MaxSparkAuthority_write_IRV
        (ESSR_ac_B.MinMax);

    /* SignalConversion generated from: '<S3>/VeESSR_M_OptEngTrqReqPred_write' */
    Rte_IrvWrite_ESSR_MedTED_VeESSR_M_OptEngTrqReqPred_write_IRV
        (ESSR_ac_B.SignalConversion);

    /* SignalConversion generated from: '<S3>/VeESSR_M_OptEngTrqReq_write' */
    Rte_IrvWrite_ESSR_MedTED_VeESSR_M_OptEngTrqReq_write_IRV
        (VeESSR_M_OptEngTrqReq);

    /* End of Outputs for SubSystem: '<Root>/ESSR_MedTED' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/MedTED' */
#endif

}

#endif

/* Output function */
#if Rte_SysCon_Variant_ESSR_Func

FUNC(void, ESSR_CODE) ESSR_PUP(void)
{

#if Rte_SysCon_Variant_ESSR_Func

    /* RootInportFunctionCallGenerator generated from: '<Root>/PUP' */
    /* Outputs for Function Call SubSystem: '<Root>/ESSR_PUP' */
    /* S-Function (fcgen): '<S4>/FcnCallGen' incorporates:
     *  SubSystem: '<S4>/ESSC_PwrUpPT'
     */
    /* DataStoreWrite: '<S3273>/BmpStrtFailed' incorporates:
     *  Constant: '<S3273>/FALSE Constant2'
     */
    VeESSR_b_BumpStrtFailed_DS = false;

    /* Sum: '<S3273>/Sum2' incorporates:
     *  Constant: '<S3274>/Calib'
     *  Constant: '<S3275>/Calib'
     *  DataStoreWrite: '<S3273>/BmpStrtFailed1'
     */
    VeESSR_n_TgtIdleSpd_DS = KeESSR_n_PrepStopDsrdEngSpd -
        KeESSR_n_PrepStopIdleSpdDB;

    /* DataStoreWrite: '<S3273>/Dsw_StrtStpFailDTC1' incorporates:
     *  Constant: '<S3273>/Constant Value'
     */
    VeESSR_g_StrtStpFailPhase_DS = 0U;

    /* DataStoreWrite: '<S3273>/Dsw_AStrtFailed5' incorporates:
     *  Constant: '<S3273>/Constant Value1'
     */
    VeESSR_Cnt_AStrtFailAttmptCntr_DS = 0U;

    /* DataStoreWrite: '<S3273>/Dsw_AStrtFailed1' incorporates:
     *  Constant: '<S3273>/Constant Value2'
     */
    VeESSR_Cnt_BackupStrtAttmptCntr_DS = 0U;

    /* DataStoreWrite: '<S3273>/Dsw_AStrtFailed2' incorporates:
     *  Constant: '<S3273>/Constant Value3'
     */
    VeESSR_Cnt_BumpStrtAttmptCntr_DS = 0U;

    /* DataStoreWrite: '<S3273>/Dsw_AStrtFailed3' incorporates:
     *  Constant: '<S3273>/Constant Value4'
     */
    VeESSR_Cnt_CSSpinupAttmptCntr_DS = 0U;

    /* DataStoreWrite: '<S3273>/Dsw_AStrtFailed4' incorporates:
     *  Constant: '<S3273>/Constant Value5'
     */
    VeESSR_Cnt_EMSpinupAttmptCntr_DS = 0U;

    /* DataStoreWrite: '<S3273>/Data Store Write2' incorporates:
     *  Constant: '<S3273>/Constant Value6'
     */
    VeESSR_Cnt_EngStallReattmptCntr_DS = 0U;

    /* DataStoreWrite: '<S3273>/Data Store Write' incorporates:
     *  Constant: '<S3273>/FALSE Constant1'
     */
    VeESSR_b_HCP_StopStart_Fault_DS = false;

    /* DataStoreWrite: '<S3273>/Data Store Write1' incorporates:
     *  Constant: '<S3273>/FALSE Constant5'
     */
    VeESSR_b_MinRun2StpTm_DS = false;

    /* DataStoreWrite: '<S3273>/Dsw_AStrtFailed' incorporates:
     *  Constant: '<S3273>/FALSE Constant'
     */
    VeESSR_b_AStrtFailed_DS = false;

    /* DataStoreWrite: '<S3273>/Dsw_AStrtFailed6' incorporates:
     *  Constant: '<S3273>/TRUE Constant1'
     */
    VeESSR_b_AStrtReattmptAllowed_DS = true;

    /* DataStoreWrite: '<S3273>/Dsw_AStrtFailed7' incorporates:
     *  Constant: '<S3273>/FALSE Constant4'
     */
    VeESSR_b_ETSDsblFuelReq_DS = false;

    /* DataStoreWrite: '<S3273>/Dsw_AStrtFailed8' incorporates:
     *  Constant: '<S3273>/FALSE Constant6'
     */
    VeESSR_b_NbTgtReq_DS = false;

    /* DataStoreWrite: '<S3273>/TCMOpenDiscCltch' incorporates:
     *  Constant: '<S3273>/FALSE Constant3'
     */
    VeESSR_b_TCMOpenDisconnctCltch_DS = false;

    /* End of Outputs for S-Function (fcgen): '<S4>/FcnCallGen' */
    /* End of Outputs for SubSystem: '<Root>/ESSR_PUP' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/PUP' */
#endif

}

#endif

/* Output function */
FUNC(void, ESSR_CODE) ESSR_PwrOff(void)
{
    /* RootInportFunctionCallGenerator generated from: '<Root>/PwrOff' incorporates:
     *  SubSystem: '<Root>/ESSR_PwrOff'
     */
    /* Outport: '<Root>/NeESSR_M_SpinDwnAddtlOffset_PM_Out' incorporates:
     *  DataStoreRead: '<S5>/NeESSR_M_SpinDwnAddtlOffset'
     */
    (void)Rte_Write_NeESSR_M_SpinDwnAddtlOffset_NeESSR_M_SpinDwnAddtlOffset
        (ESSR_ac_DW.NeESSR_M_SpinDwnAddtlOffset);

    /* Outport: '<Root>/NeESSR_M_SpinUpAddtlOffset_PM_Out' incorporates:
     *  DataStoreRead: '<S5>/NeESSR_M_SpinUpAddtlOffset'
     */
    (void)Rte_Write_NeESSR_M_SpinUpAddtlOffset_NeESSR_M_SpinUpAddtlOffset
        (ESSR_ac_DW.NeESSR_M_SpinUpAddtlOffset);

    /* Outport: '<Root>/NeESSR_g_StrtStpFailRsn_PM_Out' incorporates:
     *  DataStoreRead: '<S5>/NeESSR_g_StrtStpFailRsn'
     */
    (void)Rte_Write_NeESSR_g_StrtStpFailRsn_NeESSR_g_StrtStpFailRsn
        (ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

    /* Outport: '<Root>/NeESSR_g_StrtStpFailRsn2_PM_Out' incorporates:
     *  DataStoreRead: '<S5>/NeESSR_g_StrtStpFailRsn2'
     */
    (void)Rte_Write_NeESSR_g_StrtStpFailRsn2_NeESSR_g_StrtStpFailRsn2
        (ESSR_ac_DW.NeESSR_g_StrtStpFailRsn2);

    /* Outport: '<Root>/NeESSR_Cnt_AdptInitValue_PM_Out' incorporates:
     *  DataStoreRead: '<S5>/NeESSR_Cnt_AdptInitValue'
     */
    (void)Rte_Write_NeESSR_Cnt_AdptInitValue_NeESSR_Cnt_AdptInitValue
        (ESSR_ac_DW.NeESSR_Cnt_AdptInitValue);

    /* Outport: '<Root>/NeESSR_k_EngStpProfAngAdpt_PM_Out' incorporates:
     *  DataStoreRead: '<S5>/NeESSR_k_EngStpProfAngAdpt'
     */
    (void)Rte_Write_NeESSR_k_EngStpProfAngAdpt_NeESSR_k_EngStpProfAngAdpt
        (ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt);

    /* Outport: '<Root>/NeESSR_k_EngStpProfNiDotGainAdapt_PM_Out' incorporates:
     *  DataStoreRead: '<S5>/NeESSR_k_EngStpProfNiDotGainAdapt'
     */
    (void)
        Rte_Write_NeESSR_k_EngStpProfNiDotGainAdapt_NeESSR_k_EngStpProfNiDotGainAdapt
        (ESSR_ac_DW.NeESSR_k_EngStpProfNiDotGainAda);

    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/PwrOff' */
}

/* Output function */
FUNC(void, ESSR_CODE) ESSR_PwrOn(void)
{
    /* RootInportFunctionCallGenerator generated from: '<Root>/PwrOn' incorporates:
     *  SubSystem: '<Root>/ESSR_PwrOn'
     */
    /* S-Function (fcgen): '<S6>/FcnCallGen' incorporates:
     *  SubSystem: '<S6>/DSM_Init'
     */
    /* DataStoreWrite: '<S3277>/NeESSR_k_EngStpProfNiDotGainAdapt' incorporates:
     *  Inport: '<Root>/NeESSR_k_EngStpProfNiDotGainAdapt_PM_In'
     */
    (void)
        Rte_Read_NeESSR_k_EngStpProfNiDotGainAdapt_Rx_NeESSR_k_EngStpProfNiDotGainAdapt
        (&ESSR_ac_DW.NeESSR_k_EngStpProfNiDotGainAda);

    /* DataStoreWrite: '<S3277>/NeESSR_k_EngStpProfAngAdpt' incorporates:
     *  Inport: '<Root>/NeESSR_k_EngStpProfAngAdpt_PM_In'
     */
    (void)Rte_Read_NeESSR_k_EngStpProfAngAdpt_Rx_NeESSR_k_EngStpProfAngAdpt
        (&ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt);

    /* DataStoreWrite: '<S3277>/NeESSR_Cnt_AdptInitValue' incorporates:
     *  Inport: '<Root>/NeESSR_Cnt_AdptInitValue_PM_In'
     */
    (void)Rte_Read_NeESSR_Cnt_AdptInitValue_Rx_NeESSR_Cnt_AdptInitValue
        (&ESSR_ac_DW.NeESSR_Cnt_AdptInitValue);

    /* DataStoreWrite: '<S3277>/NeESSR_g_StrtStpFailRsn2' incorporates:
     *  Inport: '<Root>/NeESSR_g_StrtStpFailRsn2_PM_In'
     */
    (void)Rte_Read_NeESSR_g_StrtStpFailRsn2_Rx_NeESSR_g_StrtStpFailRsn2
        (&ESSR_ac_DW.NeESSR_g_StrtStpFailRsn2);

    /* DataStoreWrite: '<S3277>/NeESSR_g_StrtStpFailRsn' incorporates:
     *  Inport: '<Root>/NeESSR_g_StrtStpFailRsn_PM_In'
     */
    (void)Rte_Read_NeESSR_g_StrtStpFailRsn_Rx_NeESSR_g_StrtStpFailRsn
        (&ESSR_ac_DW.NeESSR_g_StrtStpFailRsn);

    /* DataStoreWrite: '<S3277>/NeESSR_M_SpinUpAddtlOffset' incorporates:
     *  Inport: '<Root>/NeESSR_M_SpinUpAddtlOffset_PM_In'
     */
    (void)Rte_Read_NeESSR_M_SpinUpAddtlOffset_Rx_NeESSR_M_SpinUpAddtlOffset
        (&ESSR_ac_DW.NeESSR_M_SpinUpAddtlOffset);

    /* DataStoreWrite: '<S3277>/NeESSR_M_SpinDwnAddtlOffset' incorporates:
     *  Inport: '<Root>/NeESSR_M_SpinDwnAddtlOffset_PM_In'
     */
    (void)Rte_Read_NeESSR_M_SpinDwnAddtlOffset_Rx_NeESSR_M_SpinDwnAddtlOffset
        (&ESSR_ac_DW.NeESSR_M_SpinDwnAddtlOffset);

#if Rte_SysCon_Variant_ESSR_Func

    /* Outputs for Function Call SubSystem: '<S6>/ESSC_InitializeAdapts' */
    /* DataStoreWrite: '<S3278>/Dsw_AStrtFailed7' incorporates:
     *  Constant: '<S3278>/TRUE Constant2'
     */
    VeESSR_b_AStrtReattmptAllowed_DS = true;

    /* If: '<S3278>/If' incorporates:
     *  Constant: '<S3293>/Calib'
     *  DataStoreRead: '<S3278>/Dsr_NeESSR_e_AdptInitValue'
     *  RelationalOperator: '<S3278>/Equal'
     */
    if (ESSR_ac_DW.NeESSR_Cnt_AdptInitValue != KeESSR_Cnt_AdptInitWord)
    {
        /* Outputs for IfAction SubSystem: '<S3278>/InitialAdaptValues' incorporates:
         *  ActionPort: '<S3292>/Action Port'
         */
        /* DataStoreWrite: '<S3292>/Dsw_EngStpProfNiDotGainAdapt' incorporates:
         *  Constant: '<S3292>/Constant Value'
         */
        ESSR_ac_DW.NeESSR_k_EngStpProfNiDotGainAda = 1.0F;

        /* DataStoreWrite: '<S3292>/Dsw_EngStpProfNiDotGainAdapt1' incorporates:
         *  Constant: '<S3292>/Constant Value'
         */
        ESSR_ac_DW.NeESSR_k_EngStpProfAngAdpt = 1.0F;

        /* DataStoreWrite: '<S3292>/Dsw_AdptInitValue' incorporates:
         *  Constant: '<S3295>/Calib'
         */
        ESSR_ac_DW.NeESSR_Cnt_AdptInitValue = KeESSR_Cnt_AdptInitWord;

        /* DataStoreWrite: '<S3292>/Dsw_SpinDwnAddtlOffset' incorporates:
         *  Constant: '<S3296>/Calib'
         */
        ESSR_ac_DW.NeESSR_M_SpinDwnAddtlOffset = KeESSR_M_SpinDwnInitOffst;

        /* DataStoreWrite: '<S3292>/Dsw_SpinUpAddtlOffset' incorporates:
         *  Constant: '<S3297>/Calib'
         */
        ESSR_ac_DW.NeESSR_M_SpinUpAddtlOffset = KeESSR_M_SpinUpInitOffst;

        /* End of Outputs for SubSystem: '<S3278>/InitialAdaptValues' */
    }

    /* End of If: '<S3278>/If' */
    /* End of Outputs for SubSystem: '<S6>/ESSC_InitializeAdapts' */
#endif

    /* SignalConversion generated from: '<S6>/VeESSR_Cnt_CSSpinupAttmptCntr' incorporates:
     *  SignalConversion generated from: '<S6>/VeESSR_Cnt_EMSpinupAttmptCntr'
     *  SignalConversion generated from: '<S6>/VeESSR_M_BCTiMargin_Out_Init'
     *  SignalConversion generated from: '<S6>/VeESSR_M_Clch5_TorqCmd'
     *  SignalConversion generated from: '<S6>/VeESSR_M_EngStrtTorq'
     *  SignalConversion generated from: '<S6>/VeESSR_M_EngTorqEst'
     *  SignalConversion generated from: '<S6>/VeESSR_M_EngTrqReqImmed'
     *  SignalConversion generated from: '<S6>/VeESSR_M_EngTrqReqPrdtd'
     *  SignalConversion generated from: '<S6>/VeESSR_M_EngineLosses'
     *  SignalConversion generated from: '<S6>/VeESSR_M_MtrAPulseCancelTrq'
     *  SignalConversion generated from: '<S6>/VeESSR_M_MtrA_MaxTorq'
     *  SignalConversion generated from: '<S6>/VeESSR_M_MtrA_MinTorq'
     *  SignalConversion generated from: '<S6>/VeESSR_M_MtrBPulseCancelTrq'
     *  SignalConversion generated from: '<S6>/VeESSR_M_MtrB_MaxTorq'
     *  SignalConversion generated from: '<S6>/VeESSR_M_MtrB_MinTorq'
     *  SignalConversion generated from: '<S6>/VeESSR_M_MtrC_MaxTorq'
     *  SignalConversion generated from: '<S6>/VeESSR_M_MtrC_MinTorq'
     *  SignalConversion generated from: '<S6>/VeESSR_b_AStrtFailed'
     *  SignalConversion generated from: '<S6>/VeESSR_b_AStrtPBatBoostReq'
     *  SignalConversion generated from: '<S6>/VeESSR_b_AStrtReattmptAllowed'
     *  SignalConversion generated from: '<S6>/VeESSR_b_BSGStrtFailed'
     *  SignalConversion generated from: '<S6>/VeESSR_b_BackUpStartEng'
     *  SignalConversion generated from: '<S6>/VeESSR_b_BkupStrtsAllwd'
     *  SignalConversion generated from: '<S6>/VeESSR_b_BumpStrtsAllwd'
     *  SignalConversion generated from: '<S6>/VeESSR_b_CltchStckOn'
     *  SignalConversion generated from: '<S6>/VeESSR_b_DisableMtrA_Out_Init'
     *  SignalConversion generated from: '<S6>/VeESSR_b_DisableNc1DotLim'
     *  SignalConversion generated from: '<S6>/VeESSR_b_DsblNc1ClsdLoopCntrl'
     *  SignalConversion generated from: '<S6>/VeESSR_b_DsblNiClsdLoopCntrl'
     *  SignalConversion generated from: '<S6>/VeESSR_b_EngDFCOOffHoldReq'
     *  SignalConversion generated from: '<S6>/VeESSR_b_EngOffAllwdECM'
     *  SignalConversion generated from: '<S6>/VeESSR_b_EngProdTrq_TCM'
     *  SignalConversion generated from: '<S6>/VeESSR_b_EngStallReattmpAllwd'
     *  SignalConversion generated from: '<S6>/VeESSR_b_EngStartAbort'
     *  SignalConversion generated from: '<S6>/VeESSR_b_EngStrtStpActive'
     *  SignalConversion generated from: '<S6>/VeESSR_b_HCPFuelDisable'
     *  SignalConversion generated from: '<S6>/VeESSR_b_HCP_StopStart_Fault'
     *  SignalConversion generated from: '<S6>/VeESSR_b_Hyb_ProducingTorque'
     *  SignalConversion generated from: '<S6>/VeESSR_b_IUMPR_P1C64Fail'
     *  SignalConversion generated from: '<S6>/VeESSR_b_IUMPR_P1C65Fail'
     *  SignalConversion generated from: '<S6>/VeESSR_b_IUMPR_P1C68Fail'
     *  SignalConversion generated from: '<S6>/VeESSR_b_InhibitShiftToMode'
     *  SignalConversion generated from: '<S6>/VeESSR_b_InputTorqOverride'
     *  SignalConversion generated from: '<S6>/VeESSR_b_NbTgtReq'
     *  SignalConversion generated from: '<S6>/VeESSR_b_OptimdEngOnOffCmd'
     *  SignalConversion generated from: '<S6>/VeESSR_b_P1C64_Failed'
     *  SignalConversion generated from: '<S6>/VeESSR_b_P1C64_Passed'
     *  SignalConversion generated from: '<S6>/VeESSR_b_P1C65_Failed'
     *  SignalConversion generated from: '<S6>/VeESSR_b_P1C65_Passed'
     *  SignalConversion generated from: '<S6>/VeESSR_b_P1C68_Failed'
     *  SignalConversion generated from: '<S6>/VeESSR_b_P1C68_Passed'
     *  SignalConversion generated from: '<S6>/VeESSR_b_StrtStopFail'
     *  SignalConversion generated from: '<S6>/VeESSR_b_TCMOpenDisconnctCltch'
     *  SignalConversion generated from: '<S6>/VeESSR_dn_InputAcceltnProf'
     *  SignalConversion generated from: '<S6>/VeESSR_e_EngCntrlMode'
     *  SignalConversion generated from: '<S6>/VeESSR_e_EngStartStopSt'
     *  SignalConversion generated from: '<S6>/VeESSR_e_EngState_eTPUTgtSyncSt'
     *  SignalConversion generated from: '<S6>/VeESSR_e_EngStrtProfType'
     *  SignalConversion generated from: '<S6>/VeESSR_e_EngStrtStpMd'
     *  SignalConversion generated from: '<S6>/VeESSR_e_EngStrtType'
     *  SignalConversion generated from: '<S6>/VeESSR_e_EngTrqRespType'
     *  SignalConversion generated from: '<S6>/VeESSR_e_HybEngSysActv_Out_Init'
     *  SignalConversion generated from: '<S6>/VeESSR_e_OptimdEngStrtStpType'
     *  SignalConversion generated from: '<S6>/VeESSR_e_OptimdStrtReqdActr'
     *  SignalConversion generated from: '<S6>/VeESSR_e_TCM_StartStopType'
     *  SignalConversion generated from: '<S6>/VeESSR_e_TCM_TransitionStatus'
     *  SignalConversion generated from: '<S6>/VeESSR_e_TransFldPmpCmd'
     *  SignalConversion generated from: '<S6>/VeESSR_g_StrtStpFailPhase'
     *  SignalConversion generated from: '<S6>/VeESSR_g_StrtStpFailRsn_Out_Init'
     *  SignalConversion generated from: '<S6>/VeESSR_i_CalLoader'
     *  SignalConversion generated from: '<S6>/VeESSR_n_InputSpeedProfile'
     *  SignalConversion generated from: '<S6>/VeESSR_n_NbTgt'
     *  SignalConversion generated from: '<S6>/VeESSR_n_NiPred'
     *  SignalConversion generated from: '<S6>/VeESSR_n_OptInputSpd'
     *  SignalConversion generated from: '<S6>/VeESSR_n_StrtTypAStrtSpinUpExtSpd'
     *  SignalConversion generated from: '<S6>/VeESSR_n_TgtIdleSpd'
     *  SignalConversion generated from: '<S6>/VeESSR_r_MaxSparkAuthority'
     *  SignalConversion generated from: '<S6>/VeESSR_scl_AEMDMtrAGain'
     *  SignalConversion generated from: '<S6>/VeESSR_scl_AEMDMtrBGain'
     *  SignalConversion generated from: '<S6>/VeESSR_scl_SpdCtlGainMod'
     */
#if Rte_SysCon_Variant_ESSR_NF

    /* Outputs for Function Call SubSystem: '<S6>/Controller_Output' */
    /* SignalConversion generated from: '<S3276>/VeESSR_e_EngStartStopSt' incorporates:
     *  Constant: '<S3279>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_EngS_d = ESSR_ac_ConstB.Constant_oe;

    /* SignalConversion generated from: '<S3276>/VeESSR_e_EngStrtType' incorporates:
     *  Constant: '<S3280>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_EngS_i = ESSR_ac_ConstB.Constant_e1;

    /* SignalConversion generated from: '<S3276>/VeESSR_e_EngStrtStpMd' incorporates:
     *  Constant: '<S3283>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_EngS_n = ESSR_ac_ConstB.Constant_o;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_StrtStopFail' */
    ESSR_ac_B.OutportBufferForVeESSR_b_StrtSt = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_InhibitShiftToMode' */
    ESSR_ac_B.OutportBufferForVeESSR_b_Inhibi = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_n_InputSpeedProfile' */
    ESSR_ac_B.OutportBufferForVeESSR_n_InputS = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_dn_InputAcceltnProf' */
    ESSR_ac_B.OutportBufferForVeESSR_dn_Input = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_InputTorqOverride' */
    ESSR_ac_B.OutportBufferForVeESSR_b_InputT = true;

    /* SignalConversion generated from: '<S3276>/VeESSR_M_EngTorqEst' */
    ESSR_ac_B.OutportBufferForVeESSR_M_EngTor = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_e_TransFldPmpCmd' incorporates:
     *  Constant: '<S3288>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_TransF = ESSR_ac_ConstB.Constant_m;

    /* SignalConversion generated from: '<S3276>/VeESSR_scl_SpdCtlGainMod' */
    ESSR_ac_B.OutportBufferForVeESSR_scl_SpdC = 1.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_e_EngTrqRespType' incorporates:
     *  Constant: '<S3287>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_EngTrq = ESSR_ac_ConstB.Constant_h;

    /* SignalConversion generated from: '<S3276>/VeESSR_M_EngTrqReqImmed' */
    ESSR_ac_B.OutportBufferForVeESSR_M_EngTrq = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_M_EngTrqReqPrdtd' */
    ESSR_ac_B.OutportBufferForVeESSR_M_EngT_c = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_EngDFCOOffHoldReq' */
    ESSR_ac_B.OutportBufferForVeESSR_b_EngDFC = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_EngStartAbort' */
    ESSR_ac_B.OutportBufferForVeESSR_b_EngSta = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_AStrtPBatBoostReq' */
    ESSR_ac_B.OutportBufferForVeESSR_b_AStrtP = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_EngStrtStpActive' */
    ESSR_ac_B.OutportBufferForVeESSR_b_EngStr = true;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_DisableNc1DotLim' */
    ESSR_ac_B.OutportBufferForVeESSR_b_Disabl = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_CltchStckOn' */
    ESSR_ac_B.OutportBufferForVeESSR_b_CltchS = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_DsblNiClsdLoopCntrl' */
    ESSR_ac_B.OutportBufferForVeESSR_b_DsblNi = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_e_EngCntrlMode' incorporates:
     *  Constant: '<S3286>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_EngCnt = ESSR_ac_ConstB.Constant;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_AStrtFailed' */
    ESSR_ac_B.OutportBufferForVeESSR_b_AStrtF = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_HCP_StopStart_Fault' */
    ESSR_ac_B.OutportBufferForVeESSR_b_HCP_St = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_scl_AEMDMtrAGain' */
    ESSR_ac_B.OutportBufferForVeESSR_scl_AEMD = 1.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_scl_AEMDMtrBGain' */
    ESSR_ac_B.OutportBufferForVeESSR_scl_AE_d = 1.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_EngProdTrq_TCM' */
    ESSR_ac_B.OutportBufferForVeESSR_b_EngPro = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_e_EngState_eTPUTgtSyncSt' incorporates:
     *  Constant: '<S3289>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_EngSta = ESSR_ac_ConstB.Constant_e;

    /* SignalConversion generated from: '<S3276>/VeESSR_e_TCM_StartStopType' incorporates:
     *  Constant: '<S3290>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_TCM_St = ESSR_ac_ConstB.Constant_c;

    /* SignalConversion generated from: '<S3276>/VeESSR_M_MtrA_MaxTorq' */
    ESSR_ac_B.OutportBufferForVeESSR_M_MtrA_M = 9999.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_M_MtrA_MinTorq' */
    ESSR_ac_B.OutportBufferForVeESSR_M_MtrA_c = -9999.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_M_EngStrtTorq' */
    ESSR_ac_B.OutportBufferForVeESSR_M_EngStr = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_n_NbTgt' */
    ESSR_ac_B.OutportBufferForVeESSR_n_NbTgt = 9999.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_BumpStrtsAllwd' */
    ESSR_ac_B.OutportBufferForVeESSR_b_BumpSt = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_g_StrtStpFailPhase' */
    ESSR_ac_B.OutportBufferForVeESSR_g_StrtSt = 0U;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_AStrtReattmptAllowed' */
    ESSR_ac_B.OutportBufferForVeESSR_b_AStrtR = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_n_StrtTypAStrtSpinUpExtSpd' */
    ESSR_ac_B.OutportBufferForVeESSR_n_StrtTy = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_i_CalLoader' */
    ESSR_ac_B.OutportBufferForVeESSR_i_CalLoa = 1U;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_TCMOpenDisconnctCltch' */
    ESSR_ac_B.OutportBufferForVeESSR_b_TCMOpe = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_e_TCM_TransitionStatus' incorporates:
     *  Constant: '<S3285>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_TCM_Tr = ESSR_ac_ConstB.Constant_mv;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_BackUpStartEng' */
    ESSR_ac_B.OutportBufferForVeESSR_b_BackUp = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_M_MtrB_MaxTorq' */
    ESSR_ac_B.OutportBufferForVeESSR_M_MtrB_M = 9999.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_M_MtrB_MinTorq' */
    ESSR_ac_B.OutportBufferForVeESSR_M_MtrB_d = -9999.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_DsblNc1ClsdLoopCntrl' */
    ESSR_ac_B.OutportBufferForVeESSR_b_DsblNc = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_M_Clch5_TorqCmd' */
    ESSR_ac_B.OutportBufferForVeESSR_M_Clch5_ = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_M_MtrC_MaxTorq' */
    ESSR_ac_B.OutportBufferForVeESSR_M_MtrC_M = 9999.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_M_MtrC_MinTorq' */
    ESSR_ac_B.OutportBufferForVeESSR_M_MtrC_g = -9999.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_NbTgtReq' */
    ESSR_ac_B.OutportBufferForVeESSR_b_NbTgtR = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_EngStallReattmpAllwd' */
    ESSR_ac_B.OutportBufferForVeESSR_b_EngS_j = true;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_BSGStrtFailed' */
    ESSR_ac_B.OutportBufferForVeESSR_b_BSGStr = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_BkupStrtsAllwd' */
    ESSR_ac_B.OutportBufferForVeESSR_b_BkupSt = true;

    /* SignalConversion generated from: '<S3276>/VeESSR_Cnt_CSSpinupAttmptCntr' */
    ESSR_ac_B.OutportBufferForVeESSR_Cnt_CSSp = 0U;

    /* SignalConversion generated from: '<S3276>/VeESSR_Cnt_EMSpinupAttmptCntr' */
    ESSR_ac_B.OutportBufferForVeESSR_Cnt_EMSp = 0U;

    /* SignalConversion generated from: '<S3276>/VeESSR_e_EngStrtProfType' incorporates:
     *  Constant: '<S3284>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_EngStr = ESSR_ac_ConstB.Constant_j;

    /* SignalConversion generated from: '<S3276>/VeESSR_n_OptInputSpd' */
    ESSR_ac_B.OutportBufferForVeESSR_n_OptInp = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_n_TgtIdleSpd' */
    ESSR_ac_B.OutportBufferForVeESSR_n_TgtIdl = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_OptimdEngOnOffCmd' */
    ESSR_ac_B.OutportBufferForVeESSR_b_Optimd = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_HCPFuelDisable' */
    ESSR_ac_B.OutportBufferForVeESSR_b_HCPFue = true;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_Hyb_ProducingTorque' */
    ESSR_ac_B.OutportBufferForVeESSR_b_Hyb_Pr = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_e_OptimdEngStrtStpType' incorporates:
     *  Constant: '<S3281>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_Optimd = ESSR_ac_ConstB.Constant_g;

    /* SignalConversion generated from: '<S3276>/VeESSR_e_OptimdStrtReqdActr' incorporates:
     *  Constant: '<S3282>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_Opti_a = ESSR_ac_ConstB.Constant_n;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_EngOffAllwdECM' */
    ESSR_ac_B.OutportBufferForVeESSR_b_EngOff = true;

    /* SignalConversion generated from: '<S3276>/VeESSR_M_MtrAPulseCancelTrq' */
    ESSR_ac_B.OutportBufferForVeESSR_M_MtrAPu = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_M_MtrBPulseCancelTrq' */
    ESSR_ac_B.OutportBufferForVeESSR_M_MtrBPu = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_IUMPR_P1C64Fail' */
    ESSR_ac_B.OutportBufferForVeESSR_b_IUMPR_ = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_IUMPR_P1C65Fail' */
    ESSR_ac_B.OutportBufferForVeESSR_b_IUMP_k = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_IUMPR_P1C68Fail' */
    ESSR_ac_B.OutportBufferForVeESSR_b_IUMP_l = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_r_MaxSparkAuthority' */
    ESSR_ac_B.OutportBufferForVeESSR_r_MaxSpa = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_M_EngineLosses' */
    ESSR_ac_B.OutportBufferForVeESSR_M_Engine = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_P1C64_Failed' */
    ESSR_ac_B.OutportBufferForVeESSR_b_P1C64_ = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_P1C65_Failed' */
    ESSR_ac_B.OutportBufferForVeESSR_b_P1C65_ = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_P1C68_Failed' */
    ESSR_ac_B.OutportBufferForVeESSR_b_P1C68_ = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_P1C64_Passed' */
    ESSR_ac_B.OutportBufferForVeESSR_b_P1C6_l = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_P1C65_Passed' */
    ESSR_ac_B.OutportBufferForVeESSR_b_P1C6_e = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_P1C68_Passed' */
    ESSR_ac_B.OutportBufferForVeESSR_b_P1C6_k = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_n_NiPred' */
    ESSR_ac_B.OutportBufferForVeESSR_n_NiPred = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_e_HybEngSysActv_Out_Init' incorporates:
     *  Constant: '<S3276>/Const1'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_HybEng = ESSR_ac_ConstB.Const1;

    /* SignalConversion generated from: '<S3276>/VeESSR_b_DisableMtrA_Out_Init' */
    ESSR_ac_B.OutportBufferForVeESSR_b_Disa_c = false;

    /* SignalConversion generated from: '<S3276>/VeESSR_M_BCTiMargin_Out_Init' */
    ESSR_ac_B.OutportBufferForVeESSR_M_BCTiMa = 0.0F;

    /* SignalConversion generated from: '<S3276>/VeESSR_g_StrtStpFailRsn_Out_Init' */
    ESSR_ac_B.OutportBufferForVeESSR_g_Strt_h = 0U;

    /* End of Outputs for SubSystem: '<S6>/Controller_Output' */

    /* Outport: '<Root>/VeESSR_Cnt_CSSpinupAttmptCntr' */
    (void)Rte_Write_VeESSR_Cnt_CSSpinupAttmptCntr_Value
        (ESSR_ac_B.OutportBufferForVeESSR_Cnt_CSSp);

    /* Outport: '<Root>/VeESSR_Cnt_EMSpinupAttmptCntr' */
    (void)Rte_Write_VeESSR_Cnt_EMSpinupAttmptCntr_Value
        (ESSR_ac_B.OutportBufferForVeESSR_Cnt_EMSp);

    /* Outport: '<Root>/VeESSR_M_BCTiMargin' */
    (void)Rte_Write_VeESSR_M_BCTiMargin_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_BCTiMa);

    /* Outport: '<Root>/VeESSR_M_Clch5_TorqCmd' */
    (void)Rte_Write_VeESSR_M_Clch5_TorqCmd_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_Clch5_);

    /* Outport: '<Root>/VeESSR_M_EngStrtTorq' */
    (void)Rte_Write_VeESSR_M_EngStrtTorq_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_EngStr);

    /* Outport: '<Root>/VeESSR_M_EngTorqEst' */
    (void)Rte_Write_VeESSR_M_EngTorqEst_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_EngTor);

    /* Outport: '<Root>/VeESSR_M_EngTrqReqImmed' */
    (void)Rte_Write_VeESSR_M_EngTrqReqImmed_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_EngTrq);

    /* Outport: '<Root>/VeESSR_M_EngTrqReqPrdtd' */
    (void)Rte_Write_VeESSR_M_EngTrqReqPrdtd_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_EngT_c);

    /* Outport: '<Root>/VeESSR_M_EngineLosses' */
    (void)Rte_Write_VeESSR_M_EngineLosses_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_Engine);

    /* Outport: '<Root>/VeESSR_M_MtrAPulseCancelTrq' */
    (void)Rte_Write_VeESSR_M_MtrAPulseCancelTrq_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_MtrAPu);

    /* Outport: '<Root>/VeESSR_M_MtrA_MaxTorq' */
    (void)Rte_Write_VeESSR_M_MtrA_MaxTorq_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_MtrA_M);

    /* Outport: '<Root>/VeESSR_M_MtrA_MinTorq' */
    (void)Rte_Write_VeESSR_M_MtrA_MinTorq_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_MtrA_c);

    /* Outport: '<Root>/VeESSR_M_MtrBPulseCancelTrq' */
    (void)Rte_Write_VeESSR_M_MtrBPulseCancelTrq_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_MtrBPu);

    /* Outport: '<Root>/VeESSR_M_MtrB_MaxTorq' */
    (void)Rte_Write_VeESSR_M_MtrB_MaxTorq_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_MtrB_M);

    /* Outport: '<Root>/VeESSR_M_MtrB_MinTorq' */
    (void)Rte_Write_VeESSR_M_MtrB_MinTorq_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_MtrB_d);

    /* Outport: '<Root>/VeESSR_M_MtrC_MaxTorq' */
    (void)Rte_Write_VeESSR_M_MtrC_MaxTorq_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_MtrC_M);

    /* Outport: '<Root>/VeESSR_M_MtrC_MinTorq' */
    (void)Rte_Write_VeESSR_M_MtrC_MinTorq_Value
        (ESSR_ac_B.OutportBufferForVeESSR_M_MtrC_g);

    /* Outport: '<Root>/VeESSR_b_AStrtFailed' */
    (void)Rte_Write_VeESSR_b_AStrtFailed_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_AStrtF);

    /* Outport: '<Root>/VeESSR_b_AStrtPBatBoostReq' */
    (void)Rte_Write_VeESSR_b_AStrtPBatBoostReq_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_AStrtP);

    /* Outport: '<Root>/VeESSR_b_AStrtReattmptAllowed' */
    (void)Rte_Write_VeESSR_b_AStrtReattmptAllowed_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_AStrtR);

    /* Outport: '<Root>/VeESSR_b_BSGStrtFailed' */
    (void)Rte_Write_VeESSR_b_BSGStrtFailed_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_BSGStr);

    /* Outport: '<Root>/VeESSR_b_BackUpStartEng' */
    (void)Rte_Write_VeESSR_b_BackUpStartEng_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_BackUp);

    /* Outport: '<Root>/VeESSR_b_BkupStrtsAllwd' */
    (void)Rte_Write_VeESSR_b_BkupStrtsAllwd_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_BkupSt);

    /* Outport: '<Root>/VeESSR_b_BumpStrtsAllwd' */
    (void)Rte_Write_VeESSR_b_BumpStrtsAllwd_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_BumpSt);

    /* Outport: '<Root>/VeESSR_b_CltchStckOn' */
    (void)Rte_Write_VeESSR_b_CltchStckOn_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_CltchS);

    /* Outport: '<Root>/VeESSR_b_DisableMtrA' */
    (void)Rte_Write_VeESSR_b_DisableMtrA_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_Disa_c);

    /* Outport: '<Root>/VeESSR_b_DisableNc1DotLim' */
    (void)Rte_Write_VeESSR_b_DisableNc1DotLim_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_Disabl);

    /* Outport: '<Root>/VeESSR_b_DsblNc1ClsdLoopCntrl' */
    (void)Rte_Write_VeESSR_b_DsblNc1ClsdLoopCntrl_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_DsblNc);

    /* Outport: '<Root>/VeESSR_b_DsblNiClsdLoopCntrl' */
    (void)Rte_Write_VeESSR_b_DsblNiClsdLoopCntrl_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_DsblNi);

    /* Outport: '<Root>/VeESSR_b_EngDFCOOffHoldReq' */
    (void)Rte_Write_VeESSR_b_EngDFCOOffHoldReq_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_EngDFC);

    /* Outport: '<Root>/VeESSR_b_EngOffAllwdECM' */
    (void)Rte_Write_VeESSR_b_EngOffAllwdECM_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_EngOff);

    /* Outport: '<Root>/VeESSR_b_EngProdTrq_TCM' */
    (void)Rte_Write_VeESSR_b_EngProdTrq_TCM_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_EngPro);

    /* Outport: '<Root>/VeESSR_b_EngStallReattmpAllwd' */
    (void)Rte_Write_VeESSR_b_EngStallReattmpAllwd_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_EngS_j);

    /* Outport: '<Root>/VeESSR_b_EngStartAbort' */
    (void)Rte_Write_VeESSR_b_EngStartAbort_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_EngSta);

    /* Outport: '<Root>/VeESSR_b_EngStrtStpActive' */
    (void)Rte_Write_VeESSR_b_EngStrtStpActive_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_EngStr);

    /* Outport: '<Root>/VeESSR_b_HCPFuelDisable' */
    (void)Rte_Write_VeESSR_b_HCPFuelDisable_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_HCPFue);

    /* Outport: '<Root>/VeESSR_b_HCP_StopStart_Fault' */
    (void)Rte_Write_VeESSR_b_HCP_StopStart_Fault_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_HCP_St);

    /* Outport: '<Root>/VeESSR_b_Hyb_ProducingTorque' */
    (void)Rte_Write_VeESSR_b_Hyb_ProducingTorque_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_Hyb_Pr);

    /* Outport: '<Root>/VeESSR_b_IUMPR_P1C64Fail' */
    (void)Rte_Write_VeESSR_b_IUMPR_P1C64Fail_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_IUMPR_);

    /* Outport: '<Root>/VeESSR_b_IUMPR_P1C65Fail' */
    (void)Rte_Write_VeESSR_b_IUMPR_P1C65Fail_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_IUMP_k);

    /* Outport: '<Root>/VeESSR_b_IUMPR_P1C68Fail' */
    (void)Rte_Write_VeESSR_b_IUMPR_P1C68Fail_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_IUMP_l);

    /* Outport: '<Root>/VeESSR_b_InhibitShiftToMode' */
    (void)Rte_Write_VeESSR_b_InhibitShiftToMode_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_Inhibi);

    /* Outport: '<Root>/VeESSR_b_InputTorqOverride' */
    (void)Rte_Write_VeESSR_b_InputTorqOverride_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_InputT);

    /* Outport: '<Root>/VeESSR_b_NbTgtReq' */
    (void)Rte_Write_VeESSR_b_NbTgtReq_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_NbTgtR);

    /* Outport: '<Root>/VeESSR_b_OptimdEngOnOffCmd' */
    (void)Rte_Write_VeESSR_b_OptimdEngOnOffCmd_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_Optimd);

    /* Outport: '<Root>/VeESSR_b_P1C64_Failed' */
    (void)Rte_Write_VeESSR_b_P1C64_Failed_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_P1C64_);

    /* Outport: '<Root>/VeESSR_b_P1C64_Passed' */
    (void)Rte_Write_VeESSR_b_P1C64_Passed_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_P1C6_l);

    /* Outport: '<Root>/VeESSR_b_P1C65_Failed' */
    (void)Rte_Write_VeESSR_b_P1C65_Failed_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_P1C65_);

    /* Outport: '<Root>/VeESSR_b_P1C65_Passed' */
    (void)Rte_Write_VeESSR_b_P1C65_Passed_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_P1C6_e);

    /* Outport: '<Root>/VeESSR_b_P1C68_Failed' */
    (void)Rte_Write_VeESSR_b_P1C68_Failed_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_P1C68_);

    /* Outport: '<Root>/VeESSR_b_P1C68_Passed' */
    (void)Rte_Write_VeESSR_b_P1C68_Passed_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_P1C6_k);

    /* Outport: '<Root>/VeESSR_b_StrtStopFail' */
    (void)Rte_Write_VeESSR_b_StrtStopFail_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_StrtSt);

    /* Outport: '<Root>/VeESSR_b_TCMOpenDisconnctCltch' */
    (void)Rte_Write_VeESSR_b_TCMOpenDisconnctCltch_Value
        (ESSR_ac_B.OutportBufferForVeESSR_b_TCMOpe);

    /* Outport: '<Root>/VeESSR_dn_InputAcceltnProf' */
    (void)Rte_Write_VeESSR_dn_InputAcceltnProf_Value
        (ESSR_ac_B.OutportBufferForVeESSR_dn_Input);

    /* Outport: '<Root>/VeESSR_e_EngCntrlMode' incorporates:
     *  SignalConversion generated from: '<S3276>/VeESSR_e_EngCntrlMode'
     */
    (void)Rte_Write_VeESSR_e_EngCntrlMode_Value
        (ESSR_ac_B.OutportBufferForVeESSR_e_EngCnt);

    /* Outport: '<Root>/VeESSR_e_EngStartStopSt' incorporates:
     *  SignalConversion generated from: '<S3276>/VeESSR_e_EngStartStopSt'
     */
    (void)Rte_Write_VeESSR_e_EngStartStopSt_Value
        (ESSR_ac_B.OutportBufferForVeESSR_e_EngS_d);

    /* Outport: '<Root>/VeESSR_e_EngState_eTPUTgtSyncSt' incorporates:
     *  SignalConversion generated from: '<S3276>/VeESSR_e_EngState_eTPUTgtSyncSt'
     */
    (void)Rte_Write_VeESSR_e_EngState_eTPUTgtSyncSt_Value
        (ESSR_ac_B.OutportBufferForVeESSR_e_EngSta);

    /* Outport: '<Root>/VeESSR_e_EngStrtProfType' incorporates:
     *  SignalConversion generated from: '<S3276>/VeESSR_e_EngStrtProfType'
     */
    (void)Rte_Write_VeESSR_e_EngStrtProfType_Value
        (ESSR_ac_B.OutportBufferForVeESSR_e_EngStr);

    /* Outport: '<Root>/VeESSR_e_EngStrtStpMd' incorporates:
     *  SignalConversion generated from: '<S3276>/VeESSR_e_EngStrtStpMd'
     */
    (void)Rte_Write_VeESSR_e_EngStrtStpMd_Value
        (ESSR_ac_B.OutportBufferForVeESSR_e_EngS_n);

    /* Outport: '<Root>/VeESSR_e_EngStrtType' incorporates:
     *  SignalConversion generated from: '<S3276>/VeESSR_e_EngStrtType'
     */
    (void)Rte_Write_VeESSR_e_EngStrtType_Value
        (ESSR_ac_B.OutportBufferForVeESSR_e_EngS_i);

    /* Outport: '<Root>/VeESSR_e_EngTrqRespType' incorporates:
     *  SignalConversion generated from: '<S3276>/VeESSR_e_EngTrqRespType'
     */
    (void)Rte_Write_VeESSR_e_EngTrqRespType_Value
        (ESSR_ac_B.OutportBufferForVeESSR_e_EngTrq);

    /* Outport: '<Root>/VeESSR_e_HybEngSysActv' incorporates:
     *  SignalConversion generated from: '<S3276>/VeESSR_e_HybEngSysActv_Out_Init'
     */
    (void)Rte_Write_VeESSR_e_HybEngSysActv_Value
        (ESSR_ac_B.OutportBufferForVeESSR_e_HybEng);

    /* Outport: '<Root>/VeESSR_e_OptimdEngStrtStpType' incorporates:
     *  SignalConversion generated from: '<S3276>/VeESSR_e_OptimdEngStrtStpType'
     */
    (void)Rte_Write_VeESSR_e_OptimdEngStrtStpType_Value
        (ESSR_ac_B.OutportBufferForVeESSR_e_Optimd);

    /* Outport: '<Root>/VeESSR_e_OptimdStrtReqdActr' incorporates:
     *  SignalConversion generated from: '<S3276>/VeESSR_e_OptimdStrtReqdActr'
     */
    (void)Rte_Write_VeESSR_e_OptimdStrtReqdActr_Value
        (ESSR_ac_B.OutportBufferForVeESSR_e_Opti_a);

    /* Outport: '<Root>/VeESSR_e_TCM_StartStopType' incorporates:
     *  SignalConversion generated from: '<S3276>/VeESSR_e_TCM_StartStopType'
     */
    (void)Rte_Write_VeESSR_e_TCM_StartStopType_Value
        (ESSR_ac_B.OutportBufferForVeESSR_e_TCM_St);

    /* Outport: '<Root>/VeESSR_e_TCM_TransitionStatus' incorporates:
     *  SignalConversion generated from: '<S3276>/VeESSR_e_TCM_TransitionStatus'
     */
    (void)Rte_Write_VeESSR_e_TCM_TransitionStatus_Value
        (ESSR_ac_B.OutportBufferForVeESSR_e_TCM_Tr);

    /* Outport: '<Root>/VeESSR_e_TransFldPmpCmd' incorporates:
     *  SignalConversion generated from: '<S3276>/VeESSR_e_TransFldPmpCmd'
     */
    (void)Rte_Write_VeESSR_e_TransFldPmpCmd_Value
        (ESSR_ac_B.OutportBufferForVeESSR_e_TransF);

    /* Outport: '<Root>/VeESSR_g_StrtStpFailPhase' */
    (void)Rte_Write_VeESSR_g_StrtStpFailPhase_Value
        (ESSR_ac_B.OutportBufferForVeESSR_g_StrtSt);

    /* Outport: '<Root>/VeESSR_g_StrtStpFailRsn' */
    (void)Rte_Write_VeESSR_g_StrtStpFailRsn_Value
        (ESSR_ac_B.OutportBufferForVeESSR_g_Strt_h);

    /* Outport: '<Root>/VeESSR_i_CalLoader' */
    (void)Rte_Write_VeESSR_i_CalLoader_Value
        (ESSR_ac_B.OutportBufferForVeESSR_i_CalLoa);

    /* Outport: '<Root>/VeESSR_n_InputSpeedProfile' */
    (void)Rte_Write_VeESSR_n_InputSpeedProfile_Value
        (ESSR_ac_B.OutportBufferForVeESSR_n_InputS);

    /* Outport: '<Root>/VeESSR_n_NbTgt' */
    (void)Rte_Write_VeESSR_n_NbTgt_Value
        (ESSR_ac_B.OutportBufferForVeESSR_n_NbTgt);

    /* Outport: '<Root>/VeESSR_n_NiPred' */
    (void)Rte_Write_VeESSR_n_NiPred_Value
        (ESSR_ac_B.OutportBufferForVeESSR_n_NiPred);

    /* Outport: '<Root>/VeESSR_n_OptInputSpd' */
    (void)Rte_Write_VeESSR_n_OptInputSpd_Value
        (ESSR_ac_B.OutportBufferForVeESSR_n_OptInp);

    /* Outport: '<Root>/VeESSR_n_StrtTypAStrtSpinUpExtSpd' */
    (void)Rte_Write_VeESSR_n_StrtTypAStrtSpinUpExtSpd_Value
        (ESSR_ac_B.OutportBufferForVeESSR_n_StrtTy);

    /* Outport: '<Root>/VeESSR_n_TgtIdleSpd' */
    (void)Rte_Write_VeESSR_n_TgtIdleSpd_Value
        (ESSR_ac_B.OutportBufferForVeESSR_n_TgtIdl);

    /* Outport: '<Root>/VeESSR_r_MaxSparkAuthority' */
    (void)Rte_Write_VeESSR_r_MaxSparkAuthority_Value
        (ESSR_ac_B.OutportBufferForVeESSR_r_MaxSpa);

    /* Outport: '<Root>/VeESSR_scl_AEMDMtrAGain' */
    (void)Rte_Write_VeESSR_scl_AEMDMtrAGain_Value
        (ESSR_ac_B.OutportBufferForVeESSR_scl_AEMD);

    /* Outport: '<Root>/VeESSR_scl_AEMDMtrBGain' */
    (void)Rte_Write_VeESSR_scl_AEMDMtrBGain_Value
        (ESSR_ac_B.OutportBufferForVeESSR_scl_AE_d);

    /* Outport: '<Root>/VeESSR_scl_SpdCtlGainMod' */
    (void)Rte_Write_VeESSR_scl_SpdCtlGainMod_Value
        (ESSR_ac_B.OutportBufferForVeESSR_scl_SpdC);

    /* End of Outputs for S-Function (fcgen): '<S6>/FcnCallGen' */
#endif

    /* End of SignalConversion generated from: '<S6>/VeESSR_Cnt_CSSpinupAttmptCntr' */
    /* End of Outputs for RootInportFunctionCallGenerator generated from: '<Root>/PwrOn' */
}

/* Model initialize function */
FUNC(void, ESSR_CODE) ESSR_ac_Init(void)
{

#if Rte_SysCon_Variant_ESSR_Func

    ESSR_ac_PrevZCX.ESSC_RampDownDur.IntegerDelay_Reset_ZCE = POS_ZCSIG;
    ESSR_ac_PrevZCX.PrepForStopDur.IntegerDelay_Reset_ZCE_k = POS_ZCSIG;
    ESSR_ac_PrevZCX.StartEngPFS_Dur.IntegerDelay_Reset_ZCE_jf = POS_ZCSIG;
    ESSR_ac_PrevZCX.AchIdle_12vStrt_Du.IntegerDelay_Reset_ZCE_c = POS_ZCSIG;
    ESSR_ac_PrevZCX.ESSC_AchEngIdleDur.IntegerDelay_Reset_ZCE_b = POS_ZCSIG;
    ESSR_ac_PrevZCX.ESSC_StartEngDur.IntegerDelay_Reset_ZCE_jb = POS_ZCSIG;

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_P1P2p5Func

    ESSR_ac_PrevZCX.StartEng_EM_Dur.IntegerDelay_Reset_ZCE_o = POS_ZCSIG;
    ESSR_ac_PrevZCX.ESSC_SpinUp_EM_Dur.IntegerDelay_Reset_ZCE_j = POS_ZCSIG;

#endif

#if Rte_SysCon_Variant_ESSR_BlueNexus && Rte_SysCon_Variant_ESSR_Func

    ESSR_ac_PrevZCX.ESSC_StartEngDur.Delay_Reset_ZCE_j = UNINITIALIZED_ZCSIG;
    ESSR_ac_PrevZCX.ESSC_StartEngDur.Delay1_Reset_ZCE_n = UNINITIALIZED_ZCSIG;

#elif !Rte_SysCon_Variant_ESSR_BlueNexus && !Rte_SysCon_Variant_ESSR_LQIR && Rte_SysCon_Variant_ESSR_Func

    ESSR_ac_PrevZCX.ESSC_StartEngDur.Delay_Reset_ZCE_k = UNINITIALIZED_ZCSIG;
    ESSR_ac_PrevZCX.ESSC_StartEngDur.Delay1_Reset_ZCE_c = UNINITIALIZED_ZCSIG;

#endif

#if Rte_SysCon_Variant_ESSR_Func && Rte_SysCon_Variant_ESSR_LQIR

    ESSR_ac_PrevZCX.ESSC_StartEngDur.Delay_Reset_ZCE = UNINITIALIZED_ZCSIG;
    ESSR_ac_PrevZCX.ESSC_StartEngDur.Delay1_Reset_ZCE = UNINITIALIZED_ZCSIG;

#endif

#if Rte_SysCon_Variant_ESSR_Func

    ESSR_ac_PrevZCX.SpinUp_CKS_Dur.IntegerDelay_Reset_ZCE_h = POS_ZCSIG;
    ESSR_ac_PrevZCX.SpinUp_CKS_Dur.IntegerDelay_Reset_ZCE_bi = POS_ZCSIG;
    ESSR_ac_PrevZCX.SpinUpEng_SFS_Dur.IntegerDelay_Reset_ZCE_p = POS_ZCSIG;
    ESSR_ac_PrevZCX.SpinUpEng_SFS_Dur.IntegerDelay_Reset_ZCE_i = POS_ZCSIG;
    ESSR_ac_PrevZCX.RestartPrepDur.IntegerDelay_Reset_ZCE_g = POS_ZCSIG;
    ESSR_ac_PrevZCX.ESSC_ImmedStopDur.IntegerDelay_Reset_ZCE_oe = POS_ZCSIG;

#endif

    /* SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/PwrOn' incorporates:
     *  SubSystem: '<Root>/ESSR_PwrOn'
     */
#if Rte_SysCon_Variant_ESSR_NF

    /* SystemInitialize for S-Function (fcgen): '<S6>/FcnCallGen' */
    /* SystemInitialize for Function Call SubSystem: '<S6>/Controller_Output' */
    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_e_EngStartStopSt' incorporates:
     *  Constant: '<S3279>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_EngS_d = ESSR_ac_ConstB.Constant_oe;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_e_EngStrtType' incorporates:
     *  Constant: '<S3280>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_EngS_i = ESSR_ac_ConstB.Constant_e1;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_e_EngStrtStpMd' incorporates:
     *  Constant: '<S3283>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_EngS_n = ESSR_ac_ConstB.Constant_o;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_b_InputTorqOverride' */
    ESSR_ac_B.OutportBufferForVeESSR_b_InputT = true;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_e_TransFldPmpCmd' incorporates:
     *  Constant: '<S3288>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_TransF = ESSR_ac_ConstB.Constant_m;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_scl_SpdCtlGainMod' */
    ESSR_ac_B.OutportBufferForVeESSR_scl_SpdC = 1.0F;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_e_EngTrqRespType' incorporates:
     *  Constant: '<S3287>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_EngTrq = ESSR_ac_ConstB.Constant_h;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_b_EngStrtStpActive' */
    ESSR_ac_B.OutportBufferForVeESSR_b_EngStr = true;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_e_EngCntrlMode' incorporates:
     *  Constant: '<S3286>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_EngCnt = ESSR_ac_ConstB.Constant;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_scl_AEMDMtrAGain' */
    ESSR_ac_B.OutportBufferForVeESSR_scl_AEMD = 1.0F;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_scl_AEMDMtrBGain' */
    ESSR_ac_B.OutportBufferForVeESSR_scl_AE_d = 1.0F;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_e_EngState_eTPUTgtSyncSt' incorporates:
     *  Constant: '<S3289>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_EngSta = ESSR_ac_ConstB.Constant_e;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_e_TCM_StartStopType' incorporates:
     *  Constant: '<S3290>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_TCM_St = ESSR_ac_ConstB.Constant_c;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_M_MtrA_MaxTorq' */
    ESSR_ac_B.OutportBufferForVeESSR_M_MtrA_M = 9999.0F;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_M_MtrA_MinTorq' */
    ESSR_ac_B.OutportBufferForVeESSR_M_MtrA_c = -9999.0F;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_n_NbTgt' */
    ESSR_ac_B.OutportBufferForVeESSR_n_NbTgt = 9999.0F;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_i_CalLoader' */
    ESSR_ac_B.OutportBufferForVeESSR_i_CalLoa = 1U;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_e_TCM_TransitionStatus' incorporates:
     *  Constant: '<S3285>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_TCM_Tr = ESSR_ac_ConstB.Constant_mv;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_M_MtrB_MaxTorq' */
    ESSR_ac_B.OutportBufferForVeESSR_M_MtrB_M = 9999.0F;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_M_MtrB_MinTorq' */
    ESSR_ac_B.OutportBufferForVeESSR_M_MtrB_d = -9999.0F;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_M_MtrC_MaxTorq' */
    ESSR_ac_B.OutportBufferForVeESSR_M_MtrC_M = 9999.0F;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_M_MtrC_MinTorq' */
    ESSR_ac_B.OutportBufferForVeESSR_M_MtrC_g = -9999.0F;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_b_EngStallReattmpAllwd' */
    ESSR_ac_B.OutportBufferForVeESSR_b_EngS_j = true;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_b_BkupStrtsAllwd' */
    ESSR_ac_B.OutportBufferForVeESSR_b_BkupSt = true;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_e_EngStrtProfType' incorporates:
     *  Constant: '<S3284>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_EngStr = ESSR_ac_ConstB.Constant_j;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_b_HCPFuelDisable' */
    ESSR_ac_B.OutportBufferForVeESSR_b_HCPFue = true;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_e_OptimdEngStrtStpType' incorporates:
     *  Constant: '<S3281>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_Optimd = ESSR_ac_ConstB.Constant_g;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_e_OptimdStrtReqdActr' incorporates:
     *  Constant: '<S3282>/Constant'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_Opti_a = ESSR_ac_ConstB.Constant_n;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_b_EngOffAllwdECM' */
    ESSR_ac_B.OutportBufferForVeESSR_b_EngOff = true;

    /* SystemInitialize for SignalConversion generated from: '<S3276>/VeESSR_e_HybEngSysActv_Out_Init' incorporates:
     *  Constant: '<S3276>/Const1'
     */
    ESSR_ac_B.OutportBufferForVeESSR_e_HybEng = ESSR_ac_ConstB.Const1;

    /* End of SystemInitialize for SubSystem: '<S6>/Controller_Output' */
    /* End of SystemInitialize for S-Function (fcgen): '<S6>/FcnCallGen' */
#endif

    /* End of SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/PwrOn' */

    /* SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/MedTEB' incorporates:
     *  SubSystem: '<Root>/ESSR_MedTEB'
     */
#if Rte_SysCon_Variant_ESSR_Func

    /* SystemInitialize for S-Function (fcgen): '<S2>/FcnCallGen' */

    /* SystemInitialize for Function Call SubSystem: '<S2>/ESSC_EngStartStopCtrl' */

    /* SystemInitialize for Chart: '<S13>/ESSC_EngStartStopSTM' incorporates:
     *  SubSystem: '<S175>/ESSC_ImmedStopDur'
     */
    ESSR_ac_ESSC_ImmedStopDur_Init(&ESSR_ac_DW.ESSC_ImmedStopDur);

    /* SystemInitialize for Chart: '<S13>/ESSC_EngStartStopSTM' incorporates:
     *  SubSystem: '<S561>/RestartPrepDur'
     */
    ESSR_ac_RestartPrepDur_Init(&ESSR_ac_DW.RestartPrepDur);

    /* SystemInitialize for Chart: '<S13>/ESSC_EngStartStopSTM' incorporates:
     *  SubSystem: '<S565>/SpinUpEng_SFS_Dur'
     */
    ESSR_ac_SpinUpEng_SFS_Dur_Init(&ESSR_ac_DW.SpinUpEng_SFS_Dur);

    /* SystemInitialize for Chart: '<S13>/ESSC_EngStartStopSTM' incorporates:
     *  SubSystem: '<S566>/SpinUp_CKS_Dur'
     */
    ESSR_ac_SpinUp_CKS_Dur_Init(&ESSR_ac_DW.SpinUp_CKS_Dur);

    /* SystemInitialize for Chart: '<S13>/ESSC_EngStartStopSTM' incorporates:
     *  SubSystem: '<S569>/ESSC_StartEngDur'
     */
    ESSR_ac_ESSC_StartEngDur_Init(&ESSR_ac_DW.ESSC_StartEngDur);

    /* SystemInitialize for Chart: '<S13>/ESSC_EngStartStopSTM' incorporates:
     *  SubSystem: '<S554>/ESSC_AchEngIdleDur'
     */
    ESSR_ac_ESSC_AchEngIdleDur_Init(&ESSR_ac_DW.ESSC_AchEngIdleDur);

    /* SystemInitialize for Chart: '<S13>/ESSC_EngStartStopSTM' incorporates:
     *  SubSystem: '<S555>/AchIdle_12vStrt_Du'
     */
    ESSR_ac_AchIdle_12vStrt_Du_Init(&ESSR_ac_DW.AchIdle_12vStrt_Du);

    /* SystemInitialize for Chart: '<S13>/ESSC_EngStartStopSTM' incorporates:
     *  SubSystem: '<S570>/StartEngPFS_Dur'
     */
    ESSR_ac_StartEngPFS_Dur_Init(&ESSR_ac_DW.StartEngPFS_Dur);

#if Rte_SysCon_Variant_ESSR_P1P2p5Func

    /* SystemInitialize for Function Call SubSystem: '<S568>/ESSC_SpinUp_EM_Dur' */
    ESSR_ac_ESSC_SpinUp_EM_Dur_Init(&ESSR_ac_DW.ESSC_SpinUp_EM_Dur);

    /* End of SystemInitialize for SubSystem: '<S568>/ESSC_SpinUp_EM_Dur' */

    /* SystemInitialize for Function Call SubSystem: '<S572>/StartEng_EM_Dur' */
    ESSR_ac_StartEng_EM_Dur_Init(&ESSR_ac_DW.StartEng_EM_Dur);

    /* End of SystemInitialize for SubSystem: '<S572>/StartEng_EM_Dur' */
#endif

    /* SystemInitialize for Chart: '<S13>/ESSC_EngStartStopSTM' incorporates:
     *  SubSystem: '<S2449>/PrepForStopDur'
     */
    ESSR_ac_PrepForStopDur_Init(&ESSR_ac_DW.PrepForStopDur);

    /* SystemInitialize for Chart: '<S13>/ESSC_EngStartStopSTM' incorporates:
     *  SubSystem: '<S2450>/ESSC_RampDownDur'
     */
    ESSR_ac_ESSC_RampDownDur_Init(&ESSR_ac_DW.ESSC_RampDownDur);

    /* End of SystemInitialize for SubSystem: '<S2>/ESSC_EngStartStopCtrl' */

    /* End of SystemInitialize for S-Function (fcgen): '<S2>/FcnCallGen' */
#endif

    /* End of SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/MedTEB' */

    /* SystemInitialize for Merge: '<Root>/Merge_1' incorporates:
     *  Merge: '<Root>/Merge_10'
     *  Merge: '<Root>/Merge_11'
     *  Merge: '<Root>/Merge_12'
     *  Merge: '<Root>/Merge_13'
     *  Merge: '<Root>/Merge_14'
     *  Merge: '<Root>/Merge_15'
     *  Merge: '<Root>/Merge_16'
     *  Merge: '<Root>/Merge_17'
     *  Merge: '<Root>/Merge_18'
     *  Merge: '<Root>/Merge_19'
     *  Merge: '<Root>/Merge_2'
     *  Merge: '<Root>/Merge_20'
     *  Merge: '<Root>/Merge_21'
     *  Merge: '<Root>/Merge_22'
     *  Merge: '<Root>/Merge_23'
     *  Merge: '<Root>/Merge_24'
     *  Merge: '<Root>/Merge_25'
     *  Merge: '<Root>/Merge_26'
     *  Merge: '<Root>/Merge_27'
     *  Merge: '<Root>/Merge_28'
     *  Merge: '<Root>/Merge_29'
     *  Merge: '<Root>/Merge_3'
     *  Merge: '<Root>/Merge_30'
     *  Merge: '<Root>/Merge_31'
     *  Merge: '<Root>/Merge_32'
     *  Merge: '<Root>/Merge_33'
     *  Merge: '<Root>/Merge_34'
     *  Merge: '<Root>/Merge_35'
     *  Merge: '<Root>/Merge_36'
     *  Merge: '<Root>/Merge_37'
     *  Merge: '<Root>/Merge_38'
     *  Merge: '<Root>/Merge_39'
     *  Merge: '<Root>/Merge_4'
     *  Merge: '<Root>/Merge_40'
     *  Merge: '<Root>/Merge_41'
     *  Merge: '<Root>/Merge_42'
     *  Merge: '<Root>/Merge_43'
     *  Merge: '<Root>/Merge_44'
     *  Merge: '<Root>/Merge_45'
     *  Merge: '<Root>/Merge_5'
     *  Merge: '<Root>/Merge_56'
     *  Merge: '<Root>/Merge_6'
     *  Merge: '<Root>/Merge_67'
     *  Merge: '<Root>/Merge_7'
     *  Merge: '<Root>/Merge_76'
     *  Merge: '<Root>/Merge_77'
     *  Merge: '<Root>/Merge_8'
     *  Merge: '<Root>/Merge_9'
     */
#if Rte_SysCon_Variant_ESSR_Func || Rte_SysCon_Variant_ESSR_NF

    /* SystemInitialize for Outport: '<Root>/VeESSR_e_EngStartStopSt' */
    (void)Rte_Write_VeESSR_e_EngStartStopSt_Value(CeESSR_e_EngOff);

    /* SystemInitialize for Outport: '<Root>/VeESSR_e_EngStrtType' */
    (void)Rte_Write_VeESSR_e_EngStrtType_Value(CeESSR_e_NoStrt);

    /* SystemInitialize for Outport: '<Root>/VeESSR_e_EngStrtStpMd' */
    (void)Rte_Write_VeESSR_e_EngStrtStpMd_Value(CeESSR_e_Stop);

    /* SystemInitialize for Outport: '<Root>/VeESSR_e_TransFldPmpCmd' */
    (void)Rte_Write_VeESSR_e_TransFldPmpCmd_Value(CeESSR_e_Normal);

    /* SystemInitialize for Outport: '<Root>/VeESSR_e_EngTrqRespType' */
    (void)Rte_Write_VeESSR_e_EngTrqRespType_Value(CePTAR_e_Inactive);

    /* SystemInitialize for Outport: '<Root>/VeESSR_e_EngCntrlMode' */
    (void)Rte_Write_VeESSR_e_EngCntrlMode_Value(CeTRAR_e_TorqueMode);

    /* SystemInitialize for Outport: '<Root>/VeESSR_e_EngState_eTPUTgtSyncSt' */
    (void)Rte_Write_VeESSR_e_EngState_eTPUTgtSyncSt_Value(CeESSR_e_Stopped);

    /* SystemInitialize for Outport: '<Root>/VeESSR_e_TCM_StartStopType' */
    (void)Rte_Write_VeESSR_e_TCM_StartStopType_Value(CeESSR_e_NoAction);

    /* SystemInitialize for Outport: '<Root>/VeESSR_e_TCM_TransitionStatus' */
    (void)Rte_Write_VeESSR_e_TCM_TransitionStatus_Value(CeESSR_e_Trans_Stat_Off);

#endif

    /* End of SystemInitialize for Merge: '<Root>/Merge_1' */
#if Rte_SysCon_Variant_ESSR_Func
#endif

    /* SystemInitialize for Merge: '<Root>/Merge_60' incorporates:
     *  Merge: '<Root>/Merge_46'
     *  Merge: '<Root>/Merge_47'
     *  Merge: '<Root>/Merge_48'
     *  Merge: '<Root>/Merge_49'
     *  Merge: '<Root>/Merge_50'
     *  Merge: '<Root>/Merge_51'
     *  Merge: '<Root>/Merge_52'
     *  Merge: '<Root>/Merge_53'
     *  Merge: '<Root>/Merge_54'
     *  Merge: '<Root>/Merge_55'
     *  Merge: '<Root>/Merge_57'
     *  Merge: '<Root>/Merge_58'
     *  Merge: '<Root>/Merge_59'
     *  Merge: '<Root>/Merge_61'
     *  Merge: '<Root>/Merge_62'
     *  Merge: '<Root>/Merge_63'
     *  Merge: '<Root>/Merge_64'
     *  Merge: '<Root>/Merge_65'
     *  Merge: '<Root>/Merge_66'
     *  Merge: '<Root>/Merge_68'
     *  Merge: '<Root>/Merge_69'
     *  Merge: '<Root>/Merge_70'
     *  Merge: '<Root>/Merge_71'
     *  Merge: '<Root>/Merge_72'
     *  Merge: '<Root>/Merge_73'
     *  Merge: '<Root>/Merge_74'
     *  Merge: '<Root>/Merge_75'
     *  Merge: '<Root>/Merge_78'
     *  Merge: '<Root>/Merge_79'
     *  Merge: '<Root>/Merge_80'
     */
#if Rte_SysCon_Variant_ESSR_Func || Rte_SysCon_Variant_ESSR_NF

    /* SystemInitialize for Outport: '<Root>/VeESSR_e_HybEngSysActv' */
    (void)Rte_Write_VeESSR_e_HybEngSysActv_Value(CeESSR_e_HybEngDisabled);

    /* SystemInitialize for Outport: '<Root>/VeESSR_e_EngStrtProfType' */
    (void)Rte_Write_VeESSR_e_EngStrtProfType_Value(CeESSR_e_NoStart);

    /* SystemInitialize for Outport: '<Root>/VeESSR_e_OptimdEngStrtStpType' */
    (void)Rte_Write_VeESSR_e_OptimdEngStrtStpType_Value(CeESSR_e_NoStrt);

    /* SystemInitialize for Outport: '<Root>/VeESSR_e_OptimdStrtReqdActr' */
    (void)Rte_Write_VeESSR_e_OptimdStrtReqdActr_Value(CeESSR_e_NoActTyp);

#endif

    /* End of SystemInitialize for Merge: '<Root>/Merge_60' */

    /* Enable for RootInportFunctionCallGenerator generated from: '<Root>/MedTEB' incorporates:
     *  SubSystem: '<Root>/ESSR_MedTEB'
     */
#if Rte_SysCon_Variant_ESSR_Func

    /* SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/MedTED' */
    /* Enable for S-Function (fcgen): '<S2>/FcnCallGen' */
    /* SystemInitialize for Function Call SubSystem: '<Root>/ESSR_MedTED' */

    /* SystemInitialize for SignalConversion generated from: '<S3>/VeESSR_M_EngCapacityMinRunImmed_write' */
    Rte_IrvWrite_ESSR_ac_Init_VeESSR_M_EngCapacityMinRunImmed_write_IRV
        (VeESSR_M_EngCapacityMinRunImmed);

    /* SystemInitialize for SignalConversion generated from: '<S3>/VeESSR_M_EngineLosses_write' */
    Rte_IrvWrite_ESSR_ac_Init_VeESSR_M_EngineLosses_write_IRV(ESSR_ac_B.Sum3);

    /* SystemInitialize for SignalConversion generated from: '<S3>/VeESSR_M_MaxSparkAuthority_write' */
    Rte_IrvWrite_ESSR_ac_Init_VeESSR_M_MaxSparkAuthority_write_IRV
        (ESSR_ac_B.MinMax);

    /* SystemInitialize for SignalConversion generated from: '<S3>/VeESSR_M_OptEngTrqReqPred_write' */
    Rte_IrvWrite_ESSR_ac_Init_VeESSR_M_OptEngTrqReqPred_write_IRV
        (ESSR_ac_B.SignalConversion);

    /* SystemInitialize for SignalConversion generated from: '<S3>/VeESSR_M_OptEngTrqReq_write' */
    Rte_IrvWrite_ESSR_ac_Init_VeESSR_M_OptEngTrqReq_write_IRV
        (VeESSR_M_OptEngTrqReq);

    /* End of SystemInitialize for SubSystem: '<Root>/ESSR_MedTED' */

    /* End of Enable for S-Function (fcgen): '<S2>/FcnCallGen' */
#endif

    /* End of SystemInitialize for RootInportFunctionCallGenerator generated from: '<Root>/MedTED' */
    /* End of Enable for RootInportFunctionCallGenerator generated from: '<Root>/MedTEB' */
}

/*
 * File trailer for generated code.
 *
 * [EOF]
 */
